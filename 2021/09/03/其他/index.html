<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>其他 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/09/03/%E5%85%B6%E4%BB%96/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="其他"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言一些零散的笔记，XML的读写、JSON的读写、JDBC、GUI。"><meta name="og:description" content="引言一些零散的笔记，XML的读写、JSON的读写、JDBC、GUI。"><meta property="og:url" content="/2021/09/03/%E5%85%B6%E4%BB%96/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-09-03"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="其他"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">其他</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/09/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 34317 字，约 99 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>一些零散的笔记，XML的读写、JSON的读写、JDBC、GUI。</p><h1 id="xml">XML</h1><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><p>例如，一个描述书籍的XML文档可能如下：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="cp">&lt;!DOCTYPE note SYSTEM "book.dtd"&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p>XML有几个特点：一是纯文本，默认使用UTF-8编码，二是可嵌套，适合表示结构化数据。如果把XML内容存为文件，那么它就是一个XML文件，例如<code class="language-plaintext highlighter-rouge">book.xml</code>。此外，XML内容经常通过网络作为消息传输。</p><p>XML有固定的结构，首行必定是<code class="language-plaintext highlighter-rouge">&lt;?xml version="1.0"?&gt;</code>，可以加上可选的编码。紧接着，如果以类似<code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE note SYSTEM "book.dtd"&gt;</code>声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。接下来是XML的文档内容，一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，<code class="language-plaintext highlighter-rouge">&lt;isbn lang="CN"&gt;1234567&lt;/isbn&gt;</code>包含一个属性<code class="language-plaintext highlighter-rouge">lang="CN"</code>，且元素必须正确嵌套。如果是空元素，可以用<code class="language-plaintext highlighter-rouge">&lt;tag/&gt;</code>表示。</p><p>由于使用了<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;</code>以及引号等标识符，如果内容出现了特殊符号，需要使用<code class="language-plaintext highlighter-rouge">&amp;???;</code>表示转义。例如，<code class="language-plaintext highlighter-rouge">Java&lt;tm&gt;</code>必须写成：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;name&gt;Java&amp;lt;tm&amp;gt;&lt;/name&gt;
</code></pre></div></div><p>常见的特殊字符如下：</p><table><thead><tr><th style="text-align: left">字符</th><th style="text-align: left">表示</th></tr></thead><tbody><tr><td style="text-align: left">&lt;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;lt;</code></td></tr><tr><td style="text-align: left">&gt;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;gt;</code></td></tr><tr><td style="text-align: left">&amp;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;amp;</code></td></tr><tr><td style="text-align: left">”</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;quot;</code></td></tr><tr><td style="text-align: left">’</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;apos;</code></td></tr></tbody></table><p>格式正确的XML（Well Formed）可以被解析器正常读取。而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证。</p><p>DTD文档可以指定一系列规则，例如：</p><ul><li>根元素必须是<code class="language-plaintext highlighter-rouge">book</code></li><li><code class="language-plaintext highlighter-rouge">book</code>元素必须包含<code class="language-plaintext highlighter-rouge">name</code>，<code class="language-plaintext highlighter-rouge">author</code>等指定元素</li><li><code class="language-plaintext highlighter-rouge">isbn</code>元素必须包含属性<code class="language-plaintext highlighter-rouge">lang</code></li><li>…</li></ul><p>如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。</p><p>和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。</p><p>XML是一个技术体系，除了经常用到的XML文档本身外，XML还支持：</p><ul><li>DTD和XSD：验证XML结构和数据是否有效；</li><li>Namespace：XML节点和属性的名字空间；</li><li>XSLT：把XML转化为另一种文本；</li><li>XPath：一种XML节点查询语言；</li><li>…</li></ul><p>因为XML是一种树形结构的文档，它有两种标准的解析API：</p><ul><li>DOM：一次性读取XML，并在内存中表示为树形结构；</li><li>SAX：以流的形式读取XML，使用事件回调。</li></ul><h2 id="使用dom解析">使用DOM解析</h2><p>DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个树形结构处理，从根节点开始，每个节点都可以包含任意个子节点。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">document</code>代表XML文档，是真正的“根”，而<code class="language-plaintext highlighter-rouge">&lt;book&gt;</code>虽然是根元素，但它是<code class="language-plaintext highlighter-rouge">document</code>的一个子节点。</p><p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p><ul><li>Document：代表整个XML文档；</li><li>Element：代表一个XML元素；</li><li>Attribute：代表一个元素的某个属性。</li></ul><p>使用DOM解析一个XML文档的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.Document</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.NamedNodeMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.Node</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.NodeList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.xml.sax.SAXException</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.xml.parsers.DocumentBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.parsers.DocumentBuilderFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.parsers.ParserConfigurationException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">SAXException</span><span class="o">,</span> <span class="nc">ParserConfigurationException</span> <span class="o">{</span>
        <span class="c1">// 从文件、网络流或其他来源获取 XML 输入流</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
        <span class="nc">DocumentBuilderFactory</span> <span class="n">dbf</span> <span class="o">=</span> <span class="nc">DocumentBuilderFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="nc">DocumentBuilder</span> <span class="n">db</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="na">newDocumentBuilder</span><span class="o">();</span>
        <span class="c1">// 使用 DocumentBuilder 解析输入流，获取 Document 实例</span>
        <span class="nc">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="n">printNode</span><span class="o">(</span><span class="n">doc</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">printNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">DOCUMENT_NODE</span><span class="o">:</span> <span class="c1">// Document节点</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Document: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">ELEMENT_NODE</span><span class="o">:</span> <span class="c1">// 元素节点</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Element: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">TEXT_NODE</span><span class="o">:</span> <span class="c1">// 文本</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">matches</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">)){</span><span class="c1">//为空则无视</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Text = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">ATTRIBUTE_NODE</span><span class="o">:</span> <span class="c1">// 属性</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Attr: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">CDATA_SECTION_NODE</span><span class="o">:</span><span class="c1">// 非解析文本</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span> <span class="s">"CDATA: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">trim</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">COMMENT_NODE</span><span class="o">:</span><span class="c1">// 注释</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span> <span class="s">"Comment: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">trim</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span> <span class="c1">// 其他</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"NodeType: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">()</span> <span class="o">+</span> <span class="s">", NodeName: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">hasAttributes</span><span class="o">())</span> <span class="o">{</span><span class="c1">//有属性则递归</span>
            <span class="nc">NamedNodeMap</span> <span class="n">as</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">getAttributes</span><span class="o">();</span><span class="c1">// 获取标签内所有属性</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">as</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">printNode</span><span class="o">(</span><span class="n">as</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">indent</span><span class="o">+</span><span class="mi">2</span><span class="o">);</span><span class="c1">// 递归</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">hasChildNodes</span><span class="o">())</span> <span class="o">{</span><span class="c1">//有子节点则递归</span>
            <span class="nc">NodeList</span> <span class="n">childNodes</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childNodes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">printNode</span><span class="o">(</span><span class="n">childNodes</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">indent</span><span class="o">+</span><span class="mi">2</span><span class="o">);</span><span class="c1">// 递归</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getRetraction</span><span class="o">(</span><span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">s</span><span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indent</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DocumentBuilder.parse()</code>用于解析一个XML，它可以接收<code class="language-plaintext highlighter-rouge">InputStream</code>，<code class="language-plaintext highlighter-rouge">File</code>或者<code class="language-plaintext highlighter-rouge">URL</code>，如果解析无误，将获得一个<code class="language-plaintext highlighter-rouge">Document</code>对象，这个对象代表了整个<code class="language-plaintext highlighter-rouge">XML</code>文档的树形结构。</p><p>从根节点<code class="language-plaintext highlighter-rouge">Document</code>出发，可以遍历所有子节点，获取所有元素、属性、文本数据，还可以包括注释，这些节点被统称为<code class="language-plaintext highlighter-rouge">Node</code>，每个<code class="language-plaintext highlighter-rouge">Node</code>都有自己的<code class="language-plaintext highlighter-rouge">Type</code>，根据<code class="language-plaintext highlighter-rouge">Type</code>来区分一个<code class="language-plaintext highlighter-rouge">Node</code>到底是元素，还是属性，还是文本，等等。</p><p>使用DOM API时，如果要读取某个元素的文本，需要访问它的Text类型的子节点，所以使用起来还是比较繁琐的，且DOM解析速度慢，内存占用大。</p><hr /><p><code class="language-plaintext highlighter-rouge">org.w3c.dom.Document</code> 接口表示整个 XML 文档，它是 DOM（Document Object Model） API 的核心接口之一。<code class="language-plaintext highlighter-rouge">Document</code> 对象提供了操作 XML 文档的方法，允许您访问和修改文档中的元素、属性和文本内容等。<code class="language-plaintext highlighter-rouge">Document</code> 接口定义了一些独有的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">Element getDocumentElement()</code>: 返回文档的根元素。</li><li><code class="language-plaintext highlighter-rouge">Element createElement(String tagName)</code>: 创建具有指定标签名称的新元素。</li><li><code class="language-plaintext highlighter-rouge">Text createTextNode(String data)</code>: 创建包含指定数据的新文本节点。</li><li><code class="language-plaintext highlighter-rouge">Attr createAttribute(String name)</code>: 创建具有指定名称的新属性节点。</li><li><code class="language-plaintext highlighter-rouge">Element getElementById(String elementId)</code>: 返回具有指定 ID 的元素。</li><li><code class="language-plaintext highlighter-rouge">Element createElementNS(String namespaceURI, String qualifiedName)</code>: 使用指定的命名空间URI和限定名称创建新元素。</li><li><code class="language-plaintext highlighter-rouge">Attr createAttributeNS(String namespaceURI, String qualifiedName)</code>: 使用指定的命名空间URI和限定名称创建新属性。</li><li><code class="language-plaintext highlighter-rouge">Node importNode(Node importedNode, boolean deep)</code>: 将节点从另一个文档导入到当前文档。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">org.w3c.dom.Node</code> 接口表示 DOM（Document Object Model）树中的一个节点，它是 DOM API 的核心接口之一。<code class="language-plaintext highlighter-rouge">Node</code> 接口定义了节点的通用属性和方法，所有 DOM 节点类型都实现了该接口，包括元素节点、文本节点、注释节点等。<code class="language-plaintext highlighter-rouge">Node</code> 接口的主要作用是：</p><ol><li><strong>表示 DOM 树中的一个节点：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口表示 DOM 树中的一个节点，每个节点可以是一个元素、属性、文本内容、注释等。</li><li><strong>提供访问节点的方法：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了一系列方法，用于访问和操作节点的属性、子节点和父节点等。</li><li><strong>定义节点类型：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口定义了表示不同类型节点的常量，如 <code class="language-plaintext highlighter-rouge">ELEMENT_NODE</code>、<code class="language-plaintext highlighter-rouge">TEXT_NODE</code>、<code class="language-plaintext highlighter-rouge">COMMENT_NODE</code> 等。</li><li><strong>节点关系：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了方法来获取节点的父节点、子节点、兄弟节点等关系信息。</li><li><strong>节点操作：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了方法来添加、移除、替换节点，以及克隆节点等操作。</li></ol><p>以下是一些常用的 <code class="language-plaintext highlighter-rouge">Node</code> 接口方法：</p><ol><li><strong>获取节点信息：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">String getNodeName()</code>: 返回节点的名称。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getNodeValue()</code>: 返回节点的值（仅适用于特定类型的节点，如文本节点）。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">short getNodeType()</code>: 返回节点的类型（例如，元素节点、文本节点等）。</strong></li></ul></li><li><strong>获取父节点和子节点：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node getParentNode()</code>: 返回父节点。</li><li><strong><code class="language-plaintext highlighter-rouge">NodeList getChildNodes()</code>: 返回子节点列表。</strong></li><li><code class="language-plaintext highlighter-rouge">Node getFirstChild()</code>: 返回第一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node getLastChild()</code>: 返回最后一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node getNextSibling()</code>: 返回下一个兄弟节点。</li><li><code class="language-plaintext highlighter-rouge">Node getPreviousSibling()</code>: 返回上一个兄弟节点。</li></ul></li><li><strong>操作节点：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node appendChild(Node newChild)</code>: 将节点添加为最后一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node removeChild(Node oldChild)</code>: 从子节点列表中删除指定的子节点。</li><li><code class="language-plaintext highlighter-rouge">Node replaceChild(Node newChild, Node oldChild)</code>: 用新节点替换指定的子节点。</li></ul></li><li><strong>判断节点关系：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">boolean hasChildNodes()</code>: 判断节点是否有子节点。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">boolean hasAttributes()</code>：判断节点是否有属性。</strong></li><li><code class="language-plaintext highlighter-rouge">boolean isSameNode(Node other)</code>: 判断节点是否与另一个节点相同。</li></ul></li><li><strong>其他方法：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node cloneNode(boolean deep)</code>: 复制节点（如果 <code class="language-plaintext highlighter-rouge">deep</code> 为 true，则同时复制子树）。</li><li><code class="language-plaintext highlighter-rouge">Document getOwnerDocument()</code>: 返回拥有当前节点的文档节点。</li></ul></li><li><strong>获取属性节点：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">NamedNodeMap getAttributes()</code>: 返回包含节点所有属性的 <code class="language-plaintext highlighter-rouge">NamedNodeMap</code> 对象。</strong></li></ul></li><li><strong>获取特定属性：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node getAttributeNode(String name)</code>: 返回具有指定名称的属性节点。</li><li><code class="language-plaintext highlighter-rouge">String getAttribute(String name)</code>: 返回具有指定名称的属性的值。</li></ul></li><li><strong>添加和移除属性：</strong><ul><li><code class="language-plaintext highlighter-rouge">void setAttribute(String name, String value)</code>: 设置具有指定名称和值的属性。如果属性已存在，则替换旧值。</li><li><code class="language-plaintext highlighter-rouge">void removeAttribute(String name)</code>: 删除具有指定名称的属性。</li></ul></li><li><strong>判断属性是否存在：</strong><ul><li><code class="language-plaintext highlighter-rouge">boolean hasAttribute(String name)</code>: 判断节点是否具有指定名称的属性。</li></ul></li></ol><p>在 DOM（文档对象模型）中，不同类型的节点用不同的常量值表示，以便于区分节点的类型。这些常量由 <code class="language-plaintext highlighter-rouge">Node</code> 接口定义，可以通过 <code class="language-plaintext highlighter-rouge">Node</code> 接口的静态常量来访问。常见的节点类型包括：</p><ul><li><code class="language-plaintext highlighter-rouge">Node.ELEMENT_NODE</code>：表示元素节点。</li><li><code class="language-plaintext highlighter-rouge">Node.ATTRIBUTE_NODE</code>：表示属性节点。</li><li><code class="language-plaintext highlighter-rouge">Node.TEXT_NODE</code>：表示文本节点。</li><li><code class="language-plaintext highlighter-rouge">Node.COMMENT_NODE</code>：表示注释节点。</li><li><code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code>：表示文档节点。</li></ul><p><code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code> 表示整个文档的根节点，即文档对象（Document Object）。在 DOM 中，文档对象是整个 XML 或 HTML 文档的入口点，通过文档对象可以访问文档的所有内容，包括元素、属性、文本等。通常，使用 <code class="language-plaintext highlighter-rouge">Document</code> 类型的实例表示文档对象。</p><p>例如，可以通过以下方式检查一个节点是否为文档节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="o">...;</span> <span class="c1">// 获取一个节点</span>
<span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Node</span><span class="o">.</span><span class="na">DOCUMENT_NODE</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这是一个文档节点</span>
    <span class="nc">Document</span> <span class="n">document</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Document</span><span class="o">)</span> <span class="n">node</span><span class="o">;</span>
    <span class="c1">// 可以对文档进行操作</span>
<span class="o">}</span>
</code></pre></div></div><p>通过比较节点的类型是否为 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code>，可以判断节点是否为文档节点，从而进行相应的操作。</p><p>如果对<code class="language-plaintext highlighter-rouge">Document</code>进行了修改，要保存，则可以将修改后的内容保存到文件或其他输出流中。保存 <code class="language-plaintext highlighter-rouge">Document</code> 的常用方法是将其转换为字符串形式，然后将字符串写入文件或输出流中。</p><p>下面是一个简单的示例，演示了如何将修改后的 <code class="language-plaintext highlighter-rouge">Document</code> 保存到文件中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从文件、网络流或其他来源获取 XML 输入流</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">DocumentBuilderFactory</span> <span class="n">dbf</span> <span class="o">=</span> <span class="nc">DocumentBuilderFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">DocumentBuilder</span> <span class="n">db</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="na">newDocumentBuilder</span><span class="o">();</span>
<span class="c1">// 使用 DocumentBuilder 解析输入流，获取 Document 实例</span>
<span class="nc">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="c1">// 创建一个 Transformer 对象</span>
<span class="nc">Transformer</span> <span class="n">transformer</span> <span class="o">=</span> <span class="nc">TransformerFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">().</span><span class="na">newTransformer</span><span class="o">();</span>
<span class="nc">DOMSource</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DOMSource</span><span class="o">(</span><span class="n">doc</span><span class="o">);</span>
<span class="c1">// 将字符串写入文件中</span>
<span class="nc">StreamResult</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StreamResult</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"1.xml"</span><span class="o">));</span>
<span class="c1">// 使用 Transformer 将 Document 转换为字符串形式</span>
<span class="n">transformer</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</code></pre></div></div><h2 id="使用sax解析">使用SAX解析</h2><p>使用DOM解析XML的优点是用起来省事，但它的主要缺点是内存占用太大。</p><p>另一种解析XML的方式是SAX。SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p><p>SAX解析会触发一系列事件：</p><ul><li>startDocument：开始读取XML文档；</li><li>startElement：读取到了一个元素，例如<code class="language-plaintext highlighter-rouge">&lt;book&gt;</code>；</li><li>characters：读取到了字符；</li><li>endElement：读取到了一个结束的元素，例如<code class="language-plaintext highlighter-rouge">&lt;/book&gt;</code>；</li><li>endDocument：读取XML文档结束。</li></ul><p>如果用SAX API解析XML，Java代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">SAXParserFactory</span> <span class="n">spf</span> <span class="o">=</span> <span class="nc">SAXParserFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">SAXParser</span> <span class="n">saxParser</span> <span class="o">=</span> <span class="n">spf</span><span class="o">.</span><span class="na">newSAXParser</span><span class="o">();</span>
<span class="n">saxParser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MyHandler</span><span class="o">());</span>
</code></pre></div></div><p>关键代码<code class="language-plaintext highlighter-rouge">SAXParser.parse()</code>除了需要传入一个<code class="language-plaintext highlighter-rouge">InputStream</code>外，还需要传入一个回调对象，这个对象要继承自<code class="language-plaintext highlighter-rouge">DefaultHandler</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyHandler</span> <span class="kd">extends</span> <span class="nc">DefaultHandler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startDocument</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文档开始"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endDocument</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文档结束"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startElement</span><span class="o">(</span><span class="nc">String</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">String</span> <span class="n">localName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">qName</span><span class="o">,</span> <span class="nc">Attributes</span> <span class="n">attributes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"元素："</span><span class="o">,</span> <span class="n">localName</span><span class="o">,</span> <span class="n">qName</span><span class="o">);</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"属性:"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attributes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="s">"  "</span><span class="o">,</span><span class="n">attributes</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="s">"="</span><span class="o">,</span><span class="n">attributes</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endElement</span><span class="o">(</span><span class="nc">String</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">String</span> <span class="n">localName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">qName</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"元素结束:"</span><span class="o">,</span> <span class="n">localName</span><span class="o">,</span> <span class="n">qName</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">characters</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文本:"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">ch</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">length</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">error</span><span class="o">(</span><span class="nc">SAXParseException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"错误:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果要读取<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>节点的文本，我们就必须在解析过程中根据<code class="language-plaintext highlighter-rouge">startElement()</code>和<code class="language-plaintext highlighter-rouge">endElement()</code>定位当前正在读取的节点，可以使用栈结构保存，每遇到一个<code class="language-plaintext highlighter-rouge">startElement()</code>入栈，每遇到一个<code class="language-plaintext highlighter-rouge">endElement()</code>出栈，这样，读到<code class="language-plaintext highlighter-rouge">characters()</code>时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。</p><p>SAX是一种流式解析XML的API；SAX通过事件触发，读取速度快，消耗内存少；调用方必须通过回调方法获得解析过程中的数据。</p><hr /><p>要创建 <code class="language-plaintext highlighter-rouge">SAXParser</code> 对象，通常使用 <code class="language-plaintext highlighter-rouge">SAXParserFactory</code> 工厂类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建 SAXParserFactory 实例</span>
<span class="nc">SAXParserFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">SAXParserFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// 指定是否验证 XML 文件，默认为 false</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setValidating</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 指定是否命名空间感知，默认为 false</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setNamespaceAware</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 创建 SAXParser 实例</span>
<span class="nc">SAXParser</span> <span class="n">saxParser</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newSAXParser</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">SAXParser</code> 类是用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档的类，它实现了 <code class="language-plaintext highlighter-rouge">XMLReader</code> 接口，提供了一系列方法来解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档。以下是 <code class="language-plaintext highlighter-rouge">SAXParser</code> 类的一些常用方法：</p><ul><li><code class="language-plaintext highlighter-rouge">parse(InputSource input, DefaultHandler handler)</code>：解析给定的输入源并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><strong><code class="language-plaintext highlighter-rouge">parse(InputStream is, DefaultHandler dh)</code>：解析给定的输入流并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</strong></li><li><code class="language-plaintext highlighter-rouge">parse(File f, DefaultHandler dh)</code>：解析给定的文件并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><code class="language-plaintext highlighter-rouge">parse(String uri, DefaultHandler dh)</code>：解析给定的 <code class="language-plaintext highlighter-rouge">URI</code> 并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><code class="language-plaintext highlighter-rouge">setContentHandler(ContentHandler handler)</code>：设置内容处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的内容。</li><li><code class="language-plaintext highlighter-rouge">setDTDHandler(DTDHandler handler)</code>：设置 <code class="language-plaintext highlighter-rouge">DTD</code> 处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的 <code class="language-plaintext highlighter-rouge">DTD</code> 声明。</li><li><code class="language-plaintext highlighter-rouge">setEntityResolver(EntityResolver resolver)</code>：设置实体解析器，用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的实体。</li><li><code class="language-plaintext highlighter-rouge">setErrorHandler(ErrorHandler handler)</code>：设置错误处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 解析过程中的错误。</li><li><code class="language-plaintext highlighter-rouge">getXMLReader()</code>：获取与此 <code class="language-plaintext highlighter-rouge">SAXParser</code> 关联的 <code class="language-plaintext highlighter-rouge">XMLReader</code> 对象，用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档。</li><li><code class="language-plaintext highlighter-rouge">getSchema()</code>：获取当前为 <code class="language-plaintext highlighter-rouge">SAXParser</code> 设置的 <code class="language-plaintext highlighter-rouge">XML Schema</code>。</li><li><code class="language-plaintext highlighter-rouge">isNamespaceAware()</code>：返回解析器是否为命名空间感知的布尔值。</li><li><code class="language-plaintext highlighter-rouge">isValidating()</code>：返回解析器是否验证 <code class="language-plaintext highlighter-rouge">XML</code> 内容的布尔值。</li></ul><p>这些方法用于配置和操作 <code class="language-plaintext highlighter-rouge">SAXParser</code> 实例，以便解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档并处理其内容。</p><p><code class="language-plaintext highlighter-rouge">DefaultHandler</code> 是 <code class="language-plaintext highlighter-rouge">SAX</code> 解析器的默认处理程序，它实现了 <code class="language-plaintext highlighter-rouge">ContentHandler</code>、<code class="language-plaintext highlighter-rouge">DTDHandler</code>、<code class="language-plaintext highlighter-rouge">EntityResolver</code> 和 <code class="language-plaintext highlighter-rouge">ErrorHandler</code> 接口。这些接口定义了处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容和解析过程中可能出现的各种情况的方法。以下是 <code class="language-plaintext highlighter-rouge">DefaultHandler</code> 中一些重要的方法和作用：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">startDocument()</code>：在解析文档开始时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">endDocument()</code>：在解析文档结束时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">startElement(String uri, String localName, String qName, Attributes attributes)</code>：在解析元素开始时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">endElement(String uri, String localName, String qName)</code>：在解析元素结束时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">characters(char[] ch, int start, int length)</code>：在解析字符数据时调用。</strong></li><li><code class="language-plaintext highlighter-rouge">startPrefixMapping(String prefix, String uri)</code>：在解析命名空间前缀映射时调用。</li><li><code class="language-plaintext highlighter-rouge">endPrefixMapping(String prefix)</code>：在解析命名空间前缀映射结束时调用。</li><li><code class="language-plaintext highlighter-rouge">processingInstruction(String target, String data)</code>：在解析处理指令时调用。</li><li><code class="language-plaintext highlighter-rouge">skippedEntity(String name)</code>：在解析实体时调用。</li><li><code class="language-plaintext highlighter-rouge">warning(SAXParseException e)</code>：在解析过程中遇到警告时调用。</li><li><strong><code class="language-plaintext highlighter-rouge">error(SAXParseException e)</code>：在解析过程中遇到可恢复错误时调用。</strong></li><li><code class="language-plaintext highlighter-rouge">fatalError(SAXParseException e)</code>：在解析过程中遇到致命错误时调用。</li></ul><p><code class="language-plaintext highlighter-rouge">DefaultHandler</code> 的作用是提供这些方法的默认实现，可以根据需要覆盖这些方法来处理 <code class="language-plaintext highlighter-rouge">XML</code> 解析过程中的事件。通常，可以创建一个继承自 <code class="language-plaintext highlighter-rouge">DefaultHandler</code> 的类，并重写其中的方法来实现自定义的 <code class="language-plaintext highlighter-rouge">XML</code> 处理逻辑。</p><p><code class="language-plaintext highlighter-rouge">SAXParser</code> 本身并不能直接修改 <code class="language-plaintext highlighter-rouge">XML</code>，因为 <code class="language-plaintext highlighter-rouge">SAXParser</code> 是一种流式解析器，它按顺序读取 <code class="language-plaintext highlighter-rouge">XML</code> 文件并触发相应的事件，而不会将整个 <code class="language-plaintext highlighter-rouge">XML</code> 文档加载到内存中。因此，如果需要修改 <code class="language-plaintext highlighter-rouge">XML</code>，通常需要借助其他 <code class="language-plaintext highlighter-rouge">API</code> 或方法来实现。</p><h2 id="使用stax解析">使用StAX解析</h2><p>StAX（Streaming API for XML）是用于处理 XML 的一种流式处理 API。与传统的 DOM（Document Object Model）和 SAX（Simple API for XML）相比，StAX 提供了一种更灵活的方式来读取和写入 XML 数据。</p><p>使用 StAX，可以逐个事件地处理 XML 文档，而不需要将整个文档加载到内存中（像 DOM 那样），也不需要像 SAX 那样完全依赖事件回调模型。相反，StAX 允许以迭代器的方式逐个读取或写入 XML 元素，使得处理 XML 数据变得更加简单和高效。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">XMLInputFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">XMLInputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">XMLStreamReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createXMLStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>

<span class="k">while</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">START_ELEMENT</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"元素： "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">());</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  Attribute: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">CHARACTERS</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">reader</span><span class="o">.</span><span class="na">isWhiteSpace</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文本: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">END_ELEMENT</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"元素结束: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">());</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>要使用 StAX 修改 XML，需要创建一个 <code class="language-plaintext highlighter-rouge">XMLInputFactory</code> 来读取 XML 文件，并创建一个 <code class="language-plaintext highlighter-rouge">XMLOutputFactory</code> 来写入修改后的 XML。示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 创建输入和输出的 XML 工厂</span>
<span class="nc">XMLInputFactory</span> <span class="n">inputFactory</span> <span class="o">=</span> <span class="nc">XMLInputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">XMLOutputFactory</span> <span class="n">outputFactory</span> <span class="o">=</span> <span class="nc">XMLOutputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

<span class="c1">// 创建 XML 输入和输出流</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"book2.xml"</span><span class="o">);</span>
<span class="nc">XMLStreamReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">inputFactory</span><span class="o">.</span><span class="na">createXMLStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">XMLStreamWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">outputFactory</span><span class="o">.</span><span class="na">createXMLStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
<span class="n">writer</span><span class="o">.</span><span class="na">writeStartDocument</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">,</span> <span class="s">"1.0"</span><span class="o">);</span> <span class="c1">// 写入XML声明</span>
<span class="c1">// 处理元素</span>
<span class="k">while</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">START_ELEMENT</span><span class="o">:</span>
            <span class="c1">// 处理开始元素</span>
            <span class="nc">String</span> <span class="n">elementName</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">();</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">elementName</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"book"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elementName</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 修改元素内容</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeStartElement</span><span class="o">(</span><span class="s">"book2"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 复制其他元素</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeStartElement</span><span class="o">(</span><span class="n">elementName</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeAttribute</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">getAttributeLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="n">reader</span><span class="o">.</span><span class="na">getAttributeValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>

        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">CHARACTERS</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">reader</span><span class="o">.</span><span class="na">isWhiteSpace</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="s">"isbn"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())){</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">writeCharacters</span><span class="o">(</span><span class="s">"666888"</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">writeCharacters</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">END_ELEMENT</span><span class="o">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">writeEndElement</span><span class="o">();</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 关闭流</span>
<span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>这段代码的目标是读取一个 XML 文件并将其内容修改后写入另一个 XML 文件。在处理元素内容时，如果当前元素是 <code class="language-plaintext highlighter-rouge">isbn</code>，则将其内容修改为 “666888”，如果当前元素是<code class="language-plaintext highlighter-rouge">book</code>则修改为<code class="language-plaintext highlighter-rouge">book2</code>。</p><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 是用于读取 XML 数据的接口，它允许逐个事件地读取 XML 文档的内容，并提供了一种低级别的、基于流的方式来解析 XML。通过 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code>，可以逐步遍历 XML 文档的元素、属性、文本内容等，并根据需要对文档进行处理，如提取数据、修改内容等操作。这种基于流的解析方式相比于基于文档对象模型（DOM）的解析方式，更加高效，尤其适用于处理大型 XML 文件。</p><p><code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 提供了许多方法来读取 XML 文档的不同部分，以下是一些常用的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">boolean hasNext()</code>：检查是否还有更多的事件要处理。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int next()</code>：移动到下一个 XML 事件，并返回事件的类型。</strong></li><li><code class="language-plaintext highlighter-rouge">int getEventType()</code>：返回当前事件的类型。</li><li><code class="language-plaintext highlighter-rouge">boolean isStartElement()</code>：检查当前事件是否是开始元素。</li><li><code class="language-plaintext highlighter-rouge">boolean isCharacters()</code>：检查当前事件是否是字符数据。</li><li><code class="language-plaintext highlighter-rouge">boolean isEndElement()</code>：检查当前事件是否是结束元素。</li><li><code class="language-plaintext highlighter-rouge">String getLocalName()</code>：返回当前元素的本地名称。</li><li><strong><code class="language-plaintext highlighter-rouge">int getAttributeCount()</code>：返回当前元素的属性数。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getAttributeLocalName(int index)</code>：返回指定索引处属性的本地名称。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getAttributeValue(int index)</code>：返回指定索引处属性的值。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getText()</code>：返回当前元素的文本内容。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">boolean isWhiteSpace()</code>：检查当前解析器位置是否位于空白字符上。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void close()</code>：关闭 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code>。</strong></li></ul><p>这些方法可以在处理 XML 文档时导航并提取所需的信息。</p><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 是用于写入 XML 数据的接口，它允许逐个事件地生成 XML 文档的内容，并提供了一种低级别的、基于流的方式来生成 XML。通过 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code>，可以逐步构建 XML 文档的元素、属性、文本内容等，并生成符合 XML 规范的 XML 数据。这种基于流的生成方式相比于基于文档对象模型（DOM）的生成方式，更加高效，尤其适用于生成大型 XML 文件。</p><p>常用的 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 方法包括：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">writeStartDocument(String version, String encoding)</code>：写入 XML 声明。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeStartElement(String localName)</code>：写入开始元素。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeAttribute(String localName, String value)</code>：写入元素属性。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeCharacters(String text)</code>：写入文本内容。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeEndElement()</code>：写入结束元素。</strong></li><li><code class="language-plaintext highlighter-rouge">writeEndDocument()</code>：写入 XML 结束标记。</li><li><code class="language-plaintext highlighter-rouge">flush()</code>：刷新缓冲区，确保所有数据都被写入底层流。</li><li><strong><code class="language-plaintext highlighter-rouge">close()</code>：关闭 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code>。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamConstants</code> 是一个接口，定义了一组整数常量，用于表示 XML 解析器生成的各种事件类型。这些常量用于与 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 和 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 一起使用，以便在处理 XML 文档时识别不同类型的事件。通过这些常量，可以方便地检查当前事件的类型，并根据需要执行相应的操作。</p><p><code class="language-plaintext highlighter-rouge">XMLStreamConstants</code> 提供了以下常量：</p><ul><li><code class="language-plaintext highlighter-rouge">START_ELEMENT</code>：表示开始元素事件。</li><li><code class="language-plaintext highlighter-rouge">END_ELEMENT</code>：表示结束元素事件。</li><li><code class="language-plaintext highlighter-rouge">CHARACTERS</code>：表示字符数据事件。</li><li><code class="language-plaintext highlighter-rouge">ATTRIBUTE</code>：表示属性事件。</li><li><code class="language-plaintext highlighter-rouge">NAMESPACE</code>：表示命名空间事件。</li><li><code class="language-plaintext highlighter-rouge">START_DOCUMENT</code>：表示开始文档事件。</li><li><code class="language-plaintext highlighter-rouge">END_DOCUMENT</code>：表示结束文档事件。</li><li><code class="language-plaintext highlighter-rouge">PROCESSING_INSTRUCTION</code>：表示处理指令事件。</li><li><code class="language-plaintext highlighter-rouge">COMMENT</code>：表示注释事件。</li><li><code class="language-plaintext highlighter-rouge">DTD</code>：表示 DTD 事件。</li><li><code class="language-plaintext highlighter-rouge">ENTITY_REFERENCE</code>：表示实体引用事件。</li><li><code class="language-plaintext highlighter-rouge">CDATA</code>：表示 CDATA 事件。</li><li><code class="language-plaintext highlighter-rouge">SPACE</code>：表示空格事件。</li></ul><h2 id="使用jackson">使用Jackson</h2><p>XML文档的结构：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p>完全可以对应到一个定义好的JavaBean中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>Jackson第三方库可以轻松做到XML到JavaBean的转换。要使用Jackson，先添加一个Maven的依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后，定义好JavaBean，就可以用下面几行代码解析：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/book.xml"</span><span class="o">);</span>
<span class="nc">JacksonXmlModule</span> <span class="n">module</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JacksonXmlModule</span><span class="o">();</span>
<span class="nc">XmlMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlMapper</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
<span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">author</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">tags</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">pubDate</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">XmlMapper</code>可以用<code class="language-plaintext highlighter-rouge">readValue(InputStream, Class)</code>直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
Java核心技术
Cay S. Horstmann
1234567
[Java, Network]
null
</code></pre></div></div><p>如果要解析的数据格式不是<code class="language-plaintext highlighter-rouge">Jackson</code>内置的标准格式，那么需要编写一点额外的扩展来告诉<code class="language-plaintext highlighter-rouge">Jackson</code>如何自定义解析，可以参考<a href="https://github.com/FasterXML/jackson">Jackson</a>的<a href="https://github.com/FasterXML/jackson-annotations">官方文档</a>。读取属性：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.MapperFeature</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.JacksonXmlModule</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.XmlMapper</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
        <span class="nc">JacksonXmlModule</span> <span class="n">module</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JacksonXmlModule</span><span class="o">();</span>
        <span class="c1">// 默认使用“未包装”列表:</span>
        <span class="c1">//module.setDefaultUseWrapper(false);</span>
        <span class="nc">XmlMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlMapper</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
        <span class="c1">//自动忽略无法对应pojo的字段</span>
        <span class="c1">//mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span>
        <span class="c1">//字段为null，自动忽略，不再序列化</span>
        <span class="c1">//mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>
        <span class="c1">//XML标签名:使用骆驼命名的属性名，</span>
        <span class="c1">//mapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE);</span>
        <span class="c1">//设置转换模式</span>
        <span class="n">mapper</span><span class="o">.</span><span class="na">enable</span><span class="o">(</span><span class="nc">MapperFeature</span><span class="o">.</span><span class="na">USE_STD_BEAN_NAMING</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">author</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的属性lang的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">lang</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的属性aa的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">aa</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">tags</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">pubDate</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">localName</span> <span class="o">=</span> <span class="s">"isbn"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BookAttr</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">BookAttr</span> <span class="o">{</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">isAttribute</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">localName</span> <span class="o">=</span> <span class="s">"lang"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">lang</span><span class="o">;</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">isAttribute</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">localName</span> <span class="o">=</span> <span class="s">"aa"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">aa</span><span class="o">;</span>
    <span class="c1">//测试一下</span>
    <span class="nd">@JacksonXmlText</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="json">JSON</h1><p>XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。</p><p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">id</span><span class="dl">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Java核心技术</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">author</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">firstName</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Abc</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">lastName</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Xyz</span><span class="dl">"</span>
    <span class="p">},</span>
    <span class="dl">"</span><span class="s2">isbn</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1234567</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">tags</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Java</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Network</span><span class="dl">"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div><p>JSON作为数据传输的格式，有几个显著的优点：</p><ul><li>JSON只允许使用UTF-8编码，不存在编码问题；</li><li>JSON只允许使用双引号作为key，特殊字符用<code class="language-plaintext highlighter-rouge">\</code>转义，格式简单；</li><li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li></ul><p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p><ul><li>键值对：<code class="language-plaintext highlighter-rouge">{"key": value}</code></li><li>数组：<code class="language-plaintext highlighter-rouge">[1, 2, 3]</code></li><li>字符串：<code class="language-plaintext highlighter-rouge">"abc"</code></li><li>数值（整数和浮点数）：<code class="language-plaintext highlighter-rouge">12.34</code></li><li>布尔值：<code class="language-plaintext highlighter-rouge">true</code>或<code class="language-plaintext highlighter-rouge">false</code></li><li>空值：<code class="language-plaintext highlighter-rouge">null</code></li></ul><p>浏览器直接支持使用JavaScript对JSON进行读写：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JSON string to JavaScript object:</span>
<span class="nx">jsObj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">);</span>

<span class="c1">// JavaScript object to JSON string:</span>
<span class="nx">jsonStr</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">jsObj</span><span class="p">);</span>
</code></pre></div></div><p>开发Web应用的时候，使用JSON作为数据传输，在浏览器端非常方便。因为JSON天生适合JavaScript处理，绝大多数REST API都选择JSON作为数据传输格式。</p><p>在Java中，针对JSON也有标准的JSR 353 API。常用的用于解析JSON的第三方库有：<code class="language-plaintext highlighter-rouge">Jackson</code>、<code class="language-plaintext highlighter-rouge">Gson</code>、<code class="language-plaintext highlighter-rouge">Fastjson</code>。</p><p>使用<code class="language-plaintext highlighter-rouge">Jackson</code>：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>就可以使用下面的代码解析一个JSON文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.json"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
        <span class="c1">// 反序列化时忽略不存在的JavaBean属性:</span>
        <span class="n">mapper</span><span class="o">.</span><span class="na">configure</span><span class="o">(</span><span class="nc">DeserializationFeature</span><span class="o">.</span><span class="na">FAIL_ON_UNKNOWN_PROPERTIES</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"Book{id="</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", author="</span> <span class="o">+</span> <span class="n">author</span> <span class="o">+</span> <span class="s">", isbn='"</span> <span class="o">+</span> <span class="n">isbn</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", tags="</span> <span class="o">+</span> <span class="n">tags</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>核心代码是创建一个<code class="language-plaintext highlighter-rouge">ObjectMapper</code>对象。关闭<code class="language-plaintext highlighter-rouge">DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>功能使得解析时如果JavaBean不存在该属性时解析不会报错。</p><p>还可以直接用Map接收：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.json"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div><hr /><p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
</code></pre></div></div><p>还可以生成带缩进和换行的JSON：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span><span class="o">=</span><span class="n">mapper</span><span class="o">.</span><span class="na">writerWithDefaultPrettyPrinter</span><span class="o">().</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div><hr /><p>要把JSON的某些值解析为特定的Java对象，例如<code class="language-plaintext highlighter-rouge">LocalDate</code>，也是完全可以的。例如：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Java核心技术</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">pubDate</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2016-09-01</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div><p>要解析为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">LocalDate</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>只需要引入标准的JSR 310关于<code class="language-plaintext highlighter-rouge">JavaTime</code>的数据格式定义至Maven：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-jsr310 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.datatype<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-datatype-jsr310<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后，在创建<code class="language-plaintext highlighter-rouge">ObjectMapper</code>时，注册一个新的<code class="language-plaintext highlighter-rouge">JavaTimeModule</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">().</span><span class="na">registerModule</span><span class="o">(</span><span class="k">new</span> <span class="nc">JavaTimeModule</span><span class="o">());</span>
</code></pre></div></div><p>还可以自定义解析，假设<code class="language-plaintext highlighter-rouge">Book</code>类的<code class="language-plaintext highlighter-rouge">isbn</code>是一个<code class="language-plaintext highlighter-rouge">BigInteger</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nc">BigInteger</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>但JSON数据并不是标准的整形格式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
    <span class="s">"name"</span><span class="o">:</span> <span class="s">"Java核心技术"</span><span class="o">,</span>
    <span class="s">"isbn"</span><span class="o">:</span> <span class="s">"978-7-111-54742-6"</span>
<span class="o">}</span>
</code></pre></div></div><p>直接解析，肯定报错。这时，需要自定义一个<code class="language-plaintext highlighter-rouge">IsbnDeserializer</code>，用于解析含有非数字的字符串：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IsbnDeserializer</span> <span class="kd">extends</span> <span class="nc">JsonDeserializer</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">JsonParser</span> <span class="n">p</span><span class="o">,</span> <span class="nc">DeserializationContext</span> <span class="n">ctxt</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">JsonProcessingException</span> <span class="o">{</span>
        <span class="c1">// 读取原始的JSON字符串内容:</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValueAsString</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">BigInteger</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">JsonParseException</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后，在<code class="language-plaintext highlighter-rouge">Book</code>类中使用注解标注：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 表示反序列化isbn时使用自定义的IsbnDeserializer:</span>
    <span class="nd">@JsonDeserialize</span><span class="o">(</span><span class="n">using</span> <span class="o">=</span> <span class="nc">IsbnDeserializer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>类似的，自定义序列化时我们需要自定义一个<code class="language-plaintext highlighter-rouge">IsbnSerializer</code>，然后在<code class="language-plaintext highlighter-rouge">Book</code>类中标注<code class="language-plaintext highlighter-rouge">@JsonSerialize(using = ...)</code>即可。</p><p>在反序列化时，<code class="language-plaintext highlighter-rouge">Jackson</code>要求Java类<strong>需要一个默认的无参数构造方法</strong>，否则，无法直接实例化此类。存在带参数构造方法的类，如果要反序列化，注意再提供一个无参数构造方法。</p><p>对于<code class="language-plaintext highlighter-rouge">enum</code>字段，Jackson按String类型处理，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">DayOfWeek</span> <span class="n">start</span> <span class="o">=</span> <span class="no">MONDAY</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>序列化为：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MONDAY</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div><p>对于<code class="language-plaintext highlighter-rouge">record</code>类型（<strong>Java 14</strong> ），Jackson会自动找出它的带参数构造方法，并根据JSON的key进行匹配，可直接反序列化。对<code class="language-plaintext highlighter-rouge">record</code>类型的支持需要版本<code class="language-plaintext highlighter-rouge">2.12.0</code>以上。</p><h1 id="jdbc">JDBC</h1><p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity）</p><p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p><p>在Java代码中如果要访问MySQL，必须编写代码操作JDBC接口。JDBC接口是Java标准库自带的，所以可以直接编译。而具体的JDBC驱动是由数据库厂商提供的，例如，MySQL的JDBC驱动由Oracle提供。因此，访问某个具体的数据库，只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库，因为他们都提供了标准的JDBC驱动。</p><p>从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类。</p><p>一个MySQL的JDBC的驱动就是一个jar包，本身也是纯Java编写的。编写的代码只需要引用Java标准库提供的<code class="language-plaintext highlighter-rouge">java.sql</code>包下面的相关接口，由此再间接地通过MySQL驱动的jar包通过网络访问MySQL服务器，所有复杂的网络通讯都被封装到JDBC驱动中，因此，Java程序本身只需要引入一个MySQL驱动的jar包就可以正常访问MySQL服务器</p><p>使用JDBC的好处是：</p><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</li><li>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li></ul><p>mysql的JDBC驱动：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>mysql<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>mysql-connector-java<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.1.47<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>runtime<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>依赖的<code class="language-plaintext highlighter-rouge">scope</code>是<code class="language-plaintext highlighter-rouge">runtime</code>，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。如果把<code class="language-plaintext highlighter-rouge">runtime</code>改成<code class="language-plaintext highlighter-rouge">compile</code>，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似<code class="language-plaintext highlighter-rouge">com.mysql.jdbc.Connection</code>这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为<code class="language-plaintext highlighter-rouge">compile</code>。</p><h2 id="连接数据库">连接数据库</h2><p><code class="language-plaintext highlighter-rouge">Connection</code>代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。打开一个<code class="language-plaintext highlighter-rouge">Connection</code>时，需要准备URL、用户名和口令，才能成功连接到数据库。</p><p>URL是由数据库厂商指定的格式，例如，MySQL的URL是：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key1=value1&amp;key2=value2
</code></pre></div></div><p>假设数据库运行在本机<code class="language-plaintext highlighter-rouge">localhost</code>，端口使用标准的<code class="language-plaintext highlighter-rouge">3306</code>，数据库名称是<code class="language-plaintext highlighter-rouge">studentdb</code>，那么URL如下：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jdbc:mysql://localhost:3306/studentdb?useSSL=false&amp;characterEncoding=utf8
</code></pre></div></div><p>后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码（注意MySQL的UTF-8是<code class="language-plaintext highlighter-rouge">utf8</code>）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JDBC连接的URL, 不同数据库有不同的格式:</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3306/studentdb?useSSL=false&amp;characterEncoding=utf8"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">user</span> <span class="o">=</span> <span class="s">"root"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"123456"</span><span class="o">;</span>
<span class="c1">// 获取连接:</span>
<span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="c1">// 关闭连接:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DriverManager</code>会自动扫描<code class="language-plaintext highlighter-rouge">classpath</code>，找到所有的JDBC驱动，然后根据传入的URL自动挑选一个合适的驱动。</p><p>因为JDBC连接是一种昂贵的资源，所以使用后要及时释放。使用<code class="language-plaintext highlighter-rouge">try (resource)</code>来自动释放JDBC连接是一个好方法。</p><h2 id="查询">查询</h2><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT xuehao, name, sex, age FROM student WHERE sex='男'"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">ResultSetMetaData</span> <span class="n">metaData</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getMetaData</span><span class="o">();</span><span class="c1">//返回列名</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">metaData</span><span class="o">.</span><span class="na">getColumnCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//列从1开始</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">metaData</span><span class="o">.</span><span class="na">getColumnName</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="s">"\t"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 注意：索引从1开始</span>
                <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">sex</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"sex"</span><span class="o">);</span><span class="c1">//使用名称访问</span>
                <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"age"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">id</span><span class="o">+</span><span class="s">"\t"</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">"\t"</span><span class="o">+</span><span class="n">sex</span><span class="o">+</span><span class="s">"\t"</span><span class="o">+</span><span class="n">age</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Statement</code>对象，用于执行一个查询，executeQuery传入一个SQL字符串，并提交查询返回结果。</p><p><code class="language-plaintext highlighter-rouge">ResultSetMetaData</code>和<code class="language-plaintext highlighter-rouge">ResultSet</code>获取列时，索引从<code class="language-plaintext highlighter-rouge">1</code>开始而不是<code class="language-plaintext highlighter-rouge">0</code>。</p><p>可以封装为<code class="language-plaintext highlighter-rouge">List</code>，不建议，为了后续维护方便，还是用<code class="language-plaintext highlighter-rouge">JavaBean</code>比较好。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT xuehao, name, sex, age FROM student WHERE sex='男'"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">ResultSetMetaData</span> <span class="n">metaData</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getMetaData</span><span class="o">();</span><span class="c1">//返回列名</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">metaData</span><span class="o">.</span><span class="na">getColumnCount</span><span class="o">();</span>
            <span class="nc">String</span> <span class="o">[]</span><span class="n">columnName</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//列从1开始</span>
                <span class="n">columnName</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">metaData</span><span class="o">.</span><span class="na">getColumnName</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">line</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">line</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">columnName</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">rs</span><span class="o">.</span><span class="na">getObject</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
                <span class="o">}</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="sql注入">SQL注入</h2><p>使用<code class="language-plaintext highlighter-rouge">Statement</code>拼字符串非常容易引发SQL注入的问题，这是因为SQL参数往往是从方法参数传入的。假设用户登录的验证方法如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pass</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT * FROM user WHERE login='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"' AND pass='"</span> <span class="o">+</span> <span class="n">pass</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，参数<code class="language-plaintext highlighter-rouge">name</code>和<code class="language-plaintext highlighter-rouge">pass</code>通常都是Web页面输入后由程序接收到的。</p><p>如果用户的输入是程序期待的值，就可以拼出正确的SQL。例如：name = <code class="language-plaintext highlighter-rouge">"bob"</code>，pass = <code class="language-plaintext highlighter-rouge">"1234"</code>：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">login</span><span class="o">=</span><span class="s1">'bob'</span> <span class="k">AND</span> <span class="n">pass</span><span class="o">=</span><span class="s1">'1234'</span>
</code></pre></div></div><p>但是，如果用户的输入是一个精心构造的字符串，就可以拼出意想不到的SQL，这个SQL也是正确的，但它查询的条件不是程序设计的意图。例如：<code class="language-plaintext highlighter-rouge">name</code> = <code class="language-plaintext highlighter-rouge">bob' OR pass=</code>, <code class="language-plaintext highlighter-rouge">pass</code> = <code class="language-plaintext highlighter-rouge">' OR pass='</code>：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">login</span><span class="o">=</span><span class="s1">'bob'</span> <span class="k">OR</span> <span class="n">pass</span><span class="o">=</span><span class="s1">' AND pass='</span> <span class="k">OR</span> <span class="n">pass</span><span class="o">=</span><span class="s1">''</span>
</code></pre></div></div><p>这个SQL语句执行的时候，根本不用判断口令是否正确，这样一来，登录就形同虚设。</p><p>要避免SQL注入攻击，要对所有字符串参数进行转义，使用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>可以<strong>完全避免SQL注入</strong>的问题，<code class="language-plaintext highlighter-rouge">PreparedStatement</code>始终使用<code class="language-plaintext highlighter-rouge">?</code>作为占位符，在设置参数值时会自动转义特殊字符，比如单引号、双引号等。这样可以确保参数值不会被误解为 SQL 代码的一部分，从而进一步增强了防御能力，还能高效利用数据库本身对查询的缓存。上述登录SQL如果用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>可以改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pass</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM user WHERE login=? AND pass=?"</span><span class="o">;</span>
    <span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span><span class="c1">//设置第一个问号为name</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">pass</span><span class="o">);</span>
	<span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>所以，使用Java对数据库进行操作时，必须使用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>。</p><h2 id="数据类型">数据类型</h2><p>使用JDBC的时候，需要在Java数据类型和SQL数据类型之间进行转换。JDBC在<code class="language-plaintext highlighter-rouge">java.sql.Types</code>定义了一组常量来表示如何映射SQL数据类型，平时使用的类型通常也就以下几种：</p><table><thead><tr><th style="text-align: left">SQL数据类型</th><th style="text-align: left">Java数据类型</th></tr></thead><tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIT</code>, <code class="language-plaintext highlighter-rouge">BOOL</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">boolean</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">INTEGER</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">int</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">long</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">REAL</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">float</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">FLOAT</code>, <code class="language-plaintext highlighter-rouge">DOUBLE</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">double</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">CHAR</code>, <code class="language-plaintext highlighter-rouge">VARCHAR</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">String</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">DECIMAL</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">BigDecimal</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">DATE</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">java.sql.Date</code>, <code class="language-plaintext highlighter-rouge">LocalDate</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">TIME</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">java.sql.Time</code>, <code class="language-plaintext highlighter-rouge">LocalTime</code></td></tr></tbody></table><p>注意：只有最新的JDBC驱动才支持<code class="language-plaintext highlighter-rouge">LocalDate</code>和<code class="language-plaintext highlighter-rouge">LocalTime</code>。</p><h2 id="更新">更新</h2><p>插入操作是<code class="language-plaintext highlighter-rouge">INSERT</code>，即插入一条新记录，更新与删除也是一样的。通过JDBC进行插入，本质上也是用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>执行一条SQL语句，不过最后执行的不是<code class="language-plaintext highlighter-rouge">executeQuery()</code>，而是<code class="language-plaintext highlighter-rouge">executeUpdate()</code>。当成功执行<code class="language-plaintext highlighter-rouge">executeUpdate()</code>后，返回值是<code class="language-plaintext highlighter-rouge">int</code>，表示插入的记录数量。</p><p>如果数据库的表设置了自增主键，那么在执行<code class="language-plaintext highlighter-rouge">INSERT</code>语句时，并不需要指定主键，数据库会自动分配主键。若希望以不指定列名的形式插入，则可以用0作为主键值表示自增。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span><span class="o">=</span><span class="s">"INSERT INTO student values(?,?,?,?,?,?)"</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="nc">Statement</span><span class="o">.</span><span class="na">RETURN_GENERATED_KEYS</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"张四"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="s">"男"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">20</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="s">"江苏南京"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="s">"计算机"</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
    <span class="c1">// 获取自动生成的主键值</span>
    <span class="nc">ResultSet</span> <span class="n">generatedKeys</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">getGeneratedKeys</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">generatedKeys</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">primaryKey</span> <span class="o">=</span> <span class="n">generatedKeys</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"插入的主键值为: "</span> <span class="o">+</span> <span class="n">primaryKey</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>对于使用自增主键的程序，要获取插入后的自增主键的值，可以在创建<code class="language-plaintext highlighter-rouge">PreparedStatement</code>的时候，指定一个<code class="language-plaintext highlighter-rouge">RETURN_GENERATED_KEYS</code>标志位，表示JDBC驱动必须返回插入的自增主键。</p><p>然后调用<code class="language-plaintext highlighter-rouge">getGeneratedKeys()</code>获取一个<code class="language-plaintext highlighter-rouge">ResultSet</code>对象，这个对象包含了数据库自动生成的主键的值，读取该对象的每一行来获取自增主键的值。如果一次插入多条记录，那么这个<code class="language-plaintext highlighter-rouge">ResultSet</code>对象就会有多行返回值。如果插入时有多列自增，那么<code class="language-plaintext highlighter-rouge">ResultSet</code>对象的每一行都会对应多个自增值（自增列不一定必须是主键）。</p><h2 id="事务">事务</h2><p>数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的<code class="language-plaintext highlighter-rouge">synchronized</code>同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性：</p><ul><li>Atomicity：原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>Consistency：一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>Isolation：隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>Durability：，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>数据库事务可以并发执行，而数据库系统从效率考虑，对事务定义了不同的隔离级别。SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th style="text-align: left">Isolation Level</th><th style="text-align: left">脏读（Dirty Read）</th><th style="text-align: left">不可重复读（Non Repeatable Read）</th><th style="text-align: left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td style="text-align: left">Read Uncommitted</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left">Read Committed</td><td style="text-align: left">-</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left">Repeatable Read</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left">Serializable</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr></tbody></table><p><strong>Read Uncommitted</strong>是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p><p>在<strong>Read Committed</strong>隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>在<strong>Repeatable Read</strong>隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p><strong>Serializable</strong>是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><p><strong>默认隔离级别</strong></p><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用<code class="language-plaintext highlighter-rouge">InnoDB</code>，默认的隔离级别是Repeatable Read。</p><hr /><p>对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。</p><p>假设小明准备给小红支付100，两人在数据库中的记录主键分别是<code class="language-plaintext highlighter-rouge">123</code>和<code class="language-plaintext highlighter-rouge">456</code>，那么用两条SQL语句操作如下：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">accounts</span> <span class="k">SET</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="mi">100</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">123</span> <span class="k">AND</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">accounts</span> <span class="k">SET</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">100</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">456</span><span class="p">;</span>
</code></pre></div></div><p>这两条语句必须以事务方式执行才能保证业务的正确性，因为一旦第一条SQL执行成功而第二条SQL失败的话，系统的钱就会凭空减少100，而有了事务，要么这笔转账成功；要么转账失败，双方账户的钱都不变。</p><p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">openConnection</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 关闭自动提交:</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">setAutoCommit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
    <span class="c1">// 执行多条SQL语句:</span>
    <span class="n">insert</span><span class="o">();</span> <span class="n">update</span><span class="o">();</span> <span class="n">delete</span><span class="o">();</span>
    <span class="c1">// 提交事务:</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 回滚事务:</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">setAutoCommit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，开启事务的关键代码是<code class="language-plaintext highlighter-rouge">conn.setAutoCommit(false)</code>，表示关闭自动提交。提交事务的代码在执行完指定的若干条SQL语句后，调用<code class="language-plaintext highlighter-rouge">conn.commit()</code>。要注意事务不是总能成功，如果事务提交失败，会抛出SQL异常（也可能在执行SQL语句的时候就抛出了），此时必须捕获并调用<code class="language-plaintext highlighter-rouge">conn.rollback()</code>回滚事务。最后，在<code class="language-plaintext highlighter-rouge">finally</code>中通过<code class="language-plaintext highlighter-rouge">conn.setAutoCommit(true)</code>把<code class="language-plaintext highlighter-rouge">Connection</code>对象的状态恢复到初始值。</p><p>如果不及时提交或者回滚，当另一个事务需要对本事务中影响的行进行<strong>更新</strong>的时候是会被阻塞的。一直等到事务超时释放。所以一个事物要么尽快提交，要么尽快回滚。</p><p>默认情况下，获取到<code class="language-plaintext highlighter-rouge">Connection</code>连接后，总是处于“自动提交”模式，也就是每执行一条SQL都是作为事务自动执行的。只要关闭了<code class="language-plaintext highlighter-rouge">Connection</code>的<code class="language-plaintext highlighter-rouge">autoCommit</code>，那么就可以在一个事务中执行多条语句，事务以<code class="language-plaintext highlighter-rouge">commit()</code>方法结束。</p><p>如果要设定事务的隔离级别，可以使用如下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设定隔离级别为READ COMMITTED:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setTransactionIsolation</span><span class="o">(</span><span class="nc">Connection</span><span class="o">.</span><span class="na">TRANSACTION_READ_COMMITTED</span><span class="o">);</span>
</code></pre></div></div><p>如果没有调用上述方法，那么会使用数据库的默认隔离级别。MySQL的默认隔离级别是<code class="language-plaintext highlighter-rouge">REPEATABLE_READ</code>。</p><h2 id="batch">Batch</h2><p>使用JDBC操作数据库的时候，经常会执行一些批量操作。</p><p>例如，一次性给会员增加可用优惠券若干，我们可以执行以下SQL代码：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">123</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">234</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">345</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">456</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div><p>实际上执行JDBC时，因为只有占位符参数不同，所以SQL实际上是一样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">params</span> <span class="o">:</span> <span class="n">paramsList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">preparedStatement</span><span class="o">(</span><span class="s">"INSERT INTO coupons (user_id, type, expires) VALUES (?,?,?)"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setLong</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>通过一个循环来执行每个<code class="language-plaintext highlighter-rouge">PreparedStatement</code>虽然可行，但是性能很低。SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。</p><p>可以利用SQL数据库的这一特性，把同一个SQL但参数不同的若干次操作合并为一个batch执行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="s">"INSERT INTO student (name, sex, age, address,depart) VALUES (?, ?, ?, ?, ?)"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 对同一个PreparedStatement反复设置参数并调用addBatch():</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Student</span> <span class="n">s</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">sex</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">address</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">depart</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">addBatch</span><span class="o">();</span> <span class="c1">// 添加到batch</span>
    <span class="o">}</span>
    <span class="c1">// 执行batch:</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeBatch</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ns</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" inserted."</span><span class="o">);</span> <span class="c1">// batch中每个SQL执行的结果数量</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>执行batch和执行一个SQL不同点在于，需要对同一个<code class="language-plaintext highlighter-rouge">PreparedStatement</code>反复设置参数并调用<code class="language-plaintext highlighter-rouge">addBatch()</code>，这样就相当于给一个SQL加上了多组参数，相当于变成了“多行”SQL。</p><p>第二个不同点是调用的不是<code class="language-plaintext highlighter-rouge">executeUpdate()</code>，而是<code class="language-plaintext highlighter-rouge">executeBatch()</code>，因为设置了多组参数，相应地，返回结果也是多个<code class="language-plaintext highlighter-rouge">int</code>值，因此返回类型是<code class="language-plaintext highlighter-rouge">int[]</code>，循环<code class="language-plaintext highlighter-rouge">int[]</code>数组即可获取每组参数执行后影响的结果数量。</p><p>另外MySQL批处理默认是关闭的，如果需要开启，在<code class="language-plaintext highlighter-rouge">url</code>上添加 ：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rewriteBatchedStatements=true
</code></pre></div></div><h2 id="连接池">连接池</h2><p>在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，可以通过连接池（Connection Pool）复用已经创建好的连接。</p><p>JDBC连接池有一个标准的接口<code class="language-plaintext highlighter-rouge">javax.sql.DataSource</code>，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，必须选择一个JDBC连接池的实现。常用的JDBC连接池有<code class="language-plaintext highlighter-rouge">HikariCP</code>、<code class="language-plaintext highlighter-rouge">C3P0</code>、<code class="language-plaintext highlighter-rouge">BoneCP</code>、<code class="language-plaintext highlighter-rouge">Druid</code>。目前使用最广泛的是<code class="language-plaintext highlighter-rouge">HikariCP</code>。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.zaxxer<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>HikariCP<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.1.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">();</span>
<span class="n">config</span><span class="o">.</span><span class="na">setJdbcUrl</span><span class="o">(</span><span class="s">"jdbc:mysql://localhost:3306/studentdb?useSSL=false&amp;characterEncoding=utf8"</span><span class="o">);</span>
<span class="n">config</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"root"</span><span class="o">);</span>
<span class="n">config</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">"123456"</span><span class="o">);</span>
<span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"connectionTimeout"</span><span class="o">,</span> <span class="s">"1000"</span><span class="o">);</span> <span class="c1">// 连接超时：1秒</span>
<span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"idleTimeout"</span><span class="o">,</span> <span class="s">"60000"</span><span class="o">);</span> <span class="c1">// 空闲超时：60秒</span>
<span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"maximumPoolSize"</span><span class="o">,</span> <span class="s">"10"</span><span class="o">);</span> <span class="c1">// 最大连接数：10</span>
<span class="nc">DataSource</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DataSource</code>实例就是连接池，创建<code class="language-plaintext highlighter-rouge">DataSource</code>也是一个非常昂贵的操作，所以通常<code class="language-plaintext highlighter-rouge">DataSource</code>实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p><p>有了连接池以后获取<code class="language-plaintext highlighter-rouge">Connection</code>时，把<code class="language-plaintext highlighter-rouge">DriverManage.getConnection()</code>改为<code class="language-plaintext highlighter-rouge">ds.getConnection()</code>即可。</p><p>通过连接池获取连接时，并不需要指定JDBC的相关URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建<code class="language-plaintext highlighter-rouge">HikariDataSource</code>时传入的<code class="language-plaintext highlighter-rouge">HikariConfig</code>持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用<code class="language-plaintext highlighter-rouge">ds.getConnection()</code>，会迫使连接池内部先创建一个<code class="language-plaintext highlighter-rouge">Connection</code>，再返回给客户端使用。当我们调用<code class="language-plaintext highlighter-rouge">conn.close()</code>方法时（<code class="language-plaintext highlighter-rouge">在try(resource){...}</code>结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p><p>连接池内部维护了若干个<code class="language-plaintext highlighter-rouge">Connection</code>实例，如果调用<code class="language-plaintext highlighter-rouge">ds.getConnection()</code>，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对<code class="language-plaintext highlighter-rouge">Connection</code>调用<code class="language-plaintext highlighter-rouge">close()</code>，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。</p><p>通常连接池提供了大量的参数可以配置，例如，维护的最小、最大活动连接数，指定一个连接在空闲一段时间后自动关闭等，需要根据应用程序的负载合理地配置这些参数。大多数连接池都提供了详细的实时状态以便进行监控。</p><h1 id="gui">GUI</h1><p><code class="language-plaintext highlighter-rouge">JFrame</code> <strong>构造方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">JFrame()</code></td><td>构造一个初始时不可见的新窗体。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(GraphicsConfiguration gc)</code></td><td>以屏幕设备的指定 <code class="language-plaintext highlighter-rouge">GraphicsConfiguration</code> 和空白标题创建一个 <code class="language-plaintext highlighter-rouge">Frame</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(String title)</code></td><td>创建一个新的、初始不可见的、具有指定标题的 <code class="language-plaintext highlighter-rouge">Frame</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(String title, GraphicsConfiguration gc)</code></td><td>创建一个具有指定标题和指定屏幕设备的 <code class="language-plaintext highlighter-rouge">GraphicsConfiguration</code> 的 <code class="language-plaintext highlighter-rouge">JFrame</code>。</td></tr></tbody></table><p><strong>常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">add()</code></td><td>将组件添加到窗口</td></tr><tr><td><code class="language-plaintext highlighter-rouge">is/setVisible()</code></td><td>获取/设置窗体的可视状态。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setTitle()</code></td><td>获取/设置窗体的标题。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setState()</code></td><td>获取/设置窗体的的最小化,最大化等状态。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setLocation()</code></td><td>获取/设置窗体在屏幕上应当出现的位置。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setSize()</code></td><td>获取/设置窗体的大小。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">setDefaultCloseOperation(int operation)</code></td><td>设置单击窗体上的关闭按钮时的默认操作。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">getContentPane()</code></td><td>获取窗体的内容面板</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">setDefaultCloseOperation</code></p><p><code class="language-plaintext highlighter-rouge">public void setDefaultCloseOperation(int operation)</code><br /> 设置用户在此窗体上发起”<code class="language-plaintext highlighter-rouge">close</code>“时默认执行的操作。必须指定以下选项之一：</p><p>值依次为<code class="language-plaintext highlighter-rouge">0-3</code></p><p><code class="language-plaintext highlighter-rouge">DO_NOTHING_ON_CLOSE</code>(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 <code class="language-plaintext highlighter-rouge">WindowListener</code> 对象的 <code class="language-plaintext highlighter-rouge">windowClosing</code> 方法中处理该操作。</p><p><code class="language-plaintext highlighter-rouge">HIDE_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">WindowConstants</code> 中定义)：调用任意已注册的 <code class="language-plaintext highlighter-rouge">WindowListener</code> 对象后自动隐藏该窗体。</p><p><code class="language-plaintext highlighter-rouge">DISPOSE_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">WindowConstants</code> 中定义)：调用任意已注册 <code class="language-plaintext highlighter-rouge">WindowListener</code> 的对象后自动隐藏并释放该窗体。</p><p><code class="language-plaintext highlighter-rouge">EXIT_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">JFrame</code> 中定义)：使用 <code class="language-plaintext highlighter-rouge">System exit</code> 方法退出应用程序。仅在应用程序中使用。</p><p>默认情况下,该值被设置为 <code class="language-plaintext highlighter-rouge">HIDE_ON_CLOSE</code>。更改此属性的值将导致激发属性更改事件,其属性名称为 “<code class="language-plaintext highlighter-rouge">defaultCloseOperation</code>“。</p><p>注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机<strong>可能</strong>会终止。<br /> <code class="language-plaintext highlighter-rouge">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</code></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/09/03/%E5%85%B6%E4%BB%96/" target="_blank">https://acteds.github.io/2021/09/03/%E5%85%B6%E4%BB%96/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1720958301', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
