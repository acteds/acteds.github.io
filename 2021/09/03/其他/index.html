<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>其他 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/09/03/%E5%85%B6%E4%BB%96/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="其他"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言一些零散的笔记，XML的读写、JSON的读写、JDBC、GUI。"><meta name="og:description" content="引言一些零散的笔记，XML的读写、JSON的读写、JDBC、GUI。"><meta property="og:url" content="/2021/09/03/%E5%85%B6%E4%BB%96/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-09-03"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="其他"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">其他</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/09/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 61422 字，约 176 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>一些零散的笔记，XML的读写、JSON的读写、JDBC、GUI。</p><h1 id="xml">XML</h1><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><p>例如，一个描述书籍的XML文档可能如下：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="cp">&lt;!DOCTYPE note SYSTEM "book.dtd"&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p>XML有几个特点：一是纯文本，默认使用UTF-8编码，二是可嵌套，适合表示结构化数据。如果把XML内容存为文件，那么它就是一个XML文件，例如<code class="language-plaintext highlighter-rouge">book.xml</code>。此外，XML内容经常通过网络作为消息传输。</p><p>XML有固定的结构，首行必定是<code class="language-plaintext highlighter-rouge">&lt;?xml version="1.0"?&gt;</code>，可以加上可选的编码。紧接着，如果以类似<code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE note SYSTEM "book.dtd"&gt;</code>声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。接下来是XML的文档内容，一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，<code class="language-plaintext highlighter-rouge">&lt;isbn lang="CN"&gt;1234567&lt;/isbn&gt;</code>包含一个属性<code class="language-plaintext highlighter-rouge">lang="CN"</code>，且元素必须正确嵌套。如果是空元素，可以用<code class="language-plaintext highlighter-rouge">&lt;tag/&gt;</code>表示。</p><p>由于使用了<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;</code>以及引号等标识符，如果内容出现了特殊符号，需要使用<code class="language-plaintext highlighter-rouge">&amp;???;</code>表示转义。例如，<code class="language-plaintext highlighter-rouge">Java&lt;tm&gt;</code>必须写成：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;name&gt;Java&amp;lt;tm&amp;gt;&lt;/name&gt;
</code></pre></div></div><p>常见的特殊字符如下：</p><table><thead><tr><th style="text-align: left">字符</th><th style="text-align: left">表示</th></tr></thead><tbody><tr><td style="text-align: left">&lt;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;lt;</code></td></tr><tr><td style="text-align: left">&gt;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;gt;</code></td></tr><tr><td style="text-align: left">&amp;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;amp;</code></td></tr><tr><td style="text-align: left">”</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;quot;</code></td></tr><tr><td style="text-align: left">’</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;apos;</code></td></tr></tbody></table><p>格式正确的XML（Well Formed）可以被解析器正常读取。而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证。</p><p>DTD文档可以指定一系列规则，例如：</p><ul><li>根元素必须是<code class="language-plaintext highlighter-rouge">book</code></li><li><code class="language-plaintext highlighter-rouge">book</code>元素必须包含<code class="language-plaintext highlighter-rouge">name</code>，<code class="language-plaintext highlighter-rouge">author</code>等指定元素</li><li><code class="language-plaintext highlighter-rouge">isbn</code>元素必须包含属性<code class="language-plaintext highlighter-rouge">lang</code></li><li>…</li></ul><p>如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。</p><p>和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。</p><p>XML是一个技术体系，除了经常用到的XML文档本身外，XML还支持：</p><ul><li>DTD和XSD：验证XML结构和数据是否有效；</li><li>Namespace：XML节点和属性的名字空间；</li><li>XSLT：把XML转化为另一种文本；</li><li>XPath：一种XML节点查询语言；</li><li>…</li></ul><p>因为XML是一种树形结构的文档，它有两种标准的解析API：</p><ul><li>DOM：一次性读取XML，并在内存中表示为树形结构；</li><li>SAX：以流的形式读取XML，使用事件回调。</li></ul><h2 id="使用dom解析">使用DOM解析</h2><p>DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个树形结构处理，从根节点开始，每个节点都可以包含任意个子节点。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">document</code>代表XML文档，是真正的“根”，而<code class="language-plaintext highlighter-rouge">&lt;book&gt;</code>虽然是根元素，但它是<code class="language-plaintext highlighter-rouge">document</code>的一个子节点。</p><p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p><ul><li>Document：代表整个XML文档；</li><li>Element：代表一个XML元素；</li><li>Attribute：代表一个元素的某个属性。</li></ul><p>使用DOM解析一个XML文档的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.Document</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.NamedNodeMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.Node</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.NodeList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.xml.sax.SAXException</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.xml.parsers.DocumentBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.parsers.DocumentBuilderFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.parsers.ParserConfigurationException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">SAXException</span><span class="o">,</span> <span class="nc">ParserConfigurationException</span> <span class="o">{</span>
        <span class="c1">// 从文件、网络流或其他来源获取 XML 输入流</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
        <span class="nc">DocumentBuilderFactory</span> <span class="n">dbf</span> <span class="o">=</span> <span class="nc">DocumentBuilderFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="nc">DocumentBuilder</span> <span class="n">db</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="na">newDocumentBuilder</span><span class="o">();</span>
        <span class="c1">// 使用 DocumentBuilder 解析输入流，获取 Document 实例</span>
        <span class="nc">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="n">printNode</span><span class="o">(</span><span class="n">doc</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">printNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">DOCUMENT_NODE</span><span class="o">:</span> <span class="c1">// Document节点</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Document: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">ELEMENT_NODE</span><span class="o">:</span> <span class="c1">// 元素节点</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Element: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">TEXT_NODE</span><span class="o">:</span> <span class="c1">// 文本</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">matches</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">)){</span><span class="c1">//为空则无视</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Text = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">ATTRIBUTE_NODE</span><span class="o">:</span> <span class="c1">// 属性</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Attr: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">CDATA_SECTION_NODE</span><span class="o">:</span><span class="c1">// 非解析文本</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span> <span class="s">"CDATA: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">trim</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">COMMENT_NODE</span><span class="o">:</span><span class="c1">// 注释</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span> <span class="s">"Comment: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">trim</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span> <span class="c1">// 其他</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"NodeType: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">()</span> <span class="o">+</span> <span class="s">", NodeName: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">hasAttributes</span><span class="o">())</span> <span class="o">{</span><span class="c1">//有属性则递归</span>
            <span class="nc">NamedNodeMap</span> <span class="n">as</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">getAttributes</span><span class="o">();</span><span class="c1">// 获取标签内所有属性</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">as</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">printNode</span><span class="o">(</span><span class="n">as</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">indent</span><span class="o">+</span><span class="mi">2</span><span class="o">);</span><span class="c1">// 递归</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">hasChildNodes</span><span class="o">())</span> <span class="o">{</span><span class="c1">//有子节点则递归</span>
            <span class="nc">NodeList</span> <span class="n">childNodes</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childNodes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">printNode</span><span class="o">(</span><span class="n">childNodes</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">indent</span><span class="o">+</span><span class="mi">2</span><span class="o">);</span><span class="c1">// 递归</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getRetraction</span><span class="o">(</span><span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">s</span><span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indent</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DocumentBuilder.parse()</code>用于解析一个XML，它可以接收<code class="language-plaintext highlighter-rouge">InputStream</code>，<code class="language-plaintext highlighter-rouge">File</code>或者<code class="language-plaintext highlighter-rouge">URL</code>，如果解析无误，将获得一个<code class="language-plaintext highlighter-rouge">Document</code>对象，这个对象代表了整个<code class="language-plaintext highlighter-rouge">XML</code>文档的树形结构。</p><p>从根节点<code class="language-plaintext highlighter-rouge">Document</code>出发，可以遍历所有子节点，获取所有元素、属性、文本数据，还可以包括注释，这些节点被统称为<code class="language-plaintext highlighter-rouge">Node</code>，每个<code class="language-plaintext highlighter-rouge">Node</code>都有自己的<code class="language-plaintext highlighter-rouge">Type</code>，根据<code class="language-plaintext highlighter-rouge">Type</code>来区分一个<code class="language-plaintext highlighter-rouge">Node</code>到底是元素，还是属性，还是文本，等等。</p><p>使用DOM API时，如果要读取某个元素的文本，需要访问它的Text类型的子节点，所以使用起来还是比较繁琐的，且DOM解析速度慢，内存占用大。</p><hr /><p><code class="language-plaintext highlighter-rouge">org.w3c.dom.Document</code> 接口表示整个 XML 文档，它是 DOM（Document Object Model） API 的核心接口之一。<code class="language-plaintext highlighter-rouge">Document</code> 对象提供了操作 XML 文档的方法，允许您访问和修改文档中的元素、属性和文本内容等。<code class="language-plaintext highlighter-rouge">Document</code> 接口定义了一些独有的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">Element getDocumentElement()</code>: 返回文档的根元素。</li><li><code class="language-plaintext highlighter-rouge">Element createElement(String tagName)</code>: 创建具有指定标签名称的新元素。</li><li><code class="language-plaintext highlighter-rouge">Text createTextNode(String data)</code>: 创建包含指定数据的新文本节点。</li><li><code class="language-plaintext highlighter-rouge">Attr createAttribute(String name)</code>: 创建具有指定名称的新属性节点。</li><li><code class="language-plaintext highlighter-rouge">Element getElementById(String elementId)</code>: 返回具有指定 ID 的元素。</li><li><code class="language-plaintext highlighter-rouge">Element createElementNS(String namespaceURI, String qualifiedName)</code>: 使用指定的命名空间URI和限定名称创建新元素。</li><li><code class="language-plaintext highlighter-rouge">Attr createAttributeNS(String namespaceURI, String qualifiedName)</code>: 使用指定的命名空间URI和限定名称创建新属性。</li><li><code class="language-plaintext highlighter-rouge">Node importNode(Node importedNode, boolean deep)</code>: 将节点从另一个文档导入到当前文档。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">org.w3c.dom.Node</code> 接口表示 DOM（Document Object Model）树中的一个节点，它是 DOM API 的核心接口之一。<code class="language-plaintext highlighter-rouge">Node</code> 接口定义了节点的通用属性和方法，所有 DOM 节点类型都实现了该接口，包括元素节点、文本节点、注释节点等。<code class="language-plaintext highlighter-rouge">Node</code> 接口的主要作用是：</p><ol><li><strong>表示 DOM 树中的一个节点：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口表示 DOM 树中的一个节点，每个节点可以是一个元素、属性、文本内容、注释等。</li><li><strong>提供访问节点的方法：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了一系列方法，用于访问和操作节点的属性、子节点和父节点等。</li><li><strong>定义节点类型：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口定义了表示不同类型节点的常量，如 <code class="language-plaintext highlighter-rouge">ELEMENT_NODE</code>、<code class="language-plaintext highlighter-rouge">TEXT_NODE</code>、<code class="language-plaintext highlighter-rouge">COMMENT_NODE</code> 等。</li><li><strong>节点关系：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了方法来获取节点的父节点、子节点、兄弟节点等关系信息。</li><li><strong>节点操作：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了方法来添加、移除、替换节点，以及克隆节点等操作。</li></ol><p>以下是一些常用的 <code class="language-plaintext highlighter-rouge">Node</code> 接口方法：</p><ol><li><strong>获取节点信息：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">String getNodeName()</code>: 返回节点的名称。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getNodeValue()</code>: 返回节点的值（仅适用于特定类型的节点，如文本节点）。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">short getNodeType()</code>: 返回节点的类型（例如，元素节点、文本节点等）。</strong></li></ul></li><li><strong>获取父节点和子节点：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node getParentNode()</code>: 返回父节点。</li><li><strong><code class="language-plaintext highlighter-rouge">NodeList getChildNodes()</code>: 返回子节点列表。</strong></li><li><code class="language-plaintext highlighter-rouge">Node getFirstChild()</code>: 返回第一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node getLastChild()</code>: 返回最后一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node getNextSibling()</code>: 返回下一个兄弟节点。</li><li><code class="language-plaintext highlighter-rouge">Node getPreviousSibling()</code>: 返回上一个兄弟节点。</li></ul></li><li><strong>操作节点：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node appendChild(Node newChild)</code>: 将节点添加为最后一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node removeChild(Node oldChild)</code>: 从子节点列表中删除指定的子节点。</li><li><code class="language-plaintext highlighter-rouge">Node replaceChild(Node newChild, Node oldChild)</code>: 用新节点替换指定的子节点。</li></ul></li><li><strong>判断节点关系：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">boolean hasChildNodes()</code>: 判断节点是否有子节点。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">boolean hasAttributes()</code>：判断节点是否有属性。</strong></li><li><code class="language-plaintext highlighter-rouge">boolean isSameNode(Node other)</code>: 判断节点是否与另一个节点相同。</li></ul></li><li><strong>其他方法：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node cloneNode(boolean deep)</code>: 复制节点（如果 <code class="language-plaintext highlighter-rouge">deep</code> 为 true，则同时复制子树）。</li><li><code class="language-plaintext highlighter-rouge">Document getOwnerDocument()</code>: 返回拥有当前节点的文档节点。</li></ul></li><li><strong>获取属性节点：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">NamedNodeMap getAttributes()</code>: 返回包含节点所有属性的 <code class="language-plaintext highlighter-rouge">NamedNodeMap</code> 对象。</strong></li></ul></li><li><strong>获取特定属性：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node getAttributeNode(String name)</code>: 返回具有指定名称的属性节点。</li><li><code class="language-plaintext highlighter-rouge">String getAttribute(String name)</code>: 返回具有指定名称的属性的值。</li></ul></li><li><strong>添加和移除属性：</strong><ul><li><code class="language-plaintext highlighter-rouge">void setAttribute(String name, String value)</code>: 设置具有指定名称和值的属性。如果属性已存在，则替换旧值。</li><li><code class="language-plaintext highlighter-rouge">void removeAttribute(String name)</code>: 删除具有指定名称的属性。</li></ul></li><li><strong>判断属性是否存在：</strong><ul><li><code class="language-plaintext highlighter-rouge">boolean hasAttribute(String name)</code>: 判断节点是否具有指定名称的属性。</li></ul></li></ol><p>在 DOM（文档对象模型）中，不同类型的节点用不同的常量值表示，以便于区分节点的类型。这些常量由 <code class="language-plaintext highlighter-rouge">Node</code> 接口定义，可以通过 <code class="language-plaintext highlighter-rouge">Node</code> 接口的静态常量来访问。常见的节点类型包括：</p><ul><li><code class="language-plaintext highlighter-rouge">Node.ELEMENT_NODE</code>：表示元素节点。</li><li><code class="language-plaintext highlighter-rouge">Node.ATTRIBUTE_NODE</code>：表示属性节点。</li><li><code class="language-plaintext highlighter-rouge">Node.TEXT_NODE</code>：表示文本节点。</li><li><code class="language-plaintext highlighter-rouge">Node.COMMENT_NODE</code>：表示注释节点。</li><li><code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code>：表示文档节点。</li></ul><p><code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code> 表示整个文档的根节点，即文档对象（Document Object）。在 DOM 中，文档对象是整个 XML 或 HTML 文档的入口点，通过文档对象可以访问文档的所有内容，包括元素、属性、文本等。通常，使用 <code class="language-plaintext highlighter-rouge">Document</code> 类型的实例表示文档对象。</p><p>例如，可以通过以下方式检查一个节点是否为文档节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="o">...;</span> <span class="c1">// 获取一个节点</span>
<span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Node</span><span class="o">.</span><span class="na">DOCUMENT_NODE</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这是一个文档节点</span>
    <span class="nc">Document</span> <span class="n">document</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Document</span><span class="o">)</span> <span class="n">node</span><span class="o">;</span>
    <span class="c1">// 可以对文档进行操作</span>
<span class="o">}</span>
</code></pre></div></div><p>通过比较节点的类型是否为 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code>，可以判断节点是否为文档节点，从而进行相应的操作。</p><p>如果对<code class="language-plaintext highlighter-rouge">Document</code>进行了修改，要保存，则可以将修改后的内容保存到文件或其他输出流中。保存 <code class="language-plaintext highlighter-rouge">Document</code> 的常用方法是将其转换为字符串形式，然后将字符串写入文件或输出流中。</p><p>下面是一个简单的示例，演示了如何将修改后的 <code class="language-plaintext highlighter-rouge">Document</code> 保存到文件中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从文件、网络流或其他来源获取 XML 输入流</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">DocumentBuilderFactory</span> <span class="n">dbf</span> <span class="o">=</span> <span class="nc">DocumentBuilderFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">DocumentBuilder</span> <span class="n">db</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="na">newDocumentBuilder</span><span class="o">();</span>
<span class="c1">// 使用 DocumentBuilder 解析输入流，获取 Document 实例</span>
<span class="nc">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="c1">// 创建一个 Transformer 对象</span>
<span class="nc">Transformer</span> <span class="n">transformer</span> <span class="o">=</span> <span class="nc">TransformerFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">().</span><span class="na">newTransformer</span><span class="o">();</span>
<span class="nc">DOMSource</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DOMSource</span><span class="o">(</span><span class="n">doc</span><span class="o">);</span>
<span class="c1">// 将字符串写入文件中</span>
<span class="nc">StreamResult</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StreamResult</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"1.xml"</span><span class="o">));</span>
<span class="c1">// 使用 Transformer 将 Document 转换为字符串形式</span>
<span class="n">transformer</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</code></pre></div></div><h2 id="使用sax解析">使用SAX解析</h2><p>使用DOM解析XML的优点是用起来省事，但它的主要缺点是内存占用太大。</p><p>另一种解析XML的方式是SAX。SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p><p>SAX解析会触发一系列事件：</p><ul><li>startDocument：开始读取XML文档；</li><li>startElement：读取到了一个元素，例如<code class="language-plaintext highlighter-rouge">&lt;book&gt;</code>；</li><li>characters：读取到了字符；</li><li>endElement：读取到了一个结束的元素，例如<code class="language-plaintext highlighter-rouge">&lt;/book&gt;</code>；</li><li>endDocument：读取XML文档结束。</li></ul><p>如果用SAX API解析XML，Java代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">SAXParserFactory</span> <span class="n">spf</span> <span class="o">=</span> <span class="nc">SAXParserFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">SAXParser</span> <span class="n">saxParser</span> <span class="o">=</span> <span class="n">spf</span><span class="o">.</span><span class="na">newSAXParser</span><span class="o">();</span>
<span class="n">saxParser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MyHandler</span><span class="o">());</span>
</code></pre></div></div><p>关键代码<code class="language-plaintext highlighter-rouge">SAXParser.parse()</code>除了需要传入一个<code class="language-plaintext highlighter-rouge">InputStream</code>外，还需要传入一个回调对象，这个对象要继承自<code class="language-plaintext highlighter-rouge">DefaultHandler</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyHandler</span> <span class="kd">extends</span> <span class="nc">DefaultHandler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startDocument</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文档开始"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endDocument</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文档结束"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startElement</span><span class="o">(</span><span class="nc">String</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">String</span> <span class="n">localName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">qName</span><span class="o">,</span> <span class="nc">Attributes</span> <span class="n">attributes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"元素："</span><span class="o">,</span> <span class="n">localName</span><span class="o">,</span> <span class="n">qName</span><span class="o">);</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"属性:"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attributes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="s">"  "</span><span class="o">,</span><span class="n">attributes</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="s">"="</span><span class="o">,</span><span class="n">attributes</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endElement</span><span class="o">(</span><span class="nc">String</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">String</span> <span class="n">localName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">qName</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"元素结束:"</span><span class="o">,</span> <span class="n">localName</span><span class="o">,</span> <span class="n">qName</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">characters</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文本:"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">ch</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">length</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">error</span><span class="o">(</span><span class="nc">SAXParseException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"错误:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果要读取<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>节点的文本，我们就必须在解析过程中根据<code class="language-plaintext highlighter-rouge">startElement()</code>和<code class="language-plaintext highlighter-rouge">endElement()</code>定位当前正在读取的节点，可以使用栈结构保存，每遇到一个<code class="language-plaintext highlighter-rouge">startElement()</code>入栈，每遇到一个<code class="language-plaintext highlighter-rouge">endElement()</code>出栈，这样，读到<code class="language-plaintext highlighter-rouge">characters()</code>时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。</p><p>SAX是一种流式解析XML的API；SAX通过事件触发，读取速度快，消耗内存少；调用方必须通过回调方法获得解析过程中的数据。</p><hr /><p>要创建 <code class="language-plaintext highlighter-rouge">SAXParser</code> 对象，通常使用 <code class="language-plaintext highlighter-rouge">SAXParserFactory</code> 工厂类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建 SAXParserFactory 实例</span>
<span class="nc">SAXParserFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">SAXParserFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// 指定是否验证 XML 文件，默认为 false</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setValidating</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 指定是否命名空间感知，默认为 false</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setNamespaceAware</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 创建 SAXParser 实例</span>
<span class="nc">SAXParser</span> <span class="n">saxParser</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newSAXParser</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">SAXParser</code> 类是用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档的类，它实现了 <code class="language-plaintext highlighter-rouge">XMLReader</code> 接口，提供了一系列方法来解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档。以下是 <code class="language-plaintext highlighter-rouge">SAXParser</code> 类的一些常用方法：</p><ul><li><code class="language-plaintext highlighter-rouge">parse(InputSource input, DefaultHandler handler)</code>：解析给定的输入源并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><strong><code class="language-plaintext highlighter-rouge">parse(InputStream is, DefaultHandler dh)</code>：解析给定的输入流并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</strong></li><li><code class="language-plaintext highlighter-rouge">parse(File f, DefaultHandler dh)</code>：解析给定的文件并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><code class="language-plaintext highlighter-rouge">parse(String uri, DefaultHandler dh)</code>：解析给定的 <code class="language-plaintext highlighter-rouge">URI</code> 并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><code class="language-plaintext highlighter-rouge">setContentHandler(ContentHandler handler)</code>：设置内容处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的内容。</li><li><code class="language-plaintext highlighter-rouge">setDTDHandler(DTDHandler handler)</code>：设置 <code class="language-plaintext highlighter-rouge">DTD</code> 处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的 <code class="language-plaintext highlighter-rouge">DTD</code> 声明。</li><li><code class="language-plaintext highlighter-rouge">setEntityResolver(EntityResolver resolver)</code>：设置实体解析器，用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的实体。</li><li><code class="language-plaintext highlighter-rouge">setErrorHandler(ErrorHandler handler)</code>：设置错误处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 解析过程中的错误。</li><li><code class="language-plaintext highlighter-rouge">getXMLReader()</code>：获取与此 <code class="language-plaintext highlighter-rouge">SAXParser</code> 关联的 <code class="language-plaintext highlighter-rouge">XMLReader</code> 对象，用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档。</li><li><code class="language-plaintext highlighter-rouge">getSchema()</code>：获取当前为 <code class="language-plaintext highlighter-rouge">SAXParser</code> 设置的 <code class="language-plaintext highlighter-rouge">XML Schema</code>。</li><li><code class="language-plaintext highlighter-rouge">isNamespaceAware()</code>：返回解析器是否为命名空间感知的布尔值。</li><li><code class="language-plaintext highlighter-rouge">isValidating()</code>：返回解析器是否验证 <code class="language-plaintext highlighter-rouge">XML</code> 内容的布尔值。</li></ul><p>这些方法用于配置和操作 <code class="language-plaintext highlighter-rouge">SAXParser</code> 实例，以便解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档并处理其内容。</p><p><code class="language-plaintext highlighter-rouge">DefaultHandler</code> 是 <code class="language-plaintext highlighter-rouge">SAX</code> 解析器的默认处理程序，它实现了 <code class="language-plaintext highlighter-rouge">ContentHandler</code>、<code class="language-plaintext highlighter-rouge">DTDHandler</code>、<code class="language-plaintext highlighter-rouge">EntityResolver</code> 和 <code class="language-plaintext highlighter-rouge">ErrorHandler</code> 接口。这些接口定义了处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容和解析过程中可能出现的各种情况的方法。以下是 <code class="language-plaintext highlighter-rouge">DefaultHandler</code> 中一些重要的方法和作用：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">startDocument()</code>：在解析文档开始时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">endDocument()</code>：在解析文档结束时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">startElement(String uri, String localName, String qName, Attributes attributes)</code>：在解析元素开始时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">endElement(String uri, String localName, String qName)</code>：在解析元素结束时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">characters(char[] ch, int start, int length)</code>：在解析字符数据时调用。</strong></li><li><code class="language-plaintext highlighter-rouge">startPrefixMapping(String prefix, String uri)</code>：在解析命名空间前缀映射时调用。</li><li><code class="language-plaintext highlighter-rouge">endPrefixMapping(String prefix)</code>：在解析命名空间前缀映射结束时调用。</li><li><code class="language-plaintext highlighter-rouge">processingInstruction(String target, String data)</code>：在解析处理指令时调用。</li><li><code class="language-plaintext highlighter-rouge">skippedEntity(String name)</code>：在解析实体时调用。</li><li><code class="language-plaintext highlighter-rouge">warning(SAXParseException e)</code>：在解析过程中遇到警告时调用。</li><li><strong><code class="language-plaintext highlighter-rouge">error(SAXParseException e)</code>：在解析过程中遇到可恢复错误时调用。</strong></li><li><code class="language-plaintext highlighter-rouge">fatalError(SAXParseException e)</code>：在解析过程中遇到致命错误时调用。</li></ul><p><code class="language-plaintext highlighter-rouge">DefaultHandler</code> 的作用是提供这些方法的默认实现，可以根据需要覆盖这些方法来处理 <code class="language-plaintext highlighter-rouge">XML</code> 解析过程中的事件。通常，可以创建一个继承自 <code class="language-plaintext highlighter-rouge">DefaultHandler</code> 的类，并重写其中的方法来实现自定义的 <code class="language-plaintext highlighter-rouge">XML</code> 处理逻辑。</p><p><code class="language-plaintext highlighter-rouge">SAXParser</code> 本身并不能直接修改 <code class="language-plaintext highlighter-rouge">XML</code>，因为 <code class="language-plaintext highlighter-rouge">SAXParser</code> 是一种流式解析器，它按顺序读取 <code class="language-plaintext highlighter-rouge">XML</code> 文件并触发相应的事件，而不会将整个 <code class="language-plaintext highlighter-rouge">XML</code> 文档加载到内存中。因此，如果需要修改 <code class="language-plaintext highlighter-rouge">XML</code>，通常需要借助其他 <code class="language-plaintext highlighter-rouge">API</code> 或方法来实现。</p><h2 id="使用stax解析">使用StAX解析</h2><p>StAX（Streaming API for XML）是用于处理 XML 的一种流式处理 API。与传统的 DOM（Document Object Model）和 SAX（Simple API for XML）相比，StAX 提供了一种更灵活的方式来读取和写入 XML 数据。</p><p>使用 StAX，可以逐个事件地处理 XML 文档，而不需要将整个文档加载到内存中（像 DOM 那样），也不需要像 SAX 那样完全依赖事件回调模型。相反，StAX 允许以迭代器的方式逐个读取或写入 XML 元素，使得处理 XML 数据变得更加简单和高效。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">XMLInputFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">XMLInputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">XMLStreamReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createXMLStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>

<span class="k">while</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">START_ELEMENT</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"元素： "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">());</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  Attribute: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">CHARACTERS</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">reader</span><span class="o">.</span><span class="na">isWhiteSpace</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文本: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">END_ELEMENT</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"元素结束: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">());</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>要使用 StAX 修改 XML，需要创建一个 <code class="language-plaintext highlighter-rouge">XMLInputFactory</code> 来读取 XML 文件，并创建一个 <code class="language-plaintext highlighter-rouge">XMLOutputFactory</code> 来写入修改后的 XML。示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 创建输入和输出的 XML 工厂</span>
<span class="nc">XMLInputFactory</span> <span class="n">inputFactory</span> <span class="o">=</span> <span class="nc">XMLInputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">XMLOutputFactory</span> <span class="n">outputFactory</span> <span class="o">=</span> <span class="nc">XMLOutputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

<span class="c1">// 创建 XML 输入和输出流</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"book2.xml"</span><span class="o">);</span>
<span class="nc">XMLStreamReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">inputFactory</span><span class="o">.</span><span class="na">createXMLStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">XMLStreamWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">outputFactory</span><span class="o">.</span><span class="na">createXMLStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
<span class="n">writer</span><span class="o">.</span><span class="na">writeStartDocument</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">,</span> <span class="s">"1.0"</span><span class="o">);</span> <span class="c1">// 写入XML声明</span>
<span class="c1">// 处理元素</span>
<span class="k">while</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">START_ELEMENT</span><span class="o">:</span>
            <span class="c1">// 处理开始元素</span>
            <span class="nc">String</span> <span class="n">elementName</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">();</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">elementName</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"book"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elementName</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 修改元素内容</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeStartElement</span><span class="o">(</span><span class="s">"book2"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 复制其他元素</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeStartElement</span><span class="o">(</span><span class="n">elementName</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeAttribute</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">getAttributeLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="n">reader</span><span class="o">.</span><span class="na">getAttributeValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>

        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">CHARACTERS</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">reader</span><span class="o">.</span><span class="na">isWhiteSpace</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="s">"isbn"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())){</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">writeCharacters</span><span class="o">(</span><span class="s">"666888"</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">writeCharacters</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">END_ELEMENT</span><span class="o">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">writeEndElement</span><span class="o">();</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 关闭流</span>
<span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>这段代码的目标是读取一个 XML 文件并将其内容修改后写入另一个 XML 文件。在处理元素内容时，如果当前元素是 <code class="language-plaintext highlighter-rouge">isbn</code>，则将其内容修改为 “666888”，如果当前元素是<code class="language-plaintext highlighter-rouge">book</code>则修改为<code class="language-plaintext highlighter-rouge">book2</code>。</p><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 是用于读取 XML 数据的接口，它允许逐个事件地读取 XML 文档的内容，并提供了一种低级别的、基于流的方式来解析 XML。通过 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code>，可以逐步遍历 XML 文档的元素、属性、文本内容等，并根据需要对文档进行处理，如提取数据、修改内容等操作。这种基于流的解析方式相比于基于文档对象模型（DOM）的解析方式，更加高效，尤其适用于处理大型 XML 文件。</p><p><code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 提供了许多方法来读取 XML 文档的不同部分，以下是一些常用的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">boolean hasNext()</code>：检查是否还有更多的事件要处理。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int next()</code>：移动到下一个 XML 事件，并返回事件的类型。</strong></li><li><code class="language-plaintext highlighter-rouge">int getEventType()</code>：返回当前事件的类型。</li><li><code class="language-plaintext highlighter-rouge">boolean isStartElement()</code>：检查当前事件是否是开始元素。</li><li><code class="language-plaintext highlighter-rouge">boolean isCharacters()</code>：检查当前事件是否是字符数据。</li><li><code class="language-plaintext highlighter-rouge">boolean isEndElement()</code>：检查当前事件是否是结束元素。</li><li><code class="language-plaintext highlighter-rouge">String getLocalName()</code>：返回当前元素的本地名称。</li><li><strong><code class="language-plaintext highlighter-rouge">int getAttributeCount()</code>：返回当前元素的属性数。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getAttributeLocalName(int index)</code>：返回指定索引处属性的本地名称。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getAttributeValue(int index)</code>：返回指定索引处属性的值。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getText()</code>：返回当前元素的文本内容。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">boolean isWhiteSpace()</code>：检查当前解析器位置是否位于空白字符上。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void close()</code>：关闭 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code>。</strong></li></ul><p>这些方法可以在处理 XML 文档时导航并提取所需的信息。</p><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 是用于写入 XML 数据的接口，它允许逐个事件地生成 XML 文档的内容，并提供了一种低级别的、基于流的方式来生成 XML。通过 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code>，可以逐步构建 XML 文档的元素、属性、文本内容等，并生成符合 XML 规范的 XML 数据。这种基于流的生成方式相比于基于文档对象模型（DOM）的生成方式，更加高效，尤其适用于生成大型 XML 文件。</p><p>常用的 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 方法包括：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">writeStartDocument(String version, String encoding)</code>：写入 XML 声明。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeStartElement(String localName)</code>：写入开始元素。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeAttribute(String localName, String value)</code>：写入元素属性。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeCharacters(String text)</code>：写入文本内容。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeEndElement()</code>：写入结束元素。</strong></li><li><code class="language-plaintext highlighter-rouge">writeEndDocument()</code>：写入 XML 结束标记。</li><li><code class="language-plaintext highlighter-rouge">flush()</code>：刷新缓冲区，确保所有数据都被写入底层流。</li><li><strong><code class="language-plaintext highlighter-rouge">close()</code>：关闭 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code>。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamConstants</code> 是一个接口，定义了一组整数常量，用于表示 XML 解析器生成的各种事件类型。这些常量用于与 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 和 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 一起使用，以便在处理 XML 文档时识别不同类型的事件。通过这些常量，可以方便地检查当前事件的类型，并根据需要执行相应的操作。</p><p><code class="language-plaintext highlighter-rouge">XMLStreamConstants</code> 提供了以下常量：</p><ul><li><code class="language-plaintext highlighter-rouge">START_ELEMENT</code>：表示开始元素事件。</li><li><code class="language-plaintext highlighter-rouge">END_ELEMENT</code>：表示结束元素事件。</li><li><code class="language-plaintext highlighter-rouge">CHARACTERS</code>：表示字符数据事件。</li><li><code class="language-plaintext highlighter-rouge">ATTRIBUTE</code>：表示属性事件。</li><li><code class="language-plaintext highlighter-rouge">NAMESPACE</code>：表示命名空间事件。</li><li><code class="language-plaintext highlighter-rouge">START_DOCUMENT</code>：表示开始文档事件。</li><li><code class="language-plaintext highlighter-rouge">END_DOCUMENT</code>：表示结束文档事件。</li><li><code class="language-plaintext highlighter-rouge">PROCESSING_INSTRUCTION</code>：表示处理指令事件。</li><li><code class="language-plaintext highlighter-rouge">COMMENT</code>：表示注释事件。</li><li><code class="language-plaintext highlighter-rouge">DTD</code>：表示 DTD 事件。</li><li><code class="language-plaintext highlighter-rouge">ENTITY_REFERENCE</code>：表示实体引用事件。</li><li><code class="language-plaintext highlighter-rouge">CDATA</code>：表示 CDATA 事件。</li><li><code class="language-plaintext highlighter-rouge">SPACE</code>：表示空格事件。</li></ul><h2 id="使用jackson">使用Jackson</h2><p>XML文档的结构：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p>完全可以对应到一个定义好的JavaBean中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>Jackson第三方库可以轻松做到XML到JavaBean的转换。要使用Jackson，先添加一个Maven的依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后，定义好JavaBean，就可以用下面几行代码解析：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/book.xml"</span><span class="o">);</span>
<span class="nc">JacksonXmlModule</span> <span class="n">module</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JacksonXmlModule</span><span class="o">();</span>
<span class="nc">XmlMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlMapper</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
<span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">author</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">tags</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">pubDate</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">XmlMapper</code>可以用<code class="language-plaintext highlighter-rouge">readValue(InputStream, Class)</code>直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
Java核心技术
Cay S. Horstmann
1234567
[Java, Network]
null
</code></pre></div></div><p>如果要解析的数据格式不是<code class="language-plaintext highlighter-rouge">Jackson</code>内置的标准格式，那么需要编写一点额外的扩展来告诉<code class="language-plaintext highlighter-rouge">Jackson</code>如何自定义解析，可以参考<a href="https://github.com/FasterXML/jackson">Jackson</a>的<a href="https://github.com/FasterXML/jackson-annotations">官方文档</a>。读取属性：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.MapperFeature</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.JacksonXmlModule</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.XmlMapper</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
        <span class="nc">JacksonXmlModule</span> <span class="n">module</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JacksonXmlModule</span><span class="o">();</span>
        <span class="c1">// 默认使用“未包装”列表:</span>
        <span class="c1">//module.setDefaultUseWrapper(false);</span>
        <span class="nc">XmlMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlMapper</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
        <span class="c1">//自动忽略无法对应pojo的字段</span>
        <span class="c1">//mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span>
        <span class="c1">//字段为null，自动忽略，不再序列化</span>
        <span class="c1">//mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>
        <span class="c1">//XML标签名:使用骆驼命名的属性名，</span>
        <span class="c1">//mapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE);</span>
        <span class="c1">//设置转换模式</span>
        <span class="n">mapper</span><span class="o">.</span><span class="na">enable</span><span class="o">(</span><span class="nc">MapperFeature</span><span class="o">.</span><span class="na">USE_STD_BEAN_NAMING</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">author</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的属性lang的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">lang</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的属性aa的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">aa</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">tags</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">pubDate</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">localName</span> <span class="o">=</span> <span class="s">"isbn"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BookAttr</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">BookAttr</span> <span class="o">{</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">isAttribute</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">localName</span> <span class="o">=</span> <span class="s">"lang"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">lang</span><span class="o">;</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">isAttribute</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">localName</span> <span class="o">=</span> <span class="s">"aa"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">aa</span><span class="o">;</span>
    <span class="c1">//测试一下</span>
    <span class="nd">@JacksonXmlText</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="json">JSON</h1><p>XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。</p><p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">id</span><span class="dl">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Java核心技术</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">author</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">firstName</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Abc</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">lastName</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Xyz</span><span class="dl">"</span>
    <span class="p">},</span>
    <span class="dl">"</span><span class="s2">isbn</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1234567</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">tags</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Java</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Network</span><span class="dl">"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div><p>JSON作为数据传输的格式，有几个显著的优点：</p><ul><li>JSON只允许使用UTF-8编码，不存在编码问题；</li><li>JSON只允许使用双引号作为key，特殊字符用<code class="language-plaintext highlighter-rouge">\</code>转义，格式简单；</li><li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li></ul><p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p><ul><li>键值对：<code class="language-plaintext highlighter-rouge">{"key": value}</code></li><li>数组：<code class="language-plaintext highlighter-rouge">[1, 2, 3]</code></li><li>字符串：<code class="language-plaintext highlighter-rouge">"abc"</code></li><li>数值（整数和浮点数）：<code class="language-plaintext highlighter-rouge">12.34</code></li><li>布尔值：<code class="language-plaintext highlighter-rouge">true</code>或<code class="language-plaintext highlighter-rouge">false</code></li><li>空值：<code class="language-plaintext highlighter-rouge">null</code></li></ul><p>浏览器直接支持使用JavaScript对JSON进行读写：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JSON string to JavaScript object:</span>
<span class="nx">jsObj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">);</span>

<span class="c1">// JavaScript object to JSON string:</span>
<span class="nx">jsonStr</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">jsObj</span><span class="p">);</span>
</code></pre></div></div><p>开发Web应用的时候，使用JSON作为数据传输，在浏览器端非常方便。因为JSON天生适合JavaScript处理，绝大多数REST API都选择JSON作为数据传输格式。</p><p>在Java中，针对JSON也有标准的JSR 353 API。常用的用于解析JSON的第三方库有：<code class="language-plaintext highlighter-rouge">Jackson</code>、<code class="language-plaintext highlighter-rouge">Gson</code>、<code class="language-plaintext highlighter-rouge">Fastjson</code>。</p><p>使用<code class="language-plaintext highlighter-rouge">Jackson</code>：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>就可以使用下面的代码解析一个JSON文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.json"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
        <span class="c1">// 反序列化时忽略不存在的JavaBean属性:</span>
        <span class="n">mapper</span><span class="o">.</span><span class="na">configure</span><span class="o">(</span><span class="nc">DeserializationFeature</span><span class="o">.</span><span class="na">FAIL_ON_UNKNOWN_PROPERTIES</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"Book{id="</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", author="</span> <span class="o">+</span> <span class="n">author</span> <span class="o">+</span> <span class="s">", isbn='"</span> <span class="o">+</span> <span class="n">isbn</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", tags="</span> <span class="o">+</span> <span class="n">tags</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>核心代码是创建一个<code class="language-plaintext highlighter-rouge">ObjectMapper</code>对象。关闭<code class="language-plaintext highlighter-rouge">DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>功能使得解析时如果JavaBean不存在该属性时解析不会报错。</p><p>还可以直接用Map接收：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.json"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div><hr /><p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
</code></pre></div></div><p>还可以生成带缩进和换行的JSON：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span><span class="o">=</span><span class="n">mapper</span><span class="o">.</span><span class="na">writerWithDefaultPrettyPrinter</span><span class="o">().</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div><hr /><p>要把JSON的某些值解析为特定的Java对象，例如<code class="language-plaintext highlighter-rouge">LocalDate</code>，也是完全可以的。例如：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Java核心技术</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">pubDate</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2016-09-01</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div><p>要解析为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">LocalDate</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>只需要引入标准的JSR 310关于<code class="language-plaintext highlighter-rouge">JavaTime</code>的数据格式定义至Maven：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-jsr310 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.datatype<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-datatype-jsr310<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后，在创建<code class="language-plaintext highlighter-rouge">ObjectMapper</code>时，注册一个新的<code class="language-plaintext highlighter-rouge">JavaTimeModule</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">().</span><span class="na">registerModule</span><span class="o">(</span><span class="k">new</span> <span class="nc">JavaTimeModule</span><span class="o">());</span>
</code></pre></div></div><p>还可以自定义解析，假设<code class="language-plaintext highlighter-rouge">Book</code>类的<code class="language-plaintext highlighter-rouge">isbn</code>是一个<code class="language-plaintext highlighter-rouge">BigInteger</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nc">BigInteger</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>但JSON数据并不是标准的整形格式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
    <span class="s">"name"</span><span class="o">:</span> <span class="s">"Java核心技术"</span><span class="o">,</span>
    <span class="s">"isbn"</span><span class="o">:</span> <span class="s">"978-7-111-54742-6"</span>
<span class="o">}</span>
</code></pre></div></div><p>直接解析，肯定报错。这时，需要自定义一个<code class="language-plaintext highlighter-rouge">IsbnDeserializer</code>，用于解析含有非数字的字符串：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IsbnDeserializer</span> <span class="kd">extends</span> <span class="nc">JsonDeserializer</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">JsonParser</span> <span class="n">p</span><span class="o">,</span> <span class="nc">DeserializationContext</span> <span class="n">ctxt</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">JsonProcessingException</span> <span class="o">{</span>
        <span class="c1">// 读取原始的JSON字符串内容:</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValueAsString</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">BigInteger</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">JsonParseException</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后，在<code class="language-plaintext highlighter-rouge">Book</code>类中使用注解标注：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 表示反序列化isbn时使用自定义的IsbnDeserializer:</span>
    <span class="nd">@JsonDeserialize</span><span class="o">(</span><span class="n">using</span> <span class="o">=</span> <span class="nc">IsbnDeserializer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>类似的，自定义序列化时我们需要自定义一个<code class="language-plaintext highlighter-rouge">IsbnSerializer</code>，然后在<code class="language-plaintext highlighter-rouge">Book</code>类中标注<code class="language-plaintext highlighter-rouge">@JsonSerialize(using = ...)</code>即可。</p><p>在反序列化时，<code class="language-plaintext highlighter-rouge">Jackson</code>要求Java类<strong>需要一个默认的无参数构造方法</strong>，否则，无法直接实例化此类。存在带参数构造方法的类，如果要反序列化，注意再提供一个无参数构造方法。</p><p>对于<code class="language-plaintext highlighter-rouge">enum</code>字段，Jackson按String类型处理，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">DayOfWeek</span> <span class="n">start</span> <span class="o">=</span> <span class="no">MONDAY</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>序列化为：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MONDAY</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div><p>对于<code class="language-plaintext highlighter-rouge">record</code>类型（<strong>Java 14</strong> ），Jackson会自动找出它的带参数构造方法，并根据JSON的key进行匹配，可直接反序列化。对<code class="language-plaintext highlighter-rouge">record</code>类型的支持需要版本<code class="language-plaintext highlighter-rouge">2.12.0</code>以上。</p><p><strong><code class="language-plaintext highlighter-rouge">TypeReference</code></strong></p><p><code class="language-plaintext highlighter-rouge">TypeReference</code> 是 Jackson 库中的一个抽象类，用于在序列化和反序列化过程中提供类型信息。由于 Java 的类型擦除机制，泛型类型的信息在运行时会被丢失，因此 <code class="language-plaintext highlighter-rouge">TypeReference</code> 用于保留这些信息，确保 Jackson 能够正确处理泛型类型。</p><p>主要用途</p><p><strong>反序列化复杂类型</strong>：在需要将 JSON 字符串反序列化为复杂类型（如泛型 List、Map 或自定义对象）时，<code class="language-plaintext highlighter-rouge">TypeReference</code> 可以帮助指定具体的类型。</p><p><strong>支持泛型类型</strong>：它允许你在匿名内部类中定义泛型类型，从而避免在反序列化时遇到类型擦除问题。</p><p>使用示例：</p><p>反序列化列表</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectMapper</span> <span class="n">objectMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">"[{\"name\":\"John\"}, {\"name\":\"Doe\"}]"</span><span class="o">;</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">json</span><span class="o">,</span> <span class="k">new</span> <span class="nc">TypeReference</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;&gt;()</span> <span class="o">{});</span>
</code></pre></div></div><p>反序列化映射</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">"{\"key1\":\"value1\", \"key2\":\"value2\"}"</span><span class="o">;</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">json</span><span class="o">,</span> <span class="k">new</span> <span class="nc">TypeReference</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;&gt;()</span> <span class="o">{});</span>
</code></pre></div></div><p>反序列化嵌套类型</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="s">"{\"data\":{\"id\":1,\"name\":\"Item 1\"}}"</span><span class="o">;</span>

<span class="nc">ResponseWrapper</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">json</span><span class="o">,</span> <span class="k">new</span> <span class="nc">TypeReference</span><span class="o">&lt;</span><span class="nc">ResponseWrapper</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;&gt;()</span> <span class="o">{});</span>
</code></pre></div></div><p>注意事项</p><p><strong>匿名内部类</strong>：使用 <code class="language-plaintext highlighter-rouge">TypeReference</code> 时，通常以匿名内部类的形式实例化，以保持类型信息。</p><p><strong>类型安全</strong>：使用 <code class="language-plaintext highlighter-rouge">TypeReference</code> 可以确保反序列化后的对象类型与预期一致，减少运行时类型转换异常的风险。</p><p><code class="language-plaintext highlighter-rouge">TypeReference</code> 是处理泛型类型时的重要工具，使得 Jackson 能够在反序列化过程中正确识别类型信息。通过使用 <code class="language-plaintext highlighter-rouge">TypeReference</code>，你可以灵活地处理复杂数据结构，确保数据的准确性和类型安全。</p><h1 id="jdbc">JDBC</h1><p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity）</p><p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p><p>在Java代码中如果要访问MySQL，必须编写代码操作JDBC接口。JDBC接口是Java标准库自带的，所以可以直接编译。而具体的JDBC驱动是由数据库厂商提供的，例如，MySQL的JDBC驱动由Oracle提供。因此，访问某个具体的数据库，只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库，因为他们都提供了标准的JDBC驱动。</p><p>从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类。</p><p>一个MySQL的JDBC的驱动就是一个jar包，本身也是纯Java编写的。编写的代码只需要引用Java标准库提供的<code class="language-plaintext highlighter-rouge">java.sql</code>包下面的相关接口，由此再间接地通过MySQL驱动的jar包通过网络访问MySQL服务器，所有复杂的网络通讯都被封装到JDBC驱动中，因此，Java程序本身只需要引入一个MySQL驱动的jar包就可以正常访问MySQL服务器</p><p>使用JDBC的好处是：</p><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</li><li>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li></ul><p>mysql的JDBC驱动：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>mysql<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>mysql-connector-java<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.1.47<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>runtime<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>依赖的<code class="language-plaintext highlighter-rouge">scope</code>是<code class="language-plaintext highlighter-rouge">runtime</code>，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。如果把<code class="language-plaintext highlighter-rouge">runtime</code>改成<code class="language-plaintext highlighter-rouge">compile</code>，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似<code class="language-plaintext highlighter-rouge">com.mysql.jdbc.Connection</code>这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为<code class="language-plaintext highlighter-rouge">compile</code>。</p><h2 id="连接数据库">连接数据库</h2><p><code class="language-plaintext highlighter-rouge">Connection</code>代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。打开一个<code class="language-plaintext highlighter-rouge">Connection</code>时，需要准备URL、用户名和口令，才能成功连接到数据库。</p><p>URL是由数据库厂商指定的格式，例如，MySQL的URL是：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key1=value1&amp;key2=value2
</code></pre></div></div><p>假设数据库运行在本机<code class="language-plaintext highlighter-rouge">localhost</code>，端口使用标准的<code class="language-plaintext highlighter-rouge">3306</code>，数据库名称是<code class="language-plaintext highlighter-rouge">studentdb</code>，那么URL如下：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jdbc:mysql://localhost:3306/studentdb?useSSL=false&amp;characterEncoding=utf8
</code></pre></div></div><p>后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码（注意MySQL的UTF-8是<code class="language-plaintext highlighter-rouge">utf8</code>）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JDBC连接的URL, 不同数据库有不同的格式:</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3306/studentdb?useSSL=false&amp;characterEncoding=utf8"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">user</span> <span class="o">=</span> <span class="s">"root"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"123456"</span><span class="o">;</span>
<span class="c1">// 获取连接:</span>
<span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="c1">// 关闭连接:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DriverManager</code>会自动扫描<code class="language-plaintext highlighter-rouge">classpath</code>，找到所有的JDBC驱动，然后根据传入的URL自动挑选一个合适的驱动。</p><p>因为JDBC连接是一种昂贵的资源，所以使用后要及时释放。使用<code class="language-plaintext highlighter-rouge">try (resource)</code>来自动释放JDBC连接是一个好方法。</p><h2 id="查询">查询</h2><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT xuehao, name, sex, age FROM student WHERE sex='男'"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">ResultSetMetaData</span> <span class="n">metaData</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getMetaData</span><span class="o">();</span><span class="c1">//返回列名</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">metaData</span><span class="o">.</span><span class="na">getColumnCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//列从1开始</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">metaData</span><span class="o">.</span><span class="na">getColumnName</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="s">"\t"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 注意：索引从1开始</span>
                <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
                <span class="nc">String</span> <span class="n">sex</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"sex"</span><span class="o">);</span><span class="c1">//使用名称访问</span>
                <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="s">"age"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">id</span><span class="o">+</span><span class="s">"\t"</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">"\t"</span><span class="o">+</span><span class="n">sex</span><span class="o">+</span><span class="s">"\t"</span><span class="o">+</span><span class="n">age</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Statement</code>对象，用于执行一个查询，executeQuery传入一个SQL字符串，并提交查询返回结果。</p><p><code class="language-plaintext highlighter-rouge">ResultSetMetaData</code>和<code class="language-plaintext highlighter-rouge">ResultSet</code>获取列时，索引从<code class="language-plaintext highlighter-rouge">1</code>开始而不是<code class="language-plaintext highlighter-rouge">0</code>。</p><p>可以封装为<code class="language-plaintext highlighter-rouge">List</code>，不建议，为了后续维护方便，还是用<code class="language-plaintext highlighter-rouge">JavaBean</code>比较好。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT xuehao, name, sex, age FROM student WHERE sex='男'"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">ResultSetMetaData</span> <span class="n">metaData</span> <span class="o">=</span> <span class="n">rs</span><span class="o">.</span><span class="na">getMetaData</span><span class="o">();</span><span class="c1">//返回列名</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">metaData</span><span class="o">.</span><span class="na">getColumnCount</span><span class="o">();</span>
            <span class="nc">String</span> <span class="o">[]</span><span class="n">columnName</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span><span class="c1">//列从1开始</span>
                <span class="n">columnName</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">metaData</span><span class="o">.</span><span class="na">getColumnName</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">line</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;&gt;();</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">line</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">columnName</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">rs</span><span class="o">.</span><span class="na">getObject</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
                <span class="o">}</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">line</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="sql注入">SQL注入</h2><p>使用<code class="language-plaintext highlighter-rouge">Statement</code>拼字符串非常容易引发SQL注入的问题，这是因为SQL参数往往是从方法参数传入的。假设用户登录的验证方法如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pass</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="s">"SELECT * FROM user WHERE login='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"' AND pass='"</span> <span class="o">+</span> <span class="n">pass</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，参数<code class="language-plaintext highlighter-rouge">name</code>和<code class="language-plaintext highlighter-rouge">pass</code>通常都是Web页面输入后由程序接收到的。</p><p>如果用户的输入是程序期待的值，就可以拼出正确的SQL。例如：name = <code class="language-plaintext highlighter-rouge">"bob"</code>，pass = <code class="language-plaintext highlighter-rouge">"1234"</code>：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">login</span><span class="o">=</span><span class="s1">'bob'</span> <span class="k">AND</span> <span class="n">pass</span><span class="o">=</span><span class="s1">'1234'</span>
</code></pre></div></div><p>但是，如果用户的输入是一个精心构造的字符串，就可以拼出意想不到的SQL，这个SQL也是正确的，但它查询的条件不是程序设计的意图。例如：<code class="language-plaintext highlighter-rouge">name</code> = <code class="language-plaintext highlighter-rouge">bob' OR pass=</code>, <code class="language-plaintext highlighter-rouge">pass</code> = <code class="language-plaintext highlighter-rouge">' OR pass='</code>：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">user</span> <span class="k">WHERE</span> <span class="n">login</span><span class="o">=</span><span class="s1">'bob'</span> <span class="k">OR</span> <span class="n">pass</span><span class="o">=</span><span class="s1">' AND pass='</span> <span class="k">OR</span> <span class="n">pass</span><span class="o">=</span><span class="s1">''</span>
</code></pre></div></div><p>这个SQL语句执行的时候，根本不用判断口令是否正确，这样一来，登录就形同虚设。</p><p>要避免SQL注入攻击，要对所有字符串参数进行转义，使用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>可以<strong>完全避免SQL注入</strong>的问题，<code class="language-plaintext highlighter-rouge">PreparedStatement</code>始终使用<code class="language-plaintext highlighter-rouge">?</code>作为占位符，在设置参数值时会自动转义特殊字符，比如单引号、双引号等。这样可以确保参数值不会被误解为 SQL 代码的一部分，从而进一步增强了防御能力，还能高效利用数据库本身对查询的缓存。上述登录SQL如果用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>可以改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">User</span> <span class="nf">login</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pass</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM user WHERE login=? AND pass=?"</span><span class="o">;</span>
    <span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span><span class="c1">//设置第一个问号为name</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">pass</span><span class="o">);</span>
	<span class="nc">ResultSet</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>所以，使用Java对数据库进行操作时，必须使用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>。</p><h2 id="数据类型">数据类型</h2><p>使用JDBC的时候，需要在Java数据类型和SQL数据类型之间进行转换。JDBC在<code class="language-plaintext highlighter-rouge">java.sql.Types</code>定义了一组常量来表示如何映射SQL数据类型，平时使用的类型通常也就以下几种：</p><table><thead><tr><th style="text-align: left">SQL数据类型</th><th style="text-align: left">Java数据类型</th></tr></thead><tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIT</code>, <code class="language-plaintext highlighter-rouge">BOOL</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">boolean</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">INTEGER</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">int</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">long</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">REAL</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">float</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">FLOAT</code>, <code class="language-plaintext highlighter-rouge">DOUBLE</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">double</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">CHAR</code>, <code class="language-plaintext highlighter-rouge">VARCHAR</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">String</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">DECIMAL</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">BigDecimal</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">DATE</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">java.sql.Date</code>, <code class="language-plaintext highlighter-rouge">LocalDate</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">TIME</code></td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">java.sql.Time</code>, <code class="language-plaintext highlighter-rouge">LocalTime</code></td></tr></tbody></table><p>注意：只有最新的JDBC驱动才支持<code class="language-plaintext highlighter-rouge">LocalDate</code>和<code class="language-plaintext highlighter-rouge">LocalTime</code>。</p><h2 id="更新">更新</h2><p>插入操作是<code class="language-plaintext highlighter-rouge">INSERT</code>，即插入一条新记录，更新与删除也是一样的。通过JDBC进行插入，本质上也是用<code class="language-plaintext highlighter-rouge">PreparedStatement</code>执行一条SQL语句，不过最后执行的不是<code class="language-plaintext highlighter-rouge">executeQuery()</code>，而是<code class="language-plaintext highlighter-rouge">executeUpdate()</code>。当成功执行<code class="language-plaintext highlighter-rouge">executeUpdate()</code>后，返回值是<code class="language-plaintext highlighter-rouge">int</code>，表示插入的记录数量。</p><p>如果数据库的表设置了自增主键，那么在执行<code class="language-plaintext highlighter-rouge">INSERT</code>语句时，并不需要指定主键，数据库会自动分配主键。若希望以不指定列名的形式插入，则可以用0作为主键值表示自增。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span><span class="o">=</span><span class="s">"INSERT INTO student values(?,?,?,?,?,?)"</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="nc">Statement</span><span class="o">.</span><span class="na">RETURN_GENERATED_KEYS</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"张四"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="s">"男"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">20</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="s">"江苏南京"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="s">"计算机"</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
    <span class="c1">// 获取自动生成的主键值</span>
    <span class="nc">ResultSet</span> <span class="n">generatedKeys</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">getGeneratedKeys</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">generatedKeys</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">primaryKey</span> <span class="o">=</span> <span class="n">generatedKeys</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"插入的主键值为: "</span> <span class="o">+</span> <span class="n">primaryKey</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>对于使用自增主键的程序，要获取插入后的自增主键的值，可以在创建<code class="language-plaintext highlighter-rouge">PreparedStatement</code>的时候，指定一个<code class="language-plaintext highlighter-rouge">RETURN_GENERATED_KEYS</code>标志位，表示JDBC驱动必须返回插入的自增主键。</p><p>然后调用<code class="language-plaintext highlighter-rouge">getGeneratedKeys()</code>获取一个<code class="language-plaintext highlighter-rouge">ResultSet</code>对象，这个对象包含了数据库自动生成的主键的值，读取该对象的每一行来获取自增主键的值。如果一次插入多条记录，那么这个<code class="language-plaintext highlighter-rouge">ResultSet</code>对象就会有多行返回值。如果插入时有多列自增，那么<code class="language-plaintext highlighter-rouge">ResultSet</code>对象的每一行都会对应多个自增值（自增列不一定必须是主键）。</p><h2 id="事务">事务</h2><p>数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的<code class="language-plaintext highlighter-rouge">synchronized</code>同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性：</p><ul><li>Atomicity：原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li>Consistency：一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li>Isolation：隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li>Durability：持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>数据库事务可以并发执行，而数据库系统从效率考虑，对事务定义了不同的隔离级别。SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th style="text-align: left">Isolation Level</th><th style="text-align: left">脏读（Dirty Read）</th><th style="text-align: left">不可重复读（Non Repeatable Read）</th><th style="text-align: left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td style="text-align: left">Read Uncommitted</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left">Read Committed</td><td style="text-align: left">-</td><td style="text-align: left">Yes</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left">Repeatable Read</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Yes</td></tr><tr><td style="text-align: left">Serializable</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">-</td></tr></tbody></table><p><strong>Read Uncommitted</strong>是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。</p><p>在<strong>Read Committed</strong>隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>在<strong>Repeatable Read</strong>隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p><strong>Serializable</strong>是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><p><strong>默认隔离级别</strong></p><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用<code class="language-plaintext highlighter-rouge">InnoDB</code>，默认的隔离级别是Repeatable Read。</p><hr /><p>对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。</p><p>假设小明准备给小红支付100，两人在数据库中的记录主键分别是<code class="language-plaintext highlighter-rouge">123</code>和<code class="language-plaintext highlighter-rouge">456</code>，那么用两条SQL语句操作如下：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">accounts</span> <span class="k">SET</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">-</span> <span class="mi">100</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">123</span> <span class="k">AND</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">accounts</span> <span class="k">SET</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">100</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">456</span><span class="p">;</span>
</code></pre></div></div><p>这两条语句必须以事务方式执行才能保证业务的正确性，因为一旦第一条SQL执行成功而第二条SQL失败的话，系统的钱就会凭空减少100，而有了事务，要么这笔转账成功；要么转账失败，双方账户的钱都不变。</p><p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">openConnection</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 关闭自动提交:</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">setAutoCommit</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
    <span class="c1">// 执行多条SQL语句:</span>
    <span class="n">insert</span><span class="o">();</span> <span class="n">update</span><span class="o">();</span> <span class="n">delete</span><span class="o">();</span>
    <span class="c1">// 提交事务:</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 回滚事务:</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">setAutoCommit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="n">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，开启事务的关键代码是<code class="language-plaintext highlighter-rouge">conn.setAutoCommit(false)</code>，表示关闭自动提交。提交事务的代码在执行完指定的若干条SQL语句后，调用<code class="language-plaintext highlighter-rouge">conn.commit()</code>。要注意事务不是总能成功，如果事务提交失败，会抛出SQL异常（也可能在执行SQL语句的时候就抛出了），此时必须捕获并调用<code class="language-plaintext highlighter-rouge">conn.rollback()</code>回滚事务。最后，在<code class="language-plaintext highlighter-rouge">finally</code>中通过<code class="language-plaintext highlighter-rouge">conn.setAutoCommit(true)</code>把<code class="language-plaintext highlighter-rouge">Connection</code>对象的状态恢复到初始值。</p><p>如果不及时提交或者回滚，当另一个事务需要对本事务中影响的行进行<strong>更新</strong>的时候是会被阻塞的。一直等到事务超时释放。所以一个事物要么尽快提交，要么尽快回滚。</p><p>默认情况下，获取到<code class="language-plaintext highlighter-rouge">Connection</code>连接后，总是处于“自动提交”模式，也就是每执行一条SQL都是作为事务自动执行的。只要关闭了<code class="language-plaintext highlighter-rouge">Connection</code>的<code class="language-plaintext highlighter-rouge">autoCommit</code>，那么就可以在一个事务中执行多条语句，事务以<code class="language-plaintext highlighter-rouge">commit()</code>方法结束。</p><p>如果要设定事务的隔离级别，可以使用如下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设定隔离级别为READ COMMITTED:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setTransactionIsolation</span><span class="o">(</span><span class="nc">Connection</span><span class="o">.</span><span class="na">TRANSACTION_READ_COMMITTED</span><span class="o">);</span>
</code></pre></div></div><p>如果没有调用上述方法，那么会使用数据库的默认隔离级别。MySQL的默认隔离级别是<code class="language-plaintext highlighter-rouge">REPEATABLE_READ</code>。</p><h2 id="batch">Batch</h2><p>使用JDBC操作数据库的时候，经常会执行一些批量操作。</p><p>例如，一次性给会员增加可用优惠券若干，我们可以执行以下SQL代码：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">123</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">234</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">345</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">coupons</span> <span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="k">type</span><span class="p">,</span> <span class="n">expires</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">456</span><span class="p">,</span> <span class="s1">'DISCOUNT'</span><span class="p">,</span> <span class="s1">'2030-12-31'</span><span class="p">);</span>
<span class="p">...</span>
</code></pre></div></div><p>实际上执行JDBC时，因为只有占位符参数不同，所以SQL实际上是一样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">params</span> <span class="o">:</span> <span class="n">paramsList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">preparedStatement</span><span class="o">(</span><span class="s">"INSERT INTO coupons (user_id, type, expires) VALUES (?,?,?)"</span><span class="o">);</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setLong</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
    <span class="n">ps</span><span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>通过一个循环来执行每个<code class="language-plaintext highlighter-rouge">PreparedStatement</code>虽然可行，但是性能很低。SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。</p><p>可以利用SQL数据库的这一特性，把同一个SQL但参数不同的若干次操作合并为一个batch执行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">PreparedStatement</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="s">"INSERT INTO student (name, sex, age, address,depart) VALUES (?, ?, ?, ?, ?)"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 对同一个PreparedStatement反复设置参数并调用addBatch():</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Student</span> <span class="n">s</span> <span class="o">:</span> <span class="n">students</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">sex</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">age</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">address</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">depart</span><span class="o">);</span>
        <span class="n">ps</span><span class="o">.</span><span class="na">addBatch</span><span class="o">();</span> <span class="c1">// 添加到batch</span>
    <span class="o">}</span>
    <span class="c1">// 执行batch:</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeBatch</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">ns</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" inserted."</span><span class="o">);</span> <span class="c1">// batch中每个SQL执行的结果数量</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>执行batch和执行一个SQL不同点在于，需要对同一个<code class="language-plaintext highlighter-rouge">PreparedStatement</code>反复设置参数并调用<code class="language-plaintext highlighter-rouge">addBatch()</code>，这样就相当于给一个SQL加上了多组参数，相当于变成了“多行”SQL。</p><p>第二个不同点是调用的不是<code class="language-plaintext highlighter-rouge">executeUpdate()</code>，而是<code class="language-plaintext highlighter-rouge">executeBatch()</code>，因为设置了多组参数，相应地，返回结果也是多个<code class="language-plaintext highlighter-rouge">int</code>值，因此返回类型是<code class="language-plaintext highlighter-rouge">int[]</code>，循环<code class="language-plaintext highlighter-rouge">int[]</code>数组即可获取每组参数执行后影响的结果数量。</p><p>另外MySQL批处理默认是关闭的，如果需要开启，在<code class="language-plaintext highlighter-rouge">url</code>上添加 ：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rewriteBatchedStatements=true
</code></pre></div></div><h2 id="连接池">连接池</h2><p>在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，可以通过连接池（Connection Pool）复用已经创建好的连接。</p><p>JDBC连接池有一个标准的接口<code class="language-plaintext highlighter-rouge">javax.sql.DataSource</code>，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，必须选择一个JDBC连接池的实现。常用的JDBC连接池有<code class="language-plaintext highlighter-rouge">HikariCP</code>、<code class="language-plaintext highlighter-rouge">C3P0</code>、<code class="language-plaintext highlighter-rouge">BoneCP</code>、<code class="language-plaintext highlighter-rouge">Druid</code>。目前使用最广泛的是<code class="language-plaintext highlighter-rouge">HikariCP</code>。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.zaxxer/HikariCP --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.zaxxer<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>HikariCP<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.1.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">();</span>
<span class="n">config</span><span class="o">.</span><span class="na">setJdbcUrl</span><span class="o">(</span><span class="s">"jdbc:mysql://localhost:3306/studentdb?useSSL=false&amp;characterEncoding=utf8"</span><span class="o">);</span>
<span class="n">config</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"root"</span><span class="o">);</span>
<span class="n">config</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="s">"123456"</span><span class="o">);</span>
<span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"connectionTimeout"</span><span class="o">,</span> <span class="s">"1000"</span><span class="o">);</span> <span class="c1">// 连接超时：1秒</span>
<span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"idleTimeout"</span><span class="o">,</span> <span class="s">"60000"</span><span class="o">);</span> <span class="c1">// 空闲超时：60秒</span>
<span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"maximumPoolSize"</span><span class="o">,</span> <span class="s">"10"</span><span class="o">);</span> <span class="c1">// 最大连接数：10</span>
<span class="nc">DataSource</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DataSource</code>实例就是连接池，创建<code class="language-plaintext highlighter-rouge">DataSource</code>也是一个非常昂贵的操作，所以通常<code class="language-plaintext highlighter-rouge">DataSource</code>实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p><p>有了连接池以后获取<code class="language-plaintext highlighter-rouge">Connection</code>时，把<code class="language-plaintext highlighter-rouge">DriverManage.getConnection()</code>改为<code class="language-plaintext highlighter-rouge">ds.getConnection()</code>即可。</p><p>通过连接池获取连接时，并不需要指定JDBC的相关URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建<code class="language-plaintext highlighter-rouge">HikariDataSource</code>时传入的<code class="language-plaintext highlighter-rouge">HikariConfig</code>持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用<code class="language-plaintext highlighter-rouge">ds.getConnection()</code>，会迫使连接池内部先创建一个<code class="language-plaintext highlighter-rouge">Connection</code>，再返回给客户端使用。当我们调用<code class="language-plaintext highlighter-rouge">conn.close()</code>方法时（<code class="language-plaintext highlighter-rouge">在try(resource){...}</code>结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p><p>连接池内部维护了若干个<code class="language-plaintext highlighter-rouge">Connection</code>实例，如果调用<code class="language-plaintext highlighter-rouge">ds.getConnection()</code>，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对<code class="language-plaintext highlighter-rouge">Connection</code>调用<code class="language-plaintext highlighter-rouge">close()</code>，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。</p><p>通常连接池提供了大量的参数可以配置，例如，维护的最小、最大活动连接数，指定一个连接在空闲一段时间后自动关闭等，需要根据应用程序的负载合理地配置这些参数。大多数连接池都提供了详细的实时状态以便进行监控。</p><h1 id="gui">GUI</h1><p><code class="language-plaintext highlighter-rouge">JFrame</code> <strong>构造方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">JFrame()</code></td><td>构造一个初始时不可见的新窗体。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(GraphicsConfiguration gc)</code></td><td>以屏幕设备的指定 <code class="language-plaintext highlighter-rouge">GraphicsConfiguration</code> 和空白标题创建一个 <code class="language-plaintext highlighter-rouge">Frame</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(String title)</code></td><td>创建一个新的、初始不可见的、具有指定标题的 <code class="language-plaintext highlighter-rouge">Frame</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(String title, GraphicsConfiguration gc)</code></td><td>创建一个具有指定标题和指定屏幕设备的 <code class="language-plaintext highlighter-rouge">GraphicsConfiguration</code> 的 <code class="language-plaintext highlighter-rouge">JFrame</code>。</td></tr></tbody></table><p><strong>常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">add()</code></td><td>将组件添加到窗口</td></tr><tr><td><code class="language-plaintext highlighter-rouge">is/setVisible()</code></td><td>获取/设置窗体的可视状态。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setTitle()</code></td><td>获取/设置窗体的标题。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setState()</code></td><td>获取/设置窗体的的最小化,最大化等状态。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setLocation()</code></td><td>获取/设置窗体在屏幕上应当出现的位置。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setSize()</code></td><td>获取/设置窗体的大小。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">setDefaultCloseOperation(int operation)</code></td><td>设置单击窗体上的关闭按钮时的默认操作。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">getContentPane()</code></td><td>获取窗体的内容面板</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">setDefaultCloseOperation</code></p><p><code class="language-plaintext highlighter-rouge">public void setDefaultCloseOperation(int operation)</code><br /> 设置用户在此窗体上发起”<code class="language-plaintext highlighter-rouge">close</code>“时默认执行的操作。必须指定以下选项之一：</p><p>值依次为<code class="language-plaintext highlighter-rouge">0-3</code></p><p><code class="language-plaintext highlighter-rouge">DO_NOTHING_ON_CLOSE</code>(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 <code class="language-plaintext highlighter-rouge">WindowListener</code> 对象的 <code class="language-plaintext highlighter-rouge">windowClosing</code> 方法中处理该操作。</p><p><code class="language-plaintext highlighter-rouge">HIDE_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">WindowConstants</code> 中定义)：调用任意已注册的 <code class="language-plaintext highlighter-rouge">WindowListener</code> 对象后自动隐藏该窗体。</p><p><code class="language-plaintext highlighter-rouge">DISPOSE_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">WindowConstants</code> 中定义)：调用任意已注册 <code class="language-plaintext highlighter-rouge">WindowListener</code> 的对象后自动隐藏并释放该窗体。</p><p><code class="language-plaintext highlighter-rouge">EXIT_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">JFrame</code> 中定义)：使用 <code class="language-plaintext highlighter-rouge">System exit</code> 方法退出应用程序。仅在应用程序中使用。</p><p>默认情况下,该值被设置为 <code class="language-plaintext highlighter-rouge">HIDE_ON_CLOSE</code>。更改此属性的值将导致激发属性更改事件,其属性名称为 “<code class="language-plaintext highlighter-rouge">defaultCloseOperation</code>“。</p><p>注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机<strong>可能</strong>会终止。<br /> <code class="language-plaintext highlighter-rouge">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</code></p><h1 id="jvm">JVM</h1><h2 id="对象的生命周期">对象的生命周期</h2><p>在Java中，对象在堆内存中的生命周期和垃圾回收（GC）过程涉及多个阶段，通常遵循以下路径：对象创建、晋升到老年代、最终被垃圾回收。</p><p><strong>对象创建</strong></p><p>当在Java程序中使用<code class="language-plaintext highlighter-rouge">new</code>关键字创建一个对象时，该对象首先被分配在堆内存中的新生代（Young Generation）的Eden区：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MyObject</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyObject</span><span class="o">();</span>
</code></pre></div></div><p><strong>新生代（Young Generation）</strong></p><p>新生代通常分为三个区域：Eden区和两个Survivor区（S0和S1）。</p><ul><li><strong>Eden区</strong>：大部分新对象最初在这里分配。</li><li><strong>Survivor区</strong>：当Eden区满时，进行Minor GC（轻量级垃圾回收），存活的对象会被移动到Survivor区。Survivor区分为两个：S0和S1，轮流使用。</li></ul><p><strong>晋升到老年代（Old Generation）</strong></p><p>对象在新生代中存活多次Minor GC后，会被晋升（Promote）到老年代。这通常通过以下过程实现：</p><ul><li><strong>Minor GC</strong>：当Eden区满时触发，存活的对象会被移动到Survivor区。如果对象在多个GC周期中依然存活（通常由对象的年龄计数决定），它们最终会被晋升到老年代。</li><li><strong>老年代</strong>：存活时间较长或较大的对象会被移动到老年代。老年代空间较大，存储持久化对象。</li></ul><p><strong>老年代（Old Generation）</strong></p><p>在老年代中，对象可以存活更长时间。然而，当老年代也满了时，会触发Major GC或Full GC，这种GC比Minor GC更耗时：</p><ul><li><strong>Major GC / Full GC</strong>：清理老年代和新生代的垃圾回收，回收未被引用的对象。通常由CMS（Concurrent Mark-Sweep）或G1（Garbage First）垃圾收集器完成。</li></ul><p><strong>垃圾回收（Garbage Collection）</strong></p><p>对象生命周期的最终阶段是垃圾回收。对象不再被引用时，它们会被标记为可回收，并在GC过程中被清除以释放内存：</p><ul><li><strong>标记-清除（Mark-Sweep）</strong>：标记所有不可达的对象，然后清除它们。</li><li><strong>标记-整理（Mark-Compact）</strong>：标记阶段后，将存活的对象压缩到堆的一端，清理掉未使用的空间。</li><li><strong>复制（Copying）</strong>：将存活对象复制到新的内存区域，通常用于新生代的Minor GC。</li></ul><p><strong>对象生命周期示例</strong></p><ol><li><strong>对象创建</strong>：新对象<code class="language-plaintext highlighter-rouge">obj</code>在Eden区分配。</li><li><strong>Minor GC</strong>：Eden区满，进行Minor GC，<code class="language-plaintext highlighter-rouge">obj</code>被移动到Survivor区。</li><li><strong>晋升到老年代</strong>：如果<code class="language-plaintext highlighter-rouge">obj</code>在多次Minor GC后依然存活，它将被晋升到老年代。</li><li><strong>Major GC</strong>：当老年代满时，进行Major GC或Full GC，<code class="language-plaintext highlighter-rouge">obj</code>被回收。</li></ol><h2 id="各区域的数据">各区域的数据</h2><ul><li>堆：对象实例、String常量池、基本类型常量池、静态变量。</li><li>方法区（元空间）：类信息、类常量池、运行时常量池。</li><li>虚拟机栈：临时变量（方法内的变量）</li></ul><p>方法区是《Java 虚拟机规范》规定的一个抽象的概念。永久代和元空间是方法区的两种实现方式。</p><p><strong>JDK8之前</strong>：用永久代作为方法区的实现，占用JVM的空间，通过Full GC进行垃圾回收（回收效率很低）。</p><p><strong>JDK8开始</strong>：用元空间作为方法区的实现，使用本地内存，不占用JVM的空间。元空间有自己的垃圾回收机制。</p><p><strong>JDK8为什么要调整方法区的位置？</strong></p><p>永久代通过Full GC进行垃圾回收，回收效率很低。</p><p>永久代有JVM 设置的固定大小上限，无法进行调整。而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。元空间里面存放的是类的元数据，这样加载的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间控制，这样能加载的类就更多了。</p><p>元空间溢出时会得到如下错误：java.lang.OutOfMemoryError: MetaSpace</p><p>相关参数：</p><ol><li>-XX：MaxMetaspaceSize。最大元空间大小，默认值为 unlimited，表示只受系统内存的限制。</li><li>-XX：MetaspaceSize 元空间的初始大小，如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</li></ol><h2 id="永久代和元空间">永久代和元空间</h2><p>永久代（Permanent Generation）和元空间（Metaspace）是 Java 虚拟机（JVM）内存管理中的两个概念，用于存储与类和方法相关的元数据。它们在不同版本的 JVM 中有不同的实现和管理方式。</p><p><strong>永久代（Permanent Generation）</strong></p><p><strong>永久代</strong>是 JDK 8 之前的 JVM 内存模型的一部分，用于存储类的元数据、方法、常量池和类的静态变量等信息。永久代的特点包括：</p><ul><li><strong>固定大小</strong>：永久代的大小在 JVM 启动时通过参数设置，不能动态调整。</li><li><strong>GC 影响</strong>：永久代会参与垃圾回收，特别是 Full GC。如果永久代空间不足，可能会触发 Full GC，从而影响应用程序性能。</li><li><strong>设置参数</strong>：<ul><li><code class="language-plaintext highlighter-rouge">-XX:PermSize=&lt;size&gt;</code>：设置初始永久代大小。</li><li><code class="language-plaintext highlighter-rouge">-XX:MaxPermSize=&lt;size&gt;</code>：设置最大永久代大小。</li></ul></li></ul><p><strong>元空间（Metaspace）</strong></p><p><strong>元空间</strong>是从 JDK 8 开始引入的，用来取代永久代的新内存区域。元空间的改进在于其存储机制和内存管理方式：</p><ul><li><strong>动态调整</strong>：元空间使用本地内存（Native Memory），其大小可以根据需要动态调整，不再受到固定大小的限制。</li><li><strong>减少 OOM 发生率</strong>：由于元空间使用本地内存，可以有效减少因为类加载过多导致的 OutOfMemoryError (OOM) 问题。</li><li><strong>设置参数</strong>：<ul><li><code class="language-plaintext highlighter-rouge">-XX:MetaspaceSize=&lt;size&gt;</code>：设置初始元空间大小。</li><li><code class="language-plaintext highlighter-rouge">-XX:MaxMetaspaceSize=&lt;size&gt;</code>：设置最大元空间大小（如果不设置，默认情况下元空间大小是可以增长到可用系统内存的上限）。</li><li><code class="language-plaintext highlighter-rouge">-XX:MinMetaspaceFreeRatio=&lt;percentage&gt;</code>：设置 GC 后元空间的最小空闲比例。</li><li><code class="language-plaintext highlighter-rouge">-XX:MaxMetaspaceFreeRatio=&lt;percentage&gt;</code>：设置 GC 后元空间的最大空闲比例。</li></ul></li></ul><p><strong>永久代和元空间的区别</strong></p><ol><li><strong>内存区域</strong>：<ul><li>永久代：位于 Java 堆内存中。</li><li>元空间：位于本地内存（Native Memory）中。</li></ul></li><li><strong>内存管理</strong>：<ul><li>永久代：大小固定，容易导致 OutOfMemoryError。</li><li>元空间：动态调整大小，更加灵活，减少 OutOfMemoryError 发生率。</li></ul></li><li><strong>垃圾回收</strong>：<ul><li>永久代：需要参与垃圾回收，特别是 Full GC。</li><li>元空间：减少了 Full GC 的频率，提高了垃圾回收的效率。</li></ul></li></ol><p>如果还在使用 JDK 7 或更早版本，建议升级到 JDK 8 或更高版本，以利用元空间带来的内存管理优势。升级后，可以删除或调整与永久代相关的 JVM 参数，并改用与元空间相关的参数。</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 示例：JDK 7 的 JVM 参数</span>
java <span class="nt">-XX</span>:PermSize<span class="o">=</span>256m <span class="nt">-XX</span>:MaxPermSize<span class="o">=</span>512m <span class="nt">-jar</span> myapp.jar

<span class="c"># 示例：JDK 8 及以上的 JVM 参数</span>
java <span class="nt">-XX</span>:MetaspaceSize<span class="o">=</span>256m <span class="nt">-XX</span>:MaxMetaspaceSize<span class="o">=</span>512m <span class="nt">-jar</span> myapp.jar
</code></pre></div></div><p>通过合理配置和使用元空间，可以更好地管理类元数据的内存，提高应用程序的性能和稳定性。</p><h2 id="内存模型">内存模型</h2><p>Java内存模型（Java Memory Model，简称JMM）是Java虚拟机规范中的一部分，用于定义Java程序在多线程环境下的内存访问规则。JMM规定了变量的读取和写入如何在不同线程之间进行交互，确保程序在不同硬件和操作系统上的执行具有一致性。</p><p><strong>基本概念</strong></p><ul><li><strong>主内存（Main Memory）</strong>: 所有的实例变量（非局部变量）都存储在主内存中。主内存是多个线程共享的内存区域。</li><li><strong>工作内存（Working Memory）</strong>: 每个线程都有自己的工作内存，也叫本地内存。线程的工作内存保存了主内存中变量的副本，线程对变量的所有操作（如读取、赋值）都在工作内存中进行，而不是直接在主内存中进行。</li></ul><p><strong>工作流程</strong></p><ul><li><strong>读取和加载</strong>: 线程从主内存读取变量值，并将其存放到工作内存中。</li><li><strong>使用和赋值</strong>: 线程在工作内存中使用或更新变量值。</li><li><strong>存储和写入</strong>: 线程将更新后的变量值从工作内存写回到主内存。</li></ul><p><strong>JMM的关键原则</strong></p><p>JMM的设计主要解决三个问题：<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>。</p><p>原子性（Atomicity）</p><ul><li><strong>原子性</strong>是指一个操作是不可分割的，执行过程中不会被其他线程干扰。</li><li>在Java中，简单的读取和赋值操作是原子性的，比如读取和写入<code class="language-plaintext highlighter-rouge">int</code>类型的变量。但是对于复合操作，如<code class="language-plaintext highlighter-rouge">i++</code>，并不是原子性的，因为它包括读取、增值和写入三个步骤。</li></ul><p>可见性（Visibility）</p><ul><li><strong>可见性</strong>是指一个线程对共享变量的修改可以及时被其他线程看到。</li><li>在JMM中，线程A对变量的修改在写入到主内存后，线程B读取时才能看到。为了保证可见性，可以使用<code class="language-plaintext highlighter-rouge">volatile</code>关键字、<code class="language-plaintext highlighter-rouge">synchronized</code>块或锁机制。</li></ul><p>有序性（Ordering）</p><ul><li><strong>有序性</strong>是指程序代码的执行顺序在多线程环境下的一致性。</li><li>JMM允许编译器和处理器在不改变单线程语义的前提下对指令进行重排序。为了保证多线程环境下的正确执行，可以使用<code class="language-plaintext highlighter-rouge">volatile</code>、<code class="language-plaintext highlighter-rouge">synchronized</code>或锁来禁止重排序。</li></ul><p>.<strong>happens-before原则</strong></p><p>JMM通过<strong>happens-before</strong>原则来定义操作之间的顺序性和可见性。</p><ul><li><strong>程序次序规则</strong>: 在一个线程内，按照代码顺序，前面的操作happens-before后面的操作。</li><li><strong>锁定规则</strong>: 对一个锁的解锁happens-before对这个锁的加锁。</li><li><strong>volatile变量规则</strong>: 对一个<code class="language-plaintext highlighter-rouge">volatile</code>变量的写操作happens-before对这个<code class="language-plaintext highlighter-rouge">volatile</code>变量的读操作。</li><li><strong>线程启动规则</strong>: <code class="language-plaintext highlighter-rouge">Thread.start()</code>happens-before线程内的所有操作。</li><li><strong>线程终止规则</strong>: 线程内的所有操作happens-before对<code class="language-plaintext highlighter-rouge">Thread.join()</code>的返回。</li></ul><p><strong>内存屏障（Memory Barriers）</strong></p><p>JMM通过插入<strong>内存屏障</strong>（Memory Barriers，也称为Memory Fences）来防止重排序和确保内存可见性。内存屏障可以分为：</p><ul><li><strong>Load Barrier</strong>: 在读取操作之前，阻止重排序。</li><li><strong>Store Barrier</strong>: 在写入操作之后，阻止重排序。</li></ul><p><strong>常用关键字</strong></p><ul><li><strong>volatile</strong>: 保证变量的可见性和有序性，但不保证原子性。使用<code class="language-plaintext highlighter-rouge">volatile</code>修饰的变量，在多线程访问时，会禁止指令重排序，并强制将更新后的值写回主内存，使得其他线程可以及时看到最新值。</li><li><strong>synchronized</strong>: 保证代码块的原子性、可见性和有序性。<code class="language-plaintext highlighter-rouge">synchronized</code>会确保线程在进入代码块之前获得锁，并在退出代码块后释放锁，保证共享变量的操作是原子性的，并且锁释放前的所有修改对其他线程可见。</li></ul><p>Java内存模型（JMM）为开发者提供了一套清晰的规则，确保在多线程环境下，代码的执行顺序和内存访问的一致性。理解JMM有助于编写正确且高效的并发程序，避免常见的并发问题，如竞态条件、内存可见性问题和指令重排序带来的不确定性。</p><h2 id="类加载过程">类加载过程</h2><p>加载=&gt; 链接（验证+准备+解析）=&gt; 初始化=&gt; 使用=&gt; 卸载</p><ol><li><p>加载（将硬盘上的Java二进制文件（class文件）转为内存中的Class对象）</p><ol><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存（不一定在堆中，HotSpot是在方法区）中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol></li><li><p>链接（给静态变量赋初始值，符号引用替换成直接引用）</p><ol><li><p><strong>验证</strong>：检查载入的class文件数据的正确性</p></li><li><p>准备：给类变量（静态变量）分配内存（方法区）并设置为零值（0、false、null等）。</p><p>例外：static final类型的String或基本类型，直接赋值为最终值，如：static final int a = 12; 在准备阶段就将a赋值为12。</p></li><li><p>解析（可选）：将常量池内的符号引用替换成直接引用。</p><p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用 ，那引用的目标必定已经在内存中存在。</p></li></ol></li><li><p>初始化（初始化类变量（静态变量）、执行静态语句块）</p><p>执行类变量（静态变量）的赋值动作和静态语句块（按定义的顺序从上往下执行）。优先级：静态、父类、子类</p><p>注意：初始化是操作类变量（也就是静态变量），不是对象的变量。</p></li><li><p>使用（以new一个对象为例）</p><ol><li>若是第一次创建 Dog 对象（对象所属的类没有加载到内存中）则先执行上面的初始化操作。</li><li>在堆上为 Dog 对象（包括实例变量）分配空间，所有属性都设成默认值(数字为 0，字符为 null，布尔为 false，引用被设成 null）</li><li>初始化实例：给实例变量赋值、执行初始化语句块</li><li>执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数</li><li>执行本类的构造函数。</li></ol></li></ol><h2 id="调优">调优</h2><p>Java 虚拟机（JVM）提供了许多参数来调整其行为和性能。以下是一些常见的 JVM 参数及其用途：</p><p><strong>内存设置</strong></p><ul><li><code class="language-plaintext highlighter-rouge">-Xms&lt;size&gt;</code>：设置初始堆大小。例如：<code class="language-plaintext highlighter-rouge">-Xms512m</code></li><li><code class="language-plaintext highlighter-rouge">-Xmx&lt;size&gt;</code>：设置最大堆大小。例如：<code class="language-plaintext highlighter-rouge">-Xmx1024m</code></li><li><code class="language-plaintext highlighter-rouge">-Xmn&lt;size&gt;</code>：设置年轻代大小。例如：<code class="language-plaintext highlighter-rouge">-Xmn256m</code></li><li><code class="language-plaintext highlighter-rouge">-XX:PermSize=&lt;size&gt;</code>：设置初始永久代大小（对于 JDK 8 之前的版本）。</li><li><code class="language-plaintext highlighter-rouge">-XX:MaxPermSize=&lt;size&gt;</code>：设置最大永久代大小（对于 JDK 8 之前的版本）。</li><li><code class="language-plaintext highlighter-rouge">-XX:MetaspaceSize=&lt;size&gt;</code>：设置初始元空间大小（对于 JDK 8 及以上版本）。</li><li><code class="language-plaintext highlighter-rouge">-XX:MaxMetaspaceSize=&lt;size&gt;</code>：设置最大元空间大小（对于 JDK 8 及以上版本）。</li></ul><p><strong>垃圾回收（GC）设置</strong></p><ul><li><code class="language-plaintext highlighter-rouge">-XX:+UseSerialGC</code>：使用串行垃圾收集器。</li><li><code class="language-plaintext highlighter-rouge">-XX:+UseParallelGC</code>：使用并行垃圾收集器（默认的垃圾收集器之一）。</li><li><code class="language-plaintext highlighter-rouge">-XX:+UseConcMarkSweepGC</code>：使用并发标记-清除垃圾收集器。</li><li><code class="language-plaintext highlighter-rouge">-XX:+UseG1GC</code>：使用 G1 垃圾收集器。</li><li><code class="language-plaintext highlighter-rouge">-XX:NewRatio=&lt;ratio&gt;</code>：设置新生代与老年代的比例。</li><li><code class="language-plaintext highlighter-rouge">-XX:SurvivorRatio=&lt;ratio&gt;</code>：设置 Eden 区与 Survivor 区的比例。</li><li><code class="language-plaintext highlighter-rouge">-XX:MaxTenuringThreshold=&lt;threshold&gt;</code>：设置对象在新生代的最大年龄。</li><li><code class="language-plaintext highlighter-rouge">-XX:+PrintGCDetails</code>：打印 GC 详细信息。</li><li><code class="language-plaintext highlighter-rouge">-XX:+PrintGCDateStamps</code>：在 GC 日志中打印时间戳。</li><li><code class="language-plaintext highlighter-rouge">-Xloggc:&lt;file&gt;</code>：将 GC 日志写入文件。</li></ul><p><strong>性能调优</strong></p><ul><li><code class="language-plaintext highlighter-rouge">-XX:+UseCompressedOops</code>：在 64 位 JVM 中使用压缩指针。</li><li><code class="language-plaintext highlighter-rouge">-XX:+AggressiveOpts</code>：使用最新的性能优化。</li><li><code class="language-plaintext highlighter-rouge">-XX:+TieredCompilation</code>：启用分层编译。</li><li><code class="language-plaintext highlighter-rouge">-XX:ParallelGCThreads=&lt;threads&gt;</code>：设置并行 GC 的线程数。</li><li><code class="language-plaintext highlighter-rouge">-XX:ConcGCThreads=&lt;threads&gt;</code>：设置并发 GC 的线程数。</li></ul><p><strong>调试和诊断</strong></p><ul><li><code class="language-plaintext highlighter-rouge">-XX:+HeapDumpOnOutOfMemoryError</code>：在出现内存溢出时生成堆转储。</li><li><code class="language-plaintext highlighter-rouge">-XX:HeapDumpPath=&lt;file&gt;</code>：指定堆转储文件路径。</li><li><code class="language-plaintext highlighter-rouge">-XX:+PrintClassHistogram</code>：打印类的直方图。</li><li><code class="language-plaintext highlighter-rouge">-XX:+PrintConcurrentLocks</code>：打印并发锁的信息。</li><li><code class="language-plaintext highlighter-rouge">-XX:+TraceClassLoading</code>：跟踪类加载。</li><li><code class="language-plaintext highlighter-rouge">-XX:+TraceClassUnloading</code>：跟踪类卸载。</li></ul><p><strong>类加载和编译</strong></p><ul><li><code class="language-plaintext highlighter-rouge">-Xbootclasspath:&lt;path&gt;</code>：设置引导类加载器的类路径。</li><li><code class="language-plaintext highlighter-rouge">-XX:CompileThreshold=&lt;invocations&gt;</code>：设置方法编译的调用阈值。</li><li><code class="language-plaintext highlighter-rouge">-XX:+PrintCompilation</code>：打印编译信息。</li><li><code class="language-plaintext highlighter-rouge">-XX:+PrintInlining</code>：打印内联信息。</li></ul><p><strong>其他常用参数</strong></p><ul><li><code class="language-plaintext highlighter-rouge">-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性。例如：<code class="language-plaintext highlighter-rouge">-Dfile.encoding=UTF-8</code></li><li><code class="language-plaintext highlighter-rouge">-verbose:gc</code>：启用 GC 日志。</li><li><code class="language-plaintext highlighter-rouge">-verbose:class</code>：启用类加载日志。</li><li><code class="language-plaintext highlighter-rouge">-verbose:jni</code>：启用 JNI 调用日志。</li><li><code class="language-plaintext highlighter-rouge">-server</code>：启用服务器模式（针对高性能应用）。</li></ul><p>这些参数可以在启动 Java 应用程序时通过命令行传递，例如：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-Xms512m</span> <span class="nt">-Xmx1024m</span> <span class="nt">-XX</span>:+UseG1GC <span class="nt">-XX</span>:+PrintGCDetails <span class="nt">-jar</span> myapp.jar
</code></pre></div></div><p>具体的参数和配置需要根据应用程序的需求和运行环境进行调整和优化。</p><h1 id="mysql">MYSQL</h1><h2 id="锁">锁</h2><p>在MySQL中，锁（Locks）是用于控制并发访问数据库对象（如表和行）的机制。锁可以防止多个事务同时修改相同的数据，从而避免数据不一致或损坏。MySQL提供了多种锁定机制，以满足不同的并发控制需求。以下是MySQL中常见的锁类型：</p><ol><li>表锁（Table Locks）</li></ol><p>表锁是针对整个表的锁定机制。MySQL使用表锁来确保对表的操作（如INSERT、UPDATE、DELETE等）的一致性。</p><ul><li><p><strong>读锁（READ LOCK）</strong>：允许多个事务同时读取表，但不允许任何事务修改表。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">LOCK</span> <span class="n">TABLES</span> <span class="k">table_name</span> <span class="k">READ</span><span class="p">;</span>
</code></pre></div></div></li><li><p><strong>写锁（WRITE LOCK）</strong>：只允许一个事务访问表，其他事务既不能读取也不能修改表。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">LOCK</span> <span class="n">TABLES</span> <span class="k">table_name</span> <span class="k">WRITE</span><span class="p">;</span>
</code></pre></div></div></li></ul><ol><li>行锁（Row Locks）</li></ol><p>行锁是针对特定行的锁定机制。InnoDB存储引擎支持行级锁定，这样可以在同一张表中允许多个事务同时修改不同的行，从而提高并发性。</p><ul><li><strong>共享锁（S锁，Shared Lock）</strong>：允许多个事务读取同一行，但不允许修改。<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">WHERE</span> <span class="p">...</span> <span class="k">LOCK</span> <span class="k">IN</span> <span class="k">SHARE</span> <span class="k">MODE</span><span class="p">;</span>
</code></pre></div></div></li><li><strong>排他锁（X锁，Exclusive Lock）</strong>：不允许其他事务读取或修改锁定的行。<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">WHERE</span> <span class="p">...</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</code></pre></div></div></li></ul><ol><li>意向锁（Intent Locks）</li></ol><p>意向锁是InnoDB自动添加的一种锁，用于表明某个事务计划对某些行加锁。这种锁的存在使得MySQL能够更高效地进行锁定检查和锁定升级。</p><ul><li><strong>意向共享锁（IS锁，Intent Shared Lock）</strong>：表明事务计划对某些行加共享锁。</li><li><strong>意向排他锁（IX锁，Intent Exclusive Lock）</strong>：表明事务计划对某些行加排他锁。</li></ul><ol><li>间隙锁（Gap Locks）</li></ol><p>间隙锁用于防止幻读（Phantom Read），它会锁定索引记录之间的“间隙”，以确保其他事务无法在这些间隙中插入新记录。</p><ol><li>临键锁（Next-Key Locks）</li></ol><p>临键锁是行锁和间隙锁的组合，用于防止其他事务对锁定行及其周围的间隙进行插入操作。临键锁用于防止幻读问题。</p><ol><li>自增锁（AUTO-INC Locks）</li></ol><p>自增锁用于确保多个事务同时插入带有AUTO_INCREMENT列的表时，生成的自增值是唯一的。</p><ol><li>全局锁（Global Locks）</li></ol><p>全局锁用于整个数据库实例的锁定，可以将数据库设置为只读模式，以进行备份等操作。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FLUSH</span> <span class="n">TABLES</span> <span class="k">WITH</span> <span class="k">READ</span> <span class="k">LOCK</span><span class="p">;</span>
</code></pre></div></div><p><strong>锁的使用示例</strong></p><p><strong>表锁示例：</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">LOCK</span> <span class="n">TABLES</span> <span class="n">employees</span> <span class="k">WRITE</span><span class="p">;</span>
<span class="c1">-- Perform write operations on the employees table</span>
<span class="n">UNLOCK</span> <span class="n">TABLES</span><span class="p">;</span>
</code></pre></div></div><p><strong>行锁示例：</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
<span class="c1">-- Perform operations on the locked row</span>
<span class="k">COMMIT</span><span class="p">;</span>
</code></pre></div></div><p><strong>查看锁信息</strong></p><p>可以使用以下命令查看当前锁的信息：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SHOW</span> <span class="n">ENGINE</span> <span class="n">INNODB</span> <span class="n">STATUS</span><span class="p">;</span>
</code></pre></div></div><p>或查询<code class="language-plaintext highlighter-rouge">information_schema</code>表：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">innodb_locks</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">innodb_lock_waits</span><span class="p">;</span>
</code></pre></div></div><p>了解和合理使用锁机制是确保数据库高效、安全并发访问的关键。</p><h2 id="区域锁">区域锁</h2><p>MySQL中的区域锁（也称为间隙锁，Gap Lock）是一种用于InnoDB存储引擎的锁机制。其主要作用是防止幻读现象和保持一致性。区域锁是在使用范围条件（Range Condition）进行查询时，对索引记录之间的空隙（Gap）加锁，以确保并发事务中数据的一致性。</p><p><strong>区域锁的主要作用</strong></p><ol><li><p><strong>防止幻读</strong>：幻读是指在一个事务中，两次相同的查询却得到不同的结果。区域锁通过锁定索引记录之间的空隙，防止其他事务在这些空隙中插入新的记录，从而避免幻读现象的发生。</p></li><li><p><strong>保持一致性</strong>：区域锁确保在一个事务中，数据的读取和写入是基于一致性的视图，不会因为其他事务的插入或删除操作而导致数据不一致。</p></li></ol><p><strong>区域锁的工作机制</strong></p><p>区域锁主要在以下两种情况下被使用：</p><ol><li><p><strong>在范围查询时加锁</strong>：当使用范围查询条件（如<code class="language-plaintext highlighter-rouge">SELECT * FROM my_table WHERE col BETWEEN 10 AND 20 FOR UPDATE</code>）时，InnoDB会锁定满足条件的记录和这些记录之间的空隙，以防止其他事务在这些空隙中插入新记录。</p></li><li><p><strong>在唯一索引上进行插入操作时加锁</strong>：当对唯一索引列进行插入操作时，如果存在唯一性约束，InnoDB会锁定可能冲突的索引记录之间的空隙，以确保插入操作的唯一性。</p></li></ol><p><strong>区域锁的示例</strong></p><p>以下是一个使用区域锁的示例：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 创建示例表</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">my_table</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">col</span> <span class="nb">INT</span>
<span class="p">);</span>

<span class="c1">-- 插入一些示例数据</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_table</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

<span class="c1">-- 开始事务1</span>
<span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="c1">-- 对满足条件的记录及其间隙加锁</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">my_table</span> <span class="k">WHERE</span> <span class="n">col</span> <span class="k">BETWEEN</span> <span class="mi">15</span> <span class="k">AND</span> <span class="mi">25</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>

<span class="c1">-- 开始事务2</span>
<span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="c1">-- 尝试在间隙中插入新记录（会被阻塞）</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">my_table</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>

<span class="c1">-- 提交事务1</span>
<span class="k">COMMIT</span><span class="p">;</span>

<span class="c1">-- 事务2继续执行，插入操作成功</span>
<span class="k">COMMIT</span><span class="p">;</span>
</code></pre></div></div><p>在这个示例中，事务1通过范围查询条件对满足条件的记录及其间隙加锁，防止事务2在这些间隙中插入新记录。只有当事务1提交后，事务2才能继续执行插入操作。</p><p><strong>区域锁的注意事项</strong></p><ol><li><p><strong>性能影响</strong>：区域锁在防止幻读和保持一致性方面起到了重要作用，但也可能会影响性能，特别是在高并发环境中。锁定空隙会导致更多的锁竞争和潜在的死锁情况。</p></li><li><p><strong>锁定范围</strong>：区域锁只适用于InnoDB存储引擎，并且仅在可重复读（REPEATABLE READ）隔离级别下生效。在读提交（READ COMMITTED）隔离级别下，InnoDB不会使用区域锁。</p></li></ol><p>MySQL中的区域锁（Gap Lock）是InnoDB存储引擎中的一种重要锁机制，用于防止幻读现象和保持数据一致性。通过锁定索引记录之间的空隙，区域锁确保了并发事务中的数据一致性和可靠性。然而，区域锁的使用也可能带来性能影响，因此在设计和优化数据库应用时，需要权衡锁机制的使用和系统性能之间的关系。</p><h2 id="索引">索引</h2><p>在MySQL中，存储索引的两种主要类型分别是：</p><ol><li><strong>聚集索引（Clustered Index）</strong></li><li><strong>非聚集索引（Non-Clustered Index）</strong></li></ol><h3 id="聚集索引clustered-index">聚集索引（Clustered Index）</h3><p>聚集索引是表中数据行的实际顺序与索引顺序一致的索引类型。每个表只能有一个聚集索引，因为表中的数据行只能按一种顺序存储。</p><ul><li><strong>特点</strong>：<ul><li>数据行按照聚集索引的键值排序存储。</li><li>通常会自动地将主键作为聚集索引。</li><li>查询效率高，特别是在范围查询和排序查询中。</li><li>插入和更新操作可能较慢，因为需要保持数据的有序性。</li></ul></li><li><strong>示例</strong>：<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">example</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div></li></ul><h3 id="非聚集索引non-clustered-index">非聚集索引（Non-Clustered Index）</h3><p>非聚集索引是索引的键值和数据行的物理存储顺序无关的索引类型。一个表可以有多个非聚集索引。</p><ul><li><strong>特点</strong>：<ul><li>非聚集索引存储的是键值及其对应的行指针。</li><li>查询操作中，MySQL会通过非聚集索引查找到行指针，然后根据行指针访问实际的数据行。</li><li>适合频繁的查询操作，但由于需要访问实际的数据行，查询效率可能不如聚集索引。</li><li>适用于多种查询条件，不限于主键。</li></ul></li><li><strong>示例</strong>：<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">example</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
    <span class="n">age</span> <span class="nb">INT</span><span class="p">,</span>
    <span class="k">INDEX</span> <span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div></li></ul><p>在MySQL中，聚集索引和非聚集索引是两种主要的存储索引类型。聚集索引用于将表中数据行按索引键值的顺序存储，而非聚集索引则存储键值和行指针以便快速查询。了解并正确使用这两种索引可以显著提高数据库查询性能。</p><h3 id="索引失效的情况">索引失效的情况</h3><p>在MySQL中，索引是用来提高查询性能的重要工具。然而，在某些情况下，索引可能会失效，导致查询性能下降。以下是一些常见的索引失效情况：</p><ol><li>索引字段上使用函数或表达式</li></ol><p>如果在查询中对索引字段使用了函数或表达式，索引会失效，因为MySQL无法利用索引来优化查询。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="k">LOWER</span><span class="p">(</span><span class="n">indexed_column</span><span class="p">)</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>隐式数据类型转换</li></ol><p>如果查询中的条件涉及隐式数据类型转换，索引也会失效。例如，索引字段是字符串类型，但查询条件是数值类型。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
</code></pre></div></div><ol><li>使用不等于或不包含（&lt;&gt;、NOT IN、NOT LIKE）</li></ol><p>使用这些操作符，索引通常会失效，因为MySQL需要扫描更多的数据行来确定结果集。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="o">&lt;&gt;</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>以通配符开头的LIKE查询</li></ol><p>如果LIKE查询的模式以通配符（%）开头，索引会失效，因为MySQL无法预测匹配的起始位置。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="k">LIKE</span> <span class="s1">'%value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>不使用前缀匹配的复合索引</li></ol><p>对于复合索引，如果查询条件中没有包含索引的前缀列，索引会失效。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 假设有一个复合索引 (column1, column2)</span>
<span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">column2</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>OR 条件中某些条件未使用索引</li></ol><p>如果查询中的OR条件部分列使用了索引，但另一部分没有使用索引，MySQL无法有效地利用索引。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="o">=</span> <span class="s1">'value1'</span> <span class="k">OR</span> <span class="n">non_indexed_column</span> <span class="o">=</span> <span class="s1">'value2'</span><span class="p">;</span>
</code></pre></div></div><ol><li>范围条件后面的列</li></ol><p>在复合索引中，如果使用了范围条件（如 &gt;, &lt;, BETWEEN），则范围条件后面的列索引会失效。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 假设有一个复合索引 (column1, column2)</span>
<span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">column1</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">AND</span> <span class="n">column2</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>NULL 值查询</li></ol><p>如果在查询条件中对索引字段进行了 IS NULL 或 IS NOT NULL 的判断，索引可能失效。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</code></pre></div></div><ol><li>表太小或数据分布不均</li></ol><p>如果表非常小，MySQL可能会选择全表扫描而不是使用索引。另外，如果数据分布非常不均匀，MySQL可能也会选择全表扫描。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子（小表）</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">small_table</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>更新频繁的表</li></ol><p>在高频率更新的表上，MySQL可能会临时选择全表扫描以避免频繁的索引更新带来的开销。</p><ol><li>使用LIMIT子句不当</li></ol><p>有些情况下，如果LIMIT子句的偏移量非常大，索引可能会失效。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 索引失效的例子（大偏移量）</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">indexed_column</span> <span class="k">LIMIT</span> <span class="mi">1000000</span><span class="p">,</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div><p>理解这些索引失效的情况有助于在设计和优化数据库查询时，避免常见的性能陷阱。</p><h3 id="强制走索引">强制走索引</h3><p>在MySQL中，有几种方法可以强制查询使用索引。以下是一些常用的方法：</p><ol><li>使用 <code class="language-plaintext highlighter-rouge">FORCE INDEX</code> 提示</li></ol><p><code class="language-plaintext highlighter-rouge">FORCE INDEX</code> 提示可以指定查询必须使用的索引。如果不使用指定的索引，查询将失败。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">FORCE</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">index_name</span><span class="p">)</span> <span class="k">WHERE</span> <span class="k">column</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>使用 <code class="language-plaintext highlighter-rouge">USE INDEX</code> 提示</li></ol><p><code class="language-plaintext highlighter-rouge">USE INDEX</code> 提示建议 MySQL 优先考虑使用指定的索引，但如果 MySQL 认为不使用索引会更高效，它可能仍会选择不使用索引。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="n">USE</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">index_name</span><span class="p">)</span> <span class="k">WHERE</span> <span class="k">column</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>使用 <code class="language-plaintext highlighter-rouge">IGNORE INDEX</code> 提示</li></ol><p><code class="language-plaintext highlighter-rouge">IGNORE INDEX</code> 提示告诉 MySQL 忽略指定的索引。这在您想要排除某些索引的情况下很有用。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">IGNORE</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">index_name</span><span class="p">)</span> <span class="k">WHERE</span> <span class="k">column</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>覆盖索引（Covering Index）</li></ol><p>覆盖索引指的是查询所需的所有列都在索引中，这样 MySQL 可以直接从索引中返回结果，而无需访问数据表。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 假设有一个复合索引 (column1, column2)</span>
<span class="k">SELECT</span> <span class="n">column1</span><span class="p">,</span> <span class="n">column2</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">WHERE</span> <span class="n">column1</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>使用 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 语句查看查询计划</li></ol><p>在执行查询之前，可以使用 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 语句查看查询计划，确保索引正在使用。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">WHERE</span> <span class="k">column</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><ol><li>确保查询条件匹配索引</li></ol><p>确保查询条件匹配索引的列，避免使用函数、表达式或隐式类型转换。</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 直接匹配索引列</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="k">table_name</span> <span class="k">WHERE</span> <span class="n">indexed_column</span> <span class="o">=</span> <span class="s1">'value'</span><span class="p">;</span>
</code></pre></div></div><p>示例：</p><p>假设有一个表 <code class="language-plaintext highlighter-rouge">employees</code>，包含以下索引：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_last_name</span> <span class="k">ON</span> <span class="n">employees</span> <span class="p">(</span><span class="n">last_name</span><span class="p">);</span>
</code></pre></div></div><p>我们希望强制查询使用该索引，可以使用 <code class="language-plaintext highlighter-rouge">FORCE INDEX</code> 提示：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">FORCE</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">idx_last_name</span><span class="p">)</span> <span class="k">WHERE</span> <span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span><span class="p">;</span>
</code></pre></div></div><p>在某些情况下，您可能需要使用复合索引。例如，假设有一个复合索引：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">INDEX</span> <span class="n">idx_full_name</span> <span class="k">ON</span> <span class="n">employees</span> <span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">);</span>
</code></pre></div></div><p>为了强制查询使用该复合索引，可以使用：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">FORCE</span> <span class="k">INDEX</span> <span class="p">(</span><span class="n">idx_full_name</span><span class="p">)</span> <span class="k">WHERE</span> <span class="n">first_name</span> <span class="o">=</span> <span class="s1">'John'</span> <span class="k">AND</span> <span class="n">last_name</span> <span class="o">=</span> <span class="s1">'Smith'</span><span class="p">;</span>
</code></pre></div></div><p>通过使用这些方法，可以更好地控制查询执行计划，确保查询在最优的情况下执行。</p><h3 id="索引的优缺点">索引的优缺点</h3><p><strong>索引优点</strong></p><p>索引优点就是提高了查询性能，主要是以下几个方面</p><ol><li>索引大大减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和临时表。</li><li>索引可以将随机I/O 变为顺序I/O</li></ol><p><strong>索引缺点</strong></p><p><strong>降低了数据写入的效率。</strong></p><p>原因：当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护。</p><p><strong>索引增加了查询优化器的选择时间。</strong></p><p>查询优化器在对一条sql语句进行分析时，会结合一系列的分析计算出一条最优的查询sql。</p><p>添加了索引之后，相当于是在原来的基础上，添加了对索引因素的分析，若在很多字段上创建了索引，会增加这个选择的时间。</p><p><strong>索引占物理空间。</strong></p><p>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p><strong>创建索引的原则</strong></p><table><thead><tr><th>索引原则</th><th>说明/示例</th></tr></thead><tbody><tr><td>对查询频率高的字段创建索引</td><td>查询频率高的字段有：作为查询条件的字段（where子句中的列）、连接子句中指定的列</td></tr><tr><td>为经常需要排序、分组和联合操作的字段建立索引</td><td>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。 如果为其建立索引，可以有效地避免排序操作。</td></tr><tr><td>尽量使用唯一索引</td><td>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。唯一值少的列上不适合建立索引或者建立索引效率低，因为创建索引会对那一列做自动的排序。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。若使用姓名的话，可能存在同名现象，从而降低查询速度。 主键索引和唯一键索引，在查询中使用是效率最高的。</td></tr><tr><td>使用短索引</td><td>如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。</td></tr><tr><td>使用前缀来索引</td><td>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</td></tr><tr><td>索引的数目不要太多</td><td>1. 每创建一个索引都会占用相应的物理空间； 2. 过多的索引会导致insert、update、delete语句的执行效率降低； 在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。若一个索引很少利用或从不使用，那么会不必要地减缓表的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使MySQL 选择不到所要使用的最好索引。只保持所需的索引有利于查询优化。如果想给已索引的表增加索引，应该考虑所要增加的索引是否是现有多列索引的最左索引。如果是，则就不要费力去增加这个索引了，因为已经有了。</td></tr><tr><td>避免索引失效</td><td> </td></tr></tbody></table><p><strong>不推荐使用索引的情况</strong></p><table><thead><tr><th><strong>情况</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>查询不频繁的字段</td><td>既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</td></tr><tr><td>数据唯一性差（一个字段的取值只有几种时）的字段不要使用索引</td><td>比如性别，只有两种可能数据。意味着索引的二叉树级别少，多是平级。这样的二叉树查找无异于全表扫描。</td></tr><tr><td>修改频率远远大于查询频率</td><td>比如login count（登录次数），频繁变化导致索引也频繁变化，增大数据库工作量，降低效率。 修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</td></tr></tbody></table><h2 id="存储引擎-myisam和innodb的区别">存储引擎-MyISAM和InnoDB的区别</h2><p><strong>InnoDB占优势的项</strong></p><table><thead><tr><th><strong>项</strong></th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td><strong>事务</strong></td><td>支持。 每条SQL语言都默认封装成事务，自动提交。最好把多条SQL语言放在begin和commit之间，组成一个事务</td><td>不支持</td></tr><tr><td><strong>外键</strong></td><td>支持。 将拥有外键的InnoDB表转成MyISAM会失败报错</td><td>不支持</td></tr><tr><td><strong>锁</strong></td><td>表级锁、行级锁（默认）。 行锁实现在索引上，不是锁在物理行记录上。若访问没有命中索引，行锁退化为表锁。</td><td>表级锁 并发量低。</td></tr><tr><td><strong>崩溃恢复</strong></td><td>支持</td><td>不支持</td></tr></tbody></table><p><strong>MyISAM占优势的项</strong></p><table><thead><tr><th><strong>项</strong></th><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td><strong>全文索引</strong></td><td>不支持</td><td>支持</td></tr></tbody></table><p>注意：从MySQL5.6之后，InnoDB也支持全文索引了。</p><p><strong>使用场景</strong></p><table><thead><tr><th><strong>InnoDB</strong></th><th><strong>MyISAM</strong></th></tr></thead><tbody><tr><td>并发高或需要事务的地方。</td><td>读操作远远超过写操作，且不需要事务的地方。</td></tr></tbody></table><h1 id="redis">Redis</h1><h2 id="数据类型-1">数据类型</h2><p>在Java中，Redis的数据类型可以通过相应的Java数据结构或对象来操作。以下是如何在Java中使用Redis的五种数据类型的概述，通常通过使用Jedis（一个Redis的Java客户端）或Spring Data Redis来实现。</p><p><strong>字符串（String）</strong></p><p>Redis的字符串类型在Java中对应的是<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Integer</code>、<code class="language-plaintext highlighter-rouge">Long</code>等基础数据类型。</p><p><strong>操作示例</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"key"</span><span class="o">,</span> <span class="s">"value"</span><span class="o">);</span> <span class="c1">// 设置字符串</span>
<span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"key"</span><span class="o">);</span> <span class="c1">// 获取字符串</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">incr</span><span class="o">(</span><span class="s">"counter"</span><span class="o">);</span> <span class="c1">// 递增一个整数值</span>
</code></pre></div></div><p><strong>使用场景</strong>:</p><p>用于存储单个值，如缓存数据、计数器等。</p><p><strong>哈希（Hash）</strong></p><p><strong>概述</strong>:</p><p>Redis的哈希类型在Java中可以通过<code class="language-plaintext highlighter-rouge">Map&lt;String, String&gt;</code>或<code class="language-plaintext highlighter-rouge">HashMap&lt;String, String&gt;</code>来操作。</p><p><strong>操作示例</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">hset</span><span class="o">(</span><span class="s">"user:1000"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"John"</span><span class="o">);</span> <span class="c1">// 设置哈希值</span>
<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">hget</span><span class="o">(</span><span class="s">"user:1000"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">);</span> <span class="c1">// 获取哈希字段</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">hgetAll</span><span class="o">(</span><span class="s">"user:1000"</span><span class="o">);</span> <span class="c1">// 获取整个哈希表</span>
</code></pre></div></div><p><strong>使用场景</strong>:</p><p>用于存储对象属性，如用户信息、配置参数等。</p><p><strong>列表（List）</strong></p><p><strong>概述</strong>:</p><p>Redis的列表类型在Java中对应的是<code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>。</p><p><strong>操作示例</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">lpush</span><span class="o">(</span><span class="s">"messages"</span><span class="o">,</span> <span class="s">"Hello World"</span><span class="o">);</span> <span class="c1">// 向列表左侧插入元素</span>
<span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">rpop</span><span class="o">(</span><span class="s">"messages"</span><span class="o">);</span> <span class="c1">// 从列表右侧弹出元素</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">lrange</span><span class="o">(</span><span class="s">"messages"</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 获取整个列表</span>
</code></pre></div></div><p><strong>使用场景</strong>:</p><p>用于实现消息队列、任务队列等场景。</p><p><strong>集合（Set）</strong></p><p><strong>概述</strong>:</p><p>Redis的集合类型在Java中可以通过<code class="language-plaintext highlighter-rouge">Set&lt;String&gt;</code>来操作。</p><p><strong>操作示例</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">sadd</span><span class="o">(</span><span class="s">"tags"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">);</span> <span class="c1">// 向集合中添加元素</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">smembers</span><span class="o">(</span><span class="s">"tags"</span><span class="o">);</span> <span class="c1">// 获取集合中的所有元素</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">srem</span><span class="o">(</span><span class="s">"tags"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">);</span> <span class="c1">// 从集合中移除元素</span>
</code></pre></div></div><p><strong>使用场景</strong>:</p><p>用于存储无序的唯一元素，如标签、好友列表、去重集合等。</p><p><strong>有序集合（Sorted Set 或 ZSet）</strong></p><p><strong>概述</strong>:</p><p>Redis的有序集合类型在Java中可以通过<code class="language-plaintext highlighter-rouge">Map&lt;String, Double&gt;</code>来操作，<code class="language-plaintext highlighter-rouge">Double</code>表示分数。</p><p><strong>操作示例</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="n">jedis</span><span class="o">.</span><span class="na">zadd</span><span class="o">(</span><span class="s">"leaderboard"</span><span class="o">,</span> <span class="mf">100.0</span><span class="o">,</span> <span class="s">"player1"</span><span class="o">);</span> <span class="c1">// 向有序集合添加元素并设置分数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">zrange</span><span class="o">(</span><span class="s">"leaderboard"</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 按分数从低到高获取有序集合中的元素</span>
<span class="nc">Double</span> <span class="n">score</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">zscore</span><span class="o">(</span><span class="s">"leaderboard"</span><span class="o">,</span> <span class="s">"player1"</span><span class="o">);</span> <span class="c1">// 获取某个元素的分数</span>
</code></pre></div></div><p><strong>使用场景</strong>:</p><p>用于实现排行榜、按优先级排序的任务队列等场景。</p><p>在Java中操作Redis的五种数据类型时，Jedis库是一个常用的选择。通过这些基本操作，可以有效地利用Redis的功能来实现缓存、数据存储、排序、消息队列等各种功能。Spring Data Redis提供了更高级别的抽象和集成，适合与Spring框架结合使用。</p><h2 id="数据持久化">数据持久化</h2><p>Redis 提供了两种主要的数据持久化方式：<strong>RDB</strong>（Redis Database）和 <strong>AOF</strong>（Append Only File）。这两种方式各有优缺点，可以单独使用，也可以组合使用，以满足不同的需求。</p><p><strong>RDB（Redis Database）</strong></p><p>RDB 是 Redis 的一种快照（Snapshot）持久化方式。Redis 会在特定的时间点，将内存中的数据生成快照并保存到磁盘上，形成 <code class="language-plaintext highlighter-rouge">.rdb</code> 文件。</p><p>特点：</p><ul><li><strong>触发方式</strong>：<ul><li>手动触发：使用 <code class="language-plaintext highlighter-rouge">SAVE</code> 命令（阻塞 Redis 进程）或 <code class="language-plaintext highlighter-rouge">BGSAVE</code> 命令（非阻塞，后台异步执行）生成 RDB 文件。</li><li>自动触发：可以通过配置文件设置某个时间段内达到指定的修改次数自动触发快照保存。</li></ul></li><li><strong>优点</strong>：<ul><li>文件紧凑：RDB 文件是 Redis 内存数据的压缩快照，占用磁盘空间小，适合用于备份。</li><li>恢复速度快：RDB 文件在恢复数据时速度较快，适合用作灾难恢复的方案。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能丢失：由于 RDB 是定期生成快照，若 Redis 意外崩溃，在上次快照生成之后到崩溃期间的数据将丢失。</li><li>持久化性能影响：生成 RDB 文件时需要进行大量的 I/O 操作，如果数据量大，可能会影响 Redis 的性能。</li></ul></li></ul><p><strong>AOF（Append Only File）</strong></p><p>AOF 是通过记录每个写操作的日志来实现持久化的。Redis 会将每个写命令追加到 AOF 文件中，当 Redis 重启时，可以通过重新执行 AOF 文件中的命令来恢复数据。</p><p>特点：</p><ul><li><strong>触发方式</strong>：<ul><li>默认情况下，每个写操作都会同步写入 AOF 文件。也可以通过配置文件设置不同的同步策略，如每秒写一次或从不写（但为了数据安全，通常不会选择这种策略）。</li></ul></li><li><strong>优点</strong>：<ul><li>数据丢失较少：AOF 记录每个写操作的日志，因此即使 Redis 意外崩溃，也只会丢失少量数据（取决于同步策略）。</li><li>可控性强：AOF 文件的内容是可读的，可以通过编辑 AOF 文件来修复错误数据或丢弃特定操作。</li></ul></li><li><strong>缺点</strong>：<ul><li>文件体积较大：由于 AOF 是将所有写操作记录下来，因此相比 RDB 文件，AOF 文件会更大，且需要定期进行压缩（AOF 重写）以控制文件大小。</li><li>恢复速度较慢：AOF 在重启时需要执行日志中的所有命令，恢复数据的过程比 RDB 慢。</li></ul></li></ul><p><strong>混合持久化（Hybrid Persistence）</strong></p><p>Redis 4.0 及以上版本引入了混合持久化的概念，它结合了 RDB 和 AOF 的优点。在 Redis 进行 AOF 重写时，首先生成一个新的 RDB 快照，然后在快照的基础上追加新命令的日志。这种方式在恢复数据时，只需加载 RDB 快照和少量的 AOF 日志，既能保证数据的完整性，又能加快恢复速度。</p><p><strong>持久化方案的选择</strong></p><ul><li><strong>纯 RDB 模式</strong>：适合对数据丢失不敏感，并且需要快速启动和小文件占用的场景，如缓存应用。</li><li><strong>纯 AOF 模式</strong>：适合对数据持久化要求高、对数据丢失敏感的场景，如金融交易系统。</li><li><strong>RDB + AOF 混合模式</strong>：适合既需要较高的数据安全性，又需要合理的性能和恢复速度的场景，如用户数据存储。</li></ul><p>Redis 提供的 RDB 和 AOF 两种持久化方式各有优缺点，可以根据具体的业务需求进行选择和配置。此外，结合两种方式的混合持久化方案在实际应用中也被广泛使用，以达到数据安全性和性能的平衡。</p><hr /><p>在 Java 应用中使用 Redis，并且希望控制 Redis 的持久化行为，通常会采用以下几种方式：</p><p><strong>使用 Redis 的 Java 客户端库</strong></p><p>在 Java 应用中，可以使用 Redis 的 Java 客户端库，如 <strong>Jedis</strong> 或 <strong>Lettuce</strong>，来与 Redis 进行交互。这些库提供了与 Redis 服务器通信的接口，可以用来发送 Redis 命令，包括与持久化相关的命令。</p><p>示例：使用 Jedis 执行持久化操作</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis.clients.jedis.Jedis</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisPersistenceExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 连接到本地的 Redis 服务</span>
        <span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>

        <span class="c1">// 触发 RDB 快照保存</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">save</span><span class="o">();</span> <span class="c1">// 同步保存，阻塞 Redis 进程</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">bgsave</span><span class="o">();</span> <span class="c1">// 异步保存，不会阻塞 Redis 进程</span>

        <span class="c1">// 配置 AOF 持久化策略</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">configSet</span><span class="o">(</span><span class="s">"appendonly"</span><span class="o">,</span> <span class="s">"yes"</span><span class="o">);</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">configSet</span><span class="o">(</span><span class="s">"appendfsync"</span><span class="o">,</span> <span class="s">"everysec"</span><span class="o">);</span>

        <span class="c1">// 关闭连接</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>配置 Redis 持久化</strong></p><p>当 Java 应用启动 Redis 实例时，可以通过配置文件或命令行参数来指定持久化的行为。例如，可以在 Redis 的配置文件 <code class="language-plaintext highlighter-rouge">redis.conf</code> 中设置持久化选项，这些设置会在 Redis 启动时生效。</p><p>示例：配置 Redis 持久化（redis.conf）</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 启用 RDB 持久化，每 15 分钟内有 1000 次写操作时触发快照保存</span>
save 900 1000

<span class="c"># 启用 AOF 持久化，并设置每秒写一次日志</span>
appendonly <span class="nb">yes
</span>appendfsync everysec
</code></pre></div></div><p><strong>Redis 持久化的控制和监控</strong></p><p>在 Java 应用中，还可以通过 Redis 客户端库发送持久化相关的命令，控制 Redis 的持久化行为，并监控持久化的状态。例如，可以使用 <code class="language-plaintext highlighter-rouge">INFO Persistence</code> 命令来获取持久化的详细信息，如上次 RDB 快照的生成时间，AOF 文件的当前状态等。</p><p>示例：获取 Redis 持久化状态</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis.clients.jedis.Jedis</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisPersistenceInfo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 连接到本地的 Redis 服务</span>
        <span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>

        <span class="c1">// 获取持久化相关的信息</span>
        <span class="nc">String</span> <span class="n">persistenceInfo</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"persistence"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">persistenceInfo</span><span class="o">);</span>

        <span class="c1">// 关闭连接</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>使用 Spring Data Redis</strong></p><p>如果在 Java 应用中使用了 Spring 框架，可以使用 <strong>Spring Data Redis</strong> 来更方便地与 Redis 进行交互。Spring Data Redis 同样可以执行 Redis 的持久化命令，但通常通过配置方式来控制 Redis 的持久化行为。</p><p>示例：Spring Data Redis 配置</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.connection.jedis.JedisConnectionFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.data.redis.core.RedisTemplate</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">JedisConnectionFactory</span> <span class="nf">jedisConnectionFactory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">JedisConnectionFactory</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">redisTemplate</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">template</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisTemplate</span><span class="o">&lt;&gt;();</span>
        <span class="n">template</span><span class="o">.</span><span class="na">setConnectionFactory</span><span class="o">(</span><span class="n">jedisConnectionFactory</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">template</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在 Java 中与 Redis 交互时，持久化机制依然遵循 Redis 的原生机制——RDB 和 AOF。Java 开发者可以通过使用 Redis 的 Java 客户端库（如 Jedis 或 Lettuce）或 Spring Data Redis 来控制和配置 Redis 的持久化行为。通过这些工具，Java 应用可以灵活地实现数据持久化，并确保数据在 Redis 中的安全性和一致性。</p><h2 id="内存淘汰机制">内存淘汰机制</h2><p>Redis 的内存淘汰机制（Eviction Policy）是指当 Redis 内存使用量达到设定的最大值时，根据一定的策略淘汰部分数据，以腾出空间存储新的数据。Redis 支持多种内存淘汰策略，可以根据具体应用场景选择最合适的策略。</p><p>在 Java 中，与 Redis 的内存淘汰机制交互通常是通过 Redis 客户端（如 Jedis、Lettuce）来进行管理和配置的，以下是 Redis 支持的几种主要内存淘汰策略：</p><p><strong>noeviction</strong></p><ul><li><strong>策略描述</strong>：当内存使用达到限制时，不再进行数据淘汰，直接返回错误。</li><li><strong>适用场景</strong>：当希望数据严格受控且不允许丢失时使用，通常在内存充足或对数据丢失敏感的应用场景下使用。</li></ul><p><strong>allkeys-lru</strong>（Least Recently Used）</p><ul><li><strong>策略描述</strong>：从所有键中淘汰最少使用的键（基于 LRU 算法）。</li><li><strong>适用场景</strong>：适用于缓存场景，淘汰不常访问的数据，保留最近访问的数据。</li></ul><p><strong>volatile-lru</strong></p><ul><li><strong>策略描述</strong>：只从设置了过期时间的键中淘汰最少使用的键。</li><li><strong>适用场景</strong>：用于需要设置过期时间的缓存数据，确保只有可能被自动删除的数据被淘汰。</li></ul><p><strong>allkeys-random</strong></p><ul><li><strong>策略描述</strong>：从所有键中随机淘汰一些键。</li><li><strong>适用场景</strong>：在需要简单的随机淘汰机制时使用，通常在对淘汰策略不敏感的场景下使用。</li></ul><p><strong>volatile-random</strong></p><ul><li><strong>策略描述</strong>：只从设置了过期时间的键中随机淘汰。</li><li><strong>适用场景</strong>：适用于需要设置过期时间的缓存数据，同时对淘汰策略不敏感的场景。</li></ul><p><strong>volatile-ttl</strong></p><ul><li><strong>策略描述</strong>：从设置了过期时间的键中淘汰即将过期的键（TTL 最短的键优先淘汰）。</li><li><strong>适用场景</strong>：用于缓存有明确生命周期的数据，确保即将到期的数据优先被淘汰。</li></ul><p><strong>allkeys-lfu</strong>（Least Frequently Used）</p><ul><li><strong>策略描述</strong>：从所有键中淘汰使用频率最低的键（基于 LFU 算法）。</li><li><strong>适用场景</strong>：适用于需要根据使用频率淘汰数据的场景，尤其在缓存热点数据时效果较好。</li></ul><p><strong>volatile-lfu</strong></p><ul><li><strong>策略描述</strong>：只从设置了过期时间的键中淘汰使用频率最低的键。</li><li><strong>适用场景</strong>：适用于需要结合过期时间和使用频率淘汰数据的场景。</li></ul><p><strong>设置最大内存和淘汰策略</strong></p><p>可以通过配置 Redis 的最大内存使用量和淘汰策略来控制内存管理行为。例如，使用 Jedis 设置最大内存和淘汰策略：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis.clients.jedis.Jedis</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisEvictionPolicyExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 连接到本地的 Redis 服务</span>
        <span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>

        <span class="c1">// 设置 Redis 的最大内存为 100MB</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">configSet</span><span class="o">(</span><span class="s">"maxmemory"</span><span class="o">,</span> <span class="s">"100mb"</span><span class="o">);</span>

        <span class="c1">// 设置内存淘汰策略为 allkeys-lru</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">configSet</span><span class="o">(</span><span class="s">"maxmemory-policy"</span><span class="o">,</span> <span class="s">"allkeys-lru"</span><span class="o">);</span>

        <span class="c1">// 关闭连接</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>监控和管理内存使用</strong></p><p>可以通过 Redis 客户端获取内存使用情况，并监控内存淘汰策略的效果。通过 <code class="language-plaintext highlighter-rouge">INFO memory</code> 命令可以查看当前内存使用情况：</p><p>示例：获取内存使用情况</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">redis.clients.jedis.Jedis</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisMemoryInfo</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 连接到本地的 Redis 服务</span>
        <span class="nc">Jedis</span> <span class="n">jedis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Jedis</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>

        <span class="c1">// 获取内存使用情况</span>
        <span class="nc">String</span> <span class="n">memoryInfo</span> <span class="o">=</span> <span class="n">jedis</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"memory"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">memoryInfo</span><span class="o">);</span>

        <span class="c1">// 关闭连接</span>
        <span class="n">jedis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Redis 的内存淘汰机制在内存达到上限时非常重要，它可以确保系统在高负载下仍然能够正常工作。根据不同的使用场景，选择合适的淘汰策略可以优化 Redis 的性能和可靠性。Java 开发者可以通过 Redis 的 Java 客户端来配置和监控这些策略，从而更好地管理 Redis 的内存使用情况。</p><h2 id="雪崩">雪崩</h2><p>Redis 作为一种高性能的缓存系统，在高并发的场景下，如果设计不当，可能会出现“雪崩”、“击穿”、“穿透”。</p><p>Redis 雪崩是指在短时间内，大量的缓存数据同时失效，导致大量请求直接打到数据库，造成数据库的瞬时压力剧增，甚至可能导致数据库宕机。</p><p><strong>原因</strong>:</p><ul><li>大量缓存设置了相同的过期时间，导致在某个时间点同时失效。</li><li>Redis 服务本身不可用（例如宕机或网络故障），所有请求直接打到数据库。</li></ul><p><strong>应对措施</strong>:</p><ul><li><p><strong>缓存数据的过期时间设置成随机值</strong>：通过设置缓存的过期时间为一个随机的区间，避免同一时间大量缓存同时失效。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">randomExpiry</span> <span class="o">=</span> <span class="n">baseExpiryTime</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="n">randomRange</span><span class="o">);</span>
</code></pre></div></div></li><li><p><strong>设置缓存预热机制</strong>：在系统启动时，将热点数据提前加载到缓存中，防止冷启动时的高并发直接打到数据库。</p></li><li><p><strong>多级缓存</strong>：在 Redis 之前加一层本地缓存或分布式缓存，如 Memcached，以减少对 Redis 的依赖。</p></li><li><p><strong>限流、降级措施</strong>：在缓存失效或 Redis 宕机时，可以通过限流、降级策略来保护数据库。</p></li><li><p><strong>Redis 高可用架构</strong>：通过 Redis 的主从复制、哨兵模式或集群模式，保证在 Redis 单点故障时，系统能自动切换到其他节点，保证服务的连续性。</p></li></ul><h2 id="击穿">击穿</h2><p>Redis 击穿指的是某个热点key在缓存中失效后，大量并发请求同时打到数据库，可能会导致数据库瞬时压力过大。</p><p><strong>应对措施</strong>:</p><ul><li><p><strong>热点数据永不过期</strong>：对于极为热点的数据，可以考虑将其缓存设置为永不过期，定期手动更新缓存。</p></li><li><p><strong>加锁（Mutex）机制</strong>：在缓存失效后，使用分布式锁（如基于 Redis 的锁机制）来控制对数据库的访问，使得只有一个线程可以访问数据库，其他线程等待或返回旧缓存。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">redis</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 查询数据库并更新缓存</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// 返回旧缓存数据</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></li><li><p><strong>设置合理的缓存失效策略</strong>：根据数据的访问频率和更新频率，合理设置缓存的失效时间，避免热点数据频繁失效。</p></li></ul><h2 id="穿透">穿透</h2><p>Redis 穿透是指缓存和数据库中<strong>都不存在</strong>的数据被大量请求，导致所有请求都打到数据库，可能造成数据库压力过大。</p><p><strong>应对措施</strong>:</p><ul><li><p><strong>缓存空结果</strong>：如果数据库中也没有对应的数据，仍然将结果（如空对象或空值）缓存起来，并设置一个短时间的过期时间，防止相同的请求反复打到数据库。</p></li><li><p><strong>布隆过滤器</strong>：在请求到达缓存之前，使用布隆过滤器对请求的key进行过滤，如果key不存在于布隆过滤器中，直接返回，减少对缓存和数据库的访问。</p></li></ul><h1 id="docker">Docker</h1><p>修改名称与标签命令：<code class="language-plaintext highlighter-rouge">docker tag [imageID] [name:tag]</code></p><p>打包容器为镜像：<code class="language-plaintext highlighter-rouge">docker commit [容器ID] [镜像名称:tag]</code></p><p>查看镜像：<code class="language-plaintext highlighter-rouge">docker images</code></p><p>查看运行中的容器：<code class="language-plaintext highlighter-rouge">docker ps</code></p><p>导出镜像： <code class="language-plaintext highlighter-rouge">docker save -o &lt;保存路径&gt;/&lt;镜像名&gt;.tar &lt;镜像名&gt;:&lt;标签&gt;</code></p><p>导入镜像：<code class="language-plaintext highlighter-rouge">docker load -i &lt;tar文件路径&gt;</code></p><p>登录Docker仓库：<code class="language-plaintext highlighter-rouge">docker login [repository]</code>，<code class="language-plaintext highlighter-rouge">repository</code>是仓库网址，如果做了DNS映射，则填写映射，如<code class="language-plaintext highlighter-rouge">local.harbor</code>。</p><h2 id="推送镜像">推送镜像</h2><p>推送镜像命令：<code class="language-plaintext highlighter-rouge">docker push [name:tag]</code></p><p><code class="language-plaintext highlighter-rouge">name</code> 是你要推送的镜像名称，通常包括仓库名。<code class="language-plaintext highlighter-rouge">tag</code> 是镜像的标签，通常用于版本控制。默认标签是 <code class="language-plaintext highlighter-rouge">latest</code>。</p><p>当你运行 <code class="language-plaintext highlighter-rouge">docker push</code> 时，Docker 会：</p><ul><li>检查你本地是否有指定的镜像和标签。</li><li>如果镜像不存在，命令将失败。</li><li>如果镜像存在，Docker 会开始将镜像分层推送到指定的仓库。这包括：<ul><li>检查每一层是否已存在于远程仓库。</li><li>仅推送那些在远程仓库中不存在的层。</li></ul></li><li>一旦所有层都推送成功，镜像将出现在远程仓库中。</li></ul><p>假设你有一个名为 <code class="language-plaintext highlighter-rouge">myapp</code> 的镜像，标签为 <code class="language-plaintext highlighter-rouge">v1.0</code>，并且想将它推送到 Docker Hub：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker push myusername/myapp:v1.0
</code></pre></div></div><p><strong>常见问题</strong>：</p><ul><li>如果在推送时遇到权限错误，确保已正确登录并且具有推送该仓库的权限。</li><li>如果网络不稳定，推送可能会失败，通常可以重试。</li></ul><p>这个过程确保你的 Docker 镜像能够安全地存储在远程仓库，以便其他用户或服务可以访问和使用。</p><h2 id="打包镜像">打包镜像</h2><p><code class="language-plaintext highlighter-rouge">Dockerfile</code>:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FROM local.harbor/jdk/jdk17:latest</span>
FROM local.harbor/base/alpine-java:8_server-jre_unlimited
<span class="c">#FROM anapsix/alpine-java:8_server-jre_unlimited</span>
<span class="c">#FROM wangxunlogin/java8</span>
<span class="c">#FROM apline/java8-ssh:1.0.0</span>
<span class="c">#ARG jarfile</span>
RUN <span class="nb">mkdir</span> <span class="nt">-p</span> /formflowprovider
<span class="c">#COPY $jarfile /formflowprovider/app.jar \</span>

COPY target/formflowprovider-1.1.1.jar /formflowprovider/app.jar

WORKDIR /formflowprovider
EXPOSE 9081
<span class="c">#ADD ./target/erueka-1.0.0.jar ./</span>
ENV CONG_ARG <span class="s1">''</span>
ENV J_ARG <span class="s1">' -Xms512m -Xmx3072m -Xss325k -XX:MaxNewSize=512m '</span>
ENV LOG_PATH  <span class="s1">'/formflowprovider/logs/'</span>
ENV JIEAN_LOG_LEVEL info
ENV LOG_FILE <span class="s1">'formflowprovider.log'</span>
CMD java <span class="nv">$J_ARG</span> <span class="nt">-Dfile</span>.encoding<span class="o">=</span>UTF8  <span class="nt">-Duser</span>.timezone<span class="o">=</span>GMT+08  <span class="nt">-Djava</span>.security.egd<span class="o">=</span>file:/dev/./urandom <span class="nt">-jar</span> app.jar <span class="nv">$CONG_ARG</span> <span class="nt">--logging</span>.path<span class="o">=</span><span class="nv">$LOG_PATH</span>
</code></pre></div></div><p>在命令行中，进入到包含 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 的目录，然后运行以下命令：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> your_image_name:your_tag 
</code></pre></div></div><h2 id="使用maven插件">使用maven插件</h2><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;project&gt;</span>
    ...
    <span class="nt">&lt;properties&gt;</span>
        <span class="nt">&lt;docker.server.addr&gt;</span>local.harbor/release/<span class="nt">&lt;/docker.server.addr&gt;</span> <span class="c">&lt;!-- Docker 服务器地址 --&gt;</span>
        <span class="nt">&lt;docker.server.id&gt;</span>docker<span class="nt">&lt;/docker.server.id&gt;</span> <span class="c">&lt;!-- Docker 服务器 ID --&gt;</span>
        <span class="nt">&lt;docker.directory.path&gt;</span>docker<span class="nt">&lt;/docker.directory.path&gt;</span> <span class="c">&lt;!-- Dockerfile 存在的目录 --&gt;</span>
        <span class="nt">&lt;docker.tag.version&gt;</span>1.0.42<span class="nt">&lt;/docker.tag.version&gt;</span> <span class="c">&lt;!-- Docker 镜像版本 --&gt;</span>
    <span class="nt">&lt;/properties&gt;</span>

    <span class="nt">&lt;build&gt;</span>
        <span class="nt">&lt;plugins&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
            <span class="nt">&lt;/plugin&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                <span class="nt">&lt;groupId&gt;</span>com.spotify<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;artifactId&gt;</span>docker-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
                <span class="nt">&lt;version&gt;</span>1.2.11<span class="nt">&lt;/version&gt;</span>
                <span class="nt">&lt;configuration&gt;</span>
                    <span class="nt">&lt;skipDocker&gt;</span>false<span class="nt">&lt;/skipDocker&gt;</span> <span class="c">&lt;!-- 设置为 false 不跳过 Docker 构建 --&gt;</span>
                    <span class="nt">&lt;pushImage&gt;</span>true<span class="nt">&lt;/pushImage&gt;</span> <span class="c">&lt;!-- 构建后自动推送镜像 --&gt;</span>
                    <span class="nt">&lt;forceTags&gt;</span>true<span class="nt">&lt;/forceTags&gt;</span> <span class="c">&lt;!-- 强制覆盖已有镜像标签 --&gt;</span>
                    <span class="nt">&lt;imageName&gt;</span>${docker.server.addr}${project.artifactId}:${docker.tag.version}<span class="nt">&lt;/imageName&gt;</span> <span class="c">&lt;!-- 动态构建镜像名称 --&gt;</span>
                    <span class="nt">&lt;dockerDirectory&gt;</span>${docker.directory.path}<span class="nt">&lt;/dockerDirectory&gt;</span> <span class="c">&lt;!-- 指定 Docker 目录 --&gt;</span>
                    <span class="nt">&lt;serverId&gt;</span>${docker.server.id}<span class="nt">&lt;/serverId&gt;</span> <span class="c">&lt;!-- Docker 服务器 ID --&gt;</span>
                    <span class="nt">&lt;buildArgs&gt;</span>
                        <span class="nt">&lt;jarfile&gt;</span>${project.build.finalName}.jar<span class="nt">&lt;/jarfile&gt;</span> <span class="c">&lt;!-- 指定 JAR 文件名 --&gt;</span>
                    <span class="nt">&lt;/buildArgs&gt;</span>
                    <span class="nt">&lt;resources&gt;</span>
                        <span class="nt">&lt;resource&gt;</span>
                            <span class="nt">&lt;targetPath&gt;</span>/<span class="nt">&lt;/targetPath&gt;</span> <span class="c">&lt;!-- JAR 文件在 Docker 镜像中的目标路径 --&gt;</span>
                            <span class="nt">&lt;directory&gt;</span>${project.build.directory}<span class="nt">&lt;/directory&gt;</span> <span class="c">&lt;!-- 构建输出目录 --&gt;</span>
                            <span class="nt">&lt;include&gt;</span>${project.build.finalName}.jar<span class="nt">&lt;/include&gt;</span> <span class="c">&lt;!-- 要包含的文件 --&gt;</span>
                        <span class="nt">&lt;/resource&gt;</span>
                    <span class="nt">&lt;/resources&gt;</span>
                <span class="nt">&lt;/configuration&gt;</span>
                <span class="nt">&lt;executions&gt;</span>
                    <span class="nt">&lt;execution&gt;</span>
                        <span class="nt">&lt;id&gt;</span>builddocker<span class="nt">&lt;/id&gt;</span> <span class="c">&lt;!-- 执行 ID --&gt;</span>
                        <span class="nt">&lt;goals&gt;</span>
                            <span class="nt">&lt;goal&gt;</span>builddocker<span class="nt">&lt;/goal&gt;</span> <span class="c">&lt;!-- 目标为构建 Docker 镜像 --&gt;</span>
                        <span class="nt">&lt;/goals&gt;</span>
                    <span class="nt">&lt;/execution&gt;</span>
                <span class="nt">&lt;/executions&gt;</span>
            <span class="nt">&lt;/plugin&gt;</span>
        <span class="nt">&lt;/plugins&gt;</span>
    <span class="nt">&lt;/build&gt;</span>
    ...
<span class="nt">&lt;/project&gt;</span>
</code></pre></div></div><p>运行以下命令构建并推送 Docker 镜像：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvn clean package
</code></pre></div></div><p>这样构建的镜像名称将会是类似 <code class="language-plaintext highlighter-rouge">local.harbor/release/your-artifact-id:1.0.42</code> 的格式。</p><hr /><p>在配置中，以下部分定义了执行：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;executions&gt;</span>
    <span class="nt">&lt;execution&gt;</span>
        <span class="nt">&lt;id&gt;</span>builddocker<span class="nt">&lt;/id&gt;</span>
        <span class="nt">&lt;goals&gt;</span>
            <span class="nt">&lt;goal&gt;</span>builddocker<span class="nt">&lt;/goal&gt;</span>
        <span class="nt">&lt;/goals&gt;</span>
    <span class="nt">&lt;/execution&gt;</span>
<span class="nt">&lt;/executions&gt;</span>
</code></pre></div></div><p>如果没有 <code class="language-plaintext highlighter-rouge">&lt;phase&gt;</code> 元素，Maven 将默认使用插件的内部绑定，这意味着当执行 <code class="language-plaintext highlighter-rouge">package</code> 时，这个目标会被自动调用。</p><p>要确认 <code class="language-plaintext highlighter-rouge">docker-maven-plugin</code> 是否自动执行，你可以查看插件的文档或源代码，查看它是否在 <code class="language-plaintext highlighter-rouge">package</code> 生命周期阶段中进行绑定。也可以通过以下命令查看 Maven 的执行计划：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mvn <span class="nb">help</span>:effective-pom
</code></pre></div></div><p>这将显示当前项目的有效 POM，包括所有继承和插件配置，帮助你了解插件在生命周期中的绑定情况。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/09/03/%E5%85%B6%E4%BB%96/" target="_blank">https://acteds.github.io/2021/09/03/%E5%85%B6%E4%BB%96/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1742558906', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
