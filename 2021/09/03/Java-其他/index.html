<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java 其他 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/09/03/Java-%E5%85%B6%E4%BB%96/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="Java 其他"><meta name="keywords" content="博客"><meta name="og:keywords" content="博客"><meta name="description" content=""><meta name="og:description" content=""><meta property="og:url" content="/2021/09/03/Java-%E5%85%B6%E4%BB%96/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-09-03"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java 其他"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java 其他</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/09/03 </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 23397 字，约 67 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>一些零散的笔记。</p><h1 id="xml">XML</h1><p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p><p>例如，一个描述书籍的XML文档可能如下：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="cp">&lt;!DOCTYPE note SYSTEM "book.dtd"&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p>XML有几个特点：一是纯文本，默认使用UTF-8编码，二是可嵌套，适合表示结构化数据。如果把XML内容存为文件，那么它就是一个XML文件，例如<code class="language-plaintext highlighter-rouge">book.xml</code>。此外，XML内容经常通过网络作为消息传输。</p><p>XML有固定的结构，首行必定是<code class="language-plaintext highlighter-rouge">&lt;?xml version="1.0"?&gt;</code>，可以加上可选的编码。紧接着，如果以类似<code class="language-plaintext highlighter-rouge">&lt;!DOCTYPE note SYSTEM "book.dtd"&gt;</code>声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。接下来是XML的文档内容，一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，<code class="language-plaintext highlighter-rouge">&lt;isbn lang="CN"&gt;1234567&lt;/isbn&gt;</code>包含一个属性<code class="language-plaintext highlighter-rouge">lang="CN"</code>，且元素必须正确嵌套。如果是空元素，可以用<code class="language-plaintext highlighter-rouge">&lt;tag/&gt;</code>表示。</p><p>由于使用了<code class="language-plaintext highlighter-rouge">&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;</code>以及引号等标识符，如果内容出现了特殊符号，需要使用<code class="language-plaintext highlighter-rouge">&amp;???;</code>表示转义。例如，<code class="language-plaintext highlighter-rouge">Java&lt;tm&gt;</code>必须写成：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;name&gt;Java&amp;lt;tm&amp;gt;&lt;/name&gt;
</code></pre></div></div><p>常见的特殊字符如下：</p><table><thead><tr><th style="text-align: left">字符</th><th style="text-align: left">表示</th></tr></thead><tbody><tr><td style="text-align: left">&lt;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;lt;</code></td></tr><tr><td style="text-align: left">&gt;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;gt;</code></td></tr><tr><td style="text-align: left">&amp;</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;amp;</code></td></tr><tr><td style="text-align: left">”</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;quot;</code></td></tr><tr><td style="text-align: left">’</td><td style="text-align: left"><code class="language-plaintext highlighter-rouge">&amp;apos;</code></td></tr></tbody></table><p>格式正确的XML（Well Formed）可以被解析器正常读取。而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证。</p><p>DTD文档可以指定一系列规则，例如：</p><ul><li>根元素必须是<code class="language-plaintext highlighter-rouge">book</code></li><li><code class="language-plaintext highlighter-rouge">book</code>元素必须包含<code class="language-plaintext highlighter-rouge">name</code>，<code class="language-plaintext highlighter-rouge">author</code>等指定元素</li><li><code class="language-plaintext highlighter-rouge">isbn</code>元素必须包含属性<code class="language-plaintext highlighter-rouge">lang</code></li><li>…</li></ul><p>如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。</p><p>和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。</p><p>XML是一个技术体系，除了经常用到的XML文档本身外，XML还支持：</p><ul><li>DTD和XSD：验证XML结构和数据是否有效；</li><li>Namespace：XML节点和属性的名字空间；</li><li>XSLT：把XML转化为另一种文本；</li><li>XPath：一种XML节点查询语言；</li><li>…</li></ul><p>因为XML是一种树形结构的文档，它有两种标准的解析API：</p><ul><li>DOM：一次性读取XML，并在内存中表示为树形结构；</li><li>SAX：以流的形式读取XML，使用事件回调。</li></ul><h2 id="使用dom解析">使用DOM解析</h2><p>DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个树形结构处理，从根节点开始，每个节点都可以包含任意个子节点。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">document</code>代表XML文档，是真正的“根”，而<code class="language-plaintext highlighter-rouge">&lt;book&gt;</code>虽然是根元素，但它是<code class="language-plaintext highlighter-rouge">document</code>的一个子节点。</p><p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p><ul><li>Document：代表整个XML文档；</li><li>Element：代表一个XML元素；</li><li>Attribute：代表一个元素的某个属性。</li></ul><p>使用DOM解析一个XML文档的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.Document</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.NamedNodeMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.Node</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.w3c.dom.NodeList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.xml.sax.SAXException</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.xml.parsers.DocumentBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.parsers.DocumentBuilderFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.xml.parsers.ParserConfigurationException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">SAXException</span><span class="o">,</span> <span class="nc">ParserConfigurationException</span> <span class="o">{</span>
        <span class="c1">// 从文件、网络流或其他来源获取 XML 输入流</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
        <span class="nc">DocumentBuilderFactory</span> <span class="n">dbf</span> <span class="o">=</span> <span class="nc">DocumentBuilderFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="nc">DocumentBuilder</span> <span class="n">db</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="na">newDocumentBuilder</span><span class="o">();</span>
        <span class="c1">// 使用 DocumentBuilder 解析输入流，获取 Document 实例</span>
        <span class="nc">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="n">printNode</span><span class="o">(</span><span class="n">doc</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">printNode</span><span class="o">(</span><span class="nc">Node</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">DOCUMENT_NODE</span><span class="o">:</span> <span class="c1">// Document节点</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Document: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">ELEMENT_NODE</span><span class="o">:</span> <span class="c1">// 元素节点</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Element: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">TEXT_NODE</span><span class="o">:</span> <span class="c1">// 文本</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">matches</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">)){</span><span class="c1">//为空则无视</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Text = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">ATTRIBUTE_NODE</span><span class="o">:</span> <span class="c1">// 属性</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"Attr: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>

            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">CDATA_SECTION_NODE</span><span class="o">:</span><span class="c1">// 非解析文本</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span> <span class="s">"CDATA: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">trim</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nc">Node</span><span class="o">.</span><span class="na">COMMENT_NODE</span><span class="o">:</span><span class="c1">// 注释</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span> <span class="s">"Comment: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeValue</span><span class="o">().</span><span class="na">trim</span><span class="o">());</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span> <span class="c1">// 其他</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getRetraction</span><span class="o">(</span><span class="n">indent</span><span class="o">)+</span><span class="s">"NodeType: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">()</span> <span class="o">+</span> <span class="s">", NodeName: "</span> <span class="o">+</span> <span class="n">n</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">hasAttributes</span><span class="o">())</span> <span class="o">{</span><span class="c1">//有属性则递归</span>
            <span class="nc">NamedNodeMap</span> <span class="n">as</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">getAttributes</span><span class="o">();</span><span class="c1">// 获取标签内所有属性</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">as</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">printNode</span><span class="o">(</span><span class="n">as</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">indent</span><span class="o">+</span><span class="mi">2</span><span class="o">);</span><span class="c1">// 递归</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">hasChildNodes</span><span class="o">())</span> <span class="o">{</span><span class="c1">//有子节点则递归</span>
            <span class="nc">NodeList</span> <span class="n">childNodes</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">getChildNodes</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">childNodes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">printNode</span><span class="o">(</span><span class="n">childNodes</span><span class="o">.</span><span class="na">item</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">indent</span><span class="o">+</span><span class="mi">2</span><span class="o">);</span><span class="c1">// 递归</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">getRetraction</span><span class="o">(</span><span class="kt">int</span> <span class="n">indent</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">s</span><span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indent</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">s</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DocumentBuilder.parse()</code>用于解析一个XML，它可以接收<code class="language-plaintext highlighter-rouge">InputStream</code>，<code class="language-plaintext highlighter-rouge">File</code>或者<code class="language-plaintext highlighter-rouge">URL</code>，如果解析无误，将获得一个<code class="language-plaintext highlighter-rouge">Document</code>对象，这个对象代表了整个<code class="language-plaintext highlighter-rouge">XML</code>文档的树形结构。</p><p>从根节点<code class="language-plaintext highlighter-rouge">Document</code>出发，可以遍历所有子节点，获取所有元素、属性、文本数据，还可以包括注释，这些节点被统称为<code class="language-plaintext highlighter-rouge">Node</code>，每个<code class="language-plaintext highlighter-rouge">Node</code>都有自己的<code class="language-plaintext highlighter-rouge">Type</code>，根据<code class="language-plaintext highlighter-rouge">Type</code>来区分一个<code class="language-plaintext highlighter-rouge">Node</code>到底是元素，还是属性，还是文本，等等。</p><p>使用DOM API时，如果要读取某个元素的文本，需要访问它的Text类型的子节点，所以使用起来还是比较繁琐的，且DOM解析速度慢，内存占用大。</p><hr /><p><code class="language-plaintext highlighter-rouge">org.w3c.dom.Document</code> 接口表示整个 XML 文档，它是 DOM（Document Object Model） API 的核心接口之一。<code class="language-plaintext highlighter-rouge">Document</code> 对象提供了操作 XML 文档的方法，允许您访问和修改文档中的元素、属性和文本内容等。<code class="language-plaintext highlighter-rouge">Document</code> 接口定义了一些独有的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">Element getDocumentElement()</code>: 返回文档的根元素。</li><li><code class="language-plaintext highlighter-rouge">Element createElement(String tagName)</code>: 创建具有指定标签名称的新元素。</li><li><code class="language-plaintext highlighter-rouge">Text createTextNode(String data)</code>: 创建包含指定数据的新文本节点。</li><li><code class="language-plaintext highlighter-rouge">Attr createAttribute(String name)</code>: 创建具有指定名称的新属性节点。</li><li><code class="language-plaintext highlighter-rouge">Element getElementById(String elementId)</code>: 返回具有指定 ID 的元素。</li><li><code class="language-plaintext highlighter-rouge">Element createElementNS(String namespaceURI, String qualifiedName)</code>: 使用指定的命名空间URI和限定名称创建新元素。</li><li><code class="language-plaintext highlighter-rouge">Attr createAttributeNS(String namespaceURI, String qualifiedName)</code>: 使用指定的命名空间URI和限定名称创建新属性。</li><li><code class="language-plaintext highlighter-rouge">Node importNode(Node importedNode, boolean deep)</code>: 将节点从另一个文档导入到当前文档。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">org.w3c.dom.Node</code> 接口表示 DOM（Document Object Model）树中的一个节点，它是 DOM API 的核心接口之一。<code class="language-plaintext highlighter-rouge">Node</code> 接口定义了节点的通用属性和方法，所有 DOM 节点类型都实现了该接口，包括元素节点、文本节点、注释节点等。<code class="language-plaintext highlighter-rouge">Node</code> 接口的主要作用是：</p><ol><li><strong>表示 DOM 树中的一个节点：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口表示 DOM 树中的一个节点，每个节点可以是一个元素、属性、文本内容、注释等。</li><li><strong>提供访问节点的方法：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了一系列方法，用于访问和操作节点的属性、子节点和父节点等。</li><li><strong>定义节点类型：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口定义了表示不同类型节点的常量，如 <code class="language-plaintext highlighter-rouge">ELEMENT_NODE</code>、<code class="language-plaintext highlighter-rouge">TEXT_NODE</code>、<code class="language-plaintext highlighter-rouge">COMMENT_NODE</code> 等。</li><li><strong>节点关系：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了方法来获取节点的父节点、子节点、兄弟节点等关系信息。</li><li><strong>节点操作：</strong> <code class="language-plaintext highlighter-rouge">Node</code> 接口提供了方法来添加、移除、替换节点，以及克隆节点等操作。</li></ol><p>以下是一些常用的 <code class="language-plaintext highlighter-rouge">Node</code> 接口方法：</p><ol><li><strong>获取节点信息：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">String getNodeName()</code>: 返回节点的名称。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getNodeValue()</code>: 返回节点的值（仅适用于特定类型的节点，如文本节点）。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">short getNodeType()</code>: 返回节点的类型（例如，元素节点、文本节点等）。</strong></li></ul></li><li><strong>获取父节点和子节点：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node getParentNode()</code>: 返回父节点。</li><li><strong><code class="language-plaintext highlighter-rouge">NodeList getChildNodes()</code>: 返回子节点列表。</strong></li><li><code class="language-plaintext highlighter-rouge">Node getFirstChild()</code>: 返回第一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node getLastChild()</code>: 返回最后一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node getNextSibling()</code>: 返回下一个兄弟节点。</li><li><code class="language-plaintext highlighter-rouge">Node getPreviousSibling()</code>: 返回上一个兄弟节点。</li></ul></li><li><strong>操作节点：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node appendChild(Node newChild)</code>: 将节点添加为最后一个子节点。</li><li><code class="language-plaintext highlighter-rouge">Node removeChild(Node oldChild)</code>: 从子节点列表中删除指定的子节点。</li><li><code class="language-plaintext highlighter-rouge">Node replaceChild(Node newChild, Node oldChild)</code>: 用新节点替换指定的子节点。</li></ul></li><li><strong>判断节点关系：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">boolean hasChildNodes()</code>: 判断节点是否有子节点。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">boolean hasAttributes()</code>：判断节点是否有属性。</strong></li><li><code class="language-plaintext highlighter-rouge">boolean isSameNode(Node other)</code>: 判断节点是否与另一个节点相同。</li></ul></li><li><strong>其他方法：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node cloneNode(boolean deep)</code>: 复制节点（如果 <code class="language-plaintext highlighter-rouge">deep</code> 为 true，则同时复制子树）。</li><li><code class="language-plaintext highlighter-rouge">Document getOwnerDocument()</code>: 返回拥有当前节点的文档节点。</li></ul></li><li><strong>获取属性节点：</strong><ul><li><strong><code class="language-plaintext highlighter-rouge">NamedNodeMap getAttributes()</code>: 返回包含节点所有属性的 <code class="language-plaintext highlighter-rouge">NamedNodeMap</code> 对象。</strong></li></ul></li><li><strong>获取特定属性：</strong><ul><li><code class="language-plaintext highlighter-rouge">Node getAttributeNode(String name)</code>: 返回具有指定名称的属性节点。</li><li><code class="language-plaintext highlighter-rouge">String getAttribute(String name)</code>: 返回具有指定名称的属性的值。</li></ul></li><li><strong>添加和移除属性：</strong><ul><li><code class="language-plaintext highlighter-rouge">void setAttribute(String name, String value)</code>: 设置具有指定名称和值的属性。如果属性已存在，则替换旧值。</li><li><code class="language-plaintext highlighter-rouge">void removeAttribute(String name)</code>: 删除具有指定名称的属性。</li></ul></li><li><strong>判断属性是否存在：</strong><ul><li><code class="language-plaintext highlighter-rouge">boolean hasAttribute(String name)</code>: 判断节点是否具有指定名称的属性。</li></ul></li></ol><p>在 DOM（文档对象模型）中，不同类型的节点用不同的常量值表示，以便于区分节点的类型。这些常量由 <code class="language-plaintext highlighter-rouge">Node</code> 接口定义，可以通过 <code class="language-plaintext highlighter-rouge">Node</code> 接口的静态常量来访问。常见的节点类型包括：</p><ul><li><code class="language-plaintext highlighter-rouge">Node.ELEMENT_NODE</code>：表示元素节点。</li><li><code class="language-plaintext highlighter-rouge">Node.ATTRIBUTE_NODE</code>：表示属性节点。</li><li><code class="language-plaintext highlighter-rouge">Node.TEXT_NODE</code>：表示文本节点。</li><li><code class="language-plaintext highlighter-rouge">Node.COMMENT_NODE</code>：表示注释节点。</li><li><code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code>：表示文档节点。</li></ul><p><code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code> 表示整个文档的根节点，即文档对象（Document Object）。在 DOM 中，文档对象是整个 XML 或 HTML 文档的入口点，通过文档对象可以访问文档的所有内容，包括元素、属性、文本等。通常，使用 <code class="language-plaintext highlighter-rouge">Document</code> 类型的实例表示文档对象。</p><p>例如，可以通过以下方式检查一个节点是否为文档节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="o">...;</span> <span class="c1">// 获取一个节点</span>
<span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">getNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Node</span><span class="o">.</span><span class="na">DOCUMENT_NODE</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 这是一个文档节点</span>
    <span class="nc">Document</span> <span class="n">document</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Document</span><span class="o">)</span> <span class="n">node</span><span class="o">;</span>
    <span class="c1">// 可以对文档进行操作</span>
<span class="o">}</span>
</code></pre></div></div><p>通过比较节点的类型是否为 <code class="language-plaintext highlighter-rouge">Node.DOCUMENT_NODE</code>，可以判断节点是否为文档节点，从而进行相应的操作。</p><p>如果对<code class="language-plaintext highlighter-rouge">Document</code>进行了修改，要保存，则可以将修改后的内容保存到文件或其他输出流中。保存 <code class="language-plaintext highlighter-rouge">Document</code> 的常用方法是将其转换为字符串形式，然后将字符串写入文件或输出流中。</p><p>下面是一个简单的示例，演示了如何将修改后的 <code class="language-plaintext highlighter-rouge">Document</code> 保存到文件中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从文件、网络流或其他来源获取 XML 输入流</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">DocumentBuilderFactory</span> <span class="n">dbf</span> <span class="o">=</span> <span class="nc">DocumentBuilderFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">DocumentBuilder</span> <span class="n">db</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="na">newDocumentBuilder</span><span class="o">();</span>
<span class="c1">// 使用 DocumentBuilder 解析输入流，获取 Document 实例</span>
<span class="nc">Document</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="c1">// 创建一个 Transformer 对象</span>
<span class="nc">Transformer</span> <span class="n">transformer</span> <span class="o">=</span> <span class="nc">TransformerFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">().</span><span class="na">newTransformer</span><span class="o">();</span>
<span class="nc">DOMSource</span> <span class="n">source</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DOMSource</span><span class="o">(</span><span class="n">doc</span><span class="o">);</span>
<span class="c1">// 将字符串写入文件中</span>
<span class="nc">StreamResult</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StreamResult</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"1.xml"</span><span class="o">));</span>
<span class="c1">// 使用 Transformer 将 Document 转换为字符串形式</span>
<span class="n">transformer</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</code></pre></div></div><h2 id="使用sax解析">使用SAX解析</h2><p>使用DOM解析XML的优点是用起来省事，但它的主要缺点是内存占用太大。</p><p>另一种解析XML的方式是SAX。SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p><p>SAX解析会触发一系列事件：</p><ul><li>startDocument：开始读取XML文档；</li><li>startElement：读取到了一个元素，例如<code class="language-plaintext highlighter-rouge">&lt;book&gt;</code>；</li><li>characters：读取到了字符；</li><li>endElement：读取到了一个结束的元素，例如<code class="language-plaintext highlighter-rouge">&lt;/book&gt;</code>；</li><li>endDocument：读取XML文档结束。</li></ul><p>如果用SAX API解析XML，Java代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">SAXParserFactory</span> <span class="n">spf</span> <span class="o">=</span> <span class="nc">SAXParserFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">SAXParser</span> <span class="n">saxParser</span> <span class="o">=</span> <span class="n">spf</span><span class="o">.</span><span class="na">newSAXParser</span><span class="o">();</span>
<span class="n">saxParser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="k">new</span> <span class="nc">MyHandler</span><span class="o">());</span>
</code></pre></div></div><p>关键代码<code class="language-plaintext highlighter-rouge">SAXParser.parse()</code>除了需要传入一个<code class="language-plaintext highlighter-rouge">InputStream</code>外，还需要传入一个回调对象，这个对象要继承自<code class="language-plaintext highlighter-rouge">DefaultHandler</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">class</span> <span class="nc">MyHandler</span> <span class="kd">extends</span> <span class="nc">DefaultHandler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startDocument</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文档开始"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endDocument</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文档结束"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startElement</span><span class="o">(</span><span class="nc">String</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">String</span> <span class="n">localName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">qName</span><span class="o">,</span> <span class="nc">Attributes</span> <span class="n">attributes</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"元素："</span><span class="o">,</span> <span class="n">localName</span><span class="o">,</span> <span class="n">qName</span><span class="o">);</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"属性:"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">attributes</span><span class="o">.</span><span class="na">getLength</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">print</span><span class="o">(</span><span class="s">"  "</span><span class="o">,</span><span class="n">attributes</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="s">"="</span><span class="o">,</span><span class="n">attributes</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">endElement</span><span class="o">(</span><span class="nc">String</span> <span class="n">uri</span><span class="o">,</span> <span class="nc">String</span> <span class="n">localName</span><span class="o">,</span> <span class="nc">String</span> <span class="n">qName</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"元素结束:"</span><span class="o">,</span> <span class="n">localName</span><span class="o">,</span> <span class="n">qName</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">characters</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">ch</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"文本:"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">ch</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">length</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">error</span><span class="o">(</span><span class="nc">SAXParseException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">"错误:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果要读取<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>节点的文本，我们就必须在解析过程中根据<code class="language-plaintext highlighter-rouge">startElement()</code>和<code class="language-plaintext highlighter-rouge">endElement()</code>定位当前正在读取的节点，可以使用栈结构保存，每遇到一个<code class="language-plaintext highlighter-rouge">startElement()</code>入栈，每遇到一个<code class="language-plaintext highlighter-rouge">endElement()</code>出栈，这样，读到<code class="language-plaintext highlighter-rouge">characters()</code>时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。</p><p>SAX是一种流式解析XML的API；SAX通过事件触发，读取速度快，消耗内存少；调用方必须通过回调方法获得解析过程中的数据。</p><hr /><p>要创建 <code class="language-plaintext highlighter-rouge">SAXParser</code> 对象，通常使用 <code class="language-plaintext highlighter-rouge">SAXParserFactory</code> 工厂类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建 SAXParserFactory 实例</span>
<span class="nc">SAXParserFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">SAXParserFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// 指定是否验证 XML 文件，默认为 false</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setValidating</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 指定是否命名空间感知，默认为 false</span>
<span class="n">factory</span><span class="o">.</span><span class="na">setNamespaceAware</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 创建 SAXParser 实例</span>
<span class="nc">SAXParser</span> <span class="n">saxParser</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">newSAXParser</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">SAXParser</code> 类是用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档的类，它实现了 <code class="language-plaintext highlighter-rouge">XMLReader</code> 接口，提供了一系列方法来解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档。以下是 <code class="language-plaintext highlighter-rouge">SAXParser</code> 类的一些常用方法：</p><ul><li><code class="language-plaintext highlighter-rouge">parse(InputSource input, DefaultHandler handler)</code>：解析给定的输入源并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><strong><code class="language-plaintext highlighter-rouge">parse(InputStream is, DefaultHandler dh)</code>：解析给定的输入流并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</strong></li><li><code class="language-plaintext highlighter-rouge">parse(File f, DefaultHandler dh)</code>：解析给定的文件并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><code class="language-plaintext highlighter-rouge">parse(String uri, DefaultHandler dh)</code>：解析给定的 <code class="language-plaintext highlighter-rouge">URI</code> 并使用指定的处理程序处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容。</li><li><code class="language-plaintext highlighter-rouge">setContentHandler(ContentHandler handler)</code>：设置内容处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的内容。</li><li><code class="language-plaintext highlighter-rouge">setDTDHandler(DTDHandler handler)</code>：设置 <code class="language-plaintext highlighter-rouge">DTD</code> 处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的 <code class="language-plaintext highlighter-rouge">DTD</code> 声明。</li><li><code class="language-plaintext highlighter-rouge">setEntityResolver(EntityResolver resolver)</code>：设置实体解析器，用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档中的实体。</li><li><code class="language-plaintext highlighter-rouge">setErrorHandler(ErrorHandler handler)</code>：设置错误处理程序，用于处理 <code class="language-plaintext highlighter-rouge">XML</code> 解析过程中的错误。</li><li><code class="language-plaintext highlighter-rouge">getXMLReader()</code>：获取与此 <code class="language-plaintext highlighter-rouge">SAXParser</code> 关联的 <code class="language-plaintext highlighter-rouge">XMLReader</code> 对象，用于解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档。</li><li><code class="language-plaintext highlighter-rouge">getSchema()</code>：获取当前为 <code class="language-plaintext highlighter-rouge">SAXParser</code> 设置的 <code class="language-plaintext highlighter-rouge">XML Schema</code>。</li><li><code class="language-plaintext highlighter-rouge">isNamespaceAware()</code>：返回解析器是否为命名空间感知的布尔值。</li><li><code class="language-plaintext highlighter-rouge">isValidating()</code>：返回解析器是否验证 <code class="language-plaintext highlighter-rouge">XML</code> 内容的布尔值。</li></ul><p>这些方法用于配置和操作 <code class="language-plaintext highlighter-rouge">SAXParser</code> 实例，以便解析 <code class="language-plaintext highlighter-rouge">XML</code> 文档并处理其内容。</p><p><code class="language-plaintext highlighter-rouge">DefaultHandler</code> 是 <code class="language-plaintext highlighter-rouge">SAX</code> 解析器的默认处理程序，它实现了 <code class="language-plaintext highlighter-rouge">ContentHandler</code>、<code class="language-plaintext highlighter-rouge">DTDHandler</code>、<code class="language-plaintext highlighter-rouge">EntityResolver</code> 和 <code class="language-plaintext highlighter-rouge">ErrorHandler</code> 接口。这些接口定义了处理 <code class="language-plaintext highlighter-rouge">XML</code> 内容和解析过程中可能出现的各种情况的方法。以下是 <code class="language-plaintext highlighter-rouge">DefaultHandler</code> 中一些重要的方法和作用：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">startDocument()</code>：在解析文档开始时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">endDocument()</code>：在解析文档结束时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">startElement(String uri, String localName, String qName, Attributes attributes)</code>：在解析元素开始时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">endElement(String uri, String localName, String qName)</code>：在解析元素结束时调用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">characters(char[] ch, int start, int length)</code>：在解析字符数据时调用。</strong></li><li><code class="language-plaintext highlighter-rouge">startPrefixMapping(String prefix, String uri)</code>：在解析命名空间前缀映射时调用。</li><li><code class="language-plaintext highlighter-rouge">endPrefixMapping(String prefix)</code>：在解析命名空间前缀映射结束时调用。</li><li><code class="language-plaintext highlighter-rouge">processingInstruction(String target, String data)</code>：在解析处理指令时调用。</li><li><code class="language-plaintext highlighter-rouge">skippedEntity(String name)</code>：在解析实体时调用。</li><li><code class="language-plaintext highlighter-rouge">warning(SAXParseException e)</code>：在解析过程中遇到警告时调用。</li><li><strong><code class="language-plaintext highlighter-rouge">error(SAXParseException e)</code>：在解析过程中遇到可恢复错误时调用。</strong></li><li><code class="language-plaintext highlighter-rouge">fatalError(SAXParseException e)</code>：在解析过程中遇到致命错误时调用。</li></ul><p><code class="language-plaintext highlighter-rouge">DefaultHandler</code> 的作用是提供这些方法的默认实现，可以根据需要覆盖这些方法来处理 <code class="language-plaintext highlighter-rouge">XML</code> 解析过程中的事件。通常，可以创建一个继承自 <code class="language-plaintext highlighter-rouge">DefaultHandler</code> 的类，并重写其中的方法来实现自定义的 <code class="language-plaintext highlighter-rouge">XML</code> 处理逻辑。</p><p><code class="language-plaintext highlighter-rouge">SAXParser</code> 本身并不能直接修改 <code class="language-plaintext highlighter-rouge">XML</code>，因为 <code class="language-plaintext highlighter-rouge">SAXParser</code> 是一种流式解析器，它按顺序读取 <code class="language-plaintext highlighter-rouge">XML</code> 文件并触发相应的事件，而不会将整个 <code class="language-plaintext highlighter-rouge">XML</code> 文档加载到内存中。因此，如果需要修改 <code class="language-plaintext highlighter-rouge">XML</code>，通常需要借助其他 <code class="language-plaintext highlighter-rouge">API</code> 或方法来实现。</p><h2 id="使用stax解析">使用StAX解析</h2><p>StAX（Streaming API for XML）是用于处理 XML 的一种流式处理 API。与传统的 DOM（Document Object Model）和 SAX（Simple API for XML）相比，StAX 提供了一种更灵活的方式来读取和写入 XML 数据。</p><p>使用 StAX，可以逐个事件地处理 XML 文档，而不需要将整个文档加载到内存中（像 DOM 那样），也不需要像 SAX 那样完全依赖事件回调模型。相反，StAX 允许以迭代器的方式逐个读取或写入 XML 元素，使得处理 XML 数据变得更加简单和高效。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">XMLInputFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">XMLInputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">XMLStreamReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">createXMLStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>

<span class="k">while</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">START_ELEMENT</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"元素： "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">());</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  Attribute: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">CHARACTERS</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">reader</span><span class="o">.</span><span class="na">isWhiteSpace</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"文本: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">END_ELEMENT</span><span class="o">:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"元素结束: "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">());</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>要使用 StAX 修改 XML，需要创建一个 <code class="language-plaintext highlighter-rouge">XMLInputFactory</code> 来读取 XML 文件，并创建一个 <code class="language-plaintext highlighter-rouge">XMLOutputFactory</code> 来写入修改后的 XML。示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 创建输入和输出的 XML 工厂</span>
<span class="nc">XMLInputFactory</span> <span class="n">inputFactory</span> <span class="o">=</span> <span class="nc">XMLInputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">XMLOutputFactory</span> <span class="n">outputFactory</span> <span class="o">=</span> <span class="nc">XMLOutputFactory</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>

<span class="c1">// 创建 XML 输入和输出流</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
<span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"book2.xml"</span><span class="o">);</span>
<span class="nc">XMLStreamReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">inputFactory</span><span class="o">.</span><span class="na">createXMLStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">XMLStreamWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">outputFactory</span><span class="o">.</span><span class="na">createXMLStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
<span class="n">writer</span><span class="o">.</span><span class="na">writeStartDocument</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">,</span> <span class="s">"1.0"</span><span class="o">);</span> <span class="c1">// 写入XML声明</span>
<span class="c1">// 处理元素</span>
<span class="k">while</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">event</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">START_ELEMENT</span><span class="o">:</span>
            <span class="c1">// 处理开始元素</span>
            <span class="nc">String</span> <span class="n">elementName</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">getLocalName</span><span class="o">();</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">elementName</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"book"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">elementName</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 修改元素内容</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeStartElement</span><span class="o">(</span><span class="s">"book2"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// 复制其他元素</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeStartElement</span><span class="o">(</span><span class="n">elementName</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">reader</span><span class="o">.</span><span class="na">getAttributeCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">writeAttribute</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">getAttributeLocalName</span><span class="o">(</span><span class="n">i</span><span class="o">),</span><span class="n">reader</span><span class="o">.</span><span class="na">getAttributeValue</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>

        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">CHARACTERS</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">reader</span><span class="o">.</span><span class="na">isWhiteSpace</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="s">"isbn"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">())){</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">writeCharacters</span><span class="o">(</span><span class="s">"666888"</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">writeCharacters</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="nc">XMLStreamConstants</span><span class="o">.</span><span class="na">END_ELEMENT</span><span class="o">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">writeEndElement</span><span class="o">();</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 关闭流</span>
<span class="n">reader</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">writer</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">input</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>这段代码的目标是读取一个 XML 文件并将其内容修改后写入另一个 XML 文件。在处理元素内容时，如果当前元素是 <code class="language-plaintext highlighter-rouge">isbn</code>，则将其内容修改为 “666888”，如果当前元素是<code class="language-plaintext highlighter-rouge">book</code>则修改为<code class="language-plaintext highlighter-rouge">book2</code>。</p><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 是用于读取 XML 数据的接口，它允许逐个事件地读取 XML 文档的内容，并提供了一种低级别的、基于流的方式来解析 XML。通过 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code>，可以逐步遍历 XML 文档的元素、属性、文本内容等，并根据需要对文档进行处理，如提取数据、修改内容等操作。这种基于流的解析方式相比于基于文档对象模型（DOM）的解析方式，更加高效，尤其适用于处理大型 XML 文件。</p><p><code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 提供了许多方法来读取 XML 文档的不同部分，以下是一些常用的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">boolean hasNext()</code>：检查是否还有更多的事件要处理。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int next()</code>：移动到下一个 XML 事件，并返回事件的类型。</strong></li><li><code class="language-plaintext highlighter-rouge">int getEventType()</code>：返回当前事件的类型。</li><li><code class="language-plaintext highlighter-rouge">boolean isStartElement()</code>：检查当前事件是否是开始元素。</li><li><code class="language-plaintext highlighter-rouge">boolean isCharacters()</code>：检查当前事件是否是字符数据。</li><li><code class="language-plaintext highlighter-rouge">boolean isEndElement()</code>：检查当前事件是否是结束元素。</li><li><code class="language-plaintext highlighter-rouge">String getLocalName()</code>：返回当前元素的本地名称。</li><li><strong><code class="language-plaintext highlighter-rouge">int getAttributeCount()</code>：返回当前元素的属性数。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getAttributeLocalName(int index)</code>：返回指定索引处属性的本地名称。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getAttributeValue(int index)</code>：返回指定索引处属性的值。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">String getText()</code>：返回当前元素的文本内容。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">boolean isWhiteSpace()</code>：检查当前解析器位置是否位于空白字符上。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void close()</code>：关闭 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code>。</strong></li></ul><p>这些方法可以在处理 XML 文档时导航并提取所需的信息。</p><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 是用于写入 XML 数据的接口，它允许逐个事件地生成 XML 文档的内容，并提供了一种低级别的、基于流的方式来生成 XML。通过 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code>，可以逐步构建 XML 文档的元素、属性、文本内容等，并生成符合 XML 规范的 XML 数据。这种基于流的生成方式相比于基于文档对象模型（DOM）的生成方式，更加高效，尤其适用于生成大型 XML 文件。</p><p>常用的 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 方法包括：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">writeStartDocument(String version, String encoding)</code>：写入 XML 声明。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeStartElement(String localName)</code>：写入开始元素。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeAttribute(String localName, String value)</code>：写入元素属性。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeCharacters(String text)</code>：写入文本内容。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">writeEndElement()</code>：写入结束元素。</strong></li><li><code class="language-plaintext highlighter-rouge">writeEndDocument()</code>：写入 XML 结束标记。</li><li><code class="language-plaintext highlighter-rouge">flush()</code>：刷新缓冲区，确保所有数据都被写入底层流。</li><li><strong><code class="language-plaintext highlighter-rouge">close()</code>：关闭 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code>。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">XMLStreamConstants</code> 是一个接口，定义了一组整数常量，用于表示 XML 解析器生成的各种事件类型。这些常量用于与 <code class="language-plaintext highlighter-rouge">XMLStreamReader</code> 和 <code class="language-plaintext highlighter-rouge">XMLStreamWriter</code> 一起使用，以便在处理 XML 文档时识别不同类型的事件。通过这些常量，可以方便地检查当前事件的类型，并根据需要执行相应的操作。</p><p><code class="language-plaintext highlighter-rouge">XMLStreamConstants</code> 提供了以下常量：</p><ul><li><code class="language-plaintext highlighter-rouge">START_ELEMENT</code>：表示开始元素事件。</li><li><code class="language-plaintext highlighter-rouge">END_ELEMENT</code>：表示结束元素事件。</li><li><code class="language-plaintext highlighter-rouge">CHARACTERS</code>：表示字符数据事件。</li><li><code class="language-plaintext highlighter-rouge">ATTRIBUTE</code>：表示属性事件。</li><li><code class="language-plaintext highlighter-rouge">NAMESPACE</code>：表示命名空间事件。</li><li><code class="language-plaintext highlighter-rouge">START_DOCUMENT</code>：表示开始文档事件。</li><li><code class="language-plaintext highlighter-rouge">END_DOCUMENT</code>：表示结束文档事件。</li><li><code class="language-plaintext highlighter-rouge">PROCESSING_INSTRUCTION</code>：表示处理指令事件。</li><li><code class="language-plaintext highlighter-rouge">COMMENT</code>：表示注释事件。</li><li><code class="language-plaintext highlighter-rouge">DTD</code>：表示 DTD 事件。</li><li><code class="language-plaintext highlighter-rouge">ENTITY_REFERENCE</code>：表示实体引用事件。</li><li><code class="language-plaintext highlighter-rouge">CDATA</code>：表示 CDATA 事件。</li><li><code class="language-plaintext highlighter-rouge">SPACE</code>：表示空格事件。</li></ul><h2 id="使用jackson">使用Jackson</h2><p>XML文档的结构：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span>
<span class="nt">&lt;book</span> <span class="na">id=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;name&gt;</span>Java核心技术<span class="nt">&lt;/name&gt;</span>
    <span class="nt">&lt;author&gt;</span>Cay S. Horstmann<span class="nt">&lt;/author&gt;</span>
    <span class="nt">&lt;isbn</span> <span class="na">lang=</span><span class="s">"CN"</span><span class="nt">&gt;</span>1234567<span class="nt">&lt;/isbn&gt;</span>
    <span class="nt">&lt;tags&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Java<span class="nt">&lt;/tag&gt;</span>
        <span class="nt">&lt;tag&gt;</span>Network<span class="nt">&lt;/tag&gt;</span>
    <span class="nt">&lt;/tags&gt;</span>
    <span class="nt">&lt;pubDate/&gt;</span>
<span class="nt">&lt;/book&gt;</span>
</code></pre></div></div><p>完全可以对应到一个定义好的JavaBean中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>Jackson第三方库可以轻松做到XML到JavaBean的转换。要使用Jackson，先添加一个Maven的依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后，定义好JavaBean，就可以用下面几行代码解析：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/book.xml"</span><span class="o">);</span>
<span class="nc">JacksonXmlModule</span> <span class="n">module</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JacksonXmlModule</span><span class="o">();</span>
<span class="nc">XmlMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlMapper</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
<span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">author</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">tags</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">pubDate</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">XmlMapper</code>可以用<code class="language-plaintext highlighter-rouge">readValue(InputStream, Class)</code>直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1
Java核心技术
Cay S. Horstmann
1234567
[Java, Network]
null
</code></pre></div></div><p>如果要解析的数据格式不是<code class="language-plaintext highlighter-rouge">Jackson</code>内置的标准格式，那么需要编写一点额外的扩展来告诉<code class="language-plaintext highlighter-rouge">Jackson</code>如何自定义解析，可以参考<a href="https://github.com/FasterXML/jackson">Jackson</a>的<a href="https://github.com/FasterXML/jackson-annotations">官方文档</a>。读取属性：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.databind.MapperFeature</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.JacksonXmlModule</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.XmlMapper</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.xml"</span><span class="o">);</span>
        <span class="nc">JacksonXmlModule</span> <span class="n">module</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JacksonXmlModule</span><span class="o">();</span>
        <span class="c1">// 默认使用“未包装”列表:</span>
        <span class="c1">//module.setDefaultUseWrapper(false);</span>
        <span class="nc">XmlMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlMapper</span><span class="o">(</span><span class="n">module</span><span class="o">);</span>
        <span class="c1">//自动忽略无法对应pojo的字段</span>
        <span class="c1">//mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</span>
        <span class="c1">//字段为null，自动忽略，不再序列化</span>
        <span class="c1">//mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);</span>
        <span class="c1">//XML标签名:使用骆驼命名的属性名，</span>
        <span class="c1">//mapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE);</span>
        <span class="c1">//设置转换模式</span>
        <span class="n">mapper</span><span class="o">.</span><span class="na">enable</span><span class="o">(</span><span class="nc">MapperFeature</span><span class="o">.</span><span class="na">USE_STD_BEAN_NAMING</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">author</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的属性lang的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">lang</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"节点isbn的属性aa的值为:"</span> <span class="o">+</span> <span class="n">book</span><span class="o">.</span><span class="na">isbn</span><span class="o">.</span><span class="na">aa</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">tags</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">.</span><span class="na">pubDate</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">localName</span> <span class="o">=</span> <span class="s">"isbn"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BookAttr</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">BookAttr</span> <span class="o">{</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">isAttribute</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">localName</span> <span class="o">=</span> <span class="s">"lang"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">lang</span><span class="o">;</span>
    <span class="nd">@JacksonXmlProperty</span><span class="o">(</span><span class="n">isAttribute</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">localName</span> <span class="o">=</span> <span class="s">"aa"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">aa</span><span class="o">;</span>
    <span class="c1">//测试一下</span>
    <span class="nd">@JacksonXmlText</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="json">JSON</h1><p>XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。</p><p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">id</span><span class="dl">"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Java核心技术</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">author</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span>
        <span class="dl">"</span><span class="s2">firstName</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Abc</span><span class="dl">"</span><span class="p">,</span>
        <span class="dl">"</span><span class="s2">lastName</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Xyz</span><span class="dl">"</span>
    <span class="p">},</span>
    <span class="dl">"</span><span class="s2">isbn</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1234567</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">tags</span><span class="dl">"</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Java</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Network</span><span class="dl">"</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div></div><p>JSON作为数据传输的格式，有几个显著的优点：</p><ul><li>JSON只允许使用UTF-8编码，不存在编码问题；</li><li>JSON只允许使用双引号作为key，特殊字符用<code class="language-plaintext highlighter-rouge">\</code>转义，格式简单；</li><li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li></ul><p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p><ul><li>键值对：<code class="language-plaintext highlighter-rouge">{"key": value}</code></li><li>数组：<code class="language-plaintext highlighter-rouge">[1, 2, 3]</code></li><li>字符串：<code class="language-plaintext highlighter-rouge">"abc"</code></li><li>数值（整数和浮点数）：<code class="language-plaintext highlighter-rouge">12.34</code></li><li>布尔值：<code class="language-plaintext highlighter-rouge">true</code>或<code class="language-plaintext highlighter-rouge">false</code></li><li>空值：<code class="language-plaintext highlighter-rouge">null</code></li></ul><p>浏览器直接支持使用JavaScript对JSON进行读写：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JSON string to JavaScript object:</span>
<span class="nx">jsObj</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">jsonStr</span><span class="p">);</span>

<span class="c1">// JavaScript object to JSON string:</span>
<span class="nx">jsonStr</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">jsObj</span><span class="p">);</span>
</code></pre></div></div><p>开发Web应用的时候，使用JSON作为数据传输，在浏览器端非常方便。因为JSON天生适合JavaScript处理，绝大多数REST API都选择JSON作为数据传输格式。</p><p>在Java中，针对JSON也有标准的JSR 353 API。常用的用于解析JSON的第三方库有：<code class="language-plaintext highlighter-rouge">Jackson</code>、<code class="language-plaintext highlighter-rouge">Gson</code>、<code class="language-plaintext highlighter-rouge">Fastjson</code>。</p><p>使用<code class="language-plaintext highlighter-rouge">Jackson</code>：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.dataformat<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-dataformat-xml<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>就可以使用下面的代码解析一个JSON文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.json"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
        <span class="c1">// 反序列化时忽略不存在的JavaBean属性:</span>
        <span class="n">mapper</span><span class="o">.</span><span class="na">configure</span><span class="o">(</span><span class="nc">DeserializationFeature</span><span class="o">.</span><span class="na">FAIL_ON_UNKNOWN_PROPERTIES</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
        <span class="nc">Book</span> <span class="n">book</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tags</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"Book{id="</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", author="</span> <span class="o">+</span> <span class="n">author</span> <span class="o">+</span> <span class="s">", isbn='"</span> <span class="o">+</span> <span class="n">isbn</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", tags="</span> <span class="o">+</span> <span class="n">tags</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>核心代码是创建一个<code class="language-plaintext highlighter-rouge">ObjectMapper</code>对象。关闭<code class="language-plaintext highlighter-rouge">DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>功能使得解析时如果JavaBean不存在该属性时解析不会报错。</p><p>还可以直接用Map接收：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">DemoTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"book.json"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">readValue</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div><hr /><p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">book</span><span class="o">);</span>
</code></pre></div></div><p>还可以生成带缩进和换行的JSON：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">json</span><span class="o">=</span><span class="n">mapper</span><span class="o">.</span><span class="na">writerWithDefaultPrettyPrinter</span><span class="o">().</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div><hr /><p>要把JSON的某些值解析为特定的Java对象，例如<code class="language-plaintext highlighter-rouge">LocalDate</code>，也是完全可以的。例如：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Java核心技术</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">pubDate</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2016-09-01</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div><p>要解析为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">LocalDate</span> <span class="n">pubDate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>只需要引入标准的JSR 310关于<code class="language-plaintext highlighter-rouge">JavaTime</code>的数据格式定义至Maven：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-jsr310 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.datatype<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jackson-datatype-jsr310<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.17.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后，在创建<code class="language-plaintext highlighter-rouge">ObjectMapper</code>时，注册一个新的<code class="language-plaintext highlighter-rouge">JavaTimeModule</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectMapper</span><span class="o">().</span><span class="na">registerModule</span><span class="o">(</span><span class="k">new</span> <span class="nc">JavaTimeModule</span><span class="o">());</span>
</code></pre></div></div><p>还可以自定义解析，假设<code class="language-plaintext highlighter-rouge">Book</code>类的<code class="language-plaintext highlighter-rouge">isbn</code>是一个<code class="language-plaintext highlighter-rouge">BigInteger</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nc">BigInteger</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>但JSON数据并不是标准的整形格式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
    <span class="s">"name"</span><span class="o">:</span> <span class="s">"Java核心技术"</span><span class="o">,</span>
    <span class="s">"isbn"</span><span class="o">:</span> <span class="s">"978-7-111-54742-6"</span>
<span class="o">}</span>
</code></pre></div></div><p>直接解析，肯定报错。这时，需要自定义一个<code class="language-plaintext highlighter-rouge">IsbnDeserializer</code>，用于解析含有非数字的字符串：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IsbnDeserializer</span> <span class="kd">extends</span> <span class="nc">JsonDeserializer</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="nf">deserialize</span><span class="o">(</span><span class="nc">JsonParser</span> <span class="n">p</span><span class="o">,</span> <span class="nc">DeserializationContext</span> <span class="n">ctxt</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">JsonProcessingException</span> <span class="o">{</span>
        <span class="c1">// 读取原始的JSON字符串内容:</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getValueAsString</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">BigInteger</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">JsonParseException</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后，在<code class="language-plaintext highlighter-rouge">Book</code>类中使用注解标注：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 表示反序列化isbn时使用自定义的IsbnDeserializer:</span>
    <span class="nd">@JsonDeserialize</span><span class="o">(</span><span class="n">using</span> <span class="o">=</span> <span class="nc">IsbnDeserializer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>类似的，自定义序列化时我们需要自定义一个<code class="language-plaintext highlighter-rouge">IsbnSerializer</code>，然后在<code class="language-plaintext highlighter-rouge">Book</code>类中标注<code class="language-plaintext highlighter-rouge">@JsonSerialize(using = ...)</code>即可。</p><p>在反序列化时，<code class="language-plaintext highlighter-rouge">Jackson</code>要求Java类<strong>需要一个默认的无参数构造方法</strong>，否则，无法直接实例化此类。存在带参数构造方法的类，如果要反序列化，注意再提供一个无参数构造方法。</p><p>对于<code class="language-plaintext highlighter-rouge">enum</code>字段，Jackson按String类型处理，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Book</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">DayOfWeek</span> <span class="n">start</span> <span class="o">=</span> <span class="no">MONDAY</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>序列化为：</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">start</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">MONDAY</span><span class="dl">"</span>
<span class="p">}</span>
</code></pre></div></div><p>对于<code class="language-plaintext highlighter-rouge">record</code>类型（<strong>Java 14</strong> ），Jackson会自动找出它的带参数构造方法，并根据JSON的key进行匹配，可直接反序列化。对<code class="language-plaintext highlighter-rouge">record</code>类型的支持需要版本<code class="language-plaintext highlighter-rouge">2.12.0</code>以上。</p><h1 id="gui">GUI</h1><p><code class="language-plaintext highlighter-rouge">JFrame</code> <strong>构造方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">JFrame()</code></td><td>构造一个初始时不可见的新窗体。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(GraphicsConfiguration gc)</code></td><td>以屏幕设备的指定 <code class="language-plaintext highlighter-rouge">GraphicsConfiguration</code> 和空白标题创建一个 <code class="language-plaintext highlighter-rouge">Frame</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(String title)</code></td><td>创建一个新的、初始不可见的、具有指定标题的 <code class="language-plaintext highlighter-rouge">Frame</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">JFrame(String title, GraphicsConfiguration gc)</code></td><td>创建一个具有指定标题和指定屏幕设备的 <code class="language-plaintext highlighter-rouge">GraphicsConfiguration</code> 的 <code class="language-plaintext highlighter-rouge">JFrame</code>。</td></tr></tbody></table><p><strong>常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">add()</code></td><td>将组件添加到窗口</td></tr><tr><td><code class="language-plaintext highlighter-rouge">is/setVisible()</code></td><td>获取/设置窗体的可视状态。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setTitle()</code></td><td>获取/设置窗体的标题。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setState()</code></td><td>获取/设置窗体的的最小化,最大化等状态。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setLocation()</code></td><td>获取/设置窗体在屏幕上应当出现的位置。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">get/setSize()</code></td><td>获取/设置窗体的大小。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">setDefaultCloseOperation(int operation)</code></td><td>设置单击窗体上的关闭按钮时的默认操作。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">getContentPane()</code></td><td>获取窗体的内容面板</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">setDefaultCloseOperation</code></p><p><code class="language-plaintext highlighter-rouge">public void setDefaultCloseOperation(int operation)</code><br /> 设置用户在此窗体上发起”<code class="language-plaintext highlighter-rouge">close</code>“时默认执行的操作。必须指定以下选项之一：</p><p>值依次为<code class="language-plaintext highlighter-rouge">0-3</code></p><p><code class="language-plaintext highlighter-rouge">DO_NOTHING_ON_CLOSE</code>(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 <code class="language-plaintext highlighter-rouge">WindowListener</code> 对象的 <code class="language-plaintext highlighter-rouge">windowClosing</code> 方法中处理该操作。</p><p><code class="language-plaintext highlighter-rouge">HIDE_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">WindowConstants</code> 中定义)：调用任意已注册的 <code class="language-plaintext highlighter-rouge">WindowListener</code> 对象后自动隐藏该窗体。</p><p><code class="language-plaintext highlighter-rouge">DISPOSE_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">WindowConstants</code> 中定义)：调用任意已注册 <code class="language-plaintext highlighter-rouge">WindowListener</code> 的对象后自动隐藏并释放该窗体。</p><p><code class="language-plaintext highlighter-rouge">EXIT_ON_CLOSE</code>(在 <code class="language-plaintext highlighter-rouge">JFrame</code> 中定义)：使用 <code class="language-plaintext highlighter-rouge">System exit</code> 方法退出应用程序。仅在应用程序中使用。</p><p>默认情况下,该值被设置为 <code class="language-plaintext highlighter-rouge">HIDE_ON_CLOSE</code>。更改此属性的值将导致激发属性更改事件,其属性名称为 “<code class="language-plaintext highlighter-rouge">defaultCloseOperation</code>“。</p><p>注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机<strong>可能</strong>会终止。<br /> <code class="language-plaintext highlighter-rouge">frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</code></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/09/03/Java-%E5%85%B6%E4%BB%96/" target="_blank">https://acteds.github.io/2021/09/03/Java-%E5%85%B6%E4%BB%96/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1714032804', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
