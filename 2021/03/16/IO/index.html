<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>I/O &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/03/16/IO/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="I/O"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言java的I/O笔记，常见的字节流和字符流，以及Filter模式、序列化、读取chasspath资源、读取zip、读取jar、重定向标准输入输出、机器无关的输入输出流、随意读写的输入输出流、缓存流、工具类。"><meta name="og:description" content="引言java的I/O笔记，常见的字节流和字符流，以及Filter模式、序列化、读取chasspath资源、读取zip、读取jar、重定向标准输入输出、机器无关的输入输出流、随意读写的输入输出流、缓存流、工具类。"><meta property="og:url" content="/2021/03/16/IO/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-03-16"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="I/O"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">I/O</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/03/16 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 44445 字，约 127 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>java的I/O笔记，常见的字节流和字符流，以及Filter模式、序列化、读取chasspath资源、读取zip、读取jar、重定向标准输入输出、机器无关的输入输出流、随意读写的输入输出流、缓存流、工具类。</p><h1 id="io">I/O</h1><p><strong>文件</strong>是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。</p><p><code class="language-plaintext highlighter-rouge">java.io</code>包中最重要的就是五个类和一个接口：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">File</code>类</strong>：用于表示文件和目录的路径名抽象表示形式。它提供了创建、删除、重命名等操作文件和目录的方法，以及获取文件属性的方法。</li><li><strong><code class="language-plaintext highlighter-rouge">OutputStream</code>类</strong>：所有输出流的基类，用于向输出目标写入字节流。它是一个抽象类，定义了写入字节流的基本方法，如<code class="language-plaintext highlighter-rouge">write(int b)</code>、<code class="language-plaintext highlighter-rouge">flush()</code>和<code class="language-plaintext highlighter-rouge">close()</code>。</li><li><strong><code class="language-plaintext highlighter-rouge">InputStream</code>类</strong>：所有输入流的基类，用于从输入源读取字节流。它也是一个抽象类，定义了读取字节流的基本方法，如<code class="language-plaintext highlighter-rouge">read()</code>、<code class="language-plaintext highlighter-rouge">available()</code>和<code class="language-plaintext highlighter-rouge">close()</code>。</li><li><strong><code class="language-plaintext highlighter-rouge">Reader</code>类</strong>：所有字符输入流的基类，用于从输入源读取字符流。它也是一个抽象类，定义了读取字符流的基本方法，如<code class="language-plaintext highlighter-rouge">read(char[] cbuf, int off, int len)</code>、<code class="language-plaintext highlighter-rouge">skip(long n)</code>和<code class="language-plaintext highlighter-rouge">close()</code>。</li><li><strong><code class="language-plaintext highlighter-rouge">Writer</code>类</strong>：所有字符输出流的基类，用于向输出目标写入字符流。它也是一个抽象类，定义了写入字符流的基本方法，如<code class="language-plaintext highlighter-rouge">write(String str, int off, int len)</code>、<code class="language-plaintext highlighter-rouge">flush()</code>和<code class="language-plaintext highlighter-rouge">close()</code>。</li><li><strong><code class="language-plaintext highlighter-rouge">Serializable</code>接口</strong>：用于标记类的对象可以被序列化。实现<code class="language-plaintext highlighter-rouge">Serializable</code>接口的类可以将其对象转换为字节序列，以便存储或传输。序列化后的对象可以在需要时进行反序列化，恢复成原始对象。</li></ol><p><strong>按照不同的方式,将流分为不同的类型按数据流动方向</strong>：</p><ul><li>输入流：只能从中读取字节数据,而不能向其写出数据，通过抽象类<code class="language-plaintext highlighter-rouge">InputStream</code> 实现。</li><li>输出流：只能向其写入字节数据,而不能从中读取数据 ，通过抽象类 <code class="language-plaintext highlighter-rouge">OutputStream</code>实现。</li></ul><p><strong>按照流所处理的数据类型</strong>：</p><ul><li>字节流：用于处理<strong>字节</strong>数据</li><li>字符流：用于处理 Unicode<strong>字符</strong>数据</li></ul><p><strong>按照流所处理的源</strong>：</p><ul><li>节点流(低级流)：向一个特定的IO设备读/写数据的流。</li><li>处理流(高级流)：对已存在的流进行连接和封装的流。处理流是“处理流的流”,它用来处理其他的流。</li></ul><p>所有从 <code class="language-plaintext highlighter-rouge">InputStream</code>或 <code class="language-plaintext highlighter-rouge">Reader</code>派生的类<strong>都有</strong>一个基本的<code class="language-plaintext highlighter-rouge">read()</code>方法,用读取的字节或者读取字节数组;</p><p>所有从 <code class="language-plaintext highlighter-rouge">OutputStream</code>或 <code class="language-plaintext highlighter-rouge">Writer</code>派生的类<strong>都有</strong>一个基本的 <code class="language-plaintext highlighter-rouge">write()</code>方法,用于写入单一的字节或者整个字节数组。</p><p><strong>一般很少使用单一的流类来产生输入输出流</strong>,而是使用这两个方法绐其他的流类提供数锯,也就是说,通过<strong>多个</strong>流对象的连接和封装使用实际的流。</p><hr /><p>如果我们需要读写的是字符，并且字符<strong>不全是</strong>单字节表示的ASCII字符，那么，按照<code class="language-plaintext highlighter-rouge">char</code>来读写显然更方便，这种流称为<strong>字符流</strong>。</p><p>Java提供了<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>表示<strong>字符流</strong>，<strong>字符流</strong>传输的<strong>最小数据单位</strong>是<code class="language-plaintext highlighter-rouge">char</code>。</p><p>例如，我们把<code class="language-plaintext highlighter-rouge">char[]</code>数组<code class="language-plaintext highlighter-rouge">Hi你好</code>这4个字符用<code class="language-plaintext highlighter-rouge">Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符<code class="language-plaintext highlighter-rouge">H</code>和<code class="language-plaintext highlighter-rouge">i</code>各占一个字节，中文字符<code class="language-plaintext highlighter-rouge">你好</code>各占3个字节：</p><pre><code class="language-txt">0x48
0x69
0xe4bda0
0xe5a5bd
</code></pre><p>反过来，我们用<code class="language-plaintext highlighter-rouge">Reader</code>读取以UTF-8编码的这8个字节，会从<code class="language-plaintext highlighter-rouge">Reader</code>中得到<code class="language-plaintext highlighter-rouge">Hi你好</code>这4个字符。</p><p><code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code><strong>本质上</strong>是一个能自动编解码的<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>。</p><p>使用<code class="language-plaintext highlighter-rouge">Reader</code>，数据源虽然是<strong>字节</strong>，但我们读入的数据都是<code class="language-plaintext highlighter-rouge">char</code>类型的字符，原因是<code class="language-plaintext highlighter-rouge">Reader</code>内部把读入的<code class="language-plaintext highlighter-rouge">byte</code>做了编码，转换成了<code class="language-plaintext highlighter-rouge">char</code>。使用<code class="language-plaintext highlighter-rouge">InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code class="language-plaintext highlighter-rouge">byte[]</code>数组，但是我们可以自己把二进制<code class="language-plaintext highlighter-rouge">byte[]</code>数组按照某种编码转换为字符串。究竟使用<code class="language-plaintext highlighter-rouge">Reader</code>还是<code class="language-plaintext highlighter-rouge">InputStream</code>，要取决于具体的使用场景。</p><p>如果数据源不是文本，就<strong>只能</strong>使用<code class="language-plaintext highlighter-rouge">InputStream</code>，如果数据源是文本，使用<code class="language-plaintext highlighter-rouge">Reader</code>更方便一些。<code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>是类似的。</p><hr /><h2 id="file">File</h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>File(File parent, String child)</td><td>根据 <code class="language-plaintext highlighter-rouge">parent</code> 抽象路径名和 <code class="language-plaintext highlighter-rouge">child</code> 路径名字符串创建一个新 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr><tr><td>File(String pathname)</td><td>通过将给定路径名字符串转换为抽象路径名来创建一个新 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr><tr><td>File(String parent, String child)</td><td>根据 <code class="language-plaintext highlighter-rouge">parent</code> 路径名字符串和 <code class="language-plaintext highlighter-rouge">child</code> 路径名字符串创建一个新 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr><tr><td>File(URI uri)</td><td>通过将给定的 <code class="language-plaintext highlighter-rouge">file: URI</code> 转换为一个抽象路径名来创建一个新的 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">File</code>对象可以用绝对路径或相对路径来构造。在Windows中，路径分隔符是<code class="language-plaintext highlighter-rouge">\</code>，在Java中需要用<code class="language-plaintext highlighter-rouge">\\</code>表示；而在Linux中，路径分隔符是<code class="language-plaintext highlighter-rouge">/</code>。为了方便跨平台使用，Java提供了<code class="language-plaintext highlighter-rouge">File.separator</code>来表示当前系统的路径分隔符。</p><p><strong>绝对路径：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">file1</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">file</span><span class="o">,</span><span class="s">"a.txt"</span><span class="o">);</span>
<span class="nc">File</span> <span class="n">file2</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:"</span><span class="o">,</span><span class="s">"a.txt"</span><span class="o">);</span>  
<span class="nc">File</span> <span class="n">file3</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:"</span><span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span><span class="o">+</span><span class="s">"a.txt"</span><span class="o">);</span>  
<span class="nc">File</span> <span class="n">file4</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:\\a.txt"</span><span class="o">);</span>  
<span class="no">URI</span> <span class="n">uri</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"file:///path/to/file.txt"</span><span class="o">);</span>
<span class="nc">File</span> <span class="n">file5</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">uri</span><span class="o">);</span>
</code></pre></div></div><p><strong>相对路径：</strong></p><p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设当前目录是C:\Docs</span>
<span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"sub\\javac"</span><span class="o">);</span> <span class="c1">// 绝对路径是C:\Docs\sub\javac</span>
<span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">".\\sub\\javac"</span><span class="o">);</span> <span class="c1">// 绝对路径是C:\Docs\sub\javac</span>
<span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"..\\sub\\javac"</span><span class="o">);</span> <span class="c1">// 绝对路径是C:\sub\javac</span>
</code></pre></div></div><p>可以用<code class="language-plaintext highlighter-rouge">.</code>表示当前目录，<code class="language-plaintext highlighter-rouge">..</code>表示上级目录。</p><p>关于<code class="language-plaintext highlighter-rouge">getPath()</code>、<code class="language-plaintext highlighter-rouge">getAbsolutePath()</code>和<code class="language-plaintext highlighter-rouge">getCanonicalPath()</code>方法：</p><ul><li><code class="language-plaintext highlighter-rouge">getPath()</code>：返回构造方法传入的路径。如果路径是相对路径，则返回的是相对于当前工作目录的路径；如果路径是绝对路径，则返回的是完整的路径。</li><li><code class="language-plaintext highlighter-rouge">getAbsolutePath()</code>：返回绝对路径。无论构造方法传入的是相对路径还是绝对路径，都返回绝对路径。</li><li><code class="language-plaintext highlighter-rouge">getCanonicalPath()</code>：返回规范路径。规范路径是绝对路径的一种表示形式，它会解析所有的符号链接、相对路径等，使得最终的路径没有多余的部分。</li></ul><p>在实际应用中，通常使用<code class="language-plaintext highlighter-rouge">getCanonicalPath()</code>获取文件的规范路径，以确保路径的唯一性和规范性。</p><hr /><h3 id="文件和目录">文件和目录</h3><p><code class="language-plaintext highlighter-rouge">File</code>对象可以<strong>表示文件也可以表示目录</strong>，即使传入的文件或目录不存在也不会出错。只有在调用<code class="language-plaintext highlighter-rouge">File</code>对象的方法时才会进行磁盘操作。例如，可以使用<code class="language-plaintext highlighter-rouge">isFile()</code>和<code class="language-plaintext highlighter-rouge">isDirectory()</code>方法来判断<code class="language-plaintext highlighter-rouge">File</code>对象是否表示文件或目录。对于文件，还可以使用<code class="language-plaintext highlighter-rouge">canRead()</code>、<code class="language-plaintext highlighter-rouge">canWrite()</code>、<code class="language-plaintext highlighter-rouge">canExecute()</code>和<code class="language-plaintext highlighter-rouge">length()</code>等方法来检查文件的权限和大小。对于目录，<code class="language-plaintext highlighter-rouge">canExecute()</code>表示是否可以列出其包含的文件和子目录。</p><p>当File对象表示一个文件时：</p><ul><li><code class="language-plaintext highlighter-rouge">createNewFile()</code>方法用于创建一个新文件，如果文件已存在则返回 false。</li><li><code class="language-plaintext highlighter-rouge">delete()</code>方法用于删除文件或者空目录，如果删除成功则返回 true。</li></ul><p>File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li><code class="language-plaintext highlighter-rouge">boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code class="language-plaintext highlighter-rouge">boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code class="language-plaintext highlighter-rouge">boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><p><strong>临时文件</strong></p><p>有些时候，程序需要读写一些临时文件，File对象提供了<code class="language-plaintext highlighter-rouge">createTempFile()</code>来创建一个临时文件，以及<code class="language-plaintext highlighter-rouge">deleteOnExit()</code>在JVM退出时自动删除该文件。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="nc">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="s">"tmp-"</span><span class="o">,</span> <span class="s">".txt"</span><span class="o">);</span> <span class="c1">// 提供临时文件的前缀和后缀</span>
<span class="n">f</span><span class="o">.</span><span class="na">deleteOnExit</span><span class="o">();</span> <span class="c1">// JVM退出时自动删除</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span><span class="c1">//true</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span><span class="c1">//C:\Users\*\AppData\Local\Temp\tmp-13660335841682657349.txt</span>
</code></pre></div></div><p><strong>遍历文件和目录</strong></p><p>当File对象表示一个目录时，可以使用<code class="language-plaintext highlighter-rouge">list()</code>和<code class="language-plaintext highlighter-rouge">listFiles()</code>列出目录下的文件和子目录名。还<code class="language-plaintext highlighter-rouge">listFiles()</code>提供了一系列重载方法，可以<strong>过滤</strong>不想要的文件和目录：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Windows"</span><span class="o">);</span>
<span class="nc">File</span><span class="o">[]</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">listFiles</span><span class="o">(</span><span class="k">new</span> <span class="nc">FilenameFilter</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 仅列出.exe文件</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".exe"</span><span class="o">);</span> <span class="c1">// 返回true表示接受该文件</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="k">if</span> <span class="o">(</span><span class="n">fs2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">temp</span> <span class="o">:</span> <span class="n">fs2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因为接口只有一个方法，因此匿名类可以写为lambda形式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span><span class="o">[]</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">listFiles</span><span class="o">((</span><span class="n">dir</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".exe"</span><span class="o">));</span>
</code></pre></div></div><h3 id="详细方法">详细方法</h3><table><thead><tr><th>返回类型</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean</td><td>canExecute()</td><td>测试应用程序是否可以执行此抽象路径名表示的文件。</td></tr><tr><td>boolean</td><td>canRead()</td><td>测试应用程序是否可以读取此抽象路径名表示的文件。</td></tr><tr><td>boolean</td><td>canWrite()</td><td>测试应用程序是否可以修改此抽象路径名表示的文件。</td></tr><tr><td>int</td><td>compareTo(File pathname)</td><td>按字母顺序比较两个抽象路径名。</td></tr><tr><td>boolean</td><td>createNewFile()</td><td>当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</td></tr><tr><td>static File</td><td>createTempFile(String prefix, String suffix)</td><td>在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。</td></tr><tr><td>static File</td><td>createTempFile(String prefix, String suffix, File directory)</td><td>在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</td></tr><tr><td>boolean</td><td>delete()</td><td>删除此抽象路径名表示的文件或目录。</td></tr><tr><td>void</td><td>deleteOnExit()</td><td>在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。</td></tr><tr><td>boolean</td><td>equals(Object obj)</td><td>测试此抽象路径名与给定对象是否相等。</td></tr><tr><td>boolean</td><td><strong>exists()</strong></td><td>测试此抽象路径名表示的文件或目录是否存在。</td></tr><tr><td>File</td><td>getAbsoluteFile()</td><td>返回此抽象路径名的绝对路径名形式。</td></tr><tr><td>String</td><td><strong>getAbsolutePath()</strong></td><td>返回此抽象路径名的绝对路径名字符串。</td></tr><tr><td>File</td><td>getCanonicalFile()</td><td>返回此抽象路径名的规范形式。</td></tr><tr><td>String</td><td><strong>getCanonicalPath()</strong></td><td>返回此抽象路径名的规范路径名字符串。</td></tr><tr><td>long</td><td>getFreeSpace()</td><td>返回此抽象路径名指定的分区中未分配的字节数。</td></tr><tr><td>String</td><td><strong>getName()</strong></td><td>返回由此抽象路径名表示的文件或目录的名称。</td></tr><tr><td>String</td><td><strong>getParent()</strong></td><td>返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。</td></tr><tr><td>File</td><td>getParentFile()</td><td>返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。</td></tr><tr><td>String</td><td><strong>getPath()</strong></td><td>将此抽象路径名转换为一个路径名字符串，返回构造方法传入的路径。</td></tr><tr><td>long</td><td>getTotalSpace()</td><td>返回此抽象路径名指定的分区大小。</td></tr><tr><td>long</td><td>getUsableSpace()</td><td>返回此抽象路径名指定的分区上可用于此虚拟机的字节数。</td></tr><tr><td>int</td><td>hashCode()</td><td>计算此抽象路径名的哈希码。</td></tr><tr><td>boolean</td><td>isAbsolute()</td><td>测试此抽象路径名是否为绝对路径名。</td></tr><tr><td>boolean</td><td><strong>isDirectory()</strong></td><td>测试此抽象路径名表示的文件是否是一个目录。</td></tr><tr><td>boolean</td><td><strong>isFile()</strong></td><td>测试此抽象路径名表示的文件是否是一个标准文件。</td></tr><tr><td>boolean</td><td>isHidden()</td><td>测试此抽象路径名指定的文件是否是一个隐藏文件。</td></tr><tr><td>long</td><td>lastModified()</td><td>返回此抽象路径名表示的文件最后一次被修改的时间。</td></tr><tr><td>long</td><td><strong>length()</strong></td><td>返回由此抽象路径名表示的文件的长度。</td></tr><tr><td>String[]</td><td>list()</td><td>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</td></tr><tr><td>String[]</td><td>list(FilenameFilter filter)</td><td>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</td></tr><tr><td>File[]</td><td>listFiles()</td><td>返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</td></tr><tr><td>File[]</td><td>listFiles(FileFilter filter)</td><td>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</td></tr><tr><td>File[]</td><td>listFiles(FilenameFilter filter)</td><td>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</td></tr><tr><td>static File[]</td><td>listRoots()</td><td>列出可用的文件系统根。</td></tr><tr><td>boolean</td><td><strong>mkdir()</strong></td><td>创建此抽象路径名指定的目录。</td></tr><tr><td>boolean</td><td><strong>mkdirs()</strong></td><td>创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。</td></tr><tr><td>boolean</td><td><strong>renameTo(File dest)</strong></td><td>重新命名此抽象路径名表示的文件。</td></tr><tr><td>boolean</td><td>setExecutable(boolean executable)</td><td>设置此抽象路径名所有者执行权限的一个便捷方法。</td></tr><tr><td>boolean</td><td>setExecutable(boolean executable, boolean ownerOnly)</td><td>设置此抽象路径名的所有者或所有用户的执行权限。</td></tr><tr><td>boolean</td><td>setLastModified(long time)</td><td>设置此抽象路径名指定的文件或目录的最后一次修改时间。</td></tr><tr><td>boolean</td><td>setReadable(boolean readable)</td><td>设置此抽象路径名所有者读权限的一个便捷方法。</td></tr><tr><td>boolean</td><td>setReadable(boolean readable, boolean ownerOnly)</td><td>设置此抽象路径名的所有者或所有用户的读权限。</td></tr><tr><td>boolean</td><td>setReadOnly()</td><td>标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。</td></tr><tr><td>boolean</td><td>setWritable(boolean writable)</td><td>设置此抽象路径名所有者写权限的一个便捷方法。</td></tr><tr><td>boolean</td><td>setWritable(boolean writable, boolean ownerOnly)</td><td>设置此抽象路径名的所有者或所有用户的写权限。</td></tr><tr><td>String</td><td>toString()</td><td>返回此抽象路径名的路径名字符串。</td></tr><tr><td>URI</td><td>toURI()</td><td>构造一个表示此抽象路径名的 file: URI。</td></tr><tr><td>URL</td><td>toURL()</td><td><strong>已过时。</strong> <em>此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。</em></td></tr></tbody></table><h2 id="字节流">字节流</h2><p>字节流是按字节读/写二进制数据字节流有两个基本的类：<code class="language-plaintext highlighter-rouge">InputStream</code>类<code class="language-plaintext highlighter-rouge">OutputStream</code>类</p><p><code class="language-plaintext highlighter-rouge">InputStream</code>类用于处理<strong>字节输入流</strong>,<code class="language-plaintext highlighter-rouge">OutputStream</code>类用于处理<strong>字节输出流</strong>。它们都是<strong>抽象类</strong>,本身<strong>不能直接用来创建对象</strong>。所有字节处理流都由<code class="language-plaintext highlighter-rouge">InputStream</code>/<code class="language-plaintext highlighter-rouge">OutputStream</code>派生而来</p><h3 id="inputstream">InputStream</h3><p><strong>InputStream常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>int read()</strong></td><td>读取一个字节，并返回字节表示的<code class="language-plaintext highlighter-rouge">int</code>值（0~255），如果已读到末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>表示不能继续读取了。</td></tr><tr><td><strong>int read(byte[] buffer)</strong></td><td>将数据读入一个字节数组,同时返回读取的字节数，若没有更多数据了则返回<code class="language-plaintext highlighter-rouge">-1</code>。</td></tr><tr><td><strong>int read(byte[] buffer,int offset,int length)</strong></td><td>将数据读入一个字节数组,放到<strong>数组</strong>的<code class="language-plaintext highlighter-rouge">offset</code>指定的位置开始,并用<code class="language-plaintext highlighter-rouge">length</code>来指定读取的最大字节数，若没有更多数据了则返回<code class="language-plaintext highlighter-rouge">-1</code>。</td></tr><tr><td>void close()</td><td>关闭流。</td></tr><tr><td>int available()</td><td>返回可以从中读取的字节数。</td></tr><tr><td>long skip(long n)</td><td>在输入流中跳过n个字节,将实际跳过的字节数返回。</td></tr><tr><td>boolean markSupported()</td><td>判断流是否支持标记功能。</td></tr><tr><td>void mark(int readlimit)</td><td>在支持标记的输入流的当前位置设置一个标记。</td></tr><tr><td>void reset()</td><td>返回到流的上一个标记。注意必须流支持标记功能。</td></tr></tbody></table><p><strong>InputStream相关类</strong></p><p><strong>低级 <code class="language-plaintext highlighter-rouge">InputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">InputStream</code>：抽象类，所有输入流的基类。</li><li><code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>：从字节数组读取数据的输入流。</li><li><code class="language-plaintext highlighter-rouge">PipedInputStream</code>：与<code class="language-plaintext highlighter-rouge">PipedOutputStream</code>配合使用，用于线程间通信。</li><li><code class="language-plaintext highlighter-rouge">FileInputStream</code>：从文件中读取数据的输入流。</li></ul><p><strong>高级 <code class="language-plaintext highlighter-rouge">InputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">DataInputStream</code>：允许应用程序以适当方式从底层输入流中读取基本 Java 数据类型。</li><li><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>：带有缓冲区的输入流，提高了从文件读取数据的性能。</li></ul><h4 id="fileinputstream">FileInputStream</h4><p><code class="language-plaintext highlighter-rouge">FileInputStream</code>是<code class="language-plaintext highlighter-rouge">InputStream</code>的一个子类。顾名思义，<code class="language-plaintext highlighter-rouge">FileInputStream</code>就是从文件流中读取数据。</p><p>一个一个读：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">);</span><span class="c1">// 读取文件</span>
<span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
<span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p><strong>缓冲</strong></p><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code class="language-plaintext highlighter-rouge">InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code class="language-plaintext highlighter-rouge">int read(byte[] b)</code>：读取若干字节并填充到<code class="language-plaintext highlighter-rouge">byte[]</code>数组，返回读取的字节数</li><li><code class="language-plaintext highlighter-rouge">int read(byte[] b, int off, int len)</code>：指定<code class="language-plaintext highlighter-rouge">byte[]</code>数组的偏移量和最大填充数</li></ul><p>利用上述方法一次读取多个字节时，需要先定义一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组作为缓冲区，<code class="language-plaintext highlighter-rouge">read()</code>方法会尽可能多地读取字节到缓冲区， 但<strong>不会超过</strong>缓冲区的大小。<code class="language-plaintext highlighter-rouge">read()</code>方法的返回实际读取了多少个字节。如果返回<code class="language-plaintext highlighter-rouge">-1</code>，表示没有更多的数据了。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">);</span><span class="c1">// 读取文件</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
<span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span><span class="c1">// 显示</span>
<span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p><p><code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>都是通过<code class="language-plaintext highlighter-rouge">close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p><p>还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成<code class="language-plaintext highlighter-rouge">IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理<code class="language-plaintext highlighter-rouge">IOException</code>。</p><p>因此，需要用<code class="language-plaintext highlighter-rouge">try ... finally</code>来保证<code class="language-plaintext highlighter-rouge">InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">);</span><span class="c1">// 读取文件</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span><span class="c1">// 显示</span>
  
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有文件"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fis</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>用<code class="language-plaintext highlighter-rouge">try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用<strong>Java 7</strong>引入的新的<code class="language-plaintext highlighter-rouge">try(resource)</code>的语法，只需要编写<code class="language-plaintext highlighter-rouge">try</code>语句，让编译器自动为我们关闭资源。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 读取文件</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span><span class="c1">// 显示</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有文件"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>实际上，编译器并不会特别地为<code class="language-plaintext highlighter-rouge">InputStream</code>加上自动关闭。编译器只看<code class="language-plaintext highlighter-rouge">try(resource = ...)</code>中的对象是否实现了<code class="language-plaintext highlighter-rouge">java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code class="language-plaintext highlighter-rouge">finally</code>语句并调用<code class="language-plaintext highlighter-rouge">close()</code>方法。<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>都实现了这个接口，因此，都可以用在<code class="language-plaintext highlighter-rouge">try(resource)</code>中。</p><p>在调用<code class="language-plaintext highlighter-rouge">InputStream</code>的<code class="language-plaintext highlighter-rouge">read()</code>方法读取数据时，我们说<code class="language-plaintext highlighter-rouge">read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">();</span> <span class="c1">// 必须等待read()方法返回才能执行下一行代码</span>
<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
</code></pre></div></div><p>执行到第二行代码时，必须等<code class="language-plaintext highlighter-rouge">read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code class="language-plaintext highlighter-rouge">read()</code>方法调用到底要花费多长时间。</p><h4 id="bytearrayinputstream">ByteArrayInputStream</h4><p><code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>可以在内存中<strong>模拟</strong>一个<code class="language-plaintext highlighter-rouge">InputStream</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">={</span><span class="mi">65</span><span class="o">,</span><span class="mi">66</span><span class="o">,</span><span class="mi">67</span><span class="o">,</span><span class="mi">68</span><span class="o">};</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">data</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>实际上是把一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组在内存中变成一个<code class="language-plaintext highlighter-rouge">InputStream</code>，虽然实际应用不多，但<strong>测试</strong>的时候，可以用它来构造一个<code class="language-plaintext highlighter-rouge">InputStream</code>。</p><h3 id="outputstream">OutputStream</h3><p><strong>OutputStream常用方法</strong></p><p>Writer常用方法(写入方法)</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>void write(int b)</strong></td><td>将参数<code class="language-plaintext highlighter-rouge">b</code>的低8位组成字节写入到流中。</td></tr><tr><td><strong>void write(byte[] buffer)</strong></td><td>将字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中的字节写入到流中。</td></tr><tr><td><strong>void write(byte[] buffer,int offset, int length)</strong></td><td>将字节数组<code class="language-plaintext highlighter-rouge">buffer</code>中从<code class="language-plaintext highlighter-rouge">offset</code>开始的<code class="language-plaintext highlighter-rouge">length</code>字节写入到流中。</td></tr><tr><td>void close()</td><td>关闭流</td></tr><tr><td>void flush()</td><td>刷空输岀流,并输岀所有被缓存的字节。</td></tr></tbody></table><p><strong>OutputStream相关类</strong></p><p><strong>低级 <code class="language-plaintext highlighter-rouge">OutputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">OutputStream</code>：抽象类，所有输出流的基类。</li><li><code class="language-plaintext highlighter-rouge">FileOutputStream</code>：向文件写入数据的输出流。</li><li><code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>：将数据写入字节数组的输出流。</li><li><code class="language-plaintext highlighter-rouge">PipedOutputStream</code>：与<code class="language-plaintext highlighter-rouge">PipedInputStream</code>配合使用，用于线程间通信。</li></ul><p><strong>高级 <code class="language-plaintext highlighter-rouge">OutputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">DataOutputStream</code>：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。</li><li><code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>：带有缓冲区的输出流，提高了写入文件的性能。</li></ul><p><strong>其他常见 <code class="language-plaintext highlighter-rouge">OutputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>：将对象写入流中的输出流。</li><li><code class="language-plaintext highlighter-rouge">FilterOutputStream</code>：添加功能的抽象输出流。</li><li><code class="language-plaintext highlighter-rouge">PrintStream</code>：用于写入各种数据值表示形式的输出流。</li></ul><p><code class="language-plaintext highlighter-rouge">void write(int b)</code>会写入一个字节到输出流。要注意的是，虽然传入的是<code class="language-plaintext highlighter-rouge">int</code>参数，但只会写入一个字节，即只写入<code class="language-plaintext highlighter-rouge">int</code>最低8位表示字节的部分（相当于<code class="language-plaintext highlighter-rouge">b &amp; 0xff</code>）。</p><p><code class="language-plaintext highlighter-rouge">OutputStream</code>也提供了<code class="language-plaintext highlighter-rouge">close()</code>方法关闭输出流，以便释放系统资源。<code class="language-plaintext highlighter-rouge">OutputStream</code>还提供了一个<code class="language-plaintext highlighter-rouge">flush()</code>方法，它的目的是将缓冲区的内容<strong>真正</strong>输出到目的地。</p><p>为什么要有<code class="language-plaintext highlighter-rouge">flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，<strong>操作系统</strong>并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组），等到缓冲区写满了，再<strong>一次性写入</strong>文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code class="language-plaintext highlighter-rouge">OutputStream</code>有个<code class="language-plaintext highlighter-rouge">flush()</code>方法，能<strong>强制</strong>把缓冲区内容输出。</p><p>通常情况下，我们<strong>不需要调用</strong>这个<code class="language-plaintext highlighter-rouge">flush()</code>方法，因为缓冲区写满了<code class="language-plaintext highlighter-rouge">OutputStream</code>会自动调用它，并且，在调用<code class="language-plaintext highlighter-rouge">close()</code>方法关闭<code class="language-plaintext highlighter-rouge">OutputStream</code>之前，也会自动调用<code class="language-plaintext highlighter-rouge">flush()</code>方法。</p><p>但是，在某些情况下，我们必须手动调用<code class="language-plaintext highlighter-rouge">flush()</code>方法。举个栗子：</p><p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code class="language-plaintext highlighter-rouge">OutputStream</code>的<code class="language-plaintext highlighter-rouge">write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息。</p><p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p><p>解决办法就是每输入一句话后，立刻调用<code class="language-plaintext highlighter-rouge">flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p><p>实际上，<code class="language-plaintext highlighter-rouge">InputStream</code>也有缓冲区。例如，从<code class="language-plaintext highlighter-rouge">FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code class="language-plaintext highlighter-rouge">int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code class="language-plaintext highlighter-rouge">read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h4 id="fileoutputstream">FileOutputStream</h4><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"out/readme.txt"</span><span class="o">);</span>
<span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">72</span><span class="o">);</span> <span class="c1">// H</span>
<span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span> <span class="c1">// Hello</span>
<span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>和<code class="language-plaintext highlighter-rouge">InputStream</code>一样，<code class="language-plaintext highlighter-rouge">OutputStream</code>的<code class="language-plaintext highlighter-rouge">write()</code>方法也是阻塞的。</p><h4 id="bytearrayoutputstream">ByteArrayOutputStream</h4><p><code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>可以在内存中模拟一个<code class="language-plaintext highlighter-rouge">OutputStream</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">ByteArrayOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello "</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>实际上是把一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组在内存中变成一个<code class="language-plaintext highlighter-rouge">OutputStream</code>，虽然实际应用不多，但<strong>测试</strong>的时候，可以用它来构造一个<code class="language-plaintext highlighter-rouge">OutputStream</code>。</p><h4 id="printstream">PrintStream</h4><p><code class="language-plaintext highlighter-rouge">PrintStream</code>是一种<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>，它在<code class="language-plaintext highlighter-rouge">OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p><ul><li>写入<code class="language-plaintext highlighter-rouge">int</code>：<code class="language-plaintext highlighter-rouge">print(int)</code></li><li>写入<code class="language-plaintext highlighter-rouge">boolean</code>：<code class="language-plaintext highlighter-rouge">print(boolean)</code></li><li>写入<code class="language-plaintext highlighter-rouge">String</code>：<code class="language-plaintext highlighter-rouge">print(String)</code></li><li>写入<code class="language-plaintext highlighter-rouge">Object</code>：<code class="language-plaintext highlighter-rouge">print(Object)</code>，实际上相当于<code class="language-plaintext highlighter-rouge">print(object.toString())</code></li><li>…</li></ul><p>以及对应的一组<code class="language-plaintext highlighter-rouge">println()</code>方法，它会自动加上换行符。</p><p>我们经常使用的<code class="language-plaintext highlighter-rouge">System.out.println()</code>实际上就是使用<code class="language-plaintext highlighter-rouge">PrintStream</code>打印各种数据。其中，<code class="language-plaintext highlighter-rouge">System.out</code>是系统默认提供的<code class="language-plaintext highlighter-rouge">PrintStream</code>，表示标准输出，而<code class="language-plaintext highlighter-rouge">System.err</code>是系统默认提供的标准错误输出：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span> <span class="c1">// 输出12345</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">());</span> <span class="c1">// 输出类似java.lang.Object@3c7a835a</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span> <span class="c1">// 输出Hello并换行</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">PrintStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>相比，除了添加了一组<code class="language-plaintext highlighter-rouge">print()</code>/<code class="language-plaintext highlighter-rouge">println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出<code class="language-plaintext highlighter-rouge">IOException</code>，这样我们在编写代码的时候，就不必捕获<code class="language-plaintext highlighter-rouge">IOException</code>。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">PrintStream</span> <span class="n">out</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"file1.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span><span class="c1">//建立一个文件输出流,true追加</span>
    <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span><span class="c1">//建立一个PrintStream对象,它将作为标准输出流</span>
    <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是一个测试串FileOutputStream"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">out</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fos</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>修改简化后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//建立一个文件输出流,true追加,建立一个PrintStream对象,它将作为标准输出流</span>
<span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"file1.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="nc">PrintStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是一个测试串FileOutputStream"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>同时操作多个<code class="language-plaintext highlighter-rouge">AutoCloseable</code>资源时，还可以在<code class="language-plaintext highlighter-rouge">try(resource) { ... }</code>语句中可以同时写出多个资源，<strong>用<code class="language-plaintext highlighter-rouge">;</code>隔开</strong>。例如，同时读写两个文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 读取input.txt，写入output.txt:</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">);</span>
     <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"output.txt"</span><span class="o">)){</span>
    <span class="n">input</span><span class="o">.</span><span class="na">transferTo</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">transferTo</code>方法是<code class="language-plaintext highlighter-rouge">InputStream</code>的一个扩展方法，用于将输入流的数据直接传输到指定的输出流中，从而避免了显式的循环读取和写入操作。在这个例子中，<code class="language-plaintext highlighter-rouge">transferTo</code>方法将<code class="language-plaintext highlighter-rouge">input.txt</code>文件的内容直接传输到<code class="language-plaintext highlighter-rouge">output.txt</code>文件中，效率比逐字节或逐块地读取和写入要高。这种方式可以提高文件传输的效率，特别是当处理大文件时。</p><h2 id="字符流">字符流</h2><p>字待流有两个基本类：<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code></p><p>1,<code class="language-plaintext highlighter-rouge">Reader</code>/<code class="language-plaintext highlighter-rouge">Writer</code>处理的是<strong>字符类型</strong>的数据。它处理流的方式是以<strong>字符</strong>为单位进行的。</p><p>2,<code class="language-plaintext highlighter-rouge">Reader</code>/<code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>/<code class="language-plaintext highlighter-rouge">OutputStream</code>一样,也分为<strong>节点流</strong>(低级流)和<strong>处理流</strong>(高级流)。</p><p><code class="language-plaintext highlighter-rouge">Reader</code>类是所有输入字符流的父类,<code class="language-plaintext highlighter-rouge">Writer</code>类是所有输出字符流的父类。设计<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>继承层次结构主要是为了国际化。而旧的I/O流继承层次结构仅支持8位字节流,并且<strong>不能很好的处理</strong>16位的Unicode字符。由于Unicode用于字符国际化,所以添加字符流的继承层次结构就是在所有的I/O操作中都支持Unicode。</p><p><code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">Reader</code>类都是抽象类,不能建立它们的对象,所以只能通过它们子类对象对文件进行操作。</p><h3 id="reader">Reader</h3><p><code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>的区别如下：</p><table><thead><tr><th style="text-align: left">InputStream</th><th style="text-align: left">Reader</th></tr></thead><tbody><tr><td style="text-align: left"><strong>字节</strong>流，以<code class="language-plaintext highlighter-rouge">byte</code>为单位</td><td style="text-align: left"><strong>字符</strong>流，以<code class="language-plaintext highlighter-rouge">char</code>为单位</td></tr><tr><td style="text-align: left">读取<strong>字节</strong>（-1，0~255）：<code class="language-plaintext highlighter-rouge">int read()</code></td><td style="text-align: left">读取<strong>字符</strong>（-1，0~65535）：<code class="language-plaintext highlighter-rouge">int read()</code></td></tr><tr><td style="text-align: left">读到<strong>字节数组</strong>：<code class="language-plaintext highlighter-rouge">int read(byte[] b)</code></td><td style="text-align: left">读到<strong>字符数组</strong>：<code class="language-plaintext highlighter-rouge">int read(char[] c)</code></td></tr></tbody></table><p><strong>Reader常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>int read()</strong></td><td>读取一个字符,并将它返回，如果已读到末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>。</td></tr><tr><td><strong>int read(char[] buffer)</strong></td><td>将从流中读取的字符放到字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中,返回读出的字符数，如果已读到末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>。</td></tr><tr><td><strong>int read(char[] buffer,int offset,int length)</strong></td><td>将读取的字符存入字符数组 <code class="language-plaintext highlighter-rouge">buffer</code> 中的指定位置，从 <code class="language-plaintext highlighter-rouge">offset</code> 开始，最多读取 <code class="language-plaintext highlighter-rouge">length</code> 个字符。</td></tr><tr><td>void mark(int n)</td><td>标记流中的当前位置，后续调用 <code class="language-plaintext highlighter-rouge">reset()</code> 方法可以回到该位置。</td></tr><tr><td>boolean MarkSupported()</td><td>判断流是否支持标记操作。</td></tr><tr><td>boolean ready()</td><td>判断流是否已经准备好进行读取操作。</td></tr></tbody></table><p><strong>Reader相关类</strong></p><p><strong>低级 <code class="language-plaintext highlighter-rouge">Reader</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">CharArrayReader</code>：从字符数组读取数据的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">PipedReader</code>：与<code class="language-plaintext highlighter-rouge">PipedWriter</code>配合使用，用于线程间通信的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">StringReader</code>：从字符串读取数据的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">FileReader</code>：从文件读取数据的<code class="language-plaintext highlighter-rouge">Reader</code>。</li></ul><p><strong>高级 <code class="language-plaintext highlighter-rouge">Reader</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">BufferedReader</code>：带有缓冲区的<code class="language-plaintext highlighter-rouge">Reader</code>，提高了从输入流读取数据的性能。</li><li><code class="language-plaintext highlighter-rouge">InputStreamReader</code>：将字节流转换为字符流的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">LineNumberReader</code>：继承自<code class="language-plaintext highlighter-rouge">BufferedReader</code>，可以记录行号的<code class="language-plaintext highlighter-rouge">Reader</code>。</li></ul><h4 id="filereader">FileReader</h4><p><code class="language-plaintext highlighter-rouge">FileReader</code>是<code class="language-plaintext highlighter-rouge">Reader</code>的一个子类，它可以打开文件并获取<code class="language-plaintext highlighter-rouge">Reader</code>。</p><p>下面的代码演示了如何完整地读取一个<code class="language-plaintext highlighter-rouge">FileReader</code>的所有字符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个FileReader对象,字符编码是???</span>
<span class="k">try</span><span class="o">(</span><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"src/readme.txt"</span><span class="o">))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="c1">// 反复调用read()方法，直到返回-1</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span> <span class="c1">// 打印char</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为<code class="language-plaintext highlighter-rouge">FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是<code class="language-plaintext highlighter-rouge">GBK</code>，打开一个<code class="language-plaintext highlighter-rouge">UTF-8</code>编码的文本文件就会出现乱码。</p><p>要避免乱码问题，我们需要在创建<code class="language-plaintext highlighter-rouge">FileReader</code>时指定编码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"src/readme.txt"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
</code></pre></div></div><p>带 Charset 参数的<code class="language-plaintext highlighter-rouge">FileReader</code>的构造方法在 <strong>Java 11</strong> 中加入。<strong>Java 8</strong> 中可以使用 <code class="language-plaintext highlighter-rouge">InputStreamReader</code> 包装 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 自行构建。</p><h4 id="chararrayreader">CharArrayReader</h4><p><code class="language-plaintext highlighter-rouge">CharArrayReader</code>可以在内存中模拟一个<code class="language-plaintext highlighter-rouge">Reader</code>，它的作用实际上是把一个<strong><code class="language-plaintext highlighter-rouge">char[]</code>数组</strong>变成一个<code class="language-plaintext highlighter-rouge">Reader</code>，这和<code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>非常类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CharArrayReader</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()))</span> <span class="o">{}</span>
</code></pre></div></div><h4 id="stringreader">StringReader</h4><p><code class="language-plaintext highlighter-rouge">StringReader</code>可以<strong>直接把<code class="language-plaintext highlighter-rouge">String</code>作为数据源</strong>，它和<code class="language-plaintext highlighter-rouge">CharArrayReader</code>几乎一样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringReader</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><h4 id="inputstreamreader">InputStreamReader</h4><p><code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>有什么关系？</p><p>除了特殊的<code class="language-plaintext highlighter-rouge">CharArrayReader</code>和<code class="language-plaintext highlighter-rouge">StringReader</code>，普通的<code class="language-plaintext highlighter-rouge">Reader</code>实际上是<strong>基于<code class="language-plaintext highlighter-rouge">InputStream</code>构造</strong>的，<code class="language-plaintext highlighter-rouge">Reader</code>从<code class="language-plaintext highlighter-rouge">InputStream</code>中读入字节流（<code class="language-plaintext highlighter-rouge">byte</code>），然后，根据编码设置，再转换为<code class="language-plaintext highlighter-rouge">char</code>就可以实现字符流。如果我们查看<code class="language-plaintext highlighter-rouge">FileReader</code>的源码，它在内部实际上持有一个<code class="language-plaintext highlighter-rouge">FileInputStream</code>。</p><p>既然<code class="language-plaintext highlighter-rouge">Reader</code>本质上是一个基于<code class="language-plaintext highlighter-rouge">InputStream</code>的<code class="language-plaintext highlighter-rouge">byte</code>到<code class="language-plaintext highlighter-rouge">char</code>的转换器，那么，如果我们已经有一个<code class="language-plaintext highlighter-rouge">InputStream</code>，想把它转换为<code class="language-plaintext highlighter-rouge">Reader</code>，是完全可行的。<code class="language-plaintext highlighter-rouge">InputStreamReader</code>就是这样一个转换器，它可以把<strong>任何</strong><code class="language-plaintext highlighter-rouge">InputStream</code>转换为<code class="language-plaintext highlighter-rouge">Reader</code>。示例代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 持有InputStream:</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"src/readme.txt"</span><span class="o">);</span>
<span class="c1">// 变换为Reader:</span>
<span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><p>构造<code class="language-plaintext highlighter-rouge">InputStreamReader</code>时，我们需要传入<code class="language-plaintext highlighter-rouge">InputStream</code>，还需要指定编码，就可以得到一个<code class="language-plaintext highlighter-rouge">Reader</code>对象。上述代码实际上就是<code class="language-plaintext highlighter-rouge">FileReader</code>的一种实现方式。</p><h3 id="writer">Writer</h3><p><code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>的区别如下：</p><table><thead><tr><th style="text-align: left">OutputStream</th><th style="text-align: left">Writer</th></tr></thead><tbody><tr><td style="text-align: left"><strong>字节</strong>流，以<code class="language-plaintext highlighter-rouge">byte</code>为单位</td><td style="text-align: left"><strong>字符</strong>流，以<code class="language-plaintext highlighter-rouge">char</code>为单位</td></tr><tr><td style="text-align: left">写入<strong>字节</strong>（<strong>0~255</strong>）：<code class="language-plaintext highlighter-rouge">void write(int b)</code></td><td style="text-align: left">写入<strong>字符</strong>（<strong>0~65535</strong>）：<code class="language-plaintext highlighter-rouge">void write(int c)</code></td></tr><tr><td style="text-align: left">写入<strong>字节</strong>数组：<code class="language-plaintext highlighter-rouge">void write(byte[] b)</code></td><td style="text-align: left">写入<strong>字符</strong>数组：<code class="language-plaintext highlighter-rouge">void write(char[] c)</code></td></tr><tr><td style="text-align: left">无对应方法</td><td style="text-align: left">写入String：<code class="language-plaintext highlighter-rouge">void write(String s)</code></td></tr></tbody></table><p><strong>Writer常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>void write(int c)</strong></td><td>将参数<code class="language-plaintext highlighter-rouge">c</code>的低16位组成的字符写入到流中。这个方法通常用于写入单个字符的数据。</td></tr><tr><td><strong>void write(char[]buffer)</strong></td><td>将字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中的所有字符写入到流中。</td></tr><tr><td><strong>void write(char[]buffer,int offset,int length)</strong></td><td>将字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中从<code class="language-plaintext highlighter-rouge">offset</code>位置开始的<code class="language-plaintext highlighter-rouge">length</code>个字符写入到流中。</td></tr><tr><td>void write(String string)</td><td>将字符串<code class="language-plaintext highlighter-rouge">string</code>写入到流中。</td></tr><tr><td>void write(String string,int offset,int length)</td><td>将字符串<code class="language-plaintext highlighter-rouge">string</code>中从<code class="language-plaintext highlighter-rouge">offset</code>位置开始的<code class="language-plaintext highlighter-rouge">length</code>个字符写入到流中。</td></tr><tr><td>Writer append(char c)</td><td>将指定字符添加到此<code class="language-plaintext highlighter-rouge">writer</code></td></tr><tr><td>void close()</td><td>关闭流</td></tr><tr><td>void flush()</td><td>刷新输出流，并将缓冲区中的数据输出。</td></tr></tbody></table><p><strong>Writer相关类</strong></p><p><strong>低级 <code class="language-plaintext highlighter-rouge">Writer</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">FileWriter</code>：将字符写入到文件的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">CharArrayWriter</code>：将字符写入到字符数组的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">StringWriter</code>：将字符写入到字符串的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">PipedWriter</code>：与<code class="language-plaintext highlighter-rouge">PipedReader</code>配合使用，用于线程间通信的<code class="language-plaintext highlighter-rouge">Writer</code>。</li></ul><p><strong>高级 <code class="language-plaintext highlighter-rouge">Writer</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">BufferedWriter</code>：带有缓冲区的<code class="language-plaintext highlighter-rouge">Writer</code>，提高了向输出流写入数据的性能。</li><li><code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>：将字符流转换为字节流的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">PrintWriter</code>：带有打印功能的<code class="language-plaintext highlighter-rouge">Writer</code>，可以方便地向输出流写入各种数据类型的值。</li></ul><h4 id="filewriter">FileWriter</h4><p>使用<code class="language-plaintext highlighter-rouge">FileWriter</code>进行文件操作时,为了减少磁盘读写次数,<strong>常使用具有缓冲功能的<code class="language-plaintext highlighter-rouge">BufferedWriter</code>类。</strong></p><p><code class="language-plaintext highlighter-rouge">FileWriter</code>就是向文件中写入字符流的<code class="language-plaintext highlighter-rouge">Writer</code>。它的使用方法和<code class="language-plaintext highlighter-rouge">FileReader</code>类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Writer</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"readme.txt"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'H'</span><span class="o">);</span> <span class="c1">// 写入单个字符</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span> <span class="c1">// 写入char[]</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span> <span class="c1">// 写入String</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="chararraywriter">CharArrayWriter</h4><p><code class="language-plaintext highlighter-rouge">CharArrayWriter</code>可以在内存中创建一个<code class="language-plaintext highlighter-rouge">Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code class="language-plaintext highlighter-rouge">char</code>，最后得到写入的<code class="language-plaintext highlighter-rouge">char[]</code>数组，这和<code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>非常类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">CharArrayWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CharArrayWriter</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">65</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">66</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">67</span><span class="o">);</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> <span class="c1">// { 'A', 'B', 'C' }</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="stringwriter">StringWriter</h4><p><code class="language-plaintext highlighter-rouge">StringWriter</code>也是一个基于内存的<code class="language-plaintext highlighter-rouge">Writer</code>，它和<code class="language-plaintext highlighter-rouge">CharArrayWriter</code>类似。实际上，<code class="language-plaintext highlighter-rouge">StringWriter</code>在内部维护了一个<code class="language-plaintext highlighter-rouge">StringBuffer</code>，并对外提供了<code class="language-plaintext highlighter-rouge">Writer</code>接口。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">StringWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">65</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">66</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">67</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// ABC</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="outputstreamwriter">OutputStreamWriter</h4><p>除了<code class="language-plaintext highlighter-rouge">CharArrayWriter</code>和<code class="language-plaintext highlighter-rouge">StringWriter</code>外，普通的Writer实际上是<strong>基于<code class="language-plaintext highlighter-rouge">OutputStream</code>构造</strong>的，它接收<code class="language-plaintext highlighter-rouge">char</code>，然后在内部自动转换成一个或多个<code class="language-plaintext highlighter-rouge">byte</code>，并写入<code class="language-plaintext highlighter-rouge">OutputStream</code>。因此，<code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>就是一个将任意的<code class="language-plaintext highlighter-rouge">OutputStream</code>转换为<code class="language-plaintext highlighter-rouge">Writer</code>的转换器：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Writer</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"readme.txt"</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><p>上述代码实际上就是<code class="language-plaintext highlighter-rouge">FileWriter</code>的一种实现方式。这和上一节的<code class="language-plaintext highlighter-rouge">InputStreamReader</code>是一样的。</p><h4 id="printwriter">PrintWriter</h4><p><code class="language-plaintext highlighter-rouge">PrintStream</code>最终输出的总是<code class="language-plaintext highlighter-rouge">byte</code>数据，而<code class="language-plaintext highlighter-rouge">PrintWriter</code>则是<strong>扩展</strong>了<code class="language-plaintext highlighter-rouge">Writer</code>接口，它的<code class="language-plaintext highlighter-rouge">print()</code>/<code class="language-plaintext highlighter-rouge">println()</code>方法最终输出的是<code class="language-plaintext highlighter-rouge">char</code>数据。两者的使用方法几乎是一模一样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringWriter</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">();</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">PrintWriter</span> <span class="n">pw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">pw</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
    <span class="n">pw</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span>
    <span class="n">pw</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
</code></pre></div></div><h2 id="filter模式">Filter模式</h2><p>Java的IO标准库提供的<code class="language-plaintext highlighter-rouge">InputStream</code>根据来源可以包括：</p><ul><li><code class="language-plaintext highlighter-rouge">FileInputStream</code>：从文件读取数据，是最终数据源；</li><li><code class="language-plaintext highlighter-rouge">ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li><li><code class="language-plaintext highlighter-rouge">Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li><li>…</li></ul><p>如果我们要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加缓冲功能，则可以从<code class="language-plaintext highlighter-rouge">FileInputStream</code>派生一个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedFileInputStream</span> <span class="kd">extends</span> <span class="nc">FileInputStream</span>
</code></pre></div></div><p>如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加计算签名的功能，类似的，也可以从<code class="language-plaintext highlighter-rouge">FileInputStream</code>派生一个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DigestFileInputStream</span> <span class="kd">extends</span> <span class="nc">FileInputStream</span>
</code></pre></div></div><p>如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加加密/解密功能，还是可以从<code class="language-plaintext highlighter-rouge">FileInputStream</code>派生一个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CipherFileInputStream</span> <span class="kd">extends</span> <span class="nc">FileInputStream</span>
</code></pre></div></div><p>如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生<code class="language-plaintext highlighter-rouge">BufferedDigestFileInputStream</code>。如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加缓冲和加解密的功能，则需要派生<code class="language-plaintext highlighter-rouge">BufferedCipherFileInputStream</code>。</p><p>我们发现，给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：</p><pre><code class="language-ascii">                          ┌─────────────────┐
                          │ FileInputStream │
                          └─────────────────┘
                                   ▲
             ┌───────────┬─────────┼─────────┬───────────┐
             │           │         │         │           │
┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐
│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│
└───────────────────────┘│└─────────────────┘│└─────────────────────┘
                         │                   │
    ┌─────────────────────────────┐ ┌─────────────────────────────┐
    │BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│
    └─────────────────────────────┘ └─────────────────────────────┘
</code></pre><p>这还只是针对<code class="language-plaintext highlighter-rouge">FileInputStream</code>设计，如果针对另一种<code class="language-plaintext highlighter-rouge">InputStream</code>设计，很快会出现子类爆炸的情况。</p><p>因此，直接使用继承，为各种<code class="language-plaintext highlighter-rouge">InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p><p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code class="language-plaintext highlighter-rouge">InputStream</code>分为两大类：</p><p>一类是直接提供数据的基础<code class="language-plaintext highlighter-rouge">InputStream</code>，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>一类是提供额外附加功能的<code class="language-plaintext highlighter-rouge">InputStream</code>，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><p>当我们需要给一个“基础”<code class="language-plaintext highlighter-rouge">InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code class="language-plaintext highlighter-rouge">InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code class="language-plaintext highlighter-rouge">FileInputStream</code>，数据来源自文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">);</span>
</code></pre></div></div><p>紧接着，我们希望<code class="language-plaintext highlighter-rouge">FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>包装这个<code class="language-plaintext highlighter-rouge">InputStream</code>，得到的包装类型是<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>，但它仍然被视为一个<code class="language-plaintext highlighter-rouge">InputStream</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">buffered</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</code></pre></div></div><p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">gzip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span><span class="n">buffered</span><span class="o">);</span>
</code></pre></div></div><p>无论我们包装多少次，得到的对象始终是<code class="language-plaintext highlighter-rouge">InputStream</code>，我们直接用<code class="language-plaintext highlighter-rouge">InputStream</code>来引用它，就可以正常读取：</p><pre><code class="language-ascii">┌─────────────────────────┐
│GZIPInputStream          │
│┌───────────────────────┐│
││BufferedFileInputStream││
││┌─────────────────────┐││
│││   FileInputStream   │││
││└─────────────────────┘││
│└───────────────────────┘│
└─────────────────────────┘
</code></pre><p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator），Filter模式可以在运行期动态增加功能。它可以让我们通过少量的类来实现各种功能的组合：</p><pre><code class="language-ascii">                 ┌─────────────┐
                 │ InputStream │
                 └─────────────┘
                       ▲ ▲
┌────────────────────┐ │ │ ┌─────────────────┐
│  FileInputStream   │─┤ └─│FilterInputStream│
└────────────────────┘ │   └─────────────────┘
┌────────────────────┐ │     ▲ ┌───────────────────┐
│ByteArrayInputStream│─┤     ├─│BufferedInputStream│
└────────────────────┘ │     │ └───────────────────┘
┌────────────────────┐ │     │ ┌───────────────────┐
│ ServletInputStream │─┘     ├─│  DataInputStream  │
└────────────────────┘       │ └───────────────────┘
                             │ ┌───────────────────┐
                             └─│CheckedInputStream │
                               └───────────────────┘
</code></pre><p>类似的，<code class="language-plaintext highlighter-rouge">OutputStream</code>也是以这种模式来提供各种功能：</p><pre><code class="language-ascii">                  ┌─────────────┐
                  │OutputStream │
                  └─────────────┘
                        ▲ ▲
┌─────────────────────┐ │ │ ┌──────────────────┐
│  FileOutputStream   │─┤ └─│FilterOutputStream│
└─────────────────────┘ │   └──────────────────┘
┌─────────────────────┐ │     ▲ ┌────────────────────┐
│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│
└─────────────────────┘ │     │ └────────────────────┘
┌─────────────────────┐ │     │ ┌────────────────────┐
│ ServletOutputStream │─┘     ├─│  DataOutputStream  │
└─────────────────────┘       │ └────────────────────┘
                              │ ┌────────────────────┐
                              └─│CheckedOutputStream │
                                └────────────────────┘
</code></pre><p><strong>编写FilterInputStream</strong></p><p>也可以自己编写<code class="language-plaintext highlighter-rouge">FilterInputStream</code>，以便可以把自己的<code class="language-plaintext highlighter-rouge">FilterInputStream</code>“叠加”到任何一个<code class="language-plaintext highlighter-rouge">InputStream</code>中。</p><p>下面的例子演示了如何编写一个<code class="language-plaintext highlighter-rouge">CountInputStream</code>，它的作用是对输入的字节进行计数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">CountInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CountInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">data</span><span class="o">)))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTotal read "</span> <span class="o">+</span> <span class="n">input</span><span class="o">.</span><span class="na">getBytesRead</span><span class="o">()</span> <span class="o">+</span> <span class="s">" bytes"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CountInputStream</span> <span class="kd">extends</span> <span class="nc">FilterInputStream</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">CountInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBytesRead</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>注意到在叠加多个<code class="language-plaintext highlighter-rouge">FilterInputStream</code>，我们只需要持有最外层的<code class="language-plaintext highlighter-rouge">InputStream</code>，并且，当最外层的<code class="language-plaintext highlighter-rouge">InputStream</code>关闭时（在<code class="language-plaintext highlighter-rouge">try(resource)</code>块的结束处自动关闭），内层的<code class="language-plaintext highlighter-rouge">InputStream</code>的<code class="language-plaintext highlighter-rouge">close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code class="language-plaintext highlighter-rouge">InputStream</code>，因此不存在资源泄露。</p><h2 id="序列化">序列化</h2><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组。</p><p>序列化后可以把<code class="language-plaintext highlighter-rouge">byte[]</code>保存到文件中，或者把<code class="language-plaintext highlighter-rouge">byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p><p>有序列化，就有反序列化，即把一个二进制内容（也就是<code class="language-plaintext highlighter-rouge">byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code class="language-plaintext highlighter-rouge">byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code class="language-plaintext highlighter-rouge">byte[]</code>并把它“变回”Java对象。</p><p>一个Java对象要能序列化，必须实现一个特殊的<code class="language-plaintext highlighter-rouge">java.io.Serializable</code>接口，它的定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Serializable</span> <span class="o">{}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Serializable</code>接口<strong>没有定义任何方法</strong>，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身<strong>贴了个“标记”</strong>，并没有增加任何方法。</p><hr /><p><strong>序列化</strong></p><p>把一个Java对象变为<code class="language-plaintext highlighter-rouge">byte[]</code>数组，需要使用<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ByteArrayOutputStream</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">output</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span><span class="c1">// 写入int</span>
    <span class="n">output</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span><span class="c1">// 写入String</span>
    <span class="n">output</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mf">123.456</span><span class="o">));</span><span class="c1">// 写入Object</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">()));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>既可以写入基本类型，如<code class="language-plaintext highlighter-rouge">int</code>，<code class="language-plaintext highlighter-rouge">boolean</code>，也可以写入<code class="language-plaintext highlighter-rouge">String</code>（以UTF-8编码），<strong>还可以写入实现了<code class="language-plaintext highlighter-rouge">Serializable</code>接口的<code class="language-plaintext highlighter-rouge">Object</code></strong>。</p><p>因为写入<code class="language-plaintext highlighter-rouge">Object</code>时需要大量的类型信息，所以写入的内容很大。</p><p><strong>序列化仅涉及对象的状态（即实例变量）</strong>，不包括类的方法。序列化的主要目的是保存对象的状态，以便在稍后可以将其完全恢复为原始状态。</p><p>还可以通过<code class="language-plaintext highlighter-rouge">transient</code> 关键字用于告诉 JVM 在序列化该对象时忽略指定的字段。这意味着在对象被序列化时，被标记为 <code class="language-plaintext highlighter-rouge">transient</code> 的字段不会被保存到序列化数据中，而在对象被反序列化时，这些字段会被 JVM 设置为默认值，例如 <code class="language-plaintext highlighter-rouge">null</code>、0 或 false，而不是之前被序列化的值。</p><p>当对象被序列化时，如果类中定义了 <code class="language-plaintext highlighter-rouge">readResolve</code> 方法，并且该方法返回一个对象，那么在反序列化时<strong>会调用该方法来获取对象</strong>，而<strong>不是通过反序列化创建一个新的对象</strong>。</p><p>这意味着 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法可以用来控制反序列化过程中返回的对象，<strong>可以在方法中返回任何想要的对象，而不受反序列化的影响</strong>。如果一个类写了 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法，并且在方法中返回了特定的对象，那么反序列化过程<strong>就会返回这个方法中指定的对象</strong>，而<strong>不会</strong>从文件中重新构造对象。也因此这会忽略保存在文件的全部序列化数据！不过，可以在反序列化之前删除<code class="language-plaintext highlighter-rouge">readResolve()</code>。</p><p>实际上，<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法的作用是控制对象的反序列化过程，可以用来确保反序列化后的对象符合特定的要求，或者实现单例模式等。</p><hr /><p><strong>反序列化</strong></p><p>和<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>相反，<code class="language-plaintext highlighter-rouge">ObjectInputStream</code>负责从一个字节流读取Java对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(...))</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
    <span class="nc">Double</span> <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Double</span><span class="o">)</span> <span class="n">input</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>除了能读取基本类型和<code class="language-plaintext highlighter-rouge">String</code>类型外，调用<code class="language-plaintext highlighter-rouge">readObject()</code>可以<strong>直接返回一个<code class="language-plaintext highlighter-rouge">Object</code>对象</strong>。要把它变成一个特定类型<strong>，必须强制转型</strong>。</p><p><code class="language-plaintext highlighter-rouge">readObject()</code>可能抛出的异常有：</p><ul><li><code class="language-plaintext highlighter-rouge">ClassNotFoundException</code>：没有找到对应的Class；</li><li><code class="language-plaintext highlighter-rouge">InvalidClassException</code>：Class不匹配。</li></ul><p>对于<code class="language-plaintext highlighter-rouge">ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code class="language-plaintext highlighter-rouge">Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序<strong>并没有定义</strong><code class="language-plaintext highlighter-rouge">Person</code>类，所以<strong>无法反序列化</strong>。</p><p>对于<code class="language-plaintext highlighter-rouge">InvalidClassException</code>，这种情况常见于序列化的<code class="language-plaintext highlighter-rouge">Person</code>对象定义了一个<code class="language-plaintext highlighter-rouge">int</code>类型的<code class="language-plaintext highlighter-rouge">age</code>字段，但是反序列化时，<code class="language-plaintext highlighter-rouge">Person</code>类定义的<code class="language-plaintext highlighter-rouge">age</code>字段被改成了<code class="language-plaintext highlighter-rouge">long</code>类型，所以导致<strong>class不兼容</strong>。</p><p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code class="language-plaintext highlighter-rouge">serialVersionUID</code>静态变量，用于标识Java类的<strong>序列化“版本”</strong>，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code class="language-plaintext highlighter-rouge">serialVersionUID</code>的值，这样就能<strong>自动阻止不匹配的class版本</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">2709425275741743919L</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>如果不显示指定 <code class="language-plaintext highlighter-rouge">serialVersionUID</code>，Java 编译器会根据<strong>类的细节</strong>自动生成一个 <code class="language-plaintext highlighter-rouge">serialVersionUID</code>。如果类的细节发生了变化（例如添加或删除字段，或者改变了方法签名），则编译器生成的 <code class="language-plaintext highlighter-rouge">serialVersionUID</code> 也会发生变化。这可能导致在反序列化时抛出 <code class="language-plaintext highlighter-rouge">InvalidClassException</code> 异常，因为序列化的类与反序列化的类的 <code class="language-plaintext highlighter-rouge">serialVersionUID</code> 不匹配。为了避免这种情况，最好显示地指定一个 <code class="language-plaintext highlighter-rouge">serialVersionUID</code>，并在类的细节发生变化时手动更新它。</p><p>实际上，非重写的方法可以随便添加修改删除，而重写的方法不能动，动了就会导致<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号。</p><p>要特别注意反序列化的几个<strong>重要特点</strong>：</p><ol><li>实现了<code class="language-plaintext highlighter-rouge">Serializable</code>接口的类，在反序列化时<strong>构造方法不会被调用</strong>。这是因为反序列化是通过<strong>读取</strong>对象的<strong>序列化数据</strong>来<strong>重新构建对象</strong>，而不是通过<strong>调用</strong>构造方法来<strong>创建对象</strong>的。</li><li>如果一个类<strong>没有实现</strong><code class="language-plaintext highlighter-rouge">Serializable</code>接口，但它是某个实现了<code class="language-plaintext highlighter-rouge">Serializable</code>接口的<strong>父类</strong>，那么在反序列化子类时，JVM会自动调用<strong>父类的无参构造方法</strong>，并且父类无参构造方法里的代码<strong>也会被执行</strong>。这是因为反序列化<strong>需要</strong>对整个继承层次进行处理，以便<strong>正确</strong>地重建对象的状态。</li></ol><p>这些规则在Java的序列化和反序列化机制中起着<strong>重要作用</strong>，确保对象在序列化和反序列化过程中能够正确地恢复其状态。</p><p>因为Java的序列化机制可以导致一个实例能直接从<code class="language-plaintext highlighter-rouge">byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code class="language-plaintext highlighter-rouge">byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致<strong>严重的安全漏洞</strong>。</p><p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的<strong>通用数据结构</strong>来实现，只输出<strong>基本类型</strong>（包括String）的内容，而不存储任何与代码相关的信息。</p><hr /><h2 id="自定义序列化">自定义序列化</h2><p>用于控制序列化和反序列化过程的方法：</p><ol><li><code class="language-plaintext highlighter-rouge">private void writeObject(ObjectOutputStream out) throws IOException</code>：用于自定义序列化过程。</li><li><code class="language-plaintext highlighter-rouge">private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException</code>：用于自定义反序列化过程。</li><li><code class="language-plaintext highlighter-rouge">private void writeObjectNoData(ObjectOutputStream out) throws ObjectStreamException</code>：用于在序列化时写入额外的数据，而不是对象的内容。</li><li><code class="language-plaintext highlighter-rouge">private Object writeReplace() throws ObjectStreamException</code>：用于在序列化过程中替换对象，返回一个替代对象。</li><li><code class="language-plaintext highlighter-rouge">private Object readResolve() throws ObjectStreamException</code>：用于在反序列化过程中替换对象，返回一个替代对象。</li></ol><p>这些方法都是私有的，且方法名是固定的，当对象被序列化或反序列化时，如果存在这些方法，Java 序列化机制会自动调用它们。这些方法可以让开发者控制序列化和反序列化的细节，从而实现更复杂的序列化逻辑。</p><p><code class="language-plaintext highlighter-rouge">writeObjectNoData</code> 方法是一个特殊的方法，在默认情况下不会被调用。它是用来处理一些特殊情况的，例如在序列化对象时，如果对象的某些字段在序列化时应该有特定的默认值，可以使用这个方法来设置这些字段的值。</p><p>但是在实际的应用中，很少会用到这个方法，因为大多数情况下，我们可以通过在 <code class="language-plaintext highlighter-rouge">writeObject</code> 方法中进行处理来达到相同的效果。</p><hr /><p>只能在 <code class="language-plaintext highlighter-rouge">writeObject</code> 方法中使用的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">defaultWriteObject()</code>：将默认序列化的字段写入输出流。这个方法会将对象的默认序列化行为委托给默认的序列化机制。</li><li><code class="language-plaintext highlighter-rouge">writeFields()</code>：将对象的非静态和非瞬态字段写入输出流。这个方法可以与 <code class="language-plaintext highlighter-rouge">readFields()</code> 配合使用，用于手动序列化对象的字段。</li><li><code class="language-plaintext highlighter-rouge">putFields()</code>：为对象创建一个 <code class="language-plaintext highlighter-rouge">java.io.ObjectOutputStream.PutField</code> 对象，可以使用该对象手动设置字段的值，并在 <code class="language-plaintext highlighter-rouge">writeFields()</code> 中写入这些值。</li></ul><p>只能在 <code class="language-plaintext highlighter-rouge">readObject </code> 方法中使用的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">defaultReadObject()</code>：从输入流中读取默认序列化的字段。这个方法会将对象的默认反序列化行为委托给默认的反序列化机制。</li><li><code class="language-plaintext highlighter-rouge">readFields()</code>：从输入流中读取对象的非静态和非瞬态字段。这个方法可以与 <code class="language-plaintext highlighter-rouge">writeFields()</code> 配合使用，用于手动反序列化对象的字段。</li><li><code class="language-plaintext highlighter-rouge">readObject()</code>：读取一个对象，并将其转换为指定的类型。这个方法通常用于读取自定义序列化的对象。</li><li><code class="language-plaintext highlighter-rouge">readUnshared()</code>：读取一个对象，并确保返回的对象是独立于当前流的。</li></ul><p>只能在 <code class="language-plaintext highlighter-rouge">writeObjectNoData</code> 方法中使用的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">defaultWriteObject()</code>：将对象的默认序列化行为委托给默认的序列化机制。这个方法通常与 <code class="language-plaintext highlighter-rouge">readObject</code> 方法中的 <code class="language-plaintext highlighter-rouge">defaultReadObject()</code> 配合使用。</li><li><code class="language-plaintext highlighter-rouge">writeFields()</code>：将对象的非静态和非瞬态字段写入输出流。这个方法通常与 <code class="language-plaintext highlighter-rouge">readObject</code> 方法中的 <code class="language-plaintext highlighter-rouge">readFields()</code> 配合使用，用于手动序列化对象的字段。</li><li><code class="language-plaintext highlighter-rouge">writeObject()</code>：将指定对象写入输出流，通常用于序列化对象的引用或特定字段。</li><li><code class="language-plaintext highlighter-rouge">writeUnshared(Object obj)</code>：将指定对象写入输出流，确保写入的对象是独立于当前流的。</li></ul><hr /><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">(</span><span class="s">"transient"</span><span class="o">,</span> <span class="s">"normal"</span><span class="o">);</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"data.ser"</span><span class="o">);</span>
             <span class="nc">ObjectOutputStream</span> <span class="n">oos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">fos</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"data.ser"</span><span class="o">);</span>
             <span class="nc">ObjectInputStream</span> <span class="n">ois</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">MyClass</span> <span class="n">newObj</span> <span class="o">=</span> <span class="o">(</span><span class="nc">MyClass</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">newObj</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyClass</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">transient</span> <span class="nc">String</span> <span class="n">transientField</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">normalField</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="nc">String</span> <span class="n">transientField</span><span class="o">,</span> <span class="nc">String</span> <span class="n">normalField</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">transientField</span> <span class="o">=</span> <span class="n">transientField</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">normalField</span> <span class="o">=</span> <span class="n">normalField</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObject</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">.</span><span class="na">defaultWriteObject</span><span class="o">();</span> <span class="c1">// 默认序列化</span>
        <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">transientField</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">());</span> <span class="c1">// 自定义序列化</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">readObject</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">in</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="n">in</span><span class="o">.</span><span class="na">defaultReadObject</span><span class="o">();</span> <span class="c1">// 默认反序列化</span>
        <span class="n">transientField</span> <span class="o">=</span> <span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">in</span><span class="o">.</span><span class="na">readObject</span><span class="o">()).</span><span class="na">toLowerCase</span><span class="o">();</span> <span class="c1">// 自定义反序列化</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">writeObjectNoData</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">normalField</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">());</span> <span class="c1">// 只在没有序列化数据时调用，可以做一些特殊处理</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"MyClass{transientField='"</span> <span class="o">+</span> <span class="n">transientField</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", normalField='"</span> <span class="o">+</span> <span class="n">normalField</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在这个例子中，<code class="language-plaintext highlighter-rouge">transientField</code> 被标记为 transient，不会被默认序列化，我们在 <code class="language-plaintext highlighter-rouge">writeObject</code> 和 <code class="language-plaintext highlighter-rouge">readObject</code> 方法中自定义了对它的序列化和反序列化操作，因此它还是会被序列化。同时，<code class="language-plaintext highlighter-rouge">normalField</code> 在 <code class="language-plaintext highlighter-rouge">writeObjectNoData</code> 方法中进行了特殊处理，只有在没有序列化数据时才会被调用。</p><h2 id="读取classpath资源">读取classpath资源</h2><p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个<code class="language-plaintext highlighter-rouge">.properties</code>文件中读取配置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">conf</span> <span class="o">=</span> <span class="s">"C:\\conf\\default.properties"</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">conf</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><p>这段代码要正常执行，必须在C盘创建<code class="language-plaintext highlighter-rouge">conf</code>目录，然后在目录里创建<code class="language-plaintext highlighter-rouge">default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p><p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p><p>有没有<strong>路径无关</strong>的读取文件的方式呢？</p><p>我们知道，Java存放<code class="language-plaintext highlighter-rouge">.class</code>的目录或jar包<strong>也可以包含任意其他类型的文件</strong>，例如：</p><ul><li>配置文件，例如<code class="language-plaintext highlighter-rouge">.properties</code>；</li><li>图片文件，例如<code class="language-plaintext highlighter-rouge">.jpg</code>；</li><li>文本文件，例如<code class="language-plaintext highlighter-rouge">.txt</code>，<code class="language-plaintext highlighter-rouge">.csv</code>；</li><li>……</li></ul><p>从classpath读取文件就<strong>可以</strong>避免不同环境下文件路径不一致的问题：如果我们把<code class="language-plaintext highlighter-rouge">default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p><p>在classpath中的资源文件，路径总是以<code class="language-plaintext highlighter-rouge">/</code>开头，我们先获取当前的<code class="language-plaintext highlighter-rouge">Class</code>对象，然后调用<code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/default.properties"</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><p>调用<code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code class="language-plaintext highlighter-rouge">null</code>。因此，我们需要检查返回的<code class="language-plaintext highlighter-rouge">InputStream</code>是否为<code class="language-plaintext highlighter-rouge">null</code>。</p><p>如果我们把默认的配置放到<strong>jar包中</strong>，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">inputStreamFromClassPath</span><span class="o">(</span><span class="s">"/default.properties"</span><span class="o">));</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">inputStreamFromFile</span><span class="o">(</span><span class="s">"./conf.properties"</span><span class="o">));</span>
</code></pre></div></div><p>这样读取配置文件，应用程序启动就更加灵活。</p><h2 id="zipinputstream">ZipInputStream</h2><p><code class="language-plaintext highlighter-rouge">ZipInputStream</code>是一种<code class="language-plaintext highlighter-rouge">FilterInputStream</code>，它可以<strong>直接读取zip包</strong>的内容：</p><pre><code class="language-ascii">┌───────────────────┐
│    InputStream    │
└───────────────────┘
          ▲
          │
┌───────────────────┐
│ FilterInputStream │
└───────────────────┘
          ▲
          │
┌───────────────────┐
│InflaterInputStream│
└───────────────────┘
          ▲
          │
┌───────────────────┐
│  ZipInputStream   │
└───────────────────┘
          ▲
          │
┌───────────────────┐
│  JarInputStream   │
└───────────────────┘
</code></pre><p>另一个<code class="language-plaintext highlighter-rouge">JarInputStream</code>是从<code class="language-plaintext highlighter-rouge">ZipInputStream</code>派生，它继承了<code class="language-plaintext highlighter-rouge">ZipInputStream</code>的功能，并增加了直接读取JAR文件中<code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>文件的能力。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p><hr /><p><strong>读取zip包</strong></p><p>要创建一个<code class="language-plaintext highlighter-rouge">ZipInputStream</code>，通常是传入一个<code class="language-plaintext highlighter-rouge">FileInputStream</code>作为数据源，然后，循环调用<code class="language-plaintext highlighter-rouge">getNextEntry()</code>，直到返回<code class="language-plaintext highlighter-rouge">null</code>，表示zip流结束。</p><p>一个<code class="language-plaintext highlighter-rouge">ZipEntry</code>表示一个<strong>压缩的文件或目录</strong>，如果是压缩的文件，我们就用<code class="language-plaintext highlighter-rouge">read()</code>方法不断读取，直到返回<code class="language-plaintext highlighter-rouge">-1</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">ZipInputStream</span> <span class="n">zip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ZipInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(...)))</span> <span class="o">{</span>
    <span class="nc">ZipEntry</span> <span class="n">entry</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">entry</span> <span class="o">=</span> <span class="n">zip</span><span class="o">.</span><span class="na">getNextEntry</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">entry</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">zip</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">...</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p><strong>写入zip包</strong></p><p><code class="language-plaintext highlighter-rouge">ZipOutputStream</code>是一种<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>，它可以直接写入内容到zip包。</p><p>要先创建一个<code class="language-plaintext highlighter-rouge">ZipOutputStream</code>，通常是包装一个<code class="language-plaintext highlighter-rouge">FileOutputStream</code>，然后，每写入一个文件前，先调用<code class="language-plaintext highlighter-rouge">putNextEntry()</code>，然后用<code class="language-plaintext highlighter-rouge">write()</code>写入<code class="language-plaintext highlighter-rouge">byte[]</code>数据，写入完毕后调用<code class="language-plaintext highlighter-rouge">closeEntry()</code>结束这个文件的打包。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">ZipOutputStream</span> <span class="n">zip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ZipOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(...)))</span> <span class="o">{</span>
    <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">zip</span><span class="o">.</span><span class="na">putNextEntry</span><span class="o">(</span><span class="k">new</span> <span class="nc">ZipEntry</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
        <span class="n">zip</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">toPath</span><span class="o">()));</span>
        <span class="n">zip</span><span class="o">.</span><span class="na">closeEntry</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上面的代码<strong>没有考虑文件的目录结构</strong>。如果要<strong>实现</strong>目录层次结构，<code class="language-plaintext highlighter-rouge">new ZipEntry(name)</code>传入的<code class="language-plaintext highlighter-rouge">name</code>要用相对路径。</p><h2 id="重定向标准输入输出">重定向标准输入输出</h2><p>Java系统<strong>预先</strong>定义了3个流对象：</p><ol><li>标准输出设备<code class="language-plaintext highlighter-rouge">System.out</code></li><li>标准输入设备<code class="language-plaintext highlighter-rouge">System.in</code></li><li>标准错误设备<code class="language-plaintext highlighter-rouge">System.err</code></li></ol><p>在<strong>默认</strong>情况下,<strong>标准输入设备是键盘,而标准输出设备是控制台</strong>,而通过<code class="language-plaintext highlighter-rouge">System.setIn</code>方法和<code class="language-plaintext highlighter-rouge">System.setout</code>方法可以改变它们的默认输入/输出设备。</p><p>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//建立一个文件输出流,并将它的append标记设置为true,建立一个PrintStream对象,它将作为标准输出流</span>
<span class="nc">PrintStream</span> <span class="n">ps</span> <span class="o">=</span><span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"Demo.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">));</span>
<span class="c1">//将标准输出定向到PrintStream对象</span>
<span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">ps</span><span class="o">);</span>
<span class="c1">//输出以条数据,它不再会在控制台输出,而是输出到了文件Demo.txt中</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"该字符串会输出到文件中"</span><span class="o">);</span>
</code></pre></div></div><p>也可以hook后都输出</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * @author aotmd
 * @version 1.0
 * @date 2021/2/27 20:29
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">重写控制台也输出日志</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">PrintStream</span> <span class="n">originalOut</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">OutputStreamWriter</span> <span class="n">fos</span><span class="o">;</span>
    <span class="cm">/**
     * 也输出日志,重写println(string)
     * @param file 日志文件路径
     * @param addTo 追加模式
     * @param addTime 文件名称是否追加时间
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">consoleToLog</span><span class="o">(</span><span class="nc">String</span> <span class="n">file</span><span class="o">,</span><span class="kt">boolean</span> <span class="n">addTo</span><span class="o">,</span><span class="kt">boolean</span> <span class="n">addTime</span><span class="o">){</span>
        <span class="c1">//设置日期格式</span>
        <span class="nc">SimpleDateFormat</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleDateFormat</span><span class="o">(</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">time</span> <span class="o">=</span> <span class="n">addTime</span> <span class="o">?</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">df</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">())</span> <span class="o">:</span> <span class="s">""</span><span class="o">;</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">file</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"."</span><span class="o">));</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">=</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">file</span><span class="o">+</span><span class="n">time</span><span class="o">+</span><span class="s">".txt"</span><span class="o">,</span><span class="n">addTo</span><span class="o">),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">originalOut</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">println</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">outputLog</span><span class="o">(</span><span class="n">s</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="kd">super</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">outputLog</span><span class="o">(</span><span class="nc">String</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">restoreConsole</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">originalOut</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">fos</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="dataoutputstream">DataOutputStream</h2><p>数据输入输出出流允许应用程序以与<strong>机器无关</strong>方式将Java基本数据类型写到底层输出流。</p><p>数据输出流：<code class="language-plaintext highlighter-rouge">DataOutputStream</code></p><p>数据输入流：<code class="language-plaintext highlighter-rouge">DataInputStream</code></p><p><strong>要想使用数据输出流和输入流,要按照一定格式输出数据,再按照相同的格式输入数据。</strong></p><p><code class="language-plaintext highlighter-rouge">DataOutputStreams</code>是<code class="language-plaintext highlighter-rouge">OutputStream</code>的子类。继承自<code class="language-plaintext highlighter-rouge">FillterOutputStream</code>类,同时实现<code class="language-plaintext highlighter-rouge">DataOutput</code>接口。在<code class="language-plaintext highlighter-rouge">DataOutput</code>接口定义了一系列写入各种数据的方法。</p><h3 id="dataoutputstream-1">DataOutputStream</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataOutputStream</span> <span class="kd">extends</span> <span class="nc">FilterOutputStream</span> <span class="kd">implements</span> <span class="nc">DataOutput</span><span class="o">{}</span> 
</code></pre></div></div><p><strong>字段</strong></p><p><code class="language-plaintext highlighter-rouge">protected int written</code>：到目前为止写入数据输出流的字节数。</p><p><strong>构造方法</strong></p><p><code class="language-plaintext highlighter-rouge">DataOutputStream(OutputStream out)</code> ：创建一个新的数据输出流,将数据写入指定基础输出流。</p><p><strong>写方法</strong></p><p><strong>(1)基本数据类型写入方法：</strong></p><p>八种基本类型：六种数字类型(四个整数型,两个浮点型),一种字符类型,还有一种布尔型。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void writeByte(int v)</td><td>将一个<code class="language-plaintext highlighter-rouge">byte</code>值以1-byte值形式写出到基础输出流中。</td></tr><tr><td>void writeShort(int v)</td><td>将一个<strong>short</strong>值以2-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeInt(int v)</td><td>将一个<code class="language-plaintext highlighter-rouge">int</code>值以4-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeLong(long v)</td><td>将一个<code class="language-plaintext highlighter-rouge">long</code>值以8-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeFloat(float v)</td><td>使用<code class="language-plaintext highlighter-rouge">Float</code>类中的floatToIntBits方法将float参数转换为一个int值,然后将该int值以4-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeDouble(double v)</td><td>使用<code class="language-plaintext highlighter-rouge">Double</code>类中的doubleToLongBits方法将double参数转换为一个long值,然后将该long值以8-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeChar(int v)</td><td>将一个<code class="language-plaintext highlighter-rouge">char</code>值以2-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeBoolean(boolean v)</td><td>将一个<code class="language-plaintext highlighter-rouge">boolean</code>值以1-byte值形式写入基础输出流。</td></tr></tbody></table><p><strong>(2)字节数组的写入方法</strong></p><p><code class="language-plaintext highlighter-rouge">void write(byte[] b, int off, int len)</code> 将指定<code class="language-plaintext highlighter-rouge">b</code>数组中从偏移量 <code class="language-plaintext highlighter-rouge">off</code> 开始的 <code class="language-plaintext highlighter-rouge">len</code> 个字节写入基础输出</p><p><strong>(3)只写入<code class="language-plaintext highlighter-rouge">int</code>的低八位</strong></p><p><code class="language-plaintext highlighter-rouge">void write(int b)</code> 将指定字节(参数<code class="language-plaintext highlighter-rouge">b</code>的八个低位)写入基础输出流。</p><p><strong>(4)写入字符串的方法</strong></p><p><code class="language-plaintext highlighter-rouge">void writeBytes(String s)</code> 将字符串按字节顺序写出到基础输出流中。</p><p><code class="language-plaintext highlighter-rouge">void writeChars(String s)</code> 采用<code class="language-plaintext highlighter-rouge">UTF-16be</code>方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。</p><p><code class="language-plaintext highlighter-rouge">void writeUTF(String str)</code> 以与机器无关方式使用<code class="language-plaintext highlighter-rouge">UTF-8</code>修改版编码将一个字符串写入基础</p><p><strong>其他方法</strong></p><p><code class="language-plaintext highlighter-rouge">void flush()</code> 清空此数据输出流。写入文件</p><p><code class="language-plaintext highlighter-rouge">int size()</code> 返回计数器 <code class="language-plaintext highlighter-rouge">written</code> 的当前值,即到目前为止写入此数据输出流的字节数。</p><hr /><h3 id="datainputstream">DataInputStream</h3><p><strong>构造方法</strong></p><p><code class="language-plaintext highlighter-rouge">DataInputStream(InputStream in)</code>：使用指定的底层 <code class="language-plaintext highlighter-rouge">InputStream</code> 创建一个 <code class="language-plaintext highlighter-rouge">DataInputStream</code>。</p><p><strong>读方法</strong></p><p><strong>1.基本类型读取方法：</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>byte readByte()</td><td>读取并返回一个输入字节。该字节被看作是 -128 到 127(包含)范围内的一个有符号值。</td></tr><tr><td>int readInt()</td><td>读取四个输入字节并返回一个 <code class="language-plaintext highlighter-rouge">int</code> 值。</td></tr><tr><td>short readShort()</td><td>读取两个字节并返回一个<code class="language-plaintext highlighter-rouge">short</code>值。</td></tr><tr><td>long readLong()</td><td>读取八个输入字节并返回一个 <code class="language-plaintext highlighter-rouge">long</code> 值。</td></tr><tr><td>float readFloat()</td><td>读取四个输入字节并返回一个 <code class="language-plaintext highlighter-rouge">float</code> 值。</td></tr><tr><td>double readDouble()</td><td>读取八个输入字节并返回一个 <code class="language-plaintext highlighter-rouge">double</code> 值。实现这一点的方法是：   先使用与 <code class="language-plaintext highlighter-rouge">readlong</code> 方法完全相同的方式构造一个 <code class="language-plaintext highlighter-rouge">long</code> 值, 然后使用与 <code class="language-plaintext highlighter-rouge">Double.longBitsToDouble</code> 方法完全相同的方式将此 <code class="language-plaintext highlighter-rouge">long</code> 值转换成一个 <code class="language-plaintext highlighter-rouge">double</code> 值。</td></tr><tr><td>boolean readBoolean()</td><td>读取一个输入字节,如果该字节不是零,则返回 <code class="language-plaintext highlighter-rouge">true</code>,如果是零,则返回 <code class="language-plaintext highlighter-rouge">false</code>。</td></tr><tr><td>char readChar()</td><td>读取两个输入字节并返回一个 <code class="language-plaintext highlighter-rouge">char</code> 值。</td></tr></tbody></table><p><strong>2.字符串读取方法</strong></p><p><code class="language-plaintext highlighter-rouge">String readUTF();</code> 读入一个已使用 UTF-8 修改版格式编码的字符串。</p><p><code class="language-plaintext highlighter-rouge">static String readUTF(DataInput in)</code> 从流 in 中读取用 UTF-8 修改版格式编码的 Unicode 字符格式的字符串;然后以 <code class="language-plaintext highlighter-rouge">String</code> 形式返回此字符串。</p><p>可以看到<code class="language-plaintext highlighter-rouge">DataInputStream</code>中读取字符串<strong>只有<code class="language-plaintext highlighter-rouge">readUTF()</code></strong>方法,<strong>没有</strong>与<code class="language-plaintext highlighter-rouge">DataOutputStream</code>对应的：</p><p><code class="language-plaintext highlighter-rouge">void writeBytes(String s)</code> 将字符串按字节顺序写出到基础输出流中。</p><p><code class="language-plaintext highlighter-rouge">void writeChars(String s)</code> 采用<code class="language-plaintext highlighter-rouge">UTF-16be</code>方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。</p><p>因此使用<code class="language-plaintext highlighter-rouge">DataOutputStream</code>的这两个方法写入字符串时,<code class="language-plaintext highlighter-rouge">DataInputStream</code>来读取可能比较<strong>麻烦</strong>。</p><p><strong>3.无符号整数读取方法</strong></p><p><code class="language-plaintext highlighter-rouge">DataInputStream</code>中并没有写入无符号整数的方法,这两个方法<strong>是不是用不到</strong>？</p><p><code class="language-plaintext highlighter-rouge">int readUnsignedByte();</code>读取一个输入字节,将它左侧补零 (zero-extend) 转变为 <code class="language-plaintext highlighter-rouge">int</code> 类型,并返回结果,所以结果的范围是 0 到 255。如果接口 <code class="language-plaintext highlighter-rouge">DataOutput</code> 的 <code class="language-plaintext highlighter-rouge">writeByte</code> 方法的参数是 0 到 255 之间的值,则此方法适用于读取用 <code class="language-plaintext highlighter-rouge">writeByte</code> 写入的字节。</p><p><code class="language-plaintext highlighter-rouge">int readUnsignedShort();</code>读取两个输入字节,并返回 0 到 65535 范围内的一个 <code class="language-plaintext highlighter-rouge">int</code> 值。如果接口 <code class="language-plaintext highlighter-rouge">DataOutput</code> 的 <code class="language-plaintext highlighter-rouge">writeShort</code> 方法的参数是 0 到 65535 范围内的值,则此方法适用于读取用 <code class="language-plaintext highlighter-rouge">writeShort</code> 写入的字节。</p><p><strong>4.读取字节数组的方法：</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int read(byte[] b)</td><td>从包含的输入流中读取一定数量的字节,并将它们存储到缓冲区数组 <code class="language-plaintext highlighter-rouge">b</code> 中。</td></tr><tr><td>int read(byte[] b, int off, int len)</td><td>从包含的输入流中将最多 <code class="language-plaintext highlighter-rouge">len</code> 个字节读入一个 <code class="language-plaintext highlighter-rouge">byte</code> 数组中。</td></tr><tr><td>void readFully(byte[] b)</td><td>从输入流中读取一些字节,并将它们存储在缓冲区数组 <code class="language-plaintext highlighter-rouge">b</code> 中。读取的字节数等于 <code class="language-plaintext highlighter-rouge">b</code> 的长度。</td></tr><tr><td>void readFully(byte[] b, int off, int len)</td><td>从输入流中读取 <code class="language-plaintext highlighter-rouge">len</code> 个字节到字节数组<code class="language-plaintext highlighter-rouge">b</code>,从<code class="language-plaintext highlighter-rouge">b</code>的<code class="language-plaintext highlighter-rouge">off</code>下标开始读入。</td></tr></tbody></table><p><strong>5.同样是读取字节数组的方法,<code class="language-plaintext highlighter-rouge">read(byte[] b)</code>和<code class="language-plaintext highlighter-rouge">readFully(byte[] b)</code>的区别：</strong></p><p>其实<code class="language-plaintext highlighter-rouge">read(byte[] b)</code>方法和<code class="language-plaintext highlighter-rouge">readFully(byte []b)</code>都是利用<code class="language-plaintext highlighter-rouge">InputStream</code>中<code class="language-plaintext highlighter-rouge">read()</code>方法,每次读取的也是一个字节,只是读取字节数组的方式不同.</p><p><code class="language-plaintext highlighter-rouge">read(byte[] b)</code>方法实质是读取流上的字节直到流上<strong>没有</strong>字节为止,如果当声明的字节数组长度<strong>大于</strong>流上的数据长度时就提前返回</p><p><code class="language-plaintext highlighter-rouge">readFully(byte[] b)</code>方法是读取流上<strong>指定长度</strong>的字节数组,也就是说如果声明了长度为<code class="language-plaintext highlighter-rouge">len</code>的字节数组,<code class="language-plaintext highlighter-rouge">readFully(byte[] b)</code>方法只有读取<code class="language-plaintext highlighter-rouge">len</code>长度个字节的时候才返回,否则<strong>阻塞等待</strong>,如果超时,则会抛出异常 <code class="language-plaintext highlighter-rouge">EOFException</code>。</p><p>那么当发送了长度为<code class="language-plaintext highlighter-rouge">len</code>的字节,那么为什么用<code class="language-plaintext highlighter-rouge">read</code>方法用户收不全呢,揪其原因我们发现消息在网络中传输是没那么理想的,我们发的那部分字节数组在传送过程中可能在接受信息方的缓存当中或者在传输线路,极端情况下可能在发送方的缓存当中,这样就不在流上,所以<code class="language-plaintext highlighter-rouge">read</code>方法提前返回了,这样就造成了各种错误。</p><p><code class="language-plaintext highlighter-rouge">readFully()</code>源码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFully</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">copy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span> 
    <span class="k">while</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="n">copy</span><span class="o">);</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>  
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">EOFException</span><span class="o">();</span>  
        <span class="o">}</span>  
        <span class="n">off</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>  
        <span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">readFully</code>方法并不是说一下就把整个文件读完了,不用去管是否到达文件末尾的异常。<code class="language-plaintext highlighter-rouge">readFully</code>只是在读取数据的时候,<strong>会一直把缓冲区读满</strong>,否则一直处于阻塞状态而等待读取。</p><p><code class="language-plaintext highlighter-rouge">read</code>方法只是将字节流中的数据读完。那么数据在TCP协议传送的过程中,可能输入流接受到的数据并不完全,只是其中的一部分。</p><p>如果这时候的缓冲区没有满的话,<code class="language-plaintext highlighter-rouge">readFully</code>将会继续等待,直到缓冲区装满。</p><p>某些时候,你可能需要读出特定的长度的字段。比如一些数据的头信息之类的,这时候如果你用<code class="language-plaintext highlighter-rouge">read</code>去读,那么可能还没有读完就个你返回来了。但是如果去用<code class="language-plaintext highlighter-rouge">readFully</code>读,那么就会完整的给你读出来。但是在更多的时候,如果不是确定要用特定长度的数据。还是用<code class="language-plaintext highlighter-rouge">read</code>去读。用<code class="language-plaintext highlighter-rouge">readFully</code>有点危险。</p><p><strong>6.跳过n个字节：</strong></p><p><code class="language-plaintext highlighter-rouge">int skipBytes(int n)</code> 试图在输入流中跳过数据的<code class="language-plaintext highlighter-rouge">n</code>个字节,并丢弃跳过的字节。</p><p><strong>实例</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span>  
<span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span>  
    <span class="o">{</span>  
        <span class="nc">FileOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"testDataOutputStream.txt"</span><span class="o">);</span>  
        <span class="nc">DataOutputStream</span> <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>  
        <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>  
        <span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">900</span><span class="o">;</span>  
        <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">12.3f</span><span class="o">;</span>  
        <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">800</span><span class="n">l</span><span class="o">;</span>  
        <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">14.23</span><span class="o">;</span>  
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>  
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'中'</span><span class="o">;</span>  
        <span class="n">dos</span><span class="o">.</span><span class="na">writeByte</span><span class="o">(</span><span class="n">b</span><span class="o">);</span><span class="c1">// 写入byte类型数据  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeShort</span><span class="o">(</span><span class="n">s</span><span class="o">);</span><span class="c1">// 写入short类型数据  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">a</span><span class="o">);</span><span class="c1">// 写入int类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeFloat</span><span class="o">(</span><span class="n">f</span><span class="o">);</span><span class="c1">// 写入float类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeLong</span><span class="o">(</span><span class="n">l</span><span class="o">);</span><span class="c1">// 写入long类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeDouble</span><span class="o">(</span><span class="n">d</span><span class="o">);</span><span class="c1">// 写入double类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeBoolean</span><span class="o">(</span><span class="n">flag</span><span class="o">);</span>  
        <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span><span class="c1">// 写入char类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="nc">FileInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"testDataOutputStream.txt"</span><span class="o">);</span>  
        <span class="nc">DataInputStream</span> <span class="n">dif</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>  
        <span class="kt">byte</span> <span class="n">btemp</span><span class="o">;</span>  
        <span class="kt">short</span> <span class="n">stemp</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">atemp</span><span class="o">;</span>  
        <span class="kt">float</span> <span class="n">ftemp</span><span class="o">;</span>  
        <span class="kt">long</span> <span class="n">ltemp</span><span class="o">;</span>  
        <span class="kt">double</span> <span class="n">dtemp</span><span class="o">;</span>  
        <span class="kt">boolean</span> <span class="n">flagtemp</span><span class="o">;</span>  
        <span class="kt">char</span> <span class="n">chtemp</span><span class="o">;</span>  
        <span class="n">btemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readByte</span><span class="o">();</span>  
        <span class="n">stemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readShort</span><span class="o">();</span>  
        <span class="n">atemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>  
        <span class="n">ftemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readFloat</span><span class="o">();</span>  
        <span class="n">ltemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readLong</span><span class="o">();</span>  
        <span class="n">dtemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readDouble</span><span class="o">();</span>  
        <span class="n">flagtemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readBoolean</span><span class="o">();</span>  
        <span class="n">chtemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readChar</span><span class="o">();</span>  
        <span class="c1">// stringtemp=dif.read  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">btemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ftemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ltemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dtemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">flagtemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">chtemp</span><span class="o">);</span>  
        <span class="n">dif</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>输出:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20
30
900
12.3
800
14.23
true
中
</code></pre></div></div><p><strong>实例二</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.DataOutputStream</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span> <span class="c1">// 所有异常抛出  </span>
        <span class="nc">DataOutputStream</span> <span class="n">dos</span><span class="o">;</span> <span class="c1">// 声明数据输出流对象  </span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:"</span> <span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> <span class="s">"order.txt"</span><span class="o">);</span> <span class="c1">// 文件的保存路径  </span>
        <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">));</span> <span class="c1">// 实例化数据输出流对象  </span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"衬衣"</span><span class="o">,</span> <span class="s">"手套"</span><span class="o">,</span> <span class="s">"围巾"</span><span class="o">};</span> <span class="c1">// 商品名称  </span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">prices</span> <span class="o">=</span> <span class="o">{</span><span class="mf">98.3f</span><span class="o">,</span> <span class="mf">30.3f</span><span class="o">,</span> <span class="mf">50.5f</span><span class="o">};</span> <span class="c1">// 商品价格  </span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span> <span class="c1">// 商品数量  </span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 循环输出  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChars</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 写入字符串,注意,这边是writeChars(),不是writechar。  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="sc">'\t'</span><span class="o">);</span> <span class="c1">// 写入分隔符,这边是读取writechar()。  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeFloat</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 写入价格  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="sc">'\t'</span><span class="o">);</span> <span class="c1">// 写入分隔符  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 写入数量  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span> <span class="c1">// 换行  </span>
        <span class="o">}</span>  
        <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭输出流  </span>
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>代码生成的文件</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>886c 8863 0009 42c4 999a 0009 0000 0003
000a 624b 5957 0009 41f2 6666 0009 0000
0002 000a 56f4 5dfe 0009 424a 0000 0009
0000 0001 000a
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">DataOutpputStream</code>写入的数据要使用<code class="language-plaintext highlighter-rouge">DataInputStream</code>取出进来,</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.DataInputStream</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span> <span class="c1">// 所有异常抛出  </span>
        <span class="nc">DataInputStream</span> <span class="n">dis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 声明数据输入流对象  </span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:"</span> <span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> <span class="s">"order.txt"</span><span class="o">);</span> <span class="c1">// 文件的保存路径  </span>
        <span class="n">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">));</span> <span class="c1">// 实例化数据输入流对象  </span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 接收名称  </span>
        <span class="kt">float</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="o">;</span> <span class="c1">// 接收价格  </span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 接收数量  </span>
        <span class="kt">char</span> <span class="n">temp</span><span class="o">[]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 接收商品名称  </span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 保存读取数据的个数  </span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// '\u0000'  </span>
        <span class="k">try</span> <span class="o">{</span>  
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>  
                <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">200</span><span class="o">];</span> <span class="c1">// 开辟空间  </span>
                <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
                <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="na">readChar</span><span class="o">())</span> <span class="o">!=</span> <span class="sc">'\t'</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 接收内容,因为直到读取到'\t'才完成了读取一个字符串,未读取到表示还有内容。  </span>
                    <span class="n">temp</span><span class="o">[</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>  
                    <span class="n">len</span><span class="o">++;</span> <span class="c1">// 读取长度加1  </span>
                <span class="o">}</span>  
                <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">temp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span> <span class="c1">// 将字符数组变为String  </span>
                <span class="n">price</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="na">readFloat</span><span class="o">();</span> <span class="c1">// 读取价格  </span>
                <span class="n">dis</span><span class="o">.</span><span class="na">readChar</span><span class="o">();</span> <span class="c1">// 读取\t  </span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span> <span class="c1">// 读取int  </span>
                <span class="n">dis</span><span class="o">.</span><span class="na">readChar</span><span class="o">();</span> <span class="c1">// 读取\n  </span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"名称：%s;价格：%5.2f;数量：%d\n"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>  
            <span class="o">}</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">}</span>  
        <span class="n">dis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>执行结果：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>名称：衬衣;价格：98.30;数量：3
名称：手套;价格：30.30;数量：2
名称：围巾;价格：50.50;数量：1
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">DataInputStream</code>读取字符串,只能通过<code class="language-plaintext highlighter-rouge">readchar(),</code>一个个读取,不像<code class="language-plaintext highlighter-rouge">DataOutpputStream</code>一样还区分<code class="language-plaintext highlighter-rouge">writechars()</code>,<code class="language-plaintext highlighter-rouge">writechar()</code>。</p><h2 id="randomaccessfile">RandomAccessFile</h2><p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code>是一种特殊的文件流,可以用它在文件的任何地方查找或者插入数据。</p><p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code>同时实现了<code class="language-plaintext highlighter-rouge">Datalnput</code>和<code class="language-plaintext highlighter-rouge">DataOutput</code>接口,所以可以用它来读/写文件。</p><p><code class="language-plaintext highlighter-rouge">RandomAccessFile</code>是一个<strong>独立的类</strong>，不是基于<code class="language-plaintext highlighter-rouge">InputStream</code>或<code class="language-plaintext highlighter-rouge">OutputStream</code>的子类，它可以直接操作文件，实现了对文件的随机读写。</p><p><strong>主要方法</strong>：</p><ul><li><code class="language-plaintext highlighter-rouge">seek(long pos)</code>：将文件指针定位到指定位置。</li><li><code class="language-plaintext highlighter-rouge">getFilePointer()</code>：返回文件指针的当前位置。</li><li><code class="language-plaintext highlighter-rouge">length()</code>：返回文件的长度。</li><li><code class="language-plaintext highlighter-rouge">read()</code>：从文件中读取一个字节，并将文件指针后移一位。</li><li><code class="language-plaintext highlighter-rouge">read(byte[] b, int off, int len)</code>：从文件中读取字节到字节数组中的指定位置。</li><li><code class="language-plaintext highlighter-rouge">readBoolean()</code>、<code class="language-plaintext highlighter-rouge">readByte()</code>、<code class="language-plaintext highlighter-rouge">readShort()</code>、<code class="language-plaintext highlighter-rouge">readChar()</code>、<code class="language-plaintext highlighter-rouge">readInt()</code>、<code class="language-plaintext highlighter-rouge">readLong()</code>、<code class="language-plaintext highlighter-rouge">readFloat()</code>、<code class="language-plaintext highlighter-rouge">readDouble()</code>：分别读取基本数据类型的值。</li><li><code class="language-plaintext highlighter-rouge">readUTF()</code>：以UTF-8格式从文件中读取一个字符串。</li><li><code class="language-plaintext highlighter-rouge">write(int b)</code>、<code class="language-plaintext highlighter-rouge">write(byte[] b, int off, int len)</code>：分别写入一个字节或字节数组到文件中。</li><li><code class="language-plaintext highlighter-rouge">writeBoolean(boolean v)</code>、<code class="language-plaintext highlighter-rouge">writeByte(int v)</code>、<code class="language-plaintext highlighter-rouge">writeShort(int v)</code>、<code class="language-plaintext highlighter-rouge">writeChar(int v)</code>、<code class="language-plaintext highlighter-rouge">writeInt(int v)</code>、<code class="language-plaintext highlighter-rouge">writeLong(long v)</code>、<code class="language-plaintext highlighter-rouge">writeFloat(float v)</code>、<code class="language-plaintext highlighter-rouge">writeDouble(double v)</code>：分别写入基本数据类型的值到文件中。</li><li><code class="language-plaintext highlighter-rouge">writeUTF(String str)</code>：以UTF-8格式将字符串写入文件。</li><li><code class="language-plaintext highlighter-rouge">close()</code>：关闭文件。</li></ul><p><strong>构造器</strong></p><ul><li><p><code class="language-plaintext highlighter-rouge">RandomAccessFile(File file, String mode)</code>：使用指定的文件对象和访问模式创建一个新的<code class="language-plaintext highlighter-rouge">RandomAccessFile</code>实例。访问模式可以是 <code class="language-plaintext highlighter-rouge">"r"</code>（只读）、<code class="language-plaintext highlighter-rouge">"rw"</code>（读写）、<code class="language-plaintext highlighter-rouge">"rws"</code>（读写并同步文件内容）、<code class="language-plaintext highlighter-rouge">"rwd"</code>（读写并同步文件内容和元数据）。</p></li><li><p><code class="language-plaintext highlighter-rouge">RandomAccessFile(String filename, String mode)</code>：使用指定的文件名和访问模式创建一个新的<code class="language-plaintext highlighter-rouge">RandomAccessFile</code>实例。访问模式可以是 <code class="language-plaintext highlighter-rouge">"r"</code>（只读）、<code class="language-plaintext highlighter-rouge">"rw"</code>（读写）、<code class="language-plaintext highlighter-rouge">"rws"</code>（读写并同步文件内容）、<code class="language-plaintext highlighter-rouge">"rwd"</code>（读写并同步文件内容和元数据）。</p></li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">(</span><span class="nc">RandomAccessFile</span> <span class="n">raf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomAccessFile</span><span class="o">(</span><span class="s">"toAppend.txt"</span><span class="o">,</span> <span class="s">"rw"</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">raf</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    <span class="n">raf</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"你好！\n"</span><span class="o">);</span>
    <span class="n">raf</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"世界！\n"</span><span class="o">);</span>
    <span class="n">raf</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">raf</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><pre><code class="language-txt">你好！

进程已结束，退出代码为 0
</code></pre><p>文件内容（具有占位符，方便读取）：</p><pre><code class="language-txt">  
你好！
 
世界！

</code></pre><h2 id="缓存流buffered">缓存流Buffered</h2><p>缓存流是计算机领域中输入输出流的一种常见形式。包括<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>/ <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code> 类和<code class="language-plaintext highlighter-rouge">BufferedReader</code>/ <code class="language-plaintext highlighter-rouge">BufferedWriter</code>类。</p><p>这种流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出,通过<strong>减少系统</strong>资源的<strong>读写次数</strong>来<strong>加快</strong>程序的执行。<code class="language-plaintext highlighter-rouge">BufferedOutputstream</code> 或<code class="language-plaintext highlighter-rouge">BufferedWriter</code> 类仅仅在缓冲区满或调用<code class="language-plaintext highlighter-rouge">flush()</code>方法时才将数据写到目的地。</p><p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>实际上默认<code class="language-plaintext highlighter-rouge">buffer</code>是为8192字节，无论调用<code class="language-plaintext highlighter-rouge">read()</code>还是<code class="language-plaintext highlighter-rouge">read(byte[],int,int)</code>，它都先以默认大小为8192字节去读数据，再根据实际请求的数据量返回。</p><p>缓存流是过滤流,在创建具体流时需要给出一个<code class="language-plaintext highlighter-rouge">InputStream</code> / <code class="language-plaintext highlighter-rouge">OutputStream</code> 类型的流作为前端流,并<strong>可以指明缓冲区的大小</strong>。</p><p><strong>构造方法</strong>：</p><ol><li><code class="language-plaintext highlighter-rouge">BufferedInputStream(InputStream in)</code>：使用指定的输入流创建一个新的缓冲输入流对象，默认缓冲区大小为 8192 字节（8 KB）。</li><li><code class="language-plaintext highlighter-rouge">BufferedInputStream(InputStream in, int size)</code>：使用指定的输入流创建一个新的缓冲输入流对象，并指定缓冲区大小为 <code class="language-plaintext highlighter-rouge">size</code> 字节。</li></ol><p><strong>方法：</strong></p><p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code> / <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>类提供<code class="language-plaintext highlighter-rouge">InputStream</code> /<code class="language-plaintext highlighter-rouge">OutputStream</code> 中定义的方法,例如 <code class="language-plaintext highlighter-rouge">read()</code> , <code class="language-plaintext highlighter-rouge">skip()</code>,<code class="language-plaintext highlighter-rouge">write()</code>等,并支持基于标签机制的回读。</p><p><code class="language-plaintext highlighter-rouge">BufferedReader</code>类中<strong>增加</strong>了一个有用的方法 <code class="language-plaintext highlighter-rouge">readLine()</code>,该方法读一行字符返回。行的结束标志是换行符“<code class="language-plaintext highlighter-rouge">\n</code>”或回车符“<code class="language-plaintext highlighter-rouge">\r</code>”,或回车符+换行符。</p><p><code class="language-plaintext highlighter-rouge">BufferedWriter</code>中也<strong>相应增加</strong>了一个方法<code class="language-plaintext highlighter-rouge">newLine()</code>,该方法写一个行分隔符。分隔符由系统特性<code class="language-plaintext highlighter-rouge">line.separator</code> 指定,可以是“<code class="language-plaintext highlighter-rouge">\n</code>”。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BufferedWriter</span> <span class="kd">extends</span> <span class="nc">Writer</span><span class="o">{}</span>  
</code></pre></div></div><p>它将文本写入字符输出流,缓冲各个字符,从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小,或者接受默认的大小。在大多数情况下,默认值就足够大了。</p><p>该类还提供了<code class="language-plaintext highlighter-rouge">newLine()</code>方法,并使用平台自己的行分隔符概念,此概念由系统属性 <code class="language-plaintext highlighter-rouge">line.separator</code> 定义。并非所有平台都使用新行符(‘\n’)来终止各行，因此调用此方法来终止每个输出行要<strong>优于</strong>直接写入新行符。</p><p>通常 <code class="language-plaintext highlighter-rouge">Writer</code> 将其输出立即发送到底层字符或字节流，除非要求提示输出,否则<strong>建议用<code class="language-plaintext highlighter-rouge">BufferedWriter</code>包装所有其<code class="language-plaintext highlighter-rouge">write()</code>操作</strong>可能开销很高的<code class="language-plaintext highlighter-rouge">Writer</code>(如 <code class="language-plaintext highlighter-rouge">FileWriters</code>和<code class="language-plaintext highlighter-rouge">OutputStreamWriters</code>)。例如:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"foo.out"</span><span class="o">)));</span>  
</code></pre></div></div><p>将缓冲<code class="language-plaintext highlighter-rouge">PrintWriter</code>对文件的输出。如果没有缓冲,则每次调用<code class="language-plaintext highlighter-rouge">print()</code>方法会导致将字符转换为字节,然后立即写入到文件,而这是极其低效的。</p><p><code class="language-plaintext highlighter-rouge">BufferedReader</code>同理</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">a1</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">FileReader</span> <span class="n">fr</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">reccount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"file2.txt"</span><span class="o">);</span>  
            <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="n">fr</span><span class="o">);</span>  
                <span class="nc">String</span> <span class="n">record</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>  
            <span class="k">while</span> <span class="o">((</span><span class="n">record</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  
                <span class="n">reccount</span><span class="o">++;</span>  
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Line"</span> <span class="o">+</span> <span class="n">reccount</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">record</span><span class="o">);</span>  
            <span class="o">}</span>  
            <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
            <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有文件"</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h2 id="files">Files</h2><p>同步IO是指，读写IO时代码必须等待数据返回后<strong>才</strong>继续执行后续代码，它的优点是<strong>代码编写简单</strong>，缺点是CPU执行效率低。</p><p>而异步IO是指，读写IO时仅发出请求，然后立刻执行<strong>后续代码</strong>，它的优点是CPU执行效率高，缺点是<strong>代码编写复杂</strong>。</p><p>Java标准库的包<code class="language-plaintext highlighter-rouge">java.io</code>提供了同步IO，而<code class="language-plaintext highlighter-rouge">java.nio</code>则是异步IO。上面我们讨论的<code class="language-plaintext highlighter-rouge">InputStream</code>、<code class="language-plaintext highlighter-rouge">OutputStream</code>、<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">FileOutputStream</code>、<code class="language-plaintext highlighter-rouge">FileReader</code>和<code class="language-plaintext highlighter-rouge">FileWriter</code>。</p><p>尽管<code class="language-plaintext highlighter-rouge">Files</code>工具类和<code class="language-plaintext highlighter-rouge">Path</code>对象位于Java NIO包内，但它们提供的方法通常是同步的，即方法调用会阻塞当前线程直到操作完成。要实现异步文件操作，需要使用Java NIO的异步通道（AsynchronousChannel）和异步文件I/O API。这些API提供了异步读取和写入文件的功能，可以在文件操作过程中继续执行其他任务，提高程序的并发性能。</p><p>从<strong>JDK 7</strong>开始，提供了<code class="language-plaintext highlighter-rouge">Files</code>这个工具类，能极大地方便我们读写文件。</p><p>Java标准库还提供了一个<code class="language-plaintext highlighter-rouge">Path</code>对象，它位于<code class="language-plaintext highlighter-rouge">java.nio.file</code>包。<code class="language-plaintext highlighter-rouge">Path</code>对象和<code class="language-plaintext highlighter-rouge">File</code>对象类似，但操作更加简单.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">p1</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">"project"</span><span class="o">,</span> <span class="s">"study"</span><span class="o">);</span> <span class="c1">// 构造一个Path对象</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">();</span> <span class="c1">// 转换为绝对路径</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">normalize</span><span class="o">();</span> <span class="c1">// 转换为规范路径</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p3</span><span class="o">);</span>
<span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p3</span><span class="o">.</span><span class="na">toFile</span><span class="o">();</span> <span class="c1">// 转换为File对象</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Path</span> <span class="n">p</span> <span class="o">:</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">".."</span><span class="o">).</span><span class="na">toAbsolutePath</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 可以直接遍历Path</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  "</span> <span class="o">+</span> <span class="n">p</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>如果需要对目录进行复杂的拼接、遍历等操作，使用<code class="language-plaintext highlighter-rouge">Path</code>对象更方便。</p><p>虽然<code class="language-plaintext highlighter-rouge">Files</code>是<code class="language-plaintext highlighter-rouge">java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code class="language-plaintext highlighter-rouge">byte[]</code>，可以这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">));</span>
</code></pre></div></div><p>如果是文本文件，可以把一个文件的全部内容读取为<code class="language-plaintext highlighter-rouge">String</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 默认使用UTF-8编码读取:</span>
<span class="nc">String</span> <span class="n">content1</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readString</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">));</span>
<span class="c1">// 可指定编码:</span>
<span class="nc">String</span> <span class="n">content2</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readString</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path"</span><span class="o">,</span> <span class="s">"to"</span><span class="o">,</span> <span class="s">"file.txt"</span><span class="o">),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">ISO_8859_1</span><span class="o">);</span>
<span class="c1">// 按行读取并返回每行内容:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readAllLines</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">));</span>
</code></pre></div></div><p>写入文件也非常方便：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写入二进制文件:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">),</span> <span class="n">data</span><span class="o">);</span>
<span class="c1">// 写入文本并指定编码:</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">),</span> <span class="s">"文本内容..."</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">ISO_8859_1</span><span class="o">);</span>
<span class="c1">// 按行写入文本:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">),</span> <span class="n">lines</span><span class="o">);</span>
</code></pre></div></div><p>此外，<code class="language-plaintext highlighter-rouge">Files</code>工具类还有<code class="language-plaintext highlighter-rouge">copy()</code>、<code class="language-plaintext highlighter-rouge">delete()</code>、<code class="language-plaintext highlighter-rouge">exists()</code>、<code class="language-plaintext highlighter-rouge">move()</code>等快捷方法操作文件和目录。<br /> 最后需要特别注意的是，<code class="language-plaintext highlighter-rouge">Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/03/16/IO/" target="_blank">https://acteds.github.io/2021/03/16/IO/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1718259049', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
