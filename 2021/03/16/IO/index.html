<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>I/O &mdash; 个人博客</title><link rel="stylesheet" href="https://acteds.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://acteds.github.io/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="https://acteds.github.io/2021/03/16/IO/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="https://acteds.github.io/feed.xml"><link rel="shortcut icon" href="https://acteds.github.io/favicon.ico"><meta property="og:title" content="I/O"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言  java的I/O笔记。I/O  文件是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。   java.io包中最重要的就是五个类和一个接口：  File OutputStream InputStream Reader Writer  serializable 数据的序列化接口，可以按照流式序列化保存对象。 按照不同的方式,将流分为不同的类型按数据流动方向： 输入流：只能从中读取字节数据,而不能向其写出数据 输出流：只能向其写入字节数据,而不能从中读取数据 输入流和输出流分别通过抽象类InputStream和 OutputStream来实现"><meta name="og:description" content="引言  java的I/O笔记。I/O  文件是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。   java.io包中最重要的就是五个类和一个接口：  File OutputStream InputStream Reader Writer  serializable 数据的序列化接口，可以按照流式序列化保存对象。 按照不同的方式,将流分为不同的类型按数据流动方向： 输入流：只能从中读取字节数据,而不能向其写出数据 输出流：只能向其写入字节数据,而不能从中读取数据 输入流和输出流分别通过抽象类InputStream和 OutputStream来实现"><meta property="og:url" content="https://acteds.github.io/2021/03/16/IO/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-03-16"> <script src="https://acteds.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://acteds.github.io/assets/js/jquery-ui.js"></script> <script src="https://acteds.github.io/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://acteds.github.io/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://acteds.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://acteds.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://acteds.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://acteds.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="I/O"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">I/O</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/03/16 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://acteds.github.io/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 40225 字，约 115 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>  java的I/O笔记。</p><h1 id="io">I/O</h1><p>  <strong>文件</strong>是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。   <code class="language-plaintext highlighter-rouge">java.io</code>包中最重要的就是五个类和一个接口：<br />   <code class="language-plaintext highlighter-rouge">File OutputStream InputStream Reader Writer</code><br />   <code class="language-plaintext highlighter-rouge">serializable</code> 数据的序列化接口，可以按照流式序列化保存对象。<br /> <strong>按照不同的方式,将流分为不同的类型按数据流动方向</strong>：</p><ul><li>输入流：只能从中读取字节数据,而不能向其写出数据</li><li>输出流：只能向其写入字节数据,而不能从中读取数据</li><li>输入流和输出流分别通过<strong>抽象类<code class="language-plaintext highlighter-rouge">InputStream</code>和 <code class="language-plaintext highlighter-rouge">OutputStream</code></strong>来实现</li></ul><p>  <strong>按照流所处理的数据类型</strong>：</p><ul><li>字节流：用于处理<strong>字节</strong>数据</li><li>字节流是按字节读/写二进制数据字节流有两个基本的类：<ul><li><code class="language-plaintext highlighter-rouge">InputStream</code>类<code class="language-plaintext highlighter-rouge">OutputStream</code>类</li><li><code class="language-plaintext highlighter-rouge">InputStream</code>类用于处理字节输入流,<code class="language-plaintext highlighter-rouge">OutputStream</code>类用于处理字节输出流。</li></ul></li><li>字符流：用于处理 Unicode<strong>字符</strong>数据</li><li>字符流的输入/输出数据是字符码即Unicode字符。<ul><li>字符流有两个基本类：<code class="language-plaintext highlighter-rouge">Reader</code>类和 <code class="language-plaintext highlighter-rouge">Writer</code>类。</li><li><code class="language-plaintext highlighter-rouge">Reader</code>类用于处理字符输入流,<code class="language-plaintext highlighter-rouge">Writer</code>类用于处理字符输出流</li></ul></li></ul><p>  <strong>按照流所处理的源</strong>：</p><ul><li>节点流(低级流)：向一个特定的IO设备读/写数据的流。</li><li>处理流(高级流)：对已存在的流进行连接和封装的流。处理流是“处理流的流”,它用来处理其他的流。</li></ul><p>  <strong>说明</strong><br />   所有从 <code class="language-plaintext highlighter-rouge">InputStream</code>或 <code class="language-plaintext highlighter-rouge">Reader</code>派生的类都有一个基本的<code class="language-plaintext highlighter-rouge">read()</code>方法,用读取的字节或者读取字节数组;<br />   所有从 <code class="language-plaintext highlighter-rouge">OutputStream</code>或 <code class="language-plaintext highlighter-rouge">Writer</code>派生的类都有一个基本的 <code class="language-plaintext highlighter-rouge">write()</code>方法,用于写入单一的字节或者整个字节数组。<br />   但在实际应用中我们一般很少使用单一的流类来产生输入输出流,而是使用这两个方法绐其他的流类提供数锯,也就是说,通过多个流对象的连接和封装使用实际的流。<br />   如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code class="language-plaintext highlighter-rouge">char</code>来读写显然更方便，这种流称为字符流。<br />   Java提供了<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>表示字符流，字符流传输的最小数据单位是<code class="language-plaintext highlighter-rouge">char</code>。<br />   例如，我们把<code class="language-plaintext highlighter-rouge">char[]</code>数组<code class="language-plaintext highlighter-rouge">Hi你好</code>这4个字符用<code class="language-plaintext highlighter-rouge">Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符<code class="language-plaintext highlighter-rouge">H</code>和<code class="language-plaintext highlighter-rouge">i</code>各占一个字节，中文字符<code class="language-plaintext highlighter-rouge">你好</code>各占3个字节：</p><pre><code class="language-txt">0x48
0x69
0xe4bda0
0xe5a5bd
</code></pre><p>  反过来，我们用<code class="language-plaintext highlighter-rouge">Reader</code>读取以UTF-8编码的这8个字节，会从<code class="language-plaintext highlighter-rouge">Reader</code>中得到<code class="language-plaintext highlighter-rouge">Hi你好</code>这4个字符。<br />   因此，<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>本质上是一个能自动编解码的<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>。<br />   使用<code class="language-plaintext highlighter-rouge">Reader</code>，数据源虽然是字节，但我们读入的数据都是<code class="language-plaintext highlighter-rouge">char</code>类型的字符，原因是<code class="language-plaintext highlighter-rouge">Reader</code>内部把读入的<code class="language-plaintext highlighter-rouge">byte</code>做了解码，转换成了<code class="language-plaintext highlighter-rouge">char</code>。使用<code class="language-plaintext highlighter-rouge">InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code class="language-plaintext highlighter-rouge">byte[]</code>数组，但是我们可以自己把二进制<code class="language-plaintext highlighter-rouge">byte[]</code>数组按照某种编码转换为字符串。究竟使用<code class="language-plaintext highlighter-rouge">Reader</code>还是<code class="language-plaintext highlighter-rouge">InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用<code class="language-plaintext highlighter-rouge">InputStream</code>，如果数据源是文本，使用<code class="language-plaintext highlighter-rouge">Reader</code>更方便一些。<code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>是类似的。<br /> <strong>同步和异步</strong>   同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。<br />   而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。<br />   Java标准库的包<code class="language-plaintext highlighter-rouge">java.io</code>提供了同步IO，而<code class="language-plaintext highlighter-rouge">java.nio</code>则是异步IO。上面我们讨论的<code class="language-plaintext highlighter-rouge">InputStream</code>、<code class="language-plaintext highlighter-rouge">OutputStream</code>、<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">FileOutputStream</code>、<code class="language-plaintext highlighter-rouge">FileReader</code>和<code class="language-plaintext highlighter-rouge">FileWriter</code>。</p><h2 id="file">File</h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>File(File parent, String child)</td><td>根据 <code class="language-plaintext highlighter-rouge">parent</code> 抽象路径名和 <code class="language-plaintext highlighter-rouge">child</code> 路径名字符串创建一个新 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr><tr><td>File(String pathname)</td><td>通过将给定路径名字符串转换为抽象路径名来创建一个新 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr><tr><td>File(String parent, String child)</td><td>根据 <code class="language-plaintext highlighter-rouge">parent</code> 路径名字符串和 <code class="language-plaintext highlighter-rouge">child</code> 路径名字符串创建一个新 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr><tr><td>File(URI uri)</td><td>通过将给定的 <code class="language-plaintext highlighter-rouge">file: URI</code> 转换为一个抽象路径名来创建一个新的 <code class="language-plaintext highlighter-rouge">File</code> 实例。</td></tr></tbody></table><p>  绝对路径：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">file</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:"</span><span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span><span class="o">+</span><span class="s">"a.txt"</span><span class="o">);</span>  
<span class="nc">File</span> <span class="n">file2</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:\\a.txt"</span><span class="o">);</span>  
<span class="nc">File</span> <span class="n">file3</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"D:"</span><span class="o">,</span><span class="s">"a.txt"</span><span class="o">);</span>  
<span class="nc">File</span> <span class="n">file4</span><span class="o">=</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">file</span><span class="o">,</span><span class="s">"a.txt"</span><span class="o">);</span>
</code></pre></div></div><p>  构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，<br />   注意Windows平台使用<code class="language-plaintext highlighter-rouge">\</code>作为路径分隔符，在Java字符串中需要用<code class="language-plaintext highlighter-rouge">\\</code>表示一个<code class="language-plaintext highlighter-rouge">\</code>。Linux平台使用<code class="language-plaintext highlighter-rouge">/</code>作为路径分隔符：<code class="language-plaintext highlighter-rouge">File f = new File("/usr/bin/javac");</code><br />   传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设当前目录是C:\Docs</span>
<span class="nc">File</span> <span class="n">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"sub\\javac"</span><span class="o">);</span> <span class="c1">// 绝对路径是C:\Docs\sub\javac</span>
<span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">".\\sub\\javac"</span><span class="o">);</span> <span class="c1">// 绝对路径是C:\Docs\sub\javac</span>
<span class="nc">File</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"..\\sub\\javac"</span><span class="o">);</span> <span class="c1">// 绝对路径是C:\sub\javac</span>
</code></pre></div></div><p>  可以用<code class="language-plaintext highlighter-rouge">.</code>表示当前目录，<code class="language-plaintext highlighter-rouge">..</code>表示上级目录。<br />   File对象有3种形式表示的路径，一种是<code class="language-plaintext highlighter-rouge">getPath()</code>，返回构造方法传入的路径，一种是<code class="language-plaintext highlighter-rouge">getAbsolutePath()</code>，返回绝对路径，一种是<code class="language-plaintext highlighter-rouge">getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。<br />   绝对路径可以表示成<code class="language-plaintext highlighter-rouge">C:\Windows\System32\..\notepad.exe</code>，而规范路径就是把<code class="language-plaintext highlighter-rouge">.</code>和<code class="language-plaintext highlighter-rouge">..</code>转换成标准的绝对路径后的路径：<code class="language-plaintext highlighter-rouge">C:\Windows\notepad.exe</code>。<br />   因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">File</span><span class="o">.</span><span class="na">separator</span><span class="o">);</span> <span class="c1">// 根据当前平台打印"\"或"/"</span>
</code></pre></div></div><p><strong>文件和目录</strong>   <code class="language-plaintext highlighter-rouge">File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个<code class="language-plaintext highlighter-rouge">File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个<code class="language-plaintext highlighter-rouge">File</code>对象，并<strong>不会</strong>导致任何磁盘操作。<strong>只有</strong>当我们调用<code class="language-plaintext highlighter-rouge">File</code>对象的某些方法的时候，才真正进行磁盘操作。<br />   例如，调用<code class="language-plaintext highlighter-rouge">isFile()</code>，判断该<code class="language-plaintext highlighter-rouge">File</code>对象是否是一个已存在的文件，调用<code class="language-plaintext highlighter-rouge">isDirectory()</code>，判断该<code class="language-plaintext highlighter-rouge">File</code>对象是否是一个已存在的目录。<br />   用<code class="language-plaintext highlighter-rouge">File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p><ul><li><code class="language-plaintext highlighter-rouge">boolean canRead()</code>：是否可读；</li><li><code class="language-plaintext highlighter-rouge">boolean canWrite()</code>：是否可写；</li><li><code class="language-plaintext highlighter-rouge">boolean canExecute()</code>：是否可执行；</li><li><code class="language-plaintext highlighter-rouge">long length()</code>：文件字节大小。</li></ul><p>  对目录而言，是否可执行表示能否列出它包含的文件和子目录。<br />   <strong>创建和删除文件</strong><br />   当File对象表示一个文件时，可以通过<code class="language-plaintext highlighter-rouge">createNewFile()</code>创建一个新文件，用<code class="language-plaintext highlighter-rouge">delete()</code>删除该文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"/path/to/file"</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">createNewFile</span><span class="o">())</span> <span class="o">{</span>
    <span class="c1">// 文件创建成功:</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">delete</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// 删除文件成功:</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  有些时候，程序需要读写一些临时文件，File对象提供了<code class="language-plaintext highlighter-rouge">createTempFile()</code>来创建一个临时文件，以及<code class="language-plaintext highlighter-rouge">deleteOnExit()</code>在JVM退出时自动删除该文件。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="nc">File</span><span class="o">.</span><span class="na">createTempFile</span><span class="o">(</span><span class="s">"tmp-"</span><span class="o">,</span> <span class="s">".txt"</span><span class="o">);</span> <span class="c1">// 提供临时文件的前缀和后缀</span>
<span class="n">f</span><span class="o">.</span><span class="na">deleteOnExit</span><span class="o">();</span> <span class="c1">// JVM退出时自动删除</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">isFile</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">getAbsolutePath</span><span class="o">());</span>
</code></pre></div></div><p>  <strong>遍历文件和目录</strong><br />   当File对象表示一个目录时，可以使用<code class="language-plaintext highlighter-rouge">list()</code>和<code class="language-plaintext highlighter-rouge">listFiles()</code>列出目录下的文件和子目录名。<code class="language-plaintext highlighter-rouge">listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"C:\\Windows"</span><span class="o">);</span>
<span class="nc">File</span><span class="o">[]</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">listFiles</span><span class="o">(</span><span class="k">new</span> <span class="nc">FilenameFilter</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// 仅列出.exe文件</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">accept</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".exe"</span><span class="o">);</span> <span class="c1">// 返回true表示接受该文件</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="k">if</span> <span class="o">(</span><span class="n">fs2</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">temp</span> <span class="o">:</span> <span class="n">fs2</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  接口只有一个方法，因此匿名类可以写为lambda形式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">File</span><span class="o">[]</span> <span class="n">fs2</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">listFiles</span><span class="o">((</span><span class="n">dir</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".exe"</span><span class="o">));</span>
</code></pre></div></div><p>  和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p><ul><li><code class="language-plaintext highlighter-rouge">boolean mkdir()</code>：创建当前File对象表示的目录；</li><li><code class="language-plaintext highlighter-rouge">boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li><li><code class="language-plaintext highlighter-rouge">boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li></ul><p>  <strong>详细方法</strong><br /> | 返回类型 | 方法 | 说明 | | ————— | ———————————————————— | ———————————————————— | | boolean | canExecute() | 测试应用程序是否可以执行此抽象路径名表示的文件。 | | boolean | canRead() | 测试应用程序是否可以读取此抽象路径名表示的文件。 | | boolean | canWrite() | 测试应用程序是否可以修改此抽象路径名表示的文件。 | | int | compareTo(File pathname) | 按字母顺序比较两个抽象路径名。 | | boolean | createNewFile() | 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 | | static File | createTempFile(String prefix, String suffix) | 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。 | | static File | createTempFile(String prefix, String suffix, File directory) | 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。 | | boolean | delete() | 删除此抽象路径名表示的文件或目录。 | | void | deleteOnExit() | 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。 | | boolean | equals(Object obj) | 测试此抽象路径名与给定对象是否相等。 | | boolean | <strong>exists()</strong> | 测试此抽象路径名表示的文件或目录是否存在。 | | File | getAbsoluteFile() | 返回此抽象路径名的绝对路径名形式。 | | String | <strong>getAbsolutePath()</strong> | 返回此抽象路径名的绝对路径名字符串。 | | File | getCanonicalFile() | 返回此抽象路径名的规范形式。 | | String | <strong>getCanonicalPath()</strong> | 返回此抽象路径名的规范路径名字符串。 | | long | getFreeSpace() | 返回此抽象路径名指定的分区中未分配的字节数。 | | String | <strong>getName()</strong> | 返回由此抽象路径名表示的文件或目录的名称。 | | String | <strong>getParent()</strong> | 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。 | | File | getParentFile() | 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。 | | String | <strong>getPath()</strong> | 将此抽象路径名转换为一个路径名字符串，返回构造方法传入的路径。 | | long | getTotalSpace() | 返回此抽象路径名指定的分区大小。 | | long | getUsableSpace() | 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。 | | int | hashCode() | 计算此抽象路径名的哈希码。 | | boolean | isAbsolute() | 测试此抽象路径名是否为绝对路径名。 | | boolean | <strong>isDirectory()</strong> | 测试此抽象路径名表示的文件是否是一个目录。 | | boolean | <strong>isFile()</strong> | 测试此抽象路径名表示的文件是否是一个标准文件。 | | boolean | isHidden() | 测试此抽象路径名指定的文件是否是一个隐藏文件。 | | long | lastModified() | 返回此抽象路径名表示的文件最后一次被修改的时间。 | | long | <strong>length()</strong> | 返回由此抽象路径名表示的文件的长度。 | | String[] | list() | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 | | String[] | list(FilenameFilter filter) | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。 | | File[] | listFiles() | 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 | | File[] | listFiles(FileFilter filter) | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 | | File[] | listFiles(FilenameFilter filter) | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 | | static File[] | listRoots() | 列出可用的文件系统根。 | | boolean | <strong>mkdir()</strong> | 创建此抽象路径名指定的目录。 | | boolean | <strong>mkdirs()</strong> | 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。 | | boolean | <strong>renameTo(File dest)</strong> | 重新命名此抽象路径名表示的文件。 | | boolean | setExecutable(boolean executable) | 设置此抽象路径名所有者执行权限的一个便捷方法。 | | boolean | setExecutable(boolean executable, boolean ownerOnly) | 设置此抽象路径名的所有者或所有用户的执行权限。 | | boolean | setLastModified(long time) | 设置此抽象路径名指定的文件或目录的最后一次修改时间。 | | boolean | setReadable(boolean readable) | 设置此抽象路径名所有者读权限的一个便捷方法。 | | boolean | setReadable(boolean readable, boolean ownerOnly) | 设置此抽象路径名的所有者或所有用户的读权限。 | | boolean | setReadOnly() | 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。 | | boolean | setWritable(boolean writable) | 设置此抽象路径名所有者写权限的一个便捷方法。 | | boolean | setWritable(boolean writable, boolean ownerOnly) | 设置此抽象路径名的所有者或所有用户的写权限。 | | String | toString() | 返回此抽象路径名的路径名字符串。 | | URI | toURI() | 构造一个表示此抽象路径名的 file: URI。 | | URL | toURL() | <strong>已过时。</strong> <em>此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。</em> |</p><h2 id="字节流">字节流</h2><p>  字节流是按字节读/写二进制数据字节流有两个基本的类：<code class="language-plaintext highlighter-rouge">InputStream</code>类<code class="language-plaintext highlighter-rouge">OutputStream</code>类<br />   <code class="language-plaintext highlighter-rouge">InputStream</code>类用于处理<strong>字节输入流</strong>,<code class="language-plaintext highlighter-rouge">OutputStream</code>类用于处理<strong>字节输出流</strong>。它们都是<strong>抽象类</strong>,本身<strong>不能直接用来创建对象</strong>。所有字节处理流都由<code class="language-plaintext highlighter-rouge">InputStream</code>/<code class="language-plaintext highlighter-rouge">OutputStream</code>派生而来</p><h3 id="inputstream">InputStream</h3><p>  <strong>InputStream常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>int read()</strong></td><td>读取一个字节，并返回字节表示的<code class="language-plaintext highlighter-rouge">int</code>值（0~255），如果已读到末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>表示不能继续读取了。</td></tr><tr><td><strong>int read(byte[] buffer)</strong></td><td>将数据读入一个字节数组,同时返回读取的字节数，若没有更多数据了则返回<code class="language-plaintext highlighter-rouge">-1</code>。</td></tr><tr><td><strong>int read(byte[] buffer,int offset,int length)</strong></td><td>将数据读入一个字节数组,放到<strong>数组</strong>的<code class="language-plaintext highlighter-rouge">offset</code>指定的位置开始,并用<code class="language-plaintext highlighter-rouge">length</code>来指定读取的最大字节数，若没有更多数据了则返回<code class="language-plaintext highlighter-rouge">-1</code>。</td></tr><tr><td>void close()</td><td>关闭流。</td></tr><tr><td>int available()</td><td>返回可以从中读取的字节数。</td></tr><tr><td>long skip(long n)</td><td>在输入流中跳过n个字节,将实际跳过的字节数返回。</td></tr><tr><td>boolean markSupported()</td><td>判断流是否支持标记功能。</td></tr><tr><td>void mark(int readlimit)</td><td>在支持标记的输入流的当前位置设置一个标记。</td></tr><tr><td>void reset()</td><td>返回到流的上一个标记。注意必须流支持标记功能。</td></tr></tbody></table><p>  <strong>InputStream相关类</strong><br />   <strong>低级 <code class="language-plaintext highlighter-rouge">InputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">InputStream</code>：抽象类，所有输入流的基类。</li><li><code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>：从字节数组读取数据的输入流。</li><li><code class="language-plaintext highlighter-rouge">PipedInputStream</code>：与<code class="language-plaintext highlighter-rouge">PipedOutputStream</code>配合使用，用于线程间通信。</li><li><code class="language-plaintext highlighter-rouge">FileInputStream</code>：从文件中读取数据的输入流。</li></ul><p>  <strong>高级 <code class="language-plaintext highlighter-rouge">InputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">DataInputStream</code>：允许应用程序以适当方式从底层输入流中读取基本 Java 数据类型。</li><li><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>：带有缓冲区的输入流，提高了从文件读取数据的性能。</li></ul><h3 id="fileinputstream">FileInputStream</h3><p>  <code class="language-plaintext highlighter-rouge">FileInputStream</code>是<code class="language-plaintext highlighter-rouge">InputStream</code>的一个子类。顾名思义，<code class="language-plaintext highlighter-rouge">FileInputStream</code>就是从文件流中读取数据。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">);</span><span class="c1">// 读取文件</span>
<span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
<span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>  <strong>缓冲</strong><br />   在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code class="language-plaintext highlighter-rouge">InputStream</code>提供了两个重载方法来支持读取多个字节：</p><ul><li><code class="language-plaintext highlighter-rouge">int read(byte[] b)</code>：读取若干字节并填充到<code class="language-plaintext highlighter-rouge">byte[]</code>数组，返回读取的字节数</li><li><code class="language-plaintext highlighter-rouge">int read(byte[] b, int off, int len)</code>：指定<code class="language-plaintext highlighter-rouge">byte[]</code>数组的偏移量和最大填充数</li></ul><p>  利用上述方法一次读取多个字节时，需要先定义一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组作为缓冲区，<code class="language-plaintext highlighter-rouge">read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code class="language-plaintext highlighter-rouge">read()</code>方法的返回实际读取了多少个字节。如果返回<code class="language-plaintext highlighter-rouge">-1</code>，表示没有更多的数据了。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">);</span><span class="c1">// 读取文件</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
<span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span><span class="c1">// 显示</span>
<span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>  在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。<br />   <code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>都是通过<code class="language-plaintext highlighter-rouge">close()</code>方法来关闭流。关闭流就会释放对应的底层资源。<br />   还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成<code class="language-plaintext highlighter-rouge">IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理<code class="language-plaintext highlighter-rouge">IOException</code>。<br />   因此，我们需要用<code class="language-plaintext highlighter-rouge">try ... finally</code>来保证<code class="language-plaintext highlighter-rouge">InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">);</span><span class="c1">// 读取文件</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span><span class="c1">// 显示</span>
    
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有文件"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">fis</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  用<code class="language-plaintext highlighter-rouge">try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用<strong>Java 7</strong>引入的新的<code class="language-plaintext highlighter-rouge">try(resource)</code>的语法，只需要编写<code class="language-plaintext highlighter-rouge">try</code>语句，让编译器自动为我们关闭资源。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"./log/output.log"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 读取文件</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">256</span><span class="o">];</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span><span class="c1">// 显示</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有文件"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  实际上，编译器并不会特别地为<code class="language-plaintext highlighter-rouge">InputStream</code>加上自动关闭。编译器只看<code class="language-plaintext highlighter-rouge">try(resource = ...)</code>中的对象是否实现了<code class="language-plaintext highlighter-rouge">java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code class="language-plaintext highlighter-rouge">finally</code>语句并调用<code class="language-plaintext highlighter-rouge">close()</code>方法。<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>都实现了这个接口，因此，都可以用在<code class="language-plaintext highlighter-rouge">try(resource)</code>中。<br />   在调用<code class="language-plaintext highlighter-rouge">InputStream</code>的<code class="language-plaintext highlighter-rouge">read()</code>方法读取数据时，我们说<code class="language-plaintext highlighter-rouge">read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">();</span> <span class="c1">// 必须等待read()方法返回才能执行下一行代码</span>
<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
</code></pre></div></div><p>  执行到第二行代码时，必须等<code class="language-plaintext highlighter-rouge">read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code class="language-plaintext highlighter-rouge">read()</code>方法调用到底要花费多长时间。</p><h3 id="bytearrayinputstream">ByteArrayInputStream</h3><p>  <code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>可以在内存中<strong>模拟</strong>一个<code class="language-plaintext highlighter-rouge">InputStream</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">data</span><span class="o">))</span> <span class="o">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
	<span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>实际上是把一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组在内存中变成一个<code class="language-plaintext highlighter-rouge">InputStream</code>，虽然实际应用不多，但<strong>测试</strong>的时候，可以用它来构造一个<code class="language-plaintext highlighter-rouge">InputStream</code>。</p><h3 id="outputstream">OutputStream</h3><p>  <strong>OutputStream常用方法</strong><br />   Writer常用方法(写入方法)</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>void write(int b)</strong></td><td>将参数<code class="language-plaintext highlighter-rouge">b</code>的低8位组成字节写入到流中。</td></tr><tr><td><strong>void write(byte[] buffer)</strong></td><td>将字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中的字节写入到流中。</td></tr><tr><td><strong>void write(byte[] buffer,int offset, int length)</strong></td><td>将字节数组<code class="language-plaintext highlighter-rouge">buffer</code>中从<code class="language-plaintext highlighter-rouge">offset</code>开始的<code class="language-plaintext highlighter-rouge">length</code>字节写入到流中。</td></tr><tr><td>void close()</td><td>关闭流</td></tr><tr><td>void flush()</td><td>刷空输岀流,并输岀所有被缓存的字节。</td></tr></tbody></table><p>  <strong>OutputStream相关类</strong><br />   <strong>低级 <code class="language-plaintext highlighter-rouge">OutputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">OutputStream</code>：抽象类，所有输出流的基类。</li><li><code class="language-plaintext highlighter-rouge">FileOutputStream</code>：向文件写入数据的输出流。</li><li><code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>：将数据写入字节数组的输出流。</li><li><code class="language-plaintext highlighter-rouge">PipedOutputStream</code>：与<code class="language-plaintext highlighter-rouge">PipedInputStream</code>配合使用，用于线程间通信。</li></ul><p>  <strong>高级 <code class="language-plaintext highlighter-rouge">OutputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">DataOutputStream</code>：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。</li><li><code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>：带有缓冲区的输出流，提高了写入文件的性能。</li></ul><p>  <strong>其他常见 <code class="language-plaintext highlighter-rouge">OutputStream</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>：将对象写入流中的输出流。</li><li><code class="language-plaintext highlighter-rouge">FilterOutputStream</code>：添加功能的抽象输出流。</li><li><code class="language-plaintext highlighter-rouge">PrintStream</code>：用于写入各种数据值表示形式的输出流。</li></ul><p>  这个抽象类定义的一个最重要的方法就是<code class="language-plaintext highlighter-rouge">void write(int b)</code>，这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code class="language-plaintext highlighter-rouge">int</code>参数，但只会写入一个字节，即只写入<code class="language-plaintext highlighter-rouge">int</code>最低8位表示字节的部分（相当于<code class="language-plaintext highlighter-rouge">b &amp; 0xff</code>）。和<code class="language-plaintext highlighter-rouge">InputStream</code>类似，<code class="language-plaintext highlighter-rouge">OutputStream</code>也提供了<code class="language-plaintext highlighter-rouge">close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code class="language-plaintext highlighter-rouge">OutputStream</code>还提供了一个<code class="language-plaintext highlighter-rouge">flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。<br />   为什么要有<code class="language-plaintext highlighter-rouge">flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code class="language-plaintext highlighter-rouge">OutputStream</code>有个<code class="language-plaintext highlighter-rouge">flush()</code>方法，能强制把缓冲区内容输出。<br />   通常情况下，我们不需要调用这个<code class="language-plaintext highlighter-rouge">flush()</code>方法，因为缓冲区写满了<code class="language-plaintext highlighter-rouge">OutputStream</code>会自动调用它，并且，在调用<code class="language-plaintext highlighter-rouge">close()</code>方法关闭<code class="language-plaintext highlighter-rouge">OutputStream</code>之前，也会自动调用<code class="language-plaintext highlighter-rouge">flush()</code>方法。<br />   但是，在某些情况下，我们必须手动调用<code class="language-plaintext highlighter-rouge">flush()</code>方法。举个栗子：<br />   小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code class="language-plaintext highlighter-rouge">OutputStream</code>的<code class="language-plaintext highlighter-rouge">write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？<br />   原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。<br />   解决办法就是每输入一句话后，立刻调用<code class="language-plaintext highlighter-rouge">flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。<br />   实际上，<code class="language-plaintext highlighter-rouge">InputStream</code>也有缓冲区。例如，从<code class="language-plaintext highlighter-rouge">FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code class="language-plaintext highlighter-rouge">int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code class="language-plaintext highlighter-rouge">read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p><h3 id="fileoutputstream">FileOutputStream</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"out/readme.txt"</span><span class="o">);</span>
<span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">72</span><span class="o">);</span> <span class="c1">// H</span>
<span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span> <span class="c1">// Hello</span>
<span class="n">output</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>  和<code class="language-plaintext highlighter-rouge">InputStream</code>一样，<code class="language-plaintext highlighter-rouge">OutputStream</code>的<code class="language-plaintext highlighter-rouge">write()</code>方法也是阻塞的。</p><h3 id="bytearrayoutputstream">ByteArrayOutputStream</h3><p>  <code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>可以在内存中模拟一个<code class="language-plaintext highlighter-rouge">OutputStream</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">ByteArrayOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello "</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
    <span class="n">output</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>实际上是把一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组在内存中变成一个<code class="language-plaintext highlighter-rouge">OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code class="language-plaintext highlighter-rouge">OutputStream</code>。</p><h3 id="printstream">PrintStream</h3><p>  <code class="language-plaintext highlighter-rouge">PrintStream</code>是一种<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>，它在<code class="language-plaintext highlighter-rouge">OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p><ul><li>写入<code class="language-plaintext highlighter-rouge">int</code>：<code class="language-plaintext highlighter-rouge">print(int)</code></li><li>写入<code class="language-plaintext highlighter-rouge">boolean</code>：<code class="language-plaintext highlighter-rouge">print(boolean)</code></li><li>写入<code class="language-plaintext highlighter-rouge">String</code>：<code class="language-plaintext highlighter-rouge">print(String)</code></li><li>写入<code class="language-plaintext highlighter-rouge">Object</code>：<code class="language-plaintext highlighter-rouge">print(Object)</code>，实际上相当于<code class="language-plaintext highlighter-rouge">print(object.toString())</code></li><li>…</li></ul><p>  以及对应的一组<code class="language-plaintext highlighter-rouge">println()</code>方法，它会自动加上换行符。<br />   我们经常使用的<code class="language-plaintext highlighter-rouge">System.out.println()</code>实际上就是使用<code class="language-plaintext highlighter-rouge">PrintStream</code>打印各种数据。其中，<code class="language-plaintext highlighter-rouge">System.out</code>是系统默认提供的<code class="language-plaintext highlighter-rouge">PrintStream</code>，表示标准输出：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span> <span class="c1">// 输出12345</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">());</span> <span class="c1">// 输出类似java.lang.Object@3c7a835a</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span> <span class="c1">// 输出Hello并换行</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">System.err</code>是系统默认提供的标准错误输出。<br />   <code class="language-plaintext highlighter-rouge">PrintStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>相比，除了添加了一组<code class="language-plaintext highlighter-rouge">print()</code>/<code class="language-plaintext highlighter-rouge">println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出<code class="language-plaintext highlighter-rouge">IOException</code>，这样我们在编写代码的时候，就不必捕获<code class="language-plaintext highlighter-rouge">IOException</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">PrintStream</span> <span class="n">out</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"file1.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span><span class="c1">//建立一个文件输出流,true追加</span>
    <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span><span class="c1">//建立一个PrintStream对象,它将作为标准输出流</span>
    <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是一个测试串FileOutputStream"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">out</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fos</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  修改简化后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//建立一个文件输出流,true追加,建立一个PrintStream对象,它将作为标准输出流</span>
<span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"file1.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="nc">PrintStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是一个测试串FileOutputStream"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  同时操作多个<code class="language-plaintext highlighter-rouge">AutoCloseable</code>资源时，可以在<code class="language-plaintext highlighter-rouge">try(resource) { ... }</code>语句中可以同时写出多个资源，用<code class="language-plaintext highlighter-rouge">;</code>隔开。例如，同时读写两个文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 读取input.txt，写入output.txt:</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"input.txt"</span><span class="o">);</span>
     <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"output.txt"</span><span class="o">))</span>
<span class="o">{</span>
    <span class="n">input</span><span class="o">.</span><span class="na">transferTo</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">transferTo</code>方法是<code class="language-plaintext highlighter-rouge">InputStream</code>的一个扩展方法，用于将输入流的数据直接传输到指定的输出流中，从而避免了显式的循环读取和写入操作。在这个例子中，<code class="language-plaintext highlighter-rouge">transferTo</code>方法将<code class="language-plaintext highlighter-rouge">input.txt</code>文件的内容直接传输到<code class="language-plaintext highlighter-rouge">output.txt</code>文件中，效率比逐字节或逐块地读取和写入要高。这种方式可以提高文件传输的效率，特别是当处理大文件时。</p><h3 id="filter模式">Filter模式</h3><p>  Java的IO标准库提供的<code class="language-plaintext highlighter-rouge">InputStream</code>根据来源可以包括：</p><ul><li><code class="language-plaintext highlighter-rouge">FileInputStream</code>：从文件读取数据，是最终数据源；</li><li><code class="language-plaintext highlighter-rouge">ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li><li><code class="language-plaintext highlighter-rouge">Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li><li>…</li></ul><p>  如果我们要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加缓冲功能，则可以从<code class="language-plaintext highlighter-rouge">FileInputStream</code>派生一个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedFileInputStream</span> <span class="kd">extends</span> <span class="nc">FileInputStream</span>
</code></pre></div></div><p>  如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加计算签名的功能，类似的，也可以从<code class="language-plaintext highlighter-rouge">FileInputStream</code>派生一个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DigestFileInputStream</span> <span class="kd">extends</span> <span class="nc">FileInputStream</span>
</code></pre></div></div><p>  如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加加密/解密功能，还是可以从<code class="language-plaintext highlighter-rouge">FileInputStream</code>派生一个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CipherFileInputStream</span> <span class="kd">extends</span> <span class="nc">FileInputStream</span>
</code></pre></div></div><p>  如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生<code class="language-plaintext highlighter-rouge">BufferedDigestFileInputStream</code>。如果要给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加缓冲和加解密的功能，则需要派生<code class="language-plaintext highlighter-rouge">BufferedCipherFileInputStream</code>。<br />   我们发现，给<code class="language-plaintext highlighter-rouge">FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：</p><pre><code class="language-ascii">                          ┌─────────────────┐
                          │ FileInputStream │
                          └─────────────────┘
                                   ▲
             ┌───────────┬─────────┼─────────┬───────────┐
             │           │         │         │           │
┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐
│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│
└───────────────────────┘│└─────────────────┘│└─────────────────────┘
                         │                   │
    ┌─────────────────────────────┐ ┌─────────────────────────────┐
    │BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│
    └─────────────────────────────┘ └─────────────────────────────┘
</code></pre><p>  这还只是针对<code class="language-plaintext highlighter-rouge">FileInputStream</code>设计，如果针对另一种<code class="language-plaintext highlighter-rouge">InputStream</code>设计，很快会出现子类爆炸的情况。<br />   因此，直接使用继承，为各种<code class="language-plaintext highlighter-rouge">InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。<br />   为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code class="language-plaintext highlighter-rouge">InputStream</code>分为两大类：<br />   一类是直接提供数据的基础<code class="language-plaintext highlighter-rouge">InputStream</code>，例如：</p><ul><li>FileInputStream</li><li>ByteArrayInputStream</li><li>ServletInputStream</li><li>…</li></ul><p>  一类是提供额外附加功能的<code class="language-plaintext highlighter-rouge">InputStream</code>，例如：</p><ul><li>BufferedInputStream</li><li>DigestInputStream</li><li>CipherInputStream</li><li>…</li></ul><p>  当我们需要给一个“基础”<code class="language-plaintext highlighter-rouge">InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code class="language-plaintext highlighter-rouge">InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code class="language-plaintext highlighter-rouge">FileInputStream</code>，数据来源自文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">);</span>
</code></pre></div></div><p>  紧接着，我们希望<code class="language-plaintext highlighter-rouge">FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>包装这个<code class="language-plaintext highlighter-rouge">InputStream</code>，得到的包装类型是<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>，但它仍然被视为一个<code class="language-plaintext highlighter-rouge">InputStream</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">buffered</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
</code></pre></div></div><p>  最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">gzip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span><span class="n">buffered</span><span class="o">);</span>
</code></pre></div></div><p>  无论我们包装多少次，得到的对象始终是<code class="language-plaintext highlighter-rouge">InputStream</code>，我们直接用<code class="language-plaintext highlighter-rouge">InputStream</code>来引用它，就可以正常读取：</p><pre><code class="language-ascii">┌─────────────────────────┐
│GZIPInputStream          │
│┌───────────────────────┐│
││BufferedFileInputStream││
││┌─────────────────────┐││
│││   FileInputStream   │││
││└─────────────────────┘││
│└───────────────────────┘│
└─────────────────────────┘
</code></pre><p>  上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p><pre><code class="language-ascii">                 ┌─────────────┐
                 │ InputStream │
                 └─────────────┘
                       ▲ ▲
┌────────────────────┐ │ │ ┌─────────────────┐
│  FileInputStream   │─┤ └─│FilterInputStream│
└────────────────────┘ │   └─────────────────┘
┌────────────────────┐ │     ▲ ┌───────────────────┐
│ByteArrayInputStream│─┤     ├─│BufferedInputStream│
└────────────────────┘ │     │ └───────────────────┘
┌────────────────────┐ │     │ ┌───────────────────┐
│ ServletInputStream │─┘     ├─│  DataInputStream  │
└────────────────────┘       │ └───────────────────┘
                             │ ┌───────────────────┐
                             └─│CheckedInputStream │
                               └───────────────────┘
</code></pre><p>  类似的，<code class="language-plaintext highlighter-rouge">OutputStream</code>也是以这种模式来提供各种功能：</p><pre><code class="language-ascii">                  ┌─────────────┐
                  │OutputStream │
                  └─────────────┘
                        ▲ ▲
┌─────────────────────┐ │ │ ┌──────────────────┐
│  FileOutputStream   │─┤ └─│FilterOutputStream│
└─────────────────────┘ │   └──────────────────┘
┌─────────────────────┐ │     ▲ ┌────────────────────┐
│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│
└─────────────────────┘ │     │ └────────────────────┘
┌─────────────────────┐ │     │ ┌────────────────────┐
│ ServletOutputStream │─┘     ├─│  DataOutputStream  │
└─────────────────────┘       │ └────────────────────┘
                              │ ┌────────────────────┐
                              └─│CheckedOutputStream │
                                └────────────────────┘
</code></pre><p><strong>编写FilterInputStream</strong>   也可以自己编写<code class="language-plaintext highlighter-rouge">FilterInputStream</code>，以便可以把自己的<code class="language-plaintext highlighter-rouge">FilterInputStream</code>“叠加”到任何一个<code class="language-plaintext highlighter-rouge">InputStream</code>中。<br />   下面的例子演示了如何编写一个<code class="language-plaintext highlighter-rouge">CountInputStream</code>，它的作用是对输入的字节进行计数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">CountInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CountInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">data</span><span class="o">)))</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"\nTotal read "</span> <span class="o">+</span> <span class="n">input</span><span class="o">.</span><span class="na">getBytesRead</span><span class="o">()</span> <span class="o">+</span> <span class="s">" bytes"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CountInputStream</span> <span class="kd">extends</span> <span class="nc">FilterInputStream</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">CountInputStream</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">in</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getBytesRead</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  注意到在叠加多个<code class="language-plaintext highlighter-rouge">FilterInputStream</code>，我们只需要持有最外层的<code class="language-plaintext highlighter-rouge">InputStream</code>，并且，当最外层的<code class="language-plaintext highlighter-rouge">InputStream</code>关闭时（在<code class="language-plaintext highlighter-rouge">try(resource)</code>块的结束处自动关闭），内层的<code class="language-plaintext highlighter-rouge">InputStream</code>的<code class="language-plaintext highlighter-rouge">close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code class="language-plaintext highlighter-rouge">InputStream</code>，因此不存在资源泄露。<br />   Java的IO标准库使用Filter模式为<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>增加功能：</p><ul><li>可以把一个<code class="language-plaintext highlighter-rouge">InputStream</code>和任意个<code class="language-plaintext highlighter-rouge">FilterInputStream</code>组合；</li><li>可以把一个<code class="language-plaintext highlighter-rouge">OutputStream</code>和任意个<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>组合。   Filter模式可以在运行期动态增加功能（又称Decorator模式）。<h3 id="读zipzipinputstream">读zipZipInputStream</h3><p>  <code class="language-plaintext highlighter-rouge">ZipInputStream</code>是一种<code class="language-plaintext highlighter-rouge">FilterInputStream</code>，它可以直接读取zip包的内容：</p><pre><code class="language-ascii">┌───────────────────┐
│    InputStream    │
└───────────────────┘
        ▲
        │
┌───────────────────┐
│ FilterInputStream │
└───────────────────┘
        ▲
        │
┌───────────────────┐
│InflaterInputStream│
└───────────────────┘
        ▲
        │
┌───────────────────┐
│  ZipInputStream   │
└───────────────────┘
        ▲
        │
┌───────────────────┐
│  JarInputStream   │
└───────────────────┘
</code></pre><p>  另一个<code class="language-plaintext highlighter-rouge">JarInputStream</code>是从<code class="language-plaintext highlighter-rouge">ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的<code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。<br />   <strong>读取zip包</strong><br />   要创建一个<code class="language-plaintext highlighter-rouge">ZipInputStream</code>，通常是传入一个<code class="language-plaintext highlighter-rouge">FileInputStream</code>作为数据源，然后，循环调用<code class="language-plaintext highlighter-rouge">getNextEntry()</code>，直到返回<code class="language-plaintext highlighter-rouge">null</code>，表示zip流结束。<br />   一个<code class="language-plaintext highlighter-rouge">ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code class="language-plaintext highlighter-rouge">read()</code>方法不断读取，直到返回<code class="language-plaintext highlighter-rouge">-1</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">ZipInputStream</span> <span class="n">zip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ZipInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(...)))</span> <span class="o">{</span>
  <span class="nc">ZipEntry</span> <span class="n">entry</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  <span class="k">while</span> <span class="o">((</span><span class="n">entry</span> <span class="o">=</span> <span class="n">zip</span><span class="o">.</span><span class="na">getNextEntry</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">entry</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">())</span> <span class="o">{</span>
          <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
          <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">zip</span><span class="o">.</span><span class="na">read</span><span class="o">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
              <span class="o">...</span>
          <span class="o">}</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  <strong>写入zip包</strong><br />   <code class="language-plaintext highlighter-rouge">ZipOutputStream</code>是一种<code class="language-plaintext highlighter-rouge">FilterOutputStream</code>，它可以直接写入内容到zip包。<br />   要先创建一个<code class="language-plaintext highlighter-rouge">ZipOutputStream</code>，通常是包装一个<code class="language-plaintext highlighter-rouge">FileOutputStream</code>，然后，每写入一个文件前，先调用<code class="language-plaintext highlighter-rouge">putNextEntry()</code>，然后用<code class="language-plaintext highlighter-rouge">write()</code>写入<code class="language-plaintext highlighter-rouge">byte[]</code>数据，写入完毕后调用<code class="language-plaintext highlighter-rouge">closeEntry()</code>结束这个文件的打包。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">ZipOutputStream</span> <span class="n">zip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ZipOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(...)))</span> <span class="o">{</span>
  <span class="nc">File</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">zip</span><span class="o">.</span><span class="na">putNextEntry</span><span class="o">(</span><span class="k">new</span> <span class="nc">ZipEntry</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
      <span class="n">zip</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">toPath</span><span class="o">()));</span>
      <span class="n">zip</span><span class="o">.</span><span class="na">closeEntry</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code class="language-plaintext highlighter-rouge">new ZipEntry(name)</code>传入的<code class="language-plaintext highlighter-rouge">name</code>要用相对路径。<br />   <code class="language-plaintext highlighter-rouge">ZipInputStream</code>可以读取zip格式的流，<code class="language-plaintext highlighter-rouge">ZipOutputStream</code>可以把多份数据写入zip包；<br />   配合<code class="language-plaintext highlighter-rouge">FileInputStream</code>和<code class="language-plaintext highlighter-rouge">FileOutputStream</code>就可以读写zip文件。</p><h3 id="读取classpath资源getresourceasstream">读取classpath资源getResourceAsStream</h3><p>  很多Java程序启动的时候，都需要读取配置文件。例如，从一个<code class="language-plaintext highlighter-rouge">.properties</code>文件中读取配置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">conf</span> <span class="o">=</span> <span class="s">"C:\\conf\\default.properties"</span><span class="o">;</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">conf</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><p>  这段代码要正常执行，必须在C盘创建<code class="language-plaintext highlighter-rouge">conf</code>目录，然后在目录里创建<code class="language-plaintext highlighter-rouge">default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。<br />   因此，从磁盘的固定目录读取配置文件，不是一个好的办法。<br />   有没有路径无关的读取文件的方式呢？<br />   我们知道，Java存放<code class="language-plaintext highlighter-rouge">.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p></li><li>配置文件，例如<code class="language-plaintext highlighter-rouge">.properties</code>；</li><li>图片文件，例如<code class="language-plaintext highlighter-rouge">.jpg</code>；</li><li>文本文件，例如<code class="language-plaintext highlighter-rouge">.txt</code>，<code class="language-plaintext highlighter-rouge">.csv</code>；</li><li>……   从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code class="language-plaintext highlighter-rouge">default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。<br />   在classpath中的资源文件，路径总是以<code class="language-plaintext highlighter-rouge">／</code>开头，我们先获取当前的<code class="language-plaintext highlighter-rouge">Class</code>对象，然后调用<code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">getClass</span><span class="o">().</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/default.properties"</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><p>  调用<code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code class="language-plaintext highlighter-rouge">null</code>。因此，我们需要检查返回的<code class="language-plaintext highlighter-rouge">InputStream</code>是否为<code class="language-plaintext highlighter-rouge">null</code>，如果为<code class="language-plaintext highlighter-rouge">null</code>，表示资源文件在classpath中没有找到。<br />   如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">inputStreamFromClassPath</span><span class="o">(</span><span class="s">"/default.properties"</span><span class="o">));</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">inputStreamFromFile</span><span class="o">(</span><span class="s">"./conf.properties"</span><span class="o">));</span>
</code></pre></div></div><p>  这样读取配置文件，应用程序启动就更加灵活。</p><h3 id="序列化objectoutputstream">序列化ObjectOutputStream</h3><p>  序列化是指把一个Java对象变成二进制内容，本质上就是一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组。<br />   为什么要把Java对象序列化呢？因为序列化后可以把<code class="language-plaintext highlighter-rouge">byte[]</code>保存到文件中，或者把<code class="language-plaintext highlighter-rouge">byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。<br />   有序列化，就有反序列化，即把一个二进制内容（也就是<code class="language-plaintext highlighter-rouge">byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code class="language-plaintext highlighter-rouge">byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code class="language-plaintext highlighter-rouge">byte[]</code>并把它“变回”Java对象。<br />   一个Java对象要能序列化，必须实现一个特殊的<code class="language-plaintext highlighter-rouge">java.io.Serializable</code>接口，它的定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Serializable</span> <span class="o">{}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。<br />   <strong>序列化</strong><br />   把一个Java对象变为<code class="language-plaintext highlighter-rouge">byte[]</code>数组，需要使用<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ByteArrayOutputStream</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">{</span>
  <span class="n">output</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span><span class="c1">// 写入int</span>
  <span class="n">output</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span><span class="c1">// 写入String</span>
  <span class="n">output</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mf">123.456</span><span class="o">));</span><span class="c1">// 写入Object</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">()));</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>既可以写入基本类型，如<code class="language-plaintext highlighter-rouge">int</code>，<code class="language-plaintext highlighter-rouge">boolean</code>，也可以写入<code class="language-plaintext highlighter-rouge">String</code>（以UTF-8编码），还可以写入实现了<code class="language-plaintext highlighter-rouge">Serializable</code>接口的<code class="language-plaintext highlighter-rouge">Object</code>。<br />   因为写入<code class="language-plaintext highlighter-rouge">Object</code>时需要大量的类型信息，所以写入的内容很大。<br />   <strong>反序列化</strong><br />   和<code class="language-plaintext highlighter-rouge">ObjectOutputStream</code>相反，<code class="language-plaintext highlighter-rouge">ObjectInputStream</code>负责从一个字节流读取Java对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(...))</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
  <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">readUTF</span><span class="o">();</span>
  <span class="nc">Double</span> <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Double</span><span class="o">)</span> <span class="n">input</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  除了能读取基本类型和<code class="language-plaintext highlighter-rouge">String</code>类型外，调用<code class="language-plaintext highlighter-rouge">readObject()</code>可以直接返回一个<code class="language-plaintext highlighter-rouge">Object</code>对象。要把它变成一个特定类型，必须强制转型。<br />   <code class="language-plaintext highlighter-rouge">readObject()</code>可能抛出的异常有：</p></li><li><code class="language-plaintext highlighter-rouge">ClassNotFoundException</code>：没有找到对应的Class；</li><li><code class="language-plaintext highlighter-rouge">InvalidClassException</code>：Class不匹配。</li></ul><p>  对于<code class="language-plaintext highlighter-rouge">ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code class="language-plaintext highlighter-rouge">Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有<strong>定义</strong><code class="language-plaintext highlighter-rouge">Person</code>类，所以无法反序列化。<br />   对于<code class="language-plaintext highlighter-rouge">InvalidClassException</code>，这种情况常见于序列化的<code class="language-plaintext highlighter-rouge">Person</code>对象定义了一个<code class="language-plaintext highlighter-rouge">int</code>类型的<code class="language-plaintext highlighter-rouge">age</code>字段，但是反序列化时，<code class="language-plaintext highlighter-rouge">Person</code>类定义的<code class="language-plaintext highlighter-rouge">age</code>字段被改成了<code class="language-plaintext highlighter-rouge">long</code>类型，所以导致class不兼容。<br />   为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code class="language-plaintext highlighter-rouge">serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code class="language-plaintext highlighter-rouge">serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">2709425275741743919L</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  要特别注意反序列化的几个重要特点：<br />   反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p><ol><li>实现了<code class="language-plaintext highlighter-rouge">Serializable</code>接口的类，在反序列化时构造方法不会被调用。这是因为反序列化是通过读取对象的序列化数据来重新构建对象，而不是通过调用构造方法来创建对象的。</li><li>如果一个类没有实现<code class="language-plaintext highlighter-rouge">Serializable</code>接口，但它是某个实现了<code class="language-plaintext highlighter-rouge">Serializable</code>接口的父类，那么在反序列化子类时，JVM会自动调用父类的无参构造方法，并且父类无参构造方法里的代码也会被执行。这是因为反序列化需要对整个继承层次进行处理，以便正确地重建对象的状态。</li></ol><p>  这些规则在Java的序列化和反序列化机制中起着重要作用，确保对象在序列化和反序列化过程中能够正确地恢复其状态。<br />   <strong>安全性</strong><br />   因为Java的序列化机制可以导致一个实例能直接从<code class="language-plaintext highlighter-rouge">byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code class="language-plaintext highlighter-rouge">byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。<br />   实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p><h2 id="字符流">字符流</h2><p>  字待流有两个基本类：<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code><br />   1,<code class="language-plaintext highlighter-rouge">Reader</code>/<code class="language-plaintext highlighter-rouge">Writer</code>处理的是<strong>字符类型</strong>的数据。它处理流的方式是以<strong>字符</strong>为单位进行的。<br />   2,<code class="language-plaintext highlighter-rouge">Reader</code>/<code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>/<code class="language-plaintext highlighter-rouge">OutputStream</code>一样,也分为<strong>节点流</strong>(低级流)和<strong>处理流</strong>(高级流)。<br />   <code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>的差异<br />   <code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>一样,用于从流中读取数据。它和<code class="language-plaintext highlighter-rouge">InputStream</code>的区别在于,<code class="language-plaintext highlighter-rouge">InputStream</code>以<strong>字节</strong>为单位操作流,而<code class="language-plaintext highlighter-rouge">Reader</code>以<strong>字符</strong>为单位操作流。<br />   <code class="language-plaintext highlighter-rouge">Reader</code>类是所有输入字待流的父类,<code class="language-plaintext highlighter-rouge">Writer</code>类是所有输出字符流的父类。设计<code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">Writer</code>继承层次结构主要是为了国际化。而旧的I/O流继承层次结构仅支持8位字节流,并且不能很好的处理16位的Unicode字符。由于Unicode用于字符国际化,所以添加字符流的继承层次结构就是在所有的I/O操作中都支持Unicode。   <code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">Reader</code>类都是抽象类,不能建立它们的对象,所以只能通过它们子类对象对文件进行操作。</p><h3 id="reader">Reader</h3><p>  <code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>的区别如下：<br /> | InputStream | Reader | | :————————————– | :—————————————- | | 字节流，以<code class="language-plaintext highlighter-rouge">byte</code>为单位 | 字符流，以<code class="language-plaintext highlighter-rouge">char</code>为单位 | | 读取<strong>字节</strong>（-1，0~255）：<code class="language-plaintext highlighter-rouge">int read()</code> | 读取<strong>字符</strong>（-1，0~65535）：<code class="language-plaintext highlighter-rouge">int read()</code> | | 读到<strong>字节数组</strong>：<code class="language-plaintext highlighter-rouge">int read(byte[] b)</code> | 读到<strong>字符数组</strong>：<code class="language-plaintext highlighter-rouge">int read(char[] c)</code> |</p><p>  <strong>Reader常用方法</strong><br /> | 方法 | 说明 | | ————————————————— | ———————————————————— | | <strong>int read()</strong> | 读取一个字符,并将它返回，如果已读到末尾，返回<code class="language-plaintext highlighter-rouge">-1</code>。 | | <strong>int read(char[] buffer)</strong> | 将从流中读取的字符放到字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中,返回读出的字符数。 | | <strong>int read(char[] buffer,int offset,int length)</strong> | 将读出的字符放到字符数组的指定<code class="language-plaintext highlighter-rouge">offet</code>开始的空间,每次最多读出<code class="language-plaintext highlighter-rouge">length</code>个字符。 | | void mark(int ) | 标记流中的位置 | | boolean MarkSupported() | 判断流是否支持<code class="language-plaintext highlighter-rouge">mark()</code> | | boolean ready() | 判断是否准备读取此流 |</p><p>  <strong>Reader相关类</strong><br />   <strong>低级 <code class="language-plaintext highlighter-rouge">Reader</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">CharArrayReader</code>：从字符数组读取数据的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">PipedReader</code>：与<code class="language-plaintext highlighter-rouge">PipedWriter</code>配合使用，用于线程间通信的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">StringReader</code>：从字符串读取数据的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">FileReader</code>：从文件读取数据的<code class="language-plaintext highlighter-rouge">Reader</code>。</li></ul><p>  <strong>高级 <code class="language-plaintext highlighter-rouge">Reader</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">BufferedReader</code>：带有缓冲区的<code class="language-plaintext highlighter-rouge">Reader</code>，提高了从输入流读取数据的性能。</li><li><code class="language-plaintext highlighter-rouge">InputStreamReader</code>：将字节流转换为字符流的<code class="language-plaintext highlighter-rouge">Reader</code>。</li><li><code class="language-plaintext highlighter-rouge">LineNumberReader</code>：继承自<code class="language-plaintext highlighter-rouge">BufferedReader</code>，可以记录行号的<code class="language-plaintext highlighter-rouge">Reader</code>。</li></ul><h3 id="filereader">FileReader</h3><p>  <code class="language-plaintext highlighter-rouge">FileReader</code>是<code class="language-plaintext highlighter-rouge">Reader</code>的一个子类，它可以打开文件并获取<code class="language-plaintext highlighter-rouge">Reader</code>。<br />   使用<code class="language-plaintext highlighter-rouge">FileWriter</code>进行文件操作时,为了减少磁盘读写次数,<strong>常使用具有缓冲功能的<code class="language-plaintext highlighter-rouge">BufferedWriter</code>类。</strong> <br />   下面的代码演示了如何完整地读取一个<code class="language-plaintext highlighter-rouge">FileReader</code>的所有字符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个FileReader对象,字符编码是???</span>
<span class="k">try</span><span class="o">(</span><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"src/readme.txt"</span><span class="o">);)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="c1">// 反复调用read()方法，直到返回-1</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">())!=-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">n</span><span class="o">);</span> <span class="c1">// 打印char</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为<code class="language-plaintext highlighter-rouge">FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是<code class="language-plaintext highlighter-rouge">GBK</code>，打开一个<code class="language-plaintext highlighter-rouge">UTF-8</code>编码的文本文件就会出现乱码。<br />   要避免乱码问题，我们需要在创建<code class="language-plaintext highlighter-rouge">FileReader</code>时指定编码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"src/readme.txt"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
</code></pre></div></div><p>  带 Charset 参数的构造函数在 <strong>Java 11</strong> 中加入。<strong>Java 8</strong> 中可以使用 <code class="language-plaintext highlighter-rouge">InputStreamReader</code> 包装 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 自行构建。</p><h3 id="chararrayreader">CharArrayReader</h3><p>  <code class="language-plaintext highlighter-rouge">CharArrayReader</code>可以在内存中模拟一个<code class="language-plaintext highlighter-rouge">Reader</code>，它的作用实际上是把一个<code class="language-plaintext highlighter-rouge">char[]</code>数组变成一个<code class="language-plaintext highlighter-rouge">Reader</code>，这和<code class="language-plaintext highlighter-rouge">ByteArrayInputStream</code>非常类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CharArrayReader</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">()))</span> <span class="o">{}</span>
</code></pre></div></div><h3 id="stringreader">StringReader</h3><p>  <code class="language-plaintext highlighter-rouge">StringReader</code>可以直接把<code class="language-plaintext highlighter-rouge">String</code>作为数据源，它和<code class="language-plaintext highlighter-rouge">CharArrayReader</code>几乎一样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringReader</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><h3 id="inputstreamreader">InputStreamReader</h3><p>  <code class="language-plaintext highlighter-rouge">Reader</code>和<code class="language-plaintext highlighter-rouge">InputStream</code>有什么关系？<br />   除了特殊的<code class="language-plaintext highlighter-rouge">CharArrayReader</code>和<code class="language-plaintext highlighter-rouge">StringReader</code>，普通的<code class="language-plaintext highlighter-rouge">Reader</code>实际上是<strong>基于</strong><code class="language-plaintext highlighter-rouge">InputStream</code>构造的，因为<code class="language-plaintext highlighter-rouge">Reader</code>需要从<code class="language-plaintext highlighter-rouge">InputStream</code>中读入字节流（<code class="language-plaintext highlighter-rouge">byte</code>），然后，根据编码设置，再转换为<code class="language-plaintext highlighter-rouge">char</code>就可以实现字符流。如果我们查看<code class="language-plaintext highlighter-rouge">FileReader</code>的源码，它在内部实际上持有一个<code class="language-plaintext highlighter-rouge">FileInputStream</code>。<br />   既然<code class="language-plaintext highlighter-rouge">Reader</code>本质上是一个基于<code class="language-plaintext highlighter-rouge">InputStream</code>的<code class="language-plaintext highlighter-rouge">byte</code>到<code class="language-plaintext highlighter-rouge">char</code>的转换器，那么，如果我们已经有一个<code class="language-plaintext highlighter-rouge">InputStream</code>，想把它转换为<code class="language-plaintext highlighter-rouge">Reader</code>，是完全可行的。<code class="language-plaintext highlighter-rouge">InputStreamReader</code>就是这样一个转换器，它可以把任何<code class="language-plaintext highlighter-rouge">InputStream</code>转换为<code class="language-plaintext highlighter-rouge">Reader</code>。示例代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 持有InputStream:</span>
<span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"src/readme.txt"</span><span class="o">);</span>
<span class="c1">// 变换为Reader:</span>
<span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><p>  构造<code class="language-plaintext highlighter-rouge">InputStreamReader</code>时，我们需要传入<code class="language-plaintext highlighter-rouge">InputStream</code>，还需要指定编码，就可以得到一个<code class="language-plaintext highlighter-rouge">Reader</code>对象。上述代码实际上就是<code class="language-plaintext highlighter-rouge">FileReader</code>的一种实现方式。</p><h3 id="writer">Writer</h3><p>  <code class="language-plaintext highlighter-rouge">Writer</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>的区别如下：</p><table><thead><tr><th style="text-align: left">OutputStream</th><th style="text-align: left">Writer</th></tr></thead><tbody><tr><td style="text-align: left">字节流，以<code class="language-plaintext highlighter-rouge">byte</code>为单位</td><td style="text-align: left">字符流，以<code class="language-plaintext highlighter-rouge">char</code>为单位</td></tr><tr><td style="text-align: left">写入字节（0~255）：<code class="language-plaintext highlighter-rouge">void write(int b)</code></td><td style="text-align: left">写入字符（0~65535）：<code class="language-plaintext highlighter-rouge">void write(int c)</code></td></tr><tr><td style="text-align: left">写入字节数组：<code class="language-plaintext highlighter-rouge">void write(byte[] b)</code></td><td style="text-align: left">写入字符数组：<code class="language-plaintext highlighter-rouge">void write(char[] c)</code></td></tr><tr><td style="text-align: left">无对应方法</td><td style="text-align: left">写入String：<code class="language-plaintext highlighter-rouge">void write(String s)</code></td></tr></tbody></table><p>  <strong>Writer常用方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><strong>void write(int c)</strong></td><td>将参数<code class="language-plaintext highlighter-rouge">c</code>的低16位组成的字符写入到流中。这个方法通常用于写入单个字符的数据。</td></tr><tr><td><strong>void write(char[]buffer)</strong></td><td>将字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中的所有字符写入到流中。</td></tr><tr><td><strong>void write(char[]buffer,int offset,int length)</strong></td><td>将字符数组<code class="language-plaintext highlighter-rouge">buffer</code>中从<code class="language-plaintext highlighter-rouge">offset</code>位置开始的<code class="language-plaintext highlighter-rouge">length</code>个字符写入到流中。</td></tr><tr><td>void write(String string)</td><td>将字符串<code class="language-plaintext highlighter-rouge">string</code>写入到流中。</td></tr><tr><td>void write(String string,int offset,int length)</td><td>将字符串<code class="language-plaintext highlighter-rouge">string</code>中从<code class="language-plaintext highlighter-rouge">offset</code>位置开始的<code class="language-plaintext highlighter-rouge">length</code>个字符写入到流中。</td></tr><tr><td>Writer append(char c)</td><td>将指定字符添加到此<code class="language-plaintext highlighter-rouge">writer</code></td></tr><tr><td>void close()</td><td>关闭流</td></tr><tr><td>void flush()</td><td>刷新输出流，并将缓冲区中的数据输出。</td></tr></tbody></table><p>  <strong>Writer相关类</strong><br />   <strong>低级 <code class="language-plaintext highlighter-rouge">Writer</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">CharArrayWriter</code>：将字符写入到字符数组的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">StringWriter</code>：将字符写入到字符串的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">PipedWriter</code>：与<code class="language-plaintext highlighter-rouge">PipedReader</code>配合使用，用于线程间通信的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">FileWriter</code>：将字符写入到文件的<code class="language-plaintext highlighter-rouge">Writer</code>。</li></ul><p>  <strong>高级 <code class="language-plaintext highlighter-rouge">Writer</code>类：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">BufferedWriter</code>：带有缓冲区的<code class="language-plaintext highlighter-rouge">Writer</code>，提高了向输出流写入数据的性能。</li><li><code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>：将字符流转换为字节流的<code class="language-plaintext highlighter-rouge">Writer</code>。</li><li><code class="language-plaintext highlighter-rouge">PrintWriter</code>：带有打印功能的<code class="language-plaintext highlighter-rouge">Writer</code>，可以方便地向输出流写入各种数据类型的值。</li></ul><h3 id="filewriter">FileWriter</h3><p>  <code class="language-plaintext highlighter-rouge">FileWriter</code>就是向文件中写入字符流的<code class="language-plaintext highlighter-rouge">Writer</code>。它的使用方法和<code class="language-plaintext highlighter-rouge">FileReader</code>类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Writer</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"readme.txt"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="sc">'H'</span><span class="o">);</span> <span class="c1">// 写入单个字符</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span> <span class="c1">// 写入char[]</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span> <span class="c1">// 写入String</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="chararraywriter">CharArrayWriter</h3><p>  <code class="language-plaintext highlighter-rouge">CharArrayWriter</code>可以在内存中创建一个<code class="language-plaintext highlighter-rouge">Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code class="language-plaintext highlighter-rouge">char</code>，最后得到写入的<code class="language-plaintext highlighter-rouge">char[]</code>数组，这和<code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code>非常类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">CharArrayWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CharArrayWriter</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">65</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">66</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">67</span><span class="o">);</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> <span class="c1">// { 'A', 'B', 'C' }</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="stringwriter">StringWriter</h3><p>  <code class="language-plaintext highlighter-rouge">StringWriter</code>也是一个基于内存的<code class="language-plaintext highlighter-rouge">Writer</code>，它和<code class="language-plaintext highlighter-rouge">CharArrayWriter</code>类似。实际上，<code class="language-plaintext highlighter-rouge">StringWriter</code>在内部维护了一个<code class="language-plaintext highlighter-rouge">StringBuffer</code>，并对外提供了<code class="language-plaintext highlighter-rouge">Writer</code>接口。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">StringWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">65</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">66</span><span class="o">);</span>
    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="mi">67</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">data</span> <span class="o">=</span> <span class="n">writer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// ABC</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="outputstreamwriter">OutputStreamWriter</h3><p>  除了<code class="language-plaintext highlighter-rouge">CharArrayWriter</code>和<code class="language-plaintext highlighter-rouge">StringWriter</code>外，普通的Writer实际上是基于<code class="language-plaintext highlighter-rouge">OutputStream</code>构造的，它接收<code class="language-plaintext highlighter-rouge">char</code>，然后在内部自动转换成一个或多个<code class="language-plaintext highlighter-rouge">byte</code>，并写入<code class="language-plaintext highlighter-rouge">OutputStream</code>。因此，<code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>就是一个将任意的<code class="language-plaintext highlighter-rouge">OutputStream</code>转换为<code class="language-plaintext highlighter-rouge">Writer</code>的转换器：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Writer</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"readme.txt"</span><span class="o">),</span> <span class="s">"UTF-8"</span><span class="o">))</span> <span class="o">{}</span>
</code></pre></div></div><p>  上述代码实际上就是<code class="language-plaintext highlighter-rouge">FileWriter</code>的一种实现方式。这和上一节的<code class="language-plaintext highlighter-rouge">InputStreamReader</code>是一样的。</p><h3 id="printwriter">PrintWriter</h3><p>  <code class="language-plaintext highlighter-rouge">PrintStream</code>最终输出的总是byte数据，而<code class="language-plaintext highlighter-rouge">PrintWriter</code>则是扩展了<code class="language-plaintext highlighter-rouge">Writer</code>接口，它的<code class="language-plaintext highlighter-rouge">print()</code>/<code class="language-plaintext highlighter-rouge">println()</code>方法最终输出的是<code class="language-plaintext highlighter-rouge">char</code>数据。两者的使用方法几乎是一模一样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringWriter</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringWriter</span><span class="o">();</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">PrintWriter</span> <span class="n">pw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">pw</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
    <span class="n">pw</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span>
    <span class="n">pw</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span>
</code></pre></div></div><h2 id="其他">其他</h2><p>  <strong>标准输入输出的重定向</strong><br />   Java系统预先定义3个流对象;</p><ol><li>标准输出设备<code class="language-plaintext highlighter-rouge">System.out</code></li><li>标准输入设备<code class="language-plaintext highlighter-rouge">System.in</code></li><li>标准错误设备<code class="language-plaintext highlighter-rouge">System.err</code></li></ol><p>  在默认情况下,标准输入设备是键盘,而标准输出设备是显示器,通过<code class="language-plaintext highlighter-rouge">System.setIn</code>方法和<code class="language-plaintext highlighter-rouge">System.setout</code>方法可以改变它们的默认输入/输出设备<br />   实例</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="nc">PrintStream</span> <span class="n">ps</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"Demo.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span><span class="c1">//建立一个文件输出流,并将它的append标记设置为true  </span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  
        <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">fos</span><span class="o">);</span><span class="c1">// 建立一个PrintStream对象,它将作为标准输出流  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">setOut</span><span class="o">(</span><span class="n">ps</span><span class="o">);</span><span class="c1">//将标准输出定向到PrintStream对象  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"该字符串会输出到文件中"</span><span class="o">);</span><span class="c1">//输出以条数据,它不再会在控制台输出,而是输出到了文件Demo.txt中  </span>
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">RandomAccessFile</code>类<br />   <code class="language-plaintext highlighter-rouge">RandomAccessFile</code>是一种特殊的文件流,可以用它在文件的任何地方查找或者插入数据<br />   <code class="language-plaintext highlighter-rouge">RandomAccessFile</code>同时实现了<code class="language-plaintext highlighter-rouge">Datalnput</code>和<code class="language-plaintext highlighter-rouge">DataOutput</code>接口,所以可以用它来读/写文件<br />   构造器<br />   <code class="language-plaintext highlighter-rouge">RandomAccessFile(java.io.File f,String mode)</code><br />   <code class="language-plaintext highlighter-rouge">RandomAccessFile(String file,String mode)</code></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RandomAccessFile</span> <span class="n">rf1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RandomAccessFile</span><span class="o">(</span><span class="s">"toAppend.txt"</span><span class="o">,</span> <span class="s">"rw"</span><span class="o">);</span>  
<span class="n">rf1</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>  
<span class="n">rf1</span><span class="o">.</span><span class="na">writeBytes</span><span class="o">(</span> <span class="s">"123\n"</span><span class="o">);</span>  
<span class="n">rf1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>​ <br />   <code class="language-plaintext highlighter-rouge">DataOutputStream</code>流类<br />   使用<code class="language-plaintext highlighter-rouge">DataOutputStream</code>类向文件中写入各种类型数据的操作步骤是:</p><ol><li>为磁盘文件建立<code class="language-plaintext highlighter-rouge">File</code>类对象;</li><li>为该<code class="language-plaintext highlighter-rouge">File</code>对象建立<code class="language-plaintext highlighter-rouge">FileOutputStream</code>类流对象,建立其与磁盘文件的连接;</li><li>为该<code class="language-plaintext highlighter-rouge">FileOutputStream</code>类对象建立<code class="language-plaintext highlighter-rouge">DataOutputStream</code>类对象,利用<code class="language-plaintext highlighter-rouge">DataOutputStream</code>类的<code class="language-plaintext highlighter-rouge">writelnt()</code>,<code class="language-plaintext highlighter-rouge">writeFloat()</code>, <code class="language-plaintext highlighter-rouge">writeDouble()</code>,<code class="language-plaintext highlighter-rouge">writeBoolean()</code>等方法分别尚文件中写入整型、单精度型、双精度型、布尔型等数据;</li><li>写入操作完成后,利用<code class="language-plaintext highlighter-rouge">close()</code>方法将流关闭,断开与磁盘文件的联系。</li></ol><h2 id="buffered缓存流">Buffered缓存流</h2><p>  缓存流是计算机领域中输入输出流的一种常见形式。包括<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>/ <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code> 类和<code class="language-plaintext highlighter-rouge">BufferedReader</code>/ <code class="language-plaintext highlighter-rouge">BufferedWriter</code>类。<br />   这种流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出,通过<strong>减少系统</strong>资源的<strong>读写次数</strong>来<strong>加快</strong>程序的执行。<code class="language-plaintext highlighter-rouge">BufferedOutputstream</code> 或<code class="language-plaintext highlighter-rouge">BufferedWriter</code> 类仅仅在缓冲区满或调用<code class="language-plaintext highlighter-rouge">flush()</code>方法时才将数据写到目的地。   <code class="language-plaintext highlighter-rouge">BufferedInputStream</code>实际上默认<code class="language-plaintext highlighter-rouge">buffer</code>是8k，无论调用<code class="language-plaintext highlighter-rouge">read()</code>还是<code class="language-plaintext highlighter-rouge">read(byte[],int,int)</code>，它都先以默认大小为8192字节去读数据，再根据实际请求的数据量返回。 <br />   缓存流是过滤流,在创建具体流时需要给出一个<code class="language-plaintext highlighter-rouge">InputStream</code> / <code class="language-plaintext highlighter-rouge">OutputStream</code> 类型的流座位前端流,并可以指明缓冲区的大小。<br />   <code class="language-plaintext highlighter-rouge">public BufferedInputStream(InputStream in)</code><br />   <code class="language-plaintext highlighter-rouge">public BufferedInputStream(InputStream in,int size)</code><br />   <code class="language-plaintext highlighter-rouge">BufferedInputStream</code> / <code class="language-plaintext highlighter-rouge">BufferedOutputStream</code>类提供<code class="language-plaintext highlighter-rouge">InputStream</code> /<code class="language-plaintext highlighter-rouge">OutputStream</code> 中定义的方法,例如 <code class="language-plaintext highlighter-rouge">read()</code> , <code class="language-plaintext highlighter-rouge">skip()</code>,<code class="language-plaintext highlighter-rouge">write()</code>等,并支持基于标签机制的回读。<br />   <code class="language-plaintext highlighter-rouge">BufferedReader</code>类中增加了一个有用的方法 <code class="language-plaintext highlighter-rouge">readLine()</code>,该方法读一行字符返回。行的结束标志是换行符“<code class="language-plaintext highlighter-rouge">\n</code>”或回车符“<code class="language-plaintext highlighter-rouge">\r</code>”,或回车符+换行符。<br />   <code class="language-plaintext highlighter-rouge">BufferedWriter</code>中也相应增加了一个方法<code class="language-plaintext highlighter-rouge">newLine()</code>,该方法写一个行分隔符。分隔符由系统特性<code class="language-plaintext highlighter-rouge">line.separator</code> 指定,可以是“<code class="language-plaintext highlighter-rouge">\n</code>”。<br />   <code class="language-plaintext highlighter-rouge">public class BufferedWriter extends Writer</code><br />   将文本写入字符输出流,缓冲各个字符,从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小,或者接受默认的大小。在大多数情况下,默认值就足够大了。该类提供了<code class="language-plaintext highlighter-rouge">newLine()</code>方法,它使用平台自己的行分隔符概念,此概念由系统属性 <code class="language-plaintext highlighter-rouge">line.separator</code> 定义。并非所有平台都使用新行符(‘\n’)来终止各行。因此调用此方法来终止每个输出行要<strong>优于</strong>直接写入新行符。 通常 <code class="language-plaintext highlighter-rouge">Writer</code> 将其输出立即发送到底层字符或字节流。除非要求提示输出,否则<strong>建议用<code class="language-plaintext highlighter-rouge">BufferedWriter</code>包装所有其<code class="language-plaintext highlighter-rouge">write()</code>操作</strong>可能开销很高的<code class="language-plaintext highlighter-rouge">Writer</code>(如 <code class="language-plaintext highlighter-rouge">FileWriters</code>和<code class="language-plaintext highlighter-rouge">OutputStreamWriters</code>)。例如:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintWriter</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileWriter</span><span class="o">(</span><span class="s">"foo.out"</span><span class="o">)));</span>  
</code></pre></div></div><p>  将缓冲<code class="language-plaintext highlighter-rouge">PrintWriter</code>对文件的输出。如果没有缓冲,则每次调用<code class="language-plaintext highlighter-rouge">print()</code>方法会导致将字符转换为字节,然后立即写入到文件,而这是极其低效的。<br />   <code class="language-plaintext highlighter-rouge">BufferedReader</code>同理</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">a1</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileNotFoundException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileReader</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">FileReader</span> <span class="n">fr</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">reccount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">fr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">"file2.txt"</span><span class="o">);</span>  
            <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="n">fr</span><span class="o">);</span>  
                <span class="nc">String</span> <span class="n">record</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>  
            <span class="k">while</span> <span class="o">((</span><span class="n">record</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>  
                <span class="n">reccount</span><span class="o">++;</span>  
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Line"</span> <span class="o">+</span> <span class="n">reccount</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">record</span><span class="o">);</span>  
            <span class="o">}</span>  
            <span class="n">fr</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
            <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有文件"</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h2 id="dataoutputstreamdatainputstream">DataOutputStream/DataInputStream</h2><p>  数据输出流允许应用程序以与机器无关方式将Java基本数据类型写到底层输出流。<br />   可以使用<code class="language-plaintext highlighter-rouge">DataOutputStream</code>和<code class="language-plaintext highlighter-rouge">DataInputStream</code>写入和读取数据。<br />   在IO包中提供了两个与平台无关的数据操作流<br />   数据输出流：<code class="language-plaintext highlighter-rouge">DataOutputStream</code><br />   数据输入流：<code class="language-plaintext highlighter-rouge">DataInputStream</code><br />   通常按照一定格式将输入输出,再按照一定格式将数据输入。<br />   要想使用数据输出流和输入流,则<strong>肯定要用户指定数据的保存格式</strong>。必须按指定的格式保存数据,才可以将数据输入流将数据读取进来。<br />   <code class="language-plaintext highlighter-rouge">DataOutputStreams</code>是<code class="language-plaintext highlighter-rouge">OutputStream</code>的子类。<br />   </p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataOutputStream</span> <span class="kd">extends</span> <span class="nc">FilterOutputStream</span> <span class="kd">implements</span> <span class="nc">DataOutput</span><span class="o">{}</span> 
</code></pre></div></div><p>  此类继承自<code class="language-plaintext highlighter-rouge">FillterOutputStream</code>类,同时实现<code class="language-plaintext highlighter-rouge">DataOutput</code>接口。在<code class="language-plaintext highlighter-rouge">DataOutput</code>接口定义了一系列写入各种数据的方法。<br />   <code class="language-plaintext highlighter-rouge">DataOutput</code>接口定义了一系列的<code class="language-plaintext highlighter-rouge">writeXXX()</code>的操作,可以写入各种类型数据。<br />   要想使用<code class="language-plaintext highlighter-rouge">DataOutputStream</code>写入数据的话,则必须指定好数据的输出格式。<br />   <code class="language-plaintext highlighter-rouge">DataOutputStream</code><br />   <strong>字段</strong><br />   到目前为止写入数据输出流的字节数。<br />   <code class="language-plaintext highlighter-rouge">protected int written</code><br />   <strong>构造方法</strong><br />   创建一个新的数据输出流,将数据写入指定基础输出流。<br />   <code class="language-plaintext highlighter-rouge">DataOutputStream(OutputStream out)</code><br />   <strong>写方法</strong><br />   (1)基本数据类型写入方法：八种基本类型：六种数字类型(四个整数型,两个浮点型),一种字符类型,还有一种布尔型。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void writeByte(int v)</td><td>将一个byte值以1-byte值形式写出到基础输出流中。</td></tr><tr><td>void writeShort(int v)</td><td>将一个short值以2-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeInt(int v)</td><td>将一个int值以4-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeLong(long v)</td><td>将一个long值以8-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeFloat(float v)</td><td>使用Float类中的floatToIntBits方法将float参数转换为一个int值,然后将该int值以4-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeDouble(double v)</td><td>使用Double类中的doubleToLongBits方法将double参数转换为一个long值,然后将该long值以8-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeChar(int v)</td><td>将一个char值以2-byte值形式写入基础输出流中,先写入高字节。</td></tr><tr><td>void writeBoolean(boolean v)</td><td>将一个boolean值以1-byte值形式写入基础输出流。</td></tr></tbody></table><p>  (2)字节数组的写入方法<br />   <code class="language-plaintext highlighter-rouge">void write(byte[] b, int off, int len)</code> 将指定 <strong>byte</strong> 数组中从偏移量 <strong>off</strong> 开始的 <strong>len</strong> 个字节写入基础输出<br />   (3)只写入int的低八位<br />   <code class="language-plaintext highlighter-rouge">void write(int b)</code> 将指定字节(参数<code class="language-plaintext highlighter-rouge">b</code>的八个低位)写入基础输出流。<br />   (4)写入字符串的方法<br />   <code class="language-plaintext highlighter-rouge">void writeBytes(String s)</code> 将字符串按字节顺序写出到基础输出流中。<br />   <code class="language-plaintext highlighter-rouge">void writeChars(String s)</code> 采用<code class="language-plaintext highlighter-rouge">UTF-16be</code>方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。<br />   <code class="language-plaintext highlighter-rouge">void writeUTF(String str)</code> 以与机器无关方式使用<code class="language-plaintext highlighter-rouge">UTF-8</code>修改版编码将一个字符串写入基础<br />   4.其他方法<br />   <code class="language-plaintext highlighter-rouge">void flush()</code> 清空此数据输出流。写入文件<br />   <code class="language-plaintext highlighter-rouge">int size()</code> 返回计数器 <code class="language-plaintext highlighter-rouge">written</code> 的当前值,即到目前为止写入此数据输出流的字节数。<br />   <code class="language-plaintext highlighter-rouge">DataInputStream</code><br />   <strong>构造方法</strong><br />   使用指定的底层 <code class="language-plaintext highlighter-rouge">InputStream</code> 创建一个 <code class="language-plaintext highlighter-rouge">DataInputStream</code>。<br />   <code class="language-plaintext highlighter-rouge">DataInputStream(InputStream in)</code><br />   <strong>读方法</strong><br />   1.基本类型读取方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>byte readByte()</td><td>读取并返回一个输入字节。该字节被看作是 -128 到 127(包含)范围内的一个有符号值。</td></tr><tr><td>int readInt()</td><td>读取四个输入字节并返回一个 int 值。</td></tr><tr><td>short readShort()</td><td>参见 DataInput 的 readShort 方法的常规协定。</td></tr><tr><td>long readLong() </td><td>读取八个输入字节并返回一个 long 值。</td></tr><tr><td>float readFloat()</td><td>读取四个输入字节并返回一个 float 值。</td></tr><tr><td>double readDouble()</td><td>读取八个输入字节并返回一个 double 值。实现这一点的方法是：   先使用与 readlong 方法完全相同的方式构造一个 long 值, 然后使用与 Double.longBitsToDouble 方法完全相同的方式将此 long 值转换成一个 double 值。</td></tr><tr><td>boolean readBoolean()</td><td>读取一个输入字节,如果该字节不是零,则返回 true,如果是零,则返回 false。</td></tr><tr><td>char readChar()</td><td>读取两个输入字节并返回一个 char 值。</td></tr></tbody></table><p>  2.字符串读取方法<br />   <code class="language-plaintext highlighter-rouge">String readUTF();</code> 读入一个已使用 UTF-8 修改版格式编码的字符串。<br />   <code class="language-plaintext highlighter-rouge">static String readUTF(DataInput in)</code> 从流 in 中读取用 UTF-8 修改版格式编码的 Unicode 字符格式的字符串;然后以 <code class="language-plaintext highlighter-rouge">String</code> 形式返回此字符串。<br />   可以看到<code class="language-plaintext highlighter-rouge">DataInputStream</code>中读取字符串<strong>只有<code class="language-plaintext highlighter-rouge">readUTF()</code></strong>方法,<strong>没有</strong>与<code class="language-plaintext highlighter-rouge">DataOutputStream</code>对应的：<br />   <code class="language-plaintext highlighter-rouge">void writeBytes(String s)</code> 将字符串按字节顺序写出到基础输出流中。<br />   <code class="language-plaintext highlighter-rouge">void writeChars(String s)</code> 采用<code class="language-plaintext highlighter-rouge">UTF-16be</code>方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。<br />   使用<code class="language-plaintext highlighter-rouge">DataOutputStream</code>的这两个方法写入字符串时,<code class="language-plaintext highlighter-rouge">DataInputStream</code>来读取可能比较<strong>麻烦</strong>。<br />   3.无符号整数读取方法<br />   <code class="language-plaintext highlighter-rouge">DataInputStream</code>中并没有写入无符号整数的方法,这两个方法是不是用不到？<br />   <code class="language-plaintext highlighter-rouge">int readUnsignedByte();</code>读取一个输入字节,将它左侧补零 (zero-extend) 转变为 <code class="language-plaintext highlighter-rouge">int</code> 类型,并返回结果,所以结果的范围是 0 到 255。如果接口 <code class="language-plaintext highlighter-rouge">DataOutput</code> 的 <code class="language-plaintext highlighter-rouge">writeByte</code> 方法的参数是 0 到 255 之间的值,则此方法适用于读取用 <code class="language-plaintext highlighter-rouge">writeByte</code> 写入的字节。<br />   <code class="language-plaintext highlighter-rouge">int readUnsignedShort();</code>读取两个输入字节,并返回 0 到 65535 范围内的一个 <code class="language-plaintext highlighter-rouge">int</code> 值。如果接口 <code class="language-plaintext highlighter-rouge">DataOutput</code> 的 <code class="language-plaintext highlighter-rouge">writeShort</code> 方法的参数是 0 到 65535 范围内的值,则此方法适用于读取用 <code class="language-plaintext highlighter-rouge">writeShort</code> 写入的字节。<br />   4.读取字节数组的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int read(byte[] b)</td><td>从包含的输入流中读取一定数量的字节,并将它们存储到缓冲区数组 <code class="language-plaintext highlighter-rouge">b</code> 中。</td></tr><tr><td>int read(byte[] b, int off, int len)</td><td>从包含的输入流中将最多 <code class="language-plaintext highlighter-rouge">len</code> 个字节读入一个 <code class="language-plaintext highlighter-rouge">byte</code> 数组中。</td></tr><tr><td>void readFully(byte[] b)</td><td>从输入流中读取一些字节,并将它们存储在缓冲区数组 <code class="language-plaintext highlighter-rouge">b</code> 中。读取的字节数等于 <code class="language-plaintext highlighter-rouge">b</code> 的长度。</td></tr><tr><td>void readFully(byte[] b, int off, int len)</td><td>从输入流中读取 <code class="language-plaintext highlighter-rouge">len</code> 个字节到字节数组<code class="language-plaintext highlighter-rouge">b</code>,从<code class="language-plaintext highlighter-rouge">b</code>的<code class="language-plaintext highlighter-rouge">off</code>下标开始读入。</td></tr></tbody></table><p>  5.同样是读取字节数组的方法,<code class="language-plaintext highlighter-rouge">read(byte[] b)</code>和<code class="language-plaintext highlighter-rouge">readFully(byte[] b)</code>的区别：<br />   其实<code class="language-plaintext highlighter-rouge">read(byte[] b)</code>方法和<code class="language-plaintext highlighter-rouge">readFully(byte []b)</code>都是利用<code class="language-plaintext highlighter-rouge">InputStream</code>中<code class="language-plaintext highlighter-rouge">read()</code>方法,每次读取的也是一个字节,只是读取字节数组的方式不同.<br />   <code class="language-plaintext highlighter-rouge">read(byte[] b)</code>方法实质是读取流上的字节直到流上<strong>没有</strong>字节为止,如果当声明的字节数组长度<strong>大于</strong>流上的数据长度时就提前返回<br />   <code class="language-plaintext highlighter-rouge">readFully(byte[] b)</code>方法是读取流上<strong>指定长度</strong>的字节数组,也就是说如果声明了长度为<code class="language-plaintext highlighter-rouge">len</code>的字节数组,<code class="language-plaintext highlighter-rouge">readFully(byte[] b)</code>方法只有读取<code class="language-plaintext highlighter-rouge">len</code>长度个字节的时候才返回,否则<strong>阻塞等待</strong>,如果超时,则会抛出异常 <code class="language-plaintext highlighter-rouge">EOFException</code>。<br />   那么当发送了长度为<code class="language-plaintext highlighter-rouge">len</code>的字节,那么为什么用<code class="language-plaintext highlighter-rouge">read</code>方法用户收不全呢,揪其原因我们发现消息在网络中传输是没那么理想的,我们发的那部分字节数组在传送过程中可能在接受信息方的缓存当中或者在传输线路,极端情况下可能在发送方的缓存当中,这样就不在流上,所以<code class="language-plaintext highlighter-rouge">read</code>方法提前返回了,这样就造成了各种错误。<br />   <code class="language-plaintext highlighter-rouge">readFully()</code>源码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFully</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">off</span><span class="o">,</span> <span class="kt">int</span> <span class="n">len</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">copy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span> 
    <span class="k">while</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">off</span><span class="o">,</span> <span class="n">len</span><span class="o">,</span> <span class="n">copy</span><span class="o">);</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>  
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">EOFException</span><span class="o">();</span>  
        <span class="o">}</span>  
        <span class="n">off</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>  
        <span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">readFully</code>方法并不是说一下就把整个文件读完了,不用去管是否到达文件末尾的异常。<code class="language-plaintext highlighter-rouge">readFully</code>只是在读取数据的时候,会一直把缓冲区读满,否则一直处于阻塞状态而等待读取。<br />   <code class="language-plaintext highlighter-rouge">read</code>方法只是将字节流中的数据读完。那么数据在TCP协议传送的过程中,可能输入流接受到的数据并不完全,只是其中的一部分。<br />   如果这时候的缓冲区没有满的话,<code class="language-plaintext highlighter-rouge">readFully</code>将会继续等待,直到缓冲区装满。<br />   某些时候,你可能需要读出特定的长度的字段。比如一些数据的头信息之类的,这时候如果你用<code class="language-plaintext highlighter-rouge">read</code>去读,那么可能还没有读完就个你返回来了。但是如果去用<code class="language-plaintext highlighter-rouge">readFully</code>读,那么就会完整的给你读出来。但是在更多的时候,如果不是确定要用特定长度的数据。还是用<code class="language-plaintext highlighter-rouge">read</code>去读。用<code class="language-plaintext highlighter-rouge">readFully</code>有点危险。<br />   6.跳过n个字节：<br />   <code class="language-plaintext highlighter-rouge">int skipBytes(int n)</code> 试图在输入流中跳过数据的<code class="language-plaintext highlighter-rouge">n</code>个字节,并丢弃跳过的字节。<br />   <strong>实例</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span>  
<span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span>  
    <span class="o">{</span>  
        <span class="nc">FileOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"testDataOutputStream.txt"</span><span class="o">);</span>  
        <span class="nc">DataOutputStream</span> <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="n">out</span><span class="o">);</span>  
        <span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>  
        <span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">900</span><span class="o">;</span>  
        <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="mf">12.3f</span><span class="o">;</span>  
        <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">800</span><span class="n">l</span><span class="o">;</span>  
        <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">14.23</span><span class="o">;</span>  
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>  
        <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'中'</span><span class="o">;</span>  
        <span class="n">dos</span><span class="o">.</span><span class="na">writeByte</span><span class="o">(</span><span class="n">b</span><span class="o">);</span><span class="c1">// 写入byte类型数据  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeShort</span><span class="o">(</span><span class="n">s</span><span class="o">);</span><span class="c1">// 写入short类型数据  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">a</span><span class="o">);</span><span class="c1">// 写入int类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeFloat</span><span class="o">(</span><span class="n">f</span><span class="o">);</span><span class="c1">// 写入float类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeLong</span><span class="o">(</span><span class="n">l</span><span class="o">);</span><span class="c1">// 写入long类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeDouble</span><span class="o">(</span><span class="n">d</span><span class="o">);</span><span class="c1">// 写入double类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">writeBoolean</span><span class="o">(</span><span class="n">flag</span><span class="o">);</span>  
        <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span><span class="c1">// 写入char类型  </span>
        <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="nc">FileInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"testDataOutputStream.txt"</span><span class="o">);</span>  
        <span class="nc">DataInputStream</span> <span class="n">dif</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">in</span><span class="o">);</span>  
        <span class="kt">byte</span> <span class="n">btemp</span><span class="o">;</span>  
        <span class="kt">short</span> <span class="n">stemp</span><span class="o">;</span>  
        <span class="kt">int</span> <span class="n">atemp</span><span class="o">;</span>  
        <span class="kt">float</span> <span class="n">ftemp</span><span class="o">;</span>  
        <span class="kt">long</span> <span class="n">ltemp</span><span class="o">;</span>  
        <span class="kt">double</span> <span class="n">dtemp</span><span class="o">;</span>  
        <span class="kt">boolean</span> <span class="n">flagtemp</span><span class="o">;</span>  
        <span class="kt">char</span> <span class="n">chtemp</span><span class="o">;</span>  
        <span class="n">btemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readByte</span><span class="o">();</span>  
        <span class="n">stemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readShort</span><span class="o">();</span>  
        <span class="n">atemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>  
        <span class="n">ftemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readFloat</span><span class="o">();</span>  
        <span class="n">ltemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readLong</span><span class="o">();</span>  
        <span class="n">dtemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readDouble</span><span class="o">();</span>  
        <span class="n">flagtemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readBoolean</span><span class="o">();</span>  
        <span class="n">chtemp</span> <span class="o">=</span> <span class="n">dif</span><span class="o">.</span><span class="na">readChar</span><span class="o">();</span>  
        <span class="c1">// stringtemp=dif.read  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">btemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">atemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ftemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ltemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dtemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">flagtemp</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">chtemp</span><span class="o">);</span>  
        <span class="n">dif</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="n">in</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>  输出:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20
30
900
12.3
800
14.23
true
中
</code></pre></div></div><p>  <strong>实例二</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.DataOutputStream</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span> <span class="c1">// 所有异常抛出  </span>
        <span class="nc">DataOutputStream</span> <span class="n">dos</span><span class="o">;</span> <span class="c1">// 声明数据输出流对象  </span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:"</span> <span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> <span class="s">"order.txt"</span><span class="o">);</span> <span class="c1">// 文件的保存路径  </span>
        <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">));</span> <span class="c1">// 实例化数据输出流对象  </span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"衬衣"</span><span class="o">,</span> <span class="s">"手套"</span><span class="o">,</span> <span class="s">"围巾"</span><span class="o">};</span> <span class="c1">// 商品名称  </span>
        <span class="kt">float</span><span class="o">[]</span> <span class="n">prices</span> <span class="o">=</span> <span class="o">{</span><span class="mf">98.3f</span><span class="o">,</span> <span class="mf">30.3f</span><span class="o">,</span> <span class="mf">50.5f</span><span class="o">};</span> <span class="c1">// 商品价格  </span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span> <span class="c1">// 商品数量  </span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 循环输出  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChars</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 写入字符串,注意,这边少数writeChars(),不是writechar(*。  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="sc">'\t'</span><span class="o">);</span> <span class="c1">// 写入分隔符,这边是读取writechar()。  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeFloat</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 写入价格  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="sc">'\t'</span><span class="o">);</span> <span class="c1">// 写入分隔符  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// 写入数量  </span>
            <span class="n">dos</span><span class="o">.</span><span class="na">writeChar</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span> <span class="c1">// 换行  </span>
        <span class="o">}</span>  
        <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭输出流  </span>
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>  代码生成的文件</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>886c 8863 0009 42c4 999a 0009 0000 0003
000a 624b 5957 0009 41f2 6666 0009 0000
0002 000a 56f4 5dfe 0009 424a 0000 0009
0000 0001 000a
</code></pre></div></div><p>  使用<code class="language-plaintext highlighter-rouge">DataOutpputStream</code>写入的数据要使用<code class="language-plaintext highlighter-rouge">DataInputStream</code>取出进来,</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.DataInputStream</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span> <span class="c1">// 所有异常抛出  </span>
        <span class="nc">DataInputStream</span> <span class="n">dis</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 声明数据输入流对象  </span>
        <span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"d:"</span> <span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> <span class="s">"order.txt"</span><span class="o">);</span> <span class="c1">// 文件的保存路径  </span>
        <span class="n">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">));</span> <span class="c1">// 实例化数据输入流对象  </span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 接收名称  </span>
        <span class="kt">float</span> <span class="n">price</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="o">;</span> <span class="c1">// 接收价格  </span>
        <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 接收数量  </span>
        <span class="kt">char</span> <span class="n">temp</span><span class="o">[]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// 接收商品名称  </span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 保存读取数据的个数  </span>
        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// '\u0000'  </span>
        <span class="k">try</span> <span class="o">{</span>  
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>  
                <span class="n">temp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="mi">200</span><span class="o">];</span> <span class="c1">// 开辟空间  </span>
                <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>  
                <span class="k">while</span> <span class="o">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="na">readChar</span><span class="o">())</span> <span class="o">!=</span> <span class="sc">'\t'</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 接收内容,因为直到读取到'\t'才完成了读取一个字符串,未读取到表示还有内容。  </span>
                    <span class="n">temp</span><span class="o">[</span><span class="n">len</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>  
                    <span class="n">len</span><span class="o">++;</span> <span class="c1">// 读取长度加1  </span>
                <span class="o">}</span>  
                <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">temp</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span> <span class="c1">// 将字符数组变为String  </span>
                <span class="n">price</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="na">readFloat</span><span class="o">();</span> <span class="c1">// 读取价格  </span>
                <span class="n">dis</span><span class="o">.</span><span class="na">readChar</span><span class="o">();</span> <span class="c1">// 读取\t  </span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">dis</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span> <span class="c1">// 读取int  </span>
                <span class="n">dis</span><span class="o">.</span><span class="na">readChar</span><span class="o">();</span> <span class="c1">// 读取\n  </span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"名称：%s;价格：%5.2f;数量：%d\n"</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>  
            <span class="o">}</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">}</span>  
        <span class="n">dis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>  执行结果：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>名称：衬衣;价格：98.30;数量：3
名称：手套;价格：30.30;数量：2
名称：围巾;价格：50.50;数量：1
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">DataInputStream</code>读取字符串,只能通过<code class="language-plaintext highlighter-rouge">readchar(),</code>一个个读取,不像<code class="language-plaintext highlighter-rouge">DataOutpputStream</code>一样还区分<code class="language-plaintext highlighter-rouge">writechars()</code>,<code class="language-plaintext highlighter-rouge">writechar()</code>。</p><h2 id="使用files">使用Files</h2><p>  从<strong>JDK 7</strong>开始，提供了<code class="language-plaintext highlighter-rouge">Files</code>这个工具类，能极大地方便我们读写文件。<br />   Java标准库还提供了一个<code class="language-plaintext highlighter-rouge">Path</code>对象，它位于<code class="language-plaintext highlighter-rouge">java.nio.file</code>包。<code class="language-plaintext highlighter-rouge">Path</code>对象和<code class="language-plaintext highlighter-rouge">File</code>对象类似，但操作更加简单.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span> <span class="n">p1</span> <span class="o">=</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"."</span><span class="o">,</span> <span class="s">"project"</span><span class="o">,</span> <span class="s">"study"</span><span class="o">);</span> <span class="c1">// 构造一个Path对象</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">toAbsolutePath</span><span class="o">();</span> <span class="c1">// 转换为绝对路径</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">);</span>
<span class="nc">Path</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">normalize</span><span class="o">();</span> <span class="c1">// 转换为规范路径</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p3</span><span class="o">);</span>
<span class="nc">File</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p3</span><span class="o">.</span><span class="na">toFile</span><span class="o">();</span> <span class="c1">// 转换为File对象</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Path</span> <span class="n">p</span> <span class="o">:</span> <span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">".."</span><span class="o">).</span><span class="na">toAbsolutePath</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 可以直接遍历Path</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  "</span> <span class="o">+</span> <span class="n">p</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  如果需要对目录进行复杂的拼接、遍历等操作，使用<code class="language-plaintext highlighter-rouge">Path</code>对象更方便。<br />   虽然<code class="language-plaintext highlighter-rouge">Files</code>是<code class="language-plaintext highlighter-rouge">java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code class="language-plaintext highlighter-rouge">byte[]</code>，可以这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">));</span>
</code></pre></div></div><p>  如果是文本文件，可以把一个文件的全部内容读取为<code class="language-plaintext highlighter-rouge">String</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 默认使用UTF-8编码读取:</span>
<span class="nc">String</span> <span class="n">content1</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readString</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">));</span>
<span class="c1">// 可指定编码:</span>
<span class="nc">String</span> <span class="n">content2</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readString</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path"</span><span class="o">,</span> <span class="s">"to"</span><span class="o">,</span> <span class="s">"file.txt"</span><span class="o">),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">ISO_8859_1</span><span class="o">);</span>
<span class="c1">// 按行读取并返回每行内容:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">readAllLines</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">));</span>
</code></pre></div></div><p>  写入文件也非常方便：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写入二进制文件:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">),</span> <span class="n">data</span><span class="o">);</span>
<span class="c1">// 写入文本并指定编码:</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">),</span> <span class="s">"文本内容..."</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">ISO_8859_1</span><span class="o">);</span>
<span class="c1">// 按行写入文本:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">Files</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Path</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"/path/to/file.txt"</span><span class="o">),</span> <span class="n">lines</span><span class="o">);</span>
</code></pre></div></div><p>  此外，<code class="language-plaintext highlighter-rouge">Files</code>工具类还有<code class="language-plaintext highlighter-rouge">copy()</code>、<code class="language-plaintext highlighter-rouge">delete()</code>、<code class="language-plaintext highlighter-rouge">exists()</code>、<code class="language-plaintext highlighter-rouge">move()</code>等快捷方法操作文件和目录。<br />   最后需要特别注意的是，<code class="language-plaintext highlighter-rouge">Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://acteds.github.io" target="_blank">acteds</a></li><li>本文链接：<a href="https://acteds.github.io/2021/03/16/IO/" target="_blank">https://acteds.github.io/2021/03/16/IO/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://acteds.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://acteds.github.io/assets/search_data.json?v=1712911176', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://acteds.github.io/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2023 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://acteds.github.io/" title="首页" target="">首页</a></li><li> <a href="https://acteds.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://acteds.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://acteds.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://acteds.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://acteds.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
