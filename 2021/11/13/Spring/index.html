<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Spring &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/11/13/Spring/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="Spring"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言"><meta name="og:description" content="引言"><meta property="og:url" content="/2021/11/13/Spring/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-11-13"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Spring"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Spring</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/11/13 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 74832 字，约 214 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>Spring框架笔记。</p><h1 id="spring">Spring</h1><p>Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。</p><p>Spring Framework主要包括几个模块：</p><ul><li>支持IoC和AOP的容器；</li><li>支持JDBC和ORM的数据访问模块；</li><li>支持声明式事务的模块；</li><li>支持基于Servlet的MVC开发；</li><li>支持基于Reactive的Web开发；</li><li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li></ul><h2 id="ioc">IoC</h2><p>容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p><p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p><p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p><p>IoC全称Inversion of Control，直译为控制反转。</p><p>假定一个在线书店，通过<code class="language-plaintext highlighter-rouge">BookService</code>获取书籍：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">DataSource</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>

    <span class="kd">public</span> <span class="nc">Book</span> <span class="nf">getBook</span><span class="o">(</span><span class="kt">long</span> <span class="n">bookId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="na">getConnection</span><span class="o">())</span> <span class="o">{</span>
            <span class="o">...</span>
            <span class="k">return</span> <span class="n">book</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为了从数据库查询书籍，<code class="language-plaintext highlighter-rouge">BookService</code>持有一个<code class="language-plaintext highlighter-rouge">DataSource</code>。为了实例化一个<code class="language-plaintext highlighter-rouge">HikariDataSource</code>，又不得不实例化一个<code class="language-plaintext highlighter-rouge">HikariConfig</code>。</p><p>现在，继续编写<code class="language-plaintext highlighter-rouge">UserService</code>获取用户：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">DataSource</span> <span class="n">dataSource</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>

    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">getUser</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="na">getConnection</span><span class="o">())</span> <span class="o">{</span>
            <span class="o">...</span>
            <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因为<code class="language-plaintext highlighter-rouge">UserService</code>也需要访问数据库，因此，不得不也实例化一个<code class="language-plaintext highlighter-rouge">HikariDataSource</code>。</p><p>上述每个组件都采用了一种简单的通过<code class="language-plaintext highlighter-rouge">new</code>创建实例并持有的方式。会有以下缺点：</p><ol><li>实例化一个组件其实很难，例如，<code class="language-plaintext highlighter-rouge">BookService</code>和<code class="language-plaintext highlighter-rouge">UserService</code>要创建<code class="language-plaintext highlighter-rouge">HikariDataSource</code>，实际上需要读取配置，才能先实例化<code class="language-plaintext highlighter-rouge">HikariConfig</code>，再实例化<code class="language-plaintext highlighter-rouge">HikariDataSource</code>。</li><li>没有必要让<code class="language-plaintext highlighter-rouge">BookService</code>和<code class="language-plaintext highlighter-rouge">UserService</code>分别创建<code class="language-plaintext highlighter-rouge">DataSource</code>实例，完全可以共享同一个<code class="language-plaintext highlighter-rouge">DataSource</code>，但谁负责创建<code class="language-plaintext highlighter-rouge">DataSource</code>，谁负责获取其他组件已经创建的<code class="language-plaintext highlighter-rouge">DataSource</code>，不好处理。</li><li>很多组件需要销毁以便释放资源，例如<code class="language-plaintext highlighter-rouge">DataSource</code>，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li><li>测试某个组件，例如<code class="language-plaintext highlighter-rouge">BookService</code>，是复杂的，因为必须要在真实的数据库环境下执行。</li></ol><p>如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p><p>因此，核心问题是：谁负责创建组件？谁负责根据依赖关系组装组件？销毁时，如何按依赖顺序正确销毁？解决这一问题的核心方案就是IoC。</p><p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p><p><code class="language-plaintext highlighter-rouge">CartServlet</code>创建了<code class="language-plaintext highlighter-rouge">BookService</code>，在创建<code class="language-plaintext highlighter-rouge">BookService</code>的过程中，又创建了<code class="language-plaintext highlighter-rouge">DataSource</code>组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p><p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code class="language-plaintext highlighter-rouge">BookService</code>自己并不会创建<code class="language-plaintext highlighter-rouge">DataSource</code>，而是等待外部通过<code class="language-plaintext highlighter-rouge">setDataSource()</code>方法来注入一个<code class="language-plaintext highlighter-rouge">DataSource</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDataSource</span><span class="o">(</span><span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>不直接<code class="language-plaintext highlighter-rouge">new</code>一个<code class="language-plaintext highlighter-rouge">DataSource</code>，而是注入一个<code class="language-plaintext highlighter-rouge">DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p><ol><li><code class="language-plaintext highlighter-rouge">BookService</code>不再关心如何创建<code class="language-plaintext highlighter-rouge">DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li><li><code class="language-plaintext highlighter-rouge">DataSource</code>实例被注入到<code class="language-plaintext highlighter-rouge">BookService</code>，同样也可以注入到<code class="language-plaintext highlighter-rouge">UserService</code>，因此，共享一个组件非常简单；</li><li>测试<code class="language-plaintext highlighter-rouge">BookService</code>更容易，因为注入的是<code class="language-plaintext highlighter-rouge">DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li></ol><p>IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p><p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;beans&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource"</span> <span class="na">class=</span><span class="s">"HikariDataSource"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"bookService"</span> <span class="na">class=</span><span class="s">"BookService"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"userService"</span> <span class="na">class=</span><span class="s">"UserService"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div><p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code class="language-plaintext highlighter-rouge">dataSource</code>的组件通过属性<code class="language-plaintext highlighter-rouge">dataSource</code>（即调用<code class="language-plaintext highlighter-rouge">setDataSource()</code>方法）注入到另外两个组件中。</p><p>依赖注入可以通过<code class="language-plaintext highlighter-rouge">set()</code>方法实现，也可以通过构造方法实现。</p><p>把<code class="language-plaintext highlighter-rouge">BookService</code>改造为通过构造方法注入，那么实现代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BookService</span><span class="o">(</span><span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dataSource</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p><ol><li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li><li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li></ol><h3 id="ioc装配">IoC装配</h3><p>首先引入依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-context<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.0.2.RELEASE<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>测试代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>编写一个特定的<code class="language-plaintext highlighter-rouge">application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span> <span class="nt">&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">"0"</span> <span class="na">ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div><hr /><h3 id="bean的配置">Bean的配置</h3><p>在 Spring中，XML配置文件的根元素是<code class="language-plaintext highlighter-rouge">&lt; beans&gt;</code>，其下包含了<code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code>子元素，每个<code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code>子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中。</p><p><code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code>元素中包含了多个<em>属性</em>。其常用属性如下：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>id</td><td>实例化对象名称</td></tr><tr><td>name</td><td>可以为bean指定多个名称，用逗号分隔</td></tr><tr><td>class</td><td>类文件的全局名称</td></tr><tr><td>scope</td><td>实例的生存空间或有效范围</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code>元素中同样包含了多个<em>子</em>元素，其子元素如下</p><p><code class="language-plaintext highlighter-rouge">constructor-arg</code>、<code class="language-plaintext highlighter-rouge">property</code>、<code class="language-plaintext highlighter-rouge">ref</code>、<code class="language-plaintext highlighter-rouge">value</code>、<code class="language-plaintext highlighter-rouge">list</code>、<code class="language-plaintext highlighter-rouge">set</code>、<code class="language-plaintext highlighter-rouge">map</code>、<code class="language-plaintext highlighter-rouge">entry</code></p><h3 id="bean的实例化">Bean的实例化</h3><p><strong>构造方法实例化，使用类的无参数构造创建</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">"testdemo"</span> <span class="kd">class</span><span class="err">="</span><span class="nc">dao</span><span class="o">.</span><span class="na">TestDemo</span><span class="err">"</span><span class="o">&gt;&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</code></pre></div></div><p><strong>使用静态工厂实例化</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">"b2"</span> <span class="kd">class</span><span class="err">="</span><span class="nc">SpringBean</span><span class="o">.</span><span class="na">Factory</span><span class="s">" factory-method="</span><span class="n">newBean</span><span class="err">"</span><span class="o">/&gt;</span>
</code></pre></div></div><p>参数：id 实例化对象名称，class 静态工厂绝对名称，factory-method 工厂的静态方法名称</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Bean</span> <span class="nf">newBean</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="k">new</span> <span class="nc">Bean</span><span class="o">();}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ap</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"Factory.xml"</span><span class="o">);</span>
        <span class="n">ap</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"b2"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Bean</span><span class="o">{}</span>
</code></pre></div></div><p><strong>实例工厂实例化</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">"factory"</span> <span class="kd">class</span><span class="err">="</span><span class="nc">SpringBean</span><span class="o">.</span><span class="na">Factory</span><span class="s">" /&gt;
&lt;bean id="</span><span class="n">b3</span><span class="s">" factory-bean="</span><span class="n">factory</span><span class="s">" factory-method="</span><span class="n">newBean2</span><span class="err">"</span><span class="o">/&gt;</span>
</code></pre></div></div><p>参数：id 实例化对象名称，factory-bean 实例化的工厂名称，factory-method 工厂的方法名称</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Bean</span> <span class="nf">newBean2</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="k">new</span> <span class="nc">Bean</span><span class="o">();}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ap</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"Factory.xml"</span><span class="o">);</span>
        <span class="n">ap</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"b3"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Bean</span><span class="o">{}</span>
</code></pre></div></div><h3 id="注入方式">注入方式</h3><p>对于构造方法注入，通过设置<code class="language-plaintext highlighter-rouge">constructor-arg</code>标签完成：</p><p><code class="language-plaintext highlighter-rouge">constructor-arg</code>参数:<code class="language-plaintext highlighter-rouge">type</code> 形参类型，<code class="language-plaintext highlighter-rouge">name</code> 形参变量名，<code class="language-plaintext highlighter-rouge">value</code> 属性值，<code class="language-plaintext highlighter-rouge">ref</code> 引用实例对象，<code class="language-plaintext highlighter-rouge">index</code> 索引值。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">"0"</span> <span class="na">ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><ul><li>每个<code class="language-plaintext highlighter-rouge">&lt;bean ...&gt;</code>都有一个<code class="language-plaintext highlighter-rouge">id</code>标识，相当于Bean的唯一ID；</li><li>在<code class="language-plaintext highlighter-rouge">a</code>Bean中，通过<code class="language-plaintext highlighter-rouge">&lt;constructor-arg index="0" ref="b"/&gt;</code>以<strong>构造方法注入</strong>了另一个<code class="language-plaintext highlighter-rouge">b</code>Bean；</li><li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li></ul><p>把上述XML配置文件用Java代码写出来，就像这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">B</span> <span class="n">b</span><span class="o">=</span><span class="k">new</span> <span class="no">B</span><span class="o">();</span>
<span class="no">A</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</code></pre></div></div><p>只不过Spring容器是通过读取XML文件后使用反射完成的。</p><p>其实这里不写<code class="language-plaintext highlighter-rouge">constructor-arg</code>，也可以，在 Spring XML 配置文件中，如果类 <code class="language-plaintext highlighter-rouge">A</code> 只有<strong>一个构造函数</strong>，并且这个构造函数需要一个 <code class="language-plaintext highlighter-rouge">B</code> 类型的参数，Spring 会自动匹配并注入所需的依赖。因此，如果只有一个构造函数并且只有一个参数类型可以匹配，则<strong>可以省略</strong> <code class="language-plaintext highlighter-rouge">&lt;constructor-arg&gt;</code> 标签。</p><p>还可以使用c命名空间简化注入,对应<code class="language-plaintext highlighter-rouge">constructor-arg</code>。</p><p><code class="language-plaintext highlighter-rouge">beans</code>标签添加属性: <code class="language-plaintext highlighter-rouge">xmlns:c="http://www.springframework.org/schema/c"</code>。</p><p>使用c命名空间，直接在bean添加参数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">"a1"</span> <span class="kd">class</span><span class="err">="</span><span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">A</span><span class="s">" c:_0-ref="</span><span class="n">b</span><span class="s">"/&gt;
&lt;bean id="</span><span class="n">a2</span><span class="s">" class="</span><span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">A</span><span class="s">" c:b-ref="</span><span class="n">b</span><span class="err">"</span><span class="o">/&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">c:_索引值</code> 对应 <code class="language-plaintext highlighter-rouge">index="索引值"</code>， 加<code class="language-plaintext highlighter-rouge">-ref</code>表示引用实例对象</p><p><code class="language-plaintext highlighter-rouge">c:形参变量名</code> 对应 <code class="language-plaintext highlighter-rouge">name="形参变量名"</code>,加<code class="language-plaintext highlighter-rouge">-ref</code>表示引用实例对象，不加则是设置普通数据类型，上面的式子如果不加，则<code class="language-plaintext highlighter-rouge">"b"</code>视为字符串。</p><p>需要注意的是<code class="language-plaintext highlighter-rouge">c:b-ref</code>这种方式只对以debug方式编译的class有效，因为对于非debug方式编译的class文件Spring将无法获取到对应构造方法的<code class="language-plaintext highlighter-rouge">参数名</code>，因为被优化掉了。之前在JavaWeb有说，可以设置编译器参数：<code class="language-plaintext highlighter-rouge">-parameters</code>，保留形参变量名。</p><hr /><p>对于set方法注入，通过设置<code class="language-plaintext highlighter-rouge">property</code>标签完成：</p><p>如果要改成<strong>通过<code class="language-plaintext highlighter-rouge">set</code>方法注入</strong>，则xml修改为：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"b"</span> <span class="na">ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">property</code>参数： <code class="language-plaintext highlighter-rouge">name</code> 变量名，<code class="language-plaintext highlighter-rouge">value</code> 属性值，<code class="language-plaintext highlighter-rouge">ref</code> 引用实例对象。</p><p>同样的，可以使用p命名空间简化注入,对应<code class="language-plaintext highlighter-rouge">property</code>。</p><p><code class="language-plaintext highlighter-rouge">beans</code>标签添加属性: <code class="language-plaintext highlighter-rouge">xmlns:p="http://www.springframework.org/schema/p"</code>。</p><p>使用p命名空间，直接在bean添加参数：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span> <span class="na">p:b-ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">p:变量名</code> 对应 <code class="language-plaintext highlighter-rouge">name="变量名"</code>，加<code class="language-plaintext highlighter-rouge">-ref</code>表示引用实例对象。</p><p>注意：<code class="language-plaintext highlighter-rouge">property</code>对应的是set方法，而<strong>不是</strong>对应的属性。如<code class="language-plaintext highlighter-rouge">name="world"</code>实际对应<code class="language-plaintext highlighter-rouge">setWorld()</code>方法，这个时候<strong>不管</strong>是否真的存在名为<code class="language-plaintext highlighter-rouge">world</code>的属性.</p><hr /><h3 id="自动装配">自动装配</h3><p>Spring的<code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code>元素中包含个 <code class="language-plaintext highlighter-rouge">autowire</code>属性，可通过设置 <code class="language-plaintext highlighter-rouge">autowire</code>的属性来自动装配Bean。自动装配，就是将一个Bean注入到其他Bean的Property中。autowire属性值及说明如下:</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>default</td><td>默认值。</td></tr><tr><td>byName</td><td>根据 Property的Name自动装配。</td></tr><tr><td>byType</td><td>根据 Property的数据类型（TYPE）自动装配</td></tr><tr><td>constructor</td><td>根据构造函数参数的数据类型。</td></tr><tr><td>autodetect</td><td>如果发现默认的构造函数，用constructor模式，否则用byType模式</td></tr><tr><td>no</td><td>不适用自动装配，Bean依赖必须通过ref元素定义。</td></tr></tbody></table><p>默认情况下，<code class="language-plaintext highlighter-rouge">autowire</code>属性的默认值为<code class="language-plaintext highlighter-rouge">default</code>。默认情况下Spring会根据<code class="language-plaintext highlighter-rouge">byName</code>的方式进行自动装配。如果Spring在容器中找到与属性名相同的Bean，则会将该Bean注入到相应的属性中。如果找不到与属性名相同的Bean，Spring会抛出<code class="language-plaintext highlighter-rouge">NoSuchBeanDefinitionException</code>异常。</p><h3 id="注入的类型">注入的类型</h3><p>如果注入的不是Bean，而是<code class="language-plaintext highlighter-rouge">boolean</code>、<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">String</code>这样的数据类型，则通过设置<code class="language-plaintext highlighter-rouge">value</code>注入（构造方法注入同理），例如，创建一个<code class="language-plaintext highlighter-rouge">HikariDataSource</code>：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource"</span> <span class="na">class=</span><span class="s">"com.zaxxer.hikari.HikariDataSource"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"jdbcUrl"</span> <span class="na">value=</span><span class="s">"jdbc:mysql://localhost:3306/test"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"root"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"password"</span> <span class="na">value=</span><span class="s">"password"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"maximumPoolSize"</span> <span class="na">value=</span><span class="s">"10"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"autoCommit"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><p>如果是Map类型，则通过嵌套<code class="language-plaintext highlighter-rouge">map</code>标签进行设置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"map"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;map&gt;</span>
            <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"1"</span> <span class="na">value=</span><span class="s">"唱"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"2"</span> <span class="na">value=</span><span class="s">"跳"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"3"</span> <span class="na">value=</span><span class="s">"RAP"</span> <span class="na">value-type=</span><span class="s">"java.lang.String"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/map&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><p>如果是List类型，则通过嵌套<code class="language-plaintext highlighter-rouge">list</code>标签进行设置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">ref=</span><span class="s">"b"</span> <span class="na">index=</span><span class="s">"0"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"list"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;list&gt;&lt;value&gt;</span>唱<span class="nt">&lt;/value&gt;&lt;value&gt;</span>跳<span class="nt">&lt;/value&gt;&lt;value&gt;</span>RAR<span class="nt">&lt;/value&gt;&lt;/list&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><p>如果是Set类型，则通过嵌套<code class="language-plaintext highlighter-rouge">set</code>标签进行设置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"set"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;set&gt;&lt;value</span> <span class="nt">&gt;</span>唱<span class="nt">&lt;/value&gt;&lt;value&gt;</span>跳<span class="nt">&lt;/value&gt;&lt;value&gt;</span>RAR<span class="nt">&lt;/value&gt;&lt;/set&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><p>前面有说name属性对应的是set方法，这里是<code class="language-plaintext highlighter-rouge">"set"</code>,所以对应<code class="language-plaintext highlighter-rouge">setList</code>方法，也可以改成其他的名字。</p><p>如果是数组，则通过嵌套<code class="language-plaintext highlighter-rouge">array</code>标签进行设置：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"list"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;array&gt;&lt;value&gt;</span>唱<span class="nt">&lt;/value&gt;&lt;value&gt;</span>跳<span class="nt">&lt;/value&gt;&lt;value&gt;</span>RAR<span class="nt">&lt;/value&gt;&lt;/array&gt;</span>
    <span class="nt">&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div><p>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">call</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">call</span> <span class="o">=</span> <span class="o">(</span><span class="no">B</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"key1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setArray</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">map</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">call</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>application.xml：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">"0"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;map&gt;</span>
                <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"1"</span> <span class="na">value=</span><span class="s">"唱"</span><span class="nt">/&gt;</span>
                <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"2"</span> <span class="na">value=</span><span class="s">"跳"</span><span class="nt">/&gt;</span>
                <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"3"</span> <span class="na">value=</span><span class="s">"RAP"</span> <span class="na">value-type=</span><span class="s">"java.lang.String"</span><span class="nt">/&gt;</span>
                <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"4"</span> <span class="na">value=</span><span class="s">"1"</span> <span class="na">value-type=</span><span class="s">"java.lang.Integer"</span><span class="nt">/&gt;</span>
                <span class="nt">&lt;entry</span> <span class="na">key=</span><span class="s">"key1"</span> <span class="na">value-ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;/map&gt;</span>
        <span class="nt">&lt;/constructor-arg&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"array"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;array&gt;&lt;value&gt;</span>唱<span class="nt">&lt;/value&gt;&lt;value&gt;</span>跳<span class="nt">&lt;/value&gt;&lt;value&gt;</span>RAR<span class="nt">&lt;/value&gt;&lt;/array&gt;</span>
        <span class="nt">&lt;/property&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1=唱, 2=跳, 3=RAP, 4=1, key1=com.aotmd.test.B@53de625d}
[唱, 跳, RAR]
hello
</code></pre></div></div><h3 id="applicationcontext">ApplicationContext</h3><p>Spring容器就是<code class="language-plaintext highlighter-rouge">ApplicationContext</code>，它是一个接口，有很多实现类，这里选择<code class="language-plaintext highlighter-rouge">ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p><p>获得了<code class="language-plaintext highlighter-rouge">ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code class="language-plaintext highlighter-rouge">ApplicationContext</code>中可以根据Bean的ID获取Bean，也可以根据Bean的类型获取Bean的引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
<span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
</code></pre></div></div><p>Spring还提供另一种IoC容器叫<code class="language-plaintext highlighter-rouge">BeanFactory</code>，使用方式和<code class="language-plaintext highlighter-rouge">ApplicationContext</code>类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BeanFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">XmlBeanFactory</span><span class="o">(</span><span class="k">new</span> <span class="nc">ClassPathResource</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">));</span>
<span class="no">A</span> <span class="n">a</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">BeanFactory</code>和<code class="language-plaintext highlighter-rouge">ApplicationContext</code>的区别在于，<code class="language-plaintext highlighter-rouge">BeanFactory</code>的实现是<strong>按需创建</strong>，即第一次获取Bean时才创建这个Bean，而<code class="language-plaintext highlighter-rouge">ApplicationContext</code>会一次性创建所有的Bean。实际上，<code class="language-plaintext highlighter-rouge">ApplicationContext</code>接口是从<code class="language-plaintext highlighter-rouge">BeanFactory</code>接口继承而来的，并且，<code class="language-plaintext highlighter-rouge">ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，总是使用<code class="language-plaintext highlighter-rouge">ApplicationContext</code>，很少会考虑使用<code class="language-plaintext highlighter-rouge">BeanFactory</code>。</p><hr /><p>创建 <code class="language-plaintext highlighter-rouge">ApplicationContext</code>接口实例通常有三种方法：</p><p><strong>通过<code class="language-plaintext highlighter-rouge">ClassPathXmlApplicationContext</code>创建</strong> <code class="language-plaintext highlighter-rouge">ClassPathXmlApplicationContext</code>将从类路径classPath目录寻找指定的XML配置文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
</code></pre></div></div><p><strong>通过<code class="language-plaintext highlighter-rouge">FileSystemXmlApplicationContext</code>创建</strong></p><p><code class="language-plaintext highlighter-rouge">FileSystemXmlApplicationContext</code>将从指定文件的<strong>绝对路径</strong>中寻找XML配置文件，找到并装载完成<code class="language-plaintext highlighter-rouge">ApplicationContext</code>的实例化工作。采用绝对路径的加载方式将导致程序的灵活性变差， 一般<strong>不推荐使用</strong>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileSystemXmlApplicationContext</span><span class="o">(</span><span class="s">"C:\\XXX\\application.xml"</span><span class="o">);</span>
</code></pre></div></div><p><strong>通过Web服务器实例化<code class="language-plaintext highlighter-rouge">ApplicationContext</code>容器</strong></p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;context-param&gt;</span>
    <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
    <span class="nt">&lt;param-value&gt;</span>classpath:application.xml<span class="nt">&lt;/param-value&gt;</span>
<span class="nt">&lt;/context-param&gt;</span>
</code></pre></div></div><p>如果有多个Spring配置文件，则在<code class="language-plaintext highlighter-rouge">param-value</code>里，以逗号分隔，如果没有定义则默认加载<code class="language-plaintext highlighter-rouge">/WEB-INF/applicationContext.xml</code>文件，<code class="language-plaintext highlighter-rouge">contextConfigLocation</code>是参数值，固定不变。</p><p>Web服务器实例化<code class="language-plaintext highlighter-rouge">ApplicationContext</code>容器时，一般使用基于<code class="language-plaintext highlighter-rouge">org.springframework.web.context.ContextLoaderListener</code>的实现方法只需要在<code class="language-plaintext highlighter-rouge">web.xml</code>中添加代码:</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;context-param&gt;</span>
    <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
    <span class="nt">&lt;param-value&gt;</span>classpath:application.xml<span class="nt">&lt;/param-value&gt;</span>
<span class="nt">&lt;/context-param&gt;</span>
<span class="nt">&lt;listener&gt;</span>
    <span class="nt">&lt;listener-class&gt;</span>
        org.springframework.web.context.ContextLoaderListener
    <span class="nt">&lt;/listener-class&gt;</span>
<span class="nt">&lt;/listener&gt;</span>
</code></pre></div></div><p>需要web依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-web<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.0.2.RELEASE<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>使用，首先<strong>获取<code class="language-plaintext highlighter-rouge">ServletContext</code></strong>，这里列出几种方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ServletContext</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getServletContext</span><span class="o">();</span>
<span class="n">sc</span><span class="o">=((</span><span class="nc">HttpServletRequest</span><span class="o">)</span><span class="n">request</span><span class="o">).</span><span class="na">getSession</span><span class="o">().</span><span class="na">getServletContext</span><span class="o">();</span>
<span class="n">sc</span><span class="o">=</span><span class="k">this</span><span class="o">.</span><span class="na">getServletContext</span><span class="o">();</span>
</code></pre></div></div><p>普通类获取方法（普通类若不经过服务器调用(如servlet调用)则会报<code class="language-plaintext highlighter-rouge">NullPointerException</code>）</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ServletContext</span> <span class="n">sc</span> <span class="o">=</span> <span class="nc">ContextLoader</span><span class="o">.</span><span class="na">getCurrentWebApplicationContext</span><span class="o">().</span><span class="na">getServletContext</span><span class="o">();</span>
</code></pre></div></div><p>然后<strong>通过<code class="language-plaintext highlighter-rouge">ServletContext</code>获取<code class="language-plaintext highlighter-rouge">ApplicationContext</code>：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ApplicationContext</span> <span class="n">ac</span> <span class="o">=</span> <span class="nc">WebApplicationContextUtils</span><span class="o">.</span><span class="na">getWebApplicationContext</span><span class="o">(</span><span class="n">sc</span><span class="o">);</span><span class="c1">// 这种方法 获取失败时返回null</span>
<span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unused"</span><span class="o">)</span>
<span class="nc">WebApplicationContext</span> <span class="n">ctx</span><span class="o">=</span><span class="nc">WebApplicationContextUtils</span><span class="o">.</span><span class="na">getRequiredWebApplicationContext</span><span class="o">(</span><span class="n">sc</span><span class="o">);</span><span class="c1">// 这种方法 获取失败时抛出异常</span>
<span class="n">ac</span> <span class="o">=</span> <span class="nc">WebApplicationContextUtils</span><span class="o">.</span><span class="na">getRequiredWebApplicationContext</span><span class="o">(</span><span class="n">sc</span><span class="o">);</span>
</code></pre></div></div><hr /><p><strong>销毁</strong></p><p>对于手动加载的Spring，<code class="language-plaintext highlighter-rouge">ApplicationContext</code>怎么销毁:</p><p>在非Web应用中，手工加载Spring IoC容器，不能用<code class="language-plaintext highlighter-rouge">ApplicationContext</code>，要用<code class="language-plaintext highlighter-rouge">AbstractApplicationContext</code>。用完以后要记得调用<code class="language-plaintext highlighter-rouge">ctx.close()</code>关闭容器。如果不记得关闭容器，最典型的问题就是数据库连接不能释放。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span><span class="n">appcon</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><h3 id="完整实例">完整实例</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebServlet</span><span class="o">(</span><span class="s">"/test"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="kd">extends</span> <span class="nc">HttpServlet</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ServletException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServletContext</span> <span class="n">servletContext</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getServletContext</span><span class="o">();</span>
        <span class="c1">// 这种方法 获取失败时返回null</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span> <span class="o">=</span> <span class="nc">WebApplicationContextUtils</span><span class="o">.</span><span class="na">getWebApplicationContext</span><span class="o">(</span><span class="n">servletContext</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">call</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCall</span><span class="o">(</span><span class="no">B</span> <span class="n">call</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">call</span> <span class="o">=</span> <span class="n">call</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">call</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>application.xml:</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span> <span class="nt">&gt;</span>
        <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"call"</span> <span class="na">ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div><p>web.xml:</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;web-app</span> <span class="na">xmlns=</span><span class="s">"http://xmlns.jcp.org/xml/ns/javaee"</span>
         <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="na">xsi:schemaLocation=</span><span class="s">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span>
         <span class="na">version=</span><span class="s">"4.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;context-param&gt;</span>
        <span class="nt">&lt;param-name&gt;</span>contextConfigLocation<span class="nt">&lt;/param-name&gt;</span>
        <span class="nt">&lt;param-value&gt;</span>classpath:application.xml<span class="nt">&lt;/param-value&gt;</span>
    <span class="nt">&lt;/context-param&gt;</span>
    <span class="nt">&lt;listener&gt;</span>
        <span class="nt">&lt;listener-class&gt;</span>
            org.springframework.web.context.ContextLoaderListener
        <span class="nt">&lt;/listener-class&gt;</span>
    <span class="nt">&lt;/listener&gt;</span>
<span class="nt">&lt;/web-app&gt;</span>
</code></pre></div></div><h3 id="bean的生命周期">Bean的生命周期</h3><p>在Spring框架中，Bean的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段。Spring提供了多个接口和配置方式，允许开发者在这三个过程的前后进行操作。在Spring中，实例化是为Bean对象分配内存空间，初始化则是对Bean的属性进行设置。</p><p>对于singleton作用域的Bean，Spring容器可以精确地管理其生命周期，包括创建、初始化和销毁。而对于prototype作用域的Bean，Spring只负责创建实例，之后Bean的生命周期由客户端代码管理，Spring容器不再跟踪其状态。</p><p>Spring中Bean的生命周期可以参考Servlet的生命周期模型：实例化→初始化→请求处理→销毁。在singleton作用域下，Bean的生命周期包括以下阶段：</p><ol><li>根据Bean的配置实例化Bean。</li><li>对实例化的Bean进行依赖注入，即对属性进行初始化。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">BeanNameAware</code>接口，将调用其<code class="language-plaintext highlighter-rouge">setBeanName(String beanName)</code>方法，传递的是Bean在Spring配置文件中的id。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">BeanFactoryAware</code>接口，将调用其<code class="language-plaintext highlighter-rouge">setBeanFactory</code>方法，传递的是当前Spring工厂实例的引用。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">BeanFactoryPostProcessor</code>接口，将调用其<code class="language-plaintext highlighter-rouge">postProcessBeanFactory()</code>方法，允许在Bean工厂实例化Bean之前对Bean定义进行修改。实现该接口可以在容器实例化Bean之前对Bean定义进行一些自定义的处理。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">ApplicationContextAware</code>接口，将调用其<code class="language-plaintext highlighter-rouge">setApplicationContext(ApplicationContext)</code>方法，传递的是Spring上下文实例的引用。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">BeanPostProcessor</code>接口，将调用其<code class="language-plaintext highlighter-rouge">postProcessBeforeInitialization(Object obj, String beanName)</code>方法，在Bean初始化前对Bean进行操作。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">InitializingBean</code>接口，将调用其<code class="language-plaintext highlighter-rouge">afterPropertiesSet</code>方法，Bean在属性设置完成后会调用该方法进行初始化操作。</li><li>如果Bean在配置文件中配置了<code class="language-plaintext highlighter-rouge">init-method</code>属性，将自动调用配置的初始化方法。</li><li>如果Bean实现了<code class="language-plaintext highlighter-rouge">BeanPostProcessor</code>接口，将调用其<code class="language-plaintext highlighter-rouge">postProcessBeforeInitialization()</code>和<code class="language-plaintext highlighter-rouge">postProcessAfterInitialization(Object obj, String beanName)</code>方法，允许在Bean初始化前后进行一些自定义处理操作。实现该接口可以在Bean初始化前后对Bean进行一些额外的处理。</li></ol><p>注意：完成上述工作后，Bean可以被使用。由于是singleton作用域，因此调用的是同一个Bean实例。</p><ol><li>当Bean不再需要时，进入销毁阶段。如果Bean实现了<code class="language-plaintext highlighter-rouge">DisposableBean</code>接口，将调用其<code class="language-plaintext highlighter-rouge">destroy</code>方法来销毁Bean。</li><li>如果在配置文件中通过<code class="language-plaintext highlighter-rouge">destroy-method</code>属性指定了Bean的销毁方法，将调用配置的销毁方法进行Bean的销毁操作。</li></ol><p>在Spring中，通过实现特定接口或配置<code class="language-plaintext highlighter-rouge">&lt;bean&gt;</code>元素的属性，开发者可以影响Bean的生命周期过程。建议谨慎使用Bean实现接口，以避免过度耦合代码与Spring框架。</p><h2 id="使用注解">使用注解</h2><p>使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，就可以直接从容器中获取Bean使用它们。</p><p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p><p>还可以使用Annotation配置，让Spring自动扫描Bean并组装它们。</p><p>原代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>xml：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;constructor-arg</span> <span class="na">index=</span><span class="s">"0"</span> <span class="na">ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span> <span class="nt">/&gt;</span>
</code></pre></div></div><p>使用注解后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*默认bean名称为首字母小写*/</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">@Component</code>注解就相当于定义了一个Bean，默认名称为小写开头的类名，可以指定<code class="language-plaintext highlighter-rouge">value</code>显示设置Bean名称。这里是使用构造方法装配，也可以使用<code class="language-plaintext highlighter-rouge">@Autowired</code>把指定类型的Bean注入到指定的字段中，它可以写在set方法上，也可以写在字段上，还可以写在构造方法形参上。如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="nd">@Autowired</span> <span class="no">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>一般把<code class="language-plaintext highlighter-rouge">@Autowired</code>写在字段上：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>对于xml配置部分，通过标注<code class="language-plaintext highlighter-rouge">@Configuration</code>，表示<code class="language-plaintext highlighter-rouge">Test</code>是一个配置类，并且标注<code class="language-plaintext highlighter-rouge">@ComponentScan</code>告诉容器，自动搜索<strong>当前配置类所在的包以及子包</strong>的注解并装配。因此要特别注意包的层次结构。通常来说，启动配置类要位于自定义的顶层包。当然也可以指定要扫描的包<code class="language-plaintext highlighter-rouge">@ComponentScan("com.aotmd.test")</code>，这样就不用特定配置类的位置了。</p><p>如果不想使用配置类，也可以使用xml扫描注解：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.aotmd.test"</span><span class="nt">/&gt;</span>
</code></pre></div></div><p>常用的装配注解：</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>描述Spring中的Bean，但是它时一个泛化的概念，仅仅表示一个组件（Bean）并且可以作用在任何层次；</td></tr><tr><td>@Repository</td><td>用于将数据访问层（DAO）层的类标识为Spring中的Bean</td></tr><tr><td>@Service</td><td>作用在业务层（service层），用于将业务层的类标识为Spring中的Bean</td></tr><tr><td>@Controller</td><td>作用在控制层（如Spring MVC 的 controller层），用于将控制层的类标识为Spring中的Bean</td></tr><tr><td>@Autowired</td><td>该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。 通过@Autowired的使用来消除setter 和getter方法。默认按照Bean的<strong>类型进行装配</strong>。</td></tr><tr><td>@Resource</td><td>该注解与@Autowired功能一样。区别在于，该注解默认是按照<strong>名称</strong>来装配注入的，只有当找不到与名称匹配的Bean才会按照类型来装配注入； @Resource注解有两个属性；name和type。name属性指定Bean实例名称，即按照名称来装配注入；type属性指定Bean类型，即按照Bean的类型进行装配</td></tr><tr><td>@Qualifier</td><td>该注解与@Autowired注解配合使用。当@Autowired注解需要按照<strong>名称</strong>来装配注入，则需要结合该注解一起使用，Bean的实例名称由@Qualifier注解的参数指定。</td></tr></tbody></table><p>注意: @Component @Repository @Service @Controller 注解默认无参数生成的Bean是<strong>首字母小写</strong>的类名,但若<strong>类名第一第二都是大写</strong>则将<strong>类名</strong>做为生成的Bean,若类名首字母是小写则一样以类名作为标识符。</p><p>上面几个注解中，虽然@Repository、@Service和@Controller等注解的功能与@Component相同，但为了使标注类的用途更加清晰（层次化），在实际开发中推荐使用@Repository标注数据访问层（DA0层）、使用@Service标注业务逻辑层（Service层）以及使用@Controller标注控制器层（控制层）。</p><h3 id="configuration">Configuration</h3><p><code class="language-plaintext highlighter-rouge">@Configuration</code>注解用于标识一个类是Spring的配置类，它通常与<code class="language-plaintext highlighter-rouge">@Bean</code>注解一起使用，用于定义Bean的创建和配置。主要作用包括：</p><ol><li><strong>定义Bean</strong>：在配置类中使用<code class="language-plaintext highlighter-rouge">@Bean</code>注解定义Bean的创建方法，Spring容器会根据这些方法创建相应的Bean实例。</li><li><strong>替代XML配置</strong>：<code class="language-plaintext highlighter-rouge">@Configuration</code>注解可以替代传统的XML配置文件，通过Java类的方式来配置应用程序的Bean。</li><li><strong>组件扫描</strong>：<code class="language-plaintext highlighter-rouge">@Configuration</code>注解通常与<code class="language-plaintext highlighter-rouge">@ComponentScan</code>注解一起使用，用于启用组件扫描，自动发现和注册Spring的Bean。</li><li><strong>条件化配置</strong>：可以结合条件注解如<code class="language-plaintext highlighter-rouge">@ConditionalOnProperty</code>等，根据条件来决定是否应用某个配置。</li><li><strong>AOP支持</strong>：<code class="language-plaintext highlighter-rouge">@Configuration</code>类中的方法可以使用<code class="language-plaintext highlighter-rouge">@Bean</code>注解来声明切面等AOP相关的Bean。</li><li><strong>配置属性绑定</strong>：可以使用<code class="language-plaintext highlighter-rouge">@Value</code>注解将配置文件中的属性值注入到<code class="language-plaintext highlighter-rouge">@Configuration</code>类中的Bean中。</li></ol><p>如果没有该注解，也可以正常使用，但它的缺陷是被调用的@Bean方法产生的实例在容器中不是唯一的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a1"</span><span class="o">);</span>
        
    <span class="o">}</span>
    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"a1"</span><span class="o">)</span>
    <span class="no">A</span> <span class="nf">getA</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getB</span><span class="o">()</span> <span class="o">==</span> <span class="n">getB</span><span class="o">());</span> <span class="c1">//结果是false，说明每调用一次getB()都会产生新的实例。加上@Configuration之后结果就是true了。</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="no">B</span> <span class="nf">getB</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">A</span><span class="o">{}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">B</span><span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="prototype">Prototype</h3><p>对于Spring容器来说，把一个Bean标记为<code class="language-plaintext highlighter-rouge">@Component</code>后，它就会自动创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，调用<code class="language-plaintext highlighter-rouge">getBean(Class)</code>获取到的Bean总是同一个实例。</p><p>还有一种Bean，每次调用<code class="language-plaintext highlighter-rouge">getBean(Class)</code>，容器都返回一个<strong>新的实例</strong>，这种Bean称为Prototype（原型），它的生命周期和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code class="language-plaintext highlighter-rouge">@Scope</code>注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Scope</span><span class="o">(</span><span class="nc">ConfigurableBeanFactory</span><span class="o">.</span><span class="na">SCOPE_PROTOTYPE</span><span class="o">)</span><span class="c1">//"prototype"</span>
</code></pre></div></div><p>即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a1</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="no">A</span> <span class="n">a2</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">==</span><span class="n">a2</span><span class="o">);</span><span class="c1">//false</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*默认bean名称为首字母小写*/</span>
<span class="nd">@Component</span>
<span class="nd">@Scope</span><span class="o">(</span><span class="nc">ConfigurableBeanFactory</span><span class="o">.</span><span class="na">SCOPE_PROTOTYPE</span><span class="o">)</span><span class="c1">//"prototype"</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">B</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>具体来说有如下几个作用域：</p><table><thead><tr><th><strong>作用域名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td>默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例。</td></tr><tr><td><strong>prototype</strong></td><td>Spring容器每次获取prototype定义的Bean，容器都将创建一个新的Bean实例。</td></tr><tr><td><strong>request</strong></td><td>在一次HTTP请求中容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用。</td></tr><tr><td><strong>session</strong></td><td>在一个HTTP Session中，容器将返回同一个Bean实例。仅在Web Spring应用程序上下文中使用。</td></tr><tr><td><strong>application</strong></td><td>为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例。仅在Web Spring应用程序上下文中使用。</td></tr><tr><td><strong>websocket</strong></td><td>为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用。</td></tr></tbody></table><h3 id="注入list">注入List</h3><p>有些时候，会有一系列接口相同，不同实现类的Bean。例如，注册用户时，要对<code class="language-plaintext highlighter-rouge">email</code>、<code class="language-plaintext highlighter-rouge">password</code>和<code class="language-plaintext highlighter-rouge">name</code>这3个变量进行验证。为了便于扩展，先定义验证接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Validator</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>然后，分别使用3个<code class="language-plaintext highlighter-rouge">Validator</code>对用户参数进行验证：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">EmailValidator</span> <span class="kd">implements</span> <span class="nc">Validator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">user</span><span class="o">.</span><span class="na">email</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">"^[a-z0-9]+@[a-z0-9]+\\.[a-z]{2,10}$"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"invalid email: "</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">email</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">PasswordValidator</span> <span class="kd">implements</span> <span class="nc">Validator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">user</span><span class="o">.</span><span class="na">password</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">"^.{6,20}$"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"invalid password"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">NameValidator</span> <span class="kd">implements</span> <span class="nc">Validator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">user</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">trim</span><span class="o">().</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">user</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"invalid name: "</span> <span class="o">+</span> <span class="n">user</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>最后，通过一个<code class="language-plaintext highlighter-rouge">Validators</code>作为入口进行验证：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">Validators</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Validator</span><span class="o">&gt;</span> <span class="n">validators</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">validate</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">validator</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">validators</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">validator</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>启动：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">Validators</span> <span class="n">validators</span><span class="o">=</span> <span class="o">(</span><span class="nc">Validators</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"validators"</span><span class="o">);</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"123@qq.com"</span><span class="o">,</span> <span class="s">"123123"</span><span class="o">,</span> <span class="s">"45ddf"</span><span class="o">);</span>
        <span class="n">validators</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Validators</code>被注入了一个<code class="language-plaintext highlighter-rouge">List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code class="language-plaintext highlighter-rouge">Validator</code>的Bean装配为一个<code class="language-plaintext highlighter-rouge">List</code>注入进来，这样一来，每新增一个<code class="language-plaintext highlighter-rouge">Validator</code>类型，就自动被Spring装配到<code class="language-plaintext highlighter-rouge">Validators</code>中了，非常方便。</p><p>因为Spring是通过扫描classpath获取到所有的Bean，而<code class="language-plaintext highlighter-rouge">List</code>是有序的，要指定<code class="language-plaintext highlighter-rouge">List</code>中Bean的顺序，可以加上<code class="language-plaintext highlighter-rouge">@Order</code>注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Order</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">EmailValidator</span> <span class="kd">implements</span> <span class="nc">Validator</span> <span class="o">{}</span>
<span class="nd">@Order</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">PasswordValidator</span> <span class="kd">implements</span> <span class="nc">Validator</span> <span class="o">{}</span>
<span class="nd">@Order</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">NameValidator</span> <span class="kd">implements</span> <span class="nc">Validator</span> <span class="o">{}</span>
</code></pre></div></div><h3 id="可选注入">可选注入</h3><p>默认情况下，当标记了一个<code class="language-plaintext highlighter-rouge">@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会<strong>抛出<code class="language-plaintext highlighter-rouge">NoSuchBeanDefinitionException</code>异常</strong>。可以给<code class="language-plaintext highlighter-rouge">@Autowired</code>增加一个<code class="language-plaintext highlighter-rouge">required = false</code>的参数，表示如果找不到就忽略，不抛出异常。这种方式非常适合有定义就使用定义，没有就使用默认值的情况。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Autowired</span><span class="o">(</span><span class="n">required</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="创建第三方bean">创建第三方Bean</h3><p>如果想给<code class="language-plaintext highlighter-rouge">A</code>注入<code class="language-plaintext highlighter-rouge">HikariDataSource</code>，但是这个类位于<code class="language-plaintext highlighter-rouge">com.zaxxer.hikari</code>包中，并且<code class="language-plaintext highlighter-rouge">HikariDataSource</code>也不可能有<code class="language-plaintext highlighter-rouge">@Component</code>注解，如何告诉IoC容器创建并配置<code class="language-plaintext highlighter-rouge">HikariDataSource</code>？</p><p>当然是在<code class="language-plaintext highlighter-rouge">@Configuration</code>类中编写一个Java方法创建并返回它，并注意给方法标记一个<code class="language-plaintext highlighter-rouge">@Bean</code>注解，这个方法返回一个<code class="language-plaintext highlighter-rouge">HikariDataSource</code>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">jdbc</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"dataSource"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">HikariDataSource</span> <span class="nf">getDataSource</span><span class="o">(){</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"jdbcUrl"</span><span class="o">,</span><span class="s">"jdbc:mysql://localhost:3306/studentdb?characterEncoding=utf-8&amp;serverTimezone=GMT%2B8&amp;useSSL=false"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span><span class="s">"root"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"password"</span><span class="o">,</span><span class="s">"123456"</span><span class="o">);</span>
        <span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">(</span><span class="n">props</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"cachePrepStmts"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*默认bean名称为首字母小写*/</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">HikariDataSource</span> <span class="n">dataSource</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">jdbc</span><span class="o">(){</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">dataSource</span><span class="o">.</span><span class="na">getConnection</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">ResultSet</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="s">"select name from student"</span><span class="o">).</span><span class="na">executeQuery</span><span class="o">();</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">resultSet</span><span class="o">.</span><span class="na">next</span><span class="o">()){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resultSet</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Spring对标记为<code class="language-plaintext highlighter-rouge">@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p><h3 id="初始化和销毁">初始化和销毁</h3><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。通常会定义一个<code class="language-plaintext highlighter-rouge">init()</code>方法进行初始化，定义一个<code class="language-plaintext highlighter-rouge">shutdown()</code>方法进行清理，需要引入JSR-250定义的Annotation。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.annotation<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.annotation-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>然后在Bean的初始化和清理方法上标记<code class="language-plaintext highlighter-rouge">@PostConstruct</code>和<code class="language-plaintext highlighter-rouge">@PreDestroy</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Init"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Shutdown"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Spring容器会对上述Bean做如下初始化流程：</p><ul><li>调用构造方法创建<code class="language-plaintext highlighter-rouge">A</code>实例；</li><li>根据<code class="language-plaintext highlighter-rouge">@Autowired</code>进行注入；</li><li>调用标记有<code class="language-plaintext highlighter-rouge">@PostConstruct</code>的<code class="language-plaintext highlighter-rouge">init()</code>方法进行初始化。</li></ul><p>而销毁时，容器会首先调用标记有<code class="language-plaintext highlighter-rouge">@PreDestroy</code>的<code class="language-plaintext highlighter-rouge">shutdown()</code>方法。</p><p>Spring只根据Annotation查找<strong>无参数</strong>方法，对方法名不作要求。</p><p>如果shutdown() 没有调用，则需要手动调用<code class="language-plaintext highlighter-rouge">applicationContext.close()</code>，而不是等待进程结束。</p><p>在Spring框架中，Bean的生命周期经历了多个阶段，包括实例化、属性赋值、初始化、使用和销毁等过程。以下是典型的Bean生命周期：</p><ol><li><p><strong>实例化（Instantiation）</strong>：在这个阶段，Spring容器根据Bean的定义创建Bean的实例。</p></li><li><p><strong>属性赋值（Populate Properties）</strong>：在实例化之后，Spring容器会根据配置文件或注解对Bean的属性进行赋值，包括基本类型的注入、引用类型的注入等。</p></li><li><p><strong>初始化（Initialization）</strong>：在属性赋值完成之后，Spring容器会调用Bean的初始化方法（如果有定义的话），可以通过<code class="language-plaintext highlighter-rouge">@PostConstruct</code>注解或实现<code class="language-plaintext highlighter-rouge">InitializingBean</code>接口来定义初始化方法。</p></li><li><p><strong>使用（In Use）</strong>：在初始化完成之后，Bean就可以被应用程序使用了，它会被注入到其他Bean中，或者被直接使用。</p></li><li><p><strong>销毁（Destruction）</strong>：在Bean不再需要的时候，Spring容器会调用Bean的销毁方法（如果有定义的话），可以通过<code class="language-plaintext highlighter-rouge">@PreDestroy</code>注解或实现<code class="language-plaintext highlighter-rouge">DisposableBean</code>接口来定义销毁方法。</p></li></ol><h3 id="使用别名">使用别名</h3><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code class="language-plaintext highlighter-rouge">DataSource</code>实例。</p><p>如果在<code class="language-plaintext highlighter-rouge">@Configuration</code>类中创建了多个同类型的Bean，在Spring 5.0之前的版本中，Spring会报<code class="language-plaintext highlighter-rouge">NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。从Spring 5.0开始，默认情况下，Spring允许存在多个同类型的Bean定义，并且不会抛出异常。相反，它会将这些Bean注册为一个集合类型的Bean。</p><p>要避免这个异常，可以指定不同的名称：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"b1"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="no">B</span> <span class="nf">b</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"b2"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="no">B</span> <span class="nf">b2</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*默认bean名称为首字母小写*/</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"b1"</span><span class="o">)</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>可以用<code class="language-plaintext highlighter-rouge">@Bean("name")</code>指定别名，也可以用<code class="language-plaintext highlighter-rouge">@Bean</code>+<code class="language-plaintext highlighter-rouge">@Qualifier("name")</code>指定别名。</p><p>其实Bean的<code class="language-plaintext highlighter-rouge">name</code>默认就是方法名称。</p><h3 id="注入选择问题">注入选择问题</h3><p>存在多个同类型的Bean时，注入时又会报错，即不知道注入哪个，因此要通过<code class="language-plaintext highlighter-rouge">@Qualifier("b1")</code>指定注入的Bean名称。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"b1"</span><span class="o">)</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这里也可以把两个注解换成 <code class="language-plaintext highlighter-rouge">@Resource(name = "b1")</code>。</p><p>还可以把待注入的<strong>变量名称</strong>改为Bean名称，这样也可以指定注入的Bean名称：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b1</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>也可以通过使用<code class="language-plaintext highlighter-rouge">@Primary</code>指定某个Bean，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code class="language-plaintext highlighter-rouge">@Primary</code>的Bean。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span><span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span><span class="c1">//test为配置文件中的id</span>
        <span class="n">a</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Primary</span>
    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"b1"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="no">B</span> <span class="nf">b</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Bean</span><span class="o">(</span><span class="s">"b2"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="no">B</span> <span class="nf">b2</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*默认bean名称为首字母小写*/</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span><span class="c1">//默认注入b1</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="n">b</span><span class="o">.</span><span class="na">hello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>若使用Spring boot，还能根据配置属性的值来决定是否应用这个配置。即注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ConditionalOnProperty</span><span class="o">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="s">"class"</span><span class="o">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"select"</span><span class="o">,</span> <span class="n">havingValue</span> <span class="o">=</span> <span class="s">"B"</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">B</span><span class="err">｛｝</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">@Configuration</code>：注解表示这是一个配置类，它会被Spring容器扫描并加载。</li><li><code class="language-plaintext highlighter-rouge">@ConditionalOnProperty</code>：注解用于根据配置属性的值来决定是否应用这个配置。它有几个参数：<ul><li><code class="language-plaintext highlighter-rouge">prefix</code>：配置属性的前缀。在这个例子中，配置属性的前缀是<code class="language-plaintext highlighter-rouge">class</code>。</li><li><code class="language-plaintext highlighter-rouge">name</code>：配置属性的名称。在这个例子中，配置属性的名称是<code class="language-plaintext highlighter-rouge">select</code>。</li><li><code class="language-plaintext highlighter-rouge">havingValue</code>：期望的配置属性值。在这个例子中，期望的配置属性值是<code class="language-plaintext highlighter-rouge">B</code>。</li></ul></li></ul><p>如果满足了以上条件，即配置属性<code class="language-plaintext highlighter-rouge">class.select</code>的值为<code class="language-plaintext highlighter-rouge">B</code>，那么这个配置类中的配置将会生效。否则，这个配置类中的配置将会被忽略。</p><h3 id="使用factorybean">使用FactoryBean</h3><p>用工厂模式创建Bean需要实现<code class="language-plaintext highlighter-rouge">FactoryBean</code>接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">BFactoryBean</span> <span class="kd">implements</span> <span class="nc">FactoryBean</span><span class="o">&lt;</span><span class="no">B</span><span class="o">&gt;{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="no">B</span> <span class="nf">getObject</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">B</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">getObjectType</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">B</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当一个Bean实现了<code class="language-plaintext highlighter-rouge">FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code class="language-plaintext highlighter-rouge">getObject()</code>创建真正的Bean。<code class="language-plaintext highlighter-rouge">getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p><p>因此，如果定义了一个<code class="language-plaintext highlighter-rouge">FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code class="language-plaintext highlighter-rouge">FactoryBean</code>的<code class="language-plaintext highlighter-rouge">getObject()</code>方法返回的Bean。为了和普通Bean区分，通常都以<code class="language-plaintext highlighter-rouge">XxxFactoryBean</code>命名。</p><p>由于可以用<code class="language-plaintext highlighter-rouge">@Bean</code>方法创建第三方Bean，本质上<code class="language-plaintext highlighter-rouge">@Bean</code>方法就是工厂方法，所以，<code class="language-plaintext highlighter-rouge">FactoryBean</code>已经用得越来越少了。</p><h3 id="使用resource">使用Resource</h3><p>在Java程序中，经常会读取配置文件、资源文件等。使用Spring容器时，也可以把“文件”注入进来，方便程序读取。</p><p>例如，AppService需要读取<code class="language-plaintext highlighter-rouge">logo.txt</code>这个文件，通常情况下，需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p><p>Spring提供了一个<code class="language-plaintext highlighter-rouge">org.springframework.core.io.Resource</code>（注意不是<code class="language-plaintext highlighter-rouge">jarkata.annotation.Resource</code>或<code class="language-plaintext highlighter-rouge">javax.annotation.Resource</code>），它可以像<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">int</code>一样使用<code class="language-plaintext highlighter-rouge">@Value</code>注入：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"classpath:/application.xml"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Resource</span> <span class="n">resource</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printResource</span><span class="o">(){</span>
        <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span>
                <span class="k">new</span> <span class="nf">InputStreamReader</span><span class="o">(</span><span class="n">resource</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">(),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)))</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">lines</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">"\n"</span><span class="o">)));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>注入<code class="language-plaintext highlighter-rouge">Resource</code>最常用的方式是通过classpath，即类似<code class="language-plaintext highlighter-rouge">classpath:/application.xml</code>表示在classpath中搜索<code class="language-plaintext highlighter-rouge">application.xml</code>文件，然后，直接调用<code class="language-plaintext highlighter-rouge">Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p><p>也可以直接指定文件的路径，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Value</span><span class="o">(</span><span class="s">"file:D:/application.xml"</span><span class="o">)</span>
</code></pre></div></div><h3 id="注入配置">注入配置</h3><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code class="language-plaintext highlighter-rouge">key=value</code>的形式写在<code class="language-plaintext highlighter-rouge">.properties</code>文件中。</p><p>例如，<code class="language-plaintext highlighter-rouge">MailService</code>根据配置的<code class="language-plaintext highlighter-rouge">app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，可以使用上一节的<code class="language-plaintext highlighter-rouge">Resource</code>来读取位于classpath下的一个<code class="language-plaintext highlighter-rouge">app.properties</code>文件。但是，这样仍然比较繁琐。</p><p>Spring容器还提供了一个更简单的<code class="language-plaintext highlighter-rouge">@PropertySource</code>来自动读取配置文件。只需要在<code class="language-plaintext highlighter-rouge">@Configuration</code>配置类上再添加一个注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="nd">@PropertySource</span><span class="o">(</span><span class="s">"classpath:app.properties"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${app.zone:Z}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">zoneId</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">appcon</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">ZoneId</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">appcon</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">print</span><span class="o">();</span>

    <span class="o">}</span>
    <span class="nd">@Bean</span>
    <span class="nc">ZoneId</span> <span class="nf">createZoneId</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
        <span class="k">return</span> <span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*默认bean名称为首字母小写*/</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${app.zone:Z}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">zoneId</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>app.properties：</p><div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">app.zone</span><span class="p">=</span><span class="s">Asia/Shanghai</span>
</code></pre></div></div><p>Spring容器看到<code class="language-plaintext highlighter-rouge">@PropertySource("app.properties")</code>注解后，自动读取这个配置文件，然后，使用<code class="language-plaintext highlighter-rouge">@Value</code>正常注入。</p><p>注入的字符串语法，它的格式如下：</p><ul><li><code class="language-plaintext highlighter-rouge">"${app.zone}"</code>表示读取key为<code class="language-plaintext highlighter-rouge">app.zone</code>的value，如果key不存在，启动将报错；</li><li><code class="language-plaintext highlighter-rouge">"${app.zone:Z}"</code>表示读取key为<code class="language-plaintext highlighter-rouge">app.zone</code>的value，但如果key不存在，就使用默认值<code class="language-plaintext highlighter-rouge">Z</code>。</li></ul><p>这样一来，就可以根据<code class="language-plaintext highlighter-rouge">app.zone</code>的配置来创建<code class="language-plaintext highlighter-rouge">ZoneId</code>。</p><p>还可以把注入的注解写到方法参数中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="nc">ZoneId</span> <span class="nf">createZoneId</span><span class="o">(</span><span class="nd">@Value</span><span class="o">(</span><span class="s">"${app.zone:Z}"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">zoneId</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">@PropertySource</code>读取配置文件，然后通过<code class="language-plaintext highlighter-rouge">@Value</code>以<code class="language-plaintext highlighter-rouge">${key:defaultValue}</code>的形式注入，可以极大地简化读取配置的麻烦。</p><p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code class="language-plaintext highlighter-rouge">SmtpConfig</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${app.zone:Z}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zoneId</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getZoneId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">zoneId</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后，在需要读取的地方，使用<code class="language-plaintext highlighter-rouge">#{appConfig.zoneId}</code>注入：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="nc">ZoneId</span> <span class="nf">createZoneId</span><span class="o">(</span><span class="nd">@Value</span><span class="o">(</span><span class="s">"#{appConfig.zoneId}"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">zoneId</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
    <span class="k">return</span> <span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">zoneId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">#{}</code>这种注入语法，和<code class="language-plaintext highlighter-rouge">${key}</code>不同的是，<code class="language-plaintext highlighter-rouge">#{}</code>表示从JavaBean读取属性。<code class="language-plaintext highlighter-rouge">"#{appConfig.zoneId}"</code>的意思是，从名称为<code class="language-plaintext highlighter-rouge">appConfig</code>的Bean读取<code class="language-plaintext highlighter-rouge">zoneId</code>属性，即调用<code class="language-plaintext highlighter-rouge">getZoneId()</code>方法。</p><p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code class="language-plaintext highlighter-rouge">#{bean.property}</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。如果<code class="language-plaintext highlighter-rouge">appConfig</code>决定从数据库中读取相关配置项，那么<code class="language-plaintext highlighter-rouge">createZoneId</code>注入的<code class="language-plaintext highlighter-rouge">@Value("#{appConfig.zoneId}")</code>仍然可以不修改正常运行。</p><h3 id="使用条件装配">使用条件装配</h3><p>开发应用程序时，会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p><p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。分别定义开发、测试和生产这3个环境：</p><ul><li>native</li><li>test</li><li>production</li></ul><p>创建某个Bean时，Spring容器可以根据注解<code class="language-plaintext highlighter-rouge">@Profile</code>来决定是否创建。例如，以下配置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="nd">@Profile</span><span class="o">(</span><span class="s">"!test"</span><span class="o">)</span>
    <span class="nc">ZoneId</span> <span class="nf">createZoneId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">ZoneId</span><span class="o">.</span><span class="na">systemDefault</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Profile</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
    <span class="nc">ZoneId</span> <span class="nf">createZoneIdForTest</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"America/New_York"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果当前的Profile设置为<code class="language-plaintext highlighter-rouge">test</code>，则Spring容器会调用<code class="language-plaintext highlighter-rouge">createZoneIdForTest()</code>创建<code class="language-plaintext highlighter-rouge">ZoneId</code>，否则，调用<code class="language-plaintext highlighter-rouge">createZoneId()</code>创建<code class="language-plaintext highlighter-rouge">ZoneId</code>。注意到<code class="language-plaintext highlighter-rouge">@Profile("!test")</code>表示非test环境。</p><p>在运行程序时，加上JVM参数<code class="language-plaintext highlighter-rouge">-Dspring.profiles.active=test</code>就可以指定以<code class="language-plaintext highlighter-rouge">test</code>环境启动。</p><p>实际上，Spring允许指定多个Profile，例如：</p><pre><code class="language-cmd">-Dspring.profiles.active=test,master
</code></pre><p>可以表示<code class="language-plaintext highlighter-rouge">test</code>环境，并使用<code class="language-plaintext highlighter-rouge">master</code>分支代码。要满足多个Profile条件，可以这样写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="nd">@Profile</span><span class="o">({</span> <span class="s">"test"</span><span class="o">,</span> <span class="s">"master"</span> <span class="o">})</span> <span class="c1">// 满足test或master</span>
<span class="nc">ZoneId</span> <span class="nf">createZoneId</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>使用Conditional</strong></p><p>除了根据<code class="language-plaintext highlighter-rouge">@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code class="language-plaintext highlighter-rouge">@Conditional</code>决定是否创建某个Bean。添加如下注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span><span class="o">(</span><span class="s">"a1"</span><span class="o">)</span>
<span class="nd">@Conditional</span><span class="o">(</span><span class="nc">MainCondition</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="no">A</span> <span class="nf">getA</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>它的意思是，如果满足<code class="language-plaintext highlighter-rouge">MainCondition</code>的条件，才会创建<code class="language-plaintext highlighter-rouge">a1</code>这个Bean。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MainCondition</span> <span class="kd">implements</span> <span class="nc">Condition</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">matches</span><span class="o">(</span><span class="nc">ConditionContext</span> <span class="n">context</span><span class="o">,</span> <span class="nc">AnnotatedTypeMetadata</span> <span class="n">metadata</span><span class="o">)</span> <span class="o">{</span>
    	<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这里直接返回<code class="language-plaintext highlighter-rouge">false</code>，因此Bean<code class="language-plaintext highlighter-rouge">a1</code>始终不会创建。</p><p>Spring只提供了<code class="language-plaintext highlighter-rouge">@Conditional</code>注解，具体判断逻辑还需要我们自己实现。</p><p>Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code class="language-plaintext highlighter-rouge">app.smtp=true</code>，则创建<code class="language-plaintext highlighter-rouge">a1</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span><span class="o">(</span><span class="s">"a1"</span><span class="o">)</span>
<span class="nd">@ConditionalOnProperty</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"app.smtp"</span><span class="o">,</span> <span class="n">havingValue</span><span class="o">=</span><span class="s">"true"</span><span class="o">)</span>
<span class="no">A</span> <span class="nf">getA</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">@ConditionalOnProperty</code>是Spring Boot框架中的一个条件注解，用于根据属性的存在与否以及属性值来决定是否应该创建一个Bean。该注解有以下参数：</p><ol><li><p><code class="language-plaintext highlighter-rouge">name</code>：要检查的属性名。指定要检查的应用程序属性的名称。如果未指定<code class="language-plaintext highlighter-rouge">prefix</code>，则将直接检查指定名称的属性。如果指定了<code class="language-plaintext highlighter-rouge">prefix</code>，则会在<code class="language-plaintext highlighter-rouge">prefix</code>后面加上<code class="language-plaintext highlighter-rouge">.</code>再加上<code class="language-plaintext highlighter-rouge">name</code>来构成完整的属性名。</p></li><li><p><code class="language-plaintext highlighter-rouge">havingValue</code>：属性必须具有的值。指定属性必须具有的值才能满足条件。默认值为空字符串。</p></li><li><p><code class="language-plaintext highlighter-rouge">matchIfMissing</code>：如果属性不存在时是否应该匹配。指定当属性不存在时是否应该认为条件匹配。默认值为<code class="language-plaintext highlighter-rouge">false</code>，即属性不存在时条件不匹配。</p></li><li><p><code class="language-plaintext highlighter-rouge">prefix</code>：属性名的前缀。指定属性名的前缀，用于构成完整的属性名。</p></li><li><p><code class="language-plaintext highlighter-rouge">value</code>：属性的值。与<code class="language-plaintext highlighter-rouge">havingValue</code>参数相同，用于指定属性必须具有的值。</p></li></ol><p>通过使用这些参数，可以根据应用程序的配置属性来动态地确定是否创建某个Bean。根据属性名、属性值、属性是否存在以及是否匹配等条件，可以灵活地控制Bean的创建过程。</p><p>如果当前classpath中存在类<code class="language-plaintext highlighter-rouge">javax.mail.Transport</code>，则创建<code class="language-plaintext highlighter-rouge">a1</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span><span class="o">(</span><span class="s">"a1"</span><span class="o">)</span>
<span class="nd">@ConditionalOnClass</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"javax.mail.Transport"</span><span class="o">)</span>
<span class="no">A</span> <span class="nf">getA</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>使用条件注解，能更灵活地装配Bean。</p><h2 id="aop">AOP</h2><p>AOP ( Aspect-Oriented Programming ）即面向切面编程，它与OOP (Object-Oriented Programming ， 面向对象编程）相辅相成，提供了与OOP 不同的抽象软件结构的视角。在OOP 中，以类作为程序的基本单元，而AOP 中的基本单元是Aspect（切面）。</p><p>在业务处理代码中通常有日志记录、性能统计、安全控制、事务处理、异常处理等操作。尽管使用OOP 可以通过封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中。</p><p>因此， 采用OOP 处理日志记录等操作不仅<strong>增加</strong>了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题， AOP 思想应运而生。</p><p>AOP 采取横向抽取机制，即将分散在各个方法中的重复代码<strong>提取</strong>出来，然后在程序<strong>编译或运行阶段</strong>将这些抽取出来的代码<strong>应用到</strong>需要执行的地方。这种横向抽取机制采用传统的OOP 是无法办到的，因为OOP 实现的是父子关系的纵向重用。但是<strong>AOP 不是OOP 的替代品，而是OOP 的补充</strong>，它们相辅相成。</p><hr /><p><strong>AOP的术语</strong></p><p>在SpringAOP框架中涉及以下常用术语。</p><p>切面（Aspect）：是指封装横切到<strong>系统功能</strong>（例如事务处理）的类。(通知方法的类)</p><p>连接点（Ooinpoint）：是指程序运行中的一些<strong>时间点</strong>，例如方法的调用或异常的抛出。(方法调用,或异常)，即定义在应用程序流程的何处插入切面的执行；</p><p>切入点（CPointcut）：是指<strong>需要处理的连接点</strong>。在SpringAOP中，<strong>所有的方法执行</strong>都是连接点，而切入点是一个描述信息，它修饰的是连接点，通过切入点<strong>确定</strong>哪些连接点需要被<strong>处理</strong>。(被处理的类的方法)</p><p>通知（Advice）：是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要<strong>执行</strong>的<strong>程序代码</strong>，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。(增强处理的代码)</p><p>引入（Introduction）：允许在现有的<strong>实现类</strong>中<strong>添加</strong>自定义的方法和属性。(增强类的方法与属性)</p><p>目标对象（TargetObject）：是指所有被通知的对象，即应用切面的原始对象或原始类。如果AOP框架使用运行时代理的方式（动态的AOP）来实现切面，那么通知对象总是一个<strong>代理对象</strong>。(要代理的对象Bean)</p><p>代理（Proxy）：是通知应用到目标对象<strong>之后</strong>被<strong>动态创建的对象</strong>。(被代理后动态生成的对象Bean)</p><p>织入（Weaving）：是<strong>将切面代码插入到目标对象</strong>上，<strong>从而生成代理对象的过程</strong>。根据不同的实现技术，AOP织入有3种方式：</p><ul><li>编译期织入，需要有特殊的Java编译器；</li><li>类装载期织入，需要有特殊的类装载器；</li><li>动态代理织入，在运行期为目标类添加通知生成子类的方式。</li></ul><p>SpringAOP框架默认采用<strong>动态代理</strong>织入，而AspectJ（基于Java语言的AOP框架）采用编译期织入和类装载期织入。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href="https://github.com/cglib/cglib">CGLIB</a>或者<a href="https://www.javassist.org/">Javassist</a>这些第三方库实现。(代理对象生成的过程)</p><p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p><p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p><p>使用代理模式的简单示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Test2</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="nc">AProxy</span><span class="o">();</span>
        <span class="n">a</span><span class="o">.</span><span class="na">func1</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">func1</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"func1"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">func2</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"func2"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">func3</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"func3"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">extends</span> <span class="no">A</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">func1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行一些代码"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">func1</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行一些代码"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">func2</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行一些代码"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">func2</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行一些代码"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kt">void</span> <span class="nf">func3</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行一些代码"</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">func3</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行一些代码"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>通过创建一个名为<code class="language-plaintext highlighter-rouge">AProxy</code>的子类来实现对<code class="language-plaintext highlighter-rouge">A</code>类的方法进行增强，这可以被认为是一种简单的AOP实现方式。在<code class="language-plaintext highlighter-rouge">AProxy</code>中，重写了<code class="language-plaintext highlighter-rouge">A</code>类的各个方法，并在方法的前后插入了额外的逻辑。</p><p>虽然这种方式实现了对<code class="language-plaintext highlighter-rouge">A</code>类方法的增强，但它并不是典型的AOP实现方式。在典型的AOP框架中，切面逻辑是通过配置或注解来定义的，而不是通过创建子类来重写方法。AOP框架通常会使用动态代理或字节码生成等技术来实现切面逻辑的动态织入，而不是在代码中显式地创建代理类。</p><hr /><h3 id="对类进行增强">对类进行增强</h3><h4 id="基于xml实现">基于XML实现</h4><p>首先添加依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-aop<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.0.2.RELEASE<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.aspectj<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>aspectjweaver<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.9.7<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>或：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-aspects<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.0.2.RELEASE<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>要通过XML配置AOP，需要使用以下几个标签：</p><p><code class="language-plaintext highlighter-rouge">&lt;aop:config&gt;</code>：这个标签用于配置AOP的相关信息，包括切面、通知等。</p><p><code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>：这个标签用于定义一个切面（Aspect），其中<code class="language-plaintext highlighter-rouge">ref</code>属性指定了切面的实例引用，即切面对象的名称或引用。</p><p>在Spring AOP中，切面（Aspect）是一个普通的Java类，它通常包含通知（Advice）和切点（Pointcut）的定义。切面类并不需要实现特定的接口或继承特定的类，只需要符合Spring AOP的约定即可。通常情况下，一个切面类会包含以下内容：</p><ul><li>通知（Advice）：定义了在连接点执行的具体操作，比如前置通知、后置通知、环绕通知等。</li><li>切点（Pointcut）：定义了在目标对象的哪些方法上执行通知。</li><li>引入（Introduction）：引入新的接口或方法到目标对象中。</li></ul><p><code class="language-plaintext highlighter-rouge">&lt;aop:declare-parents&gt;</code>：这个标签用于声明引入（Introduction）的相关信息，即在目标对象中引入新的接口或实现类。具有如下属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">types-matching</code></td><td>AspectJ类型表达式，所限制的类可加”+*..”号</td></tr><tr><td><code class="language-plaintext highlighter-rouge">implement-interfac</code></td><td>将引入的接口的标准名称</td></tr><tr><td><code class="language-plaintext highlighter-rouge">default-impl</code></td><td>将引入接口的实现类的完全限定名称</td></tr><tr><td><code class="language-plaintext highlighter-rouge">delegate-ref</code></td><td>将引入接口的实现类的Bean名称(实例化的)</td></tr></tbody></table><p><strong>目标</strong>是<code class="language-plaintext highlighter-rouge">types-matching</code>的类，spring让它实现<code class="language-plaintext highlighter-rouge">implement-interface</code>所指向的<strong>接口</strong>，而具体实现则通过<code class="language-plaintext highlighter-rouge">default-impl</code>或<code class="language-plaintext highlighter-rouge">delegate-ref</code>属性来赋予。让 <code class="language-plaintext highlighter-rouge">types-matching</code> 的类添加了<strong>接口</strong>并且指定了<strong>实现</strong>。</p><p>对类进行增强实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="no">I</span> <span class="n">i</span><span class="o">=(</span><span class="no">I</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>
        <span class="n">i</span><span class="o">.</span><span class="na">test</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"飞行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Aspect</span><span class="o">{}</span>
</code></pre></div></div><p>XML：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">/&gt;</span><span class="c">&lt;!--目标类--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span><span class="nt">/&gt;</span><span class="c">&lt;!--增强类--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"aspect"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.Aspect"</span><span class="nt">/&gt;</span><span class="c">&lt;!--切面类--&gt;</span>
<span class="nt">&lt;aop:config&gt;</span>
    <span class="nt">&lt;aop:aspect</span> <span class="na">ref=</span><span class="s">"aspect"</span><span class="nt">&gt;</span><span class="c">&lt;!--指向切面类，这里Aspect是空的--&gt;</span>
        <span class="nt">&lt;aop:declare-parents</span> <span class="na">types-matching=</span><span class="s">"com.aotmd.test.A"</span> <span class="na">implement-interface=</span><span class="s">"com.aotmd.test.I"</span> <span class="na">default-impl=</span><span class="s">"com.aotmd.test.B"</span><span class="nt">/&gt;</span>
        <span class="c">&lt;!--两种方法，选一个即可：--&gt;</span>
        <span class="nt">&lt;aop:declare-parents</span> <span class="na">types-matching=</span><span class="s">"com.aotmd.test.A"</span> <span class="na">implement-interface=</span><span class="s">"com.aotmd.test.I"</span> <span class="na">delegate-ref=</span><span class="s">"b"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/aop:aspect&gt;</span>
<span class="nt">&lt;/aop:config&gt;</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>飞行
com.aotmd.test.A$$EnhancerBySpringCGLIB$$712bcb1a
com.aotmd.test.B
</code></pre></div></div><p>在这个示例中，定义了三个bean：<code class="language-plaintext highlighter-rouge">a</code>、<code class="language-plaintext highlighter-rouge">b</code>和<code class="language-plaintext highlighter-rouge">aspect</code>。</p><ul><li><code class="language-plaintext highlighter-rouge">a</code>是目标类（Target Class），它是<code class="language-plaintext highlighter-rouge">com.aotmd.test.A</code>类的实例。</li><li><code class="language-plaintext highlighter-rouge">b</code>是增强类（Advice Class），它是<code class="language-plaintext highlighter-rouge">com.aotmd.test.B</code>类的实例。</li><li><code class="language-plaintext highlighter-rouge">aspect</code>是切面类（Aspect Class），它是<code class="language-plaintext highlighter-rouge">com.aotmd.test.Aspect</code>类的实例。</li></ul><p>然后，通过<code class="language-plaintext highlighter-rouge">&lt;aop:config&gt;</code>配置元素来定义AOP配置。在<code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>元素中，通过<code class="language-plaintext highlighter-rouge">ref="aspect"</code>将<code class="language-plaintext highlighter-rouge">aspect</code>切面类引入为切面的实例。</p><p>在<code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>元素中，使用了<code class="language-plaintext highlighter-rouge">&lt;aop:declare-parents&gt;</code>元素来声明引入（Introduction）操作。通过<code class="language-plaintext highlighter-rouge">types-matching</code>属性指定了<code class="language-plaintext highlighter-rouge">com.aotmd.test.A</code>类型的类，表示要对<code class="language-plaintext highlighter-rouge">A</code>类进行引入操作。使用<code class="language-plaintext highlighter-rouge">implement-interface</code>属性指定了要引入的接口<code class="language-plaintext highlighter-rouge">com.aotmd.test.I</code>，并使用<code class="language-plaintext highlighter-rouge">default-impl</code>属性指定了接口的默认实现类<code class="language-plaintext highlighter-rouge">com.aotmd.test.B</code>。</p><p>这样，通过AOP的引入操作，<code class="language-plaintext highlighter-rouge">A</code>类将会实现<code class="language-plaintext highlighter-rouge">I</code>接口，并使用<code class="language-plaintext highlighter-rouge">B</code>类作为接口的默认实现。这样，<code class="language-plaintext highlighter-rouge">A</code>类就拥有了<code class="language-plaintext highlighter-rouge">I</code>接口的方法，并且默认实现是<code class="language-plaintext highlighter-rouge">B</code>类的方法。</p><p>这样配置之后，<strong>所有的<code class="language-plaintext highlighter-rouge">A</code>对象</strong>都会<strong>具有<code class="language-plaintext highlighter-rouge">I</code>接口的功能</strong>，并默认使用<code class="language-plaintext highlighter-rouge">B</code>类来实现这个功能。</p><p>然后在<code class="language-plaintext highlighter-rouge">Test</code>类的<code class="language-plaintext highlighter-rouge">main</code>方法中，通过<code class="language-plaintext highlighter-rouge">ApplicationContext</code>从XML配置文件中加载了Spring容器，并从容器中获取了<code class="language-plaintext highlighter-rouge">A</code>类的实例<code class="language-plaintext highlighter-rouge">a</code>。然后调用了<code class="language-plaintext highlighter-rouge">a</code>的<code class="language-plaintext highlighter-rouge">print</code>方法，并打印了<code class="language-plaintext highlighter-rouge">a</code>的类名。接着，将<code class="language-plaintext highlighter-rouge">a</code>强制类型转换为<code class="language-plaintext highlighter-rouge">I</code>接口类型，并调用了<code class="language-plaintext highlighter-rouge">test</code>方法。</p><p>根据AOP配置，<code class="language-plaintext highlighter-rouge">a</code>的实例<code class="language-plaintext highlighter-rouge">A</code>被引入了<code class="language-plaintext highlighter-rouge">I</code>接口，并且默认实现为<code class="language-plaintext highlighter-rouge">B</code>类。因此，将<code class="language-plaintext highlighter-rouge">a</code>强制类型转换为<code class="language-plaintext highlighter-rouge">I</code>接口并调用<code class="language-plaintext highlighter-rouge">test</code>方法时，实际上会调用<code class="language-plaintext highlighter-rouge">B</code>类的<code class="language-plaintext highlighter-rouge">test</code>方法。</p><p>从spring容器中拿出来的<code class="language-plaintext highlighter-rouge">a</code>对象可以被强转换成<code class="language-plaintext highlighter-rouge">I</code>类型的对象。如果调用<code class="language-plaintext highlighter-rouge">I</code>的方法必须要强转，因为这些都是spring背后做了很多事情。</p><hr /><h4 id="基于注解">基于注解</h4><p>对类进行增强实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*@EnableAspectJAutoProxy:支持处理标有 AspectJ @Aspect 注解的组件，
类似于 Spring 的 XML 元素中的 &lt;aop:aspectj-autoproxy&gt; 功能。
用于 @Configuration 类*/</span>
<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="nd">@EnableAspectJAutoProxy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">a</span><span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="no">A</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="no">I</span> <span class="n">i</span><span class="o">=(</span><span class="no">I</span><span class="o">)</span><span class="n">a</span><span class="o">;</span>
        <span class="n">i</span><span class="o">.</span><span class="na">test</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"飞行"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">();</span>
<span class="o">}</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*这里重名了，因此要完全名*/</span>
<span class="nd">@org</span><span class="o">.</span><span class="na">aspectj</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">annotation</span><span class="o">.</span><span class="na">Aspect</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">Aspect</span><span class="o">{</span>
    <span class="nd">@DeclareParents</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span><span class="s">"com.aotmd.test.A"</span><span class="o">,</span><span class="n">defaultImpl</span> <span class="o">=</span> <span class="no">B</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="no">I</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>飞行
com.aotmd.test.A$$EnhancerBySpringCGLIB$$5fdfd7a5
com.aotmd.test.B
com.aotmd.test.B@2fd953a6
</code></pre></div></div><p>这里使用了<code class="language-plaintext highlighter-rouge">@EnableAspectJAutoProxy</code>注解来启用对标记有AspectJ <code class="language-plaintext highlighter-rouge">@Aspect</code>注解的组件的支持，类似于在Spring XML配置中使用<code class="language-plaintext highlighter-rouge">&lt;aop:aspectj-autoproxy&gt;</code>元素的功能。这个注解通常用于<code class="language-plaintext highlighter-rouge">@Configuration</code>类中。通过这个注解，Spring将会自动代理被<code class="language-plaintext highlighter-rouge">@Aspect</code>注解标记的类，使得切面逻辑能够被织入到目标类中。</p><p><code class="language-plaintext highlighter-rouge">@Aspect</code>: 这个注解用于标记一个类为切面（Aspect），其中定义了切面的通知（advice）和切点（pointcut）。在上面的代码中，<code class="language-plaintext highlighter-rouge">Aspect</code>类被标记为切面，用于定义引入操作。</p><p><code class="language-plaintext highlighter-rouge">@DeclareParents</code>: 这个注解用于在切面中声明引入操作，将新的接口引入到目标类中。在上面的代码中，<code class="language-plaintext highlighter-rouge">Aspect</code>类使用<code class="language-plaintext highlighter-rouge">@DeclareParents</code>注解来向<code class="language-plaintext highlighter-rouge">A</code>类引入<code class="language-plaintext highlighter-rouge">I</code>接口，并指定<code class="language-plaintext highlighter-rouge">B</code>类作为默认实现类。</p><p><code class="language-plaintext highlighter-rouge">@DeclareParents</code>的属性说明:</p><table><thead><tr><th><strong>属性</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td><strong>value</strong></td><td>AspectJ类型表达式，所限制的类可加”+*..”号</td></tr><tr><td><strong>default-impl</strong></td><td>将引入接口的实现类的完全限定名称的class实例</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">@DeclareParents</code>用在切面类(<code class="language-plaintext highlighter-rouge">@Aspect</code>)中的需要引入的接口实例上。</p><p>注意:切面类(<code class="language-plaintext highlighter-rouge">@Aspect</code>)需要<code class="language-plaintext highlighter-rouge">@Component</code>成一个Bean,才能在内部使用<code class="language-plaintext highlighter-rouge">@DeclareParents</code>。</p><h3 id="动态代理类型">动态代理类型</h3><p>在Java中有多种动态代理技术，例如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术是JDK和CGLIB。目前，在SpringAOP中常用JDK和CGLIB两种动态代理技术。</p><h4 id="jdk动态代理">JDK动态代理</h4><p>JDK动态代理是<code class="language-plaintext highlighter-rouge">java.lang.reflect.*</code>包提供的方式，它<strong>必须借助</strong>一个<strong>接口</strong>才能产生代理对象。因此，对于使用业务接口的类，Spring默认使用JDK动态代理实现AOP。</p><p>JDK中所要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中具有一定的局限性，而且使用反射的效率也并不是很高。</p><p>要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成，所以首先要编写用于生成代理对象的类。</p><p>java在JDK1.5之后提供了一个<code class="language-plaintext highlighter-rouge">java.lang.reflect.Proxy</code>类，通过<code class="language-plaintext highlighter-rouge">Proxy</code>类提供的一个<code class="language-plaintext highlighter-rouge">newProxyInstance</code>方法用来创建一个对象的代理对象，只需传入目标接口的类加载器、目标接口以及<code class="language-plaintext highlighter-rouge">InvocationHandler</code>回调接口，便可为<strong>目标接口</strong>生成代理类及代理对象，而且生成的代理类是其接口的实现类。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="nc">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">,</span> <span class="nc">InvocationHandler</span> <span class="n">h</span><span class="o">);</span>
</code></pre></div></div><p>通过<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建<code class="language-plaintext highlighter-rouge">interface</code>实例，需要3个参数：</p><ol><li>使用的<code class="language-plaintext highlighter-rouge">ClassLoader</code>，通常就是接口的<code class="language-plaintext highlighter-rouge">ClassLoader</code>；</li><li>需要实现的接口数组，<strong>至少需要传入一个接口进去</strong>；</li><li>用来处理接口方法调用的<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例。</li></ol><p>返回值为接口实现类的实例。</p><p><code class="language-plaintext highlighter-rouge">InvocationHandler</code>回调接口有一个方法，对于代理的逻辑方法，<strong>所有动态代理类的方法调用都会交给该回调接口方法处理</strong>，因此不要使用<code class="language-plaintext highlighter-rouge">method.invoke(proxy,args);</code>代码，这会导致无限递归：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">;</span>
</code></pre></div></div><p>参数解释：</p><ul><li><code class="language-plaintext highlighter-rouge">proxy</code>：把代理对象自己传递进来。</li><li><code class="language-plaintext highlighter-rouge">method</code>：把代理对象当前调用的方法传递进来可以使用这个参数来获取方法的信息，比如方法名、参数类型等。</li><li><code class="language-plaintext highlighter-rouge">args</code>：方法的参数数组。这个参数包含了方法调用时传入的参数值。</li><li><code class="language-plaintext highlighter-rouge">返回值</code>：返回函数执行的结果，取决于你想返回什么。</li></ul><p>通过一般类实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">JDKProxy</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JDKProxy</span><span class="o">&lt;&gt;();</span><span class="c1">//创建生成代理对象的工厂类，同时它也负责InvocationHandler的执行逻辑。</span>
        <span class="no">T</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="nc">TDemo</span><span class="o">();</span><span class="c1">//创建目标对象</span>
        <span class="cm">/*获取增强后的目标对象*/</span>
        <span class="no">T</span> <span class="n">t2</span><span class="o">=</span> <span class="n">proxy</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span><span class="c1">//任何调用都会传入invoke()回调方法,具体执行逻辑由invoke()决定。</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">T</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">save</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">modify</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">delete</span><span class="o">();</span>
<span class="o">}</span>

<span class="cm">/**
 * 目标对象
 */</span>
<span class="kd">class</span> <span class="nc">TDemo</span> <span class="kd">implements</span> <span class="no">T</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete2</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除逻辑2执行"</span><span class="o">);}</span>
<span class="o">}</span>
<span class="cm">/**
 * 切面类，可以定义多个通知，即增强处理的方法
 */</span>
<span class="kd">class</span> <span class="nc">AspectDemo</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模拟权限控制"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">except</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模拟异常处理"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模拟日志记录"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">monitor</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"性能监测"</span><span class="o">);}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">JDKProxy</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">InvocationHandler</span> <span class="o">{</span>
    <span class="cm">/**目标类实例*/</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">t</span><span class="o">;</span>
    <span class="nc">AspectDemo</span> <span class="n">asp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AspectDemo</span><span class="o">();</span><span class="c1">//创建一个切面</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">createProxy</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">t</span><span class="o">=</span><span class="n">t</span><span class="o">;</span>
        <span class="nc">ClassLoader</span> <span class="n">cld</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">();</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">();</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">cld</span><span class="o">,</span><span class="n">interfaces</span><span class="o">,</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">check</span><span class="o">();</span><span class="c1">//前增强</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">except</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"转发至代理对象方法:"</span><span class="o">+</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">t</span><span class="o">,</span><span class="n">args</span><span class="o">);</span><span class="c1">//在目标类实例t上调用方法并传入参数</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">log</span><span class="o">();</span><span class="c1">//后增强</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">monitor</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>模拟权限控制
模拟异常处理
转发至代理对象方法:delete
删除逻辑执行
模拟日志记录
性能监测
com.aotmd.test.TDemo
com.aotmd.test.$Proxy0
</code></pre></div></div><p>使用匿名类，则<code class="language-plaintext highlighter-rouge">JDKProxy</code>类只负责创建代理实例功能：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">JDKProxy</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">createProxy</span><span class="o">(</span><span class="no">T</span> <span class="n">target</span><span class="o">){</span>
        <span class="nc">ClassLoader</span> <span class="n">cld</span><span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">();</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">();</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">cld</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
            <span class="cm">/**切面类，用来增强*/</span>
            <span class="kd">final</span> <span class="nc">AspectDemo</span> <span class="n">asp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AspectDemo</span><span class="o">();</span>
            <span class="cm">/**目标类实例*/</span>
            <span class="kd">private</span> <span class="kd">final</span> <span class="no">T</span> <span class="n">t</span><span class="o">=</span><span class="n">target</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">check</span><span class="o">();</span><span class="c1">//前增强</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">except</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"转发至代理对象方法:"</span><span class="o">+</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                <span class="c1">//在目标类实例t上调用方法并传入参数</span>
                <span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">t</span><span class="o">,</span><span class="n">args</span><span class="o">);</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">log</span><span class="o">();</span><span class="c1">//后增强</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">monitor</span><span class="o">();</span>
                <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="cglib-动态代理">CGLIB 动态代理</h4><p>JDK 动态代理必须提供接口才能使用，对于没有提供接口的类，只能采用CGLIB 动态代理。CGLIB (Code Generation Library ） 是一个高性能开源的代码生成包，采用非常底层的字节码技术，<strong>对指定的目标类生成一个子类，并对子类进行增强</strong>。在Spring Core 包中己经集成了CGLIB 所需要的JAR 包，因此不需要另外导入JAR 包。</p><p>CGLIB代理的类，<strong>无需</strong>强制实现接口，其生成的代理类是被代理类的子类，并且重写的被代理类的方法。</p><p>要使用CGLIB创建代理实例，需要用到<code class="language-plaintext highlighter-rouge">org.springframework.cglib.proxy.Enhancer</code>类，首先实例化<code class="language-plaintext highlighter-rouge">Enhancer</code>类，然后通过<code class="language-plaintext highlighter-rouge">setSuperclass</code>设置需要增强的对象的class实例，最后通过<code class="language-plaintext highlighter-rouge">setCallback</code>设置<code class="language-plaintext highlighter-rouge">MethodInterceptor</code>回调接口，再通过<code class="language-plaintext highlighter-rouge">create</code>创建代理对象。</p><p><code class="language-plaintext highlighter-rouge">MethodInterceptor</code>回调接口有一个方法<code class="language-plaintext highlighter-rouge">intercept</code>，对于代理的逻辑方法，<strong>所有动态代理类的方法调用都会交给该回调接口方法处理</strong>，因此还是不要使用<code class="language-plaintext highlighter-rouge">method.invoke(o,objects);</code>代码，这会导致无限递归：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span><span class="o">,</span> <span class="nc">MethodProxy</span> <span class="n">methodProxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{}</span>
</code></pre></div></div><p>参数解释：</p><ul><li><code class="language-plaintext highlighter-rouge">o</code>：是CGLIB 根据指定父类生成的代理对象的实例。</li><li><code class="language-plaintext highlighter-rouge">method</code>：把代理对象当前要调用的方法传递进来，可以使用这个参数来获取方法的信息，比如方法名、参数类型等。</li><li><code class="language-plaintext highlighter-rouge">objects</code>：把方法参数通过数组传递进来。</li><li><code class="language-plaintext highlighter-rouge">methodProxy</code>：MethodProxy对象，可以用于调用<strong>原始方法</strong>（即目标的方法）。在intercept方法中，如果你需要调用原始方法，可以使用这个proxy对象。</li><li><code class="language-plaintext highlighter-rouge">返回值</code>：返回函数执行的结果，取决于你想返回什么。</li></ul><p><code class="language-plaintext highlighter-rouge">MethodProxy</code>是CGLIB库中的一个类，用于代理方法的调用。<code class="language-plaintext highlighter-rouge">MethodProxy</code>类提供了一些常用的方法，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">invokeSuper(Object obj, Object[] args)</code>: 调用被代理方法的实现</li><li><code class="language-plaintext highlighter-rouge">getSignature()</code>: 获取被代理方法的签名</li><li><code class="language-plaintext highlighter-rouge">getSuperIndex()</code>: 获取被代理方法在父类中的索引</li><li><code class="language-plaintext highlighter-rouge">getSuperName()</code>: 获取被代理方法的名称</li><li><code class="language-plaintext highlighter-rouge">getSuperDescriptor()</code>: 获取被代理方法的描述符</li><li><code class="language-plaintext highlighter-rouge">getSuperMethod()</code>: 获取被代理方法的<code class="language-plaintext highlighter-rouge">java.lang.reflect.Method</code>对象</li></ul><p>通过一般类实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CGLIBProxy</span> <span class="n">proxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CGLIBProxy</span><span class="o">();</span><span class="c1">//创建生成代理对象的工厂类，同时它也负责MethodInterceptor的执行逻辑。</span>
        <span class="nc">TDemo</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="nc">TDemo</span><span class="o">();</span><span class="c1">//创建目标对象</span>
        <span class="cm">/*获取增强后的目标对象*/</span>
        <span class="nc">TDemo</span> <span class="n">t2</span><span class="o">=</span> <span class="o">(</span><span class="nc">TDemo</span><span class="o">)</span> <span class="n">proxy</span><span class="o">.</span><span class="na">createProxy</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span><span class="c1">//任何调用都会传入intercept()回调方法,具体执行逻辑由intercept()决定。</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t2</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/**
 * 目标对象
 */</span>
<span class="kd">class</span> <span class="nc">TDemo</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete2</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除逻辑2执行"</span><span class="o">);}</span>
<span class="o">}</span>
<span class="cm">/**
 * 切面类，可以定义多个通知，即增强处理的方法
 */</span>
<span class="kd">class</span> <span class="nc">AspectDemo</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模拟权限控制"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">except</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模拟异常处理"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">log</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"模拟日志记录"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">monitor</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"性能监测"</span><span class="o">);}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">CGLIBProxy</span> <span class="kd">implements</span> <span class="nc">MethodInterceptor</span><span class="o">{</span>
    <span class="nc">AspectDemo</span> <span class="n">asp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AspectDemo</span><span class="o">();</span><span class="c1">//创建一个切面</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">createProxy</span><span class="o">(</span><span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Enhancer</span><span class="o">();</span>
        <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span><span class="c1">//确定需要增强的类</span>
        <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">this</span><span class="o">);</span><span class="c1">//确定回调对象</span>
        <span class="k">return</span> <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span><span class="c1">//创建代理对象</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span><span class="o">,</span> <span class="nc">MethodProxy</span> <span class="n">methodProxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">check</span><span class="o">();</span><span class="c1">//前增强</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">except</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"转发至代理对象方法:"</span><span class="o">+</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">methodProxy</span><span class="o">.</span><span class="na">invokeSuper</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">objects</span><span class="o">);</span><span class="c1">//转发调用目标类对应方法</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">log</span><span class="o">();</span><span class="c1">//后增强</span>
        <span class="n">asp</span><span class="o">.</span><span class="na">monitor</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>模拟权限控制
模拟异常处理
转发至代理对象方法:delete
删除逻辑执行
模拟日志记录
性能监测
com.aotmd.test.TDemo
com.aotmd.test.TDemo$$EnhancerByCGLIB$$a9a7303e
</code></pre></div></div><p>使用匿名类，则<code class="language-plaintext highlighter-rouge">CGLIBProxy</code>类只负责创建代理实例功能：：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CGLIBProxy</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">createProxy</span><span class="o">(</span><span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Enhancer</span> <span class="n">enhancer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Enhancer</span><span class="o">();</span>
        <span class="n">enhancer</span><span class="o">.</span><span class="na">setSuperclass</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span><span class="c1">//确定需要增强的类</span>
        <span class="n">enhancer</span><span class="o">.</span><span class="na">setCallback</span><span class="o">(</span><span class="k">new</span> <span class="nc">MethodInterceptor</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="nc">AspectDemo</span> <span class="n">asp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AspectDemo</span><span class="o">();</span><span class="c1">//创建一个切面</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">intercept</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">objects</span><span class="o">,</span> <span class="nc">MethodProxy</span> <span class="n">methodProxy</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">check</span><span class="o">();</span><span class="c1">//前增强</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">except</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"转发至代理对象方法:"</span><span class="o">+</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">methodProxy</span><span class="o">.</span><span class="na">invokeSuper</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">objects</span><span class="o">);</span><span class="c1">//转发调用目标类对应方法</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">log</span><span class="o">();</span><span class="c1">//后增强</span>
                <span class="n">asp</span><span class="o">.</span><span class="na">monitor</span><span class="o">();</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span><span class="c1">//确定回调对象</span>
        <span class="k">return</span> <span class="n">enhancer</span><span class="o">.</span><span class="na">create</span><span class="o">();</span><span class="c1">//创建代理对象</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="使用动态代理">使用动态代理</h3><p>在Spring中<strong>默认</strong>使用JDK动态代理实现AOP编程。使用<code class="language-plaintext highlighter-rouge">org.spring.framework.aop.framework.ProxyFactoryBean</code>创建代理是SpringAOP实现的最基本方式。</p><p>根据Spring中通知在目标类方法中的<strong>连接点</strong>位置，通知可以分为6种类型。</p><p>环绕通知（<code class="language-plaintext highlighter-rouge">org.aopalliance.intercept.Methodlnterceptor</code>）是在目标方法<strong>执行前</strong>和<strong>执行后</strong>实施增强，可应用于日志记录、事务处理等功能。它的方法签名为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">MethodInvocation</span> <span class="n">invocation</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">;</span>
</code></pre></div></div><p>其中<code class="language-plaintext highlighter-rouge">MethodInvocation</code>接口具有以下常用方法：</p><ol><li><code class="language-plaintext highlighter-rouge">Object[] getArguments()</code>: 获取方法调用的参数数组。</li><li><code class="language-plaintext highlighter-rouge">Method getMethod()</code>: 获取被调用的方法对象。</li><li><code class="language-plaintext highlighter-rouge">Object getThis()</code>: 获取目标对象，即被代理的对象。</li><li><code class="language-plaintext highlighter-rouge">AccessibleObject getStaticPart()</code>: 获取静态部分，即被调用的方法或构造函数。</li><li><strong><code class="language-plaintext highlighter-rouge">Object proceed() throws Throwable</code>: 执行下一个拦截器或目标方法，返回方法的返回值。</strong></li><li><code class="language-plaintext highlighter-rouge">Object getReturnValue()</code>: 获取方法调用的返回值。</li><li><code class="language-plaintext highlighter-rouge">Throwable getThrowable()</code>: 获取方法调用过程中抛出的异常。</li><li><code class="language-plaintext highlighter-rouge">void setArguments(Object[] arguments)</code>: 设置方法调用的参数数组。</li><li><code class="language-plaintext highlighter-rouge">void setReturnValue(Object returnValue)</code>: 设置方法调用的返回值。</li><li><code class="language-plaintext highlighter-rouge">void setThrowable(Throwable throwable)</code>: 设置方法调用过程中抛出的异常。</li></ol><p>前置通知（<code class="language-plaintext highlighter-rouge">org.springframework.aop.MethodBeforeAdvice</code>）是在目标方法<strong>执行前</strong>实施增强，可应用于权限管理等功能。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">(</span><span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{}</span>
</code></pre></div></div><p>后置返回通知（<code class="language-plaintext highlighter-rouge">org.spring:framework.aop.AfterReturningAdvice</code>）是在目标方法<strong>成功执行后</strong>实施增强，可应用于关闭流、删除临时文件等功能，多了个<code class="language-plaintext highlighter-rouge">returnValue</code>，表示返回值。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterReturning</span><span class="o">(</span><span class="nc">Object</span> <span class="n">returnValue</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{}</span>
</code></pre></div></div><p>后置(最终)通知（<code class="language-plaintext highlighter-rouge">org.springframework.aop.AfterAdvice</code>）是在目标方法<strong>执行后</strong>实施增强，与后置返回通知不同的是，<strong>不管是否发生异常</strong>都要执行该类通知，该类通知可应用于释放资源。</p><p>异常通知（<code class="language-plaintext highlighter-rouge">org.springframework.aop.ThrowsAdvice</code>）是在方法<strong>抛出异常后</strong>实施增强，可应用于处理异常、记录日志等功能。</p><p>引入通知（<code class="language-plaintext highlighter-rouge">org.springframework.aop.IntroductionInterceptor</code>）是在目标类中<strong>添加一些新的方法和属性</strong>，可应用于修改目标类（增强类）。</p><h4 id="proxyfactorybean">ProxyFactoryBean</h4><p>ProxyFactory Bean是<code class="language-plaintext highlighter-rouge">org.springframework.beans.factory.FactoryBean</code> 接口的实现类，FactoryBean负责实例化一个Bean实例， ProxyFactoryBean 负责为其他Bean实例创建代理实例。ProxyFactoryBean 类的常用<strong>属性</strong>如下：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>target</td><td>代理的目标对象</td></tr><tr><td>proxyInterfaces</td><td>代理需要实现的<strong>接口列表</strong>。如果是多个接口,可以使用以下格式赋值: <code class="language-plaintext highlighter-rouge">&lt;list&gt;&lt;value&gt;/value&gt;&lt;list&gt;</code> ，JDK代理使用这个参数。</td></tr><tr><td>interceptorNames</td><td>需要织入目标的Advice</td></tr><tr><td>proxyTargetClass</td><td>是否对类代理而不是接口,默认为false,使用JDK动态代理;当为true时,使用 CGLIB动态代理</td></tr><tr><td>singleton</td><td>返回的代理实例是否为单例,默认为true</td></tr><tr><td>optimize</td><td>当设置为true时强制CGLIB使用动态代理</td></tr></tbody></table><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AbstractApplicationContext</span> <span class="n">aac</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
        <span class="no">A</span> <span class="n">cGLIBProxy</span> <span class="o">=</span> <span class="o">(</span><span class="no">A</span><span class="o">)</span> <span class="n">aac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"cGLIBProxy"</span><span class="o">);</span>
        <span class="n">cGLIBProxy</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cGLIBProxy</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">IBase</span> <span class="n">jDKProxy</span><span class="o">=(</span><span class="nc">IBase</span><span class="o">)</span><span class="n">aac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"jDKProxy"</span><span class="o">);</span>
        <span class="n">jDKProxy</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">jDKProxy</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Aspect1</span> <span class="kd">implements</span>
        <span class="nc">MethodInterceptor</span><span class="o">,</span> <span class="nc">MethodBeforeAdvice</span><span class="o">,</span> <span class="nc">AfterReturningAdvice</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">MethodInvocation</span> <span class="n">i</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"当前拦截对象:"</span><span class="o">+</span><span class="n">i</span><span class="o">.</span><span class="na">getMethod</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"环绕通知前-&gt;"</span><span class="o">);</span>
        <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span><span class="c1">//转发,继续执行链中的下一个拦截。</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"环绕通知后"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">o</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">(</span><span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"前置通知"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterReturning</span><span class="o">(</span><span class="nc">Object</span> <span class="n">returnValue</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">target</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"后置通知-&gt;"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*下面使用CGLIB代理*/</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除逻辑执行"</span><span class="o">);}</span>
<span class="o">}</span>
<span class="cm">/*下面使用JDK代理*/</span>
<span class="kd">interface</span> <span class="nc">IBase</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">save</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">modify</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">delete</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="nc">IBase</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改逻辑执行"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除逻辑执行"</span><span class="o">);}</span>
<span class="o">}</span>
</code></pre></div></div><p>XML：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"aspect1"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.Aspect1"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!--下面使用CGLIB代理--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"a"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.A"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"cGLIBProxy"</span> <span class="na">class=</span><span class="s">"org.springframework.aop.framework.ProxyFactoryBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"target"</span> <span class="na">ref=</span><span class="s">"a"</span><span class="nt">/&gt;</span><span class="c">&lt;!--指定要代理的目标对象--&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"interceptorNames"</span> <span class="na">value=</span><span class="s">"aspect1"</span><span class="nt">/&gt;</span><span class="c">&lt;!--指定切面--&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"proxyTargetClass"</span> <span class="na">value=</span><span class="s">"true"</span><span class="nt">/&gt;</span><span class="c">&lt;!--代理方式,默认falseJDK代理,true,CGLIB代理--&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="c">&lt;!--下面使用JDK代理，共用aspect1，并使用p命名空间简化set注入--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"b"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.B"</span><span class="nt">/&gt;</span>
<span class="c">&lt;!--proxyInterfaces参数指定接口--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"jDKProxy"</span> <span class="na">class=</span><span class="s">"org.springframework.aop.framework.ProxyFactoryBean"</span>
      <span class="na">p:proxyInterfaces=</span><span class="s">"com.aotmd.test.IBase"</span> <span class="na">p:target-ref=</span><span class="s">"b"</span>
      <span class="na">p:interceptorNames=</span><span class="s">"aspect1"</span> <span class="na">p:proxyTargetClass=</span><span class="s">"false"</span><span class="nt">/&gt;</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>当前拦截对象:delete
环绕通知前-&gt;前置通知
删除逻辑执行
后置通知-&gt;环绕通知后
com.aotmd.test.A$$EnhancerBySpringCGLIB$$4b7ac9ec
当前拦截对象:save
环绕通知前-&gt;前置通知
保存逻辑执行
后置通知-&gt;环绕通知后
com.aotmd.test.$Proxy5
</code></pre></div></div><h3 id="aspectj">Aspectj</h3><h4 id="切入点语法定义">切入点语法定义</h4><p>在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义切入点(pointcut)。Pointcut可以通过<code class="language-plaintext highlighter-rouge">&amp;&amp;</code> 、<code class="language-plaintext highlighter-rouge">||</code>和<code class="language-plaintext highlighter-rouge">!</code>的方式进行组合。</p><p><strong>execution()</strong></p><p><strong>注意, <code class="language-plaintext highlighter-rouge">execution()</code>扫描的仅为依赖注入(控制反转)下的Bean</strong>。</p><p><code class="language-plaintext highlighter-rouge">execution()</code>是最常用的切点函数，其语法如下所示：修饰符 注解与异常是可选的。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">execution</span><span class="o">(&lt;</span><span class="n">注解</span><span class="o">&gt;&lt;</span><span class="n">修饰符</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">返回类型</span><span class="o">&gt;</span> <span class="o">&lt;[</span><span class="n">包名</span><span class="o">.][</span><span class="n">类名</span><span class="o">.]</span><span class="n">方法名</span><span class="o">&gt;(&lt;</span><span class="n">参数</span><span class="o">&gt;)</span> <span class="o">&lt;</span><span class="n">异常</span><span class="o">&gt;)</span>
</code></pre></div></div><table><thead><tr><th>通配符</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">*</code></td><td>所有语法中匹配任意字符,可与具体名称混写。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">+</code></td><td>匹配接口及其所有实现类的方法。以及<code class="language-plaintext highlighter-rouge">Object+</code>用法,匹配<code class="language-plaintext highlighter-rouge">Object</code>类型或该类的子类,接口同理。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">..</code></td><td><code class="language-plaintext highlighter-rouge">void springAOP..*(..)) </code>，<code class="language-plaintext highlighter-rouge">..</code>匹配所有子包， <code class="language-plaintext highlighter-rouge">*</code>表任意方法名, <code class="language-plaintext highlighter-rouge">&lt;参数&gt;</code>中的<code class="language-plaintext highlighter-rouge">..</code>匹配任意数量类型的参数。</td></tr></tbody></table><hr /><p><strong>对于：<code class="language-plaintext highlighter-rouge">&lt;[包名.][类名.]方法名&gt;</code>:</strong></p><p><code class="language-plaintext highlighter-rouge">execution(void springAOP..*(..))</code> ：可用,匹配所有返回值为<code class="language-plaintext highlighter-rouge">void</code>,并在springAOP包及其所有子包下的所有方法。</p><p><code class="language-plaintext highlighter-rouge">execution(void springAOP..(..))：</code>省略<code class="language-plaintext highlighter-rouge">*</code>号报错,可见<code class="language-plaintext highlighter-rouge">..</code><strong>只能匹配到包到类名</strong>,没有匹配方法名称。</p><p><code class="language-plaintext highlighter-rouge">execution(void *(..))</code>可用,匹配所有返回值为<code class="language-plaintext highlighter-rouge">void</code>的方法</p><p><code class="language-plaintext highlighter-rouge">execution(void *.*(..))</code>可用,匹配所有返回值为<code class="language-plaintext highlighter-rouge">void</code>的方法</p><p><code class="language-plaintext highlighter-rouge">execution(void *c(..))</code>可用,匹配以<code class="language-plaintext highlighter-rouge">c</code>结尾返回值为<code class="language-plaintext highlighter-rouge">void</code>的所有包与类中的方法</p><p><code class="language-plaintext highlighter-rouge">execution(void a*(..))</code>可用,匹配以<code class="language-plaintext highlighter-rouge">a</code>开头返回值为<code class="language-plaintext highlighter-rouge">void</code>的所有包与类中的方法</p><p><code class="language-plaintext highlighter-rouge">execution(void *.a*(..))</code>同上</p><p><code class="language-plaintext highlighter-rouge">execution(void *.add.a*(..))</code>可用,没有匹配到<code class="language-plaintext highlighter-rouge">springIOC.pp.add</code>类下的<code class="language-plaintext highlighter-rouge">add</code>方法,推测<code class="language-plaintext highlighter-rouge">*</code>号被限制<strong>只能匹配一层包或类</strong>了</p><p><code class="language-plaintext highlighter-rouge">execution(void springIoC.*.add.a*(..))</code>可用,正常匹配</p><p><code class="language-plaintext highlighter-rouge">execution(void *.pp.add.a*(..))</code>可用,正常匹配</p><p><code class="language-plaintext highlighter-rouge">execution(void ..a*(..))</code>报错，<code class="language-plaintext highlighter-rouge">..</code>通配符只能用于包名，而不能用于类名或方法名。</p><p><code class="language-plaintext highlighter-rouge">execution(void ...*(..))</code>可用,匹配项未知</p><p><code class="language-plaintext highlighter-rouge">execution(void spring*..*(..))</code>可用,匹配包名头为<code class="language-plaintext highlighter-rouge">spring</code>的任意包及其子包类中的<code class="language-plaintext highlighter-rouge">void</code>返回值的任意方法</p><p><code class="language-plaintext highlighter-rouge">execution(void springAOP.aaa.T+.sc(..))</code>，<code class="language-plaintext highlighter-rouge">T</code>是一个接口因此只能用<code class="language-plaintext highlighter-rouge">+</code>的形式, 匹配<code class="language-plaintext highlighter-rouge">T</code>接口的实现类或其子接口的实现类的<code class="language-plaintext highlighter-rouge">sc</code>方法。</p><hr /><p><strong>对于<code class="language-plaintext highlighter-rouge">(&lt;参数&gt;)</code></strong>：</p><p>切点表达式中方法入参部分比较复杂，可以使用<code class="language-plaintext highlighter-rouge">*</code>和<code class="language-plaintext highlighter-rouge">..</code>通配符。</p><p>其中<code class="language-plaintext highlighter-rouge">*</code>表示<strong>任意类型</strong>的参数，而<code class="language-plaintext highlighter-rouge">..</code>表示<strong>任意类型参数且参数个数不限</strong>。</p><p>如果方法中的入参类型是<code class="language-plaintext highlighter-rouge">java.lang</code>包下的类，可以直接使用类名，否则<strong>必须使用全限定类名</strong>，如<code class="language-plaintext highlighter-rouge">joke(java.util.List,int)</code>。</p><p><code class="language-plaintext highlighter-rouge">execution(* *(String,..))</code>匹配第一个参数为<code class="language-plaintext highlighter-rouge">String</code>的所有方法,<strong>包括只有一个<code class="language-plaintext highlighter-rouge">String</code>参数</strong></p><p><code class="language-plaintext highlighter-rouge">execution(void *(String,*))</code>匹配第一个参数为<code class="language-plaintext highlighter-rouge">String</code>,第二个为任意的所有方法,<strong>限定参数个数为2</strong>。</p><p><code class="language-plaintext highlighter-rouge">execution(void *(..,String,..))</code>匹配参数带<code class="language-plaintext highlighter-rouge">String</code>类型的所有方法</p><p><code class="language-plaintext highlighter-rouge">execution(void *(Object+))</code>匹配<code class="language-plaintext highlighter-rouge">Object</code>类型或该类的子类,限定参数为1</p><p><code class="language-plaintext highlighter-rouge">execution(void *(Object))</code><strong>只</strong>匹配<code class="language-plaintext highlighter-rouge">Object</code>类型,限定参数为1</p><p><code class="language-plaintext highlighter-rouge">execution(void *(springAOP.aaa.T+))</code>匹配<code class="language-plaintext highlighter-rouge">T</code>接口或接口的实现类,以及继承<code class="language-plaintext highlighter-rouge">T</code>接口的其他接口与实现类。</p><hr /><p><strong>对于<code class="language-plaintext highlighter-rouge">&lt;异常&gt;</code>：</strong></p><p><code class="language-plaintext highlighter-rouge">execution(void *(..)throws java.lang.IllegalArgumentException)</code>匹配<strong>带</strong>这个异常的方法</p><p><code class="language-plaintext highlighter-rouge">execution(void *(..)throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException</code>匹配<strong>带</strong>这两个异常的方法</p><p><code class="language-plaintext highlighter-rouge">execution(void *(..)throws Exception+)</code>同理,匹配该异常,<strong>以及该异常下的所有子异常</strong></p><p><code class="language-plaintext highlighter-rouge">execution(void *(..)throws Exception,java.lang.IllegalArgumentException)</code><strong>多个异常无位置关系</strong></p><hr /><p><strong>对于<code class="language-plaintext highlighter-rouge">&lt;注解&gt;</code>：</strong></p><p><code class="language-plaintext highlighter-rouge">execution(@java.lang.Override * *(..))</code>没有实验过</p><hr /><p><strong>对于<code class="language-plaintext highlighter-rouge">&lt;修饰符&gt;</code>：</strong></p><p><code class="language-plaintext highlighter-rouge">execution(private * *(..))</code>无效,因为无法<strong>直接</strong>在外部调用该方法</p><p><code class="language-plaintext highlighter-rouge">execution(protected * *(..))</code>没有问题,<strong>直接</strong>访问该方法可以匹配,通过该方法所在类的其他方法<strong>间接访问无法起作用</strong></p><p><code class="language-plaintext highlighter-rouge">execution(protected+ * *(..))</code><strong>无法使用</strong><code class="language-plaintext highlighter-rouge">+</code>,报错,情理之中。</p><hr /><p><strong>对于<code class="language-plaintext highlighter-rouge">&lt;返回类型&gt;</code>：</strong></p><p><code class="language-plaintext highlighter-rouge">execution(Object+ *(..))</code>同样,具有匹配<code class="language-plaintext highlighter-rouge">Object</code>类型或该类的子类,返回值<code class="language-plaintext highlighter-rouge">String</code>会被匹配。</p><hr /><p><strong><code class="language-plaintext highlighter-rouge">args()</code></strong></p><p>该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：<code class="language-plaintext highlighter-rouge">args(com.baobaotao.Waiter)</code>。</p><p>它表示运行时入参是<code class="language-plaintext highlighter-rouge">Waiter</code>类型的方法，它和<code class="language-plaintext highlighter-rouge">execution(* *(com.baobaotao.Waiter))</code>区别在于后者是针对类方法的签名而言的，而前者则针对<strong>运行时</strong>的入参类型而言。</p><p>如 <code class="language-plaintext highlighter-rouge">args(com.baobaotao.Waiter)</code>既匹配于<code class="language-plaintext highlighter-rouge">addWaiter(Waiter waiter)</code>也匹配于<code class="language-plaintext highlighter-rouge">addNaiveWaiter(NaiveWaiter naiveWaiter)</code></p><p>而<code class="language-plaintext highlighter-rouge">execution(* *(com.baobaotao.Waiter))</code>只匹配<code class="language-plaintext highlighter-rouge">addWaiter(Waiter waiter)</code>方法；</p><p>实际上，<code class="language-plaintext highlighter-rouge">args(com.baobaotao.Waiter)</code>等价于<code class="language-plaintext highlighter-rouge">execution(* *(com.baobaotao.Waiter+))</code>，当然也等价于<code class="language-plaintext highlighter-rouge">args(com.baobaotao.Waiter+)</code>。</p><p><strong><code class="language-plaintext highlighter-rouge">@args()</code></strong></p><p>该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。如<code class="language-plaintext highlighter-rouge">@args(com.baobaotao.Monitorable)</code>表示任何这样的一个目标方法：它有一个入参且入参对象的类标注<code class="language-plaintext highlighter-rouge">@Monitorable</code>注解。</p><p><strong><code class="language-plaintext highlighter-rouge">args()</code>和<code class="language-plaintext highlighter-rouge">@args()</code></strong></p><p><code class="language-plaintext highlighter-rouge">args()</code>函数的入参是<strong>类名</strong>，<code class="language-plaintext highlighter-rouge">@args()</code>函数的入参必须是<strong>注解类的类名</strong>。虽然<code class="language-plaintext highlighter-rouge">args()</code>允许在类名后使用<code class="language-plaintext highlighter-rouge">+</code>通配符后缀，但该通配符在此处没有意义：<strong>添加和不添加效果都一样</strong>。</p><p><strong>其他：</strong></p><table><thead><tr><th>类别</th><th>函数</th><th>入参</th><th>说明</th></tr></thead><tbody><tr><td>方法切点函数</td><td><code class="language-plaintext highlighter-rouge">execution()</code></td><td><strong>方法</strong>匹配模式串</td><td>表示满足某一匹配模式的所有目标类方法连接点。如<code class="language-plaintext highlighter-rouge">execution(* greetTo(..))</code>表示所有目标类中的<code class="language-plaintext highlighter-rouge">greetTo()</code>方法。</td></tr><tr><td>同上</td><td><code class="language-plaintext highlighter-rouge">@annotation()</code></td><td>方法<strong>注解类名</strong></td><td>表示标注了特定注解的目标方法连接点。如<code class="language-plaintext highlighter-rouge">@annotation(com.baobaotao.anno.NeedTest)</code>表示任何标注了<code class="language-plaintext highlighter-rouge">@NeedTest</code>注解的目标类方法。</td></tr><tr><td>方法<strong>入参</strong>切点函数</td><td><code class="language-plaintext highlighter-rouge">args()</code></td><td><strong>类名</strong></td><td>通过判别目标类方法运行时入参对象的类型定义指定连接点。如<code class="language-plaintext highlighter-rouge">args(com.baobaotao.Waiter)</code>表示所有有且仅有一个按类型匹配于Waiter的入参的方法。</td></tr><tr><td>同上</td><td><code class="language-plaintext highlighter-rouge">@args()</code></td><td>类型<strong>注解类名</strong></td><td>通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如<code class="language-plaintext highlighter-rouge">@args(com.baobaotao.Monitorable)</code>表示任何这样的一个目标方法：它有一个入参且入参对象的类标注<code class="language-plaintext highlighter-rouge">@Monitorable</code>注解。</td></tr><tr><td>目标类切点函数</td><td><code class="language-plaintext highlighter-rouge">within()</code></td><td><strong>类名</strong>匹配串</td><td>表示特定域下的所有连接点。如<code class="language-plaintext highlighter-rouge">within(com.baobaotao.service.*)</code>表示<code class="language-plaintext highlighter-rouge">com.baobaotao.service</code>包中的所有连接点，也即包中所有类的所有方法，而<code class="language-plaintext highlighter-rouge">within(com.baobaotao.service.*Service)</code>表示在<code class="language-plaintext highlighter-rouge">com.baobaotao.service</code>包中，所有以Service结尾的类的所有连接点。</td></tr><tr><td>同上</td><td><code class="language-plaintext highlighter-rouge">target()</code></td><td><strong>类名</strong></td><td>假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过<code class="language-plaintext highlighter-rouge">target(com.baobaotao.Waiter)</code>定义的切点，<code class="language-plaintext highlighter-rouge">Waiter</code>、以及<code class="language-plaintext highlighter-rouge">Waiter</code>实现类<code class="language-plaintext highlighter-rouge">NaiveWaiter</code>中所有连接点都匹配该切点。</td></tr><tr><td>同上</td><td><code class="language-plaintext highlighter-rouge">@within()</code></td><td>类型<strong>注解类名</strong></td><td>假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点。如<code class="language-plaintext highlighter-rouge">@within(com.baobaotao.Monitorable)</code>定义的切点，假如<code class="language-plaintext highlighter-rouge">Waiter</code>类标注了<code class="language-plaintext highlighter-rouge">@Monitorable</code>注解，则<code class="language-plaintext highlighter-rouge">Waiter</code>以及<code class="language-plaintext highlighter-rouge">Waiter</code>实现类<code class="language-plaintext highlighter-rouge">NaiveWaiter</code>类的所有连接点都匹配。</td></tr><tr><td>同上</td><td><code class="language-plaintext highlighter-rouge">@target()</code></td><td>类型<strong>注解类名</strong></td><td>目标类标注了特定注解，则目标类所有连接点匹配该切点。如<code class="language-plaintext highlighter-rouge">@target(com.baobaotao.Monitorable)</code>，假如<code class="language-plaintext highlighter-rouge">NaiveWaiter</code>标注了<code class="language-plaintext highlighter-rouge">@Monitorable</code>，则<code class="language-plaintext highlighter-rouge">NaiveWaiter</code>所有连接点匹配切点。</td></tr><tr><td><strong>代理类</strong>切点函数</td><td><code class="language-plaintext highlighter-rouge">this()</code></td><td><strong>类名</strong></td><td>代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。如果有一个接口<code class="language-plaintext highlighter-rouge">MyInterface</code>，并且有一个代理类<code class="language-plaintext highlighter-rouge">MyProxy</code>实现了这个接口，那么使用<code class="language-plaintext highlighter-rouge">this(MyInterface)</code>将匹配所有<code class="language-plaintext highlighter-rouge">MyProxy</code>代理类中实现<code class="language-plaintext highlighter-rouge">MyInterface</code>接口的连接点。</td></tr></tbody></table><h4 id="基于xml实现-1">基于XML实现</h4><p>AspectJ是一个基于Java语言的AOP框架。从Spring2.0以后引入了AspectJ的支持。对于目前的Spring框架，<em>建议</em>开发者使用AspectJ实现SpringAOP。</p><p>使用AspectJ实现Spring AOP的方式有两种，一是基于XML配置开发AspectJ，二是基于注解开发AspectJ。</p><p>基于XML配置开发AspectJ是指通过XML配置文件定义切面、切入点及通知，所有这些定义都必须在<code class="language-plaintext highlighter-rouge">&lt;aop:config&gt;</code>元素内。</p><table><thead><tr><th><strong>元素名称</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:config&gt;</code></td><td>开发AspectJ的顶层配置元素，在配置文件的<code class="language-plaintext highlighter-rouge">&lt;beans&gt;</code>下可以包含多个该元素</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code></td><td>配置（定义）一个切面，<code class="language-plaintext highlighter-rouge">&lt;aop:config&gt;</code>子元素，属性<code class="language-plaintext highlighter-rouge">ref</code>指定切面的定义</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:pointcut&gt;</code></td><td>配置切入点，<code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>子元素，属性<code class="language-plaintext highlighter-rouge">expression</code>指定通知增强哪些方法</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:before&gt;</code></td><td>配置前置通知,<code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>子元素, 目标方法执行前实施增强属性<code class="language-plaintext highlighter-rouge">method</code>指定前置通知方法,属性<code class="language-plaintext highlighter-rouge">pointcut-ref</code>指定关联的切入点</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:after-returning&gt;</code></td><td>配置后置返回通知, <code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>子元素, 目标方法成功执行后实施增强属性<code class="language-plaintext highlighter-rouge">method</code>指定后置返回通知方法,属性<code class="language-plaintext highlighter-rouge">pointcut-ref</code>指定关联的切入点</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:around&gt;</code></td><td>配置环绕通知, <code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>子元素, 目标方法执行前和执行后实施增强属性<code class="language-plaintext highlighter-rouge">method</code>指定环绕通知方法,属性<code class="language-plaintext highlighter-rouge">pointcut-ref</code>指定关联的切入点</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aoppafter-throwing&gt;</code></td><td>配置异常通知, <code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>子元素, 抛出异常后实施增强属性<code class="language-plaintext highlighter-rouge">method</code>指定异常通知方法,属性<code class="language-plaintext highlighter-rouge">pointcut-ref</code>指定关联的切入点,</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:after&gt;</code></td><td>配置后置(最终)通知, <code class="language-plaintext highlighter-rouge">&lt;aop:aspect&gt;</code>子元素, 标方法<em>执行后</em>实施增强属性<code class="language-plaintext highlighter-rouge">method</code>指定后置(最终)通知方法,属性<code class="language-plaintext highlighter-rouge">pointcut-ref</code>指定关联的切入点</td></tr><tr><td><code class="language-plaintext highlighter-rouge">&lt;aop:declare-parents&gt;</code></td><td>给通知引入新的额外接口，增强功能。</td></tr></tbody></table><p>实例：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"td6"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.TDemo6"</span><span class="nt">/&gt;</span><span class="c">&lt;!--目标Bean--&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"aspectJProxy"</span> <span class="na">class=</span><span class="s">"com.aotmd.test.AspectJProxy"</span><span class="nt">/&gt;</span><span class="c">&lt;!--拦截器实现方法--&gt;</span>
<span class="nt">&lt;aop:config&gt;</span><span class="c">&lt;!--配置AOP--&gt;</span>
    <span class="nt">&lt;aop:aspect</span> <span class="na">ref=</span><span class="s">"aspectJProxy"</span><span class="nt">&gt;</span><span class="c">&lt;!--拦截器配置--&gt;</span>
        <span class="c">&lt;!--配置切入点,即给指定的方法增强,当前expression表达式为返回值为void在TDemo6类下的任意形参的方法--&gt;</span>
        <span class="nt">&lt;aop:pointcut</span> <span class="na">id=</span><span class="s">"myPointCut"</span> <span class="na">expression=</span><span class="s">"execution(void com.aotmd.test.TDemo6.*(..))"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;aop:before</span> <span class="na">method=</span><span class="s">"before"</span> <span class="na">pointcut-ref=</span><span class="s">"myPointCut"</span><span class="nt">/&gt;</span><span class="c">&lt;!--关联指定拦截器(切面)的某方法为前置通知,并匹配切点--&gt;</span>
        <span class="nt">&lt;aop:after-returning</span> <span class="na">method=</span><span class="s">"afterReturning"</span> <span class="na">pointcut-ref=</span><span class="s">"myPointCut"</span><span class="nt">/&gt;</span><span class="c">&lt;!--同上,后置返回通知--&gt;</span>
        <span class="nt">&lt;aop:around</span> <span class="na">method=</span><span class="s">"around"</span> <span class="na">pointcut-ref=</span><span class="s">"myPointCut"</span><span class="nt">/&gt;</span><span class="c">&lt;!--同上,环绕通知--&gt;</span>
        <span class="nt">&lt;aop:after-throwing</span> <span class="na">method=</span><span class="s">"except"</span> <span class="na">pointcut-ref=</span><span class="s">"myPointCut"</span> <span class="na">throwing=</span><span class="s">"e"</span><span class="nt">/&gt;</span><span class="c">&lt;!--同上,异常通知,throwing异常方法形参--&gt;</span>
        <span class="nt">&lt;aop:after</span> <span class="na">method=</span><span class="s">"after"</span> <span class="na">pointcut-ref=</span><span class="s">"myPointCut"</span><span class="nt">/&gt;</span><span class="c">&lt;!--同上,关联后置(最终通知)--&gt;</span>
    <span class="nt">&lt;/aop:aspect&gt;</span>
<span class="nt">&lt;/aop:config&gt;</span>
</code></pre></div></div><p>类文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.aspectj.lang.JoinPoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.aspectj.lang.ProceedingJoinPoint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.support.AbstractApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.support.ClassPathXmlApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AbstractApplicationContext</span> <span class="n">aac</span><span class="o">=</span><span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"application.xml"</span><span class="o">);</span>
        <span class="nc">TDemo6</span> <span class="n">td6</span> <span class="o">=</span> <span class="o">(</span><span class="nc">TDemo6</span><span class="o">)</span> <span class="n">aac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"td6"</span><span class="o">);</span>
        <span class="n">td6</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
        <span class="n">td6</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span><span class="c1">//不是void返回值,因此没有被代理</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">AspectJProxy</span><span class="o">{</span>
    <span class="cm">/**前置通知 @param jp 作为参数获得目标对象信息*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">jp</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"前置通知：模拟权限控制"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span><span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterReturning</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">jp</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"后置返回通知：模拟删除临时文件"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span><span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="cm">/**环绕通知,必须一个参数是ProceedingJoinPoint 类型
     * @param pjp ProceedingJoinPoint 是JoinPoint 的子接口， 代表可以执行的目标方法
     * @return 返回值的类型必须是Object
     * @throws Throwable*/</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"环绕开始：执行目标方法前，模拟开启事务"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span> <span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span><span class="c1">//转发,继续下一拦截方法</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"环绕结束：执行目标方法前，模拟关闭事务"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">except</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">e</span><span class="o">){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"异常通知：程序执行异常"</span><span class="o">+</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">after</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"后置(最终)通知：模拟释放资源"</span><span class="o">);}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TDemo6</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除"</span><span class="o">);</span><span class="k">return</span> <span class="kc">true</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>输出结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>前置通知：模拟权限控制，目标类对象：com.aotmd.test.TDemo6@9cd25ff，被增强处理的方法：save
环绕开始：执行目标方法前，模拟开启事务，目标类对象：com.aotmd.test.TDemo6@9cd25ff，被增强处理的方法：save
保存
后置(最终)通知：模拟释放资源
环绕结束：执行目标方法前，模拟关闭事务
后置返回通知：模拟删除临时文件，目标类对象：com.aotmd.test.TDemo6@9cd25ff，被增强处理的方法：save
删除
</code></pre></div></div><p>执行顺序：</p><p><img src="/images/posts/Java/切点执行顺序.png" alt="切点执行顺序" /></p><h4 id="基于注解实现">基于注解实现</h4><p>基于注解开发AspectJ 要比基于XML 配置开发AspectJ 便捷许多，所以在实际开发中推荐使用注解方式。</p><table><thead><tr><th><strong>注解名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>@Aspect</td><td>用于定义一个切面,注解在切面类上。</td></tr><tr><td>@Pointcut</td><td>用于定义<strong>切入点表达式</strong>。在使用时需要定义一个<strong>切入点方法</strong>,该方法是一个<strong>返回值void且方法体为空的普通方法。</strong></td></tr><tr><td>@Before</td><td>用于定义<strong>前置通知</strong>。在使用时通常为其指定<code class="language-plaintext highlighter-rouge">value</code>属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。</td></tr><tr><td>@AfterReturning</td><td>用于定义<strong>后置返回通知</strong>。在使用时通常为其指定<code class="language-plaintext highlighter-rouge">value</code>属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。</td></tr><tr><td>@Around</td><td>用于定义<strong>环绕通知</strong>。在使用时通常为其指定<code class="language-plaintext highlighter-rouge">value</code>属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。</td></tr><tr><td>@AfterThrowing</td><td>用于定义<strong>异常通知</strong>。在使用时通常为其指定<code class="language-plaintext highlighter-rouge">value</code>属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。另外,还有一个<code class="language-plaintext highlighter-rouge">throwing</code>属性用于访问目标方法抛出的异常,<strong>该属性值与异常通知方法中同名的形参一致</strong>。</td></tr><tr><td>@After</td><td>用于定义<strong>后置(最终)通知</strong>。在使用时通常为其指定<code class="language-plaintext highlighter-rouge">value</code>属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。</td></tr></tbody></table><p>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="nd">@EnableAspectJAutoProxy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">TDemo7</span> <span class="n">tDemo7</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">TDemo7</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span><span class="c1">//不是void返回值,因此没有被代理</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Aspect</span> <span class="cm">/*&lt;aop:aspect ref="annotationAspectJProxy"&gt;&lt;!--拦截器配置--&gt;*/</span>
<span class="nd">@Component</span><span class="cm">/*&lt;bean id="annotationAspectJProxy" class="springAOP.AspectJProxy"/&gt;*/</span>
<span class="kd">class</span> <span class="nc">AnnotationAspectJProxy</span> <span class="o">{</span>
    <span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(void com.aotmd.test.TDemo7.*(..))"</span><span class="o">)</span><span class="cm">/*配置切入点,即给指定的方法增强,
        &lt;aop:pointcut id="cut" expression="execution(void com.aotmd.test.TDemo7.*(..))"/&gt;*/</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">cut</span><span class="o">(){}</span>
    <span class="cm">/**前置通知 @param jp 作为参数获得目标对象信息*/</span>
    <span class="nd">@Before</span><span class="o">(</span><span class="s">"cut()"</span><span class="o">)</span><span class="cm">/*&lt;aop:before method="before" pointcut-ref="cut"/&gt;前置通知*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">before</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">jp</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"前置通知：模拟权限控制"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span><span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="nd">@AfterReturning</span><span class="o">(</span><span class="s">"cut()"</span><span class="o">)</span><span class="cm">/*&lt;aop:before method="afterReturning" pointcut-ref="cut"/&gt;后置返回通知*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterReturning</span><span class="o">(</span><span class="nc">JoinPoint</span> <span class="n">jp</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"后置返回通知：模拟删除临时文件"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span><span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">jp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="cm">/**环绕通知,必须一个参数是ProceedingJoinPoint 类型
     * @param pjp ProceedingJoinPoint 是JoinPoint 的子接口， 代表可以执行的目标方法
     * @return 返回值的类型必须是Object
     * @throws Throwable*/</span>
    <span class="nd">@Around</span><span class="o">(</span><span class="s">"cut()"</span><span class="o">)</span><span class="cm">/*&lt;aop:before method="around" pointcut-ref="cut"/&gt;环绕通知*/</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"环绕开始：执行目标方法前，模拟开启事务"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span> <span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span><span class="c1">//转发,继续下一拦截方法</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"环绕结束：执行目标方法前，模拟关闭事务"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@AfterThrowing</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"cut()"</span><span class="o">,</span><span class="n">throwing</span> <span class="o">=</span> <span class="s">"e"</span><span class="o">)</span>
    <span class="cm">/*&lt;aop:after-throwing method="except" pointcut-ref="cut" throwing="e"/&gt;
    &lt;!--同上,异常通知,throwing异常方法形参--&gt;*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">except</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">e</span><span class="o">){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"异常通知：程序执行异常"</span><span class="o">+</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());}</span>
    <span class="nd">@After</span><span class="o">(</span><span class="s">"cut()"</span><span class="o">)</span>
    <span class="cm">/*&lt;aop:after method="after" pointcut-ref="cut"/&gt;&lt;!--关联后置(最终通知)--&gt;*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">after</span><span class="o">(){</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"后置(最终)通知：模拟释放资源"</span><span class="o">);}</span>
<span class="o">}</span>
<span class="nd">@Component</span><span class="cm">/*这里生成的Bean名称为TDemo7*/</span>
<span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除"</span><span class="o">);</span><span class="k">return</span> <span class="kc">true</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>环绕开始：执行目标方法前，模拟开启事务，目标类对象：com.aotmd.test.TDemo7@5f0e9815，被增强处理的方法：save
前置通知：模拟权限控制，目标类对象：com.aotmd.test.TDemo7@5f0e9815，被增强处理的方法：save
保存
环绕结束：执行目标方法前，模拟关闭事务
后置(最终)通知：模拟释放资源
后置返回通知：模拟删除临时文件，目标类对象：com.aotmd.test.TDemo7@5f0e9815，被增强处理的方法：save
删除
</code></pre></div></div><p>这里使用了<code class="language-plaintext highlighter-rouge">@EnableAspectJAutoProxy</code>注解来启用对标记有AspectJ <code class="language-plaintext highlighter-rouge">@Aspect</code>注解的组件的支持，类似于在Spring XML配置中使用<code class="language-plaintext highlighter-rouge">&lt;aop:aspectj-autoproxy&gt;</code>元素的功能。这个注解通常用于<code class="language-plaintext highlighter-rouge">@Configuration</code>类中。通过这个注解，Spring将会自动代理被<code class="language-plaintext highlighter-rouge">@Aspect</code>注解标记的类，使得切面逻辑能够被织入到目标类中。</p><p>Spring的IoC容器看到这个注解，就会自动查找带有<code class="language-plaintext highlighter-rouge">@Aspect</code>的Bean，然后根据每个方法的<code class="language-plaintext highlighter-rouge">@Before</code>、<code class="language-plaintext highlighter-rouge">@Around</code>等注解把AOP注入到特定的Bean中。</p><p><code class="language-plaintext highlighter-rouge">JoinPoint</code>接口是AspectJ框架中的一个核心接口，用于表示切点的信息。它提供了一些方法来获取与切点相关的信息。下面是<code class="language-plaintext highlighter-rouge">JoinPoint</code>接口中常用的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">getArgs()</code>：获取方法参数的数组。</li><li><code class="language-plaintext highlighter-rouge">getThis()</code>：获取代理对象的引用。</li><li><strong><code class="language-plaintext highlighter-rouge">getTarget()</code>：获取目标对象的引用，类型为<code class="language-plaintext highlighter-rouge">Signature</code>接口。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">getSignature()</code>：获取方法签名的对象。</strong></li><li><code class="language-plaintext highlighter-rouge">getStaticPart()</code>：获取静态部分的对象。</li><li><code class="language-plaintext highlighter-rouge">getKind()</code>：获取切点的类型，如method-execution、method-call等。</li><li><code class="language-plaintext highlighter-rouge">getSourceLocation()</code>：获取切点所在位置的源代码位置。</li><li><code class="language-plaintext highlighter-rouge">getStaticPart()</code>：获取静态部分的对象。</li><li><code class="language-plaintext highlighter-rouge">toShortString()</code>：获取切点的简短字符串表示。</li><li><code class="language-plaintext highlighter-rouge">toLongString()</code>：获取切点的详细字符串表示。</li></ul><p><code class="language-plaintext highlighter-rouge">JoinPoint</code>接口还包含了两个内部接口<code class="language-plaintext highlighter-rouge">StaticPart</code>和<code class="language-plaintext highlighter-rouge">EnclosingStaticPart</code>。这两个接口提供了关于切点静态部分的信息。</p><p><code class="language-plaintext highlighter-rouge">StaticPart</code>接口：表示切点的静态部分，即切点所在的位置信息。它包含了以下方法：</p><ul><li><code class="language-plaintext highlighter-rouge">getKind()</code>：获取切点的类型，如<code class="language-plaintext highlighter-rouge">method-execution</code>、<code class="language-plaintext highlighter-rouge">method-call</code>等。</li><li><code class="language-plaintext highlighter-rouge">getSignature()</code>：获取方法签名的对象，类型为<code class="language-plaintext highlighter-rouge">Signature</code>接口。</li><li><code class="language-plaintext highlighter-rouge">getSourceLocation()</code>：获取切点所在位置的源代码位置。</li><li><code class="language-plaintext highlighter-rouge">toShortString()</code>：获取切点的简短字符串表示。</li><li><code class="language-plaintext highlighter-rouge">toLongString()</code>：获取切点的详细字符串表示。</li></ul><p><code class="language-plaintext highlighter-rouge">EnclosingStaticPart</code>接口：表示包围当前切点的静态部分，即当前切点所在的方法或构造函数的信息。它包含了与<code class="language-plaintext highlighter-rouge">StaticPart</code>接口相同的方法，用于获取包围切点的静态部分的信息。</p><p>而环绕通知的<code class="language-plaintext highlighter-rouge">ProceedingJoinPoint</code>接口继承于<code class="language-plaintext highlighter-rouge">JoinPoint</code>接口，并多了：</p><ul><li><code class="language-plaintext highlighter-rouge">proceed()</code>：执行原始的连接点，即继续执行切点所在的方法。在环绕通知中，可以调用这个方法来执行原始的连接点，或者在合适的时机决定是否继续执行。</li><li><code class="language-plaintext highlighter-rouge">proceed(Object[] args)</code>：执行原始的连接点，并传入指定的参数。</li></ul><p>传入参数的实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Around</span><span class="o">(</span><span class="s">"cut()"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"环绕开始：执行目标方法前，模拟开启事务"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，目标类对象："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">()+</span> <span class="s">"，被增强处理的方法："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="c1">// 获取目标方法的参数</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span> <span class="o">=</span> <span class="n">pjp</span><span class="o">.</span><span class="na">getArgs</span><span class="o">();</span>
    <span class="c1">// 修改参数或者根据参数执行一些逻辑</span>
    <span class="c1">// ...</span>
    <span class="c1">// 调用proceed()方法并传入修改后的参数</span>
    <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">(</span><span class="n">args</span><span class="o">);</span> <span class="c1">// 传入修改后的参数</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"环绕结束：执行目标方法前，模拟关闭事务"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
<span class="o">}</span>

</code></pre></div></div><p>在环绕通知中，如果目标方法有参数，可以直接调用<code class="language-plaintext highlighter-rouge">pjp.proceed()</code>方法而不传递任何参数。这是因为<code class="language-plaintext highlighter-rouge">proceed()</code>方法会自动使用目标方法的原始参数进行执行。</p><p>如果要<strong>修改传入的参数</strong>，可以使用<code class="language-plaintext highlighter-rouge">proceed(Object[] args)</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="nd">@EnableAspectJAutoProxy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">TDemo7</span> <span class="n">tDemo7</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">TDemo7</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">modify</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">AnnotationAspectJProxy</span> <span class="o">{</span>
    <span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(void com.aotmd.test.TDemo7.*(..))"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">cut</span><span class="o">(){}</span>
    <span class="nd">@Around</span><span class="o">(</span><span class="s">"cut()"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"环绕："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
        <span class="nc">Object</span> <span class="n">obj</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">pjp</span><span class="o">.</span><span class="na">getArgs</span><span class="o">().</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">){</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="s">"修改"</span><span class="o">});</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改"</span><span class="o">+</span><span class="n">s</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除"</span><span class="o">);</span><span class="k">return</span> <span class="kc">true</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">环绕</span><span class="err">：</span><span class="n">save</span>
<span class="n">保存</span>
<span class="n">删除</span>
<span class="n">环绕</span><span class="err">：</span><span class="n">modify</span>
<span class="n">修改修改</span>
</code></pre></div></div><p>这里为了正常调用无参数的<code class="language-plaintext highlighter-rouge">save</code>方法，做了一个判断，不管传入什么字符串给<code class="language-plaintext highlighter-rouge">modify</code>，都会被hook为<code class="language-plaintext highlighter-rouge">修改</code>字符串。</p><p>当然，也可以区分切点，就不需要判断了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Around</span><span class="o">(</span><span class="s">"execution(void com.aotmd.test.TDemo7.modify(..))"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"环绕："</span><span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="nc">Object</span> <span class="n">obj</span><span class="o">=</span><span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="s">"修改"</span><span class="o">});</span>
    <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</strong></p><p>Spring AOP实现AOP的方式是动态代理，而AspectJ实现的方式是静态代理。Spring虽然支持AspectJ，但仅仅是支持AspectJ的切点解析和匹配，比如<code class="language-plaintext highlighter-rouge">@Before</code>注解和<code class="language-plaintext highlighter-rouge">execution()</code>语句，代理的底层实现还是JDK动态代理和CGLIB动态代理。</p><p>Spring AOP（动态代理）：</p><ul><li>Spring AOP基于代理模式，使用JDK动态代理或CGLIB动态代理来创建代理对象。</li><li>当目标对象实现了接口时，Spring AOP使用JDK动态代理来创建代理对象。</li><li>当目标对象没有实现接口时，Spring AOP使用CGLIB动态代理来创建代理对象。</li><li>Spring AOP通过在运行时动态地创建代理对象，并将切面逻辑织入到代理对象的方法中来实现AOP。</li></ul><p>AspectJ（静态代理）：</p><ul><li>AspectJ是一个独立的AOP框架，它使用静态代理来实现AOP。</li><li>AspectJ通过编译时织入（CTW）或类加载时织入（LTW）的方式，在编译或加载阶段将切面逻辑织入到目标类中。</li></ul><hr /><p><strong>使用<code class="language-plaintext highlighter-rouge">@annotation()</code>切入点</strong></p><p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。</p><p>Spring提供的<code class="language-plaintext highlighter-rouge">@Transactional</code>就是一个非常好的例子。如果自己写的Bean希望在一个数据库事务中被调用，就在方法上标注上<code class="language-plaintext highlighter-rouge">@Transactional</code>，或者直接在class级别注解，表示所有public方法都被安排了。通过<code class="language-plaintext highlighter-rouge">@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p><p>以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，定义一个性能监控的注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">(</span><span class="no">METHOD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="no">RUNTIME</span><span class="o">)</span>
<span class="nd">@interface</span> <span class="nc">MetricTime</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>然后在需要被监控的关键方法上标注该注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span><span class="cm">/*这里生成的Bean名称为TDemo7*/</span>
<span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存"</span><span class="o">);}</span>
    <span class="nd">@MetricTime</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改"</span><span class="o">+</span><span class="n">s</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除"</span><span class="o">);</span><span class="k">return</span> <span class="kc">true</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后，使用<code class="language-plaintext highlighter-rouge">@annotation()</code>切入点，并定义具体逻辑：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">AnnotationAspectJProxy</span> <span class="o">{</span>
    <span class="nd">@Around</span><span class="o">(</span><span class="s">"@annotation(com.aotmd.test.MetricTime) &amp;&amp; @annotation(m)"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">,</span><span class="nc">MetricTime</span> <span class="n">m</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
            <span class="c1">// 写入日志或发送至JMX:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[Metrics] "</span> <span class="o">+</span> <span class="n">pjp</span><span class="o">.</span><span class="na">getTarget</span><span class="o">().</span><span class="na">getClass</span><span class="o">()+</span><span class="s">"-&gt;"</span> <span class="o">+</span><span class="n">pjp</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">t</span> <span class="o">+</span> <span class="s">"ms"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">around()</code>方法标注了<code class="language-plaintext highlighter-rouge">@annotation(com.aotmd.test.MetricTime) &amp;&amp; @annotation(m)</code>，<code class="language-plaintext highlighter-rouge">@annotation(com.aotmd.test.MetricTime)</code>意思为目标方法是带有<code class="language-plaintext highlighter-rouge">@MetricTime</code>注解的方法。</p><p>如果还要读取<code class="language-plaintext highlighter-rouge">MetricTime</code>注解实例的内容，就需要把<strong>注解实例</strong>注入到<strong>通知方法</strong>中，则需要追加<code class="language-plaintext highlighter-rouge">&amp;&amp; @annotation(m)</code>部分，通知方法应有一个名称为<code class="language-plaintext highlighter-rouge">m</code>的形式参数，类型为<code class="language-plaintext highlighter-rouge">MetricTime</code>，Spring会给<code class="language-plaintext highlighter-rouge">m</code>传入注解实例本身。因为形参带有类型，因此可以直接写成：<code class="language-plaintext highlighter-rouge">@Around("@annotation(m)")</code>。</p><p>如果不需要注解的内容，则直接写：<code class="language-plaintext highlighter-rouge">@Around("@annotation(com.aotmd.test.MetricTime)")</code>。</p><p>执行：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="nd">@EnableAspectJAutoProxy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">TDemo7</span> <span class="n">tDemo7</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">TDemo7</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">modify</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>保存
删除
修改123
[Metrics] class com.aotmd.test.TDemo7-&gt;modify: 4ms
</code></pre></div></div><h3 id="aop原理">AOP原理</h3><p>无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态<strong>织入</strong>了其他逻辑，因此，AOP本质上就是一个<strong>代理模式</strong>。</p><p>因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。</p><p>假设定义了一个<code class="language-plaintext highlighter-rouge">TDemo7</code>的Bean：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span><span class="cm">/*这里生成的Bean名称为TDemo7*/</span>
<span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"123"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改："</span><span class="o">+</span><span class="n">s</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除"</span><span class="o">);</span><span class="k">return</span> <span class="kc">true</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>这里多个一个字段<code class="language-plaintext highlighter-rouge">s</code>，切面类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Aspect</span>
<span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">AnnotationAspectJProxy</span> <span class="o">{</span>
    <span class="nd">@Around</span><span class="o">(</span><span class="s">"execution(void com.aotmd.test.TDemo7.*(..))"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">around</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">pjp</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-↓-环绕前-↓-"</span><span class="o">);</span>
        <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">pjp</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"-↑-环绕后-↑-"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">o</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="nd">@EnableAspectJAutoProxy</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test2</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">TDemo7</span> <span class="n">tDemo7</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">TDemo7</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
        <span class="n">tDemo7</span><span class="o">.</span><span class="na">modify</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="cm">/*直接访问对象字段*/</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tDemo7</span><span class="o">.</span><span class="na">s</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">tDemo7</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-↓-环绕前-↓-
保存
-↑-环绕后-↑-
删除
-↓-环绕前-↓-
修改：123
-↑-环绕后-↑-
null
class com.aotmd.test.TDemo7$$EnhancerBySpringCGLIB$$8c624483
</code></pre></div></div><p>其中对象字段<code class="language-plaintext highlighter-rouge">s</code>没有正常初始化赋值为<code class="language-plaintext highlighter-rouge">"123"</code>。为什么AOP代理后<code class="language-plaintext highlighter-rouge">s</code>就没有正常初始化呢？代理后会生成了一个子类替代原来的bean，生成子类这个过程中并没有初始化<code class="language-plaintext highlighter-rouge">s</code>。</p><p>Spring创建的AOP代理，代理类的名总是类似<code class="language-plaintext highlighter-rouge">class com.aotmd.test.TDemo7$$EnhancerBySpringCGLIB$$8c624483</code>，Java的类名实际上允许<code class="language-plaintext highlighter-rouge">$</code>字符。</p><p>为了让调用方无感，它必须继承自<code class="language-plaintext highlighter-rouge">TDemo7</code>，然后就可以使用向上提升的特性，让代码<code class="language-plaintext highlighter-rouge">TDemo7 tDemo7 = ac.getBean(TDemo7.class);</code>正常赋值。</p><p>该代理类会覆写所有<code class="language-plaintext highlighter-rouge">public</code>和<code class="language-plaintext highlighter-rouge">protected</code>方法，并在内部将<strong>调用委托给原始的<code class="language-plaintext highlighter-rouge">TDemo7</code>实例</strong>。</p><hr /><p>最终问题转换为：代理实例的成员变量<code class="language-plaintext highlighter-rouge">s</code>的值为什么是<code class="language-plaintext highlighter-rouge">null</code>。</p><p>实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"123"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>这是编译器实际编译的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">TDemo7</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span> <span class="c1">// 构造方法的第一行代码总是调用super()</span>
        <span class="n">s</span><span class="o">=</span><span class="s">"123"</span><span class="o">;</span> <span class="c1">// 继续初始化成员变量</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然而，对于Spring通过CGLIB动态创建的<code class="language-plaintext highlighter-rouge">class com.aotmd.test.TDemo7$$EnhancerBySpringCGLIB$$8c624483</code>代理类，它的构造方法中，<strong>并未调用<code class="language-plaintext highlighter-rouge">super()</code></strong>，因此，从父类继承的成员变量，包括<code class="language-plaintext highlighter-rouge">final</code>类型的成员变量，统统都没有初始化。</p><p>Java语言规定，任何类的构造方法，第一行必须调用<code class="language-plaintext highlighter-rouge">super()</code>，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？</p><p>这是因为自动加<code class="language-plaintext highlighter-rouge">super()</code>的功能是<strong>Java编译器</strong>实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用<code class="language-plaintext highlighter-rouge">super()</code>。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：</p><p>Spring通过CGLIB创建的代理类，<strong>不会初始化代理类自身继承的任何成员变量</strong>，包括<code class="language-plaintext highlighter-rouge">final</code>类型的成员变量。</p><hr /><p>Spring在创建代理对象时，会先创建目标对象，再把目标对象注入到代理对象中，虽然代理对象继承了目标对象，但他们之间的关系本质还是组合。</p><p>为什么Spring不初始化代理对象父类？就是因为代理对象可以访问到两个<code class="language-plaintext highlighter-rouge">s</code>变量，但只需要为其中一个进行赋值，而Spring选择给target赋值，也就不需要对代理类的父类进行初始化了。</p><p>那么，为什么不直接通过super调用父类方法（即原始类方法），而是通过持有的原始target调用方法？因为有一个工厂模式创建Bean，在实例化完成后，还可以调用其他方法改变字段状态：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">createMap</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"key"</span><span class="o">,</span><span class="s">"value"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">map</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>而这个状态，很难重新被代理子类复制并替换，而且这个过程也会消耗性能，且也违背了代理模式，因此持有一个原始对象进行访问是最好的。</p><p>而且本来Bean就可以通过set方法注入其他参数或Bean，通过继承可不会重复这些额外的操作。举个简单的例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A1</span> <span class="n">a1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A1</span><span class="o">();</span>
        <span class="n">a1</span><span class="o">.</span><span class="na">setS</span><span class="o">(</span><span class="s">"hello!"</span><span class="o">);</span>
        <span class="no">A1</span> <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">A1Proxy</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A1</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setS</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A1{s='"</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A1Proxy</span> <span class="kd">extends</span> <span class="no">A1</span><span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>要复制<code class="language-plaintext highlighter-rouge">A1</code>的状态，对于简单的<code class="language-plaintext highlighter-rouge">String</code>，复制值就行了，比如：<code class="language-plaintext highlighter-rouge">a2.setS(a1.getS())</code>，那么如果是复杂对象，比如<code class="language-plaintext highlighter-rouge">Map</code>，自定义的对象，那复制起来就麻烦了。还不如持有一个原始对象呢。</p><hr /><p>那么启用了AOP后，如何修复？修复很简单，只需要把直接访问字段的代码，改为通过方法访问，这样就会在代理实例内部将<strong>调用委托给原始的<code class="language-plaintext highlighter-rouge">TDemo7</code>实例</strong>。即添加<code class="language-plaintext highlighter-rouge">getS()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span><span class="cm">/*这里生成的Bean名称为TDemo7*/</span>
<span class="kd">class</span> <span class="nc">TDemo7</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"123"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getS</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">modify</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"修改："</span><span class="o">+</span><span class="n">s</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"删除"</span><span class="o">);</span><span class="k">return</span> <span class="kc">true</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果要修改<code class="language-plaintext highlighter-rouge">s</code>，那也要通过方法，而不是直接访问字段修改。</p><hr /><p>如果<code class="language-plaintext highlighter-rouge">getS()</code>添加了<code class="language-plaintext highlighter-rouge">final</code>，因为代理类无法覆写<code class="language-plaintext highlighter-rouge">final</code>方法（这一点绕不过JVM的ClassLoader检查），因为无法覆写，所以直接调用了父类的<code class="language-plaintext highlighter-rouge">getS()</code>，因此该方法返回的是代理类的<code class="language-plaintext highlighter-rouge">s</code>，即<code class="language-plaintext highlighter-rouge">null</code>。</p><p>通过打断点步入，也可以很清晰的看到调用非<code class="language-plaintext highlighter-rouge">final</code>修饰的方法，和<code class="language-plaintext highlighter-rouge">final</code>修饰方法的不同。</p><p>实际上，如果加上日志：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.slf4j<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>slf4j-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.7.30<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>ch.qos.logback<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>logback-classic<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.2.3<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>Spring在启动时会打印一个警告：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>22:01:34.283 [main] INFO  o.s.aop.framework.CglibAopProxy - Final method [public final java.lang.String com.aotmd.test.TDemo7.getS()] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.
</code></pre></div></div><p>最终方法<code class="language-plaintext highlighter-rouge">getS()</code>无法通过 CGLIB 获得代理：对此方法的调用不会路由到目标实例，并且可能会导致针对代理实例中未初始化的字段的 NPE。</p><p>因此，使用Bean时，<strong>总是调用方法</strong>，而非直接访问字段；编写Bean时，如果可能会被代理，就不要编写<code class="language-plaintext highlighter-rouge">public final</code>方法。这样才能保证有没有AOP，代码都能正常工作。</p><hr /><p><strong>要查看动态生成的类文件，可以使用</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">getProperties</span><span class="o">().</span><span class="na">put</span><span class="o">(</span><span class="s">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="nc">DebuggingClassWriter</span><span class="o">.</span><span class="na">DEBUG_LOCATION_PROPERTY</span><span class="o">,</span> <span class="s">"C:\\class"</span><span class="o">);</span>
</code></pre></div></div><p>这两行代码是用于设置Java动态代理生成的类文件保存路径的：</p><p><code class="language-plaintext highlighter-rouge">System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");</code></p><p>这行代码设置了一个系统属性，告诉Java虚拟机（JVM）在生成动态代理类时保存生成的类文件。动态代理是一种在运行时创建代理对象的机制，通常用于AOP（面向切面编程）等场景。通过设置这个属性为<code class="language-plaintext highlighter-rouge">true</code>，JVM会将生成的动态代理类文件保存在默认的临时目录中。</p><p><code class="language-plaintext highlighter-rouge">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "C:\\class");</code></p><p>这行代码设置了另一个系统属性，指定了动态代理生成的类文件保存的路径。在这里，<code class="language-plaintext highlighter-rouge">DebuggingClassWriter.DEBUG_LOCATION_PROPERTY</code>是一个常量，表示动态代理类文件保存路径的属性名，通常用于调试目的。通过将这个属性设置为<code class="language-plaintext highlighter-rouge">C:\\class</code>，表示将生成的动态代理类文件保存在<code class="language-plaintext highlighter-rouge">C:\class</code>目录下。</p><p>综合起来，这两行代码的作用是告诉JVM在生成动态代理类时保存生成的类文件，并指定保存路径为<code class="language-plaintext highlighter-rouge">C:\class</code>。这对于调试动态代理生成的类文件或者了解动态代理的工作原理可能会有帮助。</p><h2 id="访问数据库">访问数据库</h2><p>Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：</p><ul><li>创建全局<code class="language-plaintext highlighter-rouge">DataSource</code>实例，表示数据库连接池；</li><li>在需要读写数据库的方法内部，按如下步骤访问数据库：<ul><li>从全局<code class="language-plaintext highlighter-rouge">DataSource</code>实例获取<code class="language-plaintext highlighter-rouge">Connection</code>实例；</li><li>通过<code class="language-plaintext highlighter-rouge">Connection</code>实例创建<code class="language-plaintext highlighter-rouge">PreparedStatement</code>实例；</li><li>执行SQL语句，如果是查询，则通过<code class="language-plaintext highlighter-rouge">ResultSet</code>读取结果集，如果是修改，则获得<code class="language-plaintext highlighter-rouge">int</code>结果。</li></ul></li></ul><p>正确编写JDBC代码的关键是使用<code class="language-plaintext highlighter-rouge">try ... finally</code>释放资源，涉及到事务的代码需要正确提交或回滚事务。</p><h3 id="在spring使用jdbc">在Spring使用JDBC</h3><p>在Spring使用JDBC，首先通过IoC容器创建并管理一个<code class="language-plaintext highlighter-rouge">DataSource</code>实例，Spring提供了一个<code class="language-plaintext highlighter-rouge">JdbcTemplate</code>，可以方便地操作JDBC，因此，通常情况下，会实例化一个<code class="language-plaintext highlighter-rouge">JdbcTemplate</code>。顾名思义，这个类主要使用了Template模式。</p><p>编写<strong>示例代码或者测试代码</strong>时，强烈推荐使用<a href="http://hsqldb.org/">HSQLDB</a>这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p><p>依赖：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-jdbc<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.0.2.RELEASE<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.hsqldb<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>hsqldb<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.4.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.annotation<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.annotation-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-context<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.0.2.RELEASE<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.zaxxer<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>HikariCP<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>4.0.3<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>新建配置文件：</p><div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 数据库文件名为testdb:
</span><span class="py">jdbc.url</span><span class="p">=</span><span class="s">jdbc:hsqldb:file:testdb</span>

<span class="c"># Hsqldb默认的用户名是sa，口令是空字符串:
</span><span class="py">jdbc.username</span><span class="p">=</span><span class="s">sa</span>
<span class="py">jdbc.password</span><span class="p">=</span>
</code></pre></div></div><p>初始化数据库连接，并初始化<code class="language-plaintext highlighter-rouge">JdbcTemplate</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@PropertySource</span><span class="o">(</span><span class="s">"classpath:jdbc.properties"</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">Config</span> <span class="o">{</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${jdbc.url}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">jdbcUrl</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${jdbc.username}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">jdbcUsername</span><span class="o">;</span>

    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${jdbc.password}"</span><span class="o">)</span>
    <span class="nc">String</span> <span class="n">jdbcPassword</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="nc">DataSource</span> <span class="nf">createDataSource</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">HikariConfig</span> <span class="n">config</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HikariConfig</span><span class="o">();</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setJdbcUrl</span><span class="o">(</span><span class="n">jdbcUrl</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="n">jdbcUsername</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="n">jdbcPassword</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"autoCommit"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"connectionTimeout"</span><span class="o">,</span> <span class="s">"5"</span><span class="o">);</span>
        <span class="n">config</span><span class="o">.</span><span class="na">addDataSourceProperty</span><span class="o">(</span><span class="s">"idleTimeout"</span><span class="o">,</span> <span class="s">"60"</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">HikariDataSource</span><span class="o">(</span><span class="n">config</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="nc">JdbcTemplate</span> <span class="nf">createJdbcTemplate</span><span class="o">(</span><span class="nd">@Autowired</span> <span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">JdbcTemplate</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在上述配置中：</p><ol><li>通过<code class="language-plaintext highlighter-rouge">@PropertySource("jdbc.properties")</code>读取数据库配置文件；</li><li>通过<code class="language-plaintext highlighter-rouge">@Value("${jdbc.url}")</code>注入配置文件的相关配置；</li><li>创建一个<code class="language-plaintext highlighter-rouge">DataSource</code>实例，它的实际类型是<code class="language-plaintext highlighter-rouge">HikariDataSource</code>，创建时需要用到注入的配置；</li><li>创建一个<code class="language-plaintext highlighter-rouge">JdbcTemplate</code>实例，它需要注入<code class="language-plaintext highlighter-rouge">DataSource</code>，这是通过方法参数完成注入的。</li></ol><p>实体类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span><span class="o">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">email</span><span class="o">,</span><span class="n">password</span><span class="o">,</span><span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="n">password</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"User{id="</span> <span class="o">+</span> <span class="n">id</span> <span class="o">+</span> <span class="s">", email='"</span> <span class="o">+</span> <span class="n">email</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", password='"</span> <span class="o">+</span> <span class="n">password</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用与初始化：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">class</span> <span class="nc">UserService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">;</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//在Spring容器启动时自动创建一个users表</span>
        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"DROP TABLE IF EXISTS users"</span><span class="o">);</span>
        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"CREATE TABLE IF NOT EXISTS users ("</span>
                <span class="o">+</span> <span class="s">"id BIGINT IDENTITY NOT NULL PRIMARY KEY, "</span>
                <span class="o">+</span> <span class="s">"email VARCHAR(100) NOT NULL, "</span>
                <span class="o">+</span> <span class="s">"password VARCHAR(100) NOT NULL, "</span>
                <span class="o">+</span> <span class="s">"name VARCHAR(100) NOT NULL, "</span>
                <span class="o">+</span> <span class="s">"UNIQUE (email))"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">getUserById</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 注意传入的是ConnectionCallback:</span>
        <span class="k">return</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">((</span><span class="nc">ConnectionCallback</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;)</span> <span class="o">(</span><span class="n">conn</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span>
            <span class="c1">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span>
            <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="s">"SELECT * FROM users WHERE id = ?"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">rs</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">())</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="k">new</span> <span class="nf">User</span><span class="o">(</span>
                                <span class="n">rs</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="s">"id"</span><span class="o">),</span> 
                                <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"email"</span><span class="o">),</span> 
                                <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"password"</span><span class="o">),</span> 
                                <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">));</span> 
                    <span class="o">}</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未通过 ID 找到用户。"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">register</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 创建一个KeyHolder:</span>
        <span class="nc">KeyHolder</span> <span class="n">holder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GeneratedKeyHolder</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="mi">1</span> <span class="o">!=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span>
                <span class="c1">// 参数1:PreparedStatementCreator</span>
                <span class="o">(</span><span class="n">conn</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="c1">// 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:</span>
                    <span class="kt">var</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="s">"INSERT INTO users(email, password, name) VALUES(?, ?, ?)"</span><span class="o">,</span>
                            <span class="nc">Statement</span><span class="o">.</span><span class="na">RETURN_GENERATED_KEYS</span><span class="o">);</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">email</span><span class="o">);</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setObject</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
                    <span class="k">return</span> <span class="n">ps</span><span class="o">;</span>
                <span class="o">},</span>
                <span class="c1">// 参数2:KeyHolder</span>
                <span class="n">holder</span><span class="o">)</span>
        <span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"插入失败。"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 从KeyHolder中获取返回的自增值:</span>
        <span class="k">return</span> <span class="n">holder</span><span class="o">.</span><span class="na">getKey</span><span class="o">().</span><span class="na">longValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>启动：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test4</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">ac</span><span class="o">=</span><span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">Test4</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">UserService</span> <span class="n">userService</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">UserService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">userService</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="s">"1@qq.com"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">,</span> <span class="s">"小米"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">userService</span><span class="o">.</span><span class="na">getUserById</span><span class="o">(</span><span class="n">id</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
User{id=0, email='1@qq.com', password='123456', name='小米'}
</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/11/13/Spring/" target="_blank">https://acteds.github.io/2021/11/13/Spring/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1717254498', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
