<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>单元测试 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/06/07/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="单元测试"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言使用JUnit对java代码进行单元测试。"><meta name="og:description" content="引言使用JUnit对java代码进行单元测试。"><meta property="og:url" content="/2021/06/07/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-06-07"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="单元测试"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">单元测试</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/06/07 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 7244 字，约 21 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>使用JUnit对java代码进行单元测试。</p><h1 id="单元测试">单元测试</h1><p>单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p><p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p><p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了。</p><p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p><p>假定我们编写了一个计算阶乘的类，它只有一个静态方法来计算阶乘：</p><p><em>n</em>!=1×2×3×…×<em>n</em></p><p>代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Factorial</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">fact</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>要测试这个方法，一个很自然的想法是编写一个<code class="language-plaintext highlighter-rouge">main()</code>方法，然后运行一些测试代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fact</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> <span class="o">==</span> <span class="mi">3628800</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pass"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"fail"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样我们就可以通过运行<code class="language-plaintext highlighter-rouge">main()</code>方法来运行测试代码。</p><p>不过，使用<code class="language-plaintext highlighter-rouge">main()</code>方法测试有很多缺点：</p><p>一是只能有一个<code class="language-plaintext highlighter-rouge">main()</code>方法，不能把测试代码分离，二是没有打印出测试结果和期望结果，例如，<code class="language-plaintext highlighter-rouge">expected: 3628800, but actual: 123456</code>，三是很难编写一组通用的测试代码。</p><p>因此，我们需要一种测试框架，帮助我们编写测试。</p><h2 id="junit">JUnit</h2><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p><p>使用JUnit编写单元测试的好处在于，可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p><p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。JUnit目前最新版本是5。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.junit.jupiter<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>junit-jupiter<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.4.2<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>compile<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FactorialTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testFact</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">3628800</span><span class="o">,</span> <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(</span><span class="mi">10</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2432902008176640000L</span><span class="o">,</span> <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(</span><span class="mi">20</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>核心测试方法<code class="language-plaintext highlighter-rouge">testFact()</code>加上了<code class="language-plaintext highlighter-rouge">@Test</code>注解，这是JUnit要求的，它会把带有<code class="language-plaintext highlighter-rouge">@Test</code>的方法识别为测试方法。</p><p>在测试方法内部，我们用<code class="language-plaintext highlighter-rouge">assertEquals(1, Factorial.fact(1))</code>表示，期望<code class="language-plaintext highlighter-rouge">Factorial.fact(1)</code>返回<code class="language-plaintext highlighter-rouge">1</code>。</p><p><code class="language-plaintext highlighter-rouge">assertEquals(expected, actual)</code>是最常用的测试方法，它在<code class="language-plaintext highlighter-rouge">Assertion</code>类中定义。<code class="language-plaintext highlighter-rouge">Assertion</code>还定义了其他断言方法，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">assertTrue()</code>: 期待结果为<code class="language-plaintext highlighter-rouge">true</code></li><li><code class="language-plaintext highlighter-rouge">assertFalse()</code>: 期待结果为<code class="language-plaintext highlighter-rouge">false</code></li><li><code class="language-plaintext highlighter-rouge">assertNotNull()</code>: 期待结果为非<code class="language-plaintext highlighter-rouge">null</code></li><li><code class="language-plaintext highlighter-rouge">assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li><li>…</li></ul><p>如果测试结果与预期不符，<code class="language-plaintext highlighter-rouge">assertEquals()</code>会抛出异常：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>org.opentest4j.AssertionFailedError: 
预期:362880
实际:3628800
&lt;点击以查看差异&gt;
</code></pre></div></div><p>使用浮点数时，由于浮点数无法精确地进行比较，因此需要调用<code class="language-plaintext highlighter-rouge">assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEquals</span><span class="o">(</span><span class="mf">0.1</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">/</span> <span class="mf">10.0</span><span class="o">),</span> <span class="mf">0.0000001</span><span class="o">);</span>
</code></pre></div></div><p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p><p>使用JUnit进行单元测试，可以使用断言（<code class="language-plaintext highlighter-rouge">Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p><p>在编写单元测试的时候，要遵循一定的规范：</p><p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p><p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p><p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code class="language-plaintext highlighter-rouge">0</code>，<code class="language-plaintext highlighter-rouge">null</code>，空字符串<code class="language-plaintext highlighter-rouge">""</code>等情况。</p><h2 id="使用fixture">使用Fixture</h2><p>在一个单元测试中，经常编写多个<code class="language-plaintext highlighter-rouge">@Test</code>方法，来分组、分类对目标代码进行测试。<br /> 在测试的时候，经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code class="language-plaintext highlighter-rouge">@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p><p>JUnit提供了编写测试前准备、测试后清理的固定代码，称之为Fixture。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculator</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">add</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">sub</span><span class="o">(</span><span class="kt">long</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>测试的时候先初始化对象，可以通过<code class="language-plaintext highlighter-rouge">@BeforeEach</code>来初始化，通过<code class="language-plaintext highlighter-rouge">@AfterEach</code>来清理资源：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">DemoTest</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">++;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是第"</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="s">"次实例化"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">Calculator</span> <span class="n">calculator</span><span class="o">;</span>
    <span class="nd">@BeforeEach</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">calculator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Calculator</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@AfterEach</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">tearDown</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">calculator</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testAdd</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">calculator</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">150</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">calculator</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">50</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(</span><span class="mi">130</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">calculator</span><span class="o">.</span><span class="na">add</span><span class="o">(-</span><span class="mi">20</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testSub</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertEquals</span><span class="o">(-</span><span class="mi">100</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">calculator</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(-</span><span class="mi">150</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">calculator</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="mi">50</span><span class="o">));</span>
        <span class="n">assertEquals</span><span class="o">(-</span><span class="mi">130</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">calculator</span><span class="o">.</span><span class="na">sub</span><span class="o">(-</span><span class="mi">20</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在<code class="language-plaintext highlighter-rouge">DemoTest</code>测试中，有两个标记为<code class="language-plaintext highlighter-rouge">@BeforeEach</code>和<code class="language-plaintext highlighter-rouge">@AfterEach</code>的方法，它们会在运行<strong>每个</strong><code class="language-plaintext highlighter-rouge">@Test</code>方法前后自动运行。</p><p>还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。JUnit还提供了<code class="language-plaintext highlighter-rouge">@BeforeAll</code>和<code class="language-plaintext highlighter-rouge">@AfterAll</code>，它们在运行在<strong>所有</strong>@Test之前和之后。</p><p>因为<code class="language-plaintext highlighter-rouge">@BeforeAll</code>和<code class="language-plaintext highlighter-rouge">@AfterAll</code>在<strong>所有</strong><code class="language-plaintext highlighter-rouge">@Test</code>方法运行前后仅运行一次，因此，它们只能初始化<strong>静态变量</strong>，<code class="language-plaintext highlighter-rouge">@BeforeAll</code>和<code class="language-plaintext highlighter-rouge">@AfterAll</code>也只能标注在<strong>静态方法</strong>上。</p><p><strong>每次</strong>运行一个<code class="language-plaintext highlighter-rouge">@Test</code>方法前，JUnit首先会创建一个<code class="language-plaintext highlighter-rouge">XxxTest</code><strong>实例</strong>，会调用测试类的无参构造方法。所以每个<code class="language-plaintext highlighter-rouge">@Test</code><strong>方法</strong>内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code class="language-plaintext highlighter-rouge">@Test</code>方法带到另一个<code class="language-plaintext highlighter-rouge">@Test</code>方法。IDEA里测试多个<code class="language-plaintext highlighter-rouge">Test</code>，运行旁的下拉框里选择类就可以。</p><h2 id="异常测试">异常测试</h2><p>在编写JUnit测试的时候，除了正常的输入输出，还可以特别针对可能导致异常的情况进行测试。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factorial</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">fact</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="kt">long</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>现在，我们希望对异常进行测试：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.function.Executable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">jupiter</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.</span><span class="na">assertThrows</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertThrows</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Executable</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(-</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>JUnit提供<code class="language-plaintext highlighter-rouge">assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code class="language-plaintext highlighter-rouge">Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code class="language-plaintext highlighter-rouge">Factorial.fact(-1)</code>时，必定抛出<code class="language-plaintext highlighter-rouge">IllegalArgumentException</code>。<code class="language-plaintext highlighter-rouge">assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p><p>编写一个<code class="language-plaintext highlighter-rouge">Executable</code>的匿名类太繁琐了。实际上，<strong>Java 8</strong>开始引入了函数式编程，所有<strong>单方法接口</strong>都可以简写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">jupiter</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.</span><span class="na">assertThrows</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">assertThrows</span><span class="o">(</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Factorial</span><span class="o">.</span><span class="na">fact</span><span class="o">(-</span><span class="mi">1</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="条件测试">条件测试</h2><p>在运行测试的时候，有些时候，需要排出某些<code class="language-plaintext highlighter-rouge">@Test</code>方法，不要让它运行，这时，就可以使用<code class="language-plaintext highlighter-rouge">@Disabled</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Disabled</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">testBug101</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 这个测试不会运行</span>
<span class="o">}</span>
</code></pre></div></div><p>为什么不直接注释掉<code class="language-plaintext highlighter-rouge">@Test</code>，而是要加一个<code class="language-plaintext highlighter-rouge">@Disabled</code>？这是因为注释掉<code class="language-plaintext highlighter-rouge">@Test</code>，JUnit就不知道这是个测试方法，而加上<code class="language-plaintext highlighter-rouge">@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tests run: 68, Failures: 2, Errors: 0, Skipped: 5
</code></pre></div></div><p>类似<code class="language-plaintext highlighter-rouge">@Disabled</code>这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的<code class="language-plaintext highlighter-rouge">@Test</code>方法。</p><p>一些常用的条件测试：</p><p><strong>在</strong>Windows平台执行的测试，<code class="language-plaintext highlighter-rouge">@EnableOnOs(OS.WINDOWS)</code>；</p><p><strong>不在</strong>Windows平台执行的测试，可以加上<code class="language-plaintext highlighter-rouge">@DisabledOnOs(OS.WINDOWS)</code>；</p><p>只能在Java 9或更高版本执行的测试，可以加上<code class="language-plaintext highlighter-rouge">@DisabledOnJre(JRE.JAVA_8)</code>；</p><p>只能在64位操作系统上执行的测试，可以用<code class="language-plaintext highlighter-rouge">@EnabledIfSystemProperty</code>判断：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@EnabledIfSystemProperty</span><span class="o">(</span><span class="n">named</span> <span class="o">=</span> <span class="s">"os.arch"</span><span class="o">,</span> <span class="n">matches</span> <span class="o">=</span> <span class="s">".*64.*"</span><span class="o">)</span>
</code></pre></div></div><p>需要传入环境变量<code class="language-plaintext highlighter-rouge">DEBUG=true</code>才能执行的测试，可以用<code class="language-plaintext highlighter-rouge">@EnabledIfEnvironmentVariable</code>；</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@EnabledIfEnvironmentVariable</span><span class="o">(</span><span class="n">named</span> <span class="o">=</span> <span class="s">"DEBUG"</span><span class="o">,</span> <span class="n">matches</span> <span class="o">=</span> <span class="s">"true"</span><span class="o">)</span>
</code></pre></div></div><p>当在JUnit中运行所有测试的时候，JUnit会给出执行的结果。在IDE中，我们能很容易地看到没有执行的测试。带有⊘标记的测试方法表示没有执行。</p><h2 id="参数化测试">参数化测试</h2><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法。</p><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。JUnit提供了一个<code class="language-plaintext highlighter-rouge">@ParameterizedTest</code>注解，用来进行参数化测试。</p><p>假设对<code class="language-plaintext highlighter-rouge">Math.abs()</code>进行测试，先用一组正数进行测试：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@ValueSource</span><span class="o">(</span><span class="n">ints</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">100</span> <span class="o">})</span>
<span class="kt">void</span> <span class="nf">testAbs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>再用一组负数进行测试：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@ValueSource</span><span class="o">(</span><span class="n">ints</span> <span class="o">=</span> <span class="o">{</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">100</span> <span class="o">})</span>
<span class="kt">void</span> <span class="nf">testAbsNegative</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(-</span><span class="n">x</span><span class="o">,</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>注意到参数化测试的注解是<code class="language-plaintext highlighter-rouge">@ParameterizedTest</code>，而不是普通的<code class="language-plaintext highlighter-rouge">@Test</code>。</p><p>实际的测试场景往往没有这么简单。假设我们自己编写了一个<code class="language-plaintext highlighter-rouge">StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringUtils</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">capitalize</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">toLowerCase</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="kt">void</span> <span class="nf">testCapitalize</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">,</span> <span class="nc">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">capitalize</span><span class="o">(</span><span class="n">input</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>参数如何传入？最简单的方法是通过<code class="language-plaintext highlighter-rouge">@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@MethodSource</span>
<span class="kt">void</span> <span class="nf">testCapitalize</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">,</span> <span class="nc">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">capitalize</span><span class="o">(</span><span class="n">input</span><span class="o">));</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Arguments</span><span class="o">&gt;</span> <span class="nf">testCapitalize</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span> <span class="c1">// arguments:</span>
            <span class="nc">Arguments</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"abc"</span><span class="o">,</span> <span class="s">"Abc"</span><span class="o">),</span> <span class="c1">//</span>
            <span class="nc">Arguments</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"APPLE"</span><span class="o">,</span> <span class="s">"Apple"</span><span class="o">),</span> <span class="c1">//</span>
            <span class="nc">Arguments</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"gooD"</span><span class="o">,</span> <span class="s">"Good"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>上面的代码很容易理解：静态方法<code class="language-plaintext highlighter-rouge">testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code class="language-plaintext highlighter-rouge">String</code>，正好作为测试方法的两个参数传入。</p><p>如果静态方法和测试方法的名称不同，<code class="language-plaintext highlighter-rouge">@MethodSource</code>也允许指定方法名。但使用默认同名方法最方便。</p><p>另一种传入测试参数的方法是使用<code class="language-plaintext highlighter-rouge">@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code class="language-plaintext highlighter-rouge">,</code>分隔，因此，上述测试又可以改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@CsvSource</span><span class="o">({</span> <span class="s">"abc, Abc"</span><span class="o">,</span> <span class="s">"APPLE, Apple"</span><span class="o">,</span> <span class="s">"gooD, Good"</span> <span class="o">})</span>
<span class="kt">void</span> <span class="nf">testCapitalize</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">,</span> <span class="nc">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">capitalize</span><span class="o">(</span><span class="n">input</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>如果有成百上千的测试输入，那么，直接写<code class="language-plaintext highlighter-rouge">@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code class="language-plaintext highlighter-rouge">@CsvFileSource</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@CsvFileSource</span><span class="o">(</span><span class="n">resources</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"/test-capitalize.csv"</span> <span class="o">})</span>
<span class="kt">void</span> <span class="nf">testCapitalizeUsingCsvFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">,</span> <span class="nc">String</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="nc">StringUtils</span><span class="o">.</span><span class="na">capitalize</span><span class="o">(</span><span class="n">input</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>JUnit只在classpath中查找指定的CSV文件，因此，<code class="language-plaintext highlighter-rouge">test-capitalize.csv</code>这个文件要放到<code class="language-plaintext highlighter-rouge">test</code>目录下，内容如下：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apple, Apple
HELLO, Hello
JUnit, Junit
reSource, Resource
</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/06/07/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" target="_blank">https://acteds.github.io/2021/06/07/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1726838758', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
