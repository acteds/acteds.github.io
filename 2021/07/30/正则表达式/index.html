<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>正则表达式 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="正则表达式"><meta name="keywords" content="Java,正则表达式"><meta name="og:keywords" content="Java,正则表达式"><meta name="description" content="引言正则表达式在java中的应用，包括：分组匹配、搜索替换、分割、反向引用、后向引用、零宽断言、平衡组/递归匹配。"><meta name="og:description" content="引言正则表达式在java中的应用，包括：分组匹配、搜索替换、分割、反向引用、后向引用、零宽断言、平衡组/递归匹配。"><meta property="og:url" content="/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-07-30"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="正则表达式"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">正则表达式</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/07/30 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#正则表达式" title="正则表达式">正则表达式</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 11215 字，约 33 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>正则表达式在java中的应用，包括：分组匹配、搜索替换、分割、反向引用、后向引用、零宽断言、平衡组/递归匹配。</p><h1 id="正则表达式">正则表达式</h1><p>正则表达式可以用字符串来描述规则，并用来匹配字符串。正则表达式是一套标准，它可以用于任何语言。Java标准库的<code class="language-plaintext highlighter-rouge">java.util.regex</code>包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。</p><p>要判断用户输入的年份是否是<code class="language-plaintext highlighter-rouge">20##</code>年，先写出规则如下：</p><p>一共有4个字符，分别是：<code class="language-plaintext highlighter-rouge">2</code>，<code class="language-plaintext highlighter-rouge">0</code>，<code class="language-plaintext highlighter-rouge">0~9任意数字</code>，<code class="language-plaintext highlighter-rouge">0~9任意数字</code>。</p><p>对应的正则表达式就是：<code class="language-plaintext highlighter-rouge">20\d\d</code>，其中<code class="language-plaintext highlighter-rouge">\d</code>表示任意一个数字。</p><p>把正则表达式转换为Java字符串就变成了<code class="language-plaintext highlighter-rouge">20\\d\\d</code>，注意Java字符串用<code class="language-plaintext highlighter-rouge">\\</code>表示<code class="language-plaintext highlighter-rouge">\</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">regex</span> <span class="o">=</span> <span class="s">"20\\d\\d"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2019"</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">regex</span><span class="o">));</span> <span class="c1">// true</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2100"</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">regex</span><span class="o">));</span> <span class="c1">// false</span>
</code></pre></div></div><p>正则表达式的匹配规则是从左到右按规则匹配。</p><p>如果正则表达式有特殊字符，那就需要用<code class="language-plaintext highlighter-rouge">\</code>转义。</p><p>单字符的匹配规则：</p><table><thead><tr><th style="text-align: left">正则表达式</th><th style="text-align: left">规则</th></tr></thead><tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A</code></td><td style="text-align: left">指定字符</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\u548c</code></td><td style="text-align: left">指定Unicode字符</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">.</code></td><td style="text-align: left">任意字符</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\d</code></td><td style="text-align: left">数字0~9</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\w</code></td><td style="text-align: left">大小写字母，数字和下划线</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\s</code></td><td style="text-align: left">任何不可见字符，等价于<code class="language-plaintext highlighter-rouge">[ \f\n\r\t\v]</code></td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\D</code></td><td style="text-align: left">非数字</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\W</code></td><td style="text-align: left">非\w</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">\S</code></td><td style="text-align: left">非\s</td></tr></tbody></table><p>多字符的匹配规则：</p><table><thead><tr><th style="text-align: left">正则表达式</th><th style="text-align: left">规则</th></tr></thead><tbody><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A*</code></td><td style="text-align: left">重复零次或更多次</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A+</code></td><td style="text-align: left">重复一次或更多次</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A?</code></td><td style="text-align: left">重复零次或一次</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A{n}</code></td><td style="text-align: left">重复<code class="language-plaintext highlighter-rouge">n</code>次</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A{n,}</code></td><td style="text-align: left">重复<code class="language-plaintext highlighter-rouge">n</code>次或更多次</td></tr><tr><td style="text-align: left"><code class="language-plaintext highlighter-rouge">A{n,m}</code></td><td style="text-align: left">重复<code class="language-plaintext highlighter-rouge">n</code>到<code class="language-plaintext highlighter-rouge">m</code>次</td></tr></tbody></table><p>控制符：</p><table><thead><tr><th style="text-align: left">正则表达式</th><th style="text-align: left">规则</th></tr></thead><tbody><tr><td style="text-align: left">[ABC]</td><td style="text-align: left">匹配<code class="language-plaintext highlighter-rouge">[]</code>内任意字符</td></tr><tr><td style="text-align: left">[A-F0-9xy]</td><td style="text-align: left">指定范围的字符，<code class="language-plaintext highlighter-rouge">-</code>在<code class="language-plaintext highlighter-rouge">[]</code>里是连字符，表示指定范围</td></tr><tr><td style="text-align: left">[<strong>^</strong>A-F]</td><td style="text-align: left">指定范围外的任意字符，<code class="language-plaintext highlighter-rouge">[^要排除的字符]</code></td></tr><tr><td style="text-align: left">AB<strong>|</strong>CD<strong>|</strong>EF</td><td style="text-align: left">AB或CD或EF，<code class="language-plaintext highlighter-rouge">|</code>表示或，从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</td></tr><tr><td style="text-align: left">(…)</td><td style="text-align: left">将子规则括起来，分组</td></tr></tbody></table><h2 id="分组匹配">分组匹配</h2><p>用<code class="language-plaintext highlighter-rouge">Pattern</code>对象匹配，匹配后获得一个<code class="language-plaintext highlighter-rouge">Matcher</code>对象，如果匹配成功，就可以直接从<code class="language-plaintext highlighter-rouge">Matcher.group(index)</code>返回子串：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pattern</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"(\\d{3,4})-(\\d{7,8})"</span><span class="o">);</span>
<span class="nc">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="s">"010-12345678"</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">matches</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">g0</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">g1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">g2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g0</span><span class="o">);</span><span class="c1">//表示匹配的整个字符串</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g1</span><span class="o">);</span><span class="c1">//表示第一个括号匹配的内容</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g2</span><span class="o">);</span><span class="c1">//表示第二个括号匹配的内容</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"匹配失败!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>010-12345678
010
12345678
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">Matcher</code>时，必须首先调用<code class="language-plaintext highlighter-rouge">matches()</code>判断是否匹配成功，匹配成功后，才能调用<code class="language-plaintext highlighter-rouge">group()</code>提取子串。</p><p>还可以为每个括号打标签，格式<code class="language-plaintext highlighter-rouge">(? &lt;标签名&gt;)</code>，这种方式叫命名捕获组。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pattern</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"(?&lt;f1&gt;\\d{3,4})-(?&lt;f2&gt;\\d{7,8})"</span><span class="o">);</span>
<span class="nc">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="s">"010-12345678"</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">matches</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="s">"f1"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="s">"f2"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f1</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f2</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"匹配失败!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="非贪婪表达式">非贪婪表达式</h2><p>对于<code class="language-plaintext highlighter-rouge">+</code>，<code class="language-plaintext highlighter-rouge">*</code>，<code class="language-plaintext highlighter-rouge">{1,}</code>,这样的能匹配任意多字符的表达式，它总是尽可能多地向后匹配，即贪婪匹配。要让表达式变成非贪婪的，直接在后面加个<code class="language-plaintext highlighter-rouge">?</code>号即可。非贪婪匹配，是在保证整体匹配的情况下，尽量少匹配。</p><p>对于<code class="language-plaintext highlighter-rouge">a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索<code class="language-plaintext highlighter-rouge">aabab</code>的话，它会匹配整个字符串，这被称为<strong>贪婪</strong>匹配。</p><p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code class="language-plaintext highlighter-rouge">?</code>。这样<code class="language-plaintext highlighter-rouge">.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下<strong>使用最少的重复</strong>。</p><p><code class="language-plaintext highlighter-rouge">a.*?b</code>匹配最短的，以<code class="language-plaintext highlighter-rouge">a</code>开始，以<code class="language-plaintext highlighter-rouge">b</code>结束的字符串。如果把它应用于<code class="language-plaintext highlighter-rouge">aabab</code>的话，它会匹配<code class="language-plaintext highlighter-rouge">aab</code>（第一到第三个字符）和<code class="language-plaintext highlighter-rouge">ab</code>（第四到第五个字符）。为什么第一个匹配是<code class="language-plaintext highlighter-rouge">aab</code>（第一到第三个字符）而不是<code class="language-plaintext highlighter-rouge">ab</code>（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权。</p><h2 id="搜索和替换">搜索和替换</h2><h3 id="分割字符串">分割字符串</h3><p>使用正则表达式分割字符串可以实现更加灵活的功能。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"a b c"</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">);</span> <span class="c1">// { "a", "b", "c" }</span>
<span class="s">"a b  c"</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">);</span> <span class="c1">// { "a", "b", "", "c" }</span>
<span class="s">"a, b ;; c"</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"[\\,\\;\\s]+"</span><span class="o">);</span> <span class="c1">// { "a", "b", "c" }</span>
</code></pre></div></div><h3 id="搜索字符串">搜索字符串</h3><p>使用正则表达式还可以搜索字符串。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"the quick brown fox jumps over the lazy dog."</span><span class="o">;</span>
<span class="nc">Pattern</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\wo\\w"</span><span class="o">);</span>
<span class="nc">Matcher</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="k">while</span> <span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">start</span><span class="o">(),</span> <span class="n">m</span><span class="o">.</span><span class="na">end</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sub</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>获取到<code class="language-plaintext highlighter-rouge">Matcher</code>对象后，不需要调用<code class="language-plaintext highlighter-rouge">matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code class="language-plaintext highlighter-rouge">find()</code>方法，在整个串中搜索能匹配上<code class="language-plaintext highlighter-rouge">\\wo\\w</code>规则的子串，并打印出来。这种方式比<code class="language-plaintext highlighter-rouge">String.indexOf()</code>要灵活得多，搜索的规则是3个字符：中间必须是<code class="language-plaintext highlighter-rouge">o</code>，前后两个必须是字符<code class="language-plaintext highlighter-rouge">[A-Za-z0-9_]</code>。</p><h3 id="替换字符串">替换字符串</h3><p>使用正则表达式替换字符串，可以直接调用<code class="language-plaintext highlighter-rouge">String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"The     quick\t\t brown   fox  jumps   over the  lazy dog."</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">,</span> <span class="s">" "</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">);</span> <span class="c1">// "The quick brown fox jumps over the lazy dog."</span>
</code></pre></div></div><p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p><h3 id="反向引用">反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code class="language-plaintext highlighter-rouge">&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code class="language-plaintext highlighter-rouge">replaceAll()</code>的时候，传入的第二个参数可以使用<code class="language-plaintext highlighter-rouge">$1</code>、<code class="language-plaintext highlighter-rouge">$2</code>来反向引用匹配到的子串。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"the quick brown fox jumps over the lazy dog."</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s([a-z]{4})\\s"</span><span class="o">,</span> <span class="s">" &lt;b&gt;$1&lt;/b&gt; "</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</code></pre></div></div><p>上述代码的运行结果是：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.
</code></pre></div></div><p>它实际上把任何4字符单词的前后用<code class="language-plaintext highlighter-rouge">&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于<code class="language-plaintext highlighter-rouge">" &lt;b&gt;$1&lt;/b&gt; "</code>，它用匹配的分组子串<code class="language-plaintext highlighter-rouge">([a-z]{4})</code>替换了<code class="language-plaintext highlighter-rouge">$1</code>。在这里不能使用命名捕获组。</p><h3 id="查找替换">查找替换</h3><p><code class="language-plaintext highlighter-rouge">appendTail</code> 和 <code class="language-plaintext highlighter-rouge">appendReplacement</code> 是 <code class="language-plaintext highlighter-rouge">Matcher</code> 类的方法，用于处理正则表达式的匹配结果。</p><ul><li><code class="language-plaintext highlighter-rouge">appendReplacement</code> 方法用于将匹配到的内容替换为指定的字符串，并将替换后的结果追加到一个字符串缓冲区中，结果也包含匹配前的字符串。</li><li><code class="language-plaintext highlighter-rouge">appendTail</code> 方法用于将匹配操作的最后一次匹配后的<strong>剩余字符串</strong>追加到字符串缓冲区中。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">template</span> <span class="o">=</span> <span class="s">"Hello, ${name}! You are learning ${lang}!"</span><span class="o">;</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"lang"</span><span class="o">,</span> <span class="s">"Java"</span><span class="o">);</span>
<span class="nc">StringBuilder</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\$\\{(.+?)}"</span><span class="o">).</span><span class="na">matcher</span><span class="o">(</span><span class="n">template</span><span class="o">);</span>
<span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">replacement</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">appendReplacement</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">replacement</span><span class="o">);</span><span class="c1">//替换为replacement并写入result；</span>
<span class="o">}</span>
<span class="n">matcher</span><span class="o">.</span><span class="na">appendTail</span><span class="o">(</span><span class="n">result</span><span class="o">);</span><span class="c1">//将最后的!写入result.</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div><p>第一次循环匹配到的内容是<code class="language-plaintext highlighter-rouge">${name}</code>，替换为<code class="language-plaintext highlighter-rouge">Bob</code>，然后将替换后的字符串<code class="language-plaintext highlighter-rouge">Hello, Bob</code>写入<code class="language-plaintext highlighter-rouge">result</code>，第二次循环匹配到的内容是<code class="language-plaintext highlighter-rouge">${lang}</code>，替换为<code class="language-plaintext highlighter-rouge">Java</code>，然后将替换后的字符串<code class="language-plaintext highlighter-rouge">You are learning Java</code>追加到<code class="language-plaintext highlighter-rouge">result</code>中。最后通过<code class="language-plaintext highlighter-rouge">appendTail</code>方法写入最后一个匹配后面的所有字符串，在这个示例里指<code class="language-plaintext highlighter-rouge">!</code>这个字符。</p><h2 id="处理选项">处理选项</h2><p>在 Java 的正则表达式中，有许多标志可以用来修改正则表达式的行为。以下是常见的标志及其作用：</p><ul><li><code class="language-plaintext highlighter-rouge">CASE_INSENSITIVE</code>（或 <code class="language-plaintext highlighter-rouge">i</code>）：忽略大小写，使匹配不区分大小写。</li><li><code class="language-plaintext highlighter-rouge">MULTILINE</code>（或 <code class="language-plaintext highlighter-rouge">m</code>）：多行模式，<strong>更改 <code class="language-plaintext highlighter-rouge">^</code> 和 <code class="language-plaintext highlighter-rouge">$</code> 的含义</strong>，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。</li><li><code class="language-plaintext highlighter-rouge">DOTALL</code>（或 <code class="language-plaintext highlighter-rouge">s</code>）：单行模式，<strong>更改 <code class="language-plaintext highlighter-rouge">.</code> 的含义</strong>，使它与每一个字符匹配（包括换行符 <code class="language-plaintext highlighter-rouge">\n</code>）。</li><li><code class="language-plaintext highlighter-rouge">UNICODE_CASE</code>（或 <code class="language-plaintext highlighter-rouge">u</code>）：启用 Unicode 感知的大小写折叠，使某些 Unicode 字符的大小写折叠匹配更准确。</li><li><code class="language-plaintext highlighter-rouge">CANON_EQ</code>：考虑规范等价性，使得在匹配过程中将规范等价的字符视为相同的字符。</li><li><code class="language-plaintext highlighter-rouge">UNIX_LINES</code>：启用 Unix 行模式，使 <code class="language-plaintext highlighter-rouge">\n</code> 被视为换行符。</li><li><code class="language-plaintext highlighter-rouge">LITERAL</code>：将模式作为字面值对待，而不进行解释或处理任何转义字符。</li><li><code class="language-plaintext highlighter-rouge">COMMENTS</code>：允许在正则表达式中使用<strong>空格和注释</strong>。在这种模式下，你可以使用 <code class="language-plaintext highlighter-rouge">#</code> 符号开始注释，直到行尾。这样可以使正则表达式更易读。</li><li><code class="language-plaintext highlighter-rouge">UNICODE_CHARACTER_CLASS</code>：启用 Unicode 字符类。在这种模式下，预定义字符类（如 <code class="language-plaintext highlighter-rouge">\d</code>, <code class="language-plaintext highlighter-rouge">\w</code>, <code class="language-plaintext highlighter-rouge">\s</code> 等）将与 Unicode 字符集一起工作，而不仅仅是 ASCII 字符集。这意味着 <code class="language-plaintext highlighter-rouge">\d</code> 将匹配任何 Unicode 数字字符，而不仅仅是 ASCII 数字字符。</li></ul><p>可以使用这两个标志中的一个或两个，通过按位或 <code class="language-plaintext highlighter-rouge">|</code> 运算符将它们组合起来，然后将结果传递给 <code class="language-plaintext highlighter-rouge">Pattern.compile()</code> 方法，以创建具有所需行为的正则表达式模式。</p><p>这些标志可以单独使用，也可以组合使用，例如可以使用 <code class="language-plaintext highlighter-rouge">CASE_INSENSITIVE | MULTILINE</code> 来同时忽略大小写并启用多行模式。在 Java 中，这些标志可以通过在<strong>正则表达式字符串前面</strong>加上 <code class="language-plaintext highlighter-rouge">(?...)</code> 来指定，例如 <code class="language-plaintext highlighter-rouge">(?i)</code> 表示忽略大小写。</p><p>在 <code class="language-plaintext highlighter-rouge">Pattern.compile()</code> 方法中，可以使用 <code class="language-plaintext highlighter-rouge">|</code> 运算符将多个标志组合在一起。例如，要同时使用忽略大小写和多行模式，可以这样写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"^start"</span><span class="o">,</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">CASE_INSENSITIVE</span> <span class="o">|</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">MULTILINE</span><span class="o">);</span>
</code></pre></div></div><p>这将创建一个模式，该模式将匹配以 <code class="language-plaintext highlighter-rouge">start</code> 开头的任何行，不区分大小写。</p><p>一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 <code class="language-plaintext highlighter-rouge">dotAll</code>，意为点可以匹配所有字符，然而在指定该选项时，用的还是 <code class="language-plaintext highlighter-rouge">Singleline</code> 的首字母 <code class="language-plaintext highlighter-rouge">s</code>.</p><h2 id="高级">高级</h2><p><strong>本身不匹配字符</strong>的界定符表达式，即零宽断言：</p><table><thead><tr><th>正则表达式</th><th>规则</th></tr></thead><tbody><tr><td>^</td><td>字符串开头，如果为多行则为行开头</td></tr><tr><td>$</td><td>字符串结尾，如果为多行则为行结尾</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\b</code></td><td>单词的开头或结尾。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\B</code></td><td>匹配不是单词开头或结束的位置。</td></tr></tbody></table><p>实例：正则：<code class="language-plaintext highlighter-rouge">h(\B\w+\B)a (\1)</code>，文本：<code class="language-plaintext highlighter-rouge">haha ah</code>，<strong>组1内容为<code class="language-plaintext highlighter-rouge">ah</code></strong>,组2内容为<code class="language-plaintext highlighter-rouge">ah</code>，<code class="language-plaintext highlighter-rouge">(\B\w+\B)</code>中的<code class="language-plaintext highlighter-rouge">\B</code>会检测前后不是单词分隔，因此不会匹配<code class="language-plaintext highlighter-rouge">haha</code>而是匹配<code class="language-plaintext highlighter-rouge">ah</code>,<code class="language-plaintext highlighter-rouge">\1</code>则是引用前面括号的内容。如果正则改为<code class="language-plaintext highlighter-rouge">(\B\w+\B) (\1)</code>，则整个表达式会无法匹配，因为中间有个<code class="language-plaintext highlighter-rouge">a</code>没有匹配。</p><h3 id="后向引用">后向引用</h3><p>使用小括号指定一个子表达式后，<strong>匹配这个子表达式的文本</strong>可以在表达式或其它程序中作进一步的处理。</p><p>默认情况下，每个分组会自动拥有一个<strong>组号</strong>，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给<strong>未命名组</strong>分配，第二遍只给<strong>命名组</strong>分配，因此所有命名组的组号都大于未命名的组号。分组0对应整个正则表达式匹配的内容。</p><p><strong>后向引用</strong>用于重复搜索前面某个分组匹配的文本。例如，<code class="language-plaintext highlighter-rouge">\1</code>代表分组1匹配的文本。</p><p><code class="language-plaintext highlighter-rouge">(\b\w+\b)\s+\1</code>可以用来匹配重复的单词，像<code class="language-plaintext highlighter-rouge">go go</code>, 或<code class="language-plaintext highlighter-rouge">kitty kitty</code>。这个表达式首先是一个单词，即<code class="language-plaintext highlighter-rouge">(\b(\w+)\b)</code>，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符<code class="language-plaintext highlighter-rouge">(\s+)</code>，最后是匹配分组1中捕获的内容<code class="language-plaintext highlighter-rouge">(\1)</code>。</p><p>也可以自己指定子表达式的<strong>组名</strong>：<code class="language-plaintext highlighter-rouge">(?&lt;Word&gt;\w+)</code>(把尖括号换成<code class="language-plaintext highlighter-rouge">'</code>也行：<code class="language-plaintext highlighter-rouge">(?'Word'\w+)</code>,这样就把<code class="language-plaintext highlighter-rouge">\w+</code>的<strong>组名指定</strong>为Word了。</p><p>要<strong>反向引用</strong>这个分组<strong>捕获</strong>的内容，可以使用<code class="language-plaintext highlighter-rouge">\k&lt;Word&gt;</code>，也可以使用<code class="language-plaintext highlighter-rouge">\k'Word'</code>,所以上一个例子也可以写成这样：<code class="language-plaintext highlighter-rouge">(?&lt;Word&gt;\b\w+\b)\s+\k&lt;Word&gt;\b</code>。</p><p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p><table><thead><tr><th><strong>分类</strong></th><th><strong>代码/语法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>捕获</td><td><code class="language-plaintext highlighter-rouge">(exp)</code></td><td>匹配内容<code class="language-plaintext highlighter-rouge">exp</code>,<strong>自动命名组</strong>。</td></tr><tr><td>捕获</td><td><code class="language-plaintext highlighter-rouge">(?&lt;name&gt;exp)</code></td><td>匹配内容<code class="language-plaintext highlighter-rouge">exp</code>,<strong>名称为<code class="language-plaintext highlighter-rouge">name</code>的组</strong>，也可以写成<code class="language-plaintext highlighter-rouge">(?'name'exp)</code></td></tr><tr><td>捕获</td><td><code class="language-plaintext highlighter-rouge">(?:exp)</code></td><td>匹配内容<code class="language-plaintext highlighter-rouge">exp</code>,但<strong>不给此分组分配组号</strong>，即无法引用</td></tr><tr><td>反向引用</td><td><code class="language-plaintext highlighter-rouge">\1</code></td><td>自动分组1匹配的文本，<code class="language-plaintext highlighter-rouge">\2</code>以此类推。</td></tr><tr><td>反向引用</td><td><code class="language-plaintext highlighter-rouge">\k&lt;name&gt;</code></td><td>命名分组<strong>name</strong>匹配的文本，也可以写成<code class="language-plaintext highlighter-rouge">\k'name'</code></td></tr><tr><td>零宽断言</td><td><code class="language-plaintext highlighter-rouge">(?=exp)</code></td><td>保证此语句后面，有匹配<strong>表达式<code class="language-plaintext highlighter-rouge">exp</code>所匹配内容</strong>的权利。</td></tr><tr><td>零宽断言</td><td><code class="language-plaintext highlighter-rouge">(?&lt;=exp)</code></td><td>保证此语句前面，有匹配<strong>表达式<code class="language-plaintext highlighter-rouge">exp</code>所匹配内容</strong>的权利。</td></tr><tr><td>零宽断言</td><td><code class="language-plaintext highlighter-rouge">(?!exp)</code></td><td>匹配后面<strong>跟的不是</strong><code class="language-plaintext highlighter-rouge">exp</code>的位置</td></tr><tr><td>零宽断言</td><td><code class="language-plaintext highlighter-rouge">(?&lt;!exp)</code></td><td>匹配<strong>前面不是</strong><code class="language-plaintext highlighter-rouge">exp</code>的位置</td></tr><tr><td>注释</td><td><code class="language-plaintext highlighter-rouge">(?#comment)</code></td><td>提供注释让人阅读，java不支持。</td></tr></tbody></table><h3 id="零宽断言">零宽断言</h3><p>接下来的四个用于<strong>检测</strong>内容，内容应该满足一定的条件(即断言)，因此它们也被称为<strong>零宽断言</strong>。</p><p>文本：<code class="language-plaintext highlighter-rouge">I'm singing while you're dancing.</code></p><h4 id="exp"><code class="language-plaintext highlighter-rouge">(?=exp)</code></h4><p><code class="language-plaintext highlighter-rouge">(?=exp)</code>也叫<strong>零宽度正预测先行断言</strong>，它保证此语句后面，有匹配<strong>表达式<code class="language-plaintext highlighter-rouge">exp</code>所匹配内容</strong>的权利。</p><p>例如：</p><p><code class="language-plaintext highlighter-rouge">(\w+)(?=ing)(\w+)</code>，<code class="language-plaintext highlighter-rouge">(?=ing)</code>表示后面的语句必须还有匹配<code class="language-plaintext highlighter-rouge">ing</code>的权利，因此<code class="language-plaintext highlighter-rouge">singing</code>和<code class="language-plaintext highlighter-rouge">dancing</code>可以匹配，匹配<code class="language-plaintext highlighter-rouge">singing</code>的1组为：<code class="language-plaintext highlighter-rouge">sing</code>，2组为：<code class="language-plaintext highlighter-rouge">ing</code>，匹配<code class="language-plaintext highlighter-rouge">dancing</code>的1组为：<code class="language-plaintext highlighter-rouge">danc</code>，2组为：<code class="language-plaintext highlighter-rouge">ing</code>。</p><p>如果去掉后面的<code class="language-plaintext highlighter-rouge">(\w+)</code>，即变成<code class="language-plaintext highlighter-rouge">(\w+)(?=ing)</code>，匹配<code class="language-plaintext highlighter-rouge">singing</code>的1组也不会变成<code class="language-plaintext highlighter-rouge">singing</code>,因为<code class="language-plaintext highlighter-rouge">(?=ing)</code>要保证后面的语句还有匹配<code class="language-plaintext highlighter-rouge">ing</code>的权利，<code class="language-plaintext highlighter-rouge">(?=ing)</code>限制了贪婪表达式的权利，1组还是匹配<code class="language-plaintext highlighter-rouge">sing</code>。对于<code class="language-plaintext highlighter-rouge">dancing</code>同理，1组还是匹配<code class="language-plaintext highlighter-rouge">danc</code>。</p><p>如果去掉前面的<code class="language-plaintext highlighter-rouge">\w+</code>，即变成<code class="language-plaintext highlighter-rouge">()(?=ing)(\w+)</code>，匹配<code class="language-plaintext highlighter-rouge">singing</code>的2组也不会变成<code class="language-plaintext highlighter-rouge">singing</code>,因为<code class="language-plaintext highlighter-rouge">(?=ing)</code>要保证后面的语句还有<strong>匹配</strong><code class="language-plaintext highlighter-rouge">ing</code>的权利，因此字符<code class="language-plaintext highlighter-rouge">s</code>由于这条规则被跳过了，最后匹配为<code class="language-plaintext highlighter-rouge">inging</code>。对于<code class="language-plaintext highlighter-rouge">dancing</code>同理，2组匹配<code class="language-plaintext highlighter-rouge">ing</code>。</p><p>详细来说，<code class="language-plaintext highlighter-rouge">(?=ing)</code>首先在文本里找<code class="language-plaintext highlighter-rouge">ing</code>，第一处开始索引为5，在这之前的字符串<code class="language-plaintext highlighter-rouge">I'm s</code>就被跳过了，从索引5开始的字符串<code class="language-plaintext highlighter-rouge">inging while you're dancing.</code>丢给后续表达式匹配。所以<code class="language-plaintext highlighter-rouge">\w+</code>匹配了<code class="language-plaintext highlighter-rouge">inging</code>，对于未处理的部分继续循环操作，然后继续查找<code class="language-plaintext highlighter-rouge">ing</code>，第二处在索引29，所以<code class="language-plaintext highlighter-rouge">\w+</code>匹配了<code class="language-plaintext highlighter-rouge">ing</code>。</p><h4 id="exp-1"><code class="language-plaintext highlighter-rouge">(?&lt;=exp)</code></h4><p><code class="language-plaintext highlighter-rouge">(?&lt;=exp)</code>也叫<strong>零宽度正回顾后发断言</strong>，它保证此语句前面，有匹配<strong>表达式<code class="language-plaintext highlighter-rouge">exp</code>所匹配内容</strong>的权利。</p><p>例如：</p><p><code class="language-plaintext highlighter-rouge">(\w+)(?&lt;=ing)(\w+)</code>,因此只有<code class="language-plaintext highlighter-rouge">singing</code>可以匹配，1组为：<code class="language-plaintext highlighter-rouge">sing</code>，2组为：<code class="language-plaintext highlighter-rouge">ing</code>，1组为什么不能是<code class="language-plaintext highlighter-rouge">singing</code>，实际上是可以的，但这样做了2组就没得匹配了，导致整个式子不匹配了。为什么<code class="language-plaintext highlighter-rouge">dancing</code>不能匹配呢，因为<code class="language-plaintext highlighter-rouge">(?&lt;=ing)</code>保证前面的语句有匹配<code class="language-plaintext highlighter-rouge">ing</code>的权利，因此对于<code class="language-plaintext highlighter-rouge">dancing</code>来说1组为<code class="language-plaintext highlighter-rouge">dancing</code>，2组没内容了，因此整个表达式不成立。</p><p>如果去掉前面的<code class="language-plaintext highlighter-rouge">\w+</code>，即变成<code class="language-plaintext highlighter-rouge">()(?&lt;=ing)(\w+)</code>，匹配<code class="language-plaintext highlighter-rouge">singing</code>的2组也不会变成<code class="language-plaintext highlighter-rouge">singing</code>,因为<code class="language-plaintext highlighter-rouge">(?&lt;=ing)</code>要保证前面的语句还有<strong>匹配</strong><code class="language-plaintext highlighter-rouge">ing</code>的权利，因此字符<code class="language-plaintext highlighter-rouge">sing</code>由于这条规则被跳过了，最后匹配还是为<code class="language-plaintext highlighter-rouge">ing</code>。</p><p>如果把二组改成<code class="language-plaintext highlighter-rouge">(\.)</code>,即变成<code class="language-plaintext highlighter-rouge">()(?&lt;=ing)(\.)</code>，则可以匹配<code class="language-plaintext highlighter-rouge">dancing</code>后面的<code class="language-plaintext highlighter-rouge">.</code>号，让整个表达式成立。</p><p>如果去掉后面的<code class="language-plaintext highlighter-rouge">(\w+)</code>，即变成<code class="language-plaintext highlighter-rouge">(\w+)(?&lt;=ing)</code>,则对于<code class="language-plaintext highlighter-rouge">(\w+)</code>,就可以匹配<code class="language-plaintext highlighter-rouge">singing</code>和<code class="language-plaintext highlighter-rouge">dancing</code>了，也就是说本来<code class="language-plaintext highlighter-rouge">(\w+)</code>可以匹配所有单词，由于<code class="language-plaintext highlighter-rouge">(?&lt;=ing)</code>的限制，单词结尾必须为<code class="language-plaintext highlighter-rouge">ing</code>。这样就变成与<code class="language-plaintext highlighter-rouge">(\w+ing)</code>一样了。实际上对于<code class="language-plaintext highlighter-rouge">(\w+)(?&lt;=ing)(\w+)</code>和<code class="language-plaintext highlighter-rouge">(\w+ing)(\w+)</code>没什么区别，但对于<code class="language-plaintext highlighter-rouge">()(?&lt;=ing)(\w+)</code>就<strong>不是</strong><code class="language-plaintext highlighter-rouge">(ing)(\w+)</code>了。</p><h4 id="运用">运用</h4><p>利用零宽断言，可以实现之前不可能实现的功能，比如为数字每三位添加一个<code class="language-plaintext highlighter-rouge">,</code>号。你可能想到</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"234567890"</span><span class="o">;</span>
<span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"(\\d{3})"</span><span class="o">);</span>
<span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">StringBuffer</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">appendReplacement</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">","</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">matcher</span><span class="o">.</span><span class="na">appendTail</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div><p>控制台：<code class="language-plaintext highlighter-rouge">234,567,890,</code>，似乎也还可以，但数字长度如果不是3的倍数就会出问题了：<code class="language-plaintext highlighter-rouge">String input = "1234567890";</code>，控制台：<code class="language-plaintext highlighter-rouge">123,456,789,0</code>。使用零宽断言可以解决这个问题：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"1234567890"</span><span class="o">;</span>
<span class="nc">Pattern</span> <span class="n">pattern</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"(\\d{1,3})(?=(\\d{3})+$)"</span><span class="o">);</span>
<span class="nc">Matcher</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">matcher</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">StringBuffer</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">matcher</span><span class="o">.</span><span class="na">find</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">matcher</span><span class="o">.</span><span class="na">appendReplacement</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">matcher</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">","</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">matcher</span><span class="o">.</span><span class="na">appendTail</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</code></pre></div></div><p>控制台：<code class="language-plaintext highlighter-rouge">1,234,567,890</code>。</p><p>对于正则<code class="language-plaintext highlighter-rouge">(\d{1,3})(?=(\d{3})+$)</code>部分解释如下：</p><p>第一个括号就不用说了，<code class="language-plaintext highlighter-rouge">(?=(\d{3})+$)</code>表示后面应该符合<code class="language-plaintext highlighter-rouge">(\d{3})+$</code>这个正则。<code class="language-plaintext highlighter-rouge">(\d{3})+$</code>即匹配长度是3的倍数的数字，匹配完后必须是字符串结尾。</p><p>对于第一次查询，<code class="language-plaintext highlighter-rouge">(\d{1,3})</code>取得数字<code class="language-plaintext highlighter-rouge">1</code>，之后的<code class="language-plaintext highlighter-rouge">234567890</code>符合这个要求。</p><p>对于第二次查询，<code class="language-plaintext highlighter-rouge">(\d{1,3})</code>取得数字<code class="language-plaintext highlighter-rouge">234</code>，之后的<code class="language-plaintext highlighter-rouge">567890</code>符合这个要求。</p><p>对于第三次查询，<code class="language-plaintext highlighter-rouge">(\d{1,3})</code>取得数字<code class="language-plaintext highlighter-rouge">567</code>，之后的<code class="language-plaintext highlighter-rouge">890</code>符合这个要求。</p><p>对于第四次查询，<code class="language-plaintext highlighter-rouge">(\d{1,3})</code>取得数字<code class="language-plaintext highlighter-rouge">890</code>，之后没有了，不符合零宽断言要求，因此不执行了，所以890后面也不会多出一个<code class="language-plaintext highlighter-rouge">,</code>号了。</p><p>如果<code class="language-plaintext highlighter-rouge">String input = "一共1234567890美元";</code>，则正则需要修改为<code class="language-plaintext highlighter-rouge">(\d{1,3})(?=(\d{3})+(?!\d))</code>，控制台：<code class="language-plaintext highlighter-rouge">一共1,234,567,890美元</code>，也就是将<code class="language-plaintext highlighter-rouge">$</code>修改为了<code class="language-plaintext highlighter-rouge">(?!\d)</code>，表示后面没有数字了，这看起来和<code class="language-plaintext highlighter-rouge">(?=exp)</code>很像，其实就是它的反面，也就是说<code class="language-plaintext highlighter-rouge">(?!\d)</code>等于<code class="language-plaintext highlighter-rouge">(?=[^\d])</code>，而<code class="language-plaintext highlighter-rouge">[^\d]</code>又能变成<code class="language-plaintext highlighter-rouge">\D</code>。</p><h4 id="exp-2"><code class="language-plaintext highlighter-rouge">(?!exp)</code></h4><p><code class="language-plaintext highlighter-rouge">(?!exp)</code>也叫<strong>零宽度负预测先行断言</strong>，它保证此语句后面，有<strong>不</strong>匹配<strong>表达式<code class="language-plaintext highlighter-rouge">exp</code>所匹配内容</strong>的权利。</p><p>对于<code class="language-plaintext highlighter-rouge">(?!\d)</code>等于<code class="language-plaintext highlighter-rouge">(?=[^\d])</code>。如果<code class="language-plaintext highlighter-rouge">exp</code>比较复杂就不能转换了，比如对于：<code class="language-plaintext highlighter-rouge">(?!(\d{3})+$)</code>,表示后面不符合<code class="language-plaintext highlighter-rouge">(\d{3})+$</code>，要准确转换为<code class="language-plaintext highlighter-rouge">(?=exp)</code>，不怎么可能。</p><h4 id="exp-3"><code class="language-plaintext highlighter-rouge">(?&lt;!exp)</code></h4><p><code class="language-plaintext highlighter-rouge">(?&lt;!exp)</code>也叫<strong>零宽度负回顾后发断言</strong>，它保证此语句前面，有<strong>不</strong>匹配<strong>表达式<code class="language-plaintext highlighter-rouge">exp</code>所匹配内容</strong>的权利。</p><p>对于<code class="language-plaintext highlighter-rouge">(?&lt;!\d)</code>等于<code class="language-plaintext highlighter-rouge">(?&lt;=[^\d])</code>。</p><h4 id="运用-1">运用</h4><p>利用零宽断言，可以实现之前不可能实现的功能。</p><p>文本：<code class="language-plaintext highlighter-rouge">singing while dancnig</code></p><p>我希望匹配不是以<code class="language-plaintext highlighter-rouge">ing</code>结尾的词，即匹配<code class="language-plaintext highlighter-rouge">while</code>和<code class="language-plaintext highlighter-rouge">dancnig</code>。</p><p>如果不使用零宽断言，你可能写出：<code class="language-plaintext highlighter-rouge">\b(\w+)([^ing])\b</code>，但它匹配了<code class="language-plaintext highlighter-rouge">singing </code>，第二组匹配的是空格,因为<code class="language-plaintext highlighter-rouge">[^ing]</code>实际上表示匹配<strong>一个</strong>不是<code class="language-plaintext highlighter-rouge">i</code>和<code class="language-plaintext highlighter-rouge">n</code>还有<code class="language-plaintext highlighter-rouge">g</code>的字符，因此还会额外消耗一个字符。</p><p>那么改成<code class="language-plaintext highlighter-rouge">\b(\w+)(ing)\b</code>？匹配了<code class="language-plaintext highlighter-rouge">sing</code>，额外消耗了3个字符。</p><p>那么改成<code class="language-plaintext highlighter-rouge">\b(\w+)(ing)?\b</code>匹配了全部。</p><p>因此只要不使用零宽断言就不可能达成目的。</p><p>如果使用<code class="language-plaintext highlighter-rouge">(?=exp)</code>,可以写出:<code class="language-plaintext highlighter-rouge">\b(\w+(?=[^ing]{3})[\w]{3})\b</code>,但<code class="language-plaintext highlighter-rouge">while</code>和<code class="language-plaintext highlighter-rouge">dancnig</code>也被排除了，因为<code class="language-plaintext highlighter-rouge">ile</code>的<code class="language-plaintext highlighter-rouge">i</code>被<code class="language-plaintext highlighter-rouge">[^ing]</code>排除匹配了。</p><p>只能使用<code class="language-plaintext highlighter-rouge">(?!exp)</code>了，可以写出:<code class="language-plaintext highlighter-rouge">\b(\w+(?!ing)[\w]{3})\b</code>,非常简单的达成目标了。</p><h3 id="平衡组递归匹配">平衡组/递归匹配</h3><p>有时我们需要匹配像<code class="language-plaintext highlighter-rouge">( 100 * ( 50 + 15 ) )</code>这样的可嵌套的层次性结构，这时简单地使用<code class="language-plaintext highlighter-rouge">\(.+\)</code>则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如<code class="language-plaintext highlighter-rouge">( 5 / ( 3 + 2 ) ) )</code>，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，<strong>配对</strong>的括号之间的内容呢？</p><p>为了避免<code class="language-plaintext highlighter-rouge">(</code>和<code class="language-plaintext highlighter-rouge">\(</code>把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把<code class="language-plaintext highlighter-rouge">xx &lt;aa &lt;bbb&gt; &lt;bbb&gt; aa&gt; yy</code>这样的字符串里，最长的配对的尖括号内的内容捕获出来？</p><p>这里需要用到以下的语法构造：</p><ul><li><code class="language-plaintext highlighter-rouge">(?'group')</code> 把捕获的内容命名为group,并压入<strong>堆栈(Stack)</strong></li><li><code class="language-plaintext highlighter-rouge">(?'-group')</code> 从堆栈上<strong>弹出最后</strong>压入堆栈的名为<code class="language-plaintext highlighter-rouge">group</code>的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li><li><code class="language-plaintext highlighter-rouge">(?(group)yes|no)</code> 如果堆栈上<strong>存在</strong>以名为<code class="language-plaintext highlighter-rouge">group</code>的捕获内容的话，继续匹配<code class="language-plaintext highlighter-rouge">yes</code>部分的表达式，否则继续匹配<code class="language-plaintext highlighter-rouge">no</code>部分</li><li><code class="language-plaintext highlighter-rouge">(?!)</code> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li></ul><p>我们需要做的是每碰到了左括号，就在压入一个<code class="language-plaintext highlighter-rouge">Open</code>,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span>                   #最外层的左括号
  <span class="o">[</span><span class="se">^&lt;</span><span class="o">&gt;]*</span>            #它后面非括号的内容
  <span class="o">(</span>
      <span class="o">(</span>
        <span class="o">(?</span><span class="s1">'Open'</span><span class="o">&lt;)</span>  #左括号，压入<span class="s2">"Open"</span>
        <span class="o">[</span><span class="se">^&lt;</span><span class="o">&gt;]*</span>      #左括号后面的内容
      <span class="o">)+</span>
      <span class="o">(</span>
        <span class="o">(?</span><span class="s1">'-Open'</span><span class="o">&gt;)</span> #右括号，弹出一个<span class="s2">"Open"</span>
        <span class="o">[</span><span class="se">^&lt;</span><span class="o">&gt;]*</span>      #右括号后面的内容
      <span class="o">)+</span>
  <span class="o">)*</span>
  <span class="o">(?(</span><span class="kd">Open</span><span class="o">)(?</span><span class="err">!</span><span class="o">))</span>     #最外层的右括号前检查
                    #若还有未弹出的<span class="s2">"Open"</span>
                    #则匹配失败
<span class="o">&gt;</span>                #最外层的右括号
</code></pre></div></div><p>注意：java中不支持。</p><p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<code class="language-plaintext highlighter-rouge">&lt;div&gt;</code>标签：<code class="language-plaintext highlighter-rouge">&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?'Open'&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?'-Open'&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;</code>.</p><h3 id="其他">其他</h3><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">\a</code></td><td>报警字符(打印它的效果是电脑嘀一声)</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\b</code></td><td>通常是单词分界位置，但如果在字符类里使用代表退格</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\t</code></td><td>制表符，Tab</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\r</code></td><td>回车</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\v</code></td><td>竖向制表符</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\f</code></td><td>换页符</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\n</code></td><td>换行符</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\e</code></td><td>Escape</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\0nn</code></td><td>ASCII代码中八进制代码为nn的字符</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\xnn</code></td><td>ASCII代码中十六进制代码为nn的字符</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\unnnn</code></td><td>Unicode代码中十六进制代码为nnnn的字符</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\cN</code></td><td>ASCII控制字符。比如\cC代表Ctrl+C</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\A</code></td><td>字符串开头(类似^，但不受处理多行选项的影响)</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\Z</code></td><td>字符串结尾或行尾(不受处理多行选项的影响)</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\z</code></td><td>字符串结尾(类似$，但不受处理多行选项的影响)</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\G</code></td><td>当前搜索的开头</td></tr><tr><td><code class="language-plaintext highlighter-rouge">\p{name}</code></td><td>Unicode中命名为name的字符类，例如\p{IsGreek}</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?&gt;exp)</code></td><td>贪婪子表达式，它会尽可能多地匹配<code class="language-plaintext highlighter-rouge">exp</code>，不会回溯。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?&lt;x&gt;-&lt;y&gt;exp)</code></td><td>平衡组，用于匹配一个字符串，其中<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>是平衡符号（通常是括号），<code class="language-plaintext highlighter-rouge">exp</code>是要匹配的内容。它可以用来匹配嵌套的结构，如HTML标签。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?im-nsx:exp)</code></td><td>在子表达式<code class="language-plaintext highlighter-rouge">exp</code>中改变处理选项，<code class="language-plaintext highlighter-rouge">i</code>表示不区分大小写，<code class="language-plaintext highlighter-rouge">m</code>表示多行模式，<code class="language-plaintext highlighter-rouge">n</code>表示禁止捕获，<code class="language-plaintext highlighter-rouge">s</code>表示将<code class="language-plaintext highlighter-rouge">.</code>视为匹配任何字符（包括换行符），<code class="language-plaintext highlighter-rouge">x</code>表示忽略空白和注释。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?im-nsx)</code></td><td>为表达式后面的部分改变处理选项，与上面类似。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?(exp)yes|no)</code></td><td>把<code class="language-plaintext highlighter-rouge">exp</code>当作零宽正向先行断言，如果在这个位置能匹配，使用<code class="language-plaintext highlighter-rouge">yes</code>作为此组的表达式；否则使用<code class="language-plaintext highlighter-rouge">no</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?(exp)yes)</code></td><td>同上，只是使用空表达式作为<code class="language-plaintext highlighter-rouge">no</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?(name)yes|no)</code></td><td>如果命名为<code class="language-plaintext highlighter-rouge">name</code>的组捕获到了内容，使用<code class="language-plaintext highlighter-rouge">yes</code>作为表达式；否则使用<code class="language-plaintext highlighter-rouge">no</code>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">(?(name)yes)</code></td><td>同上，只是使用空表达式作为<code class="language-plaintext highlighter-rouge">no</code>。</td></tr></tbody></table><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank">https://acteds.github.io/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1735301780', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
