<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java反射、注解、泛型 &mdash; 个人博客</title><link rel="stylesheet" href="https://acteds.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://acteds.github.io/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="https://acteds.github.io/feed.xml"><link rel="shortcut icon" href="https://acteds.github.io/favicon.ico"><meta property="og:title" content="Java反射、注解、泛型"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言  java反射、注解、泛型部分笔记。"><meta name="og:description" content="引言  java反射、注解、泛型部分笔记。"><meta property="og:url" content="https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-05-03"> <script src="https://acteds.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://acteds.github.io/assets/js/jquery-ui.js"></script> <script src="https://acteds.github.io/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://acteds.github.io/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://acteds.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://acteds.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://acteds.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://acteds.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java反射、注解、泛型"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java反射、注解、泛型</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/05/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://acteds.github.io/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 30670 字，约 88 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>  java反射、注解、泛型部分笔记。</p><h1 id="反射">反射</h1><p>  获取<strong>class</strong>的<strong>Class</strong>实例:<br />   直接通过<strong>class</strong>的静态变量<strong>class</strong>获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</code></pre></div></div><p>  通过实例变量提供的<code class="language-plaintext highlighter-rouge">getClass()</code>方法获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</code></pre></div></div><p>  通过静态方法<code class="language-plaintext highlighter-rouge">Class.forName()</code>获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"java.lang.String"</span><span class="o">);</span>
</code></pre></div></div><h2 id="class实例基本信息"><strong>Class实例基本信息:</strong></h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String</td><td>getName()</td><td>返回类的完全限定名。</td></tr><tr><td>String</td><td>getSimpleName()</td><td>返回类的简单名称，不包含包名部分。</td></tr><tr><td>String</td><td>getPackage().getName()</td><td>返回类所在包的名称。</td></tr><tr><td>boolean</td><td>isInterface()</td><td>判断是否为接口。</td></tr><tr><td>boolean</td><td>isEnum()</td><td>判断是否为枚举类型。</td></tr><tr><td>boolean</td><td>isArray()</td><td>判断是否为数组类型。</td></tr><tr><td>boolean</td><td>isPrimitive()</td><td>判断是否为基本数据类型。</td></tr><tr><td>Class</td><td>getSuperclass()</td><td>返回表示该类的父类的 Class 对象。</td></tr><tr><td>int</td><td>getModifiers()</td><td>返回表示类或接口的 Java 语言修饰符的整数。例如，public、static 等修饰符。</td></tr><tr><td>Class[]</td><td>getInterfaces()</td><td>返回一个包含表示<strong>该类</strong>实现的接口的 Class 对象的数组。(接口同理)</td></tr><tr><td>ClassLoader</td><td>getClassLoader()</td><td>返回该类的类加载器。</td></tr><tr><td>boolean</td><td>isAssignableFrom(Class)</td><td>判断当前 <code class="language-plaintext highlighter-rouge">Class</code> 对象所表示的类或接口与指定 <code class="language-plaintext highlighter-rouge">Class</code> 参数表示的类或接口是否相同，或是否是其超类或超接口。</td></tr></tbody></table><h2 id="访问字段的方法"><strong>访问字段的方法</strong></h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Field</td><td>getField(String name)</td><td>根据字段名获取某个public的field（包括父类继承）</td></tr><tr><td>Field</td><td>getDeclaredField(String name)</td><td>根据字段名获取当前类的某个field（不包括父类继承）</td></tr><tr><td>Field[]</td><td>getFields()</td><td>获取所有public的field（包括父类继承）</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td><td>获取当前类的所有field（不包括父类继承）</td></tr></tbody></table><p>  一个<code class="language-plaintext highlighter-rouge">Field</code>对象包含了一个字段的所有信息：</p><ul><li><code class="language-plaintext highlighter-rouge">getName()</code>：返回字段名称，例如，<code class="language-plaintext highlighter-rouge">"name"</code>；</li><li><code class="language-plaintext highlighter-rouge">getType()</code>：返回字段类型，也是一个<code class="language-plaintext highlighter-rouge">Class</code>实例，例如，<code class="language-plaintext highlighter-rouge">String.class</code>；</li><li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回字段的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li></ul><p>  <strong>Field的方法</strong></p><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>set(Object o,Object v)</td><td>设置指定对象o上此 Field 表示的字段的值为v。</td></tr><tr><td>Object</td><td>get(Object o)</td><td>返回指定对象o上此 Field 表示的字段的值。</td></tr><tr><td>void</td><td>setAccessible(boolean)</td><td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有字段)</td></tr></tbody></table><p>  通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">get(实例变量)</code>可以得到该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值<br />   通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">set(实例变量,新值)</code>可以设置该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值<br />   默认是不允许访问<code class="language-plaintext highlighter-rouge">private</code>字段的,可以通过调用<code class="language-plaintext highlighter-rouge">Field</code>的<code class="language-plaintext highlighter-rouge">setAccessible(true)</code>实现访问。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
        <span class="n">f</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span> <span class="c1">// "Xiao Ming"</span>
        <span class="n">f</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">p</span><span class="o">,</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="访问方法的方法"><strong>访问方法的方法</strong></h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>获取某个<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>（包括父类继承）name:方法名,parameterTypes:形式参数的Class</td></tr><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>获取当前类的某个<code class="language-plaintext highlighter-rouge">Method</code>（不包括父类继承）name:方法名,parameterTypes:形式参数的Class</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>获取所有<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>（包括父类继承）</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>获取当前类的所有<code class="language-plaintext highlighter-rouge">Method</code>（不包括父类继承）</td></tr></tbody></table><p>  一个<code class="language-plaintext highlighter-rouge">Method</code>对象包含一个方法的所有信息：</p><ul><li><code class="language-plaintext highlighter-rouge">getName()</code>：返回方法名称，例如：<code class="language-plaintext highlighter-rouge">"getScore"</code>；</li><li><code class="language-plaintext highlighter-rouge">getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code class="language-plaintext highlighter-rouge">String.class</code>；</li><li><code class="language-plaintext highlighter-rouge">getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code class="language-plaintext highlighter-rouge">{String.class, int.class}</code>；</li><li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回方法的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li></ul><p>  <strong>Method的方法</strong></p><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td> </td><td>invoke(Object o,Object …arg)</td><td>调用指定对象o上此 Method表示的方法,方法的形式参数为arg。若为静态方法,则o设置为null,</td></tr><tr><td>void</td><td>setAccessible(boolean b)</td><td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td></tr></tbody></table><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// String对象:</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello world"</span><span class="o">;</span>
<span class="c1">// 获取String substring(int)方法，参数为int:</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"substring"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 在s对象上调用该方法并获取结果:</span>
<span class="nc">String</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
<span class="c1">// 打印调用结果:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</code></pre></div></div><h2 id="访问构造方法的方法">访问构造方法的方法</h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Object</td><td>newInstance()</td><td>只能调用公有的无参数构造方法。</td></tr><tr><td>Constructor</td><td>getConstructor(Class … arg)</td><td>获取指定类的指定<strong>公有</strong>构造方法,arg为形式参数.</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class… arg)</td><td>获取指定类的构造方法,arg为形式参数.</td></tr><tr><td>Constructor[]</td><td>getConstructors()</td><td>返回该类的所有<strong>公有</strong>构造方法。</td></tr><tr><td>Constructor[]</td><td>getDeclaredConstructors()</td><td>返回该类的所有构造方法。</td></tr></tbody></table><p>  <strong>Constructor 的方法</strong></p><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Object</td><td>newInstance(Object …arg)</td><td>调用构造方法,参数为arg。</td></tr><tr><td>void</td><td>setAccessible(boolean b)</td><td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td></tr></tbody></table><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取String的Class实例:String s=new Stirng();</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="c1">// 调用构造方法:</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">cls</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="c1">// 获取构造方法Integer(int):Integer n1=new Integer(123);</span>
<span class="nc">Constructor</span> <span class="n">cons1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 调用构造方法:</span>
<span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">cons1</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span>
</code></pre></div></div><h2 id="动态代理">动态代理</h2><p>  有没有可能不编写实现类，直接在运行期创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例呢？<br />   这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例。<br />   什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：<br />   定义接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  编写实现类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  创建实例，转型为接口并调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloWorld</span><span class="o">();</span>
<span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
</code></pre></div></div><p>  这种方式就是我们通常编写代码的方式。<br />   还有一种方式是动态代码，我们仍然先定义了接口<code class="language-plaintext highlighter-rouge">Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建了一个<code class="language-plaintext highlighter-rouge">Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。<br />   一个最简单的动态代理实现如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Hello</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
            <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="c1">// 传入ClassLoader</span>
            <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="c1">// 传入要实现的接口</span>
            <span class="n">handler</span><span class="o">);</span> <span class="c1">// 传入处理调用方法的InvocationHandler</span>
        <span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  在运行期动态创建一个<code class="language-plaintext highlighter-rouge">interface</code>实例的方法如下：<br />   定义一个<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例，它负责实现接口的方法调用；<br />   通过<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建<code class="language-plaintext highlighter-rouge">interface</code>实例，它需要3个参数：</p><ol><li>使用的<code class="language-plaintext highlighter-rouge">ClassLoader</code>，通常就是接口类的<code class="language-plaintext highlighter-rouge">ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例。</li></ol><p>  将返回的<code class="language-plaintext highlighter-rouge">Object</code>强制转型为接口。<br />   动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloDynamicProxy</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">HelloDynamicProxy</span><span class="o">(</span><span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">handler</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span>
           <span class="k">this</span><span class="o">,</span>
           <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"morning"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
           <span class="k">new</span> <span class="nc">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="n">name</span> <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h1 id="注解">注解</h1><p>  注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。<br />   Java的注解可以分为三类：<br />   第一类是由编译器使用的注解，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code class="language-plaintext highlighter-rouge">@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>  这类注解不会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，它们在编译后就被编译器扔掉了。<br />   第二类是由工具处理<code class="language-plaintext highlighter-rouge">.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。<br />   第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code class="language-plaintext highlighter-rouge">@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>  定义一个注解时，还可以定义配置参数。配置参数可以包括：</p><ul><li>所有基本类型；</li><li>String；</li><li>枚举类型；</li><li>基本类型、String、Class以及枚举的数组。</li></ul><p>  因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。<br />   注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。<br />   此外，大部分注解会有一个名为<code class="language-plaintext highlighter-rouge">value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。即从<code class="language-plaintext highlighter-rouge">@Check(value=99)</code>省略为<code class="language-plaintext highlighter-rouge">@check(99)</code>。</p><h2 id="定义注解">定义注解</h2><p>  Java语言使用<code class="language-plaintext highlighter-rouge">@interface</code>语法来定义注解（<code class="language-plaintext highlighter-rouge">Annotation</code>），它的格式如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  注解的参数类似无参数方法，可以用<code class="language-plaintext highlighter-rouge">default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code class="language-plaintext highlighter-rouge">value</code>。</p><h3 id="元注解">元注解</h3><p>  有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="target">@Target</h4><p>  最常用的元注解是<code class="language-plaintext highlighter-rouge">@Target</code>。使用<code class="language-plaintext highlighter-rouge">@Target</code>可以定义<code class="language-plaintext highlighter-rouge">Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code class="language-plaintext highlighter-rouge">ElementType.TYPE</code>；</li><li>字段：<code class="language-plaintext highlighter-rouge">ElementType.FIELD</code>；</li><li>方法：<code class="language-plaintext highlighter-rouge">ElementType.METHOD</code>；</li><li>构造方法：<code class="language-plaintext highlighter-rouge">ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code class="language-plaintext highlighter-rouge">ElementType.PARAMETER</code>。</li></ul><p>  例如，定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在方法上，我们必须添加一个<code class="language-plaintext highlighter-rouge">@Target(ElementType.METHOD)</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在方法或字段上，可以把<code class="language-plaintext highlighter-rouge">@Target</code>注解参数变为数组<code class="language-plaintext highlighter-rouge">{ ElementType.METHOD, ElementType.FIELD }</code>：<br />   实际上<code class="language-plaintext highlighter-rouge">@Target</code>定义的<code class="language-plaintext highlighter-rouge">value</code>是<code class="language-plaintext highlighter-rouge">ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p><h4 id="retention">@Retention</h4><p>  另一个重要的元注解<code class="language-plaintext highlighter-rouge">@Retention</code>定义了<code class="language-plaintext highlighter-rouge">Annotation</code>的生命周期：</p><ul><li>仅编译期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code class="language-plaintext highlighter-rouge">RetentionPolicy.CLASS</code>；</li><li>运行期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.RUNTIME</code>。</li></ul><p>  如果<code class="language-plaintext highlighter-rouge">@Retention</code>不存在，则该<code class="language-plaintext highlighter-rouge">Annotation</code>默认为<code class="language-plaintext highlighter-rouge">CLASS</code>。因为通常我们自定义的<code class="language-plaintext highlighter-rouge">Annotation</code>都是<code class="language-plaintext highlighter-rouge">RUNTIME</code>，所以，务必要加上<code class="language-plaintext highlighter-rouge">@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="repeatable">@Repeatable</h4><p>  使用<code class="language-plaintext highlighter-rouge">@Repeatable</code>这个元注解可以定义<code class="language-plaintext highlighter-rouge">Annotation</code>是否可重复。这个注解应用不是特别广泛。<code class="language-plaintext highlighter-rouge">@Reports</code>是一个容器注解，用来包裹多个<code class="language-plaintext highlighter-rouge">@Report</code>注解。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repeatable</span><span class="o">(</span><span class="nc">Reports</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Reports</span> <span class="o">{</span>
    <span class="nc">Report</span><span class="o">[]</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  经过<code class="language-plaintext highlighter-rouge">@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code class="language-plaintext highlighter-rouge">@Report</code>注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"debug"</span><span class="o">)</span>
<span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"warning"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="inherited">@Inherited</h4><p>  使用<code class="language-plaintext highlighter-rouge">@Inherited</code>定义子类是否可继承父类定义的<code class="language-plaintext highlighter-rouge">Annotation</code>。<code class="language-plaintext highlighter-rouge">@Inherited</code>仅针对<code class="language-plaintext highlighter-rouge">@Target(ElementType.TYPE)</code>类型的<code class="language-plaintext highlighter-rouge">annotation</code>有效，并且仅针对<code class="language-plaintext highlighter-rouge">class</code>的继承，对<code class="language-plaintext highlighter-rouge">interface</code>的继承无效。</p><h2 id="处理注解">处理注解</h2><p>  Java的注解本身对代码逻辑没有任何影响。根据<code class="language-plaintext highlighter-rouge">@Retention</code>的配置：</p><ul><li><code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解在编译期就被丢掉了；</li><li><code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li><li><code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>  如何使用注解完全由工具决定。<code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解不但要使用，还经常需要编写。<br />   因此，我们只讨论如何读取<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解。<br />   因为注解定义后也是一种<code class="language-plaintext highlighter-rouge">class</code>，所有的注解都继承自<code class="language-plaintext highlighter-rouge">java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。<br />   Java提供的使用反射API读取<code class="language-plaintext highlighter-rouge">Annotation</code>的方法包括：<br />   判断某个注解是否存在于<code class="language-plaintext highlighter-rouge">Class</code>、<code class="language-plaintext highlighter-rouge">Field</code>、<code class="language-plaintext highlighter-rouge">Method</code>或<code class="language-plaintext highlighter-rouge">Constructor</code>：</p><ul><li><code class="language-plaintext highlighter-rouge">Class.isAnnotationPresent(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Field.isAnnotationPresent(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Method.isAnnotationPresent(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Constructor.isAnnotationPresent(Class)</code></li></ul><p>  例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断@Report是否存在于Person类:</span>
<span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><p>  使用反射API读取Annotation：</p><ul><li><code class="language-plaintext highlighter-rouge">Class.getAnnotation(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Field.getAnnotation(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Method.getAnnotation(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Constructor.getAnnotation(Class)</code></li></ul><p>  例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Person定义的@Report注解:</span>
<span class="nc">Report</span> <span class="n">report</span> <span class="o">=</span> <span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">type</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">level</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">level</span><span class="o">();</span>
</code></pre></div></div><p>  读取方法、字段和构造方法的<code class="language-plaintext highlighter-rouge">Annotation</code>和Class类似。但要读取方法参数的<code class="language-plaintext highlighter-rouge">Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span><span class="o">=</span><span class="mi">5</span><span class="o">)</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nd">@NotNull</span> <span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div><p>  要读取方法参数的注解，先用反射获取<code class="language-plaintext highlighter-rouge">Method</code>实例，然后读取方法参数的所有注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Method实例:</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 获取所有参数的Annotation:</span>
<span class="nc">Annotation</span><span class="o">[][]</span> <span class="n">annos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getParameterAnnotations</span><span class="o">();</span>
<span class="c1">// 第一个参数（索引为0）的所有Annotation:</span>
<span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annosOfName</span> <span class="o">=</span> <span class="n">annos</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">anno</span> <span class="o">:</span> <span class="n">annosOfName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">Range</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Range</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @Range注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="na">max</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">NotNull</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @NotNull注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已捕获NotNull"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="尝试手搓notnull-range">尝试手搓<strong>@NotNull @Range</strong></h2><p>  但对于方法的形式参数，Java的反射机制并不能直接获取参数的值,因此失败了。如果需要在方法运行时对参数进行检查，可以使用面向切面编程（AOP）结合反射来实现。<br />   不过对于对象的字段，可以直接通过反射获取字段的值，并进行判断。但要注意判断的时机需要另外的事件来触发。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="n">checkField</span><span class="o">(</span><span class="n">myClass</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkField</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredFields</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annotations</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotations</span><span class="o">();</span>
                <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">annotations</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="n">aClass</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">annotationType</span><span class="o">();</span>
                    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">NotNull</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">notNullDispose</span><span class="o">((</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">Range</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">rangeDispose</span><span class="o">(</span><span class="n">field</span><span class="o">,</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rangeDispose</span><span class="o">(</span><span class="nc">Field</span> <span class="n">field</span><span class="o">,</span> <span class="nc">Range</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span> <span class="nc">NotNull</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="c1">//              throw new IllegalArgumentException(text);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">NotNull</span> <span class="nf">notNullDispose</span><span class="o">(</span><span class="nc">NotNull</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">NotNull</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 不能为空"</span><span class="o">);</span>
<span class="c1">//          throw new IllegalArgumentException(n.value() + " 不能为空");</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"名称"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"地址"</span><span class="o">)</span>
    <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">address</span> <span class="o">=</span> <span class="s">"123456"</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">NotNull</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">Range</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">min</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kt">int</span> <span class="nf">max</span><span class="o">()</span> <span class="k">default</span> <span class="mi">255</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="泛型">泛型</h1><p>  泛型就是编写模板代码来适应任意类型；<br />   泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；<br />   注意泛型的继承关系：可以把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！），但不能把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变成父类）。<br />   使用<code class="language-plaintext highlighter-rouge">ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code class="language-plaintext highlighter-rouge">Object</code><br />   编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&amp;</span><span class="n">emsp</span><span class="o">;&amp;</span><span class="n">emsp</span><span class="o">;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>  
</code></pre></div></div><p>  编译器看到泛型类型<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>就可以自动推断出后面的<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>的泛型类型必须是<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><p>  除了<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code class="language-plaintext highlighter-rouge">Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>这个泛型接口。<br />   写法:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="静态方法">静态方法</h2><p>  编写泛型类时，要特别注意，泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。<br />   例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="c1">// 对静态方法使用&lt;T&gt;:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">create</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码会导致编译错误，我们无法在静态方法<code class="language-plaintext highlighter-rouge">create()</code>的方法参数和返回类型上使用泛型类型<code class="language-plaintext highlighter-rouge">T</code>。<br />   可以在<code class="language-plaintext highlighter-rouge">static</code>修饰符后面加一个<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，编译就能通过：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="c1">// 可以编译通过:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">create</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  但实际上，这个<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>和<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>类型的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>已经没有任何关系了。<br />   对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code class="language-plaintext highlighter-rouge">create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code>;这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。<code class="language-plaintext highlighter-rouge">public static &lt;T&gt; Pair&lt;T&gt; create(T first, T last) {</code> <code class="language-plaintext highlighter-rouge">static &lt;T&gt; </code>这个<code class="language-plaintext highlighter-rouge">T</code>就是语法标识,调用<code class="language-plaintext highlighter-rouge">create</code>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">create</span><span class="o">(</span><span class="s">"123"</span><span class="o">,</span><span class="s">"456"</span><span class="o">);</span>
</code></pre></div></div><ul><li>泛型类型是在实例化对象时确定的，而静态方法是在类加载时就可以直接调用的，无需创建对象实例。所以静态方法中的返回值、参数等不能依赖泛型类型<T>，必须将静态方法的泛型类型和实例类型的泛型类型区分开。</T></li><li>此外，静态方法是与类本身相关联的，而不是与类的实例相关联的。因此，即使创建了一个类的实例，静态方法也无法访问实例的泛型类型。静态方法由于随着类的加载而加载，不能访问类的泛型（因为在创建对象的时候才确定），因此必须定义自己的泛型类型。</li></ul><h2 id="多个泛型类型">多个泛型类型</h2><p>  泛型还可以定义多种类型。例如，我们希望<code class="language-plaintext highlighter-rouge">Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">K</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">K</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用的时候，需要指出两种类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"test"</span><span class="o">,</span> <span class="mi">123</span><span class="o">);</span>
</code></pre></div></div><p>  Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h2 id="擦拭法">擦拭法</h2><p>  所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。因此编译器把类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>视为<code class="language-plaintext highlighter-rouge">Object</code>；编译器根据<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>实现安全的强制转型。<br />   例如，我们编写了一个泛型类<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Object</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>  而虚拟机执行的代码并没有泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>  Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code class="language-plaintext highlighter-rouge">T</code>视为<code class="language-plaintext highlighter-rouge">Object</code>处理，但是，在需要转型的时候，编译器会根据<code class="language-plaintext highlighter-rouge">T</code>的类型自动为我们实行安全地强制转型。<br />   局限一：<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能是基本类型，例如<code class="language-plaintext highlighter-rouge">int</code>，因为实际类型是<code class="language-plaintext highlighter-rouge">Object</code>，<code class="language-plaintext highlighter-rouge">Object</code>类型无法持有基本类型：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pair&lt;int&gt; p = new Pair&lt;&gt;(1, 2); // compile error!
</code></pre></div></div><p>  局限二：无法取得带泛型的<code class="language-plaintext highlighter-rouge">Class</code>。观察以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Class</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Object</code>，我们对<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;</code>和<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型获取<code class="language-plaintext highlighter-rouge">Class</code>时，获取到的是同一个<code class="language-plaintext highlighter-rouge">Class</code>，也就是<code class="language-plaintext highlighter-rouge">Pair</code>类的<code class="language-plaintext highlighter-rouge">Class</code>。<br />   换句话说，所有泛型实例，无论<code class="language-plaintext highlighter-rouge">T</code>的类型是什么，<code class="language-plaintext highlighter-rouge">getClass()</code>返回同一个<code class="language-plaintext highlighter-rouge">Class</code>实例，因为编译后它们全部都是<code class="language-plaintext highlighter-rouge">Pair&lt;Object&gt;</code>。<br />   局限三：无法判断带泛型的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
<span class="c1">// Compile error:</span>
<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>  原因和前面一样，并不存在<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>，而是只有唯一的<code class="language-plaintext highlighter-rouge">Pair.class</code>。<br />   局限四：不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Compile error:</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码无法通过编译，因为构造方法的两行语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
</code></pre></div></div><p>  擦拭后实际上变成了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div><p>  这样一来，创建<code class="language-plaintext highlighter-rouge">new Pair&lt;String&gt;()</code>和创建<code class="language-plaintext highlighter-rouge">new Pair&lt;Integer&gt;()</code>就全部成了<code class="language-plaintext highlighter-rouge">Object</code>，显然编译器要阻止这种类型不对的代码。<br />   要实例化<code class="language-plaintext highlighter-rouge">T</code>类型，我们必须借助额外的<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>参数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>参数并通过反射来实例化<code class="language-plaintext highlighter-rouge">T</code>类型，使用的时候，也必须传入<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><p>  因为传入了<code class="language-plaintext highlighter-rouge">Class&lt;String&gt;</code>的实例，所以我们借助<code class="language-plaintext highlighter-rouge">String.class</code>就可以实例化<code class="language-plaintext highlighter-rouge">String</code>类型。</p><h3 id="不恰当的覆写方法">不恰当的覆写方法</h3><p>  有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  这是因为，定义的<code class="language-plaintext highlighter-rouge">equals(T t)</code>方法实际上会被擦拭成<code class="language-plaintext highlighter-rouge">equals(Object t)</code>，而这个方法是继承自<code class="language-plaintext highlighter-rouge">Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。<br />   换个方法名，避开与<code class="language-plaintext highlighter-rouge">Object.equals(Object)</code>的冲突就可以成功编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">same</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="泛型继承">泛型继承</h3><p>  一个类可以继承自一个泛型类。例如：父类的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>，子类的类型是<code class="language-plaintext highlighter-rouge">IntPair</code>，可以这么继承：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用的时候，因为子类<code class="language-plaintext highlighter-rouge">IntPair</code>并没有泛型类型，所以，正常使用即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntPair</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntPair</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div><p>  前面讲了，我们无法获取<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的<code class="language-plaintext highlighter-rouge">T</code>类型，即给定一个变量<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt; p</code>，无法从<code class="language-plaintext highlighter-rouge">p</code>中获取到<code class="language-plaintext highlighter-rouge">Integer</code>类型。<br />   但是，在父类是泛型类型的情况下，编译器就必须把类型<code class="language-plaintext highlighter-rouge">T</code>（对<code class="language-plaintext highlighter-rouge">IntPair</code>来说，也就是<code class="language-plaintext highlighter-rouge">Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code class="language-plaintext highlighter-rouge">IntPair</code>只能存取<code class="language-plaintext highlighter-rouge">Integer</code>这种类型。<br />   在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code class="language-plaintext highlighter-rouge">IntPair</code>可以获取到父类的泛型类型<code class="language-plaintext highlighter-rouge">Integer</code>。获取父类的泛型类型代码比较复杂：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.ParameterizedType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">IntPair</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">IntPair</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="nc">Type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getGenericSuperclass</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="nc">ParameterizedType</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ParameterizedType</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ParameterizedType</span><span class="o">)</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">Type</span><span class="o">[]</span> <span class="n">types</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">();</span> <span class="c1">// 可能有多个泛型类型</span>
            <span class="nc">Type</span> <span class="n">firstType</span> <span class="o">=</span> <span class="n">types</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 取第一个泛型类型</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">typeClass</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">firstType</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">typeClass</span><span class="o">);</span> <span class="c1">// Integer</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  因为Java引入了泛型，所以，只用<code class="language-plaintext highlighter-rouge">Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p><pre><code class="language-ascii">                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
</code></pre><h3 id="小结">小结</h3><p>  Java的泛型是采用擦拭法实现的；<br />   擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li><li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li></ul><p>  泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>；<br />   子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p><h2 id="extends通配符">extends通配符</h2><p>  我们前面已经讲到了泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类。<br />   假设我们定义了<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div><p>  然后，我们又针对<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PairHelper</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码是可以正常编译的。使用的时候，我们传入：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="nc">PairHelper</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div><p>  注意：传入的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，实际参数类型是<code class="language-plaintext highlighter-rouge">(Integer, Integer)</code>。<br />   既然实际参数是<code class="language-plaintext highlighter-rouge">Integer</code>类型，试试传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  直接运行，会得到一个编译错误：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">incompatible</span> <span class="nl">types:</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">converted</span> <span class="n">to</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span>
</code></pre></div></div><p>  原因很明显，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，因此，<code class="language-plaintext highlighter-rouge">add(Pair&lt;Number&gt;)</code>不接受参数类型<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>。<br />   但是从<code class="language-plaintext highlighter-rouge">add()</code>方法的代码可知，传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>  实际类型是<code class="language-plaintext highlighter-rouge">Integer</code>，引用类型是<code class="language-plaintext highlighter-rouge">Number</code>，没有问题。问题在于方法参数类型定死了只能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>。<br />   有没有办法使得方法参数接受<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。我们把代码改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  这样一来，给方法传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型时，它符合参数<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型。这种使用<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code class="language-plaintext highlighter-rouge">T</code>的上界限定在<code class="language-plaintext highlighter-rouge">Number</code>了。<br />   除了可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型，我们还可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型，<code class="language-plaintext highlighter-rouge">Pair&lt;BigDecimal&gt;</code>类型等等，因为<code class="language-plaintext highlighter-rouge">Double</code>和<code class="language-plaintext highlighter-rouge">BigDecimal</code>都是<code class="language-plaintext highlighter-rouge">Number</code>的子类。<br />   如果我们考察对<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型调用<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，实际的方法签名变成了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  即返回值是<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>的子类，因此，可以安全赋值给<code class="language-plaintext highlighter-rouge">Number</code>类型的变量：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  然后，我们不可预测实际类型就是<code class="language-plaintext highlighter-rouge">Integer</code>，例如，下面的代码是无法通过编译的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  这是因为实际的返回类型可能是<code class="language-plaintext highlighter-rouge">Integer</code>，也可能是<code class="language-plaintext highlighter-rouge">Double</code>或者其他类型，编译器只能确定类型一定是<code class="language-plaintext highlighter-rouge">Number</code>的子类（包括<code class="language-plaintext highlighter-rouge">Number</code>类型本身），但具体类型无法确定。<br />   我们再来考察一下<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的<code class="language-plaintext highlighter-rouge">set</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  不出意外，我们会得到一个编译错误：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>incompatible types: Integer cannot be converted to CAP#1
where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
</code></pre></div></div><p>  编译错误发生在<code class="language-plaintext highlighter-rouge">p.setFirst()</code>传入的参数是<code class="language-plaintext highlighter-rouge">Integer</code>类型。有些童鞋会问了，既然<code class="language-plaintext highlighter-rouge">p</code>的定义是<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>，那么<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>为什么不能传入<code class="language-plaintext highlighter-rouge">Integer</code>？<br />   原因还在于擦拭法。如果我们传入的<code class="language-plaintext highlighter-rouge">p</code>是<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>，显然它满足参数定义<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>，然而，<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>显然无法接受<code class="language-plaintext highlighter-rouge">Integer</code>类型。<br />   这就是<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>无法传递任何<code class="language-plaintext highlighter-rouge">Number</code>的子类型给<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>。<br />   这里唯一的例外是可以给方法参数传入<code class="language-plaintext highlighter-rouge">null</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// ok, 但是后面会抛出NullPointerException</span>
<span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span> <span class="c1">// NullPointerException</span>
</code></pre></div></div><h3 id="extends通配符的作用">extends通配符的作用</h3><p>  如果我们考察Java标准库的<code class="language-plaintext highlighter-rouge">java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span> <span class="c1">// 获取个数</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span> <span class="c1">// 根据索引获取指定元素</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 添加一个新元素</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 删除一个已有元素</span>
<span class="o">}</span>
</code></pre></div></div><p>  现在，让我们定义一个方法来处理列表的每个元素：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sumOfList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  为什么我们定义的方法参数类型是<code class="language-plaintext highlighter-rouge">List&lt;? extends Integer&gt;</code>而不是<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>？从方法内部代码看，传入<code class="language-plaintext highlighter-rouge">List&lt;? extends Integer&gt;</code>或者<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>是完全一样的，但是，注意到<code class="language-plaintext highlighter-rouge">List&lt;? extends Integer&gt;</code>的限制：</p><ul><li>允许调用<code class="language-plaintext highlighter-rouge">get()</code>方法获取<code class="language-plaintext highlighter-rouge">Integer</code>的引用；</li><li>不允许调用<code class="language-plaintext highlighter-rouge">set(? extends Integer)</code>方法并传入任何<code class="language-plaintext highlighter-rouge">Integer</code>的引用（<code class="language-plaintext highlighter-rouge">null</code>除外）。   因此，方法参数类型<code class="language-plaintext highlighter-rouge">List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code class="language-plaintext highlighter-rouge">List</code>的元素，不会修改<code class="language-plaintext highlighter-rouge">List</code>的元素（因为无法调用<code class="language-plaintext highlighter-rouge">add(? extends Integer)</code>、<code class="language-plaintext highlighter-rouge">remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code class="language-plaintext highlighter-rouge">List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用<code class="language-plaintext highlighter-rouge">set(null)</code>除外）。<h3 id="使用extends限定t类型">使用extends限定T类型</h3><p>  在定义泛型类型<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的时候，也可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div><p>  现在，我们只能定义：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">Integer</code>和<code class="language-plaintext highlighter-rouge">Double</code>都符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>。<br />   非<code class="language-plaintext highlighter-rouge">Number</code>类型将无法通过编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// compile error!</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Object</code>都不符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>，因为它们不是<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p></li></ul><h3 id="小结-1">小结</h3><p>  使用类似<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用获取<code class="language-plaintext highlighter-rouge">Number</code>引用的方法，例如：<code class="language-plaintext highlighter-rouge">Number n = obj.getFirst();</code>；</li><li>方法内部无法调用传入<code class="language-plaintext highlighter-rouge">Number</code>引用的方法（<code class="language-plaintext highlighter-rouge">null</code>除外），例如：<code class="language-plaintext highlighter-rouge">obj.setFirst(Number n);</code>。</li></ul><p>  即一句话总结：使用<code class="language-plaintext highlighter-rouge">extends</code>通配符表示可以读，不能写。<br />   使用类似<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义泛型类时表示：</p><ul><li>泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。</li></ul><h2 id="super通配符">super通配符</h2><p>  我们前面已经讲到了泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类。<br />   考察下面的<code class="language-plaintext highlighter-rouge">set</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是允许的，但是传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>是不允许的。<br />   和<code class="language-plaintext highlighter-rouge">extends</code>通配符相反，这次，我们希望接受<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型，以及<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>、<code class="language-plaintext highlighter-rouge">Pair&lt;Object&gt;</code>，因为<code class="language-plaintext highlighter-rouge">Number</code>和<code class="language-plaintext highlighter-rouge">Object</code>是<code class="language-plaintext highlighter-rouge">Integer</code>的父类，<code class="language-plaintext highlighter-rouge">setFirst(Number)</code>和<code class="language-plaintext highlighter-rouge">setFirst(Object)</code>实际上允许接受<code class="language-plaintext highlighter-rouge">Integer</code>类型。<br />   我们使用<code class="language-plaintext highlighter-rouge">super</code>通配符来改写这个方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  注意到<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。<br />   下面的代码可以被正常编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mf">12.3</span><span class="o">,</span> <span class="mf">4.56</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p2</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setSame</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  考察<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>方法，它的方法签名实际上是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">);</span>
</code></pre></div></div><p>  因此，可以安全地传入<code class="language-plaintext highlighter-rouge">Integer</code>类型。<br />   再考察<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，它的方法签名实际上是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span> <span class="kd">super</span> <span class="nc">Integer</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  这里注意到我们无法使用<code class="language-plaintext highlighter-rouge">Integer</code>类型来接收<code class="language-plaintext highlighter-rouge">getFirst()</code>的返回值，即下面的语句将无法通过编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  因为如果传入的实际类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，编译器无法将<code class="language-plaintext highlighter-rouge">Number</code>类型转型为<code class="language-plaintext highlighter-rouge">Integer</code>。<br />   注意：虽然<code class="language-plaintext highlighter-rouge">Number</code>是一个抽象类，我们无法直接实例化它。但是，即便<code class="language-plaintext highlighter-rouge">Number</code>不是抽象类，这里仍然无法通过编译。此外，传入<code class="language-plaintext highlighter-rouge">Pair&lt;Object&gt;</code>类型时，编译器也无法将<code class="language-plaintext highlighter-rouge">Object</code>类型转型为<code class="language-plaintext highlighter-rouge">Integer</code>。<br />   唯一可以接收<code class="language-plaintext highlighter-rouge">getFirst()</code>方法返回值的是<code class="language-plaintext highlighter-rouge">Object</code>类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  因此，使用<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt;</code>通配符表示：</p><ul><li>允许调用<code class="language-plaintext highlighter-rouge">set(? super Integer)</code>方法传入<code class="language-plaintext highlighter-rouge">Integer</code>的引用；</li><li>不允许调用<code class="language-plaintext highlighter-rouge">get()</code>方法获得<code class="language-plaintext highlighter-rouge">Integer</code>的引用。</li></ul><p>  唯一例外是可以获取<code class="language-plaintext highlighter-rouge">Object</code>的引用：<code class="language-plaintext highlighter-rouge">Object o = p.getFirst()</code>。<br />   换句话说，使用<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p><h3 id="对比extends和super通配符">对比extends和super通配符</h3><p>  我们再回顾一下<code class="language-plaintext highlighter-rouge">extends</code>通配符。作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型的区别在于：</p><ul><li><code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>允许调用读方法<code class="language-plaintext highlighter-rouge">T get()</code>获取<code class="language-plaintext highlighter-rouge">T</code>的引用，但不允许调用写方法<code class="language-plaintext highlighter-rouge">set(T)</code>传入<code class="language-plaintext highlighter-rouge">T</code>的引用（传入<code class="language-plaintext highlighter-rouge">null</code>除外）；</li><li><code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>允许调用写方法<code class="language-plaintext highlighter-rouge">set(T)</code>传入<code class="language-plaintext highlighter-rouge">T</code>的引用，但不允许调用读方法<code class="language-plaintext highlighter-rouge">T get()</code>获取<code class="language-plaintext highlighter-rouge">T</code>的引用（获取<code class="language-plaintext highlighter-rouge">Object</code>除外）。</li></ul><p>  一个是允许读不允许写，另一个是允许写不允许读。<br />   先记住上面的结论，我们来看Java标准库的<code class="language-plaintext highlighter-rouge">Collections</code>类定义的<code class="language-plaintext highlighter-rouge">copy()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="c1">// 把src的每个元素复制到dest中:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  它的作用是把一个<code class="language-plaintext highlighter-rouge">List</code>的每个元素依次添加到另一个<code class="language-plaintext highlighter-rouge">List</code>中。它的第一个参数是<code class="language-plaintext highlighter-rouge">List&lt;? super T&gt;</code>，表示目标<code class="language-plaintext highlighter-rouge">List</code>，第二个参数<code class="language-plaintext highlighter-rouge">List&lt;? extends T&gt;</code>，表示要复制的<code class="language-plaintext highlighter-rouge">List</code>。我们可以简单地用<code class="language-plaintext highlighter-rouge">for</code>循环实现复制。在<code class="language-plaintext highlighter-rouge">for</code>循环中，我们可以看到，对于类型<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">src</code>，我们可以安全地获取类型<code class="language-plaintext highlighter-rouge">T</code>的引用，而对于类型<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">dest</code>，我们可以安全地传入<code class="language-plaintext highlighter-rouge">T</code>的引用。<br />   这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的定义就完美地展示了<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>的意图：</p><ul><li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部不会读取<code class="language-plaintext highlighter-rouge">dest</code>，因为不能调用<code class="language-plaintext highlighter-rouge">dest.get()</code>来获取<code class="language-plaintext highlighter-rouge">T</code>的引用；</li><li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部也不会修改<code class="language-plaintext highlighter-rouge">src</code>，因为不能调用<code class="language-plaintext highlighter-rouge">src.add(T)</code>。</li></ul><p>  这是由编译器检查来实现的。如果在方法代码中意外修改了<code class="language-plaintext highlighter-rouge">src</code>，或者意外读取了<code class="language-plaintext highlighter-rouge">dest</code>，就会导致一个编译错误：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="c1">// 把src的每个元素复制到dest中:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">dest</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// compile error!</span>
        <span class="n">src</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="c1">// compile error!</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的另一个好处是可以安全地把一个<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>添加到<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>，但是无法反过来添加：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="o">...;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="o">...;</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">numList</span><span class="o">,</span> <span class="n">intList</span><span class="o">);</span>
<span class="c1">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">intList</span><span class="o">,</span> <span class="n">numList</span><span class="o">);</span>
</code></pre></div></div><p>  而这些都是通过<code class="language-plaintext highlighter-rouge">super</code>和<code class="language-plaintext highlighter-rouge">extends</code>通配符，并由编译器强制检查来实现的。</p><h3 id="pecs原则">PECS原则</h3><p>  何时使用<code class="language-plaintext highlighter-rouge">extends</code>，何时使用<code class="language-plaintext highlighter-rouge">super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。<br />   即：如果需要返回<code class="language-plaintext highlighter-rouge">T</code>，它是生产者（Producer），要使用<code class="language-plaintext highlighter-rouge">extends</code>通配符；如果需要写入<code class="language-plaintext highlighter-rouge">T</code>，它是消费者（Consumer），要使用<code class="language-plaintext highlighter-rouge">super</code>通配符。<br />   还是以<code class="language-plaintext highlighter-rouge">Collections</code>的<code class="language-plaintext highlighter-rouge">copy()</code>方法为例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="c1">// src是producer</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span> <span class="c1">// dest是consumer</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  需要返回<code class="language-plaintext highlighter-rouge">T</code>的<code class="language-plaintext highlighter-rouge">src</code>是生产者，因此声明为<code class="language-plaintext highlighter-rouge">List&lt;? extends T&gt;</code>，需要写入<code class="language-plaintext highlighter-rouge">T</code>的<code class="language-plaintext highlighter-rouge">dest</code>是消费者，因此声明为<code class="language-plaintext highlighter-rouge">List&lt;? super T&gt;</code>。</p><h3 id="无限定通配符">无限定通配符</h3><p>  我们已经讨论了<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code class="language-plaintext highlighter-rouge">?</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sample</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符既没有<code class="language-plaintext highlighter-rouge">extends</code>，也没有<code class="language-plaintext highlighter-rouge">super</code>，因此：</p><ul><li>不允许调用<code class="language-plaintext highlighter-rouge">set(T)</code>方法并传入引用（<code class="language-plaintext highlighter-rouge">null</code>除外）；</li><li>不允许调用<code class="language-plaintext highlighter-rouge">T get()</code>方法并获取<code class="language-plaintext highlighter-rouge">T</code>引用（只能获取<code class="language-plaintext highlighter-rouge">Object</code>引用）。</li></ul><p>  换句话说，既不能读，也不能写，那只能做一些<code class="language-plaintext highlighter-rouge">null</code>判断：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符有一个独特的特点，就是：<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>是所有<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的超类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// 安全地向上转型</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码是可以正常编译运行的，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p><h3 id="小结-2">小结</h3><p>  使用类似<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt;</code>通配符作为方法参数时表示：</p><ul><li>方法内部可以调用传入<code class="language-plaintext highlighter-rouge">Integer</code>引用的方法，例如：<code class="language-plaintext highlighter-rouge">obj.setFirst(Integer n);</code>；</li><li>方法内部无法调用获取<code class="language-plaintext highlighter-rouge">Integer</code>引用的方法（<code class="language-plaintext highlighter-rouge">Object</code>除外），例如：<code class="language-plaintext highlighter-rouge">Integer n = obj.getFirst();</code>。</li></ul><p>  即使用<code class="language-plaintext highlighter-rouge">super</code>通配符表示只能写不能读。<br />   使用<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>通配符要遵循PECS原则。<br />   无限定通配符<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>很少使用，可以用<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>替换，同时它是所有<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>类型的超类。<br />   其实PECS原因就是java向上转型安全，而向下转型不安全</p><h2 id="泛型和反射">泛型和反射</h2><p>  Java的部分反射API也是泛型。例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>就是泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile warning:</span>
<span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// no warning:</span>
<span class="nc">Class</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</code></pre></div></div><p>  调用<code class="language-plaintext highlighter-rouge">Class</code>的<code class="language-plaintext highlighter-rouge">getSuperclass()</code>方法返回的<code class="language-plaintext highlighter-rouge">Class</code>类型是<code class="language-plaintext highlighter-rouge">Class&lt;? super T&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">sup</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
</code></pre></div></div><p>  构造方法<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>也是泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
</code></pre></div></div><p>  我们可以声明带泛型的数组，但不能用<code class="language-plaintext highlighter-rouge">new</code>操作符创建带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ok</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p>  必须通过强制转型实现带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div><p>  使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code class="language-plaintext highlighter-rouge">ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code class="language-plaintext highlighter-rouge">arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code class="language-plaintext highlighter-rouge">arr</code>可能导致从<code class="language-plaintext highlighter-rouge">ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="c1">// ClassCastException:</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  要安全地使用泛型数组，必须扔掉<code class="language-plaintext highlighter-rouge">arr</code>的引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div><p>  上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code class="language-plaintext highlighter-rouge">ps</code>进行操作，这种操作就是安全的。<br />   带泛型的数组实际上是编译器的类型擦除：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  所以我们不能直接创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>，因为擦拭后代码变为<code class="language-plaintext highlighter-rouge">Object[]</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile error:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  必须借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>来创建泛型数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  我们还可以利用可变参数创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayHelper</span> <span class="o">{</span>
    <span class="nd">@SafeVarargs</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div><h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数</h3><p>  在上面的例子中，我们看到，通过：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  直接调用<code class="language-plaintext highlighter-rouge">asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code class="language-plaintext highlighter-rouge">ClassCastException</code>，原因还是因为擦拭法，在<code class="language-plaintext highlighter-rouge">pickTwo()</code>方法内部，编译器无法检测<code class="language-plaintext highlighter-rouge">K[]</code>的正确类型，因此返回了<code class="language-plaintext highlighter-rouge">Object[]</code>。<br />   如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code class="language-plaintext highlighter-rouge">@SafeVarargs</code>消除警告。<br />   如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。<br />   更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p><h3 id="小结-3">小结</h3><p>  部分反射API是泛型，例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>，<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>；<br />   可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；<br />   可以通过<code class="language-plaintext highlighter-rouge">Array.newInstance(Class&lt;T&gt;, int)</code>创建<code class="language-plaintext highlighter-rouge">T[]</code>数组，需要强制转型；<br /> 同时使用泛型和可变参数时需要特别小心。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://acteds.github.io" target="_blank">acteds</a></li><li>本文链接：<a href="https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" target="_blank">https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://acteds.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://acteds.github.io/assets/search_data.json?v=1712323096', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://acteds.github.io/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2023 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://acteds.github.io/" title="首页" target="">首页</a></li><li> <a href="https://acteds.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://acteds.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://acteds.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://acteds.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://acteds.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
