<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java反射、注解、泛型 &mdash; 个人博客</title><link rel="stylesheet" href="https://acteds.github.io/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/collection.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/globals/common.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/posts/index.css"><link rel="stylesheet" href="https://acteds.github.io/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://acteds.github.io/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3-%E6%B3%9B%E5%9E%8B/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="https://acteds.github.io/feed.xml"><link rel="shortcut icon" href="https://acteds.github.io/favicon.ico"><meta property="og:title" content="Java反射、注解、泛型"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言  java反射、注解、泛型部分笔记。"><meta name="og:description" content="引言  java反射、注解、泛型部分笔记。"><meta property="og:url" content="https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3-%E6%B3%9B%E5%9E%8B/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-05-03"> <script src="https://acteds.github.io/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://acteds.github.io/assets/js/jquery-ui.js"></script> <script src="https://acteds.github.io/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://acteds.github.io/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://acteds.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://acteds.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://acteds.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://acteds.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java反射、注解、泛型"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java反射、注解、泛型</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/05/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://acteds.github.io/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 36705 字，约 105 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>  java反射、注解、泛型部分笔记。</p><h1 id="反射">反射</h1><p>  获取<strong>class</strong>的<strong>Class</strong>实例:<br />   直接通过<strong>class</strong>的静态变量<strong>class</strong>获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</code></pre></div></div><p>  通过实例变量提供的<code class="language-plaintext highlighter-rouge">getClass()</code>方法获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</code></pre></div></div><p>  通过静态方法<code class="language-plaintext highlighter-rouge">Class.forName()</code>获取：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"java.lang.String"</span><span class="o">);</span>
</code></pre></div></div><h2 id="class实例基本信息"><strong>Class实例基本信息:</strong></h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>String</td><td>getName()</td><td>返回类的完全限定名。</td></tr><tr><td>String</td><td>getSimpleName()</td><td>返回类的简单名称，不包含包名部分。</td></tr><tr><td>String</td><td>getPackage().getName()</td><td>返回类所在包的名称。</td></tr><tr><td>boolean</td><td>isInterface()</td><td>判断是否为接口。</td></tr><tr><td>boolean</td><td>isEnum()</td><td>判断是否为枚举类型。</td></tr><tr><td>boolean</td><td>isArray()</td><td>判断是否为数组类型。</td></tr><tr><td>boolean</td><td>isPrimitive()</td><td>判断是否为基本数据类型。</td></tr><tr><td>Class</td><td>getSuperclass()</td><td>返回表示该类的父类的 Class 对象。</td></tr><tr><td>int</td><td>getModifiers()</td><td>返回表示类或接口的 Java 语言修饰符的整数。例如，public、static 等修饰符。</td></tr><tr><td>Class[]</td><td>getInterfaces()</td><td>返回一个包含表示<strong>该类</strong>实现的接口的 Class 对象的数组。(接口同理)</td></tr><tr><td>ClassLoader</td><td>getClassLoader()</td><td>返回该类的类加载器。</td></tr><tr><td>boolean</td><td>isAssignableFrom(Class)</td><td>判断当前 <code class="language-plaintext highlighter-rouge">Class</code> 对象所表示的类或接口与指定 <code class="language-plaintext highlighter-rouge">Class</code> 参数表示的类或接口是否相同，或是否是其超类或超接口。</td></tr><tr><td>Class</td><td>getGenericSuperclass()</td><td>获取泛型父类的<code class="language-plaintext highlighter-rouge">class</code></td></tr></tbody></table><h2 id="访问字段的方法"><strong>访问字段的方法</strong></h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Field</td><td>getField(String name)</td><td>根据字段名获取某个public的field（包括父类继承）</td></tr><tr><td>Field</td><td>getDeclaredField(String name)</td><td>根据字段名获取当前类的某个field（不包括父类继承）</td></tr><tr><td>Field[]</td><td>getFields()</td><td>获取所有public的field（包括父类继承）</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td><td>获取当前类的所有field（不包括父类继承）</td></tr></tbody></table><p>  一个<code class="language-plaintext highlighter-rouge">Field</code>对象包含了一个字段的所有信息：</p><ul><li><code class="language-plaintext highlighter-rouge">getName()</code>：返回字段名称，例如，<code class="language-plaintext highlighter-rouge">"name"</code>；</li><li><code class="language-plaintext highlighter-rouge">getType()</code>：返回字段类型，也是一个<code class="language-plaintext highlighter-rouge">Class</code>实例，例如，<code class="language-plaintext highlighter-rouge">String.class</code>；</li><li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回字段的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li></ul><p>  <strong>Field的方法</strong></p><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>void</td><td>set(Object o,Object v)</td><td>设置指定对象o上此 Field 表示的字段的值为v。</td></tr><tr><td>Object</td><td>get(Object o)</td><td>返回指定对象o上此 Field 表示的字段的值。</td></tr><tr><td>void</td><td>setAccessible(boolean)</td><td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有字段)</td></tr></tbody></table><p>  通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">get(实例变量)</code>可以得到该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值<br />   通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">set(实例变量,新值)</code>可以设置该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值<br />   默认是不允许访问<code class="language-plaintext highlighter-rouge">private</code>字段的,可以通过调用<code class="language-plaintext highlighter-rouge">Field</code>的<code class="language-plaintext highlighter-rouge">setAccessible(true)</code>实现访问。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
        <span class="n">f</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span> <span class="c1">// "Xiao Ming"</span>
        <span class="n">f</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">p</span><span class="o">,</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="访问方法的方法"><strong>访问方法的方法</strong></h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Method</td><td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>获取某个<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>（包括父类继承）name:方法名,parameterTypes:形式参数的Class</td></tr><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>获取当前类的某个<code class="language-plaintext highlighter-rouge">Method</code>（不包括父类继承）name:方法名,parameterTypes:形式参数的Class</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>获取所有<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>（包括父类继承）</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>获取当前类的所有<code class="language-plaintext highlighter-rouge">Method</code>（不包括父类继承）</td></tr></tbody></table><p>  一个<code class="language-plaintext highlighter-rouge">Method</code>对象包含一个方法的所有信息：</p><ul><li><code class="language-plaintext highlighter-rouge">getName()</code>：返回方法名称，例如：<code class="language-plaintext highlighter-rouge">"getScore"</code>；</li><li><code class="language-plaintext highlighter-rouge">getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code class="language-plaintext highlighter-rouge">String.class</code>；</li><li><code class="language-plaintext highlighter-rouge">getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code class="language-plaintext highlighter-rouge">{String.class, int.class}</code>；</li><li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回方法的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li></ul><p>  <strong>Method的方法</strong></p><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td> </td><td>invoke(Object o,Object …arg)</td><td>调用指定对象o上此 Method表示的方法,方法的形式参数为arg。若为静态方法,则o设置为null,</td></tr><tr><td>void</td><td>setAccessible(boolean b)</td><td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td></tr></tbody></table><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// String对象:</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello world"</span><span class="o">;</span>
<span class="c1">// 获取String substring(int)方法，参数为int:</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"substring"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 在s对象上调用该方法并获取结果:</span>
<span class="nc">String</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
<span class="c1">// 打印调用结果:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</code></pre></div></div><h2 id="访问构造方法的方法">访问构造方法的方法</h2><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Object</td><td>newInstance()</td><td>只能调用公有的无参数构造方法。(而且被废弃了,应写 getDeclaredConstructor()<br />.newInstance())</td></tr><tr><td>Constructor</td><td>getConstructor(Class … arg)</td><td>获取指定类的指定<strong>公有</strong>构造方法,arg为形式参数.</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class… arg)</td><td>获取指定类的构造方法,arg为形式参数.</td></tr><tr><td>Constructor[]</td><td>getConstructors()</td><td>返回该类的所有<strong>公有</strong>构造方法。</td></tr><tr><td>Constructor[]</td><td>getDeclaredConstructors()</td><td>返回该类的所有构造方法。</td></tr></tbody></table><p>  <strong>Constructor 的方法</strong></p><table><thead><tr><th>返回值</th><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>Object</td><td>newInstance(Object …arg)</td><td>调用构造方法,参数为arg。</td></tr><tr><td>void</td><td>setAccessible(boolean b)</td><td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td></tr></tbody></table><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取String的Class实例:String s=new Stirng();</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="c1">// 调用构造方法:</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">cls</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="c1">// 获取构造方法Integer(int):Integer n1=new Integer(123);</span>
<span class="nc">Constructor</span> <span class="n">cons1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 调用构造方法:</span>
<span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">cons1</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span>
</code></pre></div></div><h2 id="动态代理">动态代理</h2><p>  有没有可能不编写实现类，直接在运行期创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例呢？<br />   这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例。<br />   什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：<br />   定义接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  编写实现类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  创建实例，转型为接口并调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloWorld</span><span class="o">();</span>
<span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
</code></pre></div></div><p>  这种方式就是我们通常编写代码的方式。<br />   还有一种方式是动态代码，我们仍然先定义了接口<code class="language-plaintext highlighter-rouge">Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建了一个<code class="language-plaintext highlighter-rouge">Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。<br />   一个最简单的动态代理实现如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Hello</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
            <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="c1">// 传入ClassLoader</span>
            <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="c1">// 传入要实现的接口</span>
            <span class="n">handler</span><span class="o">);</span> <span class="c1">// 传入处理调用方法的InvocationHandler</span>
        <span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  在运行期动态创建一个<code class="language-plaintext highlighter-rouge">interface</code>实例的方法如下：<br />   定义一个<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例，它负责实现接口的方法调用；<br />   通过<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建<code class="language-plaintext highlighter-rouge">interface</code>实例，它需要3个参数：</p><ol><li>使用的<code class="language-plaintext highlighter-rouge">ClassLoader</code>，通常就是接口类的<code class="language-plaintext highlighter-rouge">ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例。</li></ol><p>  将返回的<code class="language-plaintext highlighter-rouge">Object</code>强制转型为接口。<br />   动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span><span class="n">a1</span><span class="o">();}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">a1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">HelloDynamicProxy</span> <span class="n">helloDynamicProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloDynamicProxy</span><span class="o">((</span><span class="n">proxy</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">args1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args1</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="n">helloDynamicProxy</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HelloDynamicProxy</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">HelloDynamicProxy</span><span class="o">(</span><span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="n">handler</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span>
                <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"morning"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
                <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">name</span><span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span><span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">;}</span>
</code></pre></div></div><p>  其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h1 id="注解">注解</h1><p>  注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p><h2 id="定义注解">定义注解</h2><p>  使用<code class="language-plaintext highlighter-rouge">@interface</code>语法来定义注解（<code class="language-plaintext highlighter-rouge">Annotation</code>），格式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  定义一个注解，可以定义配置参数。配置参数可以是：   所有基本类型；<code class="language-plaintext highlighter-rouge">String</code>；枚举类型；基本类型、<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Class</code>以及<code class="language-plaintext highlighter-rouge">枚举</code>的<strong>数组</strong>。<br />   配置参数必须是常量，注解配置参数可以用<code class="language-plaintext highlighter-rouge">default</code>设定一个默认值。<br />   大部分注解存在名为<code class="language-plaintext highlighter-rouge">value</code>的配参数，对此参数赋值，可以只写常量，相当于省略了value参数。即从<code class="language-plaintext highlighter-rouge">@Check(value=99)</code>省略为<code class="language-plaintext highlighter-rouge">@check(99)</code>，最常用的参数应当命名为<code class="language-plaintext highlighter-rouge">value</code>。<br />   注解的参数类似无参数方法。</p><h3 id="元注解">元注解</h3><p>  有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p><h4 id="target">@Target</h4><p>  最常用的元注解是<code class="language-plaintext highlighter-rouge">@Target</code>。使用<code class="language-plaintext highlighter-rouge">@Target</code>可以定义<code class="language-plaintext highlighter-rouge">Annotation</code>能够被应用于源码的哪些位置：</p><ul><li>类或接口：<code class="language-plaintext highlighter-rouge">ElementType.TYPE</code>；</li><li>字段：<code class="language-plaintext highlighter-rouge">ElementType.FIELD</code>；</li><li>方法：<code class="language-plaintext highlighter-rouge">ElementType.METHOD</code>；</li><li>构造方法：<code class="language-plaintext highlighter-rouge">ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code class="language-plaintext highlighter-rouge">ElementType.PARAMETER</code>。</li></ul><p>  例如，定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在方法上，我们必须添加一个<code class="language-plaintext highlighter-rouge">@Target(ElementType.METHOD)</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{}</span>
</code></pre></div></div><p>  定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在方法或字段上，可以把<code class="language-plaintext highlighter-rouge">@Target</code>注解参数变为数组<code class="language-plaintext highlighter-rouge">{ ElementType.METHOD, ElementType.FIELD }</code>：<br />   实际上<code class="language-plaintext highlighter-rouge">@Target</code>定义的<code class="language-plaintext highlighter-rouge">value</code>是<code class="language-plaintext highlighter-rouge">ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p><h4 id="retention">@Retention</h4><p>  Java的注解可以分为三类：<br />   第一类是由编译器使用的注解，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li><li><code class="language-plaintext highlighter-rouge">@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li></ul><p>  这类注解不会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，它们在编译后就被编译器扔掉了。</p><p>  第二类是由工具处理<code class="language-plaintext highlighter-rouge">.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p><p>  第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code class="language-plaintext highlighter-rouge">@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p><p>  元注解<code class="language-plaintext highlighter-rouge">@Retention</code>定义了<code class="language-plaintext highlighter-rouge">Annotation</code>的生命周期：</p><ul><li>仅编译期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.SOURCE</code>；</li><li>仅class文件：<code class="language-plaintext highlighter-rouge">RetentionPolicy.CLASS</code>；</li><li>运行期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.RUNTIME</code>。</li></ul><p>  如果<code class="language-plaintext highlighter-rouge">@Retention</code>不存在，则该<code class="language-plaintext highlighter-rouge">Annotation</code>默认为<code class="language-plaintext highlighter-rouge">CLASS</code>。因为通常我们自定义的<code class="language-plaintext highlighter-rouge">Annotation</code>都是<code class="language-plaintext highlighter-rouge">RUNTIME</code>，所以，务必要加上<code class="language-plaintext highlighter-rouge">@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p><h4 id="repeatable">@Repeatable</h4><p>  使用<code class="language-plaintext highlighter-rouge">@Repeatable</code>这个元注解可以定义<code class="language-plaintext highlighter-rouge">Annotation</code>是否可重复。这个注解应用不是特别广泛。<code class="language-plaintext highlighter-rouge">@Reports</code>是一个容器注解，用来包裹多个<code class="language-plaintext highlighter-rouge">@Report</code>注解。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repeatable</span><span class="o">(</span><span class="nc">Reports</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Reports</span> <span class="o">{</span>
    <span class="nc">Report</span><span class="o">[]</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  经过<code class="language-plaintext highlighter-rouge">@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code class="language-plaintext highlighter-rouge">@Report</code>注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"debug"</span><span class="o">)</span>
<span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"warning"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><h4 id="inherited">@Inherited</h4><p>  使用<code class="language-plaintext highlighter-rouge">@Inherited</code>定义子类是否可继承父类定义的<code class="language-plaintext highlighter-rouge">Annotation</code>。<code class="language-plaintext highlighter-rouge">@Inherited</code>仅针对<code class="language-plaintext highlighter-rouge">@Target(ElementType.TYPE)</code>类型的<code class="language-plaintext highlighter-rouge">annotation</code>有效，并且仅针对<code class="language-plaintext highlighter-rouge">class</code>的继承，对<code class="language-plaintext highlighter-rouge">interface</code>的继承无效。</p><h2 id="处理注解">处理注解</h2><p>  Java的注解本身对代码逻辑没有任何影响。根据<code class="language-plaintext highlighter-rouge">@Retention</code>的配置：</p><ul><li><code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解在编译期就被丢掉了；</li><li><code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li><li><code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li></ul><p>  如何使用注解完全由工具决定。<code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解不但要使用，还经常需要编写。<br />   因此，我们只讨论如何读取<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解。<br />   因为注解定义后也是一种<code class="language-plaintext highlighter-rouge">class</code>，所有的注解都继承自<code class="language-plaintext highlighter-rouge">java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。<br />   Java提供的使用反射API读取<code class="language-plaintext highlighter-rouge">Annotation</code>的方法包括：<br />   判断某个注解是否<strong>存在</strong>于<code class="language-plaintext highlighter-rouge">Class</code>、<code class="language-plaintext highlighter-rouge">Field</code>、<code class="language-plaintext highlighter-rouge">Method</code>或<code class="language-plaintext highlighter-rouge">Constructor</code>：</p><ul><li><code class="language-plaintext highlighter-rouge">Class.isAnnotationPresent(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Field.isAnnotationPresent(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Method.isAnnotationPresent(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Constructor.isAnnotationPresent(Class)</code></li></ul><p>  例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断@Report是否存在于Person类:</span>
<span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><p>  使用反射API<strong>读取</strong>Annotation：</p><ul><li><code class="language-plaintext highlighter-rouge">Class.getAnnotation(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Field.getAnnotation(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Method.getAnnotation(Class)</code></li><li><code class="language-plaintext highlighter-rouge">Constructor.getAnnotation(Class)</code></li></ul><p>  例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Person定义的@Report注解:</span>
<span class="nc">Report</span> <span class="n">report</span> <span class="o">=</span> <span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">type</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">level</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">level</span><span class="o">();</span>
</code></pre></div></div><p>  读取方法、字段和构造方法的<code class="language-plaintext highlighter-rouge">Annotation</code>和Class类似。但要读取方法参数的<code class="language-plaintext highlighter-rouge">Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span><span class="o">=</span><span class="mi">5</span><span class="o">)</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nd">@NotNull</span> <span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div><p>  要读取方法参数的注解，先用反射获取<code class="language-plaintext highlighter-rouge">Method</code>实例，然后读取方法参数的所有注解：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Method实例:</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 获取所有参数的Annotation:</span>
<span class="nc">Annotation</span><span class="o">[][]</span> <span class="n">annos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getParameterAnnotations</span><span class="o">();</span>
<span class="c1">// 第一个参数（索引为0）的所有Annotation:</span>
<span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annosOfName</span> <span class="o">=</span> <span class="n">annos</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">anno</span> <span class="o">:</span> <span class="n">annosOfName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">Range</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Range</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @Range注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="na">max</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">NotNull</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @NotNull注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已捕获NotNull"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="尝试手搓notnull-range">尝试手搓<strong>@NotNull @Range</strong></h2><p>  但对于方法的形式参数，Java的反射机制并不能直接获取参数的值,毕竟只有在方法调用的时候才有值,因此失败了。如果需要在方法运行时对参数进行检查，可以使用面向切面编程（AOP）结合反射来实现。<br />   不过对于对象的字段，可以直接通过反射获取字段的值，并进行判断。但要注意判断的时机需要另外的事件来触发。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="n">checkField</span><span class="o">(</span><span class="n">myClass</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkField</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredFields</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annotations</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotations</span><span class="o">();</span>
                <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">annotations</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="n">aClass</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">annotationType</span><span class="o">();</span>
                    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">NotNull</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">notNullDispose</span><span class="o">((</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">Range</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">rangeDispose</span><span class="o">(</span><span class="n">field</span><span class="o">,</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rangeDispose</span><span class="o">(</span><span class="nc">Field</span> <span class="n">field</span><span class="o">,</span> <span class="nc">Range</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span> <span class="nc">NotNull</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于:"</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="c1">//              throw new IllegalArgumentException(text);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">NotNull</span> <span class="nf">notNullDispose</span><span class="o">(</span><span class="nc">NotNull</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">NotNull</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 不能为空"</span><span class="o">);</span>
<span class="c1">//          throw new IllegalArgumentException(n.value() + " 不能为空");</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"名称"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"地址"</span><span class="o">)</span>
    <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">address</span> <span class="o">=</span> <span class="s">"123456"</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">NotNull</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">Range</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">min</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">max</span><span class="o">()</span> <span class="k">default</span> <span class="mi">255</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="泛型">泛型</h1><p>  泛型就是编写模板代码来适应任意类型；<br />   泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；<br />   注意泛型的继承关系：可以把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！），但不能把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变成父类）。<br />   使用<code class="language-plaintext highlighter-rouge">ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code class="language-plaintext highlighter-rouge">Object</code><br />   编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
</code></pre></div></div><p>  编译器看到泛型类型<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>就可以自动推断出后面的<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>的泛型类型必须是<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><p>  除了<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code class="language-plaintext highlighter-rouge">Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>这个泛型接口。<br />   泛型类写法:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  在类的定义中，泛型类型参数通常放在类名后面,即在类名后面定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><br />   在类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。<br />   初始化:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span><span class="c1">//或new Pair&lt;String&gt;("1","2");</span>
</code></pre></div></div><h2 id="泛型方法">泛型方法</h2><p>  泛型方法写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  在Java中，泛型方法的定义通常如下所示：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">返回类型</span> <span class="n">方法名</span><span class="o">(</span><span class="n">参数列表</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 方法体</span>
<span class="o">}</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：泛型类型参数声明，放在<strong>返回类型之前</strong>，表示该方法是一个泛型方法，并且可以接受类型为<code class="language-plaintext highlighter-rouge">T</code>的参数或返回类型为<code class="language-plaintext highlighter-rouge">T</code>的值。</li><li>返回类型：方法的返回类型，可以是泛型类型<code class="language-plaintext highlighter-rouge">T</code>或其他类型。</li><li>方法名：方法的名称。</li><li>参数列表：方法的参数列表，可以包含泛型类型<code class="language-plaintext highlighter-rouge">T</code>。</li><li>方法体：方法的具体实现。</li></ul><p>  在泛型方法中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是用来声明泛型类型参数的。当调用泛型方法时，可以根据实际情况传入不同的类型参数。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="nc">Integer</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它可以接受任意类型的参数并返回相同类型的值。在调用<code class="language-plaintext highlighter-rouge">myMethod</code>时，根据传入的参数类型确定返回类型，从而实现了泛型方法的灵活性。</p><p>  泛型方法的类型参数声明通常写在返回类型之前。</p><p>  在类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。而在方法中定义的泛型类型参数只适用于该方法。</p><h3 id="同时定义泛型类与泛型方法">同时定义泛型类与泛型方法</h3><p>  如果在类名后面定义了泛型类型参数，在类的方法中仍然可以使用独立的泛型类型参数。这两者是独立的，但是如果方法要使用类中定义的泛型类型参数，需要在方法中显式地指定。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  在这个例子中，<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>是一个泛型类，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>表示类的泛型类型参数。方法<code class="language-plaintext highlighter-rouge">printValue</code>中的<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code>是方法级别的泛型类型参数，与类的泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>是独立的。</p><p>  在泛型方法中可以使用泛型类的标识符，但是泛型方法的类型参数与泛型类的类型参数是独立的。例如，一个泛型类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>中的泛型方法可以使用类的泛型标识符<code class="language-plaintext highlighter-rouge">T</code>，但不必使用相同的标识符。以下是一个示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">U</span> <span class="n">u</span><span class="o">,</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyClass value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">u</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Main</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="n">myClass</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">,</span><span class="s">"haha"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>  在这个例子中，<code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它使用了泛型方法类型参数<code class="language-plaintext highlighter-rouge">U</code>，这个类型参数与泛型类<code class="language-plaintext highlighter-rouge">MyClass</code>中的类型参数<code class="language-plaintext highlighter-rouge">T</code>是不同的,也使用了泛型类方法类型参数<code class="language-plaintext highlighter-rouge">T</code>。在<code class="language-plaintext highlighter-rouge">myMethod&lt;Integer&gt;(123, "haha")</code>这个调用中，类型参数<code class="language-plaintext highlighter-rouge">U</code>被指定为<code class="language-plaintext highlighter-rouge">Integer</code>，类型参数<code class="language-plaintext highlighter-rouge">T</code>被推断为<code class="language-plaintext highlighter-rouge">String</code>。因此，<code class="language-plaintext highlighter-rouge">myMethod</code>方法的第一个参数<code class="language-plaintext highlighter-rouge">u</code>是<code class="language-plaintext highlighter-rouge">Integer</code>类型，第二个参数<code class="language-plaintext highlighter-rouge">t</code>是<code class="language-plaintext highlighter-rouge">String</code>类型。</p><h3 id="泛型类与泛型方法使用相同的泛型类型参数名">泛型类与泛型方法使用相同的泛型类型参数名</h3><p>  如果在类名后面定义了泛型类型参数，并且在方法中使用了<strong>相同的泛型类型参数名</strong>，这并不会产生冲突，因为它们在不同的作用域中。类的泛型类型参数适用于整个类，而方法的泛型类型参数只适用于该方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">T</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  在这个例子中，类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示类的类型参数。泛型方法<code class="language-plaintext highlighter-rouge">printValue</code>中也有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示方法级别的类型参数。这两个<code class="language-plaintext highlighter-rouge">T</code>是不同的，在方法中使用的<code class="language-plaintext highlighter-rouge">T</code>只在方法范围内有效，不会与类的泛型类型参数产生冲突。</p><p>  不过虽然没有问题，但不建议这么做，因为很容易让人误解。</p><h3 id="静态泛型方法">静态泛型方法</h3><p>  编写泛型类时，要特别注意，泛型类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。<br />   因为类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。<br />   在静态方法中，同样可以使用泛型类型参数，就是之前泛型方法的写法，语法一模一样。   例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myStaticMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Static method: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">myStaticMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  在这个例子中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是在静态泛型方法<code class="language-plaintext highlighter-rouge">myStaticMethod</code>的返回类型<code class="language-plaintext highlighter-rouge">void</code>之前声明的，用于定义该方法的泛型类型参数。在调用静态方法时，需要使用<code class="language-plaintext highlighter-rouge">MyClass.&lt;String&gt;</code>来指定类型参数。</p><ul><li>泛型类型是在实例化对象时确定的，而静态方法是在类加载时就可以直接调用的，无需创建对象实例。所以静态方法中的返回值、参数等不能依赖泛型类型<T>，**必须**将静态方法的泛型类型和实例类型的泛型类型**区分开**,其实相同也没关系,就是容易让人误解。</T></li><li>此外，静态方法是与类本身相关联的，而不是与类的实例相关联的。因此，即使创建了一个类的实例，静态方法也无法访问实例的泛型类型。静态方法由于随着类的加载而加载，不能访问类的泛型（因为在创建对象的时候才确定），因此必须定义自己的泛型类型。</li></ul><h2 id="多个泛型类型">多个泛型类型</h2><p>  泛型还可以定义多种类型。例如，我们希望<code class="language-plaintext highlighter-rouge">Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">K</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">K</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用的时候，需要指出两种类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"test"</span><span class="o">,</span> <span class="mi">123</span><span class="o">);</span>
</code></pre></div></div><p>  Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p><h2 id="擦拭法">擦拭法</h2><p>  所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。因此编译器把类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>视为<code class="language-plaintext highlighter-rouge">Object</code>；编译器根据<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>实现安全的强制转型。<br />   例如，我们编写了一个泛型类<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Object</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用泛型的时候，我们编写的代码也是如此，编译器看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>  而虚拟机执行的代码并没有泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>  Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code class="language-plaintext highlighter-rouge">T</code>视为<code class="language-plaintext highlighter-rouge">Object</code>处理，但是，在需要转型的时候，编译器会根据<code class="language-plaintext highlighter-rouge">T</code>的类型自动为我们实行安全地强制转型。<br />   局限一：<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能是基本类型，例如<code class="language-plaintext highlighter-rouge">int</code>，因为实际类型是<code class="language-plaintext highlighter-rouge">Object</code>，<code class="language-plaintext highlighter-rouge">Object</code>类型无法持有基本类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p>  局限二：无法取得带泛型的<code class="language-plaintext highlighter-rouge">Class</code>。观察以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Class</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Object</code>，我们对<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;</code>和<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型获取<code class="language-plaintext highlighter-rouge">Class</code>时，获取到的是同一个<code class="language-plaintext highlighter-rouge">Class</code>，也就是<code class="language-plaintext highlighter-rouge">Pair</code>类的<code class="language-plaintext highlighter-rouge">Class</code>。<br />   换句话说，所有泛型实例，无论<code class="language-plaintext highlighter-rouge">T</code>的类型是什么，<code class="language-plaintext highlighter-rouge">getClass()</code>都返回同一个<code class="language-plaintext highlighter-rouge">Class</code>实例，因为编译后它们全部都是<code class="language-plaintext highlighter-rouge">Pair</code>类然后用<code class="language-plaintext highlighter-rouge">Object</code>替换<code class="language-plaintext highlighter-rouge">T</code>。<br />   局限三：无法判断带泛型的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
<span class="c1">// Compile error:</span>
<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>  原因和前面一样，并不存在<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>，而是只有唯一的<code class="language-plaintext highlighter-rouge">Pair.class</code>。<br />   局限四：不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Compile error:</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码无法通过编译，因为构造方法的两行语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">擦拭后实际上变成了</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div><p>  这样一来，创建<code class="language-plaintext highlighter-rouge">new Pair&lt;String&gt;()</code>和创建<code class="language-plaintext highlighter-rouge">new Pair&lt;Integer&gt;()</code>,内部的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>全部成了<code class="language-plaintext highlighter-rouge">Object</code>类型，显然编译器要阻止这种类型不对的代码,为了防止可能的错误出现编译器直接一刀切这个操作。</p><p>  而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了抽象类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><p>  上面的Number是不能直接实例化的，所以编译器要阻止这种行为。</p><p>  顺便提一下，如果改成了利用反射：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  借助<code class="language-plaintext highlighter-rouge">class.newInstance()</code>创建实例时编译器要求强制处理可能出现的异常，相当于做了兼容。直接new的话如果泛型类型为抽象类，则会出错。<br />   上述代码借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>参数并通过反射来实例化<code class="language-plaintext highlighter-rouge">T</code>类型，使用的时候，也必须传入<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><h3 id="不恰当的覆写方法">不恰当的覆写方法</h3><p>  有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  在 Java 中，泛型类型在编译时会被擦除，这意味着编译器会把泛型类型的信息擦除掉，将其替换为其上限类型（如果有指定上限类型的话），或者替换为 Object 类型。这是为了与 Java 的运行时类型擦除机制相适配 <br />   定义的<code class="language-plaintext highlighter-rouge">equals(T t)</code>方法实际上会被擦拭成<code class="language-plaintext highlighter-rouge">equals(Object t)</code>，而这个方法是继承自<code class="language-plaintext highlighter-rouge">Object</code>的，而编译器会阻止一个实际上会变成覆写的泛型方法定义。   因为仅仅通过泛型代码的定义，编译器是无法确定泛型是否覆写了此方法。</p><p>  在泛型类型擦除后，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code>与 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法的签名相同。因此，从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法。<br />   但是，由于 Java 泛型的设计，编译器会在编译时对泛型类型进行额外的类型检查，以确保类型安全。在这种情况下，编译器会注意到 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法使用了泛型类型 <code class="language-plaintext highlighter-rouge">T</code>，而 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法使用了原始的 <code class="language-plaintext highlighter-rouge">Object</code> 类型，在编译时这会被认为是不同的方法。   因此，编译器会认为 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法不是重写，而是一个新定义的方法。<br />   这也是为了确保子类重写父类方法时不会改变方法的行为，避免在子类中意外修改了父类的行为。</p><p>  综上所述，虽然从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法，但在编译器的类型检查中，它们被认为是不同的方法，因为泛型类型 <code class="language-plaintext highlighter-rouge">T</code> 在编译时被认为是具有不同参数类型的。</p><p>  虽然擦除后不是覆写,但编译器装作有泛型的行为,导致在调用<code class="language-plaintext highlighter-rouge">test()</code>时编译器不知道调用哪个<code class="language-plaintext highlighter-rouge">test()</code>,非预期效果,编译器报错:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Test</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">t1</span><span class="o">=</span><span class="k">new</span> <span class="nc">Test</span><span class="o">&lt;&gt;();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"test"</span><span class="o">)){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="c1">//        t1.test((Number)124);//错误:java: 对test的引用不明确com.aotmd.SuperTest 中的方法 test(java.lang.Number) 和 com.aotmd.Test 中的方法 test(T) 都匹配</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SuperTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">test</span><span class="o">((</span><span class="nc">Number</span><span class="o">)</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SuperTest</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">Number</span> <span class="n">o</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class com.aotmd.Test
public void com.aotmd.Test.test(java.lang.Object)
public void com.aotmd.SuperTest.test(java.lang.Number)
</code></pre></div></div><h3 id="泛型继承">泛型继承</h3><p>  一个类可以继承自一个泛型类。例如：父类的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>，子类的类型是<code class="language-plaintext highlighter-rouge">IntPair</code>，可以这么继承：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用的时候，因为子类<code class="language-plaintext highlighter-rouge">IntPair</code>并没有泛型，所以正常使用即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntPair</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntPair</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div><p>  前面讲了，我们无法获取<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的<code class="language-plaintext highlighter-rouge">T</code>类型，即给定一个变量<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt; p</code>，也无法从<code class="language-plaintext highlighter-rouge">p</code>中获取到<code class="language-plaintext highlighter-rouge">Integer</code>类型。<br />   但是，在父类是泛型类型的情况下，编译器就必须把类型<code class="language-plaintext highlighter-rouge">T</code>（对<code class="language-plaintext highlighter-rouge">IntPair</code>来说，也就是<code class="language-plaintext highlighter-rouge">Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code class="language-plaintext highlighter-rouge">IntPair</code>只能存取<code class="language-plaintext highlighter-rouge">Integer</code>这种类型。<br />   在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code class="language-plaintext highlighter-rouge">IntPair</code>可以获取到父类的泛型类型<code class="language-plaintext highlighter-rouge">Integer</code>。获取父类的泛型类型代码比较复杂：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.ParameterizedType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">IntPair</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">IntPair</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="nc">Type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getGenericSuperclass</span><span class="o">();</span><span class="c1">//获取泛型父类的class</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="nc">ParameterizedType</span><span class="o">)</span> <span class="o">{</span><span class="c1">//判断是否为ParameterizedType,如果是，则表示泛型父类有实际类型参数。</span>
            <span class="nc">ParameterizedType</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ParameterizedType</span><span class="o">)</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">Type</span><span class="o">[]</span> <span class="n">types</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">();</span> <span class="c1">// 获取实际类型参数的数组，本例中数组长度为1。</span>
            <span class="nc">Type</span> <span class="n">firstType</span> <span class="o">=</span> <span class="n">types</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 获取第一个实际类型参数</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">firstType</span><span class="o">);</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">typeClass</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">firstType</span><span class="o">;</span><span class="c1">//将其转换为 Class 对象,若还是泛型K则转换失败.</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">typeClass</span><span class="o">);</span> <span class="c1">// Integer</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  修改<code class="language-plaintext highlighter-rouge">IntPair</code>,然后重新运行,类型转换会出错:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">IntPair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="no">K</span> <span class="n">o1</span><span class="o">,</span><span class="no">K</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span><span class="n">o2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  因为Java引入了泛型，所以，只用<code class="language-plaintext highlighter-rouge">Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p><pre><code class="language-ascii">                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
</code></pre><h3 id="小结">小结</h3><p>  Java的泛型是采用擦拭法实现的；<br />   擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li><li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li></ul><p>  泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>；<br />   子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p><h2 id="extends通配符在形式参数的作用">extends通配符在形式参数的作用</h2><p>  之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类,他们之前没有什么关系。<br />   假设我们定义了<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  然后对<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码是可以正常编译的。使用的时候，我们传入：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div><p>  注意：传入的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，实际参数类型是<code class="language-plaintext highlighter-rouge">(Integer, Integer)</code>。<br />   既然实际参数是<code class="language-plaintext highlighter-rouge">Integer</code>类型，试试传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div><p>  直接运行，会得到一个编译错误：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">java:</span> <span class="nl">不兼容的类型:</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">无法转换为Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span>
</code></pre></div></div><p>  原因很明显，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类,它们之间没什么关系，因此，<code class="language-plaintext highlighter-rouge">add(Pair&lt;Number&gt; p)</code>方法,不接受参数类型<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>。   方法里的代码逻辑是没有问题,<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">Integer</code>的父类。问题在于方法参数类型定死了只能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>。</p><p>  有没有办法使得方法参数接受<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>使得方法能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。我们把代码改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>  这样一来，给方法传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型时，它符合参数<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型。这种使用<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code class="language-plaintext highlighter-rouge">T</code>的上界限定在<code class="language-plaintext highlighter-rouge">Number</code>了。<br />   这样写除了可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型，还可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型，<code class="language-plaintext highlighter-rouge">Pair&lt;BigDecimal&gt;</code>类型等等，因为<code class="language-plaintext highlighter-rouge">Double</code>和<code class="language-plaintext highlighter-rouge">BigDecimal</code>都是<code class="language-plaintext highlighter-rouge">Number</code>的子类。<br />   对<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型调用<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，实际的方法签名变成了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  即返回值是<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>的子类,因为 <code class="language-plaintext highlighter-rouge">Number</code> 是 <code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code> 的上界，所以返回值可以安全地赋值给 <code class="language-plaintext highlighter-rouge">Number</code> 类型的变量 <code class="language-plaintext highlighter-rouge">first</code>(向上提升)：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  不能赋值给<code class="language-plaintext highlighter-rouge">Integer</code>，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物,也即可能的向下转型是不安全的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span><span class="c1">//错误</span>
</code></pre></div></div><p>  这是因为实际的返回类型可能是<code class="language-plaintext highlighter-rouge">Integer</code>，也可能是<code class="language-plaintext highlighter-rouge">Double</code>或者其他类型，编译器只能确定类型一定是<code class="language-plaintext highlighter-rouge">Number</code>的子类（包括<code class="language-plaintext highlighter-rouge">Number</code>类型本身），但具体类型无法确定。</p><p>  尝试写操作：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: java.lang.Integer无法转换为capture#1, 共 ? extends java.lang.Number
</code></pre></div></div><p>  编译错误发生在<code class="language-plaintext highlighter-rouge">p.setFirst()</code>,我们对<code class="language-plaintext highlighter-rouge">add(Pair&lt;? extends Number&gt; p)</code>传入了<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，对于<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>为什么不能传入<code class="language-plaintext highlighter-rouge">Integer</code>呢？<br />   因为我们还能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，形式参数类型为<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>当然是无法接受<code class="language-plaintext highlighter-rouge">Integer</code>类型的。<br />   为了避免产生安全问题,编译器一刀切,直接<strong>不接受任何写行为</strong>.<br />   这就是<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>通配符的一个重要限制<br />   唯一的例外是可以给方法参数传入<code class="language-plaintext highlighter-rouge">null</code>,因为泛型只接受引用类型,也即对象,因为擦除法都擦成<code class="language-plaintext highlighter-rouge">Object</code>了,而所有的对象都可以赋值<code class="language-plaintext highlighter-rouge">null</code>,所以这是安全的行为.</p><p>  总的来说,调用:<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读,则需要用上界接收。写则因为可能向下转型的原因被切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。</p><h3 id="extends通配符形式参数实例">extends通配符形式参数实例</h3><p>  如果我们考察Java标准库的<code class="language-plaintext highlighter-rouge">java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span> <span class="c1">// 获取个数</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span> <span class="c1">// 根据索引获取指定元素</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 添加一个新元素</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 删除一个已有元素</span>
<span class="o">}</span>
</code></pre></div></div><p>  现在，让我们定义一个方法来处理列表的每个元素：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sumOfList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用<code class="language-plaintext highlighter-rouge">? extends Integer</code>限制了只读,只能调用<code class="language-plaintext highlighter-rouge">size()</code>,<code class="language-plaintext highlighter-rouge">get()</code>,不能调用<code class="language-plaintext highlighter-rouge">add()</code>,<code class="language-plaintext highlighter-rouge">remove()</code>。</p><h3 id="使用extends在类限定t类型">使用extends在类限定T类型</h3><p>  在定义<strong>泛型类型</strong><code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的时候，也可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div><p>  现在，我们只能定义：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">p3</span><span class="o">;</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">Integer</code>和<code class="language-plaintext highlighter-rouge">Double</code>都符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>。<br />   非<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类类型将无法通过编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span> <span class="c1">// compile error!</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p>  因为<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Object</code>都不符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>，因为它们不是<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p><h3 id="小结-1">小结</h3><p>  <font color="red">**使用类似`&lt;? extends Number&gt;`通配符参与方法的形式参数时表示：**</font></p><ul><li><strong>调用:<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读,则必须至少用上界<code class="language-plaintext highlighter-rouge">Number</code>接收,也可以用<code class="language-plaintext highlighter-rouge">Number</code>的父类接收,比如<code class="language-plaintext highlighter-rouge">Object</code>，避免可能的向下转型。</strong></li><li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? extends Number&gt; o)</code>写则,因为可能向下转型的原因被一刀切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。(如果有下界倒是可以赋值下界或下界的子类,避免向下转型了)</strong></li><li><strong>方法被修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的泛型类型。</strong></li></ul><p>  <font color="red">**`&lt;? extends 上界&gt;`:传参类型&lt;=上界,只能写`null`，读&gt;=上界。**</font></p><p>  其实不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? extends 上界&gt;</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  使用类似<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示：</p><ul><li>泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</li></ul><h2 id="super通配符在形式参数的作用">super通配符在形式参数的作用</h2><p>  之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类,他们之前没有什么关系。   考察下面的<code class="language-plaintext highlighter-rouge">set</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是允许的，而传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>是不允许的。<br />   和<code class="language-plaintext highlighter-rouge">extends</code>通配符相反，这次，我们希望接受泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。还是向上提升的问题，父类可以被赋值子类，所以是操作是安全的。同样的,向下转型不安全,因此禁止读取。</p><p>  使用<code class="language-plaintext highlighter-rouge">super</code>通配符来改写这个方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。<br />   下面的代码可以被正常编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mf">12.3</span><span class="o">,</span> <span class="mf">4.56</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p2</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setSame</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>方法签名实际上是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">);</span>
</code></pre></div></div><p>  因此，可以安全地传入<code class="language-plaintext highlighter-rouge">Integer</code>类型。如果你传<code class="language-plaintext highlighter-rouge">Number</code>类型,不好意思,因为泛型有可能是<code class="language-plaintext highlighter-rouge">Integer</code>所以不可以，即：有可能造成<code class="language-plaintext highlighter-rouge">Number</code>转<code class="language-plaintext highlighter-rouge">Integer</code>了,即向下转型。所以你想写入,则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入,也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能的向下转型。   而<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，它的方法签名实际上是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span> <span class="kd">super</span> <span class="nc">Integer</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  无法使用<code class="language-plaintext highlighter-rouge">Integer</code>类型来接收<code class="language-plaintext highlighter-rouge">getFirst()</code>的返回值,还是老样子,<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物,也即可能的向下转型是不安全的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  因为如果传入的实际类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，编译器无法将<code class="language-plaintext highlighter-rouge">Number</code>类型转型为<code class="language-plaintext highlighter-rouge">Integer</code>,即向下转型。<br />   唯一可以接收<code class="language-plaintext highlighter-rouge">getFirst()</code>方法返回值的是<code class="language-plaintext highlighter-rouge">Object</code>类型,因为它是所有类的父类,它能包容一切,除它自己外,所有对它的赋值都是向上提升,因此是安全的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  <font color="red">**使用类似`&lt;? super Integer&gt;`通配符参与方法的形式参数时表示：** </font></p><ul><li><strong>调用:<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt; getFirst();</code>读,因为没有限定上界,那只能用<code class="language-plaintext highlighter-rouge">Object</code>接收,避免可能的向下转型。</strong></li><li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? super Integer&gt; o)</code>写则,则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入,也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能向下转型。</strong></li><li><strong>方法修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的泛型类型。</strong></li></ul><font color="red">**`<? super 下界>`:传参类型>=下界,写<=下界，读只能`Object`。** </font> &emsp;&emsp;其实不在方法参数也能用`<? super 下界>`。 ```java package com.aotmd; public class Main { public static void main(String[] args) { A<? super String> a=new A<>("123"); System.out.println(a); } } class A <T>{ public T value; public A(T value) {this.value = value;} @Override public String toString() {return "A{value=" + value + '}'; } } ``` ### 对比extends和super通配符在形式参数的作用 &emsp;&emsp;对比`extends`和`super`，作为方法参数，`<? extends T>`类型和`<? super T>`类型的区别在于： - <font color='red'>**`<? extends T>`:传参类型<=`T`,只能写`null`，读>=`T`。**</font> - <font color='red'>**`<? super T>`: 传参类型>=`T`,写<=`T`，读只能`Object`。** </font> &emsp;&emsp;一个是允许读不允许写，另一个是允许写不允许读。 &emsp;&emsp;我们来看Java标准库的`Collections`类定义的`copy()`方法： ```java public class Collections { // 把src的每个元素复制到dest中: public static <T> void copy(List<? super T> dest, List<? extends T> src) { for (int i=0; i<src.size(); i++) { T t = src.get(i); dest.add(t); } } } ``` &emsp;&emsp;它的作用是把一个`List`的每个元素依次添加到另一个`List`中。它的第一个参数是`List<? super T>`，表示目标`List`，第二个参数`List<? extends T>`，表示要复制的`List`。我们可以简单地用`for`循环实现复制。在`for`循环中，对于类型`<? extends T>`的变量`src`可以安全的读，而对于类型`<? super T>`的变量`dest`可以安全的写。 &emsp;&emsp;这个`copy()`方法的定义就完美地展示了`extends`和`super`的意图： - `copy()`方法内部不会读取`dest`，因为不能调用`dest.get()`来获取`T`的引用； - `copy()`方法内部也不会修改`src`，因为不能调用`src.add(T)`。 ```java List<Number> numList = new ArrayList<>(); List<Integer> intList = new ArrayList<>(); // copy List<Integer> to List<Number> ok: Collections.copy(numList, intList); ``` &emsp;&emsp;这两个 `T` 是同一个类型。在方法签名中，`<T>` 定义了方法级别的泛型类型参数，表示 `copy` 方法是一个泛型方法，它接受一个类型为 `T` 的参数。如果不能推断出相同的类型，则会导致编译错误。这是因为在泛型方法中，类型参数的推断是基于传入参数的类型来确定的，编译器会尝试推断出最具体的类型，然后将其用作所有相关类型参数的类型。如果无法推断出一个具体的类型，编译器将无法确定如何匹配类型参数，从而导致编译错误。 &emsp;&emsp;**`<? extends T>`:`Integer`<=`T`,只能写`null`，读>=`T`。** &emsp;&emsp;**`<? super T>`: `Number`>=`T`,写<=`T`，读只能`Object`。** &emsp;&emsp;即`Integer`<=`T`<=`Number` &emsp;&emsp;在在这次调用中`T`的类型确定需要满足两个条件,即: - 因为`<? super T>`,所以`Number`是`T`或`T`的父类,也就是说`T`是`Number`或其子类 - 因为`<? extends T>`,所以`Integer`是`T`或`T`的子类,也就是说`T`是`Integer`或其父类 emsp;&emsp;因此，`T` 可以被推断为 `Number`或`Integer`，从而实现了将 `Integer` 类型的列表复制到 `Number` 类型的列表的操作。这种根据实际类型推断泛型类型参数的过程称为类型推断。 &emsp;&emsp;这个`copy()`方法的另一个好处是可以安全地把一个`List<Integer>`添加到`List<Number>`，但是无法反过来添加： ```java List<Number> numList = new ArrayList<>(); List<Integer> intList = new ArrayList<>(); // ERROR: cannot copy List<Number> to List<Integer>: Collections.copy(intList, numList); ``` &emsp;&emsp;而这些都是通过`super`和`extends`通配符，并由编译器强制检查来实现的。 ### PECS原则 &emsp;&emsp;何时使用`extends`，何时使用`super`？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。 &emsp;&emsp;即：如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符；如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符。 &emsp;&emsp;还是以`Collections`的`copy()`方法为例： ```java public class Collections { public static <T> void copy(List<? super T> dest, List<? extends T> src) { for (int i=0; i<src.size(); i++) { T t = src.get(i); // src是producer dest.add(t); // dest是consumer } } } ``` &emsp;&emsp;需要返回`T`的`src`是生产者，因此声明为`List<? extends T>`，需要写入`T`的`dest`是消费者，因此声明为`List<? super T>`。 ### 使用super限定T类型 &emsp;&emsp;前面说了可以使用`extends`通配符来限定`T`的类型： ```java public class Pair<T extends Number> { } ``` &emsp;&emsp;将T限制为`Number`类型或`Number`的子类。 &emsp;&emsp;那么有没有`super`通配符来限定`T`的类型呢?我想到这样的代码: ```java public class Pair<T super Number> { } ``` &emsp;&emsp;将T限制为`Number`类型或`Number`的父类。 &emsp;&emsp;**不,java中没有实现在类中对下界进行限定**。 ### 无限定通配符 &emsp;&emsp;Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个`?`： ```java void sample(Pair<?> p) { } ``` &emsp;&emsp;因为`<?>`通配符既没有`extends`，也没有`super`，因此： - 不允许调用`set(T)`方法并传入引用（`null`除外）； - 不允许调用`T get()`方法并获取`T`引用（只能获取`Object`引用）。 &emsp;&emsp;也就是说:<font color='red'>**`<?>`传参类型随便,只能写`null`(因为无上界)，读只能`Object`(因为无下界)。**</font><p>  实际上<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</p><p>  换句话说，既不能读，也不能写，那只能做一些<code class="language-plaintext highlighter-rouge">null</code>判断：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  <code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符有一个独特的特点，就是：<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>是所有<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的超类(抢了OBject的工作)：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// 安全地向上转型</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上述代码是可以正常编译运行的，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p><h2 id="总结">总结</h2><p>  在Java中，泛型方法的类型参数声明通常写在<strong>返回类型之前</strong>。在类中定义的泛型类型参数通常<strong>用于整个类的实例</strong>，而在方法中定义的泛型类型参数<strong>只适用于该方法</strong>。</p><p>  <font color="red">**使用类似`&lt;? extends Number&gt;`通配符参与方法的形式参数时表示：**</font></p><ul><li><strong>调用:<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读,则必须至少用上界<code class="language-plaintext highlighter-rouge">Number</code>接收,也可以用<code class="language-plaintext highlighter-rouge">Number</code>的父类接收,比如<code class="language-plaintext highlighter-rouge">Object</code>，避免可能的向下转型。</strong></li><li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? extends Number&gt; o)</code>写则,因为可能向下转型的原因被一刀切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。(如果有下界倒是可以赋值下界或下界的子类,避免向下转型了)</strong></li><li><strong>方法被修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的泛型类型。</strong></li></ul><p>  <font color="red">**`&lt;? extends 上界&gt;`:传参类型&lt;=上界,只能写`null`，读&gt;=上界。**</font> <br />   使用类似<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示：</p><ul><li>泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</li></ul><p>  <font color="red">**使用类似`&lt;? super Integer&gt;`通配符参与方法的形式参数时表示：** </font></p><ul><li><strong>调用:<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt; getFirst();</code>读,因为没有限定上界,那只能用<code class="language-plaintext highlighter-rouge">Object</code>接收,避免可能的向下转型。</strong></li><li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? super Integer&gt; o)</code>写则,则至少用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入,也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能向下转型。</strong></li><li><strong>方法修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的泛型类型。</strong></li></ul><p>  <code class="language-plaintext highlighter-rouge">super</code>:传参&gt;=下界,只写&gt;=下界，读只能<code class="language-plaintext highlighter-rouge">Object</code>。</p><p>  对比<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>，作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型的区别在于：</p><ul><li> <font color="red">**`&lt;? extends T&gt;`:传参类型&lt;=`T`,只能写`null`，读&gt;=`T`。**</font></li><li> <font color="red">**`&lt;? super T&gt;`: 传参类型&gt;=`T`,写&lt;=`T`，读只能`Object`。** </font></li></ul><p>  因为<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符既没有<code class="language-plaintext highlighter-rouge">extends</code>，也没有<code class="language-plaintext highlighter-rouge">super</code>，因此：</p><ul><li>不允许调用<code class="language-plaintext highlighter-rouge">set(T)</code>方法并传入引用（<code class="language-plaintext highlighter-rouge">null</code>除外）；</li><li>不允许调用<code class="language-plaintext highlighter-rouge">T get()</code>方法并获取<code class="language-plaintext highlighter-rouge">T</code>引用（只能获取<code class="language-plaintext highlighter-rouge">Object</code>引用）。</li></ul><p>  也就是说:<font color="red">**`&lt;?&gt;`传参类型随便,只能写`null`(因为无上界)，读只能`Object`(因为无下界)。**</font></p><p>  无限定通配符<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>在形式参数中可以用<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>替换，同时它是<strong>相同泛型类</strong>的所有<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>类型的超类，因此是泛型中的<code class="language-plaintext highlighter-rouge">Objec</code>，但读写限制太死，没什么用。   实际上<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</p><p>  其实不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"456"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
        <span class="no">A</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"789"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  其实PECS原因就是java向上转型安全，而向下转型不安全</p><h2 id="泛型和反射">泛型和反射</h2><p>  Java的部分反射API也是泛型。例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>就是泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile warning:</span>
<span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// no warning:</span>
<span class="nc">Class</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</code></pre></div></div><p>  调用<code class="language-plaintext highlighter-rouge">Class</code>的<code class="language-plaintext highlighter-rouge">getSuperclass()</code>方法返回的<code class="language-plaintext highlighter-rouge">Class</code>类型是<code class="language-plaintext highlighter-rouge">Class&lt;? super T&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">sup</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
</code></pre></div></div><p>  构造方法<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>也是泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
</code></pre></div></div><p>  我们可以声明带泛型的数组，但不能用<code class="language-plaintext highlighter-rouge">new</code>操作符创建带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ok</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p>  必须通过强制转型实现带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div><p>  使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code class="language-plaintext highlighter-rouge">ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code class="language-plaintext highlighter-rouge">arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code class="language-plaintext highlighter-rouge">arr</code>可能导致从<code class="language-plaintext highlighter-rouge">ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span><span class="c1">//指向了不是String的内容</span>
<span class="c1">// ClassCastException:</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span><span class="c1">//类型转换错误</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  要安全地使用泛型数组，必须扔掉<code class="language-plaintext highlighter-rouge">arr</code>的引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div><p>  上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code class="language-plaintext highlighter-rouge">ps</code>进行操作，这种操作就是安全的。<br />   带泛型的数组实际上是编译器的类型擦除：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</code></pre></div></div><p>  所以我们不能直接创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>，因为擦拭后代码变为<code class="language-plaintext highlighter-rouge">Object[]</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile error:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  显然编译器要阻止这种类型不对的代码,为了防止可能的错误出现编译器直接一刀切这个操作。<br />   而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了抽象类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[]</span> <span class="n">pair</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Abc</span><span class="o">&lt;&gt;().</span><span class="na">createArray</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  上面的Number是不能直接实例化的，所以编译器要阻止这种行为。</p><p>  必须借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>来创建泛型数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>  我们还可以利用可变参数创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayHelper</span> <span class="o">{</span>
    <span class="nd">@SafeVarargs</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div><h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数</h3><p>  在上面的例子中，我们看到，通过：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>  似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>  直接调用<code class="language-plaintext highlighter-rouge">asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code class="language-plaintext highlighter-rouge">ClassCastException</code>，原因还是因为擦拭法，在<code class="language-plaintext highlighter-rouge">pickTwo()</code>方法内部，编译器无法检测<code class="language-plaintext highlighter-rouge">K[]</code>的正确类型，因此返回了<code class="language-plaintext highlighter-rouge">Object[]</code>。<br />   如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code class="language-plaintext highlighter-rouge">@SafeVarargs</code>消除警告。<br />   如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。<br />   更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p><h3 id="小结-2">小结</h3><p>  部分反射API是泛型，例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>，<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>；<br />   可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；<br />   可以通过<code class="language-plaintext highlighter-rouge">Array.newInstance(Class&lt;T&gt;, int)</code>创建<code class="language-plaintext highlighter-rouge">T[]</code>数组，需要强制转型；<br /> 同时使用泛型和可变参数时需要特别小心。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://acteds.github.io" target="_blank">acteds</a></li><li>本文链接：<a href="https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3-%E6%B3%9B%E5%9E%8B/" target="_blank">https://acteds.github.io/2021/05/03/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3-%E6%B3%9B%E5%9E%8B/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://acteds.github.io/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://acteds.github.io/assets/search_data.json?v=1712415808', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://acteds.github.io/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2023 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://acteds.github.io/" title="首页" target="">首页</a></li><li> <a href="https://acteds.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://acteds.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://acteds.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://acteds.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://acteds.github.io/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
