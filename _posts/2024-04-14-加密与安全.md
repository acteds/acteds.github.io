---
layout: post
title: 加密与安全
categories: Java
description: Java笔记
keywords: Java
---
# 引言
Base64编码、URL编码、哈希算法、对称加密算法、口令加密算法、 密钥交换算法、 非对称加密算法、签名算法、数字证书。  


# 加密与安全

## 编码

ASCII码就是一种编码，字母`A`的编码是十六进制的`0x41`，字母`B`是`0x42`，以此类推。因为ASCII编码最多只能有128个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是`0x4e2d`，使用UTF-8则需要3个字节编码。因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。

比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。

### URL编码

URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分

之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：

- 如果字符是`A`~`Z`，`a`~`z`，`0`~`9`以及`-`、`_`、`.`、`*`，则保持不变；
- 如果是其他字符，先转换为UTF-8编码，然后对每个字节以`%XX`表示。

例如：字符`中`的UTF-8编码是`0xe4b8ad`，因此，它的URL编码是`%E4%B8%AD`。URL编码总是大写。

Java标准库提供了一个`URLEncoder`类来对任意字符串进行URL编码，而`URLDecoder则`可以解码：

```java
String encoded = URLEncoder.encode("中 文!", StandardCharsets.UTF_8);
System.out.println(encoded);//%E4%B8%AD+%E6%96%87%21
String decoded = URLDecoder.decode(encoded, StandardCharsets.UTF_8);
System.out.println(decoded);//中 文!
```

**和标准的URL编码稍有不同，`URLEncoder`把空格字符编码成`+`**，而现在的URL编码标准要求空格被编码为`%20`，不过，服务器都可以处理这两种情况。

### Base64编码

Base64编码可以把任意长度的二进制数据变为纯文本，且只包含`A`~`Z`、`a`~`z`、`0`~`9`、`+`、`/`、`=`这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个`int`整数表示，然后查表，把`int`整数用索引对应到字符，得到编码后的字符串。

举个例子：3个byte数据分别是`ff`、`e0`、`1`，按6bit分组得到`39`、`0b`、`22`和`2d`：

```ascii
┌───────────────┬───────────────┬───────────────┐
│      ff       │      e0       │       1       │
└───────────────┴───────────────┴───────────────┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│1│1│1│1│1│1│1│1│1│0│0│0│0│0│0│0│0│0│0│0│0│1│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌───────────┬───────────┬───────────┬───────────┐
│    63     │    62     │     0     │     1     │
└───────────┴───────────┴───────────┴───────────┘
```

因为6位整数的范围总是`0`~`63`，所以，能用64个字符表示：字符`A`~`Z`对应索引`0`~`25`，字符`a`~`z`对应索引`26`~`51`，字符`0`~`9`对应索引`52`~`61`，最后两个索引`62`、`63`分别用字符`+`和`/`表示。

所以对于`ff`、`e0`、`1`，首先变成：`63`、`62`、`0`、`1`，再根据表转换为：`/`、`+`、`A`、`B`。

如果输入的`byte[]`数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个`0x00`，编码后，在结尾加一个`=`表示补充了1个`0x00`，加两个`=`表示补充了2个`0x00`，解码的时候，去掉末尾补充的一个或两个`0x00`即可。

实际上，因为编码后的长度加上`=`总是4的倍数，所以即使不加`=`也可以计算出原始输入的`byte[]`。Base64编码的时候**可以**用`withoutPadding()`去掉`=`，解码出来的结果是一样的。

在Java中，二进制数据就是`byte[]`数组。Java标准库提供了`Base64`来对`byte[]`数组进行编解码：

```java
byte[] input = "中 文!".getBytes(StandardCharsets.UTF_8);
String b64encoded = Base64.getEncoder().encodeToString(input);
System.out.println(b64encoded);//5LitIOaWhyE=
byte[] output = Base64.getDecoder().decode(b64encoded);
String s= new String(output,StandardCharsets.UTF_8);
System.out.println(s);//中 文!
```

因为标准的Base64编码会出现`+`、`/`和`=`，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把`+`变成`-`，`/`变成`_`。

```java
byte[] input = new byte[] { (byte) 0xFF, (byte) 0xE0, (byte) 0x1};

String b64encoded = Base64.getEncoder().encodeToString(input);
System.out.println(b64encoded);///+AB
String s1 = Arrays.toString(Base64.getDecoder().decode(b64encoded));
System.out.println(s1);//[-1, -32, 1]

String b64encoded2 = Base64.getUrlEncoder().encodeToString(input);
System.out.println(b64encoded2);//_-AB
String s2 = Arrays.toString(Base64.getUrlDecoder().decode(b64encoded2));
System.out.println(s2);//[-1, -32, 1]
```

Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。

Base64 编码将每 6 位原始数据编码为 8 位字符（即 1 字节），因此会使数据长度增加约 1/3。这是因为 每 3 个字节原始数据编码后变为 4 个字节的 Base64 字符串。



## 哈希算法

哈希算法（Hash）又称**摘要算法**（Digest），它的作用是：对任意一组输入数据进行计算，得到一个**固定长度**的输出**摘要**。

哈希算法最重要的特点就是：

- 相同的输入**一定**得到相同的输出；
- 不同的输入**大概率**得到不同的输出。

哈希算法的目的就是为了验证原始数据是否被篡改。

Java字符串的`hashCode()`就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节`int`整数。

### 哈希碰撞

哈希碰撞是指，两个不同的输入得到了相同的输出。

```java
System.out.printf("%X\n","AaAaAa".hashCode()); // 0x7460E8C0
System.out.printf("%X\n","BBAaBB".hashCode()); // 0x7460E8C0
```

碰撞是一定会出现的，因为输出的字节长度是固定的，`String`的`hashCode()`输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。

碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：

- 碰撞概率低；
- 不能猜测输出。

常用的哈希算法有：

| 算法       | 输出长度（位） | 输出长度（字节） |
| :--------- | :------------- | :--------------- |
| MD5        | 128 bits       | 16 bytes         |
| SHA-1      | 160 bits       | 20 bytes         |
| RipeMD-160 | 160 bits       | 20 bytes         |
| SHA-256    | 256 bits       | 32 bytes         |
| SHA-512    | 512 bits       | 64 bytes         |

根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。以MD5算法为例：

```java
// 创建一个MessageDigest实例:
MessageDigest md = MessageDigest.getInstance("MD5");
// 反复调用update,输入数据:
md.update("Hello".getBytes(StandardCharsets.UTF_8));
md.update("World".getBytes(StandardCharsets.UTF_8));
byte[] result = md.digest(); // 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6
System.out.println(new BigInteger(1, result).toString(16));
```

首先根据哈希算法获取一个`MessageDigest`实例，然后，反复调用`update(byte[])`输入数据。当输入结束后，调用`digest()`方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。

### `BigInteger`的坑

**注意：如果`result`前面有0会在转换为`BigInteger`时丢失**，因为`BigInteger`类在处理字符串时会忽略前导零，因为在数值上它们没有意义。

如果需要保留前导零，可以使用其他方法，如使用`printf`格式化补0到指定位数输出，或者直接使用字节数组。

```java
package com.aotmd;

import java.math.BigInteger;

public class Main {
    public static void main(String[] args) throws Exception {
        String hexString = "000005bd4639f848dd8ed27f1b3f6b0d";
        byte[] result=hexStringToByteArray(hexString);
        //5bd4639f848dd8ed27f1b3f6b0d
        System.out.println(new BigInteger(1,result).toString(16));
        //如果知道输出的位数，可以使用printf：000005bd4639f848dd8ed27f1b3f6b0d
        System.out.printf("%032x\n",new BigInteger(1,result));
        //还可以这样直接传入16进制字符串：000005bd4639f848dd8ed27f1b3f6b0d
        System.out.printf("%032x\n",new BigInteger(hexString,16));
        //如果不知道，就直接用字节数组吧：000005bd4639f848dd8ed27f1b3f6b0d
        for (byte b : result) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
    /**
     * 16进制字符串转换为字节数组。
     * @param hexString 16进制字符串
     * @return 字节数组
     */
    public static byte[] hexStringToByteArray(String hexString) {
        int len = hexString.length();
        byte[] byteArray = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            byteArray[i / 2] = (byte) (
                    (Character.digit(hexString.charAt(i), 16) << 4)
                    + Character.digit(hexString.charAt(i+1), 16)
            );
        }
        return byteArray;
    }
}
```


### 用途

因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。

在网站上下载软件的时候，经常看到下载页显示的哈希，如何判断下载到本地的软件是原始的、未经篡改的文件？只需要自己计算一下下载到本地的文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。

哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：数据库管理员能够看到用户明文口令；数据库数据一旦泄漏，黑客即可获取用户明文口令。

不存储用户的原始口令，那么如何对用户进行认证？方法是存储用户口令的哈希，例如，MD5。在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。

这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。

使用哈希口令时，还要注意防止彩虹表攻击。如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的**常用口令**和它们的MD5的对照表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令。因此不要使用弱密码，也不要使用生日等个人信息作为密码的原因，在社工面前找到账号对应的人是很容易的。

即使用户使用了常用口令，也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）。

```java
digest = md5(salt+inputPassword)
```

经过加盐处理的数据库表，内容如下：

| username | salt  | password                         |
| :------- | :---- | :------------------------------- |
| bob      | H1r0a | a5022319ff4c56955e22a74abcc2c210 |
| alice    | 7$p2w | e5de688c99e961ed6e560b972dab8b6a |
| tim      | z5Sk9 | 1eee304b92dc0d105904e7ab58fd2f64 |

加盐的目的在于使黑客的**彩虹表失效**，即使用户使用常用口令，也无法从MD5反推原始口令。这样，就算黑客拿到了数据库和源代码，也要对每个`salt`重新计算彩虹表。这已经不能叫彩虹表了，这就是暴力破解。

就算破解出与**加盐哈希前的密码**一样**加盐哈希的密码**，也不一定能保证就是**原始的密码**，而**只要不是原始的密码**，就算账号所有者的所有网站都设置同一个密码，也只破解了这一家网站的密码，因为每家网站的盐不一样。但是，如果某家网站没有加盐，被破解，那么意味着**原始密码**就被泄露了。

因此不建议所有网站都设置同一个密码，或者按网站的信任程度和重要性使用不同的密码，并且这些密码之间要像哈希生成的特征码一样，不具有通过几个密码推测出规律的可能。

盐的生成可以使用随机数：

```java
byte[] bs = new byte[16];
new Random().nextBytes(bs);
String s = HexFormat.of().formatHex(bs);
System.out.println(s);
```

### SHA-1

SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。

在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为`"SHA-1"`。类似的，计算SHA-256，我们需要传入名称`"SHA-256"`，计算SHA-512，我们需要传入名称`"SHA-512"`。

MD5因为输出长度较短，短时间内破解是可能的，目前已经**不推荐使用**。

## BouncyCastle

Java标准库提供了一系列常用的哈希算法。

但如果我们要用的某种算法，Java标准库没有提供怎么办？

方法一：自己写一个，难度很大；

方法二：找一个现成的第三方库，直接使用。

[BouncyCastle](https://www.bouncycastle.org/)就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。

首先，把BouncyCastle提供的jar包放到classpath中。这个jar包就是`bcprov-jdk18on-xxx.jar`，可以从[官方网站](https://www.bouncycastle.org/latest_releases.html)下载。

Java标准库的`java.security`包提供了一种标准机制，允许第三方提供商无缝接入。要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：

```java
// 注册BouncyCastle:
Security.addProvider(new BouncyCastleProvider());
// 按名称正常调用:
MessageDigest md = MessageDigest.getInstance("RipeMD160");
md.update("HelloWorld".getBytes(StandardCharsets.UTF_8));
byte[] result = md.digest();
for (byte b : result) {
    System.out.printf("%02x",b);
}
```

其中，注册BouncyCastle是通过下面的语句实现的：

```java
Security.addProvider(new BouncyCastleProvider());
```

注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。



## Hmac算法

在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。

我们回顾一下哈希算法：

```java
digest = hash(input)
```

正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：

```java
digest = hash(salt + input)
```

这个`salt`可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。

Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。

Hmac算法**总是和某种哈希算法配合起来用的**。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：

```
HmacMD5 ≈ md5(secure_random_key, input)
```

因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加`salt`，有如下好处：

- HmacMD5使用的`key`长度是64字节，更安全；
- Hmac是标准算法，同样适用于SHA-1等其他哈希算法；
- Hmac输出和原有的哈希算法长度一致。

可见，Hmac本质上就是把`key`混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供`key`。

为了保证安全，我们不会自己指定`key`，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：

```java
public static void main(String[] args) throws Exception {
    KeyGenerator keyGen = KeyGenerator.getInstance("HmacMD5");
    SecretKey key = keyGen.generateKey();
    // 打印随机生成的key:
    byte[] skey = key.getEncoded();
    out(skey);
    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(key);//传入key
    mac.update("HelloWorld".getBytes(StandardCharsets.UTF_8));//添加数据
    byte[] result = mac.doFinal();//调用
    out(result);//a7f9bf40c2929734...
}
public static void out(byte[] o){
    for (byte b : o) {
        System.out.printf("%02x",b);
    }
    System.out.println();
}
```

和MD5相比，使用HmacMD5的步骤是：

1. 通过名称`HmacMD5`获取`KeyGenerator`实例；
2. 通过`KeyGenerator`创建一个`SecretKey`实例；
3. 通过名称`HmacMD5`获取`Mac`实例；
4. 用`SecretKey`初始化`Mac`实例；
5. 对`Mac`实例反复调用`update(byte[])`输入数据；
6. 调用`Mac`实例的`doFinal()`获取最终的哈希值。

可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：

| username | secret_key (64 bytes) | password                         |
| :------- | :-------------------- | :------------------------------- |
| bob      | a8c06e05f92e...5e16   | 7e0387872a57c85ef6dddbaa12f376de |
| alice    | e6a343693985...f4be   | c1f929ac2552642b302e739bc0cdbaac |
| tim      | f27a973dfdc0...6003   | af57651c3a8a73303515804d4af43790 |

有了Hmac计算的哈希和`SecretKey`，我们想要验证怎么办？这时，`SecretKey`不能从`KeyGenerator`生成，而是从一个`byte[]`数组恢复：

```java
package com.aotmd;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
public class Main {
    public static void main(String[] args) throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance("HmacMD5");
        SecretKey key = keyGen.generateKey();
        // 打印随机生成的key:
        byte[] skey = key.getEncoded();
        out(skey);
        Mac mac = Mac.getInstance("HmacMD5");
        mac.init(key);//传入key
        mac.update("HelloWorld".getBytes(StandardCharsets.UTF_8));//添加数据
        byte[] result = mac.doFinal();//调用
        out(result);
        // 通过字节数组恢复key。
        SecretKey restoreTheKey = new SecretKeySpec(skey, "HmacMD5");
        Mac mac2 = Mac.getInstance("HmacMD5");
        mac2.init(restoreTheKey);
        mac2.update("HelloWorld".getBytes(StandardCharsets.UTF_8));
        byte[] result2 = mac2.doFinal();
        out(result2);
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```

恢复`SecretKey`的语句就是`new SecretKeySpec(hkey, "HmacMD5")`。

## 对称加密算法

对称加密算法就是传统的用一个密码进行加密和解密。

从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：

```
secret = encrypt(key, message);
```

而解密则相反，它接收密码和密文，然后输出明文：

```
plain = decrypt(key, secret);
```

在软件开发中，常用的对称加密算法有：

| 算法 | 密钥长度    | 工作模式             | 填充模式                                |
| :--- | :---------- | :------------------- | :-------------------------------------- |
| DES  | 56/64       | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/...              |
| AES  | 128/192/256 | ECB/CBC/PCBC/CTR/... | NoPadding/PKCS5Padding/PKCS7Padding/... |
| IDEA | 128         | ECB                  | PKCS5Padding/PKCS7Padding/...           |

密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。

最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。

### ECB模式

AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：

```java
package com.aotmd;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
public class Main {
    public static void main(String[] args) throws Exception {
        // 128位密钥 = 16 bytes Key:
        byte[] key = "1234567890abcdef".getBytes("UTF-8");
        byte[] data = "Hello, world!".getBytes("UTF-8");
        System.out.print("原文: " + new String(data, "UTF-8")+"，16进制：");
        out(data);// 原文
        // 加密:
        byte[] encrypted = encrypt(key, data);
        System.out.print("密文: " + new String(encrypted, "UTF-8")+"，16进制：");
        out(encrypted);// 密文
        // 解密:
        byte[] decrypted = decrypt(key, encrypted);
        System.out.print("解密: " + new String(decrypted, "UTF-8")+"，16进制：");
        out(decrypted);// 解密
    }

    // 加密:
    public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        SecretKey keySpec = new SecretKeySpec(key, "AES");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        return cipher.doFinal(input);
    }

    // 解密:
    public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        SecretKey keySpec = new SecretKeySpec(key, "AES");
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        return cipher.doFinal(input);
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```

控制台：

```text
原文: Hello, world!，16进制：48656c6c6f2c20776f726c6421
密文: ��D�E����\�，16进制：db188644e9450610b9edbec41aee5cde
解密: Hello, world!，16进制：48656c6c6f2c20776f726c6421
```

Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：

1. 根据算法名称/工作模式/填充模式获取`Cipher`实例；
2. 根据算法名称初始化一个`SecretKey`实例，密钥必须是指定长度；
3. 使用`SecretKey`初始化`Cipher`实例，并设置加密或解密模式；
4. 传入明文或密文，获得密文或明文。

ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低。

对于AES加密算法，**不论使用哪种模式**（如ECB、CBC等），**密钥长度必须**为16字节（128位）、24字节（192位）或32字节（256位）。这是由AES算法的规范确定的，以确保加密过程的安全性和正确性。如果密钥长度不符合这些要求，将无法正确使用AES算法进行加密。

------

### CBC模式

更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：

```java
package com.aotmd;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;

public class Main {
    public static void main(String[] args) throws Exception {
        // 256位密钥 = 32 bytes Key:
        byte[] key = "1234567890abcdef1234567890abcdef".getBytes(StandardCharsets.UTF_8);
        byte[] data = "Hello, world!".getBytes(StandardCharsets.UTF_8);
        System.out.print("原文: " + new String(data, StandardCharsets.UTF_8)+"，16进制：");
        out(data);// 原文
        // 加密:
        byte[] encrypted = encrypt(key, data);
        System.out.print("密文: " + new String(encrypted, StandardCharsets.UTF_8)+"，16进制：");
        out(encrypted);// 密文
        // 解密:
        byte[] decrypted = decrypt(key, encrypted);
        System.out.print("解密: " + new String(decrypted, StandardCharsets.UTF_8)+"，16进制：");
        out(decrypted);// 解密
    }


    // 加密:
    public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        // CBC模式需要生成一个16 bytes的initialization vector:
        SecureRandom sr = SecureRandom.getInstanceStrong();
        byte[] iv = sr.generateSeed(16);
        IvParameterSpec ivps = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);
        byte[] data = cipher.doFinal(input);
        // IV不需要保密，把IV和密文拼一起返回:
        return join(iv, data);
    }

    // 解密:
    public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {
        // 把input分割成IV和密文:
        byte[] iv = new byte[16];
        byte[] data = new byte[input.length - 16];
        System.arraycopy(input, 0, iv, 0, 16);
        System.arraycopy(input, 16, data, 0, data.length);
        // 解密:
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        IvParameterSpec ivps = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);
        return cipher.doFinal(data);
    }

    public static byte[] join(byte[] bs1, byte[] bs2) {
        byte[] r = new byte[bs1.length + bs2.length];
        System.arraycopy(bs1, 0, r, 0, bs1.length);
        System.arraycopy(bs2, 0, r, bs1.length, bs2.length);
        return r;
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```

CBC（Cipher Block Chaining）模式还需要一个16字节的初始向量（IV）。对于IV（Initialization Vector，初始化向量）参数，在AES算法中，它的长度**是固定的**，**为16字节**（128位）。无论使用哪种模式（如CBC、CTR等），IV参数的长度都应为16字节。IV的作用是为了在每次加密操作时引入随机性，即使是在使用相同密钥加密相同数据的情况下也能产生不同的密文。

**为保证安全，随机数必须使用`SecureRandom`生成**，虽然也管不到你用`Random`。

```java
byte[] iv=new byte[16];
new Random().nextBytes(iv);
IvParameterSpec ivps = new IvParameterSpec(iv);
```

因为多了一个`IvParameterSpec`实例，因此，初始化方法需要调用`Cipher`的一个重载方法并传入`IvParameterSpec`。

其实也就多了个随机数变量而已，**注意随机数必须16字节，key必须为16/24/32字节**。



## 口令加密算法

AES加密，密钥长度是固定的128/192/256位。这是因为对称加密算法决定了口令**必须是固定长度**，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。

用户输入的口令并不能**直接**作为AES的密钥进行加密（**除非长度恰好**是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。

PBE就是Password Based Encryption的缩写，它的作用如下：

```java
key = generate(userPassword, secureRandomPassword);
```

PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：

```java
package com.aotmd;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.security.Security;

public class Main {
    public static void main(String[] args) throws Exception {
        // 把BouncyCastle作为Provider添加到java.security:
        Security.addProvider(new BouncyCastleProvider());
        // 16 bytes随机Salt:
        byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16);
        // 加密口令:
        String password = "hello12345";
        // 数据
        byte[] data = "Hello, world!".getBytes(StandardCharsets.UTF_8);
        System.out.print("原文: " + new String(data, StandardCharsets.UTF_8)+"，16进制：");
        out(data);// 原文

        // 加密:
        byte[] encrypted = encrypt(password,salt, data);
        System.out.print("密文: " + new String(encrypted, StandardCharsets.UTF_8)+"，16进制：");
        out(encrypted);// 密文
        // 解密:
        byte[] decrypted = decrypt(password,salt, encrypted);
        System.out.print("解密: " + new String(decrypted, StandardCharsets.UTF_8)+"，16进制：");
        out(decrypted);// 解密
    }


    // 加密:
    public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
        // 通过password生成key
        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance("PBEwithSHA1and128bitAES-CBC-BC");
        SecretKey skey = skeyFactory.generateSecret(keySpec);
        // 盐
        PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
        // 加密
        Cipher cipher = Cipher.getInstance("PBEwithSHA1and128bitAES-CBC-BC");
        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);
        return cipher.doFinal(input);
    }

    // 解密:
    public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
        // 通过password生成key
        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance("PBEwithSHA1and128bitAES-CBC-BC");
        SecretKey skey = skeyFactory.generateSecret(keySpec);
        // 盐
        PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
        Cipher cipher = Cipher.getInstance("PBEwithSHA1and128bitAES-CBC-BC");
        // 解密
        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);
        return cipher.doFinal(input);
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}



```

使用PBE时，还需要引入BouncyCastle，并指定算法是`PBEwithSHA1and128bitAES-CBC-BC`。观察代码，实际上真正的AES密钥是调用`Cipher`的`init()`方法时同时传入`SecretKey`和`PBEParameterSpec`实现的。在创建`PBEParameterSpec`的时候，我们还指定了循环次数`1000`，循环次数越多，暴力破解需要的计算量就越大。

如果把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。



## 密钥交换算法

对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。

现在问题来了：如何传递密钥？

在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？

要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。

DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。

假设甲乙双方需要传递密钥，他们之间可以这么做：

1. 甲首先选择一个素数`p`，例如97，底数`g`是`p`的一个本原根，例如5，随机数`a`，例如123，然后计算`A=g^a mod p`，结果是34，然后，甲发送`p＝97`，`g=5`，`A=34`给乙；
2. 乙方收到后，也选择一个随机数`b`，例如，456，然后计算`B = g^b mod p`，结果是75，乙再同时计算`s = A^b mod p`，结果是22；
3. 乙把计算的`B=75`发给甲，甲计算`s ＝ B^a mod p`，计算结果与乙算出的结果一样，都是22。

所以最终双方协商出的密钥`s`是22。注意到这个密钥`s`并没有在网络上传输。而通过网络传输的`p`，`g`，`A`和`B`是无法推算出`s`的，因为实际算法选择的素数是非常大的。

所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。

如果我们把`a`看成甲的私钥，`A`看成甲的公钥，`b`看成乙的私钥，`B`看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥`secretKey`，DH算法通过数学定律保证了双方各自计算出的`secretKey`是相同的。

使用Java实现DH算法的代码如下：

```java
package com.aotmd;
import javax.crypto.KeyAgreement;
import java.security.*;
import java.security.spec.X509EncodedKeySpec;
public class Main {
    public static void main(String[] args) {
        // Bob和Alice:
        Person bob = new Person("Bob");
        Person alice = new Person("Alice");

        // 各自生成KeyPair:
        bob.generateKeyPair();
        alice.generateKeyPair();

        // 双方交换各自的PublicKey:
        // Bob根据Alice的PublicKey生成自己的本地密钥:
        bob.generateSecretKey(alice.publicKey.getEncoded());
        // Alice根据Bob的PublicKey生成自己的本地密钥:
        alice.generateSecretKey(bob.publicKey.getEncoded());

        // 检查双方的本地密钥是否相同:注意公key私key后面一部分不一样。
        bob.printKeys();
        alice.printKeys();
        // 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...
    }
}

class Person {
    public final String name;

    public PublicKey publicKey;
    private PrivateKey privateKey;
    private byte[] secretKey;

    public Person(String name) {
        this.name = name;
    }

    // 生成本地KeyPair:
    public void generateKeyPair() {
        try {
            KeyPairGenerator kpGen = KeyPairGenerator.getInstance("DH");
            kpGen.initialize(512);
            KeyPair kp = kpGen.generateKeyPair();
            this.privateKey = kp.getPrivate();
            this.publicKey = kp.getPublic();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    public void generateSecretKey(byte[] receivedPubKeyBytes) {
        try {
            // 从byte[]恢复PublicKey:
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(receivedPubKeyBytes);
            KeyFactory kf = KeyFactory.getInstance("DH");
            PublicKey receivedPublicKey = kf.generatePublic(keySpec);
            // 生成本地密钥:
            KeyAgreement keyAgreement = KeyAgreement.getInstance("DH");
            keyAgreement.init(this.privateKey); // 自己的PrivateKey
            keyAgreement.doPhase(receivedPublicKey, true); // 对方的PublicKey
            // 生成SecretKey密钥:
            this.secretKey = keyAgreement.generateSecret();
        } catch (GeneralSecurityException e) {
            throw new RuntimeException(e);
        }
    }

    public void printKeys() {
        System.out.println("Name: " + this.name);
        System.out.print("Private key: ");
        out(this.privateKey.getEncoded());
        System.out.print("Public key: ");
        out(this.publicKey.getEncoded());
        System.out.print("Secret key: ");
        out(this.secretKey);

    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```

但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。

假设甲乙在交换公钥时被丙截获，丙把自己的公钥分别发送给甲乙两人，就变成了，甲丙通信，丙乙通信。所以使用对称加密不能防止中间人攻击

Diffie-Hellman密钥交换算法的最低和最高密钥长度取决于使用的具体实现和协议要求。一般来说，DH密钥的长度必须是64的倍数，并且范围在512到8192之间（包括512和8192）。

本原根是一个数学概念，在数论中使用。简单来说，对于一个素数$p$，如果有一个数$g$，满足$g$的不同次幂对$p$取模的结果能够覆盖从$1$到$p-1$的所有可能的余数，而且没有重复，那么$g$就是模$p$的本原根。

举个例子，考虑素数$p=7$。我们要找到一个数$g$，满足$g$的不同次幂对$7$取模的结果覆盖了$1$到$6$的所有余数。对于$p=7$，数$3$就是一个本原根，因为$3^1 \equiv 3 \pmod{7}$，$3^2 \equiv 2 \pmod{7}$，$3^3 \equiv 6 \pmod{7}$，$3^4 \equiv 4 \pmod{7}$，$3^5 \equiv 5 \pmod{7}$，$3^6 \equiv 1 \pmod{7}$。这里$3$的不同次幂依次覆盖了$1$到$6$的所有余数，且没有重复。



## 非对称加密算法

从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。

非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。

因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。

非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。

非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要`N*(N-1)/2`个密钥，因此每个人需要管理`N-1`个密钥，密钥管理难度大，而且非常容易泄漏。

既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。

所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：

1. 小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；
2. 小红用自己的RSA私钥解密得到AES口令；
3. 双方使用这个共享的AES口令用AES加密通信。

可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。

Java标准库提供了RSA算法的实现，示例代码如下：

```java
package com.aotmd;

import javax.crypto.Cipher;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.*;

public class Main {
    public static void main(String[] args) throws GeneralSecurityException, UnsupportedEncodingException {
        // 明文:
        byte[] plain = "Hello, encrypt use RSA".getBytes(StandardCharsets.UTF_8);
        // 创建公钥／私钥对:
        Person alice = new Person("Alice");

        byte[] pk = alice.getPublicKey();
        System.out.print("public key: ");
        out(pk);

        // 用Alice的公钥加密:
        byte[] encrypted = alice.encrypt(plain);
        System.out.print("encrypted: ");
        out(encrypted);//密文


        byte[] sk = alice.getPrivateKey();
        System.out.print("private key: ");
        out(sk);

        // Alice用自己的私钥解密:
        byte[] decrypted = alice.decrypt(encrypted);
        System.out.println(new String(decrypted, StandardCharsets.UTF_8));
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}

class Person {
    String name;
    // 私钥:
    PrivateKey sk;
    // 公钥:
    PublicKey pk;
    public Person(String name) throws GeneralSecurityException {
        this.name = name;
        // 生成公钥／私钥对:
        KeyPairGenerator kpGen = KeyPairGenerator.getInstance("RSA");
        kpGen.initialize(1024);
        KeyPair kp = kpGen.generateKeyPair();
        this.sk = kp.getPrivate();
        this.pk = kp.getPublic();
    }
    // 把私钥导出为字节
    public byte[] getPrivateKey() {
        return this.sk.getEncoded();
    }
    // 把公钥导出为字节
    public byte[] getPublicKey() {
        return this.pk.getEncoded();
    }
    // 用公钥加密:
    public byte[] encrypt(byte[] message) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, this.pk);
        return cipher.doFinal(message);
    }
    // 用私钥解密:
    public byte[] decrypt(byte[] input) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, this.sk);
        return cipher.doFinal(input);
    }
}
```

RSA的公钥和私钥都可以通过`getEncoded()`方法获得以`byte[]`表示的二进制数据，并根据需要保存到文件中。要从`byte[]`数组恢复公钥或私钥，可以这么写：

```java
byte[] pkData = ...
byte[] skData = ...
KeyFactory kf = KeyFactory.getInstance("RSA");
// 恢复公钥:
X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);
PublicKey pk = kf.generatePublic(pkSpec);
// 恢复私钥:
PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);
PrivateKey sk = kf.generatePrivate(skSpec);
```

以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。

如果修改待加密的`byte[]`数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。此外，只使用非对称加密算法不能防止中间人攻击。

对称加密只需记住别人的密码，就可以了，识别到是小红发的邮件，用小红的密码密码打开就可以了，发邮件，用自己的密码加密，发出去就可以了。这个问题是，有多少人就需要记多少人的密码，太麻烦了。
非对称加密，你只要记住自己的密码（秘钥），别人发给你的邮件，你也别管是谁的了，用你秘钥就可以打开。解邮件是很爽，但是，发邮件，就有问题了，你得记住每个人的公钥，然后，进行加密，这和记私钥有啥区别呢？

不过，好消息是，公钥之所以叫公钥，就是他不需要进行保密，你可以把你的公钥放在信封上和加密信，一起发给别人，别人也可以，把公钥放在信封上面，把邮件发给你，你就可以拿到别人的公钥了，然后就可以用别人的公钥加密文件一起发给别人了。所以，不需要记住别人的公钥，因为别人会告诉你。

中间人攻击是指：小红给你的发的邮件，被小明，拦截了，然后把信封上面的小红的公钥，换成了，小明的公钥。



## 签名算法

使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。

如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。

不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？

这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如`小明喜欢小红`，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认`小明喜欢小红`这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。

因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。

在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：

```java
signature = encrypt(privateKey, sha256(message))
```

对签名进行验证实际上就是用公钥解密：

```java
hash = decrypt(publicKey, signature)
```

然后把解密后的哈希与原始消息的哈希进行对比。

因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。

常用数字签名算法有：

- MD5withRSA
- SHA1withRSA
- SHA256withRSA

它们实际上就是指定某种哈希算法进行RSA签名的方式。

### SHA1withRSA

```java
package com.aotmd;

import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.*;

public class Main {
    public static void main(String[] args) throws GeneralSecurityException, UnsupportedEncodingException {
        // 生成RSA公钥/私钥:
        KeyPairGenerator kpGen = KeyPairGenerator.getInstance("RSA");
        kpGen.initialize(1024);
        KeyPair kp = kpGen.generateKeyPair();
        PrivateKey sk = kp.getPrivate();
        PublicKey pk = kp.getPublic();

        // 待签名的消息或摘要:
        byte[] message = "Hello, I am Bob!".getBytes(StandardCharsets.UTF_8);

        // 用自己的私钥签名:
        Signature s = Signature.getInstance("SHA1withRSA");
        s.initSign(sk);
        s.update(message);
        byte[] signed = s.sign();
        // 将消息与签名公开，签名用来验证消息没有被篡改
        out(message);
        out(signed);

        // 用某人公开的公钥验证，解析公开的签名和消息，是否是对应人的。
        Signature v = Signature.getInstance("SHA1withRSA");
        v.initVerify(pk);
        v.update(message);
        System.out.println(new String(message,StandardCharsets.UTF_8)+"这消息保真吗? " + v.verify(signed));
        // 消息被篡改：
        byte[] message2 = "Hello, I am Gay".getBytes(StandardCharsets.UTF_8);
        v.update(message2);
        System.out.println(new String(message2,StandardCharsets.UTF_8)+"这消息保真吗? " + v.verify(signed));
        // 用其他人的key，公钥对不上：
        PublicKey pk2 = kpGen.generateKeyPair().getPublic();
        v.initVerify(pk2);
        v.update(message);
        System.out.println(new String(message,StandardCharsets.UTF_8)+"这消息保真吗? " + v.verify(signed));
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```

控制台：

```text
48656c6c6f2c204920616d20426f6221
3aa37bb696a9c9e808cf42e45e17a79d24139972ba409cce9be475fd00d97968e68a110f667e0cca5a5ed177919c5c20b2a3720bbfc0caa5ae128887da7312ab1be5b3ac409d3917853212a3a14eb96899054db49152fd57299922f3794e874325be498f824044f763753b2eb2c855e06d823c3f1fbaf8240eaf65a25cdac0fd
Hello, I am Bob!这消息保真吗? true
Hello, I am Gay这消息保真吗? false
Hello, I am Bob!这消息保真吗? false
```

使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。



### 使用`SignedObject`

实际上可以用`SignedObject`携带消息数据，它还会记录签名和签名的算法名称。

```java
package com.aotmd;

import java.io.*;
import java.security.*;

public class Main {
    public static void main(String[] args) throws GeneralSecurityException, IOException, ClassNotFoundException {
        // 生成RSA密钥对
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
        keyPairGenerator.initialize(1024);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        PrivateKey privateKey = keyPair.getPrivate();
        PublicKey publicKey = keyPair.getPublic();

        // 创建消息
        String message = "Hello, world!";
        Signature signature = Signature.getInstance("SHA256withRSA");
        // 使用私钥对消息进行签名，创建含消息数据和签名的对象，SignedObject也会记录签名算法名称。
        SignedObject signedObject = new SignedObject(message, privateKey, signature);

        // 数据的字节数组表示
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//内存模拟
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(signedObject);//序列化
        byte[] p7Data = byteArrayOutputStream.toByteArray();//读取字节

        // 数据保存到文件或发送给其他方
        out(p7Data);


        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(p7Data);//内存模拟
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);

        SignedObject signedObjectReceived = (SignedObject) objectInputStream.readObject();//反序列化
        // 在接收方，可以使用公钥来验证消息，签名已经在对象里了
        boolean verified = signedObjectReceived.verify(publicKey, signature);
        // 拿到消息
        String verifiedMessage = (String) signedObjectReceived.getObject();

        System.out.println(verifiedMessage+"，保真吗？"+verified);

    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}

```

控制台：

```text
aced00057372001a6a6176612e73656375726974792e5369676e65644f626a65637409ffbd682a3cd5ff0200035b0007636f6e74656e747400025b425b00097369676e617475726571007e00014c000c746865616c676f726974686d7400124c6a6176612f6c616e672f537472696e673b7870757200025b42acf317f8060854e0020000787000000014aced000574000d48656c6c6f2c20776f726c64217571007e000400000080ad39f5b20d2178c282f04fd90a50ad55a4c444fea270919d61ce8813d7c74ffb6275357c25a1025890db1e78fbae9910f943c2955e6e0734b1ef9cdd83f6ddfa0d2d5d680999146dd3b5021d8c546e1b6e45c587d935a57cfbd32232188bfbe3ea0308a0ae7bc4036dfe0a9d3e495f713297bc33236c7f7981b8637bbc69de5574000d53484132353677697468525341
Hello, world!，保真吗？true
```

自建一个也非常容易，`SignedObject`是一个支持序列化，内部并封装了消息数据、签名信息和签名算法，实例化时要求传入消息数据，私钥，签名算法，内部不会保留私钥。还有验证方法`verify`，因为内部保存了签名信息，因此只需要传入公钥和签名算法即可。以及返回消息数据的`getObject`方法。**注意！传入的消息数据如果是对象需要实现序列化。**



**DSA签名**

除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。

DSA只能配合SHA使用，常用的算法有：

- SHA1withDSA
- SHA256withDSA
- SHA512withDSA

和RSA数字签名相比，DSA的优点是更快。

**ECDSA签名**

椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。



P1格式和P7格式是数字证书的编码格式，通常用于存储和传输证书及其相关信息。

**P1格式**

P1格式是一种简单的ASCII文本格式，通常用于存储私钥。P1格式的私钥文件以"-----BEGIN PRIVATE KEY-----"开头，以"-----END PRIVATE KEY-----"结尾，中间包含私钥的内容。

P1只是一种秘钥文件的规范，指明了文件中包含的内容是私钥或公钥，以及如何编码这些内容。在处理P1格式的秘钥文件时，需要注意文件中包含的标记（例如`-----BEGIN PRIVATE KEY-----`和`-----END PRIVATE KEY-----`）以及可能的Base64编码。根据具体的规范和编码，需要适当地处理文件内容以提取秘钥的原始数据，并使用相应的类和方法来解析和恢复秘钥对象。

```java
package com.aotmd;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class Main {
    public static void main(String[] args) throws GeneralSecurityException, IOException {
        //生成P1格式公钥私钥文件
        newP1();

        //读取P1格式公钥私钥文件
        Object[] object = loadP1();
        PrivateKey sk= (PrivateKey) object[0];
        PublicKey pk= (PublicKey) object[1];

        // 待签名的消息或摘要:
        byte[] message = "Hello, I am Bob!".getBytes(StandardCharsets.UTF_8);

        // 用自己的私钥签名:
        Signature s = Signature.getInstance("SHA1withRSA");
        s.initSign(sk);
        s.update(message);
        byte[] signed = s.sign();
        // 将消息与签名公开，签名用来验证消息没有被篡改
        out(message);
        out(signed);

        // 用某人公开的公钥验证，解析公开的签名和消息，是否是对应人的。
        Signature v = Signature.getInstance("SHA1withRSA");
        v.initVerify(pk);
        v.update(message);
        System.out.println(new String(message,StandardCharsets.UTF_8)+"这消息保真吗? " + v.verify(signed));
    }
    static void newP1() throws IOException, NoSuchAlgorithmException {
        // 生成RSA公钥/私钥:
        KeyPairGenerator kpGen = KeyPairGenerator.getInstance("RSA");
        kpGen.initialize(1024);
        KeyPair kp = kpGen.generateKeyPair();
        PrivateKey sk = kp.getPrivate();
        PublicKey pk = kp.getPublic();

        // P1格式公钥
        String base64EncodedPublicKey = Base64.getEncoder().encodeToString(pk.getEncoded());
        String p1FormattedPublicKey = "-----BEGIN PUBLIC KEY-----\n" +
                base64EncodedPublicKey + "\n" +
                "-----END PUBLIC KEY-----\n";
        // 将P1格式的公钥保存到文件
        FileOutputStream fos = new FileOutputStream("publicKey.p1");
        fos.write(p1FormattedPublicKey.getBytes());
        fos.close();
        // P1格式私钥
        String base64EncodedPrivateKey = Base64.getEncoder().encodeToString(sk.getEncoded());
        String p1FormattedPrivateKey = "-----BEGIN PRIVATE KEY-----\n" +
                base64EncodedPrivateKey + "\n" +
                "-----END PRIVATE KEY-----\n";

        // 将P1格式的私钥保存到文件
        FileOutputStream fos2 = new FileOutputStream("privateKey.p1");
        fos2.write(p1FormattedPrivateKey.getBytes());
        fos2.close();
    }
    static Object[] loadP1() throws InvalidKeySpecException, IOException, NoSuchAlgorithmException {
        // 加载P1格式的私钥
        FileInputStream fis = new FileInputStream("privateKey.p1");
        byte[] privateKeyBytes = fis.readAllBytes();
        fis.close();
        // 移除文本标记
        String s1=new String(privateKeyBytes)
                .replace("-----BEGIN PRIVATE KEY-----", "")
                .replace("-----END PRIVATE KEY-----", "")
                .replaceAll("\\s+", "");
        privateKeyBytes=Base64.getDecoder().decode(s1);
        KeyFactory kf = KeyFactory.getInstance("RSA");

        // 恢复私钥:
        PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(privateKeyBytes);
        PrivateKey sk = kf.generatePrivate(skSpec);

        // 加载P1格式的公钥
        FileInputStream fis2 = new FileInputStream("publicKey.p1");
        byte[] publicKeyBytes = fis2.readAllBytes();
        fis2.close();
        // 移除文本标记
        String s2=new String(publicKeyBytes)
                .replace("-----BEGIN PUBLIC KEY-----", "")
                .replace("-----END PUBLIC KEY-----", "")
                .replaceAll("\\s+", "");
        publicKeyBytes =Base64.getDecoder().decode(s2);
        X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(publicKeyBytes);
        PublicKey pk = kf.generatePublic(pkSpec);

        return new Object[]{sk,pk};
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```



P7格式是一种用于存储加密数据和证书链的格式。P7格式的文件以"-----BEGIN PKCS7-----"开头，以"-----END PKCS7-----"结尾，中间包含加密数据和证书链的信息。

当第三方接口要求使用P7格式签名时，是要求将加密数据和证书链一起打包成P7格式的数据，用于传输或存储。

**SM2算法**是一种基于椭圆曲线的非对称加密算法，是中国制定的国家密码算法标准之一。SM2算法提供了数字签名、密钥交换、公钥加密等功能，被广泛应用于各种安全领域，如电子认证、数字签名、信息传输加密等。由于SM2算法是非对称加密算法，因此在使用时需要生成一对公钥和私钥，公钥用于加密或验证签名，私钥用于解密或生成签名。



## 数字证书

摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。

因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。

数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。

上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。

要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用**自签名**的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。

在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。用下面的命令创建一个key store，并设定口令123456：

```bash
keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"
```

几个主要的参数是：

- keyalg：指定RSA加密算法；
- sigalg：指定SHA1withRSA签名算法；
- validity：指定证书有效期3650天；
- alias：指定证书在程序中引用的名称；
- dname：最重要的`CN=www.sample.com`指定了`Common Name`，如果证书用在HTTPS中，这个名称必须与域名完全一致。

执行上述命令，JDK会在当前目录创建一个`my.keystore`文件，并存**储创建成功的一个私钥和一个证书**，它的别名是`mycert`。可以使用以下命令列出密钥库的内容：

```bash
keytool -list -v -keystore my.keystore -storepass 123456
```

请注意，虽然这个密钥库包含私钥，但这只是一个自签名证书，不会被浏览器等受信任的 CA 所信任，因此在实际生产环境中，您需要从受信任的 CA 获取证书以及相应的私钥，而不是使用自签名证书。

使用 Java KeyStore (JKS) 工具生成密钥库（keystore），默认情况下，生成的密钥库将包含证书以及相应的私钥。这是因为在实际使用中，密钥库通常用于存储证书和私钥对，以便安全地管理和使用它们。

还可以使用 `-storetype pkcs12` 选项来生成 PKCS12 格式的密钥库：

```bash
keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.p12 -storetype PKCS12 -dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"
```

这个命令使用 `keytool` 工具生成了一个包含 RSA 密钥对的 PKCS12 格式的密钥库文件 `my.p12`。具体参数的含义如下：

- `-storepass 123456`: 设置密钥库的密码为 `123456`。
- `-genkeypair`: 生成密钥对。
- `-keyalg RSA`: 使用 RSA 算法生成密钥对。
- `-keysize 1024`: 设置密钥大小为 1024 位。
- `-sigalg SHA1withRSA`: 使用 SHA1withRSA 签名算法。
- `-validity 3650`: 设置证书的有效期为 3650 天。
- `-alias mycert`: 设置别名为 `mycert`。
- `-keystore my.p12`: 指定生成的密钥库文件名为 `my.p12`。
- `-storetype PKCS12`: 指定密钥库类型为 PKCS12。
- `-dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"`: 设置证书主题信息，包括通用名称 (CN)、组织单位 (OU)、组织 (O)、城市 (L)、州/省 (ST) 和国家代码 (C)。

这条命令的作用是生成一个包含指定 RSA 密钥对和证书信息的 PKCS12 格式的密钥库文件 `my.p12`。

有了key store存储的证书，就可以通过数字证书进行加解密和签名：

```java
package com.aotmd;

import javax.crypto.Cipher;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Signature;
import java.security.cert.X509Certificate;

public class Main {
    public static void main(String[] args) throws Exception  {
        byte[] message = "Hello, use X.509 cert!".getBytes(StandardCharsets.UTF_8);
        // 读取KeyStore:
        KeyStore ks = loadKeyStore("my.p12", "123456");
        // 读取私钥:,用alias指定的名字
        PrivateKey privateKey = (PrivateKey) ks.getKey("mycert", "123456".toCharArray());
        // 读取证书:
        X509Certificate certificate = (X509Certificate) ks.getCertificate("mycert");
        // 公钥加密:
        byte[] encrypted = encrypt(certificate, message);
        out(encrypted);
        // 私钥解密:
        byte[] decrypted = decrypt(privateKey, encrypted);
        System.out.println("decrypted: " + new String(decrypted, StandardCharsets.UTF_8));
        // 用私钥签名:
        byte[] sign = sign(privateKey, certificate, message);
        out(sign);
        // 用公钥验证签名:
        boolean verified = verify(certificate, message, sign);
        System.out.println("verify: " + verified);
    }
    static KeyStore loadKeyStore(String keyStoreFile, String password) {
        try (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) {
            if (input == null) {
                throw new RuntimeException("file not found in classpath: " + keyStoreFile);
            }
            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
            ks.load(input, password.toCharArray());
            return ks;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    static byte[] encrypt(X509Certificate certificate, byte[] message) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());
        return cipher.doFinal(message);
    }

    static byte[] decrypt(PrivateKey privateKey, byte[] data) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        return cipher.doFinal(data);
    }

    static byte[] sign(PrivateKey privateKey, X509Certificate certificate, byte[] message)
            throws GeneralSecurityException {
        Signature signature = Signature.getInstance(certificate.getSigAlgName());
        signature.initSign(privateKey);
        signature.update(message);
        return signature.sign();
    }

    static boolean verify(X509Certificate certificate, byte[] message, byte[] sig) throws GeneralSecurityException {
        Signature signature = Signature.getInstance(certificate.getSigAlgName());
        signature.initVerify(certificate);
        signature.update(message);
        return signature.verify(sig);
    }
    public static void out(byte[] o){
        for (byte b : o) {
            System.out.printf("%02x",b);
        }
        System.out.println();
    }
}
```

从key store直接读取了私钥-公钥对，私钥以`PrivateKey`实例表示，公钥以`X509Certificate`表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。

以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：

1. 浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；
2. 浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；
3. 服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。

上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。

注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商[DigiNotar](https://en.wikipedia.org/wiki/DigiNotar)就发生过私钥泄漏导致公司破产的事故。
