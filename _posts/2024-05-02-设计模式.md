---
layout: post
title: 设计模式
categories: Java
description: Java笔记
keywords: Java
---
# 引言
设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。

# 设计模式

软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，23个常用模式分为创建型模式、结构型模式和行为型模式三类，基于以下几个原则：

**开闭原则**

软件应该对扩展开放，而对修改关闭。在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。

**单一职责原则**

一个类只负责一项职责。针对一个类，其承担的职责越多，被复用的可能性就越小。如果类承担的职责很多，就意味着这些职责耦合在了一起。

**里氏替换原则**

如果调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。

**接口隔离原则**

- 客户需要什么样的接口，就提供什么样的接口，不需要的就删除掉；
- 类之间的依赖关系应建立在最小的接口上。也就是说，接口中的方法要尽量的少，接口功能要尽量的细分。

 **依赖倒置原则**

依赖倒转原则就是要依赖于抽象，不要依赖于实现。高层模块不依赖于底层模块，二者都依赖其抽象；抽象不依赖于细节，细节应该依赖抽象。

也就是说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等，而不是用具体类。**一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法**。特例：对象的创建过程是违背“开—闭”原则以及依赖倒转原则的，但通过工厂模式，能很好地解决对象创建过程中的依赖倒转问题。

**迪米特法则**

又称为最少知识原则，**一个软件实体应当尽可能少地与其他实体发生相互作用。**

如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。

在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；

在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

**组合/聚合复用原则**

简单的说是，尽量使用对象的组合/聚合，而不是继承来达到复用的目的。

组合和聚合都是对象建模中关联关系的一种。聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。

组合/聚合和继承是实现代码复用的两种基本途径，在设计过程中尽量使用组合/聚合，而不是继承。因为继承使得基类与子类有较强的耦合性，通常情况下基类的内部细节对子类来说是可见的，这样基类的实现细节会暴露给子类，破坏了系统的封装性。

开闭原则是所有面向对象原则的核心；里式替换原则是实现开闭原则的重要方式之一；依赖倒置原则是系统抽象化的具体实现，其是面向对象设计的主要实现机制之一；接口隔离原则要求接口的方法尽量少，接口尽量细化；迪米特法则降低系统的耦合度，其使得一个模块的修改尽量少的影响其他模块，扩展会相对容易；尽量使用组合/聚合而不是继承达到代码复用的目的。

## 创建型模式

创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。

创建型模式包括：

- 工厂方法：Factory Method
- 抽象工厂：Abstract Factory
- 建造者：Builder
- 原型：Prototype
- 单例：Singleton

### 工厂方法

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

工厂方法即Factory Method，是一种对象创建型模式。

工厂方法的目的是使得**创建对象**和**使用对象**是**分离**的，并且客户端**总是引用抽象工厂和抽象产品**：

```ascii
┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │<─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
```

实现一个解析`字符串`为`Number`的`Factory`，可以定义如下：

```java
public interface NumberFactory {
    Number parse(String s);
}
```

有了工厂接口，再编写一个工厂的实现类：

```java
public class NumberFactoryImpl implements NumberFactory {
    public Number parse(String s) {
        return new BigDecimal(s);
    }
}
```

产品接口是`Number`，`NumberFactoryImpl`返回的实际产品是`BigDecimal`。

通常会在接口`Factory`中再定义一个静态方法`getFactory()`来返回真正的子类（在 **Java 8** 中，接口可以包含静态方法）：

```java
public interface NumberFactory {
    // 创建方法:
    Number parse(String s);
    // 获取工厂实例:
    static NumberFactory getFactory() {
        return impl;
    }
    static NumberFactory impl = new NumberFactoryImpl();
}
```

在客户端中，只需要和工厂接口`NumberFactory`以及抽象产品`Number`打交道：

```java
NumberFactory factory = NumberFactory.getFactory();
Number result = factory.parse("123.456");
```

调用方可以完全忽略真正的工厂`NumberFactoryImpl`和实际的产品`BigDecimal`，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。

------

实际上，大多数情况下并不需要抽象工厂，而是通过静态方法直接返回产品，即：

```java
public class NumberFactory {
    public static Number parse(String s) {
        return new BigDecimal(s);
    }
}
```

这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：

```java
Integer n = Integer.valueOf(100);
```

`Integer`既是产品又是静态工厂。它提供了静态方法`valueOf()`来创建`Integer`。那么这种方式和直接写`new Integer(100)`有何区别呢？

```java
public final class Integer {
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ...
}
```

它的好处在于，`valueOf()`内部可能会使用`new`创建一个新的`Integer`实例，但也可能直接返回一个缓存的`Integer`实例。对于调用方来说，没必要知道`Integer`创建的细节。

 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。

如果调用方直接使用`Integer n = new Integer(100)`，那么就失去了使用缓存优化的可能性。

------

经常使用的另一个静态工厂方法是`List.of()`：

```java
List<String> list = List.of("A", "B", "C");
```

这个静态工厂方法接收可变参数，然后返回`List`接口。需要注意的是，调用方获取的产品总是`List`接口，而且并不关心它的实际类型。

即使调用方知道`List`产品的实际类型是`java.util.ImmutableCollections$ListN`，也不要去强制转型为子类，因为静态工厂方法`List.of()`保证返回`List`，但也完全可以修改为返回`java.util.ArrayList`。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。

 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。

------

和`List.of()`类似，使用`MessageDigest`时，为了创建某个摘要算法，总是使用静态工厂方法`getInstance(String)`：

```java
MessageDigest md5 = MessageDigest.getInstance("MD5");
MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
```

调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是`MessageDigest`这个抽象类。

### 抽象工厂

> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。

抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：

```ascii
                                ┌────────┐
                             ─ >│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─>│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ >│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ >│ProductA1│  ─ >│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─>│ProductB1│ └ ─>│ProductB2│
               └─────────┘     └─────────┘
```

这种模式有点类似于多个供应商负责提供一系列类型的产品。

假设希望为用户提供一个可以买荤素菜的环境，定义接口：

```java
interface ImeatAndVegetarianFactory {
    IMeat buyMeatDishes();
    IVegetarian buyVegetarianDishes();
}
interface IMeat {
    String getMeatName();
}
interface IVegetarian {
    String getVegetarianName();
}
```

定义好了抽象工厂（`ImeatAndVegetarianFactory`）以及两个抽象产品（`IMeat`和`IVegetarian`）。假设环境可以是超市也可以是菜市场，先写菜市场：

```java
/*菜市场*/
class MeatDishesFromTheWetMarketImpl implements IMeat {
    @Override
    public String getMeatName() {
        return "菜市场的荤菜";
    }
}
class VegetarianDishesInTheWetMarketImpl implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "菜市场的素菜";
    }
}
class MarketFactoryImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetMarketImpl();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetMarketImpl();
    }
}
```

然后就可以使用了：

```java
meatAndVegetarianFactory f=new MarketFactoryImpl();//菜市场
IMeat IMeat = f.buyMeatDishes();
System.out.println(IMeat.getMeatName());//菜市场的荤菜
IVegetarian IVegetarian = f.buyVegetarianDishes();
System.out.println(IVegetarian.getVegetarianName());//菜市场的素菜
```

看起来似乎也没什么作用。

再写超市：

```java
class MeatDishesFromTheWetSupermarket implements IMeat {
    @Override
    public String getMeatName() {
        return "超市的荤菜";
    }
}
class VegetarianDishesInTheWetSupermarket implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "超市的素菜";
    }
}
class SupermarketImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetSupermarket();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetSupermarket();
    }
}
```

要使用，则只需要改动一下初始化的工厂就行了：即把`new MarketFactoryImpl();`改成`new SupermarketImpl();`。这下作用比较明显了。

还可以把这行也隐藏起来，这样用户就完全不会接触到具体实现了：

```java
public class Main {
    @Test
    void test() {
        ImeatAndVegetarianFactory f= ImeatAndVegetarianFactory.createFactory("超市");
        IMeat IMeat = f.buyMeatDishes();
        System.out.println(IMeat.getMeatName());
        IVegetarian IVegetarian = f.buyVegetarianDishes();
        System.out.println(IVegetarian.getVegetarianName());
    }
}
interface ImeatAndVegetarianFactory {
    IMeat buyMeatDishes();
    IVegetarian buyVegetarianDishes();
    static ImeatAndVegetarianFactory createFactory(String name){
        if (name.equals("超市")) {
            return new SupermarketImpl();
        }else if (name.equals("菜市场")){
            return new MarketFactoryImpl();
        }
        throw new RuntimeException("未定义");
    }
}
```

抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；

抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。

------

完整代码：

```java
package test;
import org.junit.jupiter.api.Test;


public class Main {
    @Test
    void test() {
        ImeatAndVegetarianFactory f= ImeatAndVegetarianFactory.createFactory("超市");
        test(f);
        f=ImeatAndVegetarianFactory.createFactory("菜市场");
        test(f);
    }

    private static void test(ImeatAndVegetarianFactory f) {
        IMeat IMeat = f.buyMeatDishes();
        System.out.println(IMeat.getMeatName());
        IVegetarian IVegetarian = f.buyVegetarianDishes();
        System.out.println(IVegetarian.getVegetarianName());
    }
}
interface ImeatAndVegetarianFactory {
    IMeat buyMeatDishes();
    IVegetarian buyVegetarianDishes();
    static ImeatAndVegetarianFactory createFactory(String name){
        if (name.equals("超市")) {
            return new SupermarketImpl();
        }else if (name.equals("菜市场")){
            return new MarketFactoryImpl();
        }
        throw new RuntimeException("未定义");
    }
}
interface IMeat {
    String getMeatName();
}
interface IVegetarian {
    String getVegetarianName();
}
/*菜市场*/
class MeatDishesFromTheWetMarketImpl implements IMeat {
    @Override
    public String getMeatName() {
        return "菜市场的荤菜";
    }
}
class VegetarianDishesInTheWetMarketImpl implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "菜市场的素菜";
    }
}
class MarketFactoryImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetMarketImpl();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetMarketImpl();
    }
}
/*超市*/
class MeatDishesFromTheWetSupermarket implements IMeat {
    @Override
    public String getMeatName() {
        return "超市的荤菜";
    }
}
class VegetarianDishesInTheWetSupermarket implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "超市的素菜";
    }
}
class SupermarketImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetSupermarket();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetSupermarket();
    }
}
```

### 生成器

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

生成器模式/建造者模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。

使用Builder是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。

以Markdown转HTML为例，直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：

```markdown
# this is a heading
```

转换成HTML就很简单：

```html
<h1>this is a heading</h1>
```

因此，把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：

- 如果以`#`开头，使用`HeadingBuilder`转换；
- 如果以`>`开头，使用`QuoteBuilder`转换；
- 如果以`---`开头，使用`HrBuilder`转换；
- 其余使用`ParagraphBuilder`转换。

这个`HtmlBuilder`写出来如下：

```java
class HtmlBuilder {
    private HeadingBuilder headingBuilder = new HeadingBuilder();
    private HrBuilder hrBuilder = new HrBuilder();
    private ParagraphBuilder paragraphBuilder = new ParagraphBuilder();
    private QuoteBuilder quoteBuilder = new QuoteBuilder();

    public String toHtml(String markdown) {
        StringBuilder buffer = new StringBuilder();
        String []s=markdown.split("\\s");
        for (String line : s) {
            if (line.startsWith("#")) {
                buffer.append(headingBuilder.buildHeading(line)).append('\n');
            } else if (line.startsWith(">")) {
                buffer.append(quoteBuilder.buildQuote(line)).append('\n');
            } else if (line.startsWith("---")) {
                buffer.append(hrBuilder.buildHr(line)).append('\n');
            } else {
                buffer.append(paragraphBuilder.buildParagraph(line)).append('\n');
            }
        }
        return buffer.toString();
    }
}
```

`HtmlBuilder`并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个`XxxBuilder`去转换，最后，把所有转换的结果组合起来，返回给客户端。

这样一来，只需要针对每一种类型编写不同的Builder。例如，针对以`#`开头的行，需要`HeadingBuilder`：

```java
class HeadingBuilder {
    public String buildHeading(String line) {
        int n = 0;
        while (line.charAt(0) == '#') {
            n++;
            line = line.substring(1);
        }
        return String.format("<h%d>%s</h%d>", n, line.trim(), n);
    }
}
```

可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。

`JavaMail`的`MimeMessage`就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是`MimeMessage`。

很多时候，可以简化Builder模式，以链式调用的方式来创建对象。

```java
StringBuilder builder = new StringBuilder();
builder.append("123").append("456").append("789");
String url = builder.toString();
```

生成器模式旨在通过一步一步构建复杂对象来创建对象。在使用 `JavaBean` 的 `set` 方法构建 `JavaBean` 时，虽然没有明确的构建步骤，但通过设置各个属性来构建对象的过程与生成器模式中逐步构建对象的思想相似。因此，可以将使用 `JavaBean` 的 `set` 方法构建 `JavaBean` 视为一种类似生成器模式的实现方式。

`lombok`有个`@Builder` 可以使对象实现 builder 功能:

```java
public class Main {
    @Test
    void test() {
        A build = A.builder().a("1").b("2").build();
        System.out.println(build);
    }

}
@ToString
@Builder
class A{
    String a,b;
}
```

生成的代码：

```java
class A {
    String a;
    String b;
    A(String a, String b) {
        this.a = a;
        this.b = b;
    }
    public static ABuilder builder() {
        return new ABuilder();
    }
    public String toString() {
        return "A(a=" + this.a + ", b=" + this.b + ")";
    }
    public static class ABuilder {
        private String a;
        private String b;

        ABuilder() {
        }
        public ABuilder a(String a) {
            this.a = a;
            return this;
        }
        public ABuilder b(String b) {
            this.b = b;
            return this;
        }
        public A build() {
            return new A(this.a, this.b);
        }
        public String toString() {
            return "A.ABuilder(a=" + this.a + ", b=" + this.b + ")";
        }
    }
}
```

内部生成器的`toString`会自动生成：

```java
public class Main {
    @Test
    void test() {
        A.ABuilder b = A.builder().a("1").b("2");
        System.out.println(b);//A.ABuilder(a=1, b=2)
    }
}
@Builder
class A{
    String a,b;
}
```

### 原型

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。

我们举个例子：如果我们已经有了一个`String[]`数组，想再创建一个一模一样的`String[]`数组，怎么写？

实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：

```java
// 原型:
String[] original = { "Apple", "Pear", "Banana" };
// 新对象:
String[] copy = Arrays.copyOf(original, original.length);
```

对于普通类，如何实现原型拷贝？Java的`Object`提供了一个`clone()`方法，它的意图就是复制一个新的对象出来，需要实现一个`Cloneable`接口来标识一个对象是“可复制”的：

```java
class Student implements Cloneable {
    private int id;
    private String name;
    private int score;

    // 复制新对象并返回:
    public Object clone() {
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    }
}
```

使用的时候，因为`clone()`的方法签名是定义在`Object`中，返回类型也是`Object`，所以要强制转型，比较麻烦。

```java
Student student = new Student();
Object clone = student.clone();
System.out.println(student);//test.Student@6f4a47c7
System.out.println(clone);//test.Student@ae13544
```

实际上，使用原型模式更好的方式是定义一个`copy()`方法，返回明确的类型：

```java
class Student {
    private int id;
    private String name;
    private int score;

    // 复制新对象并返回:
    public Student copy() {
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    }
}
```

原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。

### 单例

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

因为这个类只有一个实例，因此，自然不能让调用方使用`new ClassName()`来创建实例了。所以，单例的构造方法必须是`private`，这样就防止了调用方自己创建实例。然后可以对外提供一个静态方法，返回一个固定的实例：

```java
public class Singleton {
    // 静态字段引用唯一实例:
    private static final Singleton INSTANCE = new Singleton();

    // 通过静态方法返回实例:
    public static Singleton getInstance() {
        return INSTANCE;
    }
    // private构造方法保证外部无法实例化:
    private Singleton() {}
}
```

```java
System.out.println(Singleton.getInstance());//相同实例
System.out.println(Singleton.getInstance());//相同实例
```

或者直接把静态变量设置为`public`。

单例模式的实现方式很简单：

1. 只有`private`构造方法，确保外部无法实例化；
2. 通过`private static`变量持有唯一实例，保证全局唯一性；
3. 通过`public static`方法返回此唯一实例，使外部调用方能获取到实例。

Java标准库有一些类就是单例，例如`Runtime`这个类：

```java
Runtime runtime = Runtime.getRuntime();
```

#### 延迟加载

即在调用方第一次调用`getInstance()`时才初始化全局唯一实例，类似这样：

```java
public class Singleton {
    private static Singleton INSTANCE = null;

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }

    private Singleton() {
    }
}
```

但这种写法在多线程中是错误的，必须对整个方法进行加锁，但加锁会严重影响并发性能，得不偿失。

------

**双重检查**

```java
class Singleton {
    private static Singleton INSTANCE = null;

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }

    private Singleton() {}
}
```

上述描述似乎已经解决了我们面临的所有问题，但实际上，从 JVM 的角度讲，这些代码仍然可能发生错误。

对于 JVM 而言，它执行的是一个个 Java 指令。在 Java 指令中创建对象和赋值操作是分开进行的，也就是说`INSTANCE= new Singleton();`语句是分两步执行的。但是 JVM 并不保证这两个操作的先后顺序，即指令重排，也就是说有可能 JVM 会为新的 `Singleton` 实例分配空间，然后直接赋值给 `instance` 成员，然后再去初始化这个 `Singleton` 实例。这样就使出错成为了可能。

不过在**JDK 5**以及更高版本扩展了`volatile`的语义，以便系统将不允许`volatile`的写相对于任何之前的读或写重新排序，并且`volatile`的读也不能相对于任何后续的读或写重新排序。

因此，**为`INSTANCE`变量添加`volatile`就修复了这个问题**。

另外，如果`INSTANCE`变量是一个不可变对象，则也不用加`volatile`，就如同`int`和`float`一样，他们的赋值操作是原子的。（[参见](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)）

------

**通过内部类实现**

```java
class Singleton {
    private Singleton() {}
    private static class SingletonContainer{
        private static final Singleton INSTANCE = new Singleton();
    }
    /**
     * 静态内部类只有在被使用时才会装载，静态属性只会在第一次装载时初始化
     */
    public static Singleton getInstance(){
        return SingletonContainer.INSTANCE;
    }
}
```

JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。

这样第一次调用`getInstance`的时候，JVM能够保证`INSTANCE`只被创建一次，并且会保证把赋值给`INSTANCE`的内存初始化完毕。此外该方法也只会在第一次调用的时候使用互斥机制。 

`INSTANCE` 是在第一次加载 `SingletonContainer` 类时被创建的，而 `SingletonContainer` 类则在调用 `getInstance` 方法的时候才会被加载，因此也实现了延迟加载。

要防止通过**反射强行调用私有构造方法**，可以在构造方法添加代码：

```java
private Singleton() {
    if (SingletonContainer.INSTANCE != null) {
        throw new RuntimeException("!");
    }
}
```

反射测试：

```java
Constructor<Singleton> declaredConstructor = Singleton.class.getDeclaredConstructor();
declaredConstructor.setAccessible(true);
Singleton singleton = declaredConstructor.newInstance();//java.lang.RuntimeException: !
System.out.println(singleton);
```

正常调用：

```java
System.out.println(Singleton.getInstance());//test.Singleton@ae13544
System.out.println(Singleton.getInstance());//test.Singleton@ae13544
```

------

####  **序列化破坏单例**

单例对象创建好之后，有时需要将对象序列化然后写入磁盘，在需要时从磁盘中读取对象并加载至内存，反序列化后的对象会重新分配内存，如果序列化的目标对象恰好是单例对象，就会破坏单例模式。

```java
public class Main {
    @Test
    void test() throws IOException,ClassNotFoundException {
        Singleton s1 = Singleton.getInstance();

        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(s1);
            }
        }
        Singleton s2;
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                s2= (Singleton) ois.readObject();
            }
        }
        System.out.println(s1);//test.Singleton@7494f96a
        System.out.println(s2);//test.Singleton@37883b97
    }

}
class Singleton implements Serializable {
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
}
```

添加一个`readResolve()`,就能保证反序列化是同一个实例了

```java
class Singleton implements Serializable {
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
    private Object readResolve(){
        return INSTANCE;
    }
}
```

在 Java 的序列化中，当对象被序列化时，如果类中定义了 `readResolve` 方法，并且该方法返回一个对象，那么在反序列化时**会调用该方法来获取对象**，而**不是通过从流中反序列化创建一个新的对象**。

这意味着 `readResolve()` 方法可以用来控制反序列化过程中返回的对象，**可以在方法中返回任何想要的对象，而不受反序列化的影响**。如果一个类写了 `readResolve()` 方法，并且在方法中返回了特定的对象，那么反序列化过程**就会返回这个方法中指定的对象**，而**不会**从文件中重新构造对象。也因此这会忽略保存在文件的全部序列化数据！示例：

```java
public class Main {
    @Test
    void test1() throws IOException {
        Singleton s1 = Singleton.getInstance();
        s1.name="序列化前";

        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(s1);
            }
        }
        System.out.println(s1);//test.Singleton@561b6512
        System.out.println(s1.name);//序列化前

    }
    @Test
    void test2() throws IOException,ClassNotFoundException {
        Singleton s2;
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                s2= (Singleton) ois.readObject();
            }
        }
        System.out.println(s2);//test.Singleton@c86b9e3
        System.out.println(s2.name);//null
    }

}
class Singleton implements Serializable {
    public String name;

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
    private Object readResolve(){
        return INSTANCE;
    }
}
```

先运行`test1()`,然后等JVM关闭后重新运行`test2()`,模拟序列化的实际运用场景，这个场景下内存地址肯定不一样，但后设置的`name`值也丢了。

实际上，`readResolve()` 方法的作用是控制对象的反序列化过程，可以用来确保反序列化后的对象符合特定的要求，或者实现单例模式等。

------

那么我们保存的`s.obj`序列化文件就这么废了吗？也不一定，**序列化仅涉及对象的状态（即实例变量）**，不包括类的方法。序列化的主要目的是保存对象的状态，以便在稍后可以将其完全恢复为原始状态。把`readResolve()` 方法注释掉不就好了。

示例：

```java
public class Main {
    @Test
    void test1() throws IOException {
        Singleton s1 = Singleton.getInstance();
        s1.name="序列化前";

        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(s1);
            }
        }
        System.out.println(s1);//Singleton{name='序列化前'}
        System.out.println(s1.name);//序列化前

    }
}
class Singleton implements Serializable {
    public String name;
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
    private Object readResolve(){
        return INSTANCE;
    }
    @Override
    public String toString() {
        return "Singleton{name='" + name + '\'' + '}';
    }
}
```

运行`test1()`生成`s.obj`。删除`readResolve`，`运行test2()`：

```java
public class Main {
    @Test
    void test2() throws IOException,ClassNotFoundException {
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                Object x = ois.readObject();
                System.out.println(x);//Singleton{name='序列化前'}
                System.out.println(((Singleton) x).name);//序列化前
            }
        }

    }

}
class Singleton implements Serializable {
    public String name;

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }

    @Override
    public String toString() {
        return "Singleton{name='" + name + '\'' + '}';
    }
}
```

正常恢复，没有问题，那么试试删除`public String toString()`，提示：

```text
java.io.InvalidClassException: test.Singleton; local class incompatible: stream classdesc serialVersionUID = 5155019565252345970, local class serialVersionUID = -6864115338217441473
```

改动太大了，改变了`serialVersionUID`，那么显示的在类里指定：

```java
class Singleton implements Serializable {
    private static final long serialVersionUID = 5155019565252345970L;
    public String name;

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
}
```

再运行`test2()`,正常反序列化，只是这次`toString`没有了：

```text
test.Singleton@79d8407f
序列化前
```

实际上，非重写的方法可以随便添加修改删除，而重写的方法不能动，动了就会导致`serialVersionUID`编号。（显示指定`serialVersionUID`编号就好了）

------

**使用枚举**

Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：

```java
public enum World {
    // 唯一枚举:
	INSTANCE;

	private String name = "world";

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
```

枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个`World`类在调用方看来就可以这么用：

```java
String name = World.INSTANCE.getName();
```

使用枚举实现Singleton也避免了即序列化和反序列化会绕过普通类的`private`构造方法从而创建出多个实例，而枚举类就没有这个问题。

枚举在序列化和反序列化过程中**会丢失枚举常量中的普通字段的值**。这是因为枚举在序列化时只保留了枚举常量的名称，并没有保存其他字段的状态。在反序列化时，只会根据枚举常量的名称重新构建枚举常量，而普通字段的值需要在程序中重新设置。即：

```java
public class Main {
    @Test
    void test1() throws IOException {
        World.INSTANCE.setName("序列化前");
        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(World.INSTANCE);
            }
        }
        System.out.println(World.INSTANCE);//World{name='序列化前'}
        System.out.println(World.INSTANCE.getName());//序列化前
    }
    @Test
    void test2() throws IOException,ClassNotFoundException {
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                World x = (World) ois.readObject();
                System.out.println(x);//World{name='null'}
                System.out.println(x.getName());//null
            }
        }

    }

}
enum World implements Serializable {
    // 唯一枚举:
    INSTANCE;
    private String name;
    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "World{name='" + name + '\'' + '}';
    }
}
```

用有参构造器设置就好了，虽然并没有改变问题的根本，也是个曲线的好办法。

```java
public class Main {
    @Test
    void test1() throws IOException {
        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(World.INSTANCE);
            }
        }
        System.out.println(World.INSTANCE);//World{name='序列化前'}
        System.out.println(World.INSTANCE.getName());//序列化前

    }
    @Test
    void test2() throws IOException,ClassNotFoundException {
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                World x = (World) ois.readObject();
                System.out.println(x);//World{name='null'}
                System.out.println(x.getName());//null
            }
        }

    }
}
enum World implements Serializable {
    // 唯一枚举:
    INSTANCE("序列化前");

    private String name;

    World(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "World{name='" + name + '\'' + '}';
    }
}
```

而枚举天然就不能使用反射调用：

```java
Constructor<World> declaredConstructor = World.class.getDeclaredConstructor(String.class);
declaredConstructor.setAccessible(true);
World world = declaredConstructor.newInstance("test");//java.lang.NoSuchMethodException: test.World.<init>(java.lang.String)
System.out.println(world);
```

找不到指定类型的构造方法，看看`java.lang.Enum`的源码，只有：

```java
protected Enum(String name, int ordinal) {
    this.name = name;
    this.ordinal = ordinal;
}
```

唯一构造函数。程序员无法调用此构造函数。它供编译器发出的代码使用，以响应枚举类型声明。形参:

- `name` – - 此枚举常量的名称，它是用于声明它的标识符。 
- `ordinal` – - 此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）

那么改成这样：

```java
Constructor<World> declaredConstructor = World.class.getDeclaredConstructor(String.class,int.class,String.class);
declaredConstructor.setAccessible(true);
World world = declaredConstructor.newInstance("枚举名",1,"test");//java.lang.IllegalArgumentException: Cannot reflectively create enum objects
System.out.println(world);
```

异常位置：

```java
@CallerSensitive
@ForceInline // to ensure Reflection.getCallerClass optimization
public T newInstance(Object ... initargs)
    throws InstantiationException, IllegalAccessException,
           IllegalArgumentException, InvocationTargetException
{
    if (!override) {
        Class<?> caller = Reflection.getCallerClass();
        checkAccess(caller, clazz, clazz, modifiers);
    }
    if ((clazz.getModifiers() & Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
```

------

什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是`new`操作符：

```java
@Component // 表示一个单例组件
public class MyService {
    ...
}
```

因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。



## 结构型模式





## 行为型模式







































