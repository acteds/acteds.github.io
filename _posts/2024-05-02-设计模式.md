---
layout: post
title: 设计模式
categories: Java
description: Java笔记
keywords: Java
---
# 引言
设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。

# 设计模式

软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的。23个常用模式分为创建型模式、结构型模式和行为型模式三类，基于以下几个原则：

**开闭原则**

软件应该对扩展开放，而对修改关闭。在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。

**单一职责原则**

一个类只负责一项职责。针对一个类，其承担的职责越多，被复用的可能性就越小。如果类承担的职责很多，就意味着这些职责耦合在了一起。

**里氏替换原则**

如果调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。

**接口隔离原则**

- 客户需要什么样的接口，就提供什么样的接口，不需要的就删除掉；
- 类之间的依赖关系应建立在最小的接口上。也就是说，接口中的方法要尽量的少，接口功能要尽量的细分。

 **依赖倒置原则**

依赖倒转原则就是要依赖于抽象，不要依赖于实现。高层模块不依赖于底层模块，二者都依赖其抽象；抽象不依赖于细节，细节应该依赖抽象。

也就是说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等，而不是用具体类。**一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法**。特例：对象的创建过程是违背“开—闭”原则以及依赖倒转原则的，但通过工厂模式，能很好地解决对象创建过程中的依赖倒转问题。

**迪米特原则**

又称为最少知识原则，**一个软件实体应当尽可能少地与其他实体发生相互作用。**

如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。

在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；

在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。

**组合/聚合复用原则**

简单的说是，尽量使用对象的组合/聚合，而不是继承来达到复用的目的。

组合和聚合都是对象建模中关联关系的一种。聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。

组合/聚合和继承是实现代码复用的两种基本途径，在设计过程中尽量使用组合/聚合，而不是继承。因为继承使得基类与子类有较强的耦合性，通常情况下基类的内部细节对子类来说是可见的，这样基类的实现细节会暴露给子类，破坏了系统的封装性。

开闭原则是所有面向对象原则的核心；里式替换原则是实现开闭原则的重要方式之一；依赖倒置原则是系统抽象化的具体实现，其是面向对象设计的主要实现机制之一；接口隔离原则要求接口的方法尽量少，接口尽量细化；迪米特原则降低系统的耦合度，其使得一个模块的修改尽量少的影响其他模块，扩展会相对容易；尽量使用组合/聚合而不是继承达到代码复用的目的。

## 创建型模式

创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。

常见的创建型模式：

- **工厂方法模式（Factory Method Pattern）**：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。
- **抽象工厂模式（Abstract Factory Pattern）**：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
- **建造者模式（Builder Pattern）**：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
- **原型模式（Prototype Pattern）**：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
- **单例模式（Singleton Pattern）**：确保一个类只有一个实例，并提供一个全局访问点。

### 工厂方法

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

工厂方法即Factory Method，是一种对象创建型模式。

工厂方法的目的是使得**创建对象**和**使用对象**是**分离**的，并且客户端**总是引用抽象工厂和抽象产品**：

```ascii
┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │<─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
```

实现一个解析`字符串`为`Number`的`Factory`，可以定义如下：

```java
public interface NumberFactory {
    Number parse(String s);
}
```

有了工厂接口，再编写一个工厂的实现类：

```java
public class NumberFactoryImpl implements NumberFactory {
    public Number parse(String s) {
        return new BigDecimal(s);
    }
}
```

产品接口是`Number`，`NumberFactoryImpl`返回的实际产品是`BigDecimal`。

通常会在接口`Factory`中再定义一个静态方法`getFactory()`来返回真正的子类（在 **Java 8** 中，接口可以包含静态方法）：

```java
public interface NumberFactory {
    // 创建方法:
    Number parse(String s);
    // 获取工厂实例:
    static NumberFactory getFactory() {
        return impl;
    }
    static NumberFactory impl = new NumberFactoryImpl();
}
```

在客户端中，只需要和工厂接口`NumberFactory`以及抽象产品`Number`打交道：

```java
NumberFactory factory = NumberFactory.getFactory();
Number result = factory.parse("123.456");
```

调用方可以完全忽略真正的工厂`NumberFactoryImpl`和实际的产品`BigDecimal`，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。

------

实际上，大多数情况下并不需要抽象工厂，而是通过静态方法直接返回产品，即：

```java
public class NumberFactory {
    public static Number parse(String s) {
        return new BigDecimal(s);
    }
}
```

这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。

静态工厂方法广泛地应用在Java标准库中。例如：

```java
Integer n = Integer.valueOf(100);
```

`Integer`既是产品又是静态工厂，它提供了静态方法`valueOf()`来创建`Integer`。

```java
public final class Integer {
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
    ...
}
```

`valueOf()`内部可能会使用`new`创建一个新的`Integer`实例，但也可能直接返回一个缓存的`Integer`实例。对于调用方来说，没必要知道`Integer`创建的细节。

 工厂方法可以**隐藏创建产品的细节**，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。

如果调用方直接使用`Integer n = new Integer(100)`，那么就失去了使用缓存优化的可能性。

------

经常使用的另一个静态工厂方法是`List.of()`：

```java
List<String> list = List.of("A", "B", "C");
```

这个静态工厂方法接收可变参数，然后返回`List`接口。需要注意的是，调用方获取的产品总是`List`接口，而且并不关心它的实际类型。

即使调用方知道`List`产品的实际类型是`java.util.ImmutableCollections$ListN`，也不要去强制转型为子类，因为静态工厂方法`List.of()`保证返回`List`，但也完全可以修改为返回`java.util.ArrayList`。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。

 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。

------

和`List.of()`类似，使用`MessageDigest`时，为了创建某个摘要算法，总是使用静态工厂方法`getInstance(String)`：

```java
MessageDigest md5 = MessageDigest.getInstance("MD5");
MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
```

调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是`MessageDigest`这个抽象类。

### 抽象工厂

> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。

抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，工厂是抽象的，产品也是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：

```ascii
                                ┌────────┐
                             ─ >│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─>│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ >│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ >│ProductA1│  ─ >│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─>│ProductB1│ └ ─>│ProductB2│
               └─────────┘     └─────────┘
```

这种模式有点类似于多个供应商负责提供一系列类型的产品。

假设希望为用户提供一个可以买荤素菜的环境，定义接口：

```java
interface ImeatAndVegetarianFactory {
    IMeat buyMeatDishes();
    IVegetarian buyVegetarianDishes();
}
interface IMeat {
    String getMeatName();
}
interface IVegetarian {
    String getVegetarianName();
}
```

定义了抽象工厂（`ImeatAndVegetarianFactory`）以及两个抽象产品（`IMeat`和`IVegetarian`）。假设环境可以是超市也可以是菜市场，先写菜市场：

```java
/*菜市场*/
class MeatDishesFromTheWetMarketImpl implements IMeat {
    @Override
    public String getMeatName() {
        return "菜市场的荤菜";
    }
}
class VegetarianDishesInTheWetMarketImpl implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "菜市场的素菜";
    }
}
class MarketFactoryImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetMarketImpl();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetMarketImpl();
    }
}
```

然后就可以使用了：

```java
meatAndVegetarianFactory f=new MarketFactoryImpl();//菜市场
IMeat IMeat = f.buyMeatDishes();
System.out.println(IMeat.getMeatName());//菜市场的荤菜
IVegetarian IVegetarian = f.buyVegetarianDishes();
System.out.println(IVegetarian.getVegetarianName());//菜市场的素菜
```

看起来似乎也没什么特别的作用。

再写超市：

```java
class MeatDishesFromTheWetSupermarket implements IMeat {
    @Override
    public String getMeatName() {
        return "超市的荤菜";
    }
}
class VegetarianDishesInTheWetSupermarket implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "超市的素菜";
    }
}
class SupermarketImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetSupermarket();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetSupermarket();
    }
}
```

要使用，则只需要改动一下初始化的工厂就行了：即把`new MarketFactoryImpl();`改成`new SupermarketImpl();`。这下作用比较明显了。

还可以把这行也隐藏起来，这样用户就完全不会接触到具体实现了：

```java
public class Main {
    @Test
    void test() {
        ImeatAndVegetarianFactory f= ImeatAndVegetarianFactory.createFactory("超市");
        IMeat IMeat = f.buyMeatDishes();
        System.out.println(IMeat.getMeatName());
        IVegetarian IVegetarian = f.buyVegetarianDishes();
        System.out.println(IVegetarian.getVegetarianName());
    }
}
interface ImeatAndVegetarianFactory {
    IMeat buyMeatDishes();
    IVegetarian buyVegetarianDishes();
    static ImeatAndVegetarianFactory createFactory(String name){
        if (name.equals("超市")) {
            return new SupermarketImpl();
        }else if (name.equals("菜市场")){
            return new MarketFactoryImpl();
        }
        throw new RuntimeException("未定义");
    }
}
```

抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；

抽象工厂模式实现的关键点是**定义工厂接口和产品接口**，但如何实现工厂与产品本身需要留给具体的子类实现，**客户端只和抽象工厂与抽象产品打交道**。

------

完整代码：

```java
package test;
import org.junit.jupiter.api.Test;


public class Main {
    @Test
    void test() {
        ImeatAndVegetarianFactory f= ImeatAndVegetarianFactory.createFactory("超市");
        test(f);
        f=ImeatAndVegetarianFactory.createFactory("菜市场");
        test(f);
    }

    private static void test(ImeatAndVegetarianFactory f) {
        IMeat IMeat = f.buyMeatDishes();
        System.out.println(IMeat.getMeatName());
        IVegetarian IVegetarian = f.buyVegetarianDishes();
        System.out.println(IVegetarian.getVegetarianName());
    }
}
interface ImeatAndVegetarianFactory {
    IMeat buyMeatDishes();
    IVegetarian buyVegetarianDishes();
    static ImeatAndVegetarianFactory createFactory(String name){
        if (name.equals("超市")) {
            return new SupermarketImpl();
        }else if (name.equals("菜市场")){
            return new MarketFactoryImpl();
        }
        throw new RuntimeException("未定义");
    }
}
interface IMeat {
    String getMeatName();
}
interface IVegetarian {
    String getVegetarianName();
}
/*菜市场*/
class MeatDishesFromTheWetMarketImpl implements IMeat {
    @Override
    public String getMeatName() {
        return "菜市场的荤菜";
    }
}
class VegetarianDishesInTheWetMarketImpl implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "菜市场的素菜";
    }
}
class MarketFactoryImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetMarketImpl();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetMarketImpl();
    }
}
/*超市*/
class MeatDishesFromTheWetSupermarket implements IMeat {
    @Override
    public String getMeatName() {
        return "超市的荤菜";
    }
}
class VegetarianDishesInTheWetSupermarket implements IVegetarian {
    @Override
    public String getVegetarianName() {
        return "超市的素菜";
    }
}
class SupermarketImpl implements ImeatAndVegetarianFactory {
    @Override
    public IMeat buyMeatDishes() {
        return new MeatDishesFromTheWetSupermarket();
    }
    @Override
    public IVegetarian buyVegetarianDishes() {
        return new VegetarianDishesInTheWetSupermarket();
    }
}
```

### 生成器

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

生成器模式/建造者模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。

使用Builder是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。

以Markdown转HTML为例，直接编写一个完整的转换器比较困难，但如果针对类似下面的**一行**文本：

```markdown
# this is a heading
```

转换成HTML就很简单：

```html
<h1>this is a heading</h1>
```

因此，把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：

- 如果以`#`开头，使用`HeadingBuilder`转换；
- 如果以`>`开头，使用`QuoteBuilder`转换；
- 如果以`---`开头，使用`HrBuilder`转换；
- 其余使用`ParagraphBuilder`转换。

这个`HtmlBuilder`写出来如下：

```java
class HtmlBuilder {
    private HeadingBuilder headingBuilder = new HeadingBuilder();
    private HrBuilder hrBuilder = new HrBuilder();
    private ParagraphBuilder paragraphBuilder = new ParagraphBuilder();
    private QuoteBuilder quoteBuilder = new QuoteBuilder();

    public String toHtml(String markdown) {
        StringBuilder buffer = new StringBuilder();
        String []s=markdown.split("\\s");
        for (String line : s) {
            if (line.startsWith("#")) {
                buffer.append(headingBuilder.buildHeading(line)).append('\n');
            } else if (line.startsWith(">")) {
                buffer.append(quoteBuilder.buildQuote(line)).append('\n');
            } else if (line.startsWith("---")) {
                buffer.append(hrBuilder.buildHr(line)).append('\n');
            } else {
                buffer.append(paragraphBuilder.buildParagraph(line)).append('\n');
            }
        }
        return buffer.toString();
    }
}
```

`HtmlBuilder`并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个`XxxBuilder`去转换，最后，把所有转换的结果组合起来，返回给客户端。

这样一来，只需要针对每一种类型编写不同的Builder。例如，针对以`#`开头的行，需要`HeadingBuilder`：

```java
class HeadingBuilder {
    public String buildHeading(String line) {
        int n = 0;
        while (line.charAt(0) == '#') {
            n++;
            line = line.substring(1);
        }
        return String.format("<h%d>%s</h%d>", n, line.trim(), n);
    }
}
```

可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。

`JavaMail`的`MimeMessage`就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是`MimeMessage`。

很多时候，可以简化Builder模式，以链式调用的方式来创建对象。

```java
StringBuilder builder = new StringBuilder();
builder.append("123").append("456").append("789");
String url = builder.toString();
```

生成器模式旨在通过一步一步构建复杂对象来创建对象。在使用 `JavaBean` 的 `set` 方法构建 `JavaBean` 时，虽然没有明确的构建步骤，但通过设置各个属性来构建对象的过程与生成器模式中逐步构建对象的思想相似。因此，可以将使用 `JavaBean` 的 `set` 方法构建 `JavaBean` 视为一种类似生成器模式的实现方式。

`lombok`有个`@Builder` 可以使对象实现 builder 功能:

```java
public class Main {
    @Test
    void test() {
        A build = A.builder().a("1").b("2").build();
        System.out.println(build);
    }

}
@ToString
@Builder
class A{
    String a,b;
}
```

生成的代码：

```java
class A {
    String a;
    String b;
    A(String a, String b) {
        this.a = a;
        this.b = b;
    }
    public static ABuilder builder() {
        return new ABuilder();
    }
    public String toString() {
        return "A(a=" + this.a + ", b=" + this.b + ")";
    }
    public static class ABuilder {
        private String a;
        private String b;

        ABuilder() {
        }
        public ABuilder a(String a) {
            this.a = a;
            return this;
        }
        public ABuilder b(String b) {
            this.b = b;
            return this;
        }
        public A build() {
            return new A(this.a, this.b);
        }
        public String toString() {
            return "A.ABuilder(a=" + this.a + ", b=" + this.b + ")";
        }
    }
}
```

内部生成器的`toString`会自动生成：

```java
public class Main {
    @Test
    void test() {
        A.ABuilder b = A.builder().a("1").b("2");
        System.out.println(b);//A.ABuilder(a=1, b=2)
    }
}
@Builder
class A{
    String a,b;
}
```

### 原型

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。

我们举个例子：如果我们已经有了一个`String[]`数组，想再创建一个一模一样的`String[]`数组，怎么写？

实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：

```java
// 原型:
String[] original = { "Apple", "Pear", "Banana" };
// 新对象:
String[] copy = Arrays.copyOf(original, original.length);
```

对于普通类，如何实现原型拷贝？Java的`Object`提供了一个`clone()`方法，它的意图就是复制一个新的对象出来，需要实现一个`Cloneable`接口来标识一个对象是“可复制”的：

```java
class Student implements Cloneable {
    private int id;
    private String name;
    private int score;

    // 复制新对象并返回:
    public Object clone() {
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    }
}
```

使用的时候，因为`clone()`的方法签名是定义在`Object`中，返回类型也是`Object`，所以要强制转型，比较麻烦。

```java
Student student = new Student();
Object clone = student.clone();
System.out.println(student);//test.Student@6f4a47c7
System.out.println(clone);//test.Student@ae13544
```

实际上，使用原型模式更好的方式是定义一个`copy()`方法，返回明确的类型：

```java
class Student {
    private int id;
    private String name;
    private int score;

    // 复制新对象并返回:
    public Student copy() {
        Student std = new Student();
        std.id = this.id;
        std.name = this.name;
        std.score = this.score;
        return std;
    }
}
```

原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。

### 单例

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

因为这个类只有一个实例，因此，自然不能让调用方使用`new ClassName()`来创建实例了。所以，单例的构造方法必须是`private`，这样就防止了调用方自己创建实例。然后可以对外提供一个静态方法，返回一个固定的实例：

```java
public class Singleton {
    // 静态字段引用唯一实例:
    private static final Singleton INSTANCE = new Singleton();

    // 通过静态方法返回实例:
    public static Singleton getInstance() {
        return INSTANCE;
    }
    // private构造方法保证外部无法实例化:
    private Singleton() {}
}
```

```java
System.out.println(Singleton.getInstance());//相同实例
System.out.println(Singleton.getInstance());//相同实例
```

或者直接把静态变量设置为`public`。

单例模式的实现方式很简单：

1. 只有`private`构造方法，确保外部无法实例化；
2. 通过`private static`变量持有唯一实例，保证全局唯一性；
3. 通过`public static`方法返回此唯一实例，使外部调用方能获取到实例。

Java标准库有一些类就是单例，例如`Runtime`这个类：

```java
Runtime runtime = Runtime.getRuntime();
```

#### 延迟加载

即在调用方第一次调用`getInstance()`时才初始化全局唯一实例，类似这样：

```java
public class Singleton {
    private static Singleton INSTANCE = null;

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE;
    }

    private Singleton() {
    }
}
```

但这种写法在多线程中是错误的，必须对整个方法进行加锁，但加锁会严重影响并发性能，得不偿失。

------

##### 双重检查

```java
class Singleton {
    private static Singleton INSTANCE = null;

    public static Singleton getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }

    private Singleton() {}
}
```

上述描述似乎已经解决了我们面临的所有问题，但实际上，从 JVM 的角度讲，这些代码仍然可能发生错误。

对于 JVM 而言，它执行的是一个个 Java 指令。在 Java 指令中创建对象和赋值操作是分开进行的，也就是说`INSTANCE= new Singleton();`语句是分两步执行的。但是 JVM 并不保证这两个操作的先后顺序，即指令重排，也就是说有可能 JVM 会为新的 `Singleton` 实例分配空间，然后直接赋值给 `instance` 成员，然后再去初始化这个 `Singleton` 实例。这样就使出错成为了可能。

不过在**JDK 5**以及更高版本扩展了`volatile`的语义，以便系统将不允许`volatile`的写相对于任何之前的读或写重新排序，并且`volatile`的读也不能相对于任何后续的读或写重新排序。

因此，**为`INSTANCE`变量添加`volatile`就修复了这个问题**。

另外，如果`INSTANCE`变量是一个不可变对象，则也不用加`volatile`，就如同`int`和`float`一样，他们的赋值操作是原子的。（[参见](http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html)）

------

##### 通过内部类实现

```java
class Singleton {
    private Singleton() {}
    private static class SingletonContainer{
        private static final Singleton INSTANCE = new Singleton();
    }
    /**
     * 静态内部类只有在被使用时才会装载，静态属性只会在第一次装载时初始化
     */
    public static Singleton getInstance(){
        return SingletonContainer.INSTANCE;
    }
}
```

JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。

这样第一次调用`getInstance`的时候，JVM能够保证`INSTANCE`只被创建一次，并且会保证把赋值给`INSTANCE`的内存初始化完毕。此外该方法也只会在第一次调用的时候使用互斥机制。 

`INSTANCE` 是在第一次加载 `SingletonContainer` 类时被创建的，而 `SingletonContainer` 类则在调用 `getInstance` 方法的时候才会被加载，因此也实现了延迟加载。

------

要防止通过**反射强行调用私有构造方法**，可以在构造方法添加代码：

```java
private Singleton() {
    if (SingletonContainer.INSTANCE != null) {
        throw new RuntimeException("!");
    }
}
```

反射测试：

```java
Constructor<Singleton> declaredConstructor = Singleton.class.getDeclaredConstructor();
declaredConstructor.setAccessible(true);
Singleton singleton = declaredConstructor.newInstance();//java.lang.RuntimeException: !
System.out.println(singleton);
```

正常调用：

```java
System.out.println(Singleton.getInstance());//test.Singleton@ae13544
System.out.println(Singleton.getInstance());//test.Singleton@ae13544
```

------

####  序列化破坏单例

单例对象创建好之后，有时需要将对象序列化然后写入磁盘，在需要时从磁盘中读取对象并加载至内存，反序列化后的对象会重新分配内存，如果序列化的目标对象恰好是单例对象，就会破坏单例模式。

```java
public class Main {
    @Test
    void test() throws IOException,ClassNotFoundException {
        Singleton s1 = Singleton.getInstance();

        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(s1);
            }
        }
        Singleton s2;
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                s2= (Singleton) ois.readObject();
            }
        }
        System.out.println(s1);//test.Singleton@7494f96a
        System.out.println(s2);//test.Singleton@37883b97
    }

}
class Singleton implements Serializable {
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
}
```

添加一个`readResolve()`,就能保证反序列化是同一个实例了

```java
class Singleton implements Serializable {
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
    private Object readResolve(){
        return INSTANCE;
    }
}
```

在 Java 的序列化中，当对象被序列化时，如果类中定义了 `readResolve` 方法，并且该方法返回一个对象，那么在反序列化时**会调用该方法来获取对象**，而**不是通过从流中反序列化创建一个新的对象**。

这意味着 `readResolve()` 方法可以用来控制反序列化过程中返回的对象，**可以在方法中返回任何想要的对象，而不受反序列化的影响**。如果一个类写了 `readResolve()` 方法，并且在方法中返回了特定的对象，那么反序列化过程**就会返回这个方法中指定的对象**，而**不会**从文件中重新构造对象。示例：

```java
public class Main {
    @Test
    void test1() throws IOException {
        Singleton s1 = Singleton.getInstance();
        s1.name="序列化前";

        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(s1);
            }
        }
        System.out.println(s1);//test.Singleton@561b6512
        System.out.println(s1.name);//序列化前

    }
    @Test
    void test2() throws IOException,ClassNotFoundException {
        Singleton s2;
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                s2= (Singleton) ois.readObject();
            }
        }
        System.out.println(s2);//test.Singleton@c86b9e3
        System.out.println(s2.name);//null
    }

}
class Singleton implements Serializable {
    public String name;

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
    private Object readResolve(){
        return INSTANCE;
    }
}
```

先运行`test1()`,然后等JVM关闭后重新运行`test2()`,模拟序列化的实际运用场景，这个场景下内存地址肯定不一样，但后设置的`name`值也丢了。

实际上，`readResolve()` 方法的作用是控制对象的反序列化过程，可以用来确保反序列化后的对象符合特定的要求，或者实现单例模式等。

------

那么我们保存的`s.obj`序列化文件就这么废了吗？也不一定，**序列化仅涉及对象的状态（即实例变量）**，不包括类的方法。序列化的主要目的是保存对象的状态，以便在稍后可以将其完全恢复为原始状态。把`readResolve()` 方法注释掉不就好了。

示例：

```java
public class Main {
    @Test
    void test1() throws IOException {
        Singleton s1 = Singleton.getInstance();
        s1.name="序列化前";

        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(s1);
            }
        }
        System.out.println(s1);//Singleton{name='序列化前'}
        System.out.println(s1.name);//序列化前

    }
}
class Singleton implements Serializable {
    public String name;
    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
    private Object readResolve(){
        return INSTANCE;
    }
    @Override
    public String toString() {
        return "Singleton{name='" + name + '\'' + '}';
    }
}
```

运行`test1()`生成`s.obj`。删除`readResolve`，`运行test2()`：

```java
public class Main {
    @Test
    void test2() throws IOException,ClassNotFoundException {
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                Object x = ois.readObject();
                System.out.println(x);//Singleton{name='序列化前'}
                System.out.println(((Singleton) x).name);//序列化前
            }
        }

    }

}
class Singleton implements Serializable {
    public String name;

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }

    @Override
    public String toString() {
        return "Singleton{name='" + name + '\'' + '}';
    }
}
```

正常恢复，没有问题，那么试试删除`public String toString()`，提示：

```text
java.io.InvalidClassException: test.Singleton; local class incompatible: stream classdesc serialVersionUID = 5155019565252345970, local class serialVersionUID = -6864115338217441473
```

改动太大了，改变了`serialVersionUID`，那么显示的在类里指定：

```java
class Singleton implements Serializable {
    private static final long serialVersionUID = 5155019565252345970L;
    public String name;

    private static final Singleton INSTANCE = new Singleton();
    public static Singleton getInstance() {
        return INSTANCE;
    }
    private Singleton() {
    }
}
```

再运行`test2()`,正常反序列化，只是这次`toString`没有了：

```text
test.Singleton@79d8407f
序列化前
```

实际上，非重写的方法可以随便添加修改删除，而重写的方法不能动，动了就会导致`serialVersionUID`编号。（显示指定`serialVersionUID`编号就好了）

------

#### 使用枚举

Java保证枚举类的每个枚举都是单例，所以只需要编写一个只有一个枚举的类即可：

```java
public enum World {
    // 唯一枚举:
	INSTANCE;

	private String name = "world";

	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
```

枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个`World`类在调用方看来就可以这么用：

```java
String name = World.INSTANCE.getName();
```

使用枚举实现Singleton也避免了即序列化和反序列化会绕过普通类的`private`构造方法从而创建出多个实例，而枚举类就没有这个问题。

枚举在序列化和反序列化过程中**会丢失枚举常量中的普通字段的值**。这是因为枚举在序列化时只保留了枚举常量的名称，并没有保存其他字段的状态。在反序列化时，只会根据枚举常量的名称重新构建枚举常量，而普通字段的值需要在程序中重新设置。即：

```java
public class Main {
    @Test
    void test1() throws IOException {
        World.INSTANCE.setName("序列化前");
        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(World.INSTANCE);
            }
        }
        System.out.println(World.INSTANCE);//World{name='序列化前'}
        System.out.println(World.INSTANCE.getName());//序列化前
    }
    @Test
    void test2() throws IOException,ClassNotFoundException {
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                World x = (World) ois.readObject();
                System.out.println(x);//World{name='null'}
                System.out.println(x.getName());//null
            }
        }

    }

}
enum World implements Serializable {
    // 唯一枚举:
    INSTANCE;
    private String name;
    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "World{name='" + name + '\'' + '}';
    }
}
```

用有参构造器设置就好了，虽然并没有改变问题的根本，也是个曲线的好办法。

```java
public class Main {
    @Test
    void test1() throws IOException {
        try(FileOutputStream f = new FileOutputStream("s.obj")){
            try(ObjectOutputStream oos=new ObjectOutputStream(f)){
                oos.writeObject(World.INSTANCE);
            }
        }
        System.out.println(World.INSTANCE);//World{name='序列化前'}
        System.out.println(World.INSTANCE.getName());//序列化前

    }
    @Test
    void test2() throws IOException,ClassNotFoundException {
        try(FileInputStream fis=new FileInputStream("s.obj")){
            try(ObjectInputStream ois=new ObjectInputStream(fis)){
                World x = (World) ois.readObject();
                System.out.println(x);//World{name='null'}
                System.out.println(x.getName());//null
            }
        }

    }
}
enum World implements Serializable {
    // 唯一枚举:
    INSTANCE("序列化前");

    private String name;

    World(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "World{name='" + name + '\'' + '}';
    }
}
```

而枚举天然就不能使用反射调用：

```java
Constructor<World> declaredConstructor = World.class.getDeclaredConstructor(String.class);
declaredConstructor.setAccessible(true);
World world = declaredConstructor.newInstance("test");//java.lang.NoSuchMethodException: test.World.<init>(java.lang.String)
System.out.println(world);
```

找不到指定类型的构造方法，看看`java.lang.Enum`的源码，只有：

```java
protected Enum(String name, int ordinal) {
    this.name = name;
    this.ordinal = ordinal;
}
```

唯一构造函数。程序员无法调用此构造函数。它供编译器发出的代码使用，以响应枚举类型声明。形参:

- `name` – - 此枚举常量的名称，它是用于声明它的标识符。 
- `ordinal` – - 此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）

那么改成这样：

```java
Constructor<World> declaredConstructor = World.class.getDeclaredConstructor(String.class,int.class,String.class);
declaredConstructor.setAccessible(true);
World world = declaredConstructor.newInstance("枚举名",1,"test");//java.lang.IllegalArgumentException: Cannot reflectively create enum objects
System.out.println(world);
```

异常位置：

```java
@CallerSensitive
@ForceInline // to ensure Reflection.getCallerClass optimization
public T newInstance(Object ... initargs)
    throws InstantiationException, IllegalAccessException,
           IllegalArgumentException, InvocationTargetException
{
    if (!override) {
        Class<?> caller = Reflection.getCallerClass();
        checkAccess(caller, clazz, clazz, modifiers);
    }
    if ((clazz.getModifiers() & Modifier.ENUM) != 0)
        throw new IllegalArgumentException("Cannot reflectively create enum objects");
    ConstructorAccessor ca = constructorAccessor;   // read volatile
    if (ca == null) {
        ca = acquireConstructorAccessor();
    }
    @SuppressWarnings("unchecked")
    T inst = (T) ca.newInstance(initargs);
    return inst;
}
```

------

什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是`new`操作符：

```java
@Component // 表示一个单例组件
public class MyService {
    ...
}
```

因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。



## 结构型模式

结构型模式主要关注如何组合不同的对象以获得更好、更灵活的结构。尽管面向对象的继承机制提供了基本的子类扩展父类功能的能力，但结构型模式不仅限于简单的继承，而更多地通过组合和运行时的动态组合来实现更灵活的功能。

主要关注如何组合类或对象以获得更大的结构，并且提供了一种方式来定义类之间的关系，以确保系统的某一部分变化不会影响其他部分。

结构型模式包括以下几种常见的模式：

1. **适配器模式（Adapter Pattern）**：将一个类的接口**转换**成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
2. **桥接模式（Bridge Pattern）**：将抽象部分与它的实现部分**分离**，使它们可以独立地变化。
3. **组合模式（Composite Pattern）**：将对象组合成**树形结构**以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。
4. **装饰器模式（Decorator Pattern）**：动态地给一个对象添加一些额外的职责，就**增加功能**来说，装饰模式比生成子类更为灵活。
5. **外观模式（Facade Pattern）**：为子系统中的一组接口提供一个统一的接口，外观模式定义了一个**高层接口**，这个接口使得这一子系统更加容易使用。
6. **享元模式（Flyweight Pattern）**：运用共享技术有效地支持大量细粒度的对象。
7. **代理模式（Proxy Pattern）**：为其他对象提供一种代理以控制对这个对象的访问。

适配器就是转换兼容，桥接就是拆分可复用部分，组合就是树形结构，装饰器就是在不改变类的情况下增强类功能，外观就是封装，享元就是缓存不变类，代理模式就是控制限制类。

### 适配器

> 将一个类的接口**转换**成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，则中间需要一个适配器转换。将下面的类传入线程是不行的：

```java
class A implements Callable<Long>{
    @Override
    public Long call() {
        return 123L;
    }
}
```

```java
Callable<Long> a=new A();
Thread thread=new Thread(a);//没有实现Runnable接口，所以不能向上转型为Runnable
thread.start();
```

办法一是改写`A`类，把实现的`Callable`改为`Runnable`，但这样做不好，因为`A`有可能在其他地方作为`Callable`被引用，改写`Task`的接口，会导致其他正常工作的代码无法编译。

另一个办法不用改写`A`类，而是用一个Adapter，把这个`Callable`接口“变成”`Runnable`接口，这样，就可以正常编译：

```java
Callable<Long> a = new A();
Thread thread = new Thread(new CallableToRunnableAdapter(a));
thread.start();
```

这个`CallableToRunnableAdapter`类就是Adapter，它接收一个`Callable`，输出一个`Runnable`。实现非常简单：

```java
class CallableToRunnableAdapter implements Runnable{
    Callable<Long> c;
    public CallableToRunnableAdapter(Callable<Long> c) {
        this.c = c;
    }
    @Override
    public void run() {
        try {
            c.call();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
```

编写一个Adapter的步骤如下：

1. 实现目标接口，这里是`Runnable`；
2. 内部持有一个待转换接口的引用，这里是通过字段持有`Callable`接口；
3. 在目标接口的实现方法内部，调用待转换接口的方法。

这样一来，Thread就可以接收这个`RunnableAdapter`，因为它实现了`Runnable`接口。`Thread`作为调用方，它会调用`RunnableAdapter`的`run()`方法，在这个`run()`方法内部，又调用了`Callable`的`call()`方法，相当于`Thread`通过一层转换，间接调用了`Callable`的`call()`方法。

使用lambda也是可以的：

```java
public class Main {
    @Test
    void test1() {
        Callable<Long> a=new A();
        Thread thread=new Thread(() -> {
            try {
                a.call();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        });
        thread.start();
    }
}

class A implements Callable<Long>{
    @Override
    public Long call() {
        return 123L;
    }
}
```

从某种程度上说，这确实可以被看作是一种简单的转换器思想，通过实现 `Runnable` 接口，将 `Callable` 接口的 `call` 方法转换成了 `Runnable` 接口的 `run` 方法，使得原本的 `Callable` 对象 `a` 可以在 `Thread` 中被使用。

虽然这种用法不是传统意义上的转换器模式，但从某种程度上可以看作是一种类似的思想，即通过接口或类的适配来实现不同对象之间的协同工作。

如果不局限与接口或类的适配，那么实例化类也沾点转换器思想，因为将数据整合“转换“为了类实例。

向上转型和向下转型在某种程度上也可以被视为适配器思想的一种体现。向上转型是指将子类对象转换为父类对象的过程，这样做可以使得子类对象可以被当做父类对象对待，从而实现多态性。这种转型可以被看作是一种接口的适配，将子类对象适配成了父类对象。

向下转型是指将父类对象转换为子类对象的过程。这种转型可能涉及到类型检查和转换，以确保父类对象确实可以被转换为子类对象。向下转型也可以被视为一种适配器思想，将父类对象适配成了子类对象，以便对其进行特定的操作或方法调用。



------

适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是`String[]`，但是需要`List`接口时，可以用一个Adapter：

```java
String[] exist = new String[] {"Good", "morning", "Bob", "and", "Alice"};
Set<String> set = new HashSet<>(Arrays.asList(exist));
```

`List<T> Arrays.asList(T[])`就相当于一个转换器，它可以把数组转换为`List`。

假设有一个`InputStream`，但希望调用`readText(Reader)`这个方法，但它的参数类型是`Reader`而不是`InputStream`，怎么办？当然是使用适配器，把`InputStream`“变成”`Reader`：

```java
InputStream input = Files.newInputStream(Paths.get("/path/to/file"));
Reader reader = new InputStreamReader(input, "UTF-8");
readText(reader);
```

`InputStreamReader`就是Java标准库提供的`Adapter`，它负责把一个`InputStream`适配为`Reader`。类似的还有`OutputStreamWriter`。

除了前面提到的对象适配器和类适配器之外，适配器思想还可以体现在以下几个方面：

1. **接口适配器模式（Interface Adapter Pattern）**：当一个接口中定义了许多方法，但只有部分方法需要被实现时，可以创建一个抽象类实现该接口，并为接口中的每个方法提供一个空实现。这样在需要使用该接口时，只需要继承这个抽象类，重写需要的方法即可，避免了在实现类中实现所有方法的繁琐性。
2. **数据适配器**：将一个数据格式转换为另一个数据格式的过程可以看作是一种适配器思想的应用。例如，将一个JSON格式的数据转换为XML格式的数据，或者将一个数据结构转换为另一个数据结构以适应不同的应用场景。
3. **协议适配器**：在网络通信中，不同的设备或系统可能使用不同的通信协议。协议适配器用于将一个通信协议转换为另一个通信协议，以实现不同设备或系统之间的通信。
4. **电源适配器**：在不同国家或地区，电源插头的形状和电压标准可能不同。电源适配器用于将一个电源插头转换为另一个电源插头，以适应不同地区的电源标准。



### 桥接

> 将抽象部分与它的实现**部分分离**，使它们都可以独立地变化。

假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：

```ascii
                   ┌───────┐
                   │  Car  │
                   └───────┘
                       ▲
    ┌──────────────────┼───────────────────┐
    │                  │                   │
┌───────┐          ┌───────┐          ┌───────┐
│BigCar │          │TinyCar│          │BossCar│
└───────┘          └───────┘          └───────┘
    ▲                  ▲                  ▲
    │                  │                  │
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │
      └───────────────┘  └───────────────┘  └───────────────┘
```

如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。

所以，桥接模式就是为了避免直接继承带来的子类爆炸。

在桥接模式中，首先把`Car`按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。

首先定义抽象类`Car`，它引用一个`Engine`：

```java
abstract class Car {
    // 引用Engine:
    protected Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }

    public abstract void drive();
}
interface Engine {
    void start();
}
```

紧接着，在一个“修正”的抽象类`RefinedCar`中定义一些**额外操作**：

```java
abstract class RefinedCar extends Car {
    public RefinedCar(Engine engine) {
        super(engine);
    }
    @Override
    public void drive() {
        this.engine.start();
        System.out.println("驾驶 " + getBrand() + " 汽车...");
    }
    public abstract String getBrand();
}
```

这样一来，最终的不同品牌继承自`RefinedCar`，例如`BossCar`：

```java
class BossCar extends RefinedCar {
    public BossCar(Engine engine) {
        super(engine);
    }

    public String getBrand() {
        return "Boss";
    }
}
```

而针对每一种引擎，继承自`Engine`，例如`HybridEngine`：

```java
class HybridEngine implements Engine {
    public void start() {
        System.out.println("启动混合引擎");
    }
}
```

客户端通过自己选择一个品牌，再配合一种引擎，得到最终的`Car`：

```java
RefinedCar car = new BossCar(new HybridEngine());
car.drive();
```

使用桥接模式的好处在于，如果要增加一种引擎，只需要针对`Engine`派生一个新的子类，如果要增加一个品牌，只需要针对`RefinedCar`派生一个子类，任何`RefinedCar`的子类都可以和任何一种`Engine`自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。

```ascii
       ┌───────────┐
       │    Car    │
       └───────────┘
             ▲
             │
       ┌───────────┐       ┌─────────┐
       │RefinedCar │ ─ ─ ─>│ Engine  │
       └───────────┘       └─────────┘
             ▲                  ▲
    ┌────────┼────────┐         │ ┌──────────────┐
    │        │        │         ├─│  FuelEngine  │
┌───────┐┌───────┐┌───────┐     │ └──────────────┘
│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐
└───────┘└───────┘└───────┘     ├─│ElectricEngine│
                                │ └──────────────┘
                                │ ┌──────────────┐
                                └─│ HybridEngine │
                                  └──────────────┘
```

桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。

### 组合

> 将对象组合成**树形结构**以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。

在组合模式中，有两种主要的对象：叶子节点和容器节点。叶子节点表示树中的最终节点，它没有子节点；容器节点表示包含子节点的节点，它可以包含叶子节点和其他容器节点。

通过使用组合模式，可以将单个对象和组合对象都视为相同类型的对象，从而可以统一处理它们。例如，无论是操作单个文件还是操作整个文件夹（包含多个文件和文件夹），客户端都可以使用相同的方式来进行操作，这样就简化了客户端的代码逻辑。

总的来说，组合模式可以构建具有层次结构的对象，并且可以统一处理这些对象，提高代码的灵活性和可维护性。

在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。要以树的结构表示XML，先抽象出节点`Node`：

```java
interface Node {
    // 添加一个节点为子节点:
    Node add(Node node);
    // 获取子节点:
    List<Node> children();
    // 输出为XML:
    String toXml();
}
```

对于一个`<name>`这样的节点，称之为`ElementNode`，它可以作为容器包含多个子节点：

```java
class ElementNode implements Node {
    private String name;
    private List<Node> list = new ArrayList<>();
    public ElementNode(String name) {
        this.name = name;
    }
    public Node add(Node node) {
        list.add(node);
        return this;
    }
    public List<Node> children() {
        return list;
    }
    public String toXml() {
        String start = "<" + name + ">\n";
        String end = "</" + name + ">";
        StringJoiner sj = new StringJoiner("", start, end);
        list.forEach(node -> {
            sj.add(node.toXml()+"\n");
        });
        return sj.toString();
    }
}
```

对于普通文本，把它看作`TextNode`，它没有子节点：

```java
class TextNode implements Node {
	private String text;
	public TextNode(String text) {
		this.text = text;
	}
	public Node add(Node node) {
		throw new UnsupportedOperationException();
	}
	public List<Node> children() {
		return null;
	}
	public String toXml() {
		return text;
	}
}
```

此外，还可以有注释节点：

```java
class CommentNode implements Node {
    private String text;
    public CommentNode(String text) {
        this.text = text;
    }
    public Node add(Node node) {
        throw new UnsupportedOperationException();
    }
    public List<Node> children() {
        return null;
    }
    public String toXml() {
        return "<!-- " + text + " -->";
    }
}
```

通过`ElementNode`、`TextNode`和`CommentNode`，就可以构造出一颗树：

```java
Node root = new ElementNode("school");
root.add(new ElementNode("classA")
        .add(new TextNode("Tom"))
        .add(new TextNode("Alice")));
root.add(new ElementNode("classB")
        .add(new TextNode("Bob"))
        .add(new TextNode("Grace"))
        .add(new CommentNode("comment...")));
System.out.println(root.toXml());
```

最后通过`root`节点输出的XML如下：

```text
<school>
<classA>
Tom
Alice
</classA>
<classB>
Bob
Grace
<!-- comment... -->
</classB>
</school>
```

使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：

```ascii
             ┌───────────┐
             │   Node    │
             └───────────┘
                   ▲
      ┌────────────┼────────────┐
      │            │            │
┌───────────┐┌───────────┐┌───────────┐
│ElementNode││ TextNode  ││CommentNode│
└───────────┘└───────────┘└───────────┘
```

作为容器节点的`ElementNode`又可以添加任意个`Node`，这样就可以构成层级结构。

类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。

文件形式的：

```java
package test;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;


public class Main {
    @Test
    void test1() {
        // 创建文件
        FileSystemComponent file1 = new File("File1.txt");
        FileSystemComponent file2 = new File("File2.txt");

        // 创建文件夹并添加文件
        FileSystemComponent folder1 = new Folder("Folder1");
        folder1.add(file1);
        folder1.add(file2);

        // 创建文件夹并添加文件
        FileSystemComponent folder2 = new Folder("Folder2");
        FileSystemComponent file3 = new File("File3.txt");
        folder2.add(file3);

        // 将文件夹添加到根文件夹
        FileSystemComponent rootFolder = new Folder("Root");
        rootFolder.add(folder1);
        rootFolder.add(folder2);

        // 打印整个文件系统
        rootFolder.print("");
    }
}

abstract class FileSystemComponent {
    protected String name;

    public FileSystemComponent(String name) {
        this.name = name;
    }

    public abstract void print(String sep);
    public abstract void add(FileSystemComponent component);

    public abstract void remove(FileSystemComponent component);
}
class File extends FileSystemComponent {
    public File(String name) {
        super(name);
    }

    @Override
    public void print(String sep) {
        System.out.println(sep+"File: " + name);
    }

    @Override
    public void add(FileSystemComponent component) {
    }

    @Override
    public void remove(FileSystemComponent component) {
    }
}

class Folder extends FileSystemComponent {
    private List<FileSystemComponent> children = new ArrayList<>();

    public Folder(String name) {
        super(name);
    }

    public void add(FileSystemComponent component) {
        children.add(component);
    }

    public void remove(FileSystemComponent component) {
        children.remove(component);
    }

    @Override
    public void print(String sep) {
        System.out.println(sep+"Folder: " + name);
        for (FileSystemComponent component : children) {
            component.print(sep+"\t");
        }
    }
}
```

### 装饰器

> 动态地给一个对象**添加一些额外的职责**。就增加功能来说，相比生成子类更为灵活。

装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。

在Java标准库中，`InputStream`是抽象类，`FileInputStream`、`ServletInputStream`、`Socket.getInputStream()`这些`InputStream`都是最终数据源。

现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。

Decorator模式的目的就是一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得想要的功能。

例如：给`FileInputStream`增加缓冲和解压缩功能，用Decorator模式写出来如下：

```java
// 创建原始的数据源:
InputStream fis = new FileInputStream("test.gz");
// 增加缓冲功能:
InputStream bis = new BufferedInputStream(fis);
// 增加解压缩功能:
InputStream gis = new GZIPInputStream(bis);
```

或者一次性写成这样：

```java
InputStream input = new GZIPInputStream( // 第二层装饰
                        new BufferedInputStream( // 第一层装饰
                            new FileInputStream("test.gz") // 核心功能
                        ));
```

`BufferedInputStream`和`GZIPInputStream`实际上都是从`FilterInputStream`继承的，这个`FilterInputStream`就是一个抽象的Decorator。把Decorator模式画出来如下：

```ascii
             ┌───────────┐
             │ Component │
             └───────────┘
                   ▲
      ┌────────────┼─────────────────┐
      │            │                 │
┌───────────┐┌───────────┐     ┌───────────┐
│ComponentA ││ComponentB │...  │ Decorator │
└───────────┘└───────────┘     └───────────┘
                                     ▲
                              ┌──────┴──────┐
                              │             │
                        ┌───────────┐ ┌───────────┐
                        │DecoratorA │ │DecoratorB │...
                        └───────────┘ └───────────┘
```

最顶层的`Component`是接口，对应到IO的就是`InputStream`这个抽象类。`ComponentA`、`ComponentB`是实际的子类，对应到IO的就是`FileInputStream`、`ServletInputStream`这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是`FilterInputStream`。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是`BufferedInputStream`、`GZIPInputStream`等。

Decorator模式实际上把核心功能和附加功能给分开了。核心功能指`FileInputStream`这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。

如果要新增核心功能，就增加Component的子类，例如`ByteInputStream`。如果要增加附加功能，就增加Decorator的子类，例如`CipherInputStream`。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。

如果要设计完整的Decorator模式，应该如何设计？

假设需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。

首先，仍然需要定义顶层接口`TextNode`：

```java
public interface TextNode {
    // 设置text:
    void setText(String text);
    // 获取text:
    String getText();
}
```

对于核心节点，例如`<span>`，它需要从`TextNode`直接继承：

```java
public class SpanNode implements TextNode {
    private String text;

    public void setText(String text) {
        this.text = text;
    }

    public String getText() {
        return "<span>" + text + "</span>";
    }
}
```

为了实现Decorator模式，需要有一个抽象的Decorator类：

```java
public abstract class NodeDecorator implements TextNode {
    //注意这里也实现了TextNode接口
    protected final TextNode target;

    protected NodeDecorator(TextNode target) {
        this.target = target;
    }

    public void setText(String text) {
        this.target.setText(text);
    }
}
```

这个`NodeDecorator`类的核心是持有一个`TextNode`，即将要把功能附加到的`TextNode`实例。接下来就可以写一个加粗功能：

```java
public class BoldDecorator extends NodeDecorator {
    public BoldDecorator(TextNode target) {
        super(target);
    }

    public String getText() {
        //重写加了内容
        return "<b>" + target.getText() + "</b>";
    }
}
```

调用：

```java
TextNode n1 = new SpanNode();//外层<span>
n1.setText("Hello");//正常修改text
TextNode n2 = new BoldDecorator(n1);//getText时加一个<b>包围原内容
System.out.println(n2.getText());//调用栈：n2.getText()->n1.getText()

TextNode n3 = new BoldDecorator(n2);//getText时加一个<b>包围原内容
//调用栈：n3.getText()->n2.getText()->n1.getText()
// n1返回text内容，然后n2加<b>返回，然后n1加<b>返回
System.out.println(n3.getText());//<b><b><span>Hello</span></b></b>
//调用栈：n3.setText()->n2.setText()->n1.setText()->this.text = text;
n3.setText("HI");//只修改了text

System.out.println(n3.getText());//<b><b><span>HI</span></b></b>
```

类似的，可以继续加`ItalicDecorator`、`UnderlineDecorator`等。

------

**装饰器与桥接模式**

装饰器和桥接的目的都是降低继承中衍生的子类的数量。

桥接是通过把一个组件及其子类作为另一总体的字段引用实现功能组合，也可以用多个组件来拼合总体。桥接的子类是负责总体的局部功能，是构成性的，是必要的。

装饰器则在大类下创建一个装饰器的子族，不管是主要部件还是装饰器都隶属于这个大类，所以装饰器可以不断嵌套。装饰器则是对已经具有了完整功能的总体进行修饰，是附加性的，是可选的。

### 外观

> 为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个**高层接口**，这个接口使得这一子系统更加容易使用。

外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：

如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。

以注册公司为例，假设注册公司需要三步：

1. 向工商局申请公司营业执照；
2. 在银行开设账户；
3. 在税务局开设纳税号。

以下是三个系统的接口：

```java
// 工商注册:
public class AdminOfIndustry {
    public Company register(String name) {
        ...
    }
}
// 银行开户:
public class Bank {
    public String openAccount(String companyId) {
        ...
    }
}
// 纳税登记:
public class Taxation {
    public String applyTaxCode(String companyId) {
        ...
    }
}
```

如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：

```java
public class Facade {
    public Company openCompany(String name) {
        Company c = this.admin.register(name);
        String bankAccount = this.bank.openAccount(c.getId());
        c.setBankAccount(bankAccount);
        String taxCode = this.taxation.applyTaxCode(c.getId());
        c.setTaxCode(taxCode);
        return c;
    }
}
```

这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：

```java
Company c = facade.openCompany("Facade Software Ltd.");
```

很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个`RestApiController`，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。

更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。

也就是说，我如果需要实现一个功能，比如打印水仙花数，我可以直接在main里写，也可以封装打印水仙花数为一个函数，然后通过主函数调用这个函数。这就是一种简单的外观模式的应用。外观模式的核心思想就是封装复杂的逻辑，提供一个简单的接口给客户端使用，从而简化客户端的操作。

### 享元

> 运用共享技术有效地支持大量细粒度的对象。

享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就**没有必要**，直接向调用方返回一个**共享的实例**就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。

享元模式在Java标准库中有很多应用。包装类型如`Byte`、`Integer`都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以`Integer`为例，如果我们通过`Integer.valueOf()`这个静态工厂方法创建`Integer`实例，当传入的`int`范围在`-128`~`+127`之间时，会直接返回缓存的`Integer`实例：

```java
Integer n1 = Integer.valueOf(100);
Integer n2 = Integer.valueOf(100);
System.out.println(n1 == n2); // true
```

对于`Byte`来说，因为它一共只有256个状态，所以，通过`Byte.valueOf()`创建的`Byte`实例，全部都是缓存对象。

因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的**复用**。

 总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。

在实际应用中，**享元模式主要应用于缓存**，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。

以`Student`为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：

```java
public class Student {
    // 持有缓存:
    private static final Map<String, Student> cache = new HashMap<>();

    // 静态工厂方法:
    public static Student create(int id, String name) {
        String key = id + "\n" + name;
        // 先查找缓存:
        Student std = cache.get(key);
        if (std == null) {
            // 未找到,创建新对象:
            System.out.println(String.format("create new Student(%s, %s)", id, name));
            std = new Student(id, name);
            // 放入缓存:
            cache.put(key, std);
        } else {
            // 缓存中存在:
            System.out.println(String.format("return cached Student(%s, %s)", std.id, std.name));
        }
        return std;
    }
    private final int id;
    private final String name;
    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
```

在实际应用中，经常使用成熟的缓存库，例如[Guava](https://github.com/google/guava)的[Cache](https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java)，因为它提供了最大缓存数量限制、定时过期等实用功能。

享元模式的设计思想是尽量复用已创建的对象，常用于工厂方法内部的优化。

单例模式是不允许创建新实例，只能使用一个实例。

而享元要求**实例不变**，才能把“创建一个新实例”的操作给优化成“直接返回一个缓存的实例”。

### 代理

> 为其他对象提供一种代理以**控制**对这个对象的访问。

代理模式，即Proxy，它和Adapter模式很类似。Adapter模式，它用于把A接口转换为B接口，即做兼容：

```java
public class BAdapter implements B {
    private A a;
    public BAdapter(A a) {
        this.a = a;
    }
    public void b() {
        a.a();
    }
}
```

而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：

```java
public class AProxy implements A {
    private A a;
    public AProxy(A a) {
        this.a = a;
    }
    public void a() {
        this.a.a();
    }
}
```

这是原始的，可以加功能，比如权限判断来限制访问，打印日志：

```java
public class Main {
    @Test
    void test1() {
        A aProxy=new AProxy(new AImpl());
        aProxy.a();
    }
}
interface A{
    void a();
}
class AImpl implements A{
    @Override
    public void a() {
        System.out.println("原功能");
    }
}
class AProxy implements A {
    private A a;
    public AProxy(A a) {
        this.a = a;
    }
    public void a() {
        System.out.println("调用前");
        this.a.a();
        System.out.println("调用后");
    }
}
```

为什么不把权限检查的功能直接写到目标实例的内部？因为编写代码的原则有：

- 职责清晰：一个类只负责一件事；
- 易于测试：一次只测一个功能。

用Proxy实现这个权限检查，可以获得更清晰、更简洁的代码：

- `A`接口：只定义接口；
- `AImpl`类：只实现A接口的业务逻辑；
- `AProxy`类：只实现A接口的日志输出代理。

如果希望编写其他类型的代理，可以继续增加，一个套一个。

实际上权限检查、打印日志只是代理模式的一种应用。Proxy还广泛应用在：

**远程代理**

远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。

**虚代理**

虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。

例如：

```java
public class Main {
    @Test
    void test1() {
        I a=I.getInstance();
        System.out.println("得到对象");
        a.print();
    }
}
interface I{
    static I getInstance() {
        return new I() {
            private I i=null;
            @Override
            public void print() {
                if (i==null){
                    i=new A();
                }
                i.print();
            }
        };
    }
    void print();
}


class A implements I{
    public A() {
        System.out.println("实例化");
    }

    @Override
    public void print() {
        System.out.println("打印");
    }
}
```

再加上队列复用：

```java
public class Main {
    @Test
    void test1() throws Exception {
        Runnable r=()->{
            for (int i=0;i<5;i++){
                try(I a=I.getInstance()){
                    Thread.sleep(100);
                    a.print();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        };
        Thread thread = new Thread(r);
        thread.start();
        r.run();
        thread.join();
        System.out.println(I.idleQueue.size());

    }
}
interface I extends AutoCloseable{
    /*空闲队列，线程安全的*/
    Queue<I> idleQueue = new ArrayBlockingQueue<>(100);
    /**
     * 虚代理
     * @return 虚代理
     */
    static I getInstance() {
        /*复用空闲的A代理*/
        I i = idleQueue.poll();
        if(i==null){
            i=new Aproxy();
        }
        return i;
    }
    void print();
}
 class Aproxy implements I{
    private I i=null;
    @Override
    public void print() {
        /*调用方法时才实例化*/
        if (i==null){
            i=new A();
        }
        i.print();
    }

    @Override
    public void close() {
        /*丢回空闲队列*/
        idleQueue.offer(this);
        System.out.println("假装关闭了");
    }
}

class A implements I{
    public A() {
        System.out.println("实例化");
    }

    @Override
    public void print() {
        System.out.println("打印");
    }

    @Override
    public void close() {
        System.out.println("已关闭");
    }
}
```

A最多只实例化了2次，因为只有2个线程。如果注释掉：`a.print();`，则A实例化0次，因为使用了虚代理。





**保护代理**

保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。

**智能引用**

智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。



代理模式和装饰器模式有一些相似之处，但它们的目的和使用方式略有不同：

- **装饰器模式**：装饰器模式旨在动态地给对象**添加额外的职责**，而不改变其接口。它通常通过创建一个包装对象来包裹真实的对象，并在保持真实对象接口不变的情况下，增加额外的功能或责任。
- **代理模式**：代理模式为其他对象提供一种代理以**控制对这个对象的访问**。代理类通常在客户端和真实主题之间充当中介，可以用于控制对真实对象的访问权限、缓存对象的访问结果、延迟加载对象等。

虽然两者都涉及到包装一个对象以增强其功能，但装饰器模式注重于增加新的行为，而代理模式注重于控制对对象的访问。

Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。

















## 行为型模式

行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。

行为型模式有：

责任链模式（Chain of Responsibility）：将请求的发送者和接收者解耦，让多个对象都有机会处理这个请求。

命令模式（Command）：将请求封装成一个对象，从而可以用不同的请求对客户进行参数化，并且对请求排队或记录请求日志，以及支持可撤销的操作。

解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

中介模式（Mediator）：用一个中介对象来封装一系列的对象交互，使得对象不需要显式地相互引用，从而达到解耦的目的。

备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象到原先保存的状态。

观察者模式（Observer）：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象状态发生变化时，会通知所有的观察者对象。

状态模式（State）：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式将对象的状态封装成独立的类，并将不同状态对应的行为抽象出来，使得在不同状态下可以定义不同的行为，而不需要使用大量的条件语句来判断当前状态。这样可以让代码更加清晰、可维护，同时也符合开闭原则，因为添加新的状态类不会影响现有代码。

策略模式（Strategy）：定义了一系列的算法，并将每一个算法封装起来，使得它们可以相互替换，让算法独立于使用它的客户而独立变化。

模板方法模式（Template Method）：定义一个操作中的算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。



### 责任链

> 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到**其中某个处理成功为止**。责任链模式把多个处理器串成链，然后让请求在链上传递。

用责任链模式时，每个处理方法只关心自己责任的范围内的数据。对于超出自己责任范围的，扔给下一个处理方法。

定义一个要处理的`Request`数据：

```java
class Data{
    private int id=0;
    private String name="";
    private int sum=0;

    public Data(int id, String name, int sum) {
        this.id = id;
        this.name = name;
        this.sum = sum;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getSum() {
        return sum;
    }

    public void setSum(int sum) {
        this.sum = sum;
    }
}
```

抽象出处理方法：

```java
interface I<T> {
    // 返回Boolean.TRUE = 成功
    // 返回Boolean.FALSE = 拒绝
    // 返回null = 交下一个处理
    Boolean process(T t);
}
```

实现：

```java
class AHandler implements I<Data>{
    @Override
    public Boolean process(Data data) {
        if (data.getSum()>=90){
            System.out.println("优");
            return true;
        }
        /*继续责任链*/
        return null;
    }
}
class BHandler implements I<Data>{
    @Override
    public Boolean process(Data data) {
        if (data.getSum()>=80){
            System.out.println("良");
            return true;
        }
        /*继续责任链*/
        return null;
    }
}
class CHandler implements I<Data>{
    @Override
    public Boolean process(Data data) {
        if (data.getSum()>=60){
            System.out.println("及格");
            return true;
        }
        /*继续责任链*/
        return null;
    }
}
class DHandler implements I<Data>{
    @Override
    public Boolean process(Data data) {
        if (data.getSum()>=0) {
            System.out.println("不及格");
        }
        /*停止责任链*/
        return false;
    }
}
```

组合处理方法：

```java
class HandlerChain<T>{
    List<I<T>> handlers=new ArrayList<>();
    public void addHandler(I<T> handler) {
        this.handlers.add(handler);
    }

    public boolean start(T data) {
        // 依次调用每个Handler:
        for (I<T> handler : handlers) {
            Boolean r = handler.process(data);
            if (r != null) {
                // 如果返回TRUE或FALSE，处理结束:
                System.out.println(data+ (r ? "已打分" : "已拒绝") +handler.getClass().getSimpleName());
                return r;
            }
        }
        throw new RuntimeException("没有责任方法对此处理：" + data);
    }
}
```

使用：

```java
/*构造责任链*/
HandlerChain<Data> handlerChain=new HandlerChain<>();
handlerChain.addHandler(new AHandler());
handlerChain.addHandler(new BHandler());
handlerChain.addHandler(new CHandler());
handlerChain.addHandler(new DHandler());
/*使用责任链*/
handlerChain.start(new Data(1,"小并",100));
handlerChain.start(new Data(2,"小西",60));
handlerChain.start(new Data(3,"小强",50));
handlerChain.start(new Data(4,"小希",-1));
```

控制台：

```text
优
test.Data@8c3b9d已打分AHandler
及格
test.Data@4c39bec8已打分CHandler
不及格
test.Data@f79e已拒绝DHandler
test.Data@7ee8290b已拒绝DHandler
```

`Handler`添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。

责任链模式有很多变种。有些责任链的实现方式是通过某个`Handler`手动调用下一个`Handler`来传递`Request`。

还有一些责任链模式，每个`Handler`都有机会处理`Request`，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个`Handler`处理掉`Request`，而是每个`Handler`都做一些工作，比如：记录日志；检查权限；准备相关资源；

Servlet规范定义的`Filter`就是一种责任链模式，它不但允许每个`Filter`都有机会处理请求，还允许每个`Filter`决定是否将请求“放行”给下一个`Filter`：

```java
class AuditFilter implements Filter {
    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
        //做些工作，如果做完了就放行给下一个：
        chain.doFilter(req, resp);
    }
}
```

这种模式不但允许一个`Filter`自行决定处理`ServletRequest`和`ServletResponse`，还可以“伪造”`ServletRequest`和`ServletResponse`以便让下一个`Filter`处理，能实现非常复杂的功能。

责任链模式是一种把多个处理器组合在一起，依次处理请求的模式，添加新的处理器或者重新排列处理器非常容易，经常用在拦截、预处理请求等。









