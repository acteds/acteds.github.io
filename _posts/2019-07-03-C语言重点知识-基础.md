---
layout: post
title: C语言重点知识-基础
categories: c
description: C语言重点知识笔记
keywords: c
---
# 引言  
本篇文章介绍C的基础,即输入输出、判断、循环、存储类、函数、操作符、数组。  


# 其他
## **行尾加\\**
在C语言中通过在行的最后加**\\**可以告诉C语言这行与下行合并在任意位置,但是如果下行有缩进那么缩进也会被合并:  
```c
#include <stdio.h>
int main(int argc, char const *argv[])
{
    char a[255] = "\0";
    scanf("%s", a);
    pri\
ntf("%s", a);
    return 0;
}
```
## **goto的使用:**
```c
a1:
    out99();
    goto a1;
```
## **整型提升**
表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器（ALU）的操作数的字节长度一般就是**int**的字节长度，同时也是CPU的通用寄存器的长度。  
因此，即使两个**char**类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度.所以，表达式中各种长度可能小于**int**长度的整型值，都必须先转换为**int**或 **unsigned int**，然后才能送入CPU去执行运算.  
无符号整型提升时左边补0,有符号整型提升左边补符号位.  
栈区默认使用高地址处的空间。  
数组随着下标的增长,地址是由低到高变化。  
**Release**版本是经过优化的,**debug**版本是未经优化的。  
整型是以**补码**存放在内存中,补码=原码除符号位取反+1。  
## **大端小端(字节序存储模式)**
大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在內存的低地址中  
小端（存储）模式，是指数据的**低位保存在內存的低地址**中，而数据的髙位，保存在内存的高地址中。  
**`int a=1;`**,如果是小端则a的值在内存中为**01 00 00 00**.  
## **浮点数在内存中的存储:**
IEEE 754:  
对于32位浮点数,1位符号位+8位次方位,+23位浮点位.,次方位要加127确保为正  
-5.0相当于-101.0 即-1.01\*2^2 那么s=1,M=1.01,E=2  
也就是:1 10000001 01000000000000000000000  
对于64位浮点数,1位符号位+11位次方位,+54位浮点位.,指数位要加1023确保为正  
表格 1 各种数据类型的初始值  

| 数据类型 | 初始化默认值 |
|----------|--------------|
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

# 输入输出
**`printf()`**的返回值为打印的字符串长度  
使用**printf** 输出 **double** 和 **float** 都可以用 **`%f`** 占位符，而 **double** 可以额外用 **`%lf`**。  
而**scanf**输入情况下 **double** **必须**用 **`%lf`**，**float** **必须**用 **`%f`** 不能混用。  
**scanf**函数以**空格**或**换行**做为分隔符  
当**`getchar()`**放在**`scanf("%s",chs)`**语句后面,那么将会接收**`sacnf()`**没有接收的**`\n`**,要解决,则可以再加一个**`getchar()`**或循环**`getchar()`**清空缓冲区.  
## **格式化输出:**
**基本型，用 %f**  
不指定输出类型的长度，一般是实数中的整数部分全部输出，小数部分输出六位。例：  
```c
double a=1.0;
printf("%f\n",a/3);
```
运行结果：**0.333333**  
## **指定数据宽度和小数位数，用 `%m.nf`**
例：将上个程序的双精度变量 a 输出 15 位小数，用 `%20.15f` 的格式声明，指定输出的数据占 20 列，其中包括 15 位小数。改动上面程序如下：  
```c
double a=1.0;
printf("%20.15f\n",a/3);
```
运行结果：  
```text
   0.333333333333333
```
注意在 0 的前面有 3 个空格，且双精度数只保证 15 位有效数字的准确性。  
## **输出的数据左对齐，用 `%-m.nf`**
在 **`m.n`** 前加一个负号，其作用与 **`%m.nf`** 形式作用基本相同，但当数据长度不长过 **`m`**时，数据向左靠，右端补空格。  
**%p打印地址**  
##  **gets()**
函数原型：  
```c
char *gets(char *buffer);
```
函数功能：从键盘上输入字符，直至接受到换行符或EOF时停止，并将读取的结果存放在**buffer**指针所指向的字符数组中。  
读取的换行符被转换为null值，做为字符数组的最后一个字符，来结束字符串。  
读取字符到数组,**str**为数组名。例：**gets(str);**  
**gets()的安全性问题**  
示例:  
```c
char str[5];
gets(str);
printf("%s",str);
```
如果输入的内容大于5，也会正常的打印出来，但是系统会提示程序崩溃。  
**gets**函数由于没有指定输入字符大小，所以会**无限读取**，一旦输入的字符大于数组长度，就会发生**内存越界**，从而造成程序崩溃或其他数据的错误。  
考虑到程序安全性和健壮性，建议用**fgets()**来代替**gets()**。即:**fgets(str,5,stdin);**，**stdin**表示从键盘输入数据。  
## **fgets()**
函数原型：  
```c
char *fgets(char *s, int n, FILE *stream);
```
函数功能：从文件指针**stream**中读取字符，存到以**s**为起始地址的空间里，直到读完**n-1**个字符，或者读完一行。  
注意：调用**fgets**函数时，最多只能读入**n-1**个字符。读入结束后，系统将自动在最后**加'\0'**，并以**s**作为函数值返回。  
可以这么使用：**fgets(str, sizeof(str), stdin);**  
其中**str**为数组首地址，**sizeof(str)**为数组大小，**stdin**表示从键盘输入数据。  
# 判断语句
**else与离得最近的未匹配的if匹配**  
**switch** 语句中的 **expression** 是一个常量表达式，**必须**是一个**整型**或**枚举类型**。**case** 的 **constant-expression** **必须**与 switch 中的变量具有**相同的数据类型**，且**必须**是一个**常量**或**字面量**。  
# 循环
while与for的不同  
```c
for (int i = 1; i \< 10; i++)
{
    //该操作只会跳过i==5之后的语句,然后执行i++;
    if (i == 5) { continue; }
    printf("%d", i);
}
printf("\n");
int i = 1;
while (i\<=10)
{
     //该操作会使i++;语句无法执行,导致死循环
     if (i==5) { continue; }
     printf("%d", i);
     i++;
}
```
执行结果:  
```text
12346789
1234
```
同样的,**do...while**不当使用**continue**;也会导致死循环.  
for循环里第一条语句在**C99**之前是不能同时定义并赋值的,**只能赋值**即:  
```c
int i = 0;
for (i = 1; i < 10; i++) { }
```
建议for语句的循环控制变量的取值采用"前闭后开区间"写法  
```c
for (i = 1; i < 10; i++)
```
两条语句执行效果相同,都是死循环  
```c
for (;;){}
while (1) {}
```
递归是一个简洁的概念，同时也是一种很有用的手段。但是，使用递归是要付出代价的。与直接的语句(如**while**循环)相比，递归函数会耗费**更多**的运行时间，并且要占用大量的栈空间。递归函数每次调用自身时，都需要把它的状态存到栈中，以便在它调用完自身后，程序可以返回到它原来的状态。未经精心设计的递归函数总是会带来麻烦。  
# 存储类
**auto** 存储类是所有**局部变量默认**的存储类**,auto** **只能**用在函数内，即 **auto** 只能修饰局部变量。  
**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小，且**不能**对它应用一元的**&**运算符（因为它**没有内存位置**）。寄存器只用于需要快速访问的变量，比如计数器。定义 **register** 并不意味着变量将被存储在寄存器中，它意味着变量**可能存储在寄存器**中，这取决于硬件和实现的限制。  
**static** 存储类指示编译器在**程序的生命周期**内**保持局部变量**的**存在**，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 **static** 修饰局部变量可以在函数调用之间保持局部变量的值。  
**static** 修饰符也可以应用于**全局变量**。当 **static** 修饰全局变量时，会使变量的**作用域限制在**声明它的**文件内**。  
全局声明的一个 **static** 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 **static** 变量或方法**同一个文件**中。**static** 为所有**全局变量默认**的存储类.  
**extern** 存储类用于在一个文件中声明一个全局变量或函数，该变量或函数是在另一个文件中定义的。通过使用 **extern**，可以将变量或函数的引用提供给其他文件，使得这些变量或函数在**其他文件**中可见和可访问。具体来说：  
对于变量或函数，**extern** 用于声明一个全局变量或函数。变量或函数的定义通常在另一个文件里，使用 **extern** 声明这个变量或函数后可以在当前文件中使用这个全局变量或函数。  
在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个变量名字相同，会优先使用**局部变量**值.  
全局变量与局部变量在内存中的区别:  
全局变量保存在**内存的全局存储区**中，占用**静态**的存储单元；  
局部变量保存在**栈**中，只有在所在函数被调用时才**动态**地为变量分配存储单元。  
# 函数
在函数声明中，参数的名称并不重要，只有**参数的类型**是**必需**的，因此下面也是有效的声明：  
```c
int max(int, int);
```
在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是**必需**的。应该在调用函数的文件**顶部**声明函数。  
引用的声明以及调用:  
```c
extern void swap(int *x, int *y);
swap(&a, &b);
```
## **内部函数**
如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数前面加 **static**,即:  
```c
static int max(int a,int b){;}
```
内部函数又称静态函数。使用内部函数，可以使函数的作用域只**局限**于**所在文件**。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。  
## **外部函数**(**默认**)
如果在定义函数时，在函数的首部的最左端加关键字 **extern**，则此函数是外部函数，可供**其它文件调**用。即:  
```c
extern int max (int a,int b){;}
```
在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 **extern**，表示该函数是在其他文件中定义的外部函数。  
## **内联函数**
内联函数是使用 **inline** 关键字修饰的函数。内联函数在源代码中具有函数的结构，但在编译后不具备函数的性质，而是直接将函数体插入到每个调用处。内联函数的主要作用是消除函数调用时的时间开销，特别适合于频繁执行的小函数。  
# 操作符
**所有整数在C语言中都是以补码的形式**  
**补码为原码除符号位取反再加一**  
右移操作符:**\>\>**  
算数右移:右边丢弃,左边补原符号位  
逻辑右移:右边丢弃,左边补0  
无符号为逻辑位移,有符号数为算数右移.  
左移操作符:**\<\<**  
左边丢弃,右边补0  
**sizeof返回的数是无符号整型**  
因此与-1比较大小则-1会发生隐式类型转换,也会看做无符号数。  
**sizeof**内的式子不会进行计算.即:  
```c
short s = 0;
int a = 10;
printf("%I64d\n", sizeof(s = a + 5));
printf("%d\n", s);
```
结果:  
```text
2
0
```
**~**  
取反,包括符号位  
**&& \|\|**  
断路与断路或,即得出结果后就不再向后执行了  
```c
int i = 0, a = 1, b = 2, c = 3, d = 4;
i = a++ || ++b || d++;
printf("%d %d %d %d\n", a, b, c, d);
i = 0, a = 1, b = 2, c = 3, d = 4;
i = a++ && ++b && d++;
printf("%d %d %d %d\n", a, b, c, d);
```
结果:  
```text
2 2 3 4
2 3 3 5
```
# 数组
声明:  
```c
type arrayName [ arraySize ];
```
这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C 数据类型。  
```c
double balance[10];
```
初始化:  
```c
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```
大括号**{}**之间的值的数目不能大于在数组声明时在方括号**\[\]**中指定的元素数目。  
如果省略掉了数组的大小，数组的大小则为**初始化时元素的个数**。  
二维数组列不能省略,行则可以即:**a\[\]\[20\]**;  
**&arr** 为数组的地址,当使用**&arr+1**时跳过的地址为整个数组的大小.  
**sizeof(arr)**表示整个数组的大小  
**二维数组存放字符串，则在读取时当一维数组使用:**  
```c
#include<stdio.h>
int main(){
	int i;
	char names[6][50]={"马超","关平","赵云","张飞","关羽","刘备"};
	for(i=0;i<6;i++) {
		printf("悍将名称：%s\n",names[i]);
	}
    return 0;
}
```
**二维数组传递给函数**  
方法1: 第一维的长度可以不指定，但必须指定第二维的长度：  
```c
void print_a(int a[][5], int n, int m)
```
方法2: 指向一个有5个元素一维数组的指针：  
```c
void print_b(int (*a)[5], int n, int m)
```
方法3: 利用数组是顺序存储的特性,通过降维来访问原数组  
```c
void print_c(int *a, int n, int m)
```
如果知道二维数组的长度，当然选择第一或者第二种方式，但是长度不确定时，只能传入数组大小来遍历元素。  
