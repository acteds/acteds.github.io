---
layout: post
title: 并行流的相关问题
categories: Java
description: Java笔记
keywords: Java
---

# 引言

并行流的相关问题，顺序问题，以及多线程问题。

# Java

## Stream流

### 并行流

#### 顺序

并行流 (`parallelStream`) 并不保证元素的顺序。默认情况下，`parallelStream` 会分割任务并让多个线程并行处理数据，这样**处理顺序**是不可预测的，因此它无法保证结果的顺序。

**保证结果顺序：**

**使用顺序流**：如果你不特别需要并行处理，可以改为使用顺序流（即使用 `stream()` 而不是 `parallelStream()`），这样可以确保顺序不变。

```java
List<String> tableHeader = StreamSupport.stream(r.spliterator(), false)
        .map(Cell::getStringCellValue)
        .collect(Collectors.toList());
```

**使用 `collect` 时强制保序**：如果你坚持使用并行流，并且仍然需要保持顺序，可以在收集结果时使用 `Collectors.toList()`，因为它会**按顺序将流中的元素收集到列表**中，即使是并行流：

```java
List<String> tableHeader = StreamSupport.stream(r.spliterator(), true)
        .map(Cell::getStringCellValue)
        .collect(Collectors.toList());
```

还可以显示的在流的末尾使用 `sorted()` 或 `forEachOrdered()` 来强制保持顺序。

------

但是，**即使你使用 `Collectors.toList()`**，并行流的**内部执行顺序**仍然不可预测，即：

并行流在执行时不会保证操作的顺序。流中的操作可能会被多个线程并行执行，这样即使是 `map` 或 `filter` 这些按顺序执行的操作，在并行流中也可能会导致结果的顺序发生改变。

为什么并行流与 `Collectors.toList()` 保持顺序？

流的合并方式： 当使用 `parallelStream` 时，数据会被分割成多个片段，每个线程处理其中的一部分。每个片段中的操作是顺序的，但它们之间的合并顺序不一定保持一致。

`Collectors.toList()` 的行为：

 `Collectors.toList()` 是一个 无状态收集器，它只是将流中的元素收集到一个新的列表中。由于 `List` 是有顺序的容器，所以它会保持收集的顺序，即使是并行流。因为在 `parallelStream()` 的情况下，流会分割成多个子流，并行处理后最终合并，而合并时，`toList` 会保持各个子流处理后的顺序。

#### 多线程

并行流（`parallelStream`）是 Java 8 引入的功能，它通过分割数据源来使用多个线程并行地处理数据，从而提高处理速度。但并行流的多线程使用也带来了一些潜在的问题，特别是在以下几种情况下：

**线程安全问题**

并行流使用多个线程同时操作同一数据，这可能会引发线程安全问题。例如，如果你在流的操作中修改共享的可变对象，或者在 `collect` 操作中使用了非线程安全的集合，就可能会出现并发修改的问题。

解决方案：

- 对于共享的资源，确保线程安全。可以使用 `ConcurrentHashMap`、`CopyOnWriteArrayList` 等线程安全的集合。
- 使用 `synchronized` 或 `ThreadLocal` 来保证每个线程操作自己的副本。
- 避免在流中直接修改外部共享的状态，特别是在 `forEach` 操作中。

**状态不一致**

并行流中的一些操作可能会导致中间结果的不一致。例如，在并行流的某个操作中修改了共享状态，可能会造成中间状态在多个线程之间不一致，最终导致结果不正确。

解决方案：
- 避免修改流中的共享状态，尤其是不可变对象的状态。
- 使用不可变对象和线程本地数据来避免状态不一致。
- 对于需要修改状态的操作，确保该操作是原子性的。

**线程池饱和**
并行流会使用公共的 `ForkJoinPool` 来管理线程池。如果并行流的任务过多，线程池可能会耗尽，导致线程饱和，甚至阻塞其他任务。

解决方案：

- 可以通过设置系统属性 `java.util.concurrent.ForkJoinPool.common.parallelism` 来控制 `ForkJoinPool` 的线程池大小（默认为 `availableProcessors`）。
- 对于非常重的任务，考虑使用自定义的线程池，而不是依赖默认的公共线程池。


**示例代码：避免线程安全问题**

假设你在使用并行流时修改了共享的 `List`，这将导致线程安全问题：

```java
List<Integer> sharedList = new ArrayList<>();
List<Integer> data = Arrays.asList(1, 2, 3, 4, 5);

// 错误的并行流：会修改共享资源，造成线程安全问题
data.parallelStream().forEach(i -> sharedList.add(i));  // 不安全

// 正确的做法：使用线程安全的集合或避免共享资源
List<Integer> safeList = Collections.synchronizedList(new ArrayList<>());
data.parallelStream().forEach(i -> safeList.add(i));  // 安全
```

或者，避免在流操作中修改外部状态：

```java
// 错误的做法：修改外部共享状态
List<Integer> externalList = new ArrayList<>();
data.parallelStream().forEach(i -> externalList.add(i));  // 可能不安全

// 正确的做法：使用局部变量或者线程局部变量
ThreadLocal<List<Integer>> localList = ThreadLocal.withInitial(ArrayList::new);
data.parallelStream().forEach(i -> localList.get().add(i));  // 安全
```

并行流在适当的场景下可以显著提升性能，但如果使用不当，会导致性能问题或线程安全问题。为了安全高效地使用并行流：
- 确保流中的操作是线程安全的。
- 避免并行化不适合并行的任务。
- 处理数据时，确保操作的顺序性（如果需要的话）。
- 留意线程池资源限制和并行度的配置。

使用并行流时要权衡其带来的好处与潜在的复杂性和开销。

#### 使用场景

如果数据量小，使用 `parallelStream()` 仍然会开启多个线程，但在这种情况下，开多线程的开销可能大于并行处理带来的性能提升。`parallelStream()` 并不会自动判断数据量大小并决定是否启用并行。

详细解释：

1. **`parallelStream()` 的工作原理**： 
   `parallelStream()` 会将数据分成多个片段，并在不同的线程中并行处理这些片段。具体来说，它使用了 **`ForkJoinPool`** 来管理线程池，默认情况下，会根据 CPU 核心数来决定线程池的大小。

2. **线程开销**： 
   对于较小的数据量，线程的创建、上下文切换和管理等开销可能超过并行化处理所带来的性能提升。这是因为每个线程都有一定的启动成本，而如果数据量不够大，单线程的处理可能已经足够高效。

3. **`parallelStream()` 会开线程**： 
   即使数据量很小，调用 `parallelStream()` 依然会启动多个线程，具体线程数取决于 **`ForkJoinPool.commonPool()`** 的设置，默认情况下，它会根据机器的 **CPU 核心数** 来分配线程数。如果你的 CPU 核心数较多，`parallelStream()` 会使用多个线程来处理即使是小的数据集。

4. **性能评估**： 
   - 对于小数据集，**顺序流（`stream()`）** 往往比并行流更高效，因为线程开销、任务划分和合并等都增加了额外的成本。
   - 如果你有大量的数据并行处理，并且**数据量大于处理开销**，`parallelStream()` 的并行化处理可能会带来明显的性能提升。

结论：
- `parallelStream()` 不会自动判断数据量的大小。
- 即使数据量小，`parallelStream()` 仍会启动多个线程，但这可能会导致性能下降。
- 如果数据量较小，推荐使用顺序流（`stream()`），这样可以避免不必要的线程开销。

如果你的数据量较小，可以通过对比测试顺序流和并行流的性能，来决定是否使用并行流。

------

“**大**”和“**小**”数据量是相对的，具体取决于多种因素，包括数据的复杂性、处理任务的复杂度、硬件环境、并行化的开销等。没有一个固定的阈值来判断数据量是“大”还是“小”，但可以根据以下几个维度来理解和评估：

**数据量的维度**
   - **条目数**：指的是集合中元素的数量。比如，`List` 中有 1000 条数据，或者 10,000 条数据。
   - **元素大小**：每个数据项的大小。例如，每个数据项可能是一个简单的整数，或者包含多个字段和复杂的数据结构。

   **一般经验**：
   - 小数据量：通常为 1000 条以下的数据。
   - 中等数据量：大约 1000 到 100,000 条。
   - 大数据量：超过 100,000 条数据，尤其是需要做复杂计算时。

**操作的复杂度**
   - **简单操作**：例如对简单数据类型（如整数、字符串等）的求和、查找等操作。
   - **复杂操作**：例如对每个数据项进行复杂的计算、条件筛选、合并、排序、分组等操作。

   - **小数据量** 和 **简单操作**：并行流的开销不明显，可能没有必要使用 `parallelStream()`，使用顺序流更为高效。
   - **小数据量** 和 **复杂操作**：即使数据量小，复杂的操作可能使得并行化处理带来明显的性能提升。

**硬件和环境的影响**
   - **CPU 核心数**：计算机的核心数直接影响并行流的性能。如果只有 2 个核心，使用 4 个线程的并行流可能不会带来太多的性能提升，甚至可能因线程调度开销而影响性能。如果有 16 核或更多的 CPU，数据量更大时并行流的效果会更加明显。
   - **内存和 I/O 操作**：如果涉及到 I/O 操作（例如从数据库读取大量数据或进行网络请求），那么并行流的好处可能会受到系统 I/O 性能的限制。如果 CPU 处理时间是瓶颈，那么并行化会带来明显提升。

**性能评估：**
   - 对于 **小数据量** 和 **简单操作**，例如几百条数据的简单映射或过滤，顺序流通常更高效，因为创建和调度线程的开销可能超过并行处理的优势。
   - 对于 **大数据量** 或 **复杂操作**，如需要排序、大量计算或高复杂度的映射等，并行流能够有效利用多核 CPU 的并行处理能力，减少处理时间。

**经验法则**
   - **小数据量**：几百到几千条数据，建议使用 **顺序流**（`stream()`）。
   - **中等数据量**：几千到十几万条数据，使用 **顺序流** 和 **并行流** 性能相近，可以根据实际测试决定。
   - **大数据量**：超过十万条数据，特别是当数据量远大于 CPU 核心数时，使用 **并行流**（`parallelStream()`）通常能获得更好的性能。

**具体建议：**
   - **实验**：可以进行简单的性能测试，对比 **顺序流** 和 **并行流** 的执行时间，特别是在你的数据集和硬件环境下。对于小数据量，通常可以避免使用并行流。
   - **监控和调优**：在实际应用中，监控处理过程中的资源使用情况，如 CPU、内存等，并根据需要调整。

总结：
- **小数据量**：通常指几百到几千条数据，顺序流更高效。
- **大数据量**：通常指超过十万条数据，并且需要进行计算、排序等操作时，使用并行流能带来显著性能提升。
- 数据量“多”还是“少”没有严格标准，主要是看操作的复杂性和系统的硬件资源。在处理小数据量时，避免使用 `parallelStream()` 会更高效。

