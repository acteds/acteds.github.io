---
layout: post
title: Java-正则表达式
categories: [Java,正则表达式]
description: Java笔记
keywords: Java,正则表达式
---
# 引言
&emsp;&emsp;正则表达式在java中的应用，包括：分组匹配、搜索替换、分割、反向引用、后向引用、零宽断言、平衡组/递归匹配。       



# 正则表达式
&emsp;&emsp;正则表达式可以用字符串来描述规则，并用来匹配字符串。正则表达式是一套标准，它可以用于任何语言。Java标准库的`java.util.regex`包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。  
&emsp;&emsp;要判断用户输入的年份是否是`20##`年，先写出规则如下：  
&emsp;&emsp;一共有4个字符，分别是：`2`，`0`，`0~9任意数字`，`0~9任意数字`。  
&emsp;&emsp;对应的正则表达式就是：`20\d\d`，其中`\d`表示任意一个数字。  
&emsp;&emsp;把正则表达式转换为Java字符串就变成了`20\\d\\d`，注意Java字符串用`\\`表示`\`。  
```java
String regex = "20\\d\\d";
System.out.println("2019".matches(regex)); // true
System.out.println("2100".matches(regex)); // false
```
&emsp;&emsp;正则表达式的匹配规则是从左到右按规则匹配。  
&emsp;&emsp;如果正则表达式有特殊字符，那就需要用`\`转义。  
&emsp;&emsp;单字符的匹配规则：  

| 正则表达式 | 规则                                  |
| :--------- | :------------------------------------ |
| `A`        | 指定字符                              |
| `\u548c`   | 指定Unicode字符                       |
| `.`        | 任意字符                              |
| `\d`       | 数字0~9                               |
| `\w`       | 大小写字母，数字和下划线              |
| `\s`       | 任何不可见字符，等价于`[ \f\n\r\t\v]` |
| `\D`       | 非数字                                |
| `\W`       | 非\w                                  |
| `\S`       | 非\s                                  |

&emsp;&emsp;多字符的匹配规则：  

| 正则表达式 | 规则              |
| :--------- | :---------------- |
| `A*`       | 重复零次或更多次  |
| `A+`       | 重复一次或更多次  |
| `A?`       | 重复零次或一次    |
| `A{n}`     | 重复`n`次         |
| `A{n,}`    | 重复`n`次或更多次 |
| `A{n,m}`   | 重复`n`到`m`次    |

&emsp;&emsp;控制符：  

| 正则表达式         | 规则                                                         |
| :----------------- | :----------------------------------------------------------- |
| [ABC]              | 匹配`[]`内任意字符                                           |
| [A-F0-9xy]         | 指定范围的字符，`-`在`[]`里是连字符，表示指定范围            |
| [**^**A-F]         | 指定范围外的任意字符，`[^要排除的字符]`                      |
| AB**\|**CD**\|**EF | AB或CD或EF，`|`表示或，从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 |
| (...)              | 将子规则括起来，分组                                         |

## 分组匹配
&emsp;&emsp;用`Pattern`对象匹配，匹配后获得一个`Matcher`对象，如果匹配成功，就可以直接从`Matcher.group(index)`返回子串：  
```java
Pattern p = Pattern.compile("(\\d{3,4})-(\\d{7,8})");
Matcher m = p.matcher("010-12345678");
if (m.matches()) {
    String g0 = m.group(0);
    String g1 = m.group(1);
    String g2 = m.group(2);
    System.out.println(g0);//表示匹配的整个字符串
    System.out.println(g1);//表示第一个括号匹配的内容
    System.out.println(g2);//表示第二个括号匹配的内容
} else {
    System.out.println("匹配失败!");
}
```
&emsp;&emsp;控制台：  
```text
010-12345678
010
12345678
```
&emsp;&emsp;使用`Matcher`时，必须首先调用`matches()`判断是否匹配成功，匹配成功后，才能调用`group()`提取子串。  
&emsp;&emsp;还可以为每个括号打标签，格式`(? <标签名>)`，这种方式叫命名捕获组。  
```java
Pattern p = Pattern.compile("(?<f1>\\d{3,4})-(?<f2>\\d{7,8})");
Matcher m = p.matcher("010-12345678");
if (m.matches()) {
    String f1 = m.group("f1");
    String f2 = m.group("f2");
    System.out.println(f1);
    System.out.println(f2);
} else {
    System.out.println("匹配失败!");
}
```
## 非贪婪表达式
&emsp;&emsp;对于`+`，`*`，`{1,}`,这样的能匹配任意多字符的表达式，它总是尽可能多地向后匹配，即贪婪匹配。要让表达式变成非贪婪的，直接在后面加个`?`号即可。非贪婪匹配，是在保证整体匹配的情况下，尽量少匹配。  
&emsp;&emsp;对于`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索`aabab`的话，它会匹配整个字符串，这被称为**贪婪**匹配。  
&emsp;&emsp;有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下**使用最少的重复**。  
&emsp;&emsp;`a.*?b`匹配最短的，以`a`开始，以`b`结束的字符串。如果把它应用于`aabab`的话，它会匹配`aab`（第一到第三个字符）和`ab`（第四到第五个字符）。为什么第一个匹配是`aab`（第一到第三个字符）而不是`ab`（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权。  
## 搜索和替换
### 分割字符串
&emsp;&emsp;使用正则表达式分割字符串可以实现更加灵活的功能。  
```java
"a b c".split("\\s"); // { "a", "b", "c" }
"a b  c".split("\\s"); // { "a", "b", "", "c" }
"a, b ;; c".split("[\\,\\;\\s]+"); // { "a", "b", "c" }
```
### 搜索字符串
&emsp;&emsp;使用正则表达式还可以搜索字符串。  
```java
String s = "the quick brown fox jumps over the lazy dog.";
Pattern p = Pattern.compile("\\wo\\w");
Matcher m = p.matcher(s);
while (m.find()) {
    String sub = s.substring(m.start(), m.end());
    System.out.println(sub);
}
```
&emsp;&emsp;获取到`Matcher`对象后，不需要调用`matches()`方法（因为匹配整个串肯定返回false），而是反复调用`find()`方法，在整个串中搜索能匹配上`\\wo\\w`规则的子串，并打印出来。这种方式比`String.indexOf()`要灵活得多，搜索的规则是3个字符：中间必须是`o`，前后两个必须是字符`[A-Za-z0-9_]`。  
### 替换字符串
&emsp;&emsp;使用正则表达式替换字符串，可以直接调用`String.replaceAll()`，它的第一个参数是正则表达式，第二个参数是待替换的字符串。：  
```java
String s = "The     quick\t\t brown   fox  jumps   over the  lazy dog.";
String r = s.replaceAll("\\s+", " ");
System.out.println(r); // "The quick brown fox jumps over the lazy dog."
```
&emsp;&emsp;上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。  
### 反向引用
&emsp;&emsp;如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个`<b>xxxx</b>`，这个时候，使用`replaceAll()`的时候，传入的第二个参数可以使用`$1`、`$2`来反向引用匹配到的子串。  
```java
String s = "the quick brown fox jumps over the lazy dog.";
String r = s.replaceAll("\\s([a-z]{4})\\s", " <b>$1</b> ");
System.out.println(r);
```
&emsp;&emsp;上述代码的运行结果是：  
```text
the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.
```
&emsp;&emsp;它实际上把任何4字符单词的前后用`<b>xxxx</b>`括起来。实现替换的关键就在于`" <b>$1</b> "`，它用匹配的分组子串`([a-z]{4})`替换了`$1`。在这里不能使用命名捕获组。  
### 查找替换
&emsp;&emsp;`appendTail` 和 `appendReplacement` 是 `Matcher` 类的方法，用于处理正则表达式的匹配结果。  
- `appendReplacement` 方法用于将匹配到的内容替换为指定的字符串，并将替换后的结果追加到一个字符串缓冲区中，结果也包含匹配前的字符串。
- `appendTail` 方法用于将匹配操作的最后一次匹配后的**剩余字符串**追加到字符串缓冲区中。

```java
String template = "Hello, ${name}! You are learning ${lang}!";
Map<String, String> values = Map.of("name", "Bob", "lang", "Java");
StringBuilder result = new StringBuilder();
Matcher matcher = Pattern.compile("\\$\\{(.+?)}").matcher(template);
while (matcher.find()) {
    String key = matcher.group(1);
    String replacement = values.getOrDefault(key, "");
    matcher.appendReplacement(result, replacement);//替换为replacement并写入result；
}
matcher.appendTail(result);//将最后的!写入result.
System.out.println(result);
```
&emsp;&emsp;第一次循环匹配到的内容是`${name}`，替换为`Bob`，然后将替换后的字符串`Hello, Bob`写入`result`，第二次循环匹配到的内容是`${lang}`，替换为`Java`，然后将替换后的字符串`You are learning Java`追加到`result`中。最后通过`appendTail`方法写入最后一个匹配后面的所有字符串，在这个示例里指`!`这个字符。  
## 处理选项
&emsp;&emsp;在 Java 的正则表达式中，有许多标志可以用来修改正则表达式的行为。以下是常见的标志及其作用：  
1. `CASE_INSENSITIVE`（或 `i`）：忽略大小写，使匹配不区分大小写。
2. `MULTILINE`（或 `m`）：多行模式，**更改 `^` 和 `$` 的含义**，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。
3. `DOTALL`（或 `s`）：单行模式，**更改 `.` 的含义**，使它与每一个字符匹配（包括换行符 `\n`）。
4. `UNICODE_CASE`（或 `u`）：启用 Unicode 感知的大小写折叠，使某些 Unicode 字符的大小写折叠匹配更准确。
5. `CANON_EQ`：考虑规范等价性，使得在匹配过程中将规范等价的字符视为相同的字符。
6. `UNIX_LINES`：启用 Unix 行模式，使 `\n` 被视为换行符。
7. `LITERAL`：将模式作为字面值对待，而不进行解释或处理任何转义字符。
8. `COMMENTS`：允许在正则表达式中使用**空格和注释**。在这种模式下，你可以使用 `#` 符号开始注释，直到行尾。这样可以使正则表达式更易读。
9. `UNICODE_CHARACTER_CLASS`：启用 Unicode 字符类。在这种模式下，预定义字符类（如 `\d`, `\w`, `\s` 等）将与 Unicode 字符集一起工作，而不仅仅是 ASCII 字符集。这意味着 `\d` 将匹配任何 Unicode 数字字符，而不仅仅是 ASCII 数字字符。

&emsp;&emsp;可以使用这两个标志中的一个或两个，通过按位或 `|` 运算符将它们组合起来，然后将结果传递给 `Pattern.compile()` 方法，以创建具有所需行为的正则表达式模式。  
&emsp;&emsp;这些标志可以单独使用，也可以组合使用，例如可以使用 `CASE_INSENSITIVE | MULTILINE` 来同时忽略大小写并启用多行模式。在 Java 中，这些标志可以通过在**正则表达式字符串前面**加上 `(?...)` 来指定，例如 `(?i)` 表示忽略大小写。  
&emsp;&emsp;在 `Pattern.compile()` 方法中，可以使用 `|` 运算符将多个标志组合在一起。例如，要同时使用忽略大小写和多行模式，可以这样写：  
```java
Pattern pattern = Pattern.compile("^start", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
```
&emsp;&emsp;这将创建一个模式，该模式将匹配以 `start` 开头的任何行，不区分大小写。  
&emsp;&emsp;一个经常被问到的问题是：是不是只能同时使用多行模式和单行模式中的一种？答案是：不是。这两个选项之间没有任何关系，除了它们的名字比较相似（以至于让人感到疑惑）以外。事实上，为了避免混淆，在最新的 JavaScript 中，单行模式其实名叫 `dotAll`，意为点可以匹配所有字符，然而在指定该选项时，用的还是 `Singleline` 的首字母 `s`.  
## 高级
**本身不匹配字符**的界定符表达式，即零宽断言：

| 正则表达式 | 规则                             |
| ---------- | -------------------------------- |
| ^          | 字符串开头，如果为多行则为行开头 |
| $          | 字符串结尾，如果为多行则为行结尾 |
| `\b`       | 单词的开头或结尾。               |
| `\B`       | 匹配不是单词开头或结束的位置。   |

&emsp;&emsp;实例：正则：`h(\B\w+\B)a (\1)`，文本：`haha ah`，**组1内容为`ah`**,组2内容为`ah`，`(\B\w+\B)`中的`\B`会检测前后不是单词分隔，因此不会匹配`haha`而是匹配`ah`,`\1`则是引用前面括号的内容。如果正则改为`(\B\w+\B) (\1)`，则整个表达式会无法匹配，因为中间有个`a`没有匹配。  
### 后向引用
&emsp;&emsp;使用小括号指定一个子表达式后，**匹配这个子表达式的文本**可以在表达式或其它程序中作进一步的处理。  
&emsp;&emsp;默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。  
&emsp;&emsp;实际上组号分配过程是要从左向右扫描两遍的：第一遍只给**未命名组**分配，第二遍只给**命名组**分配，因此所有命名组的组号都大于未命名的组号。分组0对应整个正则表达式匹配的内容。  
&emsp;&emsp;**后向引用**用于重复搜索前面某个分组匹配的文本。例如，`\1`代表分组1匹配的文本。  
&emsp;&emsp;`(\b\w+\b)\s+\1`可以用来匹配重复的单词，像`go go`, 或`kitty kitty`。这个表达式首先是一个单词，即`(\b(\w+)\b)`，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符`(\s+)`，最后是匹配分组1中捕获的内容`(\1)`。  
&emsp;&emsp;也可以自己指定子表达式的**组名**：`(?<Word>\w+)`(把尖括号换成`'`也行：`(?'Word'\w+)`,这样就把`\w+`的**组名指定**为Word了。  
&emsp;&emsp;要**反向引用**这个分组**捕获**的内容，可以使用`\k<Word>`，也可以使用`\k'Word'`,所以上一个例子也可以写成这样：`(?<Word>\b\w+\b)\s+\k<Word>\b`。  
&emsp;&emsp;使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：  

| **分类** | **代码/语法**  | **说明**                                                     |
| -------- | -------------- | ------------------------------------------------------------ |
| 捕获     | `(exp)`        | 匹配内容`exp`,**自动命名组**。                               |
| 捕获     | `(?<name>exp)` | 匹配内容`exp`,**名称为`name`的组**，也可以写成`(?'name'exp)` |
| 捕获     | `(?:exp)`      | 匹配内容`exp`,但**不给此分组分配组号**，即无法引用           |
| 反向引用 | `\1`           | 自动分组1匹配的文本，`\2`以此类推。                          |
| 反向引用 | `\k<name>`     | 命名分组**name**匹配的文本，也可以写成`\k'name'`             |
| 零宽断言 | `(?=exp)`      | 保证此语句后面，有匹配**表达式`exp`所匹配内容**的权利。      |
| 零宽断言 | `(?<=exp)`     | 保证此语句前面，有匹配**表达式`exp`所匹配内容**的权利。      |
| 零宽断言 | `(?!exp)`      | 匹配后面**跟的不是**`exp`的位置                              |
| 零宽断言 | `(?<!exp)`     | 匹配**前面不是**`exp`的位置                                  |
| 注释     | `(?#comment)`  | 提供注释让人阅读，java不支持。                               |

### 零宽断言
&emsp;&emsp;接下来的四个用于**检测**内容，内容应该满足一定的条件(即断言)，因此它们也被称为**零宽断言**。  
&emsp;&emsp;文本：`I'm singing while you're dancing.`  
#### `(?=exp)`
&emsp;&emsp;`(?=exp)`也叫**零宽度正预测先行断言**，它保证此语句后面，有匹配**表达式`exp`所匹配内容**的权利。  
&emsp;&emsp;例如：  
&emsp;&emsp;`(\w+)(?=ing)(\w+)`，`(?=ing)`表示后面的语句必须还有匹配`ing`的权利，因此`singing`和`dancing`可以匹配，匹配`singing`的1组为：`sing`，2组为：`ing`，匹配`dancing`的1组为：`danc`，2组为：`ing`。  
&emsp;&emsp;如果去掉后面的`(\w+)`，即变成`(\w+)(?=ing)`，匹配`singing`的1组也不会变成`singing`,因为`(?=ing)`要保证后面的语句还有匹配`ing`的权利，`(?=ing)`限制了贪婪表达式的权利，1组还是匹配`sing`。对于`dancing`同理，1组还是匹配`danc`。  
&emsp;&emsp;如果去掉前面的`\w+`，即变成`()(?=ing)(\w+)`，匹配`singing`的2组也不会变成`singing`,因为`(?=ing)`要保证后面的语句还有**匹配**`ing`的权利，因此字符`s`由于这条规则被跳过了，最后匹配为`inging`。对于`dancing`同理，2组匹配`ing`。  
&emsp;&emsp;详细来说，`(?=ing)`首先在文本里找`ing`，第一处开始索引为5，在这之前的字符串`I'm s`就被跳过了，从索引5开始的字符串`inging while you're dancing.`丢给后续表达式匹配。所以`\w+`匹配了`inging`，对于未处理的部分继续循环操作，然后继续查找`ing`，第二处在索引29，所以`\w+`匹配了`ing`。  
#### `(?<=exp)`
&emsp;&emsp;`(?<=exp)`也叫**零宽度正回顾后发断言**，它保证此语句前面，有匹配**表达式`exp`所匹配内容**的权利。  
&emsp;&emsp;例如：  
&emsp;&emsp;`(\w+)(?<=ing)(\w+)`,因此只有`singing`可以匹配，1组为：`sing`，2组为：`ing`，1组为什么不能是`singing`，实际上是可以的，但这样做了2组就没得匹配了，导致整个式子不匹配了。为什么`dancing`不能匹配呢，因为`(?<=ing)`保证前面的语句有匹配`ing`的权利，因此对于`dancing`来说1组为`dancing`，2组没内容了，因此整个表达式不成立。  
&emsp;&emsp;如果去掉前面的`\w+`，即变成`()(?<=ing)(\w+)`，匹配`singing`的2组也不会变成`singing`,因为`(?<=ing)`要保证前面的语句还有**匹配**`ing`的权利，因此字符`sing`由于这条规则被跳过了，最后匹配还是为`ing`。  
&emsp;&emsp;如果把二组改成`(\.)`,即变成`()(?<=ing)(\.)`，则可以匹配`dancing`后面的`.`号，让整个表达式成立。  
&emsp;&emsp;如果去掉后面的`(\w+)`，即变成`(\w+)(?<=ing)`,则对于`(\w+)`,就可以匹配`singing`和`dancing`了，也就是说本来`(\w+)`可以匹配所有单词，由于`(?<=ing)`的限制，单词结尾必须为`ing`。这样就变成与`(\w+ing)`一样了。实际上对于`(\w+)(?<=ing)(\w+)`和`(\w+ing)(\w+)`没什么区别，但对于`()(?<=ing)(\w+)`就**不是**`(ing)(\w+)`了。  
#### 运用
&emsp;&emsp;利用零宽断言，可以实现之前不可能实现的功能，比如为数字每三位添加一个`,`号。你可能想到  
```java
String input = "234567890";
Pattern pattern = Pattern.compile("(\\d{3})");
Matcher matcher = pattern.matcher(input);
StringBuffer result = new StringBuffer();
while (matcher.find()) {
    matcher.appendReplacement(result, matcher.group(1) + ",");
}
matcher.appendTail(result);
System.out.println(result);
```
&emsp;&emsp;控制台：`234,567,890,`，似乎也还可以，但数字长度如果不是3的倍数就会出问题了：`String input = "1234567890";`，控制台：`123,456,789,0`。使用零宽断言可以解决这个问题：  
```java
String input = "1234567890";
Pattern pattern = Pattern.compile("(\\d{1,3})(?=(\\d{3})+$)");
Matcher matcher = pattern.matcher(input);
StringBuffer result = new StringBuffer();
while (matcher.find()) {
    matcher.appendReplacement(result, matcher.group(1) + ",");
}
matcher.appendTail(result);
System.out.println(result);
```
&emsp;&emsp;控制台：`1,234,567,890`。  
&emsp;&emsp;对于正则`(\d{1,3})(?=(\d{3})+$)`部分解释如下：  
&emsp;&emsp;第一个括号就不用说了，`(?=(\d{3})+$)`表示后面应该符合`(\d{3})+$`这个正则。`(\d{3})+$`即匹配长度是3的倍数的数字，匹配完后必须是字符串结尾。  
&emsp;&emsp;对于第一次查询，`(\d{1,3})`取得数字`1`，之后的`234567890`符合这个要求。  
&emsp;&emsp;对于第二次查询，`(\d{1,3})`取得数字`234`，之后的`567890`符合这个要求。  
&emsp;&emsp;对于第三次查询，`(\d{1,3})`取得数字`567`，之后的`890`符合这个要求。  
&emsp;&emsp;对于第四次查询，`(\d{1,3})`取得数字`890`，之后没有了，不符合零宽断言要求，因此不执行了，所以890后面也不会多出一个`,`号了。  
&emsp;&emsp;如果`String input = "一共1234567890美元";`，则正则需要修改为`(\d{1,3})(?=(\d{3})+(?!\d))`，控制台：`一共1,234,567,890美元`，也就是将`$`修改为了`(?!\d)`，表示后面没有数字了，这看起来和`(?=exp)`很像，其实就是它的反面，也就是说`(?!\d)`等于`(?=[^\d])`，而`[^\d]`又能变成`\D`。  
#### `(?!exp)`
&emsp;&emsp;`(?!exp)`也叫**零宽度负预测先行断言**，它保证此语句后面，有**不**匹配**表达式`exp`所匹配内容**的权利。  
&emsp;&emsp;对于`(?!\d)`等于`(?=[^\d])`。如果`exp`比较复杂就不能转换了，比如对于：`(?!(\d{3})+$)`,表示后面不符合`(\d{3})+$`，要准确转换为`(?=exp)`，不怎么可能。  
#### `(?<!exp)`
&emsp;&emsp;`(?<!exp)`也叫**零宽度负回顾后发断言**，它保证此语句前面，有**不**匹配**表达式`exp`所匹配内容**的权利。  
&emsp;&emsp;对于`(?<!\d)`等于`(?<=[^\d])`。  
#### 运用
&emsp;&emsp;利用零宽断言，可以实现之前不可能实现的功能。  
&emsp;&emsp;文本：`singing while dancnig`  
&emsp;&emsp;我希望匹配不是以`ing`结尾的词，即匹配`while`和`dancnig`。  
&emsp;&emsp;如果不使用零宽断言，你可能写出：`\b(\w+)([^ing])\b`，但它匹配了`singing `，第二组匹配的是空格,因为`[^ing]`实际上表示匹配**一个**不是`i`和`n`还有`g`的字符，因此还会额外消耗一个字符。  
&emsp;&emsp;那么改成`\b(\w+)(ing)\b`？匹配了`sing`，额外消耗了3个字符。  
&emsp;&emsp;那么改成`\b(\w+)(ing)?\b`匹配了全部。  
&emsp;&emsp;因此只要不使用零宽断言就不可能达成目的。  
&emsp;&emsp;如果使用`(?=exp)`,可以写出:`\b(\w+(?=[^ing]{3})[\w]{3})\b`,但`while`和`dancnig`也被排除了，因为`ile`的`i`被`[^ing]`排除匹配了。  
&emsp;&emsp;只能使用`(?!exp)`了，可以写出:`\b(\w+(?!ing)[\w]{3})\b`,非常简单的达成目标了。  
### 平衡组/递归匹配

&emsp;&emsp;有时我们需要匹配像`( 100 * ( 50 + 15 ) )`这样的可嵌套的层次性结构，这时简单地使用`\(.+\)`则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如`( 5 / ( 3 + 2 ) ) )`，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，**配对**的括号之间的内容呢？  
&emsp;&emsp;为了避免`(`和`\(`把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把`xx <aa <bbb> <bbb> aa> yy`这样的字符串里，最长的配对的尖括号内的内容捕获出来？  

&emsp;&emsp;这里需要用到以下的语法构造：  
- `(?'group')` 把捕获的内容命名为group,并压入**堆栈(Stack)**
- `(?'-group')` 从堆栈上**弹出最后**压入堆栈的名为`group`的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- `(?(group)yes|no)` 如果堆栈上**存在**以名为`group`的捕获内容的话，继续匹配`yes`部分的表达式，否则继续匹配`no`部分
- `(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

&emsp;&emsp;我们需要做的是每碰到了左括号，就在压入一个`Open`,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。  
```batch
<                   #最外层的左括号
  [^<>]*            #它后面非括号的内容
  (
      (
        (?'Open'<)  #左括号，压入"Open"
        [^<>]*      #左括号后面的内容
      )+
      (
        (?'-Open'>) #右括号，弹出一个"Open"
        [^<>]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的"Open"
                    #则匹配失败
>                #最外层的右括号
```
&emsp;&emsp;注意：java中不支持。  
&emsp;&emsp;平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的`<div>`标签：`<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>`.  
### 其他

| 代码/语法         | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| `\a`              | 报警字符(打印它的效果是电脑嘀一声)                           |
| `\b`              | 通常是单词分界位置，但如果在字符类里使用代表退格             |
| `\t`              | 制表符，Tab                                                  |
| `\r`              | 回车                                                         |
| `\v`              | 竖向制表符                                                   |
| `\f`              | 换页符                                                       |
| `\n`              | 换行符                                                       |
| `\e`              | Escape                                                       |
| `\0nn`            | ASCII代码中八进制代码为nn的字符                              |
| `\xnn`            | ASCII代码中十六进制代码为nn的字符                            |
| `\unnnn`          | Unicode代码中十六进制代码为nnnn的字符                        |
| `\cN`             | ASCII控制字符。比如\cC代表Ctrl+C                             |
| `\A`              | 字符串开头(类似^，但不受处理多行选项的影响)                  |
| `\Z`              | 字符串结尾或行尾(不受处理多行选项的影响)                     |
| `\z`              | 字符串结尾(类似$，但不受处理多行选项的影响)                  |
| `\G`              | 当前搜索的开头                                               |
| `\p{name}`        | Unicode中命名为name的字符类，例如\p{IsGreek}                 |
| `(?>exp)`         | 贪婪子表达式，它会尽可能多地匹配`exp`，不会回溯。            |
| `(?<x>-<y>exp)`   | 平衡组，用于匹配一个字符串，其中`x`和`y`是平衡符号（通常是括号），`exp`是要匹配的内容。它可以用来匹配嵌套的结构，如HTML标签。 |
| `(?im-nsx:exp)`   | 在子表达式`exp`中改变处理选项，`i`表示不区分大小写，`m`表示多行模式，`n`表示禁止捕获，`s`表示将`.`视为匹配任何字符（包括换行符），`x`表示忽略空白和注释。 |
| `(?im-nsx)`       | 为表达式后面的部分改变处理选项，与上面类似。                 |
| `(?(exp)yes|no)`  | 把`exp`当作零宽正向先行断言，如果在这个位置能匹配，使用`yes`作为此组的表达式；否则使用`no`。 |
| `(?(exp)yes)`     | 同上，只是使用空表达式作为`no`。                             |
| `(?(name)yes|no)` | 如果命名为`name`的组捕获到了内容，使用`yes`作为表达式；否则使用`no`。 |
| `(?(name)yes)`    | 同上，只是使用空表达式作为`no`。                             |
