# Java Web

对于Browser来说，请求页面的流程如下：

1. 与服务器建立TCP连接；
2. 发送HTTP请求；
3. 收取HTTP响应，然后把网页在浏览器中显示出来。

浏览器发送的HTTP请求如下：

```
GET / HTTP/1.1
Host: www.sina.com.cn
User-Agent: Mozilla/5.0 xxx
Accept: */*
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8
```

其中，第一行表示使用`GET`请求获取路径为`/`的资源，并使用`HTTP/1.1`协议，从第二行开始，每行都是以`Header: Value`形式表示的HTTP头，比较常用的HTTP Header包括：

- Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；
- User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似`Mozilla/5.0 ... Chrome/79`，IE浏览器的标识类似`Mozilla/5.0 (Windows NT ...) like Gecko`；
- Accept：表示浏览器能接收的资源类型，如`text/*`，`image/*`或者`*/*`表示所有；
- Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；
- Accept-Encoding：表示浏览器可以支持的压缩类型，例如`gzip, deflate, br`。

服务器的响应如下：

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 21932
Content-Encoding: gzip
Cache-Control: max-age=300

<html>...网页数据...
```

服务器响应的第一行总是版本号+空格+数字+空格+文本，数字表示响应代码，其中`2xx`表示成功，`3xx`表示重定向，`4xx`表示客户端引发的错误，`5xx`表示服务器端引发的错误。数字是给程序识别，文本则是给开发者调试使用的。常见的响应代码有：

- 200 OK：表示成功；
- 301 Moved Permanently：表示该URL已经永久重定向；
- 302 Found：表示该URL需要临时重定向；
- 304 Not Modified：表示该资源没有修改，客户端可以使用本地缓存的版本；
- 400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；
- 401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；
- 403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；
- 404 Not Found：表示客户端请求了一个不存在的资源；
- 500 Internal Server Error：表示服务器处理时内部出错，例如因为无法连接数据库；
- 503 Service Unavailable：表示服务器此刻暂时无法处理请求。

从第二行开始，服务器每一行均返回一个HTTP头。服务器经常返回的HTTP Header包括：

- Content-Type：表示该响应内容的类型，例如`text/html`，`image/jpeg`；
- Content-Length：表示该响应内容的长度（字节数）；
- Content-Encoding：表示该响应压缩算法，例如`gzip`；
- Cache-Control：指示客户端应如何缓存，例如`max-age=300`表示可以最多缓存300秒。

HTTP请求和响应都由HTTP Header和HTTP Body构成，其中HTTP Header每行都以`\r\n`结束。如果遇到两个连续的`\r\n`，那么后面就是HTTP Body。浏览器读取HTTP Body，并根据Header信息中指示的`Content-Type`、`Content-Encoding`等解压后显示网页、图像或其他内容。

通常浏览器获取的**第一个资源是HTML网页**，在网页中，如果嵌入了JavaScript、CSS、图片、视频等其他资源，浏览器会根据资源的URL**再次**向服务器请求对应的资源。

Browser/Server模式，简称BS架构，基本过程是：

浏览器请求一个URL，服务器就把生成的HTML网页发送给浏览器，而浏览器和服务器之间的传输协议是HTTP。浏览器根据网页的url继续请求获取网页需要的资源，比如图片等

HTTP协议是一个基于TCP协议之上的请求-响应协议，也就是说，本质是一个TCP连接，然后根据HTTP协议的规定，规范化处理交互的内容，就是分析HTTP body 和 header，实现就是使用`ServeSocket`，而对于HTML浏览器会自己解析，因此只要保证通信、负责传输HTML内容到客户端本地就行。

## 编写HTTP Server

一个HTTP Server本质上是一个TCP服务器，用TCP编程的多线程实现的服务器端框架：

```java
try (ServerSocket server = new ServerSocket(8080)) {
    System.out.println("服务器正在运行。");
    for (; ; ) {
        Socket sock = server.accept();
        System.out.println("连接来自：" + sock.getRemoteSocketAddress());
        Thread t = new WebPage(sock);
        t.start();
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

处理：

```java
class WebPage extends Thread{
    private Socket socket;

    public WebPage(Socket socket) {
        this.socket = socket;
    }
    @Override
    public void run() {
        try (InputStream input = this.socket.getInputStream()) {
            try (OutputStream output = this.socket.getOutputStream()) {
                handle(input, output);
            }
            System.out.println("客户端已断开连接。");
        } catch (Exception e) {}
    }
    private void handle(InputStream in,OutputStream out) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));
        // 读取HTTP请求:
        boolean requestOk = false;
        String first = reader.readLine();
        if (first.startsWith("GET / HTTP/1.")) {
            requestOk = true;
        }
        for (;;) {
            String header = reader.readLine();
            if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕
                break;
            }
            System.out.println(header);
        }
        System.out.println(requestOk ? "响应正常" : "响应错误");
        if (!requestOk) {
            // 发送错误响应:
            writer.write("HTTP/1.0 404 Not Found\r\n");
            writer.write("Content-Length: 0\r\n");
            writer.write("\r\n");
            writer.flush();
        } else {
            // 发送成功响应:
            String data = "<html><body><h1>Hello, world!</h1></body></html>";
            int length = data.getBytes(StandardCharsets.UTF_8).length;
            writer.write("HTTP/1.0 200 OK\r\n");
            writer.write("Connection: close\r\n");
            writer.write("Content-Type: text/html\r\n");
            writer.write("Content-Length: " + length + "\r\n");
            writer.write("\r\n"); // 空行标识Header和Body的分隔
            writer.write(data);
            writer.flush();
        }
    }
}
```

只处理了`GET /`的请求。当读取到空行时，表示已读到连续两个`\r\n`，说明请求结束，可以发送响应。发送响应时，先发送响应代码`HTTP/1.0 200 OK`表示一个成功的200响应，使用`HTTP/1.0`协议。然后，依次发送Header，发送完Header后，再发送一个空行标识Header结束，紧接着发送HTTP Body。

HTTP目前有多个版本，`1.0`是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应，这样就大大提高了传输效率。

HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？HTTP 2.0可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。

HTTP 3.0为了进一步提高速度，将抛弃TCP协议，改为使用无需创建连接的UDP协议，目前HTTP 3.0仍然处于实验阶段。

## Servlet

编写HTTP服务器其实是非常简单的，只需要先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应即可。

但是，要编写一个完善的HTTP服务器，以HTTP/1.1为例，需要考虑的包括：

- 识别正确和错误的HTTP请求；
- 识别正确和错误的HTTP头；
- 复用TCP连接；
- 复用线程；
- IO异常处理；
- ...

这些基础工作需要耗费大量的时间，并且经过长期测试才能稳定运行。如果只需要输出一个简单的HTML页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发。

因此，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，然后只需要把自己的应用程序跑在Web服务器上。为了实现这一目的，JavaEE提供了Servlet API，使用Servlet API编写自己的Servlet来处理HTTP请求，Web服务器实现Servlet API接口，实现底层功能。

实现一个最简单的Servlet：

```java
@WebServlet("/")// WebServlet注解表示这是一个Servlet，并映射到地址/:
public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("text/html");// 设置响应类型
        resp.getWriter().write("<h1>Hello, world!</h1>");// 获取输出流，并写入。
        resp.getWriter().flush();//强制输出
    }
}
```

`@WebServlet("/")`也可以在`Web.xml`里配置：

```xml
<servlet>
    <servlet-name>hello</servlet-name>
    <servlet-class>test.MyServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>hello</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

一个Servlet总是继承自`HttpServlet`，然后覆写`doGet()`或`doPost()`方法。注意到`doGet()`方法传入了`HttpServletRequest`和`HttpServletResponse`两个对象，分别代表HTTP请求和响应。使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为`HttpServletRequest`和`HttpServletResponse`就已经封装好了请求和响应。以发送响应为例，只需要设置正确的响应类型，然后获取`PrintWriter`，写入响应即可。

Servlet API是一个jar包，需要通过Maven来引入它，才能正常编译。`pom.xml`文件的打包类型需要设置为`war`。并引入依赖：

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```

`<scope>`指定为`provided`，表示编译时使用，但不会打包到`.war`文件中，因为运行期Web服务器本身已经提供了Servlet API相关的jar包。

4.0及之前版本的`servlet-api`由Oracle官方维护，而5.0及以后的`servlet-api`由Eclipse开源社区维护，引入的依赖项是`jakarta.servlet`，对于很多仅支持Servlet 4.0版本的框架来说，例如Spring 5，就只能使用`javax.servlet:4.0.0`版本。

目录结构为：

```ascii
Maven
│  pom.xml
│
├─src
│  ├─main
│  │  ├─java
│  │  │  └─test
│  │  │          MyServlet.java
│  │  │
│  │  ├─resources
│  │  │
│  │  └─webapp
│  │      │  index.jsp
│  │      │
│  │      └─WEB-INF
│  │              web.xml
│  │
│  └─test
│      ├─java
│      └─resources
│
└─target
```

运行Maven命令`mvn clean package`，在`target`目录下得到一个`war`文件，这个文件就是编译打包后的Web应用程序。

如果使用mvn clean package报错信息中有类似

`org.apache.maven.plugins 的Due to ..... Cannot access defaults field of Properties`错误（war打包问题）

在pom.xml中指定package插件的版本即可:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.3.2</version>
        </plugin>
    </plugins>
</build>
```

maven-war-plugin插件会自动使用main-webapp-WEB-INF-web.xml文件作为配置文件。也可以自己在pom.xml中进行配置:

```xml
    <build>
        <finalName>打包的名字</finalName>
<!-- 如果使用maven-war-plugin默认配置则不需要配-->
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-war-plugin</artifactId>
                    <version>2.2</version>
                    <configuration>
                        <webXml>webapp\WEB-INF.xml</webXml>
                        <!-- 指定jsp、js、css的路劲 -->
<!--                        <warSourceDirectory>WebRoot</warSourceDirectory>-->
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
```

------

普通的Java程序是通过启动JVM，然后执行`main()`方法开始运行。但是Web应用程序有所不同，我们无法直接运行`war`文件，必须先启动Web服务器，再由Web服务器加载我们编写的`HelloServlet`，这样就可以让`HelloServlet`处理浏览器发送的请求。

因此，首先要找一个支持Servlet API的Web服务器。常用的服务器有：

- [Tomcat](https://tomcat.apache.org/)：由Apache开发的开源免费服务器；
- [Jetty](https://www.eclipse.org/jetty/)：由Eclipse开发的开源免费服务器；
- [GlassFish](https://javaee.github.io/glassfish/)：一个开源的全功能JavaEE服务器。

还有一些收费的商用服务器，如Oracle的[WebLogic](https://www.oracle.com/middleware/weblogic/)，IBM的[WebSphere](https://www.ibm.com/cloud/websphere-application-platform/)。

无论使用哪个服务器，只要它支持对应版本的Servlet API ，war包都可以在上面运行。

要运行`war`文件，首先要[下载Tomcat服务器](https://tomcat.apache.org/download-90.cgi)，解压后，把`war`复制到Tomcat的`webapps`目录下，然后切换到`bin`目录，执行`startup.sh`或`startup.bat`启动Tomcat服务器。然后通过浏览器访问`http://127.0.0.1:8080/war文件名称/`即可。

一个Web服务器允许同时运行多个Web App，因此，第一级目录`/war文件名称`表示Web App的名字，后面的`/`才是在项目中映射的servlet路径。

那能不能直接使用`/`？答案是肯定的。先关闭Tomcat（执行`shutdown.sh`或`shutdown.bat`），然后删除Tomcat的webapps目录下的所有文件夹和文件，最后把自己的`war`文件复制过来，改名为`ROOT.war`，文件名为`ROOT`的应用程序将作为默认应用，启动后直接访问`http://127.0.0.1:8080/`即可。

Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机，执行Tomcat的`main()`方法，然后由Tomcat负责加载`.war`文件，实例化Servlet。如果Tomcat服务器收到的请求路径是`/`（假定部署文件为ROOT.war），就转发到`HelloServlet`并传入`HttpServletRequest`和`HttpServletResponse`两个对象。编写的Servlet并不是直接运行，而是由Web服务器加载后创建实例运行，所以，类似Tomcat这样的Web服务器也称为Servlet容器。

由于Servlet版本分为<=4.0和>=5.0两种，所以，要根据使用的Servlet版本选择正确的Tomcat版本。从[Tomcat版本页](https://tomcat.apache.org/whichversion.html)可知：

- 使用Servlet<=4.0时，选择Tomcat 9.x或更低版本；
- 使用Servlet>=5.0时，选择Tomcat 10.x或更高版本。

在Servlet容器中运行的Servlet具有如下特点：

- 无法在代码中直接通过new创建Servlet实例，必须由Servlet容器自动创建Servlet实例；
- Servlet容器只会给每个Servlet类创建唯一实例；
- Servlet容器会使用多线程执行`doGet()`或`doPost()`方法。

线程安全问题：

- 在Servlet中定义的实例变量会被多个线程同时访问，要注意线程安全；
- `HttpServletRequest`和`HttpServletResponse`实例是由Servlet容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；
- 在`doGet()`或`doPost()`方法中，如果使用了`ThreadLocal`，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为Servlet容器很可能用线程池实现线程复用。

**在IDEA中配置Tomcat运行调试：**

运行调试窗口-添加Tomcat服务器-本地，配置-选择本地Tomcat路径。

项目结构窗口-工件-添加-Web应用程序（展开或者归档都行）-基于模块。

运行调试窗口-Tomcat服务器-部署选项卡-添加工件-设置映射的网址。

**使用Tomcat的jar包运行调试：**

Tomcat的启动流程：

1. 启动JVM并执行Tomcat的`main()`方法；
2. 加载war并初始化Servlet；
3. 正常服务。

启动Tomcat无非就是设置好classpath并执行Tomcat某个jar包的`main()`方法，完全可以把Tomcat的jar包全部引入进来，然后自己编写一个`main()`方法，先启动Tomcat，然后让它加载我们的webapp就行。

添加依赖：

```xml
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-core</artifactId>
    <version>9.0.26</version>
    <scope>provided</scope>
</dependency>
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
    <version>9.0.26</version>
    <scope>provided</scope>
</dependency>
```

Servlet API可以不用显示引用，因为引入Tomcat依赖后自动引入了Servlet API。

可以编写一个`main()`方法，启动Tomcat服务器：

```java
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 设置Tomcat的端口号，默认为8080
        tomcat.setPort(Integer.getInteger("port", 8080));
        // 获取Tomcat的连接器
        tomcat.getConnector();

        // 将webapp添加到Tomcat，路径为src/main/webapp
        Context ctx = tomcat.addWebapp(
                "",
                new File("src/main/webapp").getAbsolutePath()
        );
        // 创建Web资源根目录
        WebResourceRoot resources = new StandardRoot(ctx);
        // 添加预设资源，包括类路径和WEB-INF目录
        resources.addPreResources(
                new DirResourceSet(
                        resources,
                        "/WEB-INF/classes",
                        new File("target/classes").getAbsolutePath(),
                        "/"
                )
        );
        // 设置Web应用的资源
        ctx.setResources(resources);
        // 启动Tomcat
        tomcat.start();
        // 等待Tomcat服务器结束
        tomcat.getServer().await();
    }
```

使用IDEA时需要注意设置：在`运行调试`窗口的`构建并运行`栏，右边的`修改选项`勾选`将带有"provided"作用域的依赖项添加到类路径`。

这样，直接运行`main()`方法，即可启动嵌入式Tomcat服务器，然后，通过预设的`tomcat.addWebapp("", new File("src/main/webapp")`，Tomcat会自动加载当前工程作为根webapp，可直接在浏览器访问`http://localhost:8080/`。

通过`main()`方法启动Tomcat服务器并加载自己的webapp有如下好处：

1. 启动简单，无需下载Tomcat或安装任何IDE插件；
2. 调试方便，可在IDE中使用断点调试；
3. 使用Maven创建war包后，也可以正常部署到独立的Tomcat服务器中。



**生成可执行war包**

如果要生成可执行的war包，用`java -jar xxx.war`启动，则需要把Tomcat的依赖项的`<scope>`设置为compile，然后配置`maven-war-plugin`如下：

```xml
<build>
    <finalName>hello</finalName>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.3.2</version>
            <configuration>
                <!-- 复制classes到war包根目录 -->
                <webResources>
                    <resource>
                        <directory>${project.build.directory}/classes</directory>
                    </resource>
                </webResources>
                <archiveClasses>true</archiveClasses>
                <archive>
                    <manifest>
                        <!-- 添加Class-Path -->
                        <addClasspath>true</addClasspath>
                        <!-- Classpath前缀 -->
                        <classpathPrefix>tmp-webapp/WEB-INF/lib/</classpathPrefix>
                        <!-- main所在的启动类 -->
                        <mainClass>test.Main</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
```

生成的war包结构如下：

```ascii
hello.war
├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── ...
├── WEB-INF
│   ├── classes
│   ├── lib
│   │   ├── ecj-3.18.0.jar
│   │   ├── tomcat-annotations-api-9.0.26.jar
│   │   ├── tomcat-embed-core-9.0.26.jar
│   │   ├── tomcat-embed-el-9.0.26.jar
│   │   ├── tomcat-embed-jasper-9.0.26.jar
│   │   └── Maven-1.0-SNAPSHOT.jar
│   └── web.xml
└──test
    ├── MyServlet.class
    └── Main.class
```

之所以要把编译后的classes复制到war包根目录，是因为用`java -jar hello.war`启动时，JVM的Class Loader不会查找`WEB-INF/lib`的jar包，而是直接从`hello.war`的根目录查找。`MANIFEST.MF`生成的内容如下：

```text
Manifest-Version: 1.0
Created-By: Maven WAR Plugin 3.3.2
Build-Jdk-Spec: 10
Class-Path: tmp-webapp/WEB-INF/lib/commons-lang3-3.9.jar tmp-webapp/WE
 B-INF/lib/mysql-connector-java-5.1.47.jar tmp-webapp/WEB-INF/lib/tomc
 at-embed-core-9.0.26.jar tmp-webapp/WEB-INF/lib/tomcat-annotations-ap
 i-9.0.26.jar tmp-webapp/WEB-INF/lib/tomcat-embed-jasper-9.0.26.jar tm
 p-webapp/WEB-INF/lib/tomcat-embed-el-9.0.26.jar tmp-webapp/WEB-INF/li
 b/ecj-3.18.0.jar
Main-Class: test.Main
```

注意到`Class-Path`的路径，这里定义的`Class-Path`相当于`java -cp`指定的Classpath，JVM不会在一个jar包中查找jar包内的jar包，它只会在文件系统中搜索，因此，还要修改`main()`方法，在执行`main()`方法时，先自解压`war`包，再启动Tomcat。还要注意依赖问题，如果在不存在Tomcat依赖时important，就会提示找不到类，因此Tomcat启动要另外写在一个类中：

```java
package test;

import org.apache.catalina.Context;
import org.apache.catalina.LifecycleException;
import org.apache.catalina.WebResourceRoot;
import org.apache.catalina.startup.Tomcat;
import org.apache.catalina.webresources.DirResourceSet;
import org.apache.catalina.webresources.StandardRoot;
import java.io.File;

public class TomcatRun{
    protected static void runTomcat(String webDir, String baseDir) {
        Tomcat tomcat = new Tomcat();
        // 设置Tomcat的端口号，默认为8080
        tomcat.setPort(Integer.getInteger("port", 8080));
        // 获取Tomcat的连接器
        tomcat.getConnector();

        // 将webapp添加到Tomcat，路径为webDir
        Context ctx = tomcat.addWebapp(
                "",
                new File(webDir).getAbsolutePath()
        );
        // 创建Web资源根目录
        WebResourceRoot resources = new StandardRoot(ctx);
        // 添加预设资源，包括类路径和WEB-INF目录
        resources.addPreResources(
                new DirResourceSet(
                        resources,
                        "/WEB-INF/classes",
                        new File(baseDir).getAbsolutePath(),
                        "/"
                )
        );
        // 设置Web应用的资源
        ctx.setResources(resources);
        // 启动Tomcat
        try {
            tomcat.start();
        } catch (LifecycleException e) {
            throw new RuntimeException(e);
        }
        // 等待Tomcat服务器结束
        tomcat.getServer().await();
    }
}
```

启动类：

```java
package test;


import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) throws IOException {
        // 判定是否从jar/war启动:
        String jarFile = Main.class.getProtectionDomain().getCodeSource().getLocation().getFile();
        boolean isJarFile = jarFile.endsWith(".war") || jarFile.endsWith(".jar");
        if (!isJarFile){
            TomcatRun.runTomcat("src/main/webapp","target/classes");
            return;
        }
        // webapp根目录:
        String webDir =  "tmp-webapp";
        // 解压到tmp-webapp:
        unpack(webDir, jarFile);
        // 启动Tomcat:
        TomcatRun.runTomcat(webDir, "tmp-webapp");
    }

    private static void unpack(String webDir, String jarFile) throws IOException {
        Path baseDir = Paths.get(webDir).normalize().toAbsolutePath();
        if (Files.isDirectory(baseDir)) {
            Files.delete(baseDir);
        }
        Files.createDirectories(baseDir);
        System.out.println("extract to: " + baseDir);

        try (JarFile jar = new JarFile(jarFile)) {
            List<JarEntry> entries = jar.stream().sorted(Comparator.comparing(JarEntry::getName))
                    .collect(Collectors.toList());
            for (JarEntry entry : entries) {
                Path res = baseDir.resolve(entry.getName());
                if (!entry.isDirectory()) {
                    System.out.println(res);
                    Files.createDirectories(res.getParent());
                    Files.copy(jar.getInputStream(entry), res);
                }
            }
        }
        // JVM退出时自动删除tmp-webapp:
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try(Stream<Path> sorted = Files.walk(baseDir).sorted(Comparator.reverseOrder())) {
                sorted.map(Path::toFile).forEach(File::delete);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }));
    }
}
```

现在，执行`java -jar hello.war`时，JVM先定位`hello.war`的`Main`类，运行`main()`，自动解压后，文件系统目录如下：

```ascii
<work>
├── hello.war
└── tmp-webapp
    └── WEB-INF
        ├── lib
	   	│   ├── ecj-3.18.0.jar
   		│   ├── tomcat-annotations-api-9.0.26.jar
	   	│   ├── tomcat-embed-core-9.0.26.jar
	   	│   ├── tomcat-embed-el-9.0.26.jar
	   	│   ├── tomcat-embed-jasper-9.0.26.jar
   		│   └── Maven-1.0-SNAPSHOT.jar
        └── web.xml
```

解压后的目录结构和我们在`MANIFEST.MF`中设定的`Class-Path`一致，因此，JVM能顺利加载Tomcat的jar包，然后运行Tomcat，启动Web App。

编写可执行的jar或者war需要注意的几点：

- 必须在`MANIFEST.MF`中指定`Main-Class`和`Class-Path`；
- `Main`必须能在jar/war包的根目录下被JVM的Class Loader加载；
- `Main`负责解压jar/war，解压后的目录结构与`MANIFEST.MF`中设定的`Class-Path`一致；
- `Main`**不能引用任何解压后才能被加载的类**，例如`org.apache.catalina.startup.Tomcat`。



实际上直接用springboot打包最简单。













