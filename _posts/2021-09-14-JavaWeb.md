# Java Web

对于Browser来说，请求页面的流程如下：

1. 与服务器建立TCP连接；
2. 发送HTTP请求；
3. 收取HTTP响应，然后把网页在浏览器中显示出来。

浏览器发送的HTTP请求如下：

```
GET / HTTP/1.1
Host: www.sina.com.cn
User-Agent: Mozilla/5.0 xxx
Accept: */*
Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8
```

其中，第一行表示使用`GET`请求获取路径为`/`的资源，并使用`HTTP/1.1`协议，从第二行开始，每行都是以`Header: Value`形式表示的HTTP头，比较常用的HTTP Header包括：

- Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；
- User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似`Mozilla/5.0 ... Chrome/79`，IE浏览器的标识类似`Mozilla/5.0 (Windows NT ...) like Gecko`；
- Accept：表示浏览器能接收的资源类型，如`text/*`，`image/*`或者`*/*`表示所有；
- Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；
- Accept-Encoding：表示浏览器可以支持的压缩类型，例如`gzip, deflate, br`。

服务器的响应如下：

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 21932
Content-Encoding: gzip
Cache-Control: max-age=300

<html>...网页数据...
```

服务器响应的第一行总是版本号+空格+数字+空格+文本，数字表示响应代码，其中`2xx`表示成功，`3xx`表示重定向，`4xx`表示客户端引发的错误，`5xx`表示服务器端引发的错误。数字是给程序识别，文本则是给开发者调试使用的。常见的响应代码有：

- 200 OK：表示成功；
- 301 Moved Permanently：表示该URL已经永久重定向；
- 302 Found：表示该URL需要临时重定向；
- 304 Not Modified：表示该资源没有修改，客户端可以使用本地缓存的版本；
- 400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；
- 401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；
- 403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；
- 404 Not Found：表示客户端请求了一个不存在的资源；
- 500 Internal Server Error：表示服务器处理时内部出错，例如因为无法连接数据库；
- 503 Service Unavailable：表示服务器此刻暂时无法处理请求。

从第二行开始，服务器每一行均返回一个HTTP头。服务器经常返回的HTTP Header包括：

- Content-Type：表示该响应内容的类型，例如`text/html`，`image/jpeg`；
- Content-Length：表示该响应内容的长度（字节数）；
- Content-Encoding：表示该响应压缩算法，例如`gzip`；
- Cache-Control：指示客户端应如何缓存，例如`max-age=300`表示可以最多缓存300秒。

HTTP请求和响应都由HTTP Header和HTTP Body构成，其中HTTP Header每行都以`\r\n`结束。如果遇到两个连续的`\r\n`，那么后面就是HTTP Body。浏览器读取HTTP Body，并根据Header信息中指示的`Content-Type`、`Content-Encoding`等解压后显示网页、图像或其他内容。

通常浏览器获取的**第一个资源是HTML网页**，在网页中，如果嵌入了JavaScript、CSS、图片、视频等其他资源，浏览器会根据资源的URL**再次**向服务器请求对应的资源。

Browser/Server模式，简称BS架构，基本过程是：

浏览器请求一个URL，服务器就把生成的HTML网页发送给浏览器，而浏览器和服务器之间的传输协议是HTTP。浏览器根据网页的url继续请求获取网页需要的资源，比如图片等

HTTP协议是一个基于TCP协议之上的请求-响应协议，也就是说，本质是一个TCP连接，然后根据HTTP协议的规定，规范化处理交互的内容，就是分析HTTP body 和 header，实现就是使用`ServeSocket`，而对于HTML浏览器会自己解析，因此只要保证通信、负责传输HTML内容到客户端本地就行。

## 编写HTTP Server

一个HTTP Server本质上是一个TCP服务器，用TCP编程的多线程实现的服务器端框架：

```java
try (ServerSocket server = new ServerSocket(8080)) {
    System.out.println("服务器正在运行。");
    for (; ; ) {
        Socket sock = server.accept();
        System.out.println("连接来自：" + sock.getRemoteSocketAddress());
        Thread t = new WebPage(sock);
        t.start();
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

处理：

```java
class WebPage extends Thread{
    private Socket socket;

    public WebPage(Socket socket) {
        this.socket = socket;
    }
    @Override
    public void run() {
        try (InputStream input = this.socket.getInputStream()) {
            try (OutputStream output = this.socket.getOutputStream()) {
                handle(input, output);
            }
            System.out.println("客户端已断开连接。");
        } catch (Exception e) {}
    }
    private void handle(InputStream in,OutputStream out) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));
        // 读取HTTP请求:
        boolean requestOk = false;
        String first = reader.readLine();
        if (first.startsWith("GET / HTTP/1.")) {
            requestOk = true;
        }
        for (;;) {
            String header = reader.readLine();
            if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕
                break;
            }
            System.out.println(header);
        }
        System.out.println(requestOk ? "响应正常" : "响应错误");
        if (!requestOk) {
            // 发送错误响应:
            writer.write("HTTP/1.0 404 Not Found\r\n");
            writer.write("Content-Length: 0\r\n");
            writer.write("\r\n");
            writer.flush();
        } else {
            // 发送成功响应:
            String data = "<html><body><h1>Hello, world!</h1></body></html>";
            int length = data.getBytes(StandardCharsets.UTF_8).length;
            writer.write("HTTP/1.0 200 OK\r\n");
            writer.write("Connection: close\r\n");
            writer.write("Content-Type: text/html\r\n");
            writer.write("Content-Length: " + length + "\r\n");
            writer.write("\r\n"); // 空行标识Header和Body的分隔
            writer.write(data);
            writer.flush();
        }
    }
}
```

只处理了`GET /`的请求。当读取到空行时，表示已读到连续两个`\r\n`，说明请求结束，可以发送响应。发送响应时，先发送响应代码`HTTP/1.0 200 OK`表示一个成功的200响应，使用`HTTP/1.0`协议。然后，依次发送Header，发送完Header后，再发送一个空行标识Header结束，紧接着发送HTTP Body。

HTTP目前有多个版本，`1.0`是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应，这样就大大提高了传输效率。

HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？HTTP 2.0可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。

HTTP 3.0为了进一步提高速度，将抛弃TCP协议，改为使用无需创建连接的UDP协议，目前HTTP 3.0仍然处于实验阶段。

## Servlet

编写HTTP服务器其实是非常简单的，只需要先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应即可。

但是，要编写一个完善的HTTP服务器，以HTTP/1.1为例，需要考虑的包括：

- 识别正确和错误的HTTP请求；
- 识别正确和错误的HTTP头；
- 复用TCP连接；
- 复用线程；
- IO异常处理；
- ...

这些基础工作需要耗费大量的时间，并且经过长期测试才能稳定运行。如果只需要输出一个简单的HTML页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发。

因此，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，然后只需要把自己的应用程序跑在Web服务器上。为了实现这一目的，JavaEE提供了Servlet API，使用Servlet API编写自己的Servlet来处理HTTP请求，Web服务器实现Servlet API接口，实现底层功能。

实现一个最简单的Servlet：

```java
@WebServlet("/")// WebServlet注解表示这是一个Servlet，并映射到地址/:
public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("text/html");// 设置响应类型
        resp.getWriter().write("<h1>Hello, world!</h1>");// 获取输出流，并写入。
        resp.getWriter().flush();//强制输出
    }
}
```

`@WebServlet("/")`也可以在`Web.xml`里配置：

```xml
<servlet>
    <servlet-name>hello</servlet-name>
    <servlet-class>test.MyServlet</servlet-class>
</servlet>
<servlet-mapping>
    <servlet-name>hello</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

一个Servlet总是继承自`HttpServlet`，然后覆写`doGet()`或`doPost()`方法。注意到`doGet()`方法传入了`HttpServletRequest`和`HttpServletResponse`两个对象，分别代表HTTP请求和响应。使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为`HttpServletRequest`和`HttpServletResponse`就已经封装好了请求和响应。以发送响应为例，只需要设置正确的响应类型，然后获取`PrintWriter`，写入响应即可。

Servlet API是一个jar包，需要通过Maven来引入它，才能正常编译。`pom.xml`文件的打包类型需要设置为`war`。并引入依赖：

```xml
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```

`<scope>`指定为`provided`，表示编译时使用，但不会打包到`.war`文件中，因为运行期Web服务器本身已经提供了Servlet API相关的jar包。

4.0及之前版本的`servlet-api`由Oracle官方维护，而5.0及以后的`servlet-api`由Eclipse开源社区维护，引入的依赖项是`jakarta.servlet`，对于很多仅支持Servlet 4.0版本的框架来说，例如Spring 5，就只能使用`javax.servlet:4.0.0`版本。

目录结构为：

```ascii
Maven
│  pom.xml
│
├─src
│  ├─main
│  │  ├─java
│  │  │  └─test
│  │  │          MyServlet.java
│  │  │
│  │  ├─resources
│  │  │
│  │  └─webapp
│  │      │  index.jsp
│  │      │
│  │      └─WEB-INF
│  │              web.xml
│  │
│  └─test
│      ├─java
│      └─resources
│
└─target
```

运行Maven命令`mvn clean package`，在`target`目录下得到一个`war`文件，这个文件就是编译打包后的Web应用程序。

如果使用mvn clean package报错信息中有类似

`org.apache.maven.plugins 的Due to ..... Cannot access defaults field of Properties`错误（war打包问题）

在pom.xml中指定package插件的版本即可:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.3.2</version>
        </plugin>
    </plugins>
</build>
```

maven-war-plugin插件会自动使用main-webapp-WEB-INF-web.xml文件作为配置文件。也可以自己在pom.xml中进行配置:

```xml
    <build>
        <finalName>打包的名字</finalName>
<!-- 如果使用maven-war-plugin默认配置则不需要配-->
        <pluginManagement>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-war-plugin</artifactId>
                    <version>2.2</version>
                    <configuration>
                        <webXml>webapp\WEB-INF.xml</webXml>
                        <!-- 指定jsp、js、css的路劲 -->
<!--                        <warSourceDirectory>WebRoot</warSourceDirectory>-->
                    </configuration>
                </plugin>
            </plugins>
        </pluginManagement>
    </build>
```

------

### 运行

普通的Java程序是通过启动JVM，然后执行`main()`方法开始运行。但是Web应用程序有所不同，我们无法直接运行`war`文件，必须先启动Web服务器，再由Web服务器加载我们编写的`HelloServlet`，这样就可以让`HelloServlet`处理浏览器发送的请求。

因此，首先要找一个支持Servlet API的Web服务器。常用的服务器有：

- [Tomcat](https://tomcat.apache.org/)：由Apache开发的开源免费服务器；
- [Jetty](https://www.eclipse.org/jetty/)：由Eclipse开发的开源免费服务器；
- [GlassFish](https://javaee.github.io/glassfish/)：一个开源的全功能JavaEE服务器。

还有一些收费的商用服务器，如Oracle的[WebLogic](https://www.oracle.com/middleware/weblogic/)，IBM的[WebSphere](https://www.ibm.com/cloud/websphere-application-platform/)。

无论使用哪个服务器，只要它支持对应版本的Servlet API ，war包都可以在上面运行。

要运行`war`文件，首先要[下载Tomcat服务器](https://tomcat.apache.org/download-90.cgi)，解压后，把`war`复制到Tomcat的`webapps`目录下，然后切换到`bin`目录，执行`startup.sh`或`startup.bat`启动Tomcat服务器。然后通过浏览器访问`http://127.0.0.1:8080/war文件名称/`即可。

一个Web服务器允许同时运行多个Web App，因此，第一级目录`/war文件名称`表示Web App的名字，后面的`/`才是在项目中映射的servlet路径。

那能不能直接使用`/`？答案是肯定的。先关闭Tomcat（执行`shutdown.sh`或`shutdown.bat`），然后删除Tomcat的webapps目录下的所有文件夹和文件，最后把自己的`war`文件复制过来，改名为`ROOT.war`，文件名为`ROOT`的应用程序将作为默认应用，启动后直接访问`http://127.0.0.1:8080/`即可。

Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机，执行Tomcat的`main()`方法，然后由Tomcat负责加载`.war`文件，实例化Servlet。如果Tomcat服务器收到的请求路径是`/`（假定部署文件为ROOT.war），就转发到`HelloServlet`并传入`HttpServletRequest`和`HttpServletResponse`两个对象。编写的Servlet并不是直接运行，而是由Web服务器加载后创建实例运行，所以，类似Tomcat这样的Web服务器也称为Servlet容器。

由于Servlet版本分为<=4.0和>=5.0两种，所以，要根据使用的Servlet版本选择正确的Tomcat版本。从[Tomcat版本页](https://tomcat.apache.org/whichversion.html)可知：

- 使用Servlet<=4.0时，选择Tomcat 9.x或更低版本；
- 使用Servlet>=5.0时，选择Tomcat 10.x或更高版本。

在Servlet容器中运行的Servlet具有如下特点：

- 无法在代码中直接通过new创建Servlet实例，必须由Servlet容器自动创建Servlet实例；
- Servlet容器只会给每个Servlet类创建唯一实例；
- Servlet容器会使用多线程执行`doGet()`或`doPost()`方法。

线程安全问题：

- 在Servlet中定义的实例变量会被多个线程同时访问，要注意线程安全；
- `HttpServletRequest`和`HttpServletResponse`实例是由Servlet容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；
- 在`doGet()`或`doPost()`方法中，如果使用了`ThreadLocal`，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为Servlet容器很可能用线程池实现线程复用。

------

**在IDEA中配置Tomcat运行调试：**

运行调试窗口-添加Tomcat服务器-本地，配置-选择本地Tomcat路径。

项目结构窗口-工件-添加-Web应用程序（展开或者归档都行）-基于模块。

运行调试窗口-Tomcat服务器-部署选项卡-添加工件-设置映射的网址。

**使用Tomcat的jar包运行调试：**

Tomcat的启动流程：

1. 启动JVM并执行Tomcat的`main()`方法；
2. 加载war并初始化Servlet；
3. 正常服务。

启动Tomcat无非就是设置好classpath并执行Tomcat某个jar包的`main()`方法，完全可以把Tomcat的jar包全部引入进来，然后自己编写一个`main()`方法，先启动Tomcat，然后让它加载我们的webapp就行。

添加依赖：

```xml
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-core</artifactId>
    <version>9.0.26</version>
    <scope>provided</scope>
</dependency>
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
    <version>9.0.26</version>
    <scope>provided</scope>
</dependency>
```

Servlet API可以不用显示引用，因为引入Tomcat依赖后自动引入了Servlet API。

可以编写一个`main()`方法，启动Tomcat服务器：

```java
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 设置Tomcat的端口号，默认为8080
        tomcat.setPort(Integer.getInteger("port", 8080));
        // 获取Tomcat的连接器
        tomcat.getConnector();

        // 将webapp添加到Tomcat，路径为src/main/webapp
        Context ctx = tomcat.addWebapp(
                "",
                new File("src/main/webapp").getAbsolutePath()
        );
        // 创建Web资源根目录
        WebResourceRoot resources = new StandardRoot(ctx);
        // 添加预设资源，包括类路径和WEB-INF目录
        resources.addPreResources(
                new DirResourceSet(
                        resources,
                        "/WEB-INF/classes",
                        new File("target/classes").getAbsolutePath(),
                        "/"
                )
        );
        // 设置Web应用的资源
        ctx.setResources(resources);
        // 启动Tomcat
        tomcat.start();
        // 等待Tomcat服务器结束
        tomcat.getServer().await();
    }
```

使用IDEA时需要注意设置：在`运行调试`窗口的`构建并运行`栏，右边的`修改选项`勾选`将带有"provided"作用域的依赖项添加到类路径`。

这样，直接运行`main()`方法，即可启动嵌入式Tomcat服务器，然后，通过预设的`tomcat.addWebapp("", new File("src/main/webapp")`，Tomcat会自动加载当前工程作为根webapp，可直接在浏览器访问`http://localhost:8080/`。

通过`main()`方法启动Tomcat服务器并加载自己的webapp有如下好处：

1. 启动简单，无需下载Tomcat或安装任何IDE插件；
2. 调试方便，可在IDE中使用断点调试；
3. 使用Maven创建war包后，也可以正常部署到独立的Tomcat服务器中。

------

### 生成可执行war包

如果要生成可执行的war包，用`java -jar xxx.war`启动，则需要把Tomcat的依赖项的`<scope>`设置为compile，然后配置`maven-war-plugin`如下：

```xml
<build>
    <finalName>hello</finalName>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <version>3.3.2</version>
            <configuration>
                <!-- 复制classes到war包根目录 -->
                <webResources>
                    <resource>
                        <directory>${project.build.directory}/classes</directory>
                    </resource>
                </webResources>
                <archiveClasses>true</archiveClasses>
                <archive>
                    <manifest>
                        <!-- 添加Class-Path -->
                        <addClasspath>true</addClasspath>
                        <!-- Classpath前缀 -->
                        <classpathPrefix>tmp-webapp/WEB-INF/lib/</classpathPrefix>
                        <!-- main所在的启动类 -->
                        <mainClass>test.Main</mainClass>
                    </manifest>
                </archive>
            </configuration>
        </plugin>
    </plugins>
</build>
```

生成的war包结构如下：

```ascii
hello.war
├── META-INF
│   ├── MANIFEST.MF
│   └── maven
│       └── ...
├── WEB-INF
│   ├── classes
│   ├── lib
│   │   ├── ecj-3.18.0.jar
│   │   ├── tomcat-annotations-api-9.0.26.jar
│   │   ├── tomcat-embed-core-9.0.26.jar
│   │   ├── tomcat-embed-el-9.0.26.jar
│   │   ├── tomcat-embed-jasper-9.0.26.jar
│   │   └── Maven-1.0-SNAPSHOT.jar
│   └── web.xml
└──test
    ├── MyServlet.class
    └── Main.class
```

之所以要把编译后的classes复制到war包根目录，是因为用`java -jar hello.war`启动时，JVM的Class Loader不会查找`WEB-INF/lib`的jar包，而是直接从`hello.war`的根目录查找。`MANIFEST.MF`生成的内容如下：

```text
Manifest-Version: 1.0
Created-By: Maven WAR Plugin 3.3.2
Build-Jdk-Spec: 10
Class-Path: tmp-webapp/WEB-INF/lib/commons-lang3-3.9.jar tmp-webapp/WE
 B-INF/lib/mysql-connector-java-5.1.47.jar tmp-webapp/WEB-INF/lib/tomc
 at-embed-core-9.0.26.jar tmp-webapp/WEB-INF/lib/tomcat-annotations-ap
 i-9.0.26.jar tmp-webapp/WEB-INF/lib/tomcat-embed-jasper-9.0.26.jar tm
 p-webapp/WEB-INF/lib/tomcat-embed-el-9.0.26.jar tmp-webapp/WEB-INF/li
 b/ecj-3.18.0.jar
Main-Class: test.Main
```

注意到`Class-Path`的路径，这里定义的`Class-Path`相当于`java -cp`指定的Classpath，JVM不会在一个jar包中查找jar包内的jar包，它只会在文件系统中搜索，因此，还要修改`main()`方法，在执行`main()`方法时，先自解压`war`包，再启动Tomcat。还要注意依赖问题，如果在不存在Tomcat依赖时important，就会提示找不到类，因此Tomcat启动要另外写在一个类中：

```java
package test;

import org.apache.catalina.Context;
import org.apache.catalina.LifecycleException;
import org.apache.catalina.WebResourceRoot;
import org.apache.catalina.startup.Tomcat;
import org.apache.catalina.webresources.DirResourceSet;
import org.apache.catalina.webresources.StandardRoot;
import java.io.File;

public class TomcatRun{
    protected static void runTomcat(String webDir, String baseDir) {
        Tomcat tomcat = new Tomcat();
        // 设置Tomcat的端口号，默认为8080
        tomcat.setPort(Integer.getInteger("port", 8080));
        // 获取Tomcat的连接器
        tomcat.getConnector();

        // 将webapp添加到Tomcat，路径为webDir
        Context ctx = tomcat.addWebapp(
                "",
                new File(webDir).getAbsolutePath()
        );
        // 创建Web资源根目录
        WebResourceRoot resources = new StandardRoot(ctx);
        // 添加预设资源，包括类路径和WEB-INF目录
        resources.addPreResources(
                new DirResourceSet(
                        resources,
                        "/WEB-INF/classes",
                        new File(baseDir).getAbsolutePath(),
                        "/"
                )
        );
        // 设置Web应用的资源
        ctx.setResources(resources);
        // 启动Tomcat
        try {
            tomcat.start();
        } catch (LifecycleException e) {
            throw new RuntimeException(e);
        }
        // 等待Tomcat服务器结束
        tomcat.getServer().await();
    }
}
```

启动类：

```java
package test;


import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Comparator;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) throws IOException {
        // 判定是否从jar/war启动:
        String jarFile = Main.class.getProtectionDomain().getCodeSource().getLocation().getFile();
        boolean isJarFile = jarFile.endsWith(".war") || jarFile.endsWith(".jar");
        if (!isJarFile){
            TomcatRun.runTomcat("src/main/webapp","target/classes");
            return;
        }
        // webapp根目录:
        String webDir =  "tmp-webapp";
        // 解压到tmp-webapp:
        unpack(webDir, jarFile);
        // 启动Tomcat:
        TomcatRun.runTomcat(webDir, "tmp-webapp");
    }

    private static void unpack(String webDir, String jarFile) throws IOException {
        Path baseDir = Paths.get(webDir).normalize().toAbsolutePath();
        if (Files.isDirectory(baseDir)) {
            Files.delete(baseDir);
        }
        Files.createDirectories(baseDir);
        System.out.println("extract to: " + baseDir);

        try (JarFile jar = new JarFile(jarFile)) {
            List<JarEntry> entries = jar.stream().sorted(Comparator.comparing(JarEntry::getName))
                    .collect(Collectors.toList());
            for (JarEntry entry : entries) {
                Path res = baseDir.resolve(entry.getName());
                if (!entry.isDirectory()) {
                    System.out.println(res);
                    Files.createDirectories(res.getParent());
                    Files.copy(jar.getInputStream(entry), res);
                }
            }
        }
        // JVM退出时自动删除tmp-webapp:
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try(Stream<Path> sorted = Files.walk(baseDir).sorted(Comparator.reverseOrder())) {
                sorted.map(Path::toFile).forEach(File::delete);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }));
    }
}
```

现在，执行`java -jar hello.war`时，JVM先定位`hello.war`的`Main`类，运行`main()`，自动解压后，文件系统目录如下：

```ascii
<work>
├── hello.war
└── tmp-webapp
    └── WEB-INF
        ├── lib
        │   ├── ecj-3.18.0.jar
        │   ├── tomcat-annotations-api-9.0.26.jar
        │   ├── tomcat-embed-core-9.0.26.jar
        │   ├── tomcat-embed-el-9.0.26.jar
        │   ├── tomcat-embed-jasper-9.0.26.jar
        │   └── Maven-1.0-SNAPSHOT.jar
        └── web.xml
```

解压后的目录结构和我们在`MANIFEST.MF`中设定的`Class-Path`一致，因此，JVM能顺利加载Tomcat的jar包，然后运行Tomcat，启动Web App。

编写可执行的jar或者war需要注意的几点：

- 必须在`MANIFEST.MF`中指定`Main-Class`和`Class-Path`；
- `Main`必须能在jar/war包的根目录下被JVM的Class Loader加载；
- `Main`负责解压jar/war，解压后的目录结构与`MANIFEST.MF`中设定的`Class-Path`一致；
- `Main`**不能引用任何解压后才能被加载的类**，例如`org.apache.catalina.startup.Tomcat`。



实际上直接用springboot打包最简单。

------

### 方法参数

一个Web App就是由一个或多个Servlet组成的，每个Servlet通过注解说明自己能处理的路径。

早期的Servlet需要在web.xml中配置映射路径，但最新Servlet版本只需要通过注解就可以完成映射。

浏览器发送请求的时候，还会请求方法（HTTP Method）：即GET、POST、PUT等不同类型的请求。因此，要处理GET请求，要覆写`doGet()`方法，要处理POST请求，就需要覆写`doPost()`方法。如果没有覆写`doPost()`方法，post请求后，程序会直接返回405或400错误。一个Webapp完全可以有多个Servlet，分别映射不同的路径。

浏览器发出的HTTP请求总是由Web Server先接收，然后，根据Servlet配置的映射，不同的路径转发到不同的Servlet：

```ascii
               ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐

               │            /hello    ┌───────────────┐│
                          ┌──────────>│ HelloServlet  │
               │          │           └───────────────┘│
┌───────┐    ┌──────────┐ │ /signin   ┌───────────────┐
│Browser│───>│Dispatcher│─┼──────────>│ SignInServlet ││
└───────┘    └──────────┘ │           └───────────────┘
               │          │ /         ┌───────────────┐│
                          └──────────>│ IndexServlet  │
               │                      └───────────────┘│
                              Web Server
               └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

这种根据路径转发的功能一般称为Dispatch。映射到`/`的`IndexServlet`比较特殊，它实际上会接收**所有未匹配的路径**，相当于`/*`，Dispatcher的逻辑可以用伪代码实现如下：

```java
String path = ...
if (path.equals("/hello")) {
    dispatchTo(helloServlet);
} else if (path.equals("/signin")) {
    dispatchTo(signinServlet);
} else {
    // 所有未匹配的路径均转发到"/"
    dispatchTo(indexServlet);
}
```

------

 **HttpServletRequest**

`HttpServletRequest`封装了一个HTTP请求，它实际上是从`ServletRequest`继承而来。最早设计Servlet时，设计者希望Servlet不仅能处理HTTP，也能处理类似SMTP等其他协议，因此，单独抽出了`ServletRequest`接口，但实际上除了HTTP外，并没有其他协议会用Servlet处理，所以这是一个过度设计。

通过`HttpServletRequest`提供的接口方法可以拿到HTTP请求的几乎全部信息，常用的方法有：

- `getMethod()`：返回请求方法，例如，`"GET"`，`"POST"`；
- `getRequestURI()`：返回请求路径，但不包括请求参数，例如，`"/hello"`；
- `getQueryString()`：返回请求参数，例如，`"name=Bob&a=1&b=2"`；
- **`getParameter(name)`：返回请求参数，GET请求从URL读取参数，POST请求从Body中读取参数；**
- `getContentType()`：获取请求Body的类型，例如，`"application/x-www-form-urlencoded"`；
- `getContextPath()`：获取当前Webapp挂载的路径，对于ROOT.war来说，总是返回空字符串`""`；
- `getCookies()`：返回请求携带的所有Cookie；
- `getHeader(name)`：获取指定的Header，对Header名称不区分大小写；
- `getHeaderNames()`：返回所有Header名称；
- `getInputStream()`：如果该请求带有HTTP Body，该方法将打开一个输入流用于读取Body；
- `getReader()`：和`getInputStream()`类似，但打开的是Reader；
- `getRemoteAddr()`：返回客户端的IP地址；
- `getScheme()`：返回协议类型，例如，`"http"`，`"https"`；

此外，`HttpServletRequest`还有两个方法：`setAttribute()`和`getAttribute()`，可以给当前`HttpServletRequest`对象附加多个Key-Value，相当于把`HttpServletRequest`当作一个`Map<String, Object>`使用。

------

**HttpServletResponse**

`HttpServletResponse`封装了一个HTTP响应。由于HTTP响应必须先发送Header，再发送Body，所以，操作`HttpServletResponse`对象时，必须先调用设置Header的方法，最后调用发送Body的方法。

常用的设置Header的方法有：

- `setStatus(sc)`：设置响应代码，默认是`200`；
- `setContentType(type)`：设置Body的类型，例如，`"text/html"`；
- `setCharacterEncoding(charset)`：设置字符编码，例如，`"UTF-8"`；
- `setHeader(name, value)`：设置一个Header的值；
- `addCookie(cookie)`：给响应添加一个Cookie；
- `addHeader(name, value)`：给响应添加一个Header，因为HTTP协议允许有多个相同的Header；

写入响应时，需要通过`getOutputStream()`获取写入流，或者通过`getWriter()`获取字符流，二者只能获取其中一个。

写入响应前，无需设置`setContentLength()`，因为底层服务器会根据写入的字节数**自动设置**，如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用Chunked编码让浏览器能识别数据结束符而不需要设置Content-Length头。

但是，写入完毕后调用`flush()`却是必须的，因为大部分Web服务器都基于HTTP/1.1协议，会复用TCP连接。如果没有调用`flush()`，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后**千万不要**调用`close()`，原因同样是因为会复用TCP连接，如果关闭写入流，将关闭TCP连接，使得Web服务器无法复用此TCP连接。

有了`HttpServletRequest`和`HttpServletResponse`这两个高级接口，就不需要直接处理HTTP协议。具体的实现类是由各服务器提供的，编写的Web应用程序只关心接口方法，并不需要关心具体实现的子类。

`response`的其他用法：

禁用缓存:

```java
response.setHeader("Cache-Control", "no-store");
response.setDateHeader("Expires", 0);
```

自动刷新，以及指定转到的URL:

```java
response.setHeader("refresh", "0");
response.setHeader("refresh", "5;URL=index");
```



------

 ### Servlet多线程问题

一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个Servlet的`doGet()`、`doPost()`等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题：

```java
public class HelloServlet extends HttpServlet {
    private Map<String, String> map = new ConcurrentHashMap<>();

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 注意读写map字段是多线程并发的:
        this.map.put(key, value);
    }
}
```

对于每个请求，Web服务器会创建唯一的`HttpServletRequest`和`HttpServletResponse`实例，因此，`HttpServletRequest`和`HttpServletResponse`实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。

------

### Redirect

重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用**新的URL再重新发送新请求**。

例如，已经编写了一个能处理`/hello`的`HelloServlet`，如果收到的路径为`/hi`，希望能重定向到`/hello`，可以再编写一个`RedirectServlet`：

```java
@WebServlet(urlPatterns = "/hi")
public class RedirectServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 构造重定向的路径:
        String name = req.getParameter("name");
        String redirectToUrl = "/hello" + (name == null ? "" : "?name=" + name);
        // 发送重定向响应:
        resp.sendRedirect(redirectToUrl);
    }
}
```

如果浏览器发送`GET /hi`请求，`RedirectServlet`将处理此请求。由于`RedirectServlet`在内部又发送了重定向响应，因此，浏览器会收到如下响应：

```
HTTP/1.1 302 Found
Location: /hello
```

当浏览器收到302响应后，它会立刻根据`Location`的指示发送一个新的`GET /hello`请求，这个过程就是重定。

重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会**缓存**`/hi`到`/hello`这个重定向的关联，下次请求`/hi`的时候，浏览器就直接发送`/hello`请求了。

重定向的目的是当Web应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。

`HttpServletResponse`提供了快捷的`redirect()`方法实现302重定向。如果要实现301永久重定向，可以这么写：

```java
resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301
resp.setHeader("Location", "/hello");
```

------

### Forward

Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。

例如，已经编写了一个能处理`/hello`的`HelloServlet`，继续编写一个能处理`/morning`的`ForwardServlet`：

```java
@WebServlet(urlPatterns = "/morning")
public class ForwardServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.getRequestDispatcher("/hello").forward(req, resp);
    }
}
```

`ForwardServlet`在收到请求后，它并不自己发送响应，而是把请求和响应都转发给路径为`/hello`的Servlet，即下面的代码：

```java
req.getRequestDispatcher("/hello").forward(req, resp);
```

后续请求的处理实际上是由`HelloServlet`完成的。这种处理方式称为转发（Forward）。转发和重定向的区别在于，转发是在Web服务器内部完成的，对浏览器来说，它只发出了一个HTTP请求。使用转发的时候，浏览器的地址栏路径仍然是`/morning`，浏览器并不知道该请求在Web服务器内部实际上做了一次转发。

还可以利用其它方法跳转：

自动刷新，指定转到的URL:

```java
response.setHeader("refresh", "5;URL=index");
```

弹窗后跳转，不建议用`alert`

```java
out.print("<script>alert('删除失败');window.location='List.jsp'</script>");
```



------

### Session

在Web应用程序中，经常要跟踪用户身份。当一个用户登录成功后，如果他继续访问其他页面，Web程序如何才能识别出该用户身份？

因为HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。

这种基于唯一ID识别用户身份的机制称为Session。每个用户第一次访问服务器后，会自动获得一个Session ID。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。

JavaEE的Servlet机制内建了对Session的支持。以登录为例，当一个用户登录成功后，就可以把这个用户的名字放入一个`HttpSession`对象，以便后续访问其他页面的时候，能直接从`HttpSession`取出用户名：

```java
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
    // 模拟一个数据库:
    private final Map<String, String> users = Map.of("bob", "bob123", "alice", "alice123", "tom", "tomcat");

    // GET请求时显示登录页:
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
        resp.setContentType("text/html;charset=UTF-8");
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        PrintWriter pw = resp.getWriter();
        pw.write("<h1>登录</h1>");
        pw.write("<form action=\"/login\" method=\"post\">");
        pw.write("<p>用户名: <input name=\"username\"></p>");
        pw.write("<p>密码: <input name=\"password\" type=\"password\"></p>");
        pw.write("<p><button type=\"submit\">登录</button> <a href=\"/\">返回</a></p>");
        pw.write("</form>");
        pw.flush();
    }
    // POST请求时处理用户登录:
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("text/html;charset=UTF-8");
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        String name = req.getParameter("username");
        String password = req.getParameter("password");
        String expectedPassword = users.get(name.toLowerCase());
        if (expectedPassword != null && expectedPassword.equals(password)) {
            // 登录成功:
            req.getSession().setAttribute("user", name);//将用户名放入当前`HttpSession`中
            resp.getWriter().write("登录成功");
            resp.setHeader("refresh", "5;URL=/index");
        } else {
            resp.getWriter().write("登录失败");
            resp.setHeader("refresh", "5;URL=/login");
        }
    }
}
```

在`IndexServlet`中，可以从`HttpSession`取出用户名：

```java
@WebServlet("/index")
public class IndexServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("text/html;charset=UTF-8");
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        String user=(String) req.getSession().getAttribute("user");
        PrintWriter pw = resp.getWriter();
        pw.write("<h1>欢迎你, " + (user != null ? user : "访客") + "</h1>");
        if (user == null) {
            pw.write("<p><a href='/login'>请登录</a></p>");
        } else {
            pw.write("<p><a href='/logout'>退出登录</a></p>");
        }
        pw.flush();
    }
}
```

如果用户已登录，可以通过访问`/logout`退出登录。登出逻辑就是从`HttpSession`中移除用户相关信息：

```java
@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        req.getSession().removeAttribute("user");
        resp.sendRedirect("/index");
    }
}
```

可以通过访问`http://127.0.0.1:8080/login`登录。

对于Web应用程序来说，总是通过`HttpSession`这个高级接口访问当前Session。如果要深入理解Session原理，可以认为Web服务器在内存中自动维护了一个ID到`HttpSession`的映射表。

服务器识别Session的关键就是依靠一个名为`JSESSIONID`的Cookie。在Servlet中**第一次调用**`req.getSession()`时，Servlet容器自动创建一个Session ID，然后通过一个名为`JSESSIONID`的Cookie发送给浏览器。`JSESSIONID`是由Servlet容器自动创建的，目的是维护一个浏览器会话，它和登录逻辑没有关系；即使没有登录功能，仍然可以使用`HttpSession`追踪用户，例如，放入一些用户配置信息等。

除了使用Cookie机制可以实现Session外，还可以通过隐藏表单、URL末尾附加ID来追踪Session。这些机制很少使用，最常用的Session机制仍然是Cookie。

使用Session时，由于服务器把所有用户的Session都存储在内存中，如果遇到内存不足的情况，就需要把部分不活动的Session序列化到磁盘上，这会大大降低服务器的运行效率，因此，放入Session的对象要小。

可以通过使用`req.getSession().invalidate();`使此会话失效，然后取消绑定到它的任何对象。

还可以设置seesion的时长，例如 30 分钟没有活动，会将已经存放的用户信息从seesion中移除。

```java
session.setMaxInactiveInterval(30 * 60);//30分钟没活动，自动移除
```

------

### CooKie

Servlet提供的`HttpSession`本质上就是通过一个名为`JSESSIONID`的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie可以任意使用。

如果想要设置一个Cookie，例如，记录用户选择的语言，可以编写一个`LanguageServlet`：

```java
@WebServlet("/language")
public class LanguageServlet extends HttpServlet {
    private static final String[] language={"en","zh"};
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        String lang=req.getParameter("lang");
        if (Arrays.asList(language).contains(lang)){
            // 创建一个新的Cookie:
            Cookie cookie = new Cookie("lang", lang);
            // 该Cookie生效的路径范围:
            cookie.setPath("/");
            // 该Cookie有效期:
            cookie.setMaxAge(8640000); // 8640000秒=100天
            // 将该Cookie添加到响应:
            resp.addCookie(cookie);
        }
        resp.sendRedirect("/index");
    }
}
```

创建一个新Cookie时，除了指定名称和值以外，通常需要设置`setPath("/")`，浏览器根据此前缀决定是否发送Cookie。如果一个Cookie调用了`setPath("/user/")`，那么浏览器只有在请求以`/user/`开头的路径时才会附加此Cookie。通过`setMaxAge()`设置Cookie的有效期，单位为秒，最后通过`resp.addCookie()`把它添加到响应。如果访问的是https网页，还需要调用`setSecure(true)`，否则浏览器不会发送该Cookie。

通过访问：`http://127.0.0.1:8080/language?lang=zh`，可以设置Cookie。问号后面为表单的值，多个值用`&`隔开，特殊符号要转义，比如空格要转义为`%20`。

如果要读取Cookie，例如，在`IndexServlet`中，读取名为`lang`的Cookie以获取用户设置的语言：

```java
@WebServlet("/index")
public class IndexServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("text/html;charset=UTF-8");
        req.setCharacterEncoding("utf-8");
        resp.setCharacterEncoding("utf-8");
        String user=(String) req.getSession().getAttribute("user");
        PrintWriter pw = resp.getWriter();
        pw.write("<h1>欢迎你, " + (user != null ? user : "访客") + "</h1>");
        System.out.println(parseLanguageFromCookie(req));
        if (user == null) {
            pw.write("<p><a href='/login'>请登录</a></p>");
        } else {
            pw.write("<p><a href='/logout'>退出登录</a></p>");
        }
        pw.flush();
    }
    private String parseLanguageFromCookie(HttpServletRequest req) {
        // 获取请求附带的所有Cookie:
        Cookie[] cookies = req.getCookies();
        // 循环每个Cookie:
        for (Cookie cookie : cookies) {
            // 如果Cookie名称为lang:
            if (cookie.getName().equals("lang")) {
                // 返回Cookie的值:
                return cookie.getValue();
            }
        }
        // 返回默认值:
        return "en";
    }
}
```

读取Cookie主要依靠遍历`HttpServletRequest`附带的所有Cookie。



## JSP

Servlet就是一个能处理HTTP请求，发送HTTP响应的小程序，而发送响应无非就是获取`PrintWriter`，然后输出HTML。只不过，用PrintWriter输出HTML比较痛苦，因为不但要正确编写HTML，还需要插入各种变量。

JSP是Java Server Pages的缩写，它的文件必须放到`/src/main/webapp`下，文件名必须以`.jsp`结尾，整个文件与HTML并无太大区别，但需要插入变量，或者动态输出的地方，使用特殊指令`<% ... %>`。

编写一个`index.jsp`：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="UTF-8" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Title</title>
</head>
<body>
<%-- JSP Comment --%>
<h1>你好!<%=session.getAttribute("user")%></h1>
</body>
</html>
```

整个JSP的内容实际上是一个HTML，但是稍有不同：

- 包含在`<%--`和`--%>`之间的是JSP的注释，它们会被完全忽略；
- 包含在`<%`和`%>`之间的是Java代码，可以编写任意Java代码；
- 如果使用`<%= xxx %>`则可以快捷输出一个变量的值。
- 包含在`<%!`和`%>`之间的是Java代码，可以设置全局变量或方法。

JSP页面内置了几个变量，可以直接使用：

- `page`：表示当前JSP页面本身，可以调用**页面**的方法。
- `request`：表示`HttpServletRequest`对象。可以通过该对象在**同一请求期间的不同页面**之间共享数据。
- `session`：表示当前`HttpSession`对象；可以通过该对象在**同一会话期间的不同页面之间**共享数据。
- `application`：表示`ServletContext`对象。可以通过该对象在**不同的页面之间**共享数据。
- `out`：表示`HttpServletResponse`的`PrintWriter`；
- `response`：表示`HttpServletResponse`对象，用于处理HTTP响应。
- `config`：表示`ServletContext`对象的`ServletConfig`，用于获取JSP页面的初始化参数。
- `exception`：表示在页面处理过程中发生的异常对象，如果页面没有发生异常，则该变量为null。

------

访问JSP页面时，直接指定完整路径。例如，`http://localhost:8080/index.jsp`。

JSP和Servlet其实没有任何区别，因为JSP在执行前首先被编译成一个Servlet。在Tomcat的临时目录下，可以找到一个`index_jsp.java`的源文件，这个文件就是Tomcat把JSP自动转换成的Servlet源码：

```java
out = pageContext.getOut();
out.write("\r\n");
out.write("\r\n");
out.write("<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\r\n");
out.write("<html>\r\n");
out.write("<head>\r\n");
out.write("    <title>Title</title>\r\n");
out.write("</head>\r\n");
out.write("<body>\r\n");
out.write("\r\n");
out.write("<h1>你好!");
out.print(session.getAttribute("user"));
out.write("</h1>\r\n");
out.write("</body>\r\n");
out.write("</html>\r\n");
```

JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的`.jsp`文件，如果找到了，就自动编译成Servlet再执行。在服务器运行过程中，如果修改了JSP的内容，那么服务器会自动重新编译。

**如何获取复选框选中的值**

```jsp
<form action="" method="get"> 
您喜欢的水果？<br /><br /> 
<label><input name="Fruit" type="checkbox" value="1" />苹果 </label> 
<label><input name="Fruit" type="checkbox" value="2" />桃子 </label> 
<label><input name="Fruit" type="checkbox" value="3" />香蕉 </label> 
<label><input name="Fruit" type="checkbox" value="3" />梨 </label> 
</form> 
```

后台代码：

```java
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
    //获取选中的选项
    String[] Fruit=req.getParameterValues("Fruit");
    System.out.println(Arrays.toString(Fruit));
}
```

假设四个全选中，则输出：`[1,2,3,4]`





------

### 动作指令

JSP的指令非常复杂，SP页面本身可以通过`page`指令引入Java类：

```jsp
<%@ page import="java.io.*" %>
<%@ page import="java.util.*" %>
```

这样后续的Java代码才能引用简单类名而不是完整类名。

`language`设置jsp页面语言属性, `contentTyp`设置MIME类型和字符编码, `pageEncoding`设置页面编码格式：

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
```

------

使用`include`指令可以引入另一个JSP文件：

```jsp
<html>
<body>
    <%@ include file="header.jsp"%>
    <h1>Index Page</h1>
    <%@ include file="footer.jsp"%>
</body>
```

还可以导入普通文件：

```java
<%@ include file="hello.txt"* %>
```

------

设置全局变量或方法：

```jsp
<%! 
    int n=1;
    int count(){
        return 1;
    }
%>
```

------

### 动作指令标签

引入：

```jsp
<jsp:include page=""></jsp:include>
```

跳转入date.jsp：

```jsp
<jsp:forward page="date.jsp"></jsp:forward>
```

会显示跳转前的url

传递参数的动作可做为其他标识的子标识

```jsp
<jsp:param value="张三"  name="name"/>
```

即:

```jsp
<jsp:forward page="date.jsp">
	<jsp:param value="张三"  name="name"/>
</jsp:forward>
```

例子:

```jsp
<% 
String name=request.getParameter("name");
String password=request.getParameter("password");
String sex=request.getParameter("sex");
String age=request.getParameter("age");
if(name.equals("")){
%>
	<jsp:forward page="err.jsp"></jsp:forward>
<%
}
else{
%>
	<jsp:forward page="cg.jsp"></jsp:forward>
<%
}
%>
```



### JSTL

JSP还允许自定义输出的tag，例如：

```jsp
<c:out value = "${sessionScope.user.name}"/>
```

JSP Tag需要正确引入taglib的jar包，并且还需要正确声明，使用起来非常复杂：

```xml
<!-- https://mvnrepository.com/artifact/org.apache.taglibs/taglibs-standard-impl -->
<dependency>
    <groupId>org.apache.taglibs</groupId>
    <artifactId>taglibs-standard-impl</artifactId>
    <version>1.2.5</version>
    <scope>runtime</scope>
</dependency>
```

用法：

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" pageEncoding="UTF-8" %>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Title</title>
</head>
<body>
<%-- JSP Comment --%>
<%--@elvariable id="user" type="java.lang.String"--%>
<h1>你好!<c:out value="${user}"/></h1>
</body>
</html>
```

`${user}` 意思是取出某一范围中名称为user的变量，它的取值范围是`Page`,`Request`,`Session`,`Application`。

而`${param.user}`就不是从这四个范围取值的方式了，而是相当于 `request.getParameter("user")`。



**在JSP页面获取当前项目名称的方法**：

一般对于静态资源会用到。

方法1：

```jsp
 <%= this.getServletContext().getContextPath() %>
```

方法2： 使用EL表达式

```jsp
${pageContext.request.contextPath}
```



### MVC

Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML；JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码。

在`UserServlet`中，可以从数据库读取`User`、`School`等信息，然后，把读取封装到的`JavaBean`先放到`HttpServletRequest`中，再通过`forward()`传给`user.jsp`处理。而在`user.jsp`中，只负责展示相关`JavaBean`的信息，就不需要编写访问数据库等复杂逻辑。

需要展示的`User`被放入`HttpServletRequest`中以便传递给JSP，因为一个请求对应一个`HttpServletRequest`，也无需清理它，处理完该请求后`HttpServletRequest`实例将被丢弃；

把`user.jsp`放到`/WEB-INF/`目录下，是因为`WEB-INF`是一个特殊目录，Web Server会阻止浏览器对`WEB-INF`目录下任何资源的访问，这样就防止用户通过`/user.jsp`路径直接访问到JSP页面；

JSP页面首先从`request`变量获取`User`实例，然后在页面中直接输出。这里把`UserServlet`看作业务逻辑处理，把`User`看作模型，把`user.jsp`看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即`UserServlet`作为控制器（Controller），`User`作为模型（Model），`user.jsp`作为视图（View）。

使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。MVC模式是一种分离业务逻辑和显示逻辑的设计模式，广泛地应用在Web页面和传统的桌面程序中。

------

通过结合Servlet和JSP的MVC模式，可以发挥二者各自的优点：

- Servlet实现业务逻辑；
- JSP实现展示逻辑。

但是，直接把MVC搭在Servlet和JSP之上还是不太好，原因如下：

- Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口；
- JSP对页面开发不友好，更好的替代品是模板引擎；
- 业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。

能不能通过普通的Java类实现MVC的Controller？类似下面的代码：

```java
class UserController {
    @GetMapping("/signin")
    public ModelAndView signin() {
        ...
    }

    @PostMapping("/signin")
    public ModelAndView doSignin(SignInBean bean) {
        ...
    }

    @GetMapping("/signout")
    public ModelAndView signout(HttpSession session) {
        ...
    }
}
```

上面的这个Java类每个方法都对应一个GET或POST请求，方法返回值是`ModelAndView`，它包含一个View的路径以及一个Model，这样，再由MVC框架处理后返回给浏览器。

如果是GET请求，希望MVC框架能直接把URL参数按方法参数对应起来然后传入：

```java
@GetMapping("/hello")
public ModelAndView hello(String name) {
    ...
}
```

如果是POST请求，希望MVC框架能直接把Post参数变成一个JavaBean后通过方法参数传入：

```java
@PostMapping("/signin")
public ModelAndView doSignin(SignInBean bean) {
    ...
}
```

为了增加灵活性，如果Controller的方法在处理请求时需要访问`HttpServletRequest`、`HttpServletResponse`、`HttpSession`这些实例时，只要方法参数有定义，就可以自动传入：

```java
@GetMapping("/signout")
public ModelAndView signout(HttpSession session) {
    ...
}
```

------

**设计MVC框架**

`ModelAndView`对象包含一个`View`和一个`Model`。实际上`View`就是模板的路径，而`Model`可以用一个`Map<String, Object>`表示，因此，`ModelAndView`定义非常简单：

```java
public class ModelAndView {
    Map<String, Object> model;
    String view;
}
```

比较复杂的是需要在MVC框架中创建一个接收所有请求的`Servlet`通常命名为`DispatcherServlet`，它总是映射到`/`，然后，根据不同的Controller的方法定义的`@Get`或`@Post`的`Path`决定调用哪个方法，最后，获得方法返回的`ModelAndView`后，渲染模板，写入`HttpServletResponse`，即完成了整个MVC的处理。

这个MVC的架构如下：

```ascii
   HTTP Request    ┌─────────────────┐
──────────────────>│DispatcherServlet│
                   └─────────────────┘
                            │
               ┌────────────┼────────────┐
               ▼            ▼            ▼
         ┌───────────┐┌───────────┐┌───────────┐
         │Controller1││Controller2││Controller3│
         └───────────┘└───────────┘└───────────┘
               │            │            │
               └────────────┼────────────┘
                            ▼
   HTTP Response ┌────────────────────┐
<────────────────│render(ModelAndView)│
                 └────────────────────┘
```

其中，`DispatcherServlet`以及如何渲染均由MVC框架实现，在MVC框架之上只需要编写每一个Controller。

编写`DispatcherServlet`，需要存储请求路径到某个具体方法的映射：

```java
@WebServlet(urlPatterns = "/")
public class DispatcherServlet extends HttpServlet {
    private Map<String, GetDispatcher> getMappings = new HashMap<>();
    private Map<String, PostDispatcher> postMappings = new HashMap<>();
}
```

处理一个GET请求是通过`GetDispatcher`对象完成的，它需要如下信息：

```java
class GetDispatcher {
    Object instance; // Controller实例
    Method method; // Controller方法
    String[] parameterNames; // 方法参数名称
    Class<?>[] parameterClasses; // 方法参数类型
}
```

有了以上信息，就可以定义`invoke()`来处理真正的请求：

```java
class GetDispatcher {
    ...
    public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) {
        Object[] arguments = new Object[parameterClasses.length];
        for (int i = 0; i < parameterClasses.length; i++) {
            String parameterName = parameterNames[i];
            Class<?> parameterClass = parameterClasses[i];
            if (parameterClass == HttpServletRequest.class) {
                arguments[i] = request;
            } else if (parameterClass == HttpServletResponse.class) {
                arguments[i] = response;
            } else if (parameterClass == HttpSession.class) {
                arguments[i] = request.getSession();
            } else if (parameterClass == int.class) {
                arguments[i] = Integer.valueOf(getOrDefault(request, parameterName, "0"));
            } else if (parameterClass == long.class) {
                arguments[i] = Long.valueOf(getOrDefault(request, parameterName, "0"));
            } else if (parameterClass == boolean.class) {
                arguments[i] = Boolean.valueOf(getOrDefault(request, parameterName, "false"));
            } else if (parameterClass == String.class) {
                arguments[i] = getOrDefault(request, parameterName, "");
            } else {
                throw new RuntimeException("Missing handler for type: " + parameterClass);
            }
        }
        return (ModelAndView) this.method.invoke(this.instance, arguments);
    }

    private String getOrDefault(HttpServletRequest request, String name, String defaultValue) {
        String s = request.getParameter(name);
        return s == null ? defaultValue : s;
    }
}
```

上述代码比较繁琐，但逻辑非常简单，即通过构造某个方法需要的所有参数列表，使用反射调用该方法后返回结果。类似的，`PostDispatcher`需要如下信息：

```java
class PostDispatcher {
    Object instance; // Controller实例
    Method method; // Controller方法
    Class<?>[] parameterClasses; // 方法参数类型
    ObjectMapper objectMapper; // JSON映射
}
```

和GET请求不同，POST请求严格地来说不能有URL参数，所有数据都应当从Post Body中读取。为了简化处理，只支持JSON格式的POST请求，这样，把Post数据转化为JavaBean就非常容易。

```java
class PostDispatcher {
    ...
    public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) {
        Object[] arguments = new Object[parameterClasses.length];
        for (int i = 0; i < parameterClasses.length; i++) {
            Class<?> parameterClass = parameterClasses[i];
            if (parameterClass == HttpServletRequest.class) {
                arguments[i] = request;
            } else if (parameterClass == HttpServletResponse.class) {
                arguments[i] = response;
            } else if (parameterClass == HttpSession.class) {
                arguments[i] = request.getSession();
            } else {
                // 读取JSON并解析为JavaBean:
                BufferedReader reader = request.getReader();
                arguments[i] = this.objectMapper.readValue(reader, parameterClass);
            }
        }
        return (ModelAndView) this.method.invoke(instance, arguments);
    }
}
```

json转换依赖：

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.17.0</version>
</dependency>
```

为了方便性，可以把方法提出接口：

```java
interface Dispatcher {
    ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) throws InvocationTargetException, IllegalAccessException, IOException;
}
```

最后实现整个`DispatcherServlet`的处理流程：

```java
@WebServlet(urlPatterns = "/")
public class DispatcherServlet extends HttpServlet {
    private Map<String, GetDispatcher> getMappings = new HashMap<>();
    private Map<String, PostDispatcher> postMappings = new HashMap<>();

    private ViewEngine viewEngine;

    @Override
    public void init() {
        // todo 扫描注解
        this.getMappings = scanGetInControllers();
        this.postMappings = scanPostInControllers();
        // 模板引擎初始化
        viewEngine=new ViewEngine(this.getServletContext());
    }
    
    private Map<String, PostDispatcher> scanPostInControllers() {
        return null;
    }

    private Map<String, GetDispatcher> scanGetInControllers() {
        return null;
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("text/html");
        resp.setCharacterEncoding("UTF-8");
        // 根据路径查找GetDispatcher:
        String path = req.getRequestURI().substring(req.getContextPath().length());
        Dispatcher dispatcher = this.getMappings.get(path);
        if (dispatcher == null) {
            // 未找到返回404:
            resp.sendError(404);
            return;
        }
        run(req, resp,dispatcher);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType("text/html");
        resp.setCharacterEncoding("UTF-8");
        // 根据路径查找GetDispatcher:
        String path = req.getRequestURI().substring(req.getContextPath().length());
        Dispatcher dispatcher = this.postMappings.get(path);
        if (dispatcher == null) {
            // 未找到返回404:
            resp.sendError(404);
            return;
        }
        run(req, resp,dispatcher);
    }

    private void run(HttpServletRequest req, HttpServletResponse resp, Dispatcher dispatcher) throws IOException {
        // 调用Controller方法获得返回值:
        ModelAndView mv;
        try {
            mv = dispatcher.invoke(req, resp);
        } catch (InvocationTargetException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        // 允许返回null，表示内部已自行处理完毕；
        if (mv == null) {
            return;
        }
        // 允许返回`redirect:`开头的view表示重定向:
        if (mv.view.startsWith("redirect:")) {
            resp.sendRedirect(mv.view.substring(9));
            return;
        }

        // 将模板引擎渲染的内容写入响应:
        PrintWriter pw = resp.getWriter();
        this.viewEngine.render(mv, pw);
        pw.flush();
    }
}
```



用反射得到注解方法暂时不提。对于模板引擎`ViewEngine`，Java有很多开源的模板引擎，常用的有：[Thymeleaf](https://www.thymeleaf.org/)、[FreeMarker](https://freemarker.apache.org/)、[Velocity](https://velocity.apache.org/)，用法都大同小异。推荐一个使用[Jinja](https://palletsprojects.com/p/jinja/)语法的模板引擎[Pebble](https://pebbletemplates.io/)，它的特点是语法简单，支持模板继承，编写出来的模板类似：

```html
<html>
<body>
  <ul>
  {% for user in users %}
    <li><a href="{{ user.url }}">{{ user.username }}</a></li>
  {% endfor %}
  </ul>
</body>
</html>
```

即变量用：

```html
{{ XXX }}
```

控制语句用

```html
{% XXX %}
```

使用Pebble渲染只需要如下几行代码：

```java
class ViewEngine {
    private final PebbleEngine engine;

    public ViewEngine(ServletContext servletContext) {
        // 定义一个ServletLoader用于加载模板:
        ServletLoader loader = new ServletLoader(servletContext);
        // 模板编码:
        loader.setCharset("UTF-8");
        // 模板前缀，这里默认模板必须放在`/WEB-INF/templates`目录:
        loader.setPrefix("/WEB-INF/templates");
        // 模板后缀:
        loader.setSuffix("");
        // 创建Pebble实例:
        this.engine = new PebbleEngine.Builder()
                .autoEscaping(true) // 默认打开HTML字符转义，防止XSS攻击
                .cacheActive(false) // 禁用缓存使得每次修改模板可以立刻看到效果
                .loader(loader).build();
    }

    public void render(ModelAndView mv, Writer writer) throws IOException {
        // 查找模板:
        PebbleTemplate template = this.engine.getTemplate(mv.view);
        // 渲染:
        template.evaluate(writer, mv.model);
    }
}
```

依赖：

```xml
<!-- https://mvnrepository.com/artifact/io.pebbletemplates/pebble -->
<dependency>
    <groupId>io.pebbletemplates</groupId>
    <artifactId>pebble</artifactId>
    <version>3.2.2</version>
</dependency>
```

这里规定了模板必须放在`webapp/WEB-INF/templates`目录下。

再实现一个`FileServlet`来处理静态文件：

```java
@WebServlet(urlPatterns = { "/favicon.ico", "/static/*" })
public class FileServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        // 读取当前请求路径:
        ServletContext ctx = req.getServletContext();
        // RequestURI包含ContextPath,需要去掉:
        String urlPath = req.getRequestURI().substring(ctx.getContextPath().length());
        // 获取真实文件路径:
        String filepath = ctx.getRealPath(urlPath);
        if (filepath == null) {
            // 无法获取到路径:
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        Path path = Paths.get(filepath);
        if (!path.toFile().isFile()) {
            // 文件不存在:
            resp.sendError(HttpServletResponse.SC_NOT_FOUND);
            return;
        }
        // 根据文件名猜测Content-Type:
        String mime = Files.probeContentType(path);
        if (mime == null) {
            mime = "application/octet-stream";
        }
        resp.setContentType(mime);
        // 读取文件并写入Response:
        OutputStream output = resp.getOutputStream();
        try (InputStream input = new BufferedInputStream(new FileInputStream(filepath))) {
            input.transferTo(output);
        }
        output.flush();
    }
}
```

静态文件应该放在`webapp/static`目录下。

为了把**方法参数的名称**编译到class文件中，以便处理`@GetMapping`时使用，需要打开编译器的一个参数：

在Eclipse中勾选`Preferences`-`Java`-`Compiler`-`Store information about method parameters (usable via reflection)`；

在Idea中选择`Preferences`-`Build, Execution, Deployment`-`Compiler`-`Java Compiler`-`Additional command line parameters`，填入`-parameters`；

在Maven的`pom.xml`添加一段配置如下：

```xml
<project ...>
    <modelVersion>4.0.0</modelVersion>
    ...
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <compilerArgs>
                        <arg>-parameters</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

`-parameters`的作用是在编译后的类文件中**保留方法参数的名称**。默认情况下，Java编译器在编译过程中会丢弃方法参数的名称，而只保留参数的顺序。



一个MVC框架是基于Servlet基础抽象出更高级的接口，使得上层基于MVC框架的开发可以不涉及Servlet相关的`HttpServletRequest`等接口，处理多个请求更加灵活，并且可以使用任意模板引擎，不必使用JSP。







































