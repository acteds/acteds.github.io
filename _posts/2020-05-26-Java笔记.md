---
layout: post
title: Java笔记
categories: Java
description: Java的基础笔记
keywords: Java
---
# 引言  
&emsp;&emsp;java的基础笔记。    


# 基础
&emsp;&emsp;**alt+/** 内容辅助，在类内右键-生成Getter和Setter..  。
## 基本数据类型
- 简单数据类型
  - 数值型
    - 整数类（byte(8)，short(16)，int(32)，long(64)）
    - 浮点类型（float(32)，double(64)）
  - 字符型（char(16)）
  - 布尔型（boolean(1)）
- 引用数据类型
  - 类（class）
  - 接口（interface）
  - 数组

- int型：不带L：100，200，9_000_000
- long型：必须带L：100L，200L，9_000_000_000_000L
- double型：不带F：1.0，2.3e10
- float型：必须带F：1.0F，2.3e10F

&emsp;&emsp;中间的`_`可以随意加。`1_2_3_4`，浮点数也可以，比如`12_3.45`，不过为了规范，还是应该三个添加一个最好。  
&emsp;&emsp;`long l1 = 182L;` 因为`long`，`float`等字面值中均是数字开头，字母结尾，故变量名**不能数字开头**，避免与变量值歧义，编译不过。  
&emsp;&emsp;整数运算在除数为`0`时会报错，而浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值：  
- `NaN`表示Not a Number
- `Infinity`表示无穷大
- `-Infinity`表示负无穷大

&emsp;&emsp;java中可以对**浮点数**求模。    
&emsp;&emsp;字符类型`char`表示一个字符。Java的`char`类型除了可表示标准的ASCII外，还可以表示一个Unicode字符。注意`char`类型使用单引号`'`，且仅有一个字符，要和双引号`"`的字符串类型区分开。  
&emsp;&emsp;`var`不是关键字，而是在Java 10中引入的一种类型推断的新特性。它用于声明局部变量时，可以根据赋值语句的类型推断变量的类型，从而简化代码编写。需要注意的是，虽然`var`可以用于声明局部变量，但不能用于声明方法参数、方法返回值、类的字段等其他地方。  

------

 **位移\<\<\>\> \>\>\>**
&emsp;&emsp;左移加0,右移加**符号位**  
&emsp;&emsp;例如**int a=30;a\>\>36;**  
&emsp;&emsp;那么**36**大于**int的位数**,要进行除**32**取余,即**a\>\>4**  
&emsp;&emsp;无符号右移运算符**\>\>\>**  
&emsp;&emsp;用来将一个数的各二进制位无符号右移若干位,与运算符**\>\>相同**的是移出的低位被舍弃,但**不同**的是最高位**补0**,如:  
&emsp;&emsp;**a=00110111**,则**a\>\>\>2** 结果为 **00001101**  
&emsp;&emsp;**b=11010011**,则**b\>\>\>2** 结果为 **00110100**  
&emsp;&emsp;**Random();**  
```java
import java.util.Random;
Random rand = new Random();  
int i = rand.nextInt(100);  
System.out.println("i = " + i);
```
&emsp;&emsp;返回一个**伪随机数**,它是取自此随机数生成器序列的、在 0(包括)和100(不包括)之间均匀分布的 **int** 值  
## 输入输出
&emsp;&emsp;**输入**  
- `nextInt()`: 读取输入的下一个整数。如果遇到非整数字符（如空格、换行符等），会停止读取，并将输入中的整数部分作为结果返回。
- `nextDouble()`: 读取输入的下一个浮点数（小数）。同样地，遇到非浮点数字符会停止读取，并将输入中的浮点数部分作为结果返回。
- `next()`: 读取输入的下一个单词（以空格分隔的字符串）。遇到空格、换行符等会停止读取，并将输入中的单词部分作为结果返回。
- `nextLine()`: 读取输入的下一行文本（包括换行符）。它会读取输入直到换行符为止，并将包括换行符在内的整行文本作为结果返回。

```java
import java.util.Scanner;
Scanner scanner=new Scanner(System.in);
int m=scanner.nextInt();//读整数
double d=nextDouble()//读小数
String s = scanner.next();//读一串
scanner.nextLine();//读一行
```
&emsp;&emsp;`System.out`代表标准输出流，而`System.in`代表标准输入流。  
&emsp;&emsp;**输出**  
&emsp;&emsp;有回车  `System.out.println();`  
&emsp;&emsp;无回车  `System.out.print();`  
&emsp;&emsp;格式化输出使用`System.out.printf()`，不想打印只想生成字符串则使用`String.format()`。  

| 占位符 | 说明                             | 占位符 | 说明                               |
| :----- | :------------------------------- | ------ | ---------------------------------- |
| %d     | 格式化输出整数                   | %%     | 转义%，代指一个%                   |
| %x     | 格式化输出十六进制整数           | %8d    | 输出补到8位，不足在**前**面补空格  |
| %f     | 格式化输出浮点数                 | %-8d   | 输出补到8位，不足在**后**面补空格  |
| %e     | 格式化输出科学计数法表示的浮点数 | %08d   | 输出补到8位，不足则**前**面补**0** |
| %s     | 格式化字符串                     | %6.3f  | 输出补到6位,小数位占3位            |

&emsp;&emsp;详细的格式化参数请参考JDK文档[java.util.Formatter](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Formatter.html#syntax)  
## 字符串
&emsp;&emsp;**`args[0]`**是命令行执行的第一个字符串  `public static void main(String[] args){}`，以此类推。
### 字符类型
&emsp;&emsp;字符类型`char`是**基本数据类型**，它是`character`的缩写。一个`char`保存一个Unicode字符：  
```java
char c1 = 'A';char c2 = '中';
```
&emsp;&emsp;因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用**一个**`char`类型表示，它们都占用**两个字节**。要显示一个字符的Unicode编码，只需将`char`类型直接赋值给`int`类型即可：  
```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
```
&emsp;&emsp;还可以直接用转义字符`\u`+Unicode编码来表示一个字符：  
```java
// 注意是十六进制:
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```
### 字符串类型
&emsp;&emsp;字符串类型`String`是**引用类型**，`\`是转义字符，两个`\\`表示一个`\`字符：  
&emsp;&emsp;常见的转义字符包括：  
- `\"` 表示字符`"`
- `\'` 表示字符`'`
- `\\` 表示字符`\`
- `\n` 表示换行符
- `\r` 表示回车符
- `\t` 表示Tab
- `\u####` 表示一个Unicode编码的字符

&emsp;&emsp;Java编译器对`String`有特殊处理，即可以直接用`"..."`来表示一个字符串。实际上字符串在`String`内部是通过一个`char[]`数组表示的，因此，按下面的写法也是可以的：  
```java
String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'});
```

------

&emsp;&emsp;**字符串连接**  
&emsp;&emsp;Java的编译器对字符串做了特殊照顾，可以使用`+`连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。  
&emsp;&emsp;引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`。  

------

&emsp;&emsp;**多行字符串**  
&emsp;&emsp;从Java 13开始，字符串可以用`"""..."""`表示多行字符串（Text Blocks）了。多行字符串前面共同的空格会被去掉，即：  
```java
String s = """
...........SELECT * FROM
...........  users
...........WHERE id > 100
...........ORDER BY name DESC
...........""";
```
&emsp;&emsp;用`.`标注的空格都会被去掉。如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：  
```java
String s = """
.........  SELECT * FROM
.........    users
.........WHERE id > 100
.........  ORDER BY name DESC
.........  """;
```
&emsp;&emsp;总是以最短的行首空格为基准。  

------

### **不可变特性**
&emsp;&emsp;Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。字符串会维护在常量池内，而字符串变量指向常量池中的字符串。  
&emsp;&emsp;这意味着一旦字符串对象被创建，它的值就不能被修改。当你对字符串进行操作时，实际上是创建了一个新的字符串对象，而原始字符串对象保持不变。  
&emsp;&emsp;这种不可变性带来了一些优点，例如：  
- 线程安全：由于字符串是不可变的，多个线程可以安全地共享字符串对象而无需担心数据竞争。
- 缓存哈希值：由于字符串的不可变性，可以缓存字符串的哈希值，提高性能。
- 安全性：不可变字符串可以避免在运行时被修改，提高代码的安全性。

&emsp;&emsp;另外，字符串常量池是Java中用于存储字符串常量的特殊区域，它可以减少内存占用，提高性能。当你创建一个字符串常量时，如果常量池中已经存在相同内容的字符串，则会直接返回常量池中的字符串引用，而不会创建新的字符串对象。  
&emsp;&emsp;因此，了解字符串的不可变性和字符串常量池的特性有助于更好地理解和利用Java中的字符串。  

------

&emsp;&emsp;判断值类型的变量是否相等，可以使用`==`运算符。但是，判断引用类型的变量是否相等，`==`表示“引用是否相等”。要判断引用类型的变量内容是否相等，必须使用`equals()`方法。  
```java
String s1 = "hello";
String s2 = "HELLO".toLowerCase();
System.out.println(s1);
System.out.println(s2);
if (s1 == s2) {
    System.out.println("s1 == s2");
} else {
    System.out.println("s1 != s2");
}
```
&emsp;&emsp;调用`"HELLO".toLowerCase()`会创建一个新的**字符串对象**，因为在Java中字符串是不可变的，任何对字符串的修改操作都会创建一个新的字符串对象。因此，`"HELLO".toLowerCase()`会在堆内存中创建一个新的字符串对象，该对象存储小写形式的字符串。因此，`String s2 = "HELLO".toLowerCase();`中的`s2`引用的是**堆**内存中新创建的对象，其内存地址与字符串常量池中的地址不同。  
### Obect.equals()
&emsp;&emsp;判断两个字符串是否相等在java中,用的是**equals();**  
&emsp;&emsp;例;A字符串和B和字符串比较:  
```java
String a="123",b="456";  
if (a.equals(b)) {  
    System.out.println("相等");  
}
```
&emsp;&emsp;**equals()**是**Object**的方法,所以对所有对象都适用。**默认**为:  
```java
public boolean equals(Object obj) {  
    return (this == obj);  
}
```
&emsp;&emsp;**String.equals()**  
```java
public boolean equals(Object anObject) {  
    if (this == anObject) {  
        return true;  
    }  
    if (anObject instanceof String) {  
        String aString = (String)anObject;  
        if (coder() == aString.coder()) {  
            return isLatin1() ? StringLatin1.equals(value, aString.value) 
                : StringUTF16.equals(value, aString.value);  
        }  
    }  
    return false;  
}
```
&emsp;&emsp;**String**类重写**equals**方法时,首先判断如果是自己直接返回**true**,如果不是自己,判断参数是否为**String**类型,不是则返回**false**。之后就是比较字符串内容是否相等了。  
&emsp;&emsp;堆和常量池的区别:  
&emsp;&emsp;Java的存储空间：寄存器、栈、**堆**、静态存储区、**常量存储区(常量池)**、其他存储位置。  
&emsp;&emsp;此处重点介绍堆和常量存储区：  
&emsp;&emsp;**堆**：存储**new**的对象;  **常量池**：用来存储**final static**、**String**的常量。  
&emsp;&emsp;**Object.equals**与**String.equals**的区别  
&emsp;&emsp;**Object.equals(==)**：**比较内存地址;**  
&emsp;&emsp;**String.equals: 比较内容,不管内存地址。**  
&emsp;&emsp;**Object.equals**相等,**String.equals一定**相等;  
&emsp;&emsp;**String.equals**相等,**Object.equals不一定**相等。  
&emsp;&emsp;实例  
```java
&emsp;&emsp;// 维护在常量池里面    
String a="hello";  
String b="hello";  
// new出来的所有对象都在堆内存中  
// 只要是new出现来的都是新对象  
String c=new String("hello");  
String d=new String("hello");  
// 对比内存地址  
System.out.println("a==b = " + (a == b));  
System.out.println("a==c = " + (a == c));  
System.out.println("c==d = " + (c == d));  
// 对比内容  
System.out.println("a.equals(b) = " + a.equals(b));  
System.out.println("a.equals(c) = " + a.equals(c));  
System.out.println("c.equals(d) = " + c.equals(d));
```
&emsp;&emsp;结果:  
```text
a==b = true
a==c = false
c==d = false
a.equals(b) = true
a.equals(c) = true
c.equals(d) = true
```
&emsp;&emsp;**a**,**b**都是常量,**a**和**b**都是指向常量存储区中的常量**'hello'**,所以无论内容还是内存地址都是一样的,因此**a==b**以及**a.equals(b)**都是**true**;  
&emsp;&emsp;**c,d**都是变量,他们都是**new**出来的对象,里面存在两个**hello**变量,**c**和**d**分别指向自己的**hello**变量,所以**c**和**d**内容一样,但是内存地址不一样,因此**c==d**是**false**,但是**c.equals(d)**为**true**。  
### 常用方法
1. `equals(Object obj)`: 比较两个字符串值是否相等。
2. `equalsIgnoreCase(String anotherString)`: 比较两个字符串值是否相等，忽略大小写。
3. `length()`: 返回字符串的长度。
4. `charAt(int index)`: 返回指定索引处的字符。
5. `substring(int beginIndex)`: 返回从指定索引开始到字符串末尾的子字符串。
6. `substring(int beginIndex, int endIndex)`: 返回从beginIndex开始到endIndex-1的子字符串。
7. `indexOf(String str)`: 返回指定子字符串在原字符串中第一次出现的索引。
8. `lastIndexOf(String str)`: 返回指定子字符串在原字符串中最后一次出现的索引。
9. `contains(CharSequence s)`: 判断是否包含指定的字符序列。
10. `startsWith(String prefix)`: 判断字符串是否以指定前缀开头。
11. `endsWith(String suffix)`: 判断字符串是否以指定后缀结尾。
12. `isEmpty()`: 判断字符串是否为空。
13. `isBlank()`: 判断字符串是否只有空白字符。
14. `toUpperCase()`: 将字符串转换为大写。
15. `toLowerCase()`: 将字符串转换为小写。
16. `trim()`: 去除字符串两端的空白字符。
17. `strip()`: 去除字符串两端的空白字符，包括中文空格。
18. `replace(char oldChar, char newChar)`: 替换字符串中的字符。
19. `replace(String old, String new)`: 替换字符串中的old为new。
20. `replaceAll(String regex, String new)`: 正则替换。
21. `split(String regex)`: 根据给定正则表达式分隔字符串。
22. `String.join(CharSequence delimiter, CharSequence... elements)`: 使用指定分隔符delimiter连接多个字符串。
23. `String.format(String format, Object... args)`: 使用指定格式化字符串和参数创建格式化字符串。
24. `formatted(Object... args)`: 格式化字符串，同上，只是format变成了调用方。。
25. `matches(String regex)`: 判断字符串是否匹配指定的正则表达式。
27. `String.valueOf(Object o)`:转换为字符串。

### 字符串转其他类型
&emsp;&emsp;将**radix**进制的**s**转换为十进制数。`Integer.parseInt(String s[,int radix=10])`  **radix**的范围是在2~36之间,超出范围会**抛异常**，**s**的长度也**不能超出**7,否则也会抛异常。    
&emsp;&emsp;要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为`int`类型：  
```java
int n1 = Integer.parseInt("123"); // 123
int n2 = Integer.parseInt("ff", 16); // 按十六进制转换，255
```
&emsp;&emsp;把字符串转换为`boolean`类型：  
```java
boolean b1 = Boolean.parseBoolean("true"); // true
boolean b2 = Boolean.parseBoolean("FALSE"); // false
```
&emsp;&emsp;**Double.parseDouble**方法是把数字类型的字符串,转换成**double**类型  
&emsp;&emsp;**Double.valueOf**方法是把数字类型的字符串,转换成**Double**类型  
&emsp;&emsp;可以看出大体是没有任何区别,就是返回值的**类型**区别  
```java
double a=Double.parseDouble("123");  
Double b=Double.valueOf("123");
```
&emsp;&emsp;**valueOf**方法在返回的时候**new Double()**,所以返回的是**Double**。  
&emsp;&emsp;**intValue()**表示拆箱，将对象类型转换为基础类型  
&emsp;&emsp;**valueOf()**表示装箱，将基础类型转换为对象类型  
&emsp;&emsp;要特别注意，`Integer`有个`getInteger(String)`方法，它不是将字符串转换为`int`，而是把该字符串对应的系统变量转换为`Integer`：  
```java
Integer.getInteger("java.version"); // 版本号，11
```
&emsp;&emsp;`String`和`char[]`类型可以互相转换，方法是：  
```
char[] cs = "Hello".toCharArray(); // String -> char[]
String s = new String(cs); // char[] -> String
```
&emsp;&emsp;如果修改了`char[]`数组，`String`并不会改变。  
```java
char[] cs = "Hello".toCharArray();
String s = new String(cs);
System.out.println(s);
cs[0] = 'X';
System.out.println(s);
```
&emsp;&emsp;这是因为通过`new String(char[])`创建新的`String`实例时，它并不会直接引用传入的`char[]`数组，而是会复制一份，所以，修改外部的`char[]`数组不会影响`String`实例内部的`char[]`数组，因为这是两个不同的数组。  
&emsp;&emsp;从`String`的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。  
###  字符编码
&emsp;&emsp;在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从`0`到`127`，最高位始终为`0`，称为`ASCII`编码。例如，字符`'A'`的编码是`0x41`，字符`'1'`的编码是`0x31`。  
&emsp;&emsp;如果要把汉字也纳入计算机编码，很显然一个字节是不够的。`GB2312`标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为`1`，以便和`ASCII`编码区分开。例如，汉字`'中'`的`GB2312`编码是`0xd6d0`。 
&emsp;&emsp;类似的，日文有`Shift_JIS`编码，韩文有`EUC-KR`编码，这些编码因为标准不统一，同时使用，就会产生冲突。  
&emsp;&emsp;为了统一全球所有语言的编码，全球统一码联盟发布了`Unicode`编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。  
&emsp;&emsp;`Unicode`编码需要两个或者更多字节表示，我们可以比较中英文字符在`ASCII`、`GB2312`和`Unicode`的编码：  
&emsp;&emsp;英文字符`'A'`的`ASCII`编码和`Unicode`编码：  
```ascii
         ┌────┐
ASCII:   │ 41 │
         └────┘
         ┌────┬────┐
Unicode: │ 00 │ 41 │
         └────┴────┘
```
&emsp;&emsp;英文字符的`Unicode`编码就是简单地在前面添加一个`00`字节。  
&emsp;&emsp;中文字符`'中'`的`GB2312`编码和`Unicode`编码：  
```ascii
         ┌────┬────┐
GB2312:  │ d6 │ d0 │
         └────┴────┘
         ┌────┬────┐
Unicode: │ 4e │ 2d │
         └────┴────┘
```
&emsp;&emsp;那我们经常使用的`UTF-8`又是什么编码呢？因为英文字符的`Unicode`编码高字节总是`00`，包含大量英文的文本会浪费空间，所以，出现了`UTF-8`编码，它是一种变长编码，用来把固定长度的`Unicode`编码变成1～4字节的变长编码。通过`UTF-8`编码，英文字符`'A'`的`UTF-8`编码变为`0x41`，正好和`ASCII`码一致，而中文`'中'`的`UTF-8`编码为3字节`0xe4b8ad`。  
&emsp;&emsp;`UTF-8`编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为`UTF-8`编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。  
&emsp;&emsp;在Java中，`char`类型实际上就是两个字节的`Unicode`编码。如果我们要手动把字符串转换成其他编码，可以这样做：  
```java
byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
```
&emsp;&emsp;注意：转换编码后，就不再是`char`类型，而是`byte`类型表示的数组。  
&emsp;&emsp;如果要把已知编码的`byte[]`转换为`String`，可以这样做：  
```java
String s1 = new String(b, "GBK"); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
```
&emsp;&emsp;始终牢记：Java的`String`和`char`在内存中总是以Unicode编码表示。  
&emsp;&emsp;对于不同版本的JDK，`String`类在内存中有不同的优化方式。具体来说，早期JDK版本的`String`总是以`char[]`存储，它的定义如下：  
```java
public final class String {
    private final char[] value;
    private final int offset;
    private final int count;
}
```
&emsp;&emsp;而较新的JDK版本的`String`则以`byte[]`存储：如果`String`仅包含ASCII字符，则每个`byte`存储一个字符，否则，每两个`byte`存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的`String`通常仅包含ASCII字符：  
```java
public final class String {
    private final byte[] value;
    private final byte coder; // 0 = LATIN1, 1 = UTF16
```
&emsp;&emsp;对于使用者来说，`String`内部的优化不影响任何已有代码，因为它的`public`方法签名是不变的。  
### 字符串拼接
&emsp;&emsp;**StringBuilder**  
&emsp;&emsp;Java编译器对`String`做了特殊处理，使得我们可以直接用`+`拼接字符串。  
```java
String s = "";
for (int i = 0; i < 1000; i++) {
    s = s + "," + i;
}
```
&emsp;&emsp;虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。  
&emsp;&emsp;为了能高效拼接字符串，Java标准库提供了`StringBuilder`，它是一个可变对象，可以预分配缓冲区，这样，往`StringBuilder`中新增字符时，不会创建新的临时对象。`StringBuilder`还可以进行链式调用。使用append()方法添加字符串，然后使用toString()方法返回拼接后的字符串。  
&emsp;&emsp;对于普通的字符串`+`操作，并不需要我们将其改写为`StringBuilder`，因为Java编译器在编译时就自动把多个连续的`+`操作编码为`StringConcatFactory`的操作。在运行期，`StringConcatFactory`会自动把字符串连接操作优化为数组复制或者`StringBuilder`操作。  
&emsp;&emsp;`StringBuffer`，是Java早期的一个`StringBuilder`的线程安全版本，它通过同步来保证多个线程操作`StringBuffer`也是安全的，但是同步会带来执行速度的下降。`StringBuilder`和`StringBuffer`接口完全相同，现在完全没有必要使用`StringBuffer`。  
&emsp;&emsp;**StringJoiner**  
&emsp;&emsp;要高效拼接字符串，应该使用`StringBuilder`。  
&emsp;&emsp;很多时候，我们拼接的字符串像这样：  
```java
String[] names = {"Bob", "Alice", "Grace"};
var sb = new StringBuilder();
sb.append("Hello ");
for (String name : names) {
    sb.append(name).append(",");
}
// 注意去掉最后的", ":
sb.delete(sb.length() - 1, sb.length());
sb.append("!");
System.out.println(sb.toString());
```
&emsp;&emsp;类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个`StringJoiner`来干这个事，构造方法可以在第二个参数和第三个参数传入开头的结尾：  
```java
String[] names = {"Bob", "Alice", "Grace"};
var sj = new StringJoiner(",", "Hello ", "!");
for (String name : names) {
    sj.add(name);
}
System.out.println(sj.toString());
```
&emsp;&emsp;**String.join()**  
&emsp;&emsp;`String`还提供了一个静态方法`join()`，这个方法在内部使用了`StringJoiner`来拼接字符串，在不需要指定“开头”和“结尾”的时候，用`String.join()`更方便：  
```java
String[] names = {"Bob", "Alice", "Grace"};
var s = String.join(", ", names);
```

## 数组
&emsp;&emsp;定义一个数组类型的变量，使用数组类型`类型[]`，例如，`int[]`。和单个基本类型变量不同，数组变量初始化**必须**使用`new int[5]`表示创建一个可容纳5个`int`元素的数组。  
- 数组所有元素初始化为默认值，整型都是`0`，浮点型是`0.0`，布尔型是`false`；
- 数组一旦创建后，**大小**就**不可改变**。

&emsp;&emsp;要访问数组中的某一个元素，需要使用索引。数组索引从`0`开始，例如，5个元素的数组，索引范围是`0`~`4`。  
&emsp;&emsp;可以修改数组中的某一个元素，使用赋值语句，例如，`ns[1] = 79;`。  
&emsp;&emsp;可以用`数组变量.length`获取数组大小。  
&emsp;&emsp;数组是引用类型，在使用索引访问数组元素时，如果**索引超出范围**，运行时将报错。  
&emsp;&emsp;可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：  
```java
 int[] ns = new int[] { 68, 79, 91, 85, 62 };
```
&emsp;&emsp;**还可以进一步简写为**：  
```java
int[] ns = { 68, 79, 91, 85, 62 };
```
&emsp;&emsp;对于**简单数据类型**的数组,当对其进行初始化时,会将对应的值赋给对应的各个数组元素。    
&emsp;&emsp;在定义数组的时候,系统会给这个数组分配用于存放这个数组的内存空间：它会在**堆(Heap)**内存空间中给数组分配—个空间用于存放数组变量。  
&emsp;&emsp;**引用数据类型**数组在创建的时候也是首先给数组元素分配**內存空间**然后给这些数组元素一个默认的初始值**null.**  
&emsp;&emsp;在进行**引用数据类型**数组的初始化的时候,和**简单数据类型**数组的初始化有些**不同**,因为数组**本身是引用类**型,而现在**数组元素也是**引用类型,所以这个时候需要给数组元素**所引用**的对象**也分配**内存空间。  
```java
String[] arr = new String[10];  
arr[0] = new String("one");  
arr[1] = new String("two");  
arr[2] = new String("three");  
arr[3] = new String("Iou");  
arr[4] = new String("five");  
arr[5] = new String("six");  
arr[6] = new String("seven");  
arr[7] = new String("eight");  
arr[8] = new String("nine");  
arr[9] = new String("ten");  
System.out.println(Arrays.toString(arr));
```

------

&emsp;&emsp;数组**没有length()**这个方法,**String有length()**这个方法。    
```java
int[] a =new int[8];  
System.out.println(a.length);//8  
String s = "012345678";  
int length = s.length();  
System.out.println(length);//9
```
&emsp;&emsp;**s.charAt(n)**  
&emsp;&emsp;获取**字符串**的第**n+1**个字符  
```java
String s="hello world";  
System.out.println(s.charAt(0));//h
```
&emsp;&emsp;**import java.util.Arrays;**  
&emsp;&emsp;**Arrays.toString(arr)**  
&emsp;&emsp;格式化的将数组内容转为字符串  
```java
int[] b ={1,2,3,4,5};  
System.out.println(Arrays.toString(b));//[1, 2, 3, 4, 5]
```
&emsp;&emsp;**Arrays.sort(arr)**  
&emsp;&emsp;对数组进行**升序**排序  
```java
int[] a = {12, 3, 19, 2, 10, 13};  
System.out.println("before sort:");  
for (int value : a) System.out.print(value + " ");  
System.out.println();  
Arrays.sort(a);  
System.out.println("after sort:");  
for (int value : a) System.out.print(value + " ");
```
&emsp;&emsp;输出:  
```text
before sort:
12 3 19 2 10 13
after sort:
2 3 10 12 13 19
```
&emsp;&emsp;数组可直接相互**热拷贝**(a,b**相同指向**)  
```java
int[] a={1,2,3},b=a;  
System.out.println(Arrays.toString(a));//[1, 2, 3]  
a[0]=9;  
System.out.println(Arrays.toString(b));//[9, 2, 3]
```
&emsp;&emsp;冷拷贝  
&emsp;&emsp;**System.arraycopy(src, srcPos, dest, destPos, length)**  
&emsp;&emsp;从**src**\[**srcPos**\]开始复制**length**个元素到**dest**\[**destPos**\]的对应位置上.  

| 参数    | 说明                     |
| ------- | ------------------------ |
| src     | 源数组。                 |
| srcPos  | 源数组中的起始位置。     |
| dest    | 目标数组。               |
| destPos | 目标数据中的起始位置。   |
| ength   | 要复制的数组元素的数量。 |

```java
int[] a ={1,2,3,4,5,6,7,8,9,10};  
int[] b ={100,200,300,400,500,600,700,800,900,100};  
System.arraycopy(a,2,b,5,5);  
System.out.println("b = " + Arrays.toString(b));//b = [100, 200, 300, 400, 500, 3, 4, 5, 6, 7]
```
&emsp;&emsp;完整复制:  
```java
int[] a ={12, 3, 19, 2, 10, 13},b=new int[a.length];  
System.arraycopy(a,0,b,0,a.length);  
System.out.println(Arrays.toString(b));//[12, 3, 19, 2, 10, 13]
```
## 多维数组
&emsp;&emsp;当使用**new**来创建多维数组时,不必指定每一维的大小而**只需要**指定**最左边**的维的大小就可以了。如果你指定了其中的某一维的大小,那么所有处于这一维**左边**的各维的大小**都要**指定。  
&emsp;&emsp;动态初始化  
```java
int[][][] a = new int[2][2][4];  
int[][] ab = new int[2][];
```
&emsp;&emsp;静态初始化  
```java
double[][][] a2 = {  
    {
        {1.1, 2.2}, {3.3, 4.4}
    },{
        {5.5, 6.6}, {7.7, 8.8}
    },{
        {9.9, 1.2}, {2.3, 3.4}
    },  
};  
System.out.println(Arrays.deepToString(a2));
```
&emsp;&emsp;多维数组也可以通过数组声明和初始化分开的动态初始化方法来对数组进行初始化  
```java
double[][][] a2 = new double[2][3][4];
```
&emsp;&emsp;java中多维数组的声明和初始化应按从高维到低维的顺序进行  
```java
int[][] a = new int[3][];  
a[0] = new int[2];  
a[1] = new int[4];  
a[2] = new int[3];
```
&emsp;&emsp;获取某维长度例子:  
```java
int[][] x = {
    {1, 2}, {3, 4, 5}, {6}, {}
};  
System.out.println(x[1].length);//3  
System.out.println(x.length);//4
```
&emsp;&emsp;`Arrays.deepToString()`可以输出多维数组
## 流程控制
&emsp;&emsp;`switch`语句根据`switch (表达式)`计算的结果，跳转到匹配的`case`结果，然后继续执行后续语句，直到遇到`break`结束执行。字符串匹配时，是比较“内容相等”。  
```java
switch (option) {
    case 3:
        ...
            break;
    case 2:
        ...
            break;
    case 1:
        ...
            break;
    default:
        ...
}
```
&emsp;&emsp;使用`switch`时，注意`case`语句并没有花括号`{}`，而且，`case`语句具有“穿透性”，漏写`break`将导致意想不到的结果。  
&emsp;&emsp;从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且**不需要**`break`语句，还可以直接返回值。  
&emsp;&emsp;如果有多条语句，需要用`{}`括起来，若这时需要返回值则需要用`yield`。还可以使用多个匹配项，用逗号分隔：  
```java
String fruit = "pear";
int opt = switch (fruit) {
    case "apple" -> 1;
    case "pear", "mango" -> {
        System.out.println("pear or mango");
        yield 2;
    }
    default -> 0;
};// 注意赋值语句要以;结束
System.out.println("opt = " + opt);
```

------

&emsp;&emsp;使用`for`循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。`break`结束整个循环`continue`结束本次循环，整个循环继续执行。  
&emsp;&emsp;使用label跳出多重循环（尽量不要使用）。  
```java
OUTER:  
//outer label  
for (int i = 0; i < 4; i++) {  
    INNER:  
    //inter label  
    for (int j = 0; j < 4; j++) {  
        System.out.print("轮次: " + (i*4+j+1));  
        if (i == 1) {  
            System.out.println(" 未执行完");  
            break INNER;//跳出内层for(),执行下一轮  
        }  
        System.out.println(" 完整执行");  
    }  
}
```
&emsp;&emsp;结果:  
```text
轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
轮次: 9 完整执行
轮次: 10 完整执行
轮次: 11 完整执行
轮次: 12 完整执行
轮次: 13 完整执行
轮次: 14 完整执行
轮次: 15 完整执行
轮次: 16 完整执行
```
```java
OUTER:  
//outer label  
for (int i = 0; i < 4; i++) {  
    INNER:  
    //inter label  
    for (int j = 0; j < 4; j++) {  
        System.out.print("轮次: " + (i*4+j+1));  
        if (i == 1) {  
            System.out.println(" 未执行完");  
            break OUTER;//跳出外层for(),执行下一个语句  
        }  
        System.out.println(" 完整执行");  
    }  
}
```
&emsp;&emsp;结果:  
```text
轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
```
## java关键字表

| abstract     | assert     | boolean | break     | byte      | continue   |
|--------------|------------|---------|-----------|-----------|------------|
| case         | catch      | char    | class     | const     | double     |
| default      | do         | else    | enum      | extends   | final      |
| finally      | float      | for     | goto      | if        | implements |
| import       | instanceof | int     | interface | long      | native     |
| new          | null       | package | private   | protected | public     |
| return       | short      | static  | strictfp  | super     | switch     |
| synchronized | this       | throw   | throws    | transient | try        |
| void         | volatile   | while   |           |           |            |

&emsp;&emsp;**volatile** 关键字用于标记字段可能会被多个线程同时访问，告诉编译器不要对这个字段进行优化，因为它的值可能会在其他线程中更改。这可以确保每次读取字段时都从内存中读取最新的值，而不是使用缓存中的旧值。  
&emsp;&emsp;**transient** 关键字用于告诉编译器在序列化时忽略字段。当对象被序列化时，**transient** 修饰的字段的值不会被保存。  
&emsp;&emsp;**native**本地方法，由本地其他语言代码实现  
&emsp;&emsp;**synchronized** 关键字用于实现线程同步，确保多个线程在访问共享资源时不会发生冲突。当一个线程访问一个对象的 **synchronized** 方法或代码块时，其他线程必须等待，直到该线程执行完成释放锁。  
&emsp;&emsp;**java.lang.Runnable**多线程接口。  
&emsp;&emsp;`java.lang.Runnable`是一个接口，用于表示可以由线程执行的任务。它只包含一个方法`run()`，该方法定义了线程要执行的代码。通过实现`Runnable`接口并重写`run()`方法，可以创建一个可运行的任务，然后将其传递给`Thread`类的构造函数，从而创建一个线程并启动它。  
```java
public interface Runnable {
    public abstract void run();
}
```
&emsp;&emsp;`run()`方法中包含了线程的执行逻辑，当线程启动时，会调用`run()`方法来执行任务。实现`Runnable`接口的类可以实现自己的逻辑，例如：  
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Hello, I am a runnable task.");
    }
}
public class Main {
    public static void main(String[] args) {
        Runnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }
}
```
&emsp;&emsp;在上面的例子中，`MyRunnable`实现了`Runnable`接口，并在`run()`方法中定义了要执行的任务。然后，创建一个`Thread`对象，并将`MyRunnable`实例传递给`Thread`的构造函数，最后调用`start()`方法启动线程，线程会执行`MyRunnable`中的`run()`方法。  

# 面向对象基础
## 包
&emsp;&emsp;当一个大型程序交由数个不同的程序人员开发时,用到相同的类名是很有可能的, Java程序开发中为了避免这种情况,提供了一个包的概念(**package**) 。  
&emsp;&emsp;同一个包内的类名**不允许重复**,不同包内**可以有**相同名称的类。包允许将类组合成较小的单元,类似于文件夹;在包与包之间对于类的访问权限能提供更有力的约束。  
&emsp;&emsp;使用包很简单,通过关键字**package** 声明,作为Java源文件的**第一条语句**,指明该源文件定义的类所在的包。**package**语句一般格式为:  
&emsp;&emsp;**package packageName;**  
&emsp;&emsp;包名可以是一个合法的标识符,也可以是若干个标识符加"**.**"号分割而成,点号就是文件夹的分隔. 
```java
package tom;  
package sun.com.cn;  
```
&emsp;&emsp;注意只能有一个包声明，以上只为格式例子。  
&emsp;&emsp;如果省略了**package**语句,类将保存在一个缺省的没有名称的包中;尽管缺省包很方便,但对于大型的程序,它是不恰当的;请尽量为自己编写的类定义具体的包。 
&emsp;&emsp;在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。  
&emsp;&emsp;包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。  

&emsp;&emsp;**import**  
&emsp;&emsp;在一个`class`中，我们总会引用其他的`class`，如果要使用ArrayList，可以使用完整类名：  
```java
java.util.List<String> list = new java.util.ArrayList<>();
```
&emsp;&emsp;很显然，每次写完整类名比较痛苦。那么还可以使用**import**语句。
&emsp;&emsp;使用**import**语句可以引入包中的类。Java源文件中**可以**有**多个import**语句,它们在程序中的位置是有要求的,**必须**写在**package**语句和**源文件**的类定义**之间**。  
&emsp;&emsp;要引入`java.util`包中的`Date`类,使用：
```java
import java.util.Date;
```
&emsp;&emsp;如果要引入一个包中的全部类,则可以用星号来代替,如:**import java.awt.\*;**  
&emsp;&emsp;还有一种`import static`的语法，它可以导入一个类的静态字段和静态方法：  
```java
package com.aotmd;
// 导入System类的所有静态字段和静态方法:
import static java.lang.System.*;
public class Main {
    public static void main(String[] args) {
        // 相当于调用System.out.println(…)
        out.println("Hello, world!");
    }
}
```
&emsp;&emsp;`import static`很少使用。  
&emsp;&emsp;Java编译器最终编译出的`.class`文件只使用*完整类名*，因此，在代码中，当编译器遇到一个`class`名称时：  
- 如果是完整类名，就直接根据完整类名查找这个`class`；
- 如果是简单类名，按下面的顺序依次查找：
  - 查找当前`package`是否存在这个`class`；
  - 查找`import`的包是否包含这个`class`；
  - 查找`java.lang`包是否包含这个`class`。

&emsp;&emsp;如果按照上面的规则还无法确定类名，则编译报错。  
&emsp;&emsp;因此，编写class的时候，编译器会自动帮我们做两个import动作：  
- 默认自动`import`当前`package`的其他`class`；
- 默认自动`import java.lang.*`。注意：自动导入的是`java.lang`包，但类似`java.lang.reflect`这些包仍需要手动导入。

&emsp;&emsp;如果有两个`class`名称相同，例如，`mr.jun.Arrays`和`java.util.Arrays`，那么只能`import`其中一个，另一个必须写完整类名。  

## 类
&emsp;&emsp;类是一个独立的单位,它有一个类名,其内部包括成员变量,用于描述属性;还包括类的成员方法,用于描述行为。因此,类也被认为是种抽象数据类型,这种数据类型不但包括数据,还包括方法。  
&emsp;&emsp;包含**main**方法的主类必須定义为**public**。  
&emsp;&emsp;在一个.java中可以有**多个**类,但只能有一个类为**public**修饰符,且该类的名称必须与文件名称相同.  
&emsp;&emsp;**class**为Java定义类的关键字,必须写在**修饰符**和**类名**中间,使用空格隔开.  
&emsp;&emsp;类的名字要符合Java的命名规范,同时名字要有意义能够反映出这个类的内容,**第一个字母一般为大写**.  
&emsp;&emsp;定义类的最终目的是要使用这些类,**创建**并操作某类的对象是使用该类的最主要手段。  
&emsp;&emsp;**创建类的实例对象**  
&emsp;&emsp;**类名对象名=new类名(\[参数1,参数2…\]);**  
&emsp;&emsp;例：  
```java
NoteTest t=new NoteTest();
```
&emsp;&emsp;通过运算符“**.**”,对象可以实现对**自己变量**的访问及对**自己方法**的调用。  

------

### **构造方法**  
&emsp;&emsp;构造方法是让编程人员在编写代码的时候可以更方便,少写点代码,还可以在构造方法里面加入一些初始化代码.    
&emsp;&emsp;**构造方法**是类中的一种特殊方法,是为对象**初始化**操作编写的方法,用它来定义对象的初始状态。每个类都有**构造方法**,它也是由**方法名**、**参数**和**方法体**组成。构造**方法名必须**与**类名相同**,它**没有返回值类型**,用户**不能直接调用**它,**只能**通过**new**对象实例化时由虚拟机**自动调用**.  
&emsp;&emsp;因为是由虚拟机来调用构造方法,所以构造方法一般应定义成 **public**  
&emsp;&emsp;**每个**对象在生成时都**必须**执行构造方法,而且只能执行一次;如果构造方法调用失败,那么对象也无法创建;  
&emsp;&emsp;在没有定义构造方法的情况下,类会**自动**产生一个无参数的默认构造方法,这个默认的构造方法什么都不做;一旦**显式**地定义了构造方法,默认的无参构造方法自动消失,若此时还需要无参构造方法,则需要显示地重新定义。  
&emsp;&emsp;一个类可以有多个**构造方法**,**构造方法可以被重载**  
```java
class User {  
    public String uid,username,password;  
    public User() {}  
    public User(String uid, String username, String password) {  
        this.uid = uid;  
        this.username = username;  
        this.password = password;  
    }  
}
```
### this
&emsp;&emsp;**this**就是指代当前对象 ,**this可以**出现在**实例方法**和**构造方法**中,但**不可以**出现在**类方法**中。    
&emsp;&emsp;当**局部变量**和**成员变量**的名字**相同**时,成员变量就会被隐藏,这时如果想在成员方法中使用成员变量,就必须便用关键字**this**.  
&emsp;&emsp;语法：  
&emsp;&emsp;**this.成员变量名**  
&emsp;&emsp;**this.成员方法名()**  
&emsp;&emsp;**this()**  
&emsp;&emsp;通过**this()**可以调用自己的其他**构造方法**.  
&emsp;&emsp;在使用**this**调用构造方法的时候有以下规范:  
&emsp;&emsp;所有的**构造方法**是在对象实例化的时候被默认调用而且是在调用普通方法**之前**调用,所以使用"**this()**”**调用构造方法**的操作,一定要放在构造方法的**首行**,首行指第一条语句,且在一个构造方法里**只能调用一个**;  
&emsp;&emsp;如果一个类之中存在多个构造方法,且这些构造方法都使用了**this()**互相调用,那么至少要保留一个构造方法没有调用其他构造方法,以作为程序的出口。(不能陷入死循环)  
&emsp;&emsp;**this不能**用在**static**方法中！(java中类的方法池中都有一个隐含的参数**this**,他表示本对象的引用但是**static**方法是没有这个隐含参数的,因为**static**方法和类的实例无关它只在类装载的时候初始化,很多书都把静态变量称作类级变量)  
### **类的封装**
&emsp;&emsp;在设计一个类时,应该对成员变量的访问作出一些**限定**,不允许外界随意访问.这就需要实现类的封装。  
&emsp;&emsp;所谓类的封装是指在定义一个类时,将类中的属性**私有化**,即使用 **private**关键字来修饰,私有属性只能在它所在**类中**被访问,如果外界想要访问私有属性,需要使用**公有**方法进行间接调用,其中包括用于获取属性值的 getXxx方法和设置属性值的 setXxx方法。  

| 访问修饰符 | 本类 | 同包子类 | 同包非子类 | 不同包子类 | 不同包且非子类 |
|------------|------|----------|------------|------------|----------------|
| private    | 是   | 否       | 否         | 否         | 否             |
| 默认       | 是   | 是       | 是         | 否         | 否             |
| protected  | 是   | 是       | 是         | 是         | 否             |
| public     | 是   | 是       | 是         | 是         | 是             |

### tostring()
&emsp;&emsp;**public String toString()**返回该对象的字符串表示。通常,**ToString**方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。  
```java
public class Test{  
    private int a,b;  
    public Test(int a, int b) { this.a = a;this.b = b; }  
    public static void main(String[] args) {  
        System.out.println(new Test(1,2));//默认调用toString()  
    }  
    @Override  
    public String toString() {  
        return "Test{a=" + a + ", b=" + b + '}';  
    }  
}
```
### **实例方法，类方法**  
&emsp;&emsp;实例方法就是对象方法,和类方法的区别是,类方法有**static**关键字,**不需要实例**,**直接类名调用**，类属性也是如此。  
```java
public class NoteTest {  
    public static int a=1;//类属性  
    public int b=2;//实例属性  
    public void f1(){};//实例方法  
    public static void f2() {}//类方法  
    public static void main(String args[]){//类方法    
        NoteTest noteTest=new NoteTest();  
        System.out.println(noteTest.b);  
        noteTest.f1();  
        System.out.println(NoteTest.a);  
        NoteTest.f2();  
    }  
}
```
&emsp;&emsp;类方法，类属性也可以通过实例调用，但这没有意义。这通常是不推荐的做法，因为类方法和类属性是与类相关联的，而不是与实例相关联的。正确的做法是通过类名直接调用类方法和访问类属性。通过实例调用类方法和类属性可能会造成混淆，不利于代码的清晰性和维护性。  
&emsp;&emsp;在代码中，实例对象能访问类字段只是因为编译器可以根据实例类型自动转换为`类名.静态字段`来访问静态对象。对于类方法也是如此。  
&emsp;&emsp;静态方法（类方法）属于类而不属于实例，因此，静态方法内部，无法访问`this`变量，也无法访问实例字段，它只能访问静态字段（类字段/类属性）。  

## 方法
&emsp;&emsp;**方法**是完成特定功能的、相对独立的程序段。**方法**一旦定义,就可以在不同的程序段中多次调用,故方法可以增强程序结构的清晰度,提高编程效率。在Java程序中,**方法只能在类**中声明,格式如下: 
&emsp;&emsp;**\[修饰符\] 返回值类型 方法名 \[(参数表)\]{**  
&emsp;&emsp;**声明部分**  
&emsp;&emsp;**语句部分**  
&emsp;&emsp;**}**  
&emsp;&emsp;方法声明包括方法头和方法体2部分  
1. 修饰符可以是公共访问控制符**public**、私有访冋控制符**private**、保护访问控制符 **protected**等。  
2. 类型标识符反映方法完成其功能后返回的运算结果的数据类型。如果方法**没有返回值**,用**void**关键字指明。  
3. 方法名要符合标识符的命名规则,不要与Java中的关键字**重名**。  
4. 参数表指定在**调用**该方法时,应该传递的参数的个数和数据类型。  
5. 对于**有返回值**的方法,其方法体中至少有一条`return`语句。
6. 对于**没有返回值**的方法，可以用`return;`终止执行方法。
7. 方法声明**不能嵌套**,即不能在方法中再声明其它的方法。  

&emsp;&emsp;对于有返回值的方法作为表达式或表达式的一部分来调用,其在表达式中出现的形式为：  
&emsp;&emsp;**方法名(\[实际参数表\])**  
```java
public class NoteTest {  
    static int act(){  
        return 1;  
    }  
    public static void main(String[] args) {  
        System.out.println("act() = " + act());  
    }  
}
```
&emsp;&emsp;在调用一个带有**形式参数**的方法时,必须为方法提供**实际参数**,完成实际参数与形式参数的结合,称为参数传递,然后用实际参数执行所调用的方法体。**在Java中**,参数传递是以**传值**的方式进行,即**将实际参数的值传递给形式参数.**同构造方法一样，普通方法也可以进行重载。
### **可变参数**
&emsp;&emsp;可变参数用`类型...`定义，可变参数相当于数组类型。Java中的可变参数（varargs）实际上是一种**语法糖**，编译器会将传递给可变参数的参数**封装成一个数组**，因此可以像处理数组一样处理这些参数。这种语法糖使得方法的调用更加简洁，不再需要手动创建数组来传递参数。  
&emsp;&emsp;如果对带有可变参数的方法传入`null`，编译器会不知道怎么处理，编译器无法确定应该创建一个空数组还是一个包含一个`null`元素的数组。这种情况下，编译器会产生一个警告（warning），提示可能会有`NullPointerException`的风险。因此，在使用可变参数时，应该**避免**传入`null`。  
### **递归程序**
```java
public class NoteTest {  
    static int test(int n){  
        if (n==1) return 1;  
        return test(n-1)*n;  
    }  
    public static void main(String[] args) {  
        System.out.println("5! = " + test(5));//5! = 120  
    }  
}
```
## 继承
&emsp;&emsp;最高层是**最普遍**的、**最一般**的情况,往下每一层都比上一层**更具体**,并包含有高层的特征,通过这样的层次结构使下层的类能自动享用上层类的特点和性质;  
&emsp;&emsp;继承其实就是自动地共享被继承类中成员属性和成员方法的机制。  
&emsp;&emsp;继承是利用现有的类创建新类的过程,现有的类称作基类(或父类),创建的新类称作派生类(子类)  
&emsp;&emsp;在Java中实现继承需要使用到**extends**关键字;  
> **\[访问修饰符\] class 派生类名 extends 基类名{**  
**成员列表**  
**}**  

&emsp;&emsp;如:  
```java
class Student extends User{}
```
&emsp;&emsp;在Java中，每个类都具有父类。如果一个类没有声明父类，则默认情况下会继承`java.lang.Object`。  
&emsp;&emsp;**严禁定义与父类重名的字段**  
&emsp;&emsp;在Java中，严禁定义与父类重名的字段是为了避免可能引起的混淆和语义歧义。具体来说，这样的限制主要是为了维护良好的代码可读性和可维护性，避免潜在的错误和困惑。当子类定义了与父类同名的字段时，可能会导致以下问题：  
1. 语义歧义：同名字段可能具有不同的含义，这会使代码的意图变得模糊，增加理解和维护的难度。
2. 可见性问题：如果子类定义了与父类同名的字段，可能会掩盖父类的字段，导致无法访问父类的字段，从而造成错误或者逻辑混乱。
3. 潜在的错误：当同名字段在父类和子类中同时存在时，应用继承关系的代码可能会对同名字段产生矛盾的假设，从而引发潜在的错误。

&emsp;&emsp;为了避免上述问题，Java语言规范明确禁止在子类中定义与父类同名的字段。如果子类需要引用父类的字段，应该通过**super**关键字或者在父类中提供合适的访问方法。  
&emsp;&emsp;总之，严禁定义与父类重名的字段是为了保证代码的清晰性、可读性和可维护性，以及避免可能引起的混淆和错误。  
### **继承的作用**
- 引入继承,实现了代码重用;  
- 引入继承,实现了递增式的程序设计。  
- 继承是能自动传播代码和重用代码的有力工具;  
- 继承能够在某些比较一般的类的基础上建造、建立和扩充新类;  
- 能减少代码和数据的重复冗余度,并通过增强一致性来减少模块间的接口和界面,从而增强了程序的可维护性。  
- 能清晰地体现出类与类之间的层次结构关系。  

### **继承的限制**
&emsp;&emsp;一个子类只能够继承一个父类,存在**单继承**局限，子类不会继承任何父类的构造方法。  
&emsp;&emsp;子类可以获得**除private**权限**以外**的所有父类属性,但是：  
&emsp;&emsp;在创建子类的对象时**默认**先执行调用父类的无参构造方法，然后再执行子类自己的**构造方法**。要取消这个默认行为，子类可以在自己的**构造方法**中使用**super**关键字来调用父类的**含参数构造方法**,但这个调用语句**必须**是子类构造方法的**第一个**可执行语句。  
&emsp;&emsp;若不显示的进行**super**,则会自动调用**super()**;若此时父类没有**无参构造函数**则会出错.  
```java
class Father {  
    public Father(int a) {  
        System.out.println("父类带参构造函数");  
    }  
}  
class Son extends Father {  
    public Son() {  
        super(1);//必须  
        System.out.println("子类无参构造函数");  
    }  
}
```
### **super**  
- 在**子类的构造方法**中,**super**关键字可以**显式**地调用父类的构造方法,用于将参数传递给它;需要注意的是：**该语句必须是子类构造方法的第一条语句。**  其一般语法是：  `super(实际参数);`  
- 如果父类和子类中有**同名成员**,在子类中默认访问是属于自己的那一个成员;  **super**可以访问父类的**变量**或**方法**，值得注意的是，`super`关键字访问的是父类中已经实例化的成员，而**不会影响**到子类中的同名成员。 

&emsp;&emsp;**super**关键字可以明确地指定要访问父类中的成员;前提条件是：父类中的该成员**不是private**的。  这种用法中**不需要**像**构造方法**中一样需要限定为第一条语句.  
&emsp;&emsp;其一般语法是：  
&emsp;&emsp;**super.成员名;**  
&emsp;&emsp;**super.方法名();**  
```java
class User {  
    public String uid;  
    public User(String uid) {  
        this.uid = uid;  
    }  
    @Override  
    public String toString() {  
        return "User{uid='" + uid + '\\' + '}';  
    }  
}  
class Student extends User{  
    public String username;  
    public Student(String uid,String username) {  
        super(uid);//必须,否则自动调用super(),然后报错  
        this.username=username;  
    }  
    @Override  
    public String toString() {  
        String s="";  
        s=super.toString()+"\nStudent{uid='" + uid + '\\' + ", username='" + username + '\\' + '}';;  
        return s;  
    }  
    public static void main(String[] args) {  
        System.out.println(new Student("1", "张三"));  
    }  
}
```
### **final**  
&emsp;&emsp;**final**修饰符可以修饰类、成员变量和方法。
- 对于类，**final**表示该类不能被继承，即它是一个最终类，不能有子类。
- 对于方法，**final**表示该方法不能被子类重写，即它是一个最终方法。
- 对于变量，**final**表示只能被赋值一次，这意味着一旦被赋值后，就不能再改变它的值。 

&emsp;&emsp;当编译器确定一个**方法**是**final**的时候，它会使用内联（inline）机制，将方法调用直接替换为方法体的内容，这样可以避免方法调用的开销，提高执行效率。这种优化是可能的，因为**final**方法是不能被子类重写的，所以在编译时就可以确定调用的是哪个方法。    

### **阻止继承**
&emsp;&emsp;正常情况下，只要某个class没有`final`修饰符，那么任何类都可以从该class继承。  
&emsp;&emsp;从**Java 15**开始，允许使用`sealed`修饰class，并通过`permits`明确写出能够从该class继承的子类名称。例如，定义一个`Shape`类：  
```java
public sealed class Shape permits Rect, Circle, Triangle {}
```
&emsp;&emsp;上述`Shape`类就是一个`sealed`类，它只允许指定的3个类继承它。这种`sealed`类主要用于一些框架，防止继承被滥用。  
### **构造代码块/初始化块、静态代码块**
&emsp;&emsp;构造代码块和静态代码块的作用是在对象创建和类加载时执行特定的初始化操作，可以用来进行一些必要的预处理或初始化工作。  
&emsp;&emsp;构造代码块：  
- 构造代码块用于在**创建对象时**执行初始化操作。
- 构造代码块没有任何修饰符（如 public、private、protected）。
- **每次**创建对象时，构造代码块都会被执行，且**优先于**构造方法执行。
- 构造代码块中的代码实际上会被自动插入到每个构造方法的**最前面**。

&emsp;&emsp;静态代码块：  
- 静态代码块用于在**类被加载时**执行初始化操作，**仅执行一次**。
- 静态代码块使用 `static` 关键字修饰。
- 静态代码块在类加载时自动执行，且优先于构造代码块和构造方法执行。

```java
class HelloA {
    public HelloA() {
        System.out.println("helloA");
    }
    {
        System.out.println("AAA");
    }
    static {
        System.out.println("AAA static");
    }
}
class HelloB extends HelloA {
    public HelloB() {
        System.out.println("Hellob");
    }
    {
        System.out.println("BBB");
    }
    static {
        System.out.println("BBB static");
    }
    public static void main(String[] args) {
        new HelloB();
    }
}
```
&emsp;&emsp;父类静态代码块->子类静态代码块->父类构造代码块->父类构造方法->子类构造代码块->子类构造方法  
&emsp;&emsp;在Java中，类的初始化过程如下：  
1. 加载：查找并加载类的字节码文件，创建一个 `Class` 对象。
2. 连接：
   - 验证：确保字节码文件的正确性。
   - 准备：为类的静态变量分配内存，并设置默认初始值。
   - 解析：将符号引用转换为直接引用。
3. 初始化：
   - 执行类的静态代码块和静态字段的赋值操作。
   - 如果有父类，先初始化父类。

&emsp;&emsp;在实例化对象时，会先初始化类。初始化类的过程包括执行静态代码块和静态字段的赋值操作。然后执行构造方法。  
&emsp;&emsp;`HelloA`和`HelloB`都有静态代码块和构造代码块，按照上面的顺序执行会是这样的：  
1. 加载`HelloA`类和`HelloB`类。
2. 连接：
   - 验证、准备、解析。
3. 初始化`HelloA`类：
   - 执行`HelloA`类的静态代码块和静态字段的赋值操作。
4. 初始化`HelloB`类：
   - 执行`HelloB`类的静态代码块和静态字段的赋值操作。
5. 创建`HelloB`对象：
   - 执行`HelloA`的构造代码块和构造方法。
   - 执行`HelloB`的构造代码块和构造方法。

&emsp;&emsp;因此，最终的输出顺序是：  
```text
AAA static
BBB static
AAA
helloA
BBB
Hellob
```
## 多态
&emsp;&emsp;多态是面向对象的最后一个主要特征,它本身主要分为两个方面：  
&emsp;&emsp;方法的多态性：**重载**与**覆写**  
- **重载**：同一个方法名称,根据不同的参数类型及个数可以完成不同的功能;  
- **覆写**：同一个方法,根据操作的子类不同,所完成的功能也不同。  

&emsp;&emsp;对象的多态性：父子类对象的转换。  
- **向上转型**：子类对象变为父类对象,格式：**父类 父类对象=子类实例**,自动;  
- **向下转型**：父类对象变为子类对象,格式：**子类 子类对象=(子类)父类实例**,强制;  

&emsp;&emsp;**向上转型、向下转型**  
&emsp;&emsp;向上转型是将子类的实例赋值给父类的引用变量，通过父类引用来访问子类对象。子类在向上转型为父类后，只能使用父类中定义过的方法和属性，而无法直接使用子类特有的方法和属性。  
&emsp;&emsp;在向上转型后，如果需要重新使用子类特有的方法和属性，需要进行向下转型。向下转型是将父类的引用变量重新指向子类对象，并将其类型更改为子类类型，可以使用子类特有的方法和属性。  
&emsp;&emsp;在向下转型的时候，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。因此，向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。  
&emsp;&emsp;向上转型是编译时的概念，因为编译器只会检查类型是否匹配。在运行时，Java会自动调用实际对象的方法，即实现了向上转型的多态特性。  
&emsp;&emsp;为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型。`instanceof`实际上判断一个变量所指向的实例是否是**指定类型**，或者这个类型的**子类**。如果一个引用变量为`null`，那么对任何`instanceof`的判断都为`false`。  
&emsp;&emsp;从**Java 14**开始，判断`instanceof`后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：  
```java
Object obj = "hello";
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.toUpperCase());
}
```
&emsp;&emsp;可以改写如下：  
```java
Object obj = "hello";
if (obj instanceof String s) {
    // 可以直接使用变量s:
    System.out.println(s.toUpperCase());
}
```
&emsp;&emsp;这种使用`instanceof`的写法更加简洁。  
&emsp;&emsp;**方法覆盖（重写/覆写）**  
&emsp;&emsp;在类的继承体系结构中,如果子类中出现了与父类中**相同**原型的方法,那么认为子类中的方法**覆盖**了父类中的方法(也称为方法重写);通过**子类**的实例调用被覆盖的方法时,将**总是调用子类中的方法**,而父类中的方法将被**隐藏**。这是因为在运行时，Java 虚拟机会动态地确定对象的实际类型，并调用该实际类型中的方法。这种行为称为动态方法调度（Dynamic Method Dispatch）。 加上`@Override`可以让编译器帮助检查是否进行了**正确的覆盖** 。  
```java
package com.aotmd.test;  
public class NoteTest {//用于容纳main方法  
    public static void main(String[] args){  
        ParentClass parobj=new ParentClass();  
        parobj.fun();//父类的实例调用此方法  
        ChildClass chiobj=new ChildClass();  
        chiobj.fun();//子类的实例调用此方法  
    }  
}  
class ParentClass{//定义父类  
    public void fun(){  
        System.out.println("这是父类中的方法。");  
    }  
}  
class ChildClass extends ParentClass {//子类继承于父类  
    public void fun(){//子类覆盖父类中的方法  
        System.out.println("这是子类中的方法。");  
    }  
}
```
&emsp;&emsp;**区分方法覆盖和方法重载**  
&emsp;&emsp;方法覆盖(重写)和方法重载是两个极易混淆的概念,必须严格区分;  
&emsp;&emsp;方法覆盖出现的前提条件之一是**必须有继承**发生的情况下,而且要求父类和子类中的方法**必须同原型**;  
&emsp;&emsp;方法重载时,继承并不是必需的,它**只要求方法名称相同**,而参数列表则**必须不同**,换言之,各方法的**原型**其实是**不同**的。
&emsp;&emsp;父类的引用指向哪个类的实例就调用哪个类中的方法;同样是使用父类的引用,调用同一个名称的方法,却可以得到不同的调用结果，这就是多态。即：同一方法,多种形态;实际上多态包括**动态多态**和**静态多态**。  
- 静态多态也称为编译时多态,即在编译时决定调用哪个方法;  静态多态一般是指**方法重载**;  只要构成了方法重载,就可以认为形成了静态多态的条件; 静态多态与是否发生继承没有必然联系。  
- 动态多态也称为运行时多态,即在运行时才能确定调用哪个方法;形成动态多态**必须要有继承**的情况存在;在继承中必须要有**方法覆盖**;必须由基类的引用指向派生类的实例,并且通过基类的引用调用被覆盖的方法;  

&emsp;&emsp;方法签名指的是一个方法的名称、参数列表以及参数类型的组合。它用于区分相同名称但参数不同的方法，是方法重载的重要依据。方法签名包括方法名、参数类型和参数数目，不包括方法的返回值类型。例如，以下是一个方法的签名：  `public void printArray(int[] arr)` ，方法名为`printArray`，参数类型为`int[]`，参数数目为`1`，没有返回值类型。   
&emsp;&emsp;实例  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        Person p=new Person("小张", 18);  
        System.out.println(p.getPerson());  
        p=new Student("小李", 20,"中国工学院","一年级");  
        System.out.println(p.getPerson());  
        p=new GraduateStudent("小花", 22,"中国工学院","一年级","李");  
        System.out.println(p.getPerson());  
    }  
}  
class Person{  
    protected String name;  
    protected int age;  
    public Person(String name, int age) {  
        super();  
        this.name = name;  
        this.age = age;  
    }  
    public String getPerson(){  
        return "姓名:"+name+" 年龄:"+age;  
    }  
}  
class Student extends Person{  
    protected String school;  
    protected String grade;  
    public Student(String name, int age, String school, String grade) {  
        super(name, age);  
        this.school = school;  
        this.grade = grade;  
    }  
    public String getPerson() {  
        return super.getPerson()+" 学校:"+school+" 班级:"+age;  
    }  
}  
class GraduateStudent extends Student{  
    protected String mentor;  
    public GraduateStudent(String name, int age, String school, String grade, String mentor) {  
        super(name, age, school, grade);  
        this.mentor = mentor;  
    }  
    public String getPerson() {  
        return super.getPerson()+" 导师:"+mentor;  
    }  
}
```
&emsp;&emsp;输出:  
```text
姓名:小张 年龄:18
姓名:小李 年龄:20 学校:中国工学院 班级:20
姓名:小花 年龄:22 学校:中国工学院 班级:22 导师:李
```
## 抽象类
&emsp;&emsp;如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：  
```java
class Person {
    public abstract void run();
}
```
&emsp;&emsp;把一个方法声明为`abstract`，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，`Person`类也无法被实例化。**必须**把`Person`类本身也声明为`abstract`，才能正确编译它：  
```java
abstract class Person {
    public abstract void run();
}
```
&emsp;&emsp;抽象类不能被实例化，但抽象类中可以定义非抽象方法，用以为子类提供默认的实现。  
&emsp;&emsp;子类继承抽象类后，如果不是抽象类，则必须实现抽象类中的所有抽象方法，否则子类也必须定义为抽象类。因此，抽象方法实际上相当于定义了“规范”，让子类实现自己的逻辑，从而实现多态性。  
&emsp;&emsp;**使用抽象类数组（new I[]并不是实例化，而是数组特定写法）**：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        Abst[] absts=new Abst[]{new A(),new A()};
    }
}
abstract class Abst{ }
class A extends Abst{}
```
&emsp;&emsp;实际上就是（参见[数组简写](#数组)）：  
```java
A a1=new A();
A a2=new A();
Abst[] absts={a1,a2};
```


## 接口
&emsp;&emsp;接口关键字:**interface**  
&emsp;&emsp;如果某个类中的所有方法**都是**抽象方法,那么可以考虑将该类定义为接口;  
&emsp;&emsp;Java中的接口是一个特殊的抽象类,可以利用接口实现多态,同时接口也弥补了Java单一继承的弱点。一般便用接口声明**方法或常量**,接口中的方法**只能**是声明,**不能是具体的实现**。  
&emsp;&emsp;接口就是某个事物对外提供的一些功能的**申明**  
&emsp;&emsp;语法格式如下:  
> **\[修饰符\] interface 接口名\[extends父接口名列表\]{**  
> **\[public\] \[static\] \[final\]常量;**  
> **\[public\] \[abstract\]方法;**  
> **}**  


| 名词                    | 解释                                                |
| ----------------------- | --------------------------------------------------- |
| 修饰符                  | 可选,指定接口的访问权限,可选值为**public**。        |
| 接口名                  | 必选,用于指定接口的名称,一般情况下,要求首字母大写。 |
| **extends**父接口名列表 | 可选,用于继承哪些接口，可继承多个。                 |
| 方法                    | 接口中的方法**只有定义**而没有被实现。              |

&emsp;&emsp;接口定义的所有方法默认都是`public abstract`的，而所有变量也都是`public static final`的。  
&emsp;&emsp;与抽象类相似,接口同样**不可以**实例化,只能用于实现;如果某类要**实现接口**,则使用**implements**关键字.  **\[访问权限\]class类名implements接口名{ 成员列表｝**  
```java
public class MyClass implements IMyInterface {}
```
&emsp;&emsp;一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`，如果有一个以上接口被实现,则用**逗号**隔开接口名称,如下所示;  
```java
class demo implements myinterface,myconstants{}
```
&emsp;&emsp;接口调用  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        ICalc ICalc4 =new Calc();  
        System.out.println(ICalc4.add(1,2));  
    }  
}  
interface ICalc {  
    int add(int x, int y);  
    int sub(int x, int y);  
}  
class Calc implements ICalc {  
    public int add(int x, int y) { return x+y; }  
    public int sub(int x, int y) { return x-y; }  
}
```
------

&emsp;&emsp;**default**  
&emsp;&emsp;`default`方法是**Java 8**引入的接口新特性之一，它允许在接口中定义具有默认实现的方法。在接口中使用`default`关键字修饰的方法可以在接口中**直接实现**，而不需要实现类去实现这个方法。这样的好处是可以向现有的接口添加新的方法，而不会影响到已有的实现类，因为它们可以选择性地覆盖默认实现。  
```java
interface Animal {
    void eat();
    default void sleep() {
        System.out.println("Animal sleeps");
    }
}
class Dog implements Animal {
    public void eat() {
        System.out.println("Dog eats");
    }
}
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Output: Dog eats
        dog.sleep(); // Output: Animal sleeps
    }
}
```
&emsp;&emsp;需要注意的是，如果一个类实现了多个接口，而这些接口中有**相同签名**的`default`方法，那么实现类**必须覆盖**这个方法并**明确指定**调用哪个接口的方法。  
&emsp;&emsp;一个接口可以定义多个`default`方法。在实现类中，如果要调用**特定**接口的`default`方法，可以使用`接口名.super.方法名()`的语法来指定调用哪个接口的方法。例如：  
```java
interface Animal {
    default void eat() {
        System.out.println("Animal eats");
    }
    default void sleep() {
        System.out.println("Animal sleeps");
    }
}
interface Pet {
    default void play() {
        System.out.println("Pet plays");
    }
}
class Dog implements Animal, Pet {
    public void eat() {
        Animal.super.eat(); // 调用Animal接口的eat方法
    }
    public void sleep() {
        Animal.super.sleep(); // 调用Animal接口的sleep方法
    }
    public void play() {
        Pet.super.play(); // 调用Pet接口的play方法
    }
}
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Output: Animal eats
        dog.sleep(); // Output: Animal sleeps
        dog.play();  // Output: Pet plays
    }
}
```
&emsp;&emsp;接口中的默认方法（default method）**可以调用接口中的抽象方法**：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        I i=new A();
        i.out();
    }
}
interface I{
    void hi();
    default void out(){hi();}
}
class A implements I{
    @Override
    public void hi() {
        System.out.println("测试");
    }
}
```

------

&emsp;&emsp;**使用接口数组（new I[]并不是实例化，而是数组特定写法）**：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        I[] i=new I[]{new A(),new A()};
    }
}
interface I{}
class A implements I{}
```
&emsp;&emsp;实际上就是（参见[数组简写](#数组)）：  
```java
A a1=new A();
A a2=new A();
I[] i={a1,a2};
```
&emsp;&emsp;**抽象类与接口的异同**  

| 异同点     | abstract class                   | interface                            |
| :--------- | :------------------------------- | ------------------------------------ |
| 实例化     | 不能                             | 不能                                 |
| 构造方法   | 可以，为了让子类调用并完成初始化 | 不能                                 |
| 初始化块   | 可以                             | 不能，接口中只有常量，不需要。       |
| 继承       | 只能继承抽象类，使用：`extends`  | 只能继承接口，使用：`extends`        |
| 被继承     | 只能`extends`一个抽象类          | 可以`implements`多个接口             |
| 字段       | 可以                             | **只能**定义**静态常量属性**，即只读 |
| 抽象方法   | 可以定义                         | 可以定义                             |
| 非抽象方法 | **可以**包含普通方法，静态方法   | 可以定义default方法                  |

## 内部类
### 内部类
&emsp;&emsp;有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。  
&emsp;&emsp;如果一个类定义在另一个类的内部，这个类就是Inner Class：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        Outer.Inner inner=new Outer().new Inner();
    }
}
class Outer {
    class Inner {
        {
            System.out.println("已实例化");
        }
    }
}
```
&emsp;&emsp;上述定义的`Outer`是一个普通类，而`Inner`是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。  
&emsp;&emsp;要实例化一个`Inner`，必须首先创建一个`Outer`的实例，然后，调用`Outer`实例的`new`来创建`Inner`实例。这是因为Inner Class除了有一个`this`指向它自己，还**隐含**地持有一个Outer Class实例，可以用`Outer.this`访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。  
&emsp;&emsp;如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问外部类`private`的权限。  
&emsp;&emsp;包含内部类的外部类，在这个外部类里面，也可以使用内部类本身`private`的字段。  
&emsp;&emsp;观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而`Inner`类被编译为`Outer$Inner.class`。  
&emsp;&emsp;非静态内部类**不能**有静态成员变量，因为非静态内部类的实例是依赖于外部类实例存在的，而静态成员变量是不依赖于实例存在的。如果非静态内部类有静态成员变量，会导致内部类的实例和外部类实例之间产生不一致。  
### **匿名类**
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        new Outer();
    }
}
class Outer {
    public Outer() {
        I i=new I(){
            @Override
            public void out() {
                System.out.println("匿名类");
            }
        };
        i.out();
    }
}
interface I{
    void out();
}
```
&emsp;&emsp;我们在方法内部实例化了一个`I`。`I`本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了`I`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`I`。  
&emsp;&emsp;如果匿名类实现的接口只有一个方法，则可以用lamda表达式来简化代码：  
```java
I i= () -> System.out.println("匿名类");
i.out();
```
&emsp;&emsp;匿名类和Inner Class一样，可以访问Outer Class的`private`字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。  
&emsp;&emsp;观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而匿名类被编译为`Outer$1.class`。如果有多个匿名类，Java编译器会将每个匿名类依次命名为`Outer$1`、`Outer$2`、`Outer$3`……  
&emsp;&emsp;除了接口外，匿名类也完全可以继承自普通类。  
```java
Map<String, String> map1 = new HashMap<>();
Map<String, String> map2 = new HashMap<>() {}; // 匿名类!
Map<String, String> map3 = new HashMap<String, String>() {// 匿名类!
    public int a=0;
    public int out(){
        return 0;
    }
    {
        put("A", "1");
        put("B", "2");
    }
};
System.out.println(map3.get("A"));
```
&emsp;&emsp;匿名类是一种在使用过程中直接定义类的方式，适合于创建一次性的、不需要重复使用的类。在使用匿名类时，有几个要注意的地方：  
1. **作用域**：匿名类的作用域只在定义的地方，超出该作用域就无法再次使用。
2. **继承与实现**：可以继承一个类，也可以实现一个接口，但不能同时做到。在匿名类中可以重写父类的方法或实现接口的方法。
3. **访问权限**：匿名类可以访问外部类的成员变量和方法，但是外部类不能直接访问匿名类的成员变量和方法。
4. **初始化块**：可以在匿名类中使用初始化块来进行一些初始化操作，类似于构造方法，但并不是真正的构造方法，匿名类没有显式的构造方法。
5. **变量捕获**：如果在匿名类中使用了外部的变量，该变量必须是`final`或者是事实上的`final`（即在初始化后不再改变），否则编译会报错。

&emsp;&emsp;非静态内部类**不能**有静态成员变量，因为非静态内部类的实例是依赖于外部类实例存在的，而静态成员变量是不依赖于实例存在的。如果非静态内部类有静态成员变量，会导致内部类的实例和外部类实例之间产生不一致。  
### 静态内部类
&emsp;&emsp;顾名思义，就是内部内加上`static`，既然有类方法，类字段，那么这个就叫类类吧，既然有实例方法,实例字段,那么不带`static`的就叫实例类。  
&emsp;&emsp;用`static`修饰的内部类和Inner Class有很大的不同，它不再依附于`Outer`的实例，而是一个完全独立的类，因此无法引用`Outer.this`，但它可以访问`Outer`的`private`**静态**字段和**静态**方法。如果把`StaticNested`移到`Outer`之外，就失去了访问`private`的权限。  
## 编译和运行
```batch
 javac -d < destination directory> <java files>
```
&emsp;&emsp;将编译java文件得到的class 文件输出到指定目录 `destination directory`， 如果java 文件属于某个包`com.hello`，则会自动生成包名对应的文件目录 `com/hello`，如：**javac –d . Demo.java**  
```batch
 java -cp  or -classpath <class file path> <class name>
```
&emsp;&emsp;明确指出用户的类库路径，覆盖环境变量获得的**CLASSPATH**，如果不通过-cp 设置 **CLASSPATH**，当前目录默认为用户的类库路径，此时如果**class**文件包含在当前目录子文件中，同样会报**ClassNotFoundException** 。如：**java -cp 绝对路径 com.Test**  
&emsp;&emsp;指定编码：**javac -encoding UTF-8**  
&emsp;&emsp;Java 11新增功能，可以直接运行一个**单文件**源码：`java Hello.java`  
&emsp;&emsp;假设我们创建了如下的目录结构：  
```ascii
work
├── bin
└── src
    └── com
        └── itranswarp
            ├── sample
            │   └── Main.java
            └── world
                └── Person.java
```
&emsp;&emsp;其中，`bin`目录用于存放编译后的`class`文件，`src`目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？首先，确保当前目录是`work`目录然后，编译`src`目录下的所有Java文件：  
```batch
$ javac -d ./bin src/**/*.java
```
&emsp;&emsp;命令行`-d`指定输出的`class`文件存放`bin`目录，后面的参数`src/**/*.java`表示`src`目录下的所有`.java`文件，包括任意深度的子目录。  
&emsp;&emsp;注意：Windows不支持`**`这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有`.java`文件：  
```batch
C:\work> javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java
```
&emsp;&emsp;如果编译无误，则`javac`命令没有任何输出。可以在`bin`目录下看到如下`class`文件：  
```ascii
bin
└── com
    └── itranswarp
        ├── sample
        │   └── Main.class
        └── world
            └── Person.class
```
&emsp;&emsp;现在，我们就可以直接运行`class`文件了。根据当前目录的位置确定classpath，例如，当前目录仍为`work`，则classpath为`bin`或者`./bin`：  
```batch
$ java -cp bin com.itranswarp.sample.Main 
Hello, world!
```

### classpath
&emsp;&emsp;`classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class`。  
&emsp;&emsp;因为Java是编译型语言，源码文件是`.java`，而编译后的`.class`文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个`abc.xyz.Hello`的类，应该去哪搜索对应的`Hello.class`文件。  
&emsp;&emsp;所以，`classpath`就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用`;`分隔，带空格的目录用`""`括起来，可能长这样：  
```batch
C:\work\project1\bin;C:\shared;"D:\My Documents\project1\bin"
```
&emsp;&emsp;在Linux系统上，用`:`分隔，可能长这样：  
```batch
/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin
```
&emsp;&emsp;现在我们假设`classpath`是`.;C:\work\project1\bin;C:\shared`，当JVM在加载`abc.xyz.Hello`这个类时，会依次查找：  
- <当前目录>\abc\xyz\Hello.class
- C:\work\project1\bin\abc\xyz\Hello.class
- C:\shared\abc\xyz\Hello.class

&emsp;&emsp;注意到`.`代表当前目录。如果JVM在某个路径下找到了对应的`class`文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。  
&emsp;&emsp;`classpath`的设定方法有两种：  
- 在系统环境变量中设置`classpath`环境变量，不推荐；强烈不推荐在系统环境变量中设置`classpath`，那样会污染整个系统环境。
- 在启动JVM时设置`classpath`变量，推荐。

&emsp;&emsp;在启动JVM时设置`classpath`才是推荐的做法。实际上就是给`java`命令传入`-classpath`或`-cp`参数：  
```batch
java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```
&emsp;&emsp;或者使用`-cp`的简写：  
```batch
java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```
&emsp;&emsp;没有设置系统环境变量，也没有传入`-cp`参数，那么JVM**默认**的`classpath`为`.`，即当前目录：  
```batch
java abc.xyz.Hello
```
&emsp;&emsp;上述命令告诉JVM只在当前目录搜索`Hello.class`。  
&emsp;&emsp;在IDE中运行Java程序，IDE自动传入的`-cp`参数是当前工程的`bin`目录和引入的jar包。  
&emsp;&emsp;通常，我们在自己编写的`class`中，会引用Java核心库的`class`，例如，`String`、`ArrayList`等。不需要告诉JVM如何去Java核心库查找`class`，JVM怎么可能笨到连自己的核心库在哪都不知道？不要把任何Java核心库添加到classpath中。默认的当前目录`.`对于绝大多数情况都够用了。  
&emsp;&emsp;假设我们有一个编译后的`Hello.class`，它的包名是`com.example`，当前目录是`C:\work`，那么，目录结构必须如下：  
```ascii
C:\work
└─ com
   └─ example
      └─ Hello.class
```
&emsp;&emsp;运行这个`Hello.class`必须在当前目录下使用如下命令：  
```batch
C:\work> java -cp . com.example.Hello
```
&emsp;&emsp;JVM根据classpath设置的`.`在当前目录下查找`com.example.Hello`，即实际搜索文件必须位于`com/example/Hello.class`。如果指定的`.class`文件不存在，或者目录结构和包名对不上，均会报错。  
### jar包
&emsp;&emsp;如果有很多`.class`文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。  
&emsp;&emsp;jar包就是用来干这个事的，它可以把`package`组织的目录层级，以及各个目录下的所有文件（包括`.class`文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。  
&emsp;&emsp;jar包实际上就是一个zip格式的**压缩文件**，而jar包相当于目录。如果我们要执行一个jar包的`class`，就可以把jar包放到`classpath`中：  
```batch
java -cp ./hello.jar abc.xyz.Hello
```
&emsp;&emsp;这样JVM会自动在`hello.jar`文件里去搜索某个类。  
&emsp;&emsp;那么问题来了：如何创建jar包？  
&emsp;&emsp;因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功。  
&emsp;&emsp;假设编译输出的目录结构是这样：  
```ascii
package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
```
&emsp;&emsp;这里需要特别注意的是，jar包里的第一层目录，不能是`bin`，而应该是`hong`、`ming`、`mr`。  
&emsp;&emsp;jar包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：  
```batch
java -jar hello.jar
```
&emsp;&emsp;在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包。  
### class版本
&emsp;&emsp;通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是`java.exe`这个程序的版本：  
```bash
$ java -version
java version "17" 2021-09-14 LTS
```
&emsp;&emsp;而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。  
&emsp;&emsp;如果用Java 11编译一个Java程序，输出的class文件版本默认就是55，这个class既可以在Java 11上运行，也可以在Java 17上运行，因为Java 17支持的class文件版本是61，表示“最多支持到版本61”。查看class版本可以用`javap -v`。  
&emsp;&emsp;如果用Java 17编译一个Java程序，输出的class文件版本默认就是61，它可以在Java 17、Java 18上运行，但不可能在Java 11上运行，因为Java 11支持的class版本最多到55。如果使用低于Java 17的JVM运行，会得到一个`UnsupportedClassVersionError`，错误信息类似：  
```text
java.lang.UnsupportedClassVersionError: Xxx has been compiled by a more recent version of the Java Runtime...
```
&emsp;&emsp;只要看到`UnsupportedClassVersionError`就表示当前要加载的class文件版本超过了JVM的能力，必须使用更高版本的JVM才能运行。  
&emsp;&emsp;我们也可以用Java 17编译一个Java程序，指定输出的class版本要兼容Java 11（即class版本55），这样编译生成的class文件就可以在Java >=11的环境中运行。  
&emsp;&emsp;指定编译输出有两种方式，一种是在`javac`命令行中用参数`--release`设置：  
```batch
$ javac --release 11 Main.java
```
&emsp;&emsp;参数`--release 11`表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。  
&emsp;&emsp;第二种方式是用参数`--source`指定源码版本，用参数`--target`指定输出class版本：  
```batch
$ javac --source 9 --target 11 Main.java
```
&emsp;&emsp;上述命令如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本。注意`--release`参数和`--source --target`参数只能二选一，不能同时设置。  
&emsp;&emsp;然而，指定版本如果低于当前的JDK版本，会有一些潜在的问题。例如，我们用Java 17编译`Hello.java`，参数设置`--source 9`和`--target 11`：  
```java
public class Hello {
    public static void hello(String name) {
        System.out.println("hello".indent(4));
    }
}
```
&emsp;&emsp;用低于Java 11的JVM运行`Hello`会得到一个`LinkageError`，因为无法加载`Hello.class`文件，而用Java 11运行`Hello`会得到一个`NoSuchMethodError`，因为`String.indent()`方法是从Java 12才添加进来的，Java 11的`String`版本根本没有`indent()`方法。  
&emsp;&emsp; 注：如果使用--release 11则会在编译时检查该方法是否在Java 11中存在。  
&emsp;&emsp;**因此，如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class。**  
&emsp;&emsp;如果使用`javac`编译时不指定任何版本参数，那么相当于使用`--release 当前版本`编译，即源码版本和输出版本均为当前版本。  
&emsp;&emsp;**源码版本**  
&emsp;&emsp;在编写源代码的时候，我们通常会预设一个源码的版本。在编译的时候，如果用`--source`或`--release`指定源码版本，则使用指定的源码版本检查语法。  
&emsp;&emsp;例如，使用了lambda表达式的源码版本至少要为8才能编译，使用了`var`关键字的源码版本至少要为10才能编译，使用`switch`表达式的源码版本至少要为12才能编译，且12和13版本需要启用`--enable-preview`参数。  
### 模块
&emsp;&emsp;从Java 9开始，JDK又引入了模块（Module）。  
&emsp;&emsp;什么是模块？这要从Java 9之前的版本说起。  
&emsp;&emsp;我们知道，`.class`文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆`.class`文件，很不便于管理，所以，`jar`文件就是`class`文件的容器。  
&emsp;&emsp;在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫`rt.jar`，一共有60多M。  
&emsp;&emsp;如果是自己开发的程序，除了一个自己的`app.jar`以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：  
```bash
java -cp app.jar:a.jar:b.jar:c.jar com.Main
```
&emsp;&emsp; **注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。**  
&emsp;&emsp;如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出`ClassNotFoundException`。  
&emsp;&emsp;所以，jar只是用于存放class的容器，它并不关心class之间的依赖。  
&emsp;&emsp;从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果`a.jar`必须依赖另一个`b.jar`才能运行，那我们应该给`a.jar`加点说明啥的，让程序在编译和运行的时候能自动定位到`b.jar`，这种自带“依赖关系”的class容器就是模块。  
&emsp;&emsp;为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的`rt.jar`分拆成了几十个模块，这些模块以`.jmod`扩展名标识，可以在`$JAVA_HOME/jmods`目录下找到它们：  
- java.base.jmod
- java.compiler.jmod
- java.datatransfer.jmod
- java.desktop.jmod
- ...

&emsp;&emsp;这些`.jmod`文件每一个都是一个模块，模块名就是文件名。例如：模块`java.base`对应的文件就是`java.base.jmod`。模块之间的依赖关系已经被写入到模块内的`module-info.class`文件了。所有的模块都直接或间接地依赖`java.base`模块，只有`java.base`模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从`Object`直接或间接继承而来。  
&emsp;&emsp;把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。  
&emsp;&emsp;**编写模块**  
&emsp;&emsp;那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以`oop-module`工程为例，它的目录结构如下：  
```ascii
oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
```
&emsp;&emsp;其中，`bin`目录存放编译后的class文件，`src`目录存放源码，按包名的目录结构存放，仅仅在`src`目录下多了一个`module-info.java`这个文件，这就是模块的描述文件。在这个模块中，它长这样：  
```java
module hello.world {
	requires java.base; // 可不写，任何模块都会自动引入java.base
	requires java.xml;
}
```
&emsp;&emsp;其中，`module`是关键字，后面的`hello.world`是模块的名称，它的命名规范与包一致。花括号的`requires xxx;`表示这个模块需要引用的其他模块名。除了`java.base`可以被自动引入外，这里我们引入了一个`java.xml`的模块。  
&emsp;&emsp;当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，`Main.java`代码如下：  
```java
package com.itranswarp.sample;
// 必须引入java.xml模块后才能使用其中的类:
import javax.xml.XMLConstants;
public class Main {
	public static void main(String[] args) {
		Greeting g = new Greeting();
		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));
	}
}
```
&emsp;&emsp;如果把`requires java.xml;`从`module-info.java`中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。  
&emsp;&emsp;下面，我们用JDK提供的命令行工具来编译并创建模块。  
&emsp;&emsp;首先，我们把工作目录切换到`oop-module`，在当前目录下编译所有的`.java`文件，并存放到`bin`目录下，命令如下：  
```bash
$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java
```
&emsp;&emsp;如果编译成功，现在项目结构如下：  
```ascii
oop-module
├── bin
│   ├── com
│   │   └── itranswarp
│   │       └── sample
│   │           ├── Greeting.class
│   │           └── Main.class
│   └── module-info.class
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
```
&emsp;&emsp;注意到`src`目录下的`module-info.java`被编译到`bin`目录下的`module-info.class`。  
&emsp;&emsp;下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入`--main-class`参数，让这个jar包能自己定位`main`方法所在的类：  
```bash
$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .
```
&emsp;&emsp;现在我们就在当前目录下得到了`hello.jar`这个jar包，它和普通jar包并无区别，可以直接使用命令`java -jar hello.jar`来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的`jmod`命令把一个jar包转换成模块：  
```bash
$ jmod create --class-path hello.jar hello.jmod
```
&emsp;&emsp;于是，在当前目录下我们又得到了`hello.jmod`这个模块文件，这就是最后打包出来的传说中的模块！  
&emsp;&emsp;**运行模块**  
&emsp;&emsp;要运行一个jar，我们使用`java -jar xxx.jar`命令。要运行一个模块，我们只需要指定模块名。试试：  
```bash
$ java --module-path hello.jmod --module hello.world
```
&emsp;&emsp;结果是一个错误：  
```bash
Error occurred during initialization of boot layer
java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod
```
&emsp;&emsp;原因是`.jmod`不能被放入`--module-path`中。换成`.jar`就没问题了：  
```bash
$ java --module-path hello.jar --module hello.world
Hello, xml!
```
&emsp;&emsp;那我们辛辛苦苦创建的`hello.jmod`有什么用？答案是我们可以用它来打包JRE。  
&emsp;&emsp;**打包JRE**  
&emsp;&emsp;前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的`rt.jar`拆成了几十个`.jmod`模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。  
&emsp;&emsp;过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？  
&emsp;&emsp;现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了`jlink`命令来干这件事。命令如下：  
```bash
$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/
```
&emsp;&emsp;我们在`--module-path`参数指定了我们自己的模块`hello.jmod`，然后，在`--add-modules`参数中指定了我们用到的3个模块`java.base`、`java.xml`和`hello.world`，用`,`分隔。最后，在`--output`参数指定输出目录。  
&emsp;&emsp;现在，在当前目录下，我们可以找到`jre`目录，这是一个完整的并且带有我们自己`hello.jmod`模块的JRE。试试直接运行这个JRE：  
```bash
$ jre/bin/java --module hello.world
Hello, xml!
```
&emsp;&emsp;要分发我们自己的Java应用程序，只需要把这个`jre`目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。  
&emsp;&emsp;**访问权限**  
&emsp;&emsp;前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。  
&emsp;&emsp;确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。  
&emsp;&emsp;举个例子：我们编写的模块`hello.world`用到了模块`java.xml`的一个类`javax.xml.XMLConstants`，我们之所以能直接使用这个类，是因为模块`java.xml`的`module-info.java`中声明了若干导出：  
```java
module java.xml {
    exports java.xml;
    exports javax.xml.catalog;
    exports javax.xml.datatype;
    ...
}
```
&emsp;&emsp;只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的`hello.world`模块中的`com.itranswarp.sample.Greeting`类，我们必须将其导出：  
```java
module hello.world {
    exports com.itranswarp.sample;
    requires java.base;
	requires java.xml;
}
```
&emsp;&emsp;因此，模块进一步隔离了代码的访问权限。  
# 异常
&emsp;&emsp;异常处理是通过5个关键字来实现的：  

| 关键词  | 说明                                  |
|---------|---------------------------------------|
| try     | 执行可能产生异常的代码                |
| catch   | 捕获异常                              |
| throw   | 抛出异常,手动抛出异常                 |
| throws  | 声明异常,声明方法可能要抛出的各种异常 |
| finally | 无论是否发生异常代码总能执行          |

&emsp;&emsp;Java语言中的异常也是通过一个对象来表示的,程序运行时抛出的异常实际上就是一个异常对象。该对象中不仅封装了错误信息,还提供了些处理方法。  
&emsp;&emsp;**String getMessage()**在**Exception**类中定义的方法,被继承到**所有**的异常类中,用于获得与异常相关的描述信息。  
&emsp;&emsp;**void printstackTrace()**在**Exception**类中定义的方法,用于在控制台上显示有关异常的信息,不但有异常的原因,还涉及产生异常的代码行。  
&emsp;&emsp;**try{**  
&emsp;&emsp;**//可能发生异常的代码段**  
&emsp;&emsp;**} catch (异常类型 e){**  
&emsp;&emsp;**//对异常进行处理的代码段**  
&emsp;&emsp;**}finally{**  
&emsp;&emsp;**//始终执行的代码段**  
&emsp;&emsp;**}**  
&emsp;&emsp;**//其他代码段**  

&emsp;&emsp;在**try**发生异常则程序跳到**catch**块中执行,否则不执行**catch**块语句;**catch**块代码处理完后,程序仍会向下执行而不会异常终止。发生异常语句后面的代码**不会被执行**;  
&emsp;&emsp;如果希望语句无论是否发生异常都要执行,可在**try..catch**句后添加**finally**块;无论是否发生异常, **finally**块都将**执行**;**finally**块是可选的,可视具体情况决定是否添加;**finally**块必须和**try**块一起使用,不能单独存在。  
&emsp;&emsp;如果某个函数中的代码有可能引发异常,可以使用**try/catch**块进行处理,这种处理方式成为"内部处理"  
&emsp;&emsp;如果不方便在函数内部进行处理,也可以将异常往函数外部传递,这就要使用到关键字**throws**;**throws**用于将函数内部产生的异常抛给主调函数;  

&emsp;&emsp;抛出异常:  
&emsp;&emsp;**返回值类型 函数名(参数列表) throws异常类型｛代码段｝**  
&emsp;&emsp;当调用带有**throws**关键字的函数时,则**必须**放在**try/catch**块中进行监控,否则编译器将会报错;  

&emsp;&emsp;有时候,在**try**块中的代码段将有可能产生**多种**不同类型的**异常**,而我们又需要针对不同的异常类型进行不同的处理方式,那么我们就可以**使用多重catch**块,来分别捕获不同类型的异常  
&emsp;&emsp;虽然多重**catch**块可以同时监视多个不同类型的异常,但是**try**块中一旦有某个异常产生,程序就会跳转到与之异常类型**最匹配**的**catch**块中执行,然后执行**finally**块(如果有**finally**块的话)或之后的语句;也就是说,多重**catch**块只会捕捉到**最先产生的异常**,而不是把所有的异常全部捕捉完;即：不论有多少个**catch**块,**最多**只会执行其中的**一个**;请注意**catch**块的书写顺序：类层次**越低的越往上写,越高的越往下写**。  
&emsp;&emsp;有时候,整个语句块可以产生异常,而其中的某个部分又可能产生另外的异常,而我们需要分别进行处理;这样,就可以通过嵌套**try/catch**块来完成;嵌套**try/catc**h块就是在一个**try/catch**块中包含有另外的**try/catch**块。  

&emsp;&emsp;**异常类型**  
&emsp;&emsp;产生异常的原因多种多样,大致有：系统资源不可用：如内存分配失败,文件打开失败,数据源连接失败等等;程序控制不当：如被零除,负数开方,数组下标越界等等。  
&emsp;&emsp;当异常发生时,程序一般会作出如下反应：发生异常的部分产生系统定义的错误信息;程序意外终止,并将控制权返回操作系统;程序中所有已分配资源的状态保持不变,这样将会导致资源泄漏。那么我们就必须对有可能产生的异常进行处理。  
&emsp;&emsp;自定义异常类一般继承于**Exception**类;**Exception**类是绝大部分异常类的父类,在异常类型不明的情况下,可以都认为是**Exception**.  
&emsp;&emsp;**Throwable**有两个直接子类,它们是：  
&emsp;&emsp;**Error**类：称为**错误类**,通常是指**系统**中的**内部错误**以及资源耗尽的错误,是比较严重的,仅靠修改程序本身是**不能**恢复执行的  
&emsp;&emsp;**Exception**类：称为**异常类**,表示程序本身**可以**处理的错误。在开发Java程序过程中进行的异常处理,主要就是针对**Exception**类及其子类的异常处理。  
&emsp;&emsp;Java 根据各个类库也定义了一些其他的异常,下面的表中列出了 Java 的非检查性异常。  

| 异常                            | 描述                                                                                                                |
|---------------------------------|---------------------------------------------------------------------------------------------------------------------|
| ArithmeticException             | 当出现异常的运算条件时,抛出此异常。例如,一个整数"除以零"时,抛出此类的一个实例。                                     |
| ArrayIndexOutOfBoundsException  | 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小,则该索引为非法索引。                                 |
| ArrayStoreException             | 试图将错误类型的对象存储到一个对象数组时抛出的异常。                                                                |
| ClassCastException              | 当试图将对象强制转换为不是实例的子类时,抛出该异常。                                                                 |
| IllegalArgumentException        | 抛出的异常表明向方法传递了一个不合法或不正确的参数。                                                                |
| IllegalMonitorStateException    | 抛出的异常表明某一线程已经试图等待对象的监视器,或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。     |
| IllegalStateException           | 在非法或不适当的时间调用方法时产生的信号。换句话说,即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 |
| IllegalThreadStateException     | 线程没有处于请求操作所要求的适当状态时抛出的异常。                                                                  |
| IndexOutOfBoundsException       | 指示某排序索引(例如对数组、字符串或向量的排序)超出范围时抛出。                                                      |
| NegativeArraySizeException      | 如果应用程序试图创建大小为负的数组,则抛出该异常。                                                                   |
| NullPointerException            | 当应用程序试图在需要对象的地方使用 null 时,抛出该异常                                                               |
| NumberFormatException           | 当应用程序试图将字符串转换成一种数值类型,但该字符串不能转换为适当格式时,抛出该异常。                                |
| SecurityException               | 由安全管理器抛出的异常,指示存在安全侵犯。                                                                           |
| StringIndexOutOfBoundsException | 此异常由 String 方法抛出,指示索引或者为负,或者超出字符串的大小。                                                    |
| UnsupportedOperationException   | 当不支持请求的操作时,抛出该异常。                                                                                   |

&emsp;&emsp;下面的表中列出了 Java 定义在 **java.lang** 包中的检查性异常类。  

| 异常                       | 描述                                                                                                                           |
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| ClassNotFoundException     | 应用程序试图加载类时,找不到相应的类,抛出该异常。                                                                               |
| CloneNotSupportedException | 当调用 Object 类中的 clone 方法克隆对象,但该对象的类无法实现 Cloneable 接口时,抛出该异常。                                     |
| IllegalAccessException     | 拒绝访问一个类的时候,抛出该异常。                                                                                              |
| InstantiationException     | 当试图使用 Class 类中的 newInstance 方法创建一个类的实例,而指定的类对象因为是一个接口或是一个抽象类而无法实例化时,抛出该异常。 |
| InterruptedException       | 一个线程被另一个线程中断,抛出该异常。                                                                                          |
| NoSuchFieldException       | 请求的变量不存在                                                                                                               |
| NoSuchMethodException      | 请求的方法不存在                                                                                                               |

&emsp;&emsp;**throws**  
&emsp;&emsp;定义一个方法的时候可以使用**throws**关键字声明。使用**throws**关键字声明的方法表示此方法不处理异常,而交给方法**调用处**进行处理。当调用带有**throws**关键字的函数时,则**必须**放在**try/catch**块中进行,否编器将会报错;同样地,如果不便进行监控处理,也可以继续使用**throws**往外抛出异常但不太推荐此种做法。(外抛不需要**try/catch**)  
&emsp;&emsp;**throws**关键字格式：  
&emsp;&emsp;**public 返回值类型 方法名称(参数列表)*throws* 异常类{};**  
&emsp;&emsp;假设定义一个除法,对于除法操作可能出现异常,可能不会。所以对于这种方法最好将它使用**throws**关键字声明,一旦出现异常,则应该交给调用处处理。  
```java
class Math {  
    public int div(int i, int j) throws Exception {// 定义除法操作,如果有异常,则交给被调用处处理  
        return i / j;// 计算,但是此处有可能出现异常  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        Math m = new Math();// 实例化Math类对象  
        try {  
            System.out.println("除法操作：" + m.div(10, 0));  
        } catch (Exception e) {  
            e.printStackTrace();// 打印异常  
        }  
    }  
}
```
&emsp;&emsp;因为**div**使用了**throws**关键字声明,所以调用此方法的时候,方法**必须进行异常处理**。  
```java
class Math {  
    public int div(int i, int j) throws Exception {// 定义除法操作,如果有异常,则交给被调用处处理  
        return i / j;// 计算,但是此处有可能出现异常  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) throws Exception {  
        Math m = new Math();// 实例化Math类对象  
        System.out.println("除法操作：" + m.div(10, 0));  
    }  
}
```
&emsp;&emsp;在本程序中,主方法不处理任何异常,而交给JAVA中最大头**JVM**,所以如果在主方法使用了**throws**关键字,则表示一切异常交给**JVM**进行处理。默认处理方式也是**JVM**完成。  
&emsp;&emsp;**throw**  
&emsp;&emsp;**throw new Exception("自己抛着玩的。")**  
&emsp;&emsp;手动抛出一个异常,抛出一个异常类的实例化对象.执行流程将在**throw**语句后立即停止,转而寻找与之类型相匹配的**catch**块  
&emsp;&emsp;在异常处理中,**try**语句捕获的是一个异常对象,那么此异常对象也可以自己抛出。  
```java
public class NoteTest {  
    public static void main(String[] args) throws Exception {  
        throw new Exception("自己抛着玩的。");// 抛出异常的实例化对象  
    }  
}
```
&emsp;&emsp;在一般开发中**try,catch,finally,throw,throws**联合使用的情况是最多的。  
&emsp;&emsp;例如,现在要使用一个相除的方法,但是在操作之前必须打印“运算开始”的信息,结束之后必须打印“异常结束”。如果有异常,需要把异常交给异常调用处处理。面对这样要求,必须全部使用以上关键字。  
```java
class Math {  
    public int div(int i, int j) throws Exception { // 定义除法操作,如果有异常,则交给被调用处处理  
        System.out.println("***** 计算开始 *****");  
        int temp = i / j; // 计算,但是此处有可能出现异常  
        System.out.println("***** 计算结束 *****");  
        return temp;  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        Math m = new Math();  
        try {  
            System.out.println("除法操作：" + m.div(10, 0));  
        } catch (Exception e) {  
            System.out.println("异常产生：" + e);  
            }  
    }  
    }
```
&emsp;&emsp;运行结果：  
```text
***** 计算开始 *****
异常产生：java.lang.ArithmeticException: / by zero
```
&emsp;&emsp;以上没有计算结束,因为没有异常发生了,直接中断程序操作。所以要抛出异常对象,给方法调用处处理,使用**throw**关键字。  
```java
class Math {  
    public int div(int i, int j) throws Exception { // 定义除法操作,如果有异常,则交给被调用处处理  
        System.out.println("***** 计算开始 *****");  
        int temp = 0; // 计算,但是此处有可能出现异常  
        try {  
            temp = i / j;  
        } catch (Exception e) {  
            throw e;  
        } finally {  
            System.out.println("***** 计算结束 *****");  
        }  
        return temp;  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        Math m = new Math();  
        try {  
            System.out.println("除法操作：" + m.div(10, 0));  
        } catch (Exception e) {  
            System.out.println("异常产生：" + e);  
        }  
    }  
}
```
&emsp;&emsp;**Exception**与**runtimeException**的区别是面试中经常出现的问题。  
```java
String str = "123" ; // 定义字符串,全部由数字组成  
int temp = Integer.parseInt(str) ; // 将字符串变为int类型  
System.out.println(temp * temp) ; // 计算乘方
```
&emsp;&emsp;parseInt()的定义格式：  
```java
public static int parseInt(String s) throws NumberFormatException
```
&emsp;&emsp;此方法明明使用了**throws**关键字抛出异常,为什么不用处理,也可以编译通过？  
&emsp;&emsp;在JAVA异常处理机制中:  
- 如果抛出的是**EXception**的类型,则**必须**进行**try ..catch**进行处理。  
- 如果抛出的是**RuntimeException**的类型,则**可以不使用try..catch**处理,一旦发生异常之后,将由JVM处理。  

&emsp;&emsp;为了保证程序的健康性,在有可能出现异常的时候还是老实使用**try..catch**处理。  

&emsp;&emsp;**自定义异常类。**  
&emsp;&emsp;只需要继承**Exception**类就可以自定义异常类。因为JAVA中提供的都是标准异常类(包括一些异常信息),如果需要自己想要的异常信息就可以自定义异常类。**Exception**类是绝大部分异常类的父类,在异常类型不明的情况下,可以都认为是**Exception**.  
```java
class MyException extends Exception {// 自定义异常类,继承Exception类  
    public MyException(String msg) {  
        super(msg);// 调用Exception类中有一个参数的构造方法,传递错误信息  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        try {  
            throw new MyException("自定义异常。");// 抛出异常  
        } catch (Exception e) {  
            System.out.println(e);//打印错误信息:MyException: 自定义异常。  
        }  
    }  
}
```
&emsp;&emsp;**总结**  
&emsp;&emsp;**throw**与**throws**关键字联合使用问题。  
&emsp;&emsp;**throw**：抛出异常。  
&emsp;&emsp;**throws**：在方法声明处使用,表示此方法不处理异常,而在调用此方法处处理异常。  
&emsp;&emsp;**Exception**是必须处理的,而**RuntimeException**异常是可以不处理的。但是为了保证程序正常运行,最好处理。  
&emsp;&emsp;如果自定义异常,直接继承异常即可。  
# 文件 
## I/O流概述
&emsp;&emsp;**文件**是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。  
&emsp;&emsp;“流”是一个抽象的概念,它代表任何有能力输出数据的数据源对象或者是有能力接收数据的接收端对象。  
&emsp;&emsp;**java.io**包中最重要的就是五个类和一个接口：  
&emsp;&emsp;**File OutputStream InputStream Reader Writer**  
&emsp;&emsp;**serializable** 数据的序列化接口，可以按照流式序列化保存对象。  
## I/O流的分类
&emsp;&emsp;&nbsp;  
### 按照不同的方式,将流分为不同的类型按数据流动方向
&emsp;&emsp;输入流：只能从中读取字节数据,而不能向其写出数据  
&emsp;&emsp;输出流：只能向其写入字节数据,而不能从中读取数据  
&emsp;&emsp;输入流和输出流分别通过**抽象类InputStream和 OutputStream**来实现  
### 按照流所处理的数据类型
&emsp;&emsp;字节流：用于处理字节数据  
&emsp;&emsp;字节流是按字节读/写二进制数据字节流有两个基本的类：  
&emsp;&emsp;**InputStream**类**OutputStream**类  
&emsp;&emsp;**InputStream**类用于处理字节输入流,**OutputStream**类用于处理字节输出流。  
&emsp;&emsp;字符流：用于处理 Unicode字符数据  
&emsp;&emsp;字符流的输入/输出数据是字符码即Unicode字符。  
&emsp;&emsp;字符流有两个基本类：**Reader**类和 **Writer**类。**Reader**类用于处理字符输入流,**Writer**类用于处理字符输出流  
### 按照流所处理的源
&emsp;&emsp;节点流(低级流)：向一个特定的IO设备读/写数据的流  
&emsp;&emsp;处理流(高级流)：对已存在的流进行连接和封装的流  
&emsp;&emsp;处理流是“处理流的流”,它用来处理其他的流。  
### 说明
&emsp;&emsp;所有从 **InputStream**或 **Reader**派生的类都有一个基本的**read()**方法,用读取的字节或者读取字节数组;  
&emsp;&emsp;所有从 **OutputStream**或 **Writer**派生的类都有一个基本的 **write()**方法,用于写入单一的字节或者整个字节数组。  
&emsp;&emsp;但在实际应用中我们一般很少使用单一的流类来产生输入输出流,而是使用这两个方法绐其他的流类提供数锯,也就是说,通过多个流对象的连接和封装使用实际的流。  
## File

| 构造函数                          | 说明                                                                            |
|-----------------------------------|---------------------------------------------------------------------------------|
| File(File parent, String child)   | 根据 **parent** 抽象路径名和 **child** 路径名字符串创建一个新 **File** 实例。   |
| File(String pathname)             | 通过将给定路径名字符串转换为抽象路径名来创建一个新 **File** 实例。              |
| File(String parent, String child) | 根据 **parent** 路径名字符串和 **child** 路径名字符串创建一个新 **File** 实例。 |
| File(URI uri)                     | 通过将给定的 **file: URI** 转换为一个抽象路径名来创建一个新的 **File** 实例。   |

```java
File file=new File("D:"+ File.separator+"a.txt");  
File file2=new File("D:\\a.txt");  
File file3=new File("D:","a.txt");  
File file4=new File(file,"a.txt");
```

| 返回类型        | 方法                                                         | 说明                                                                                                                                                                              |
|-----------------|--------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  boolean        | canExecute()                                                 | 测试应用程序是否可以执行此抽象路径名表示的文件。                                                                                                                                  |
|  boolean        | canRead()                                                    | 测试应用程序是否可以读取此抽象路径名表示的文件。                                                                                                                                  |
|  boolean        | canWrite()                                                   | 测试应用程序是否可以修改此抽象路径名表示的文件。                                                                                                                                  |
|  int            | compareTo(File pathname)                                     | 按字母顺序比较两个抽象路径名。                                                                                                                                                    |
|  boolean        | createNewFile()                                              | 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。                                                                                                      |
| static File     | createTempFile(String prefix, String suffix)                 | 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。                                                                                                                |
| static File     | createTempFile(String prefix, String suffix, File directory) | 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。                                                                                                            |
|  boolean        | delete()                                                     | 删除此抽象路径名表示的文件或目录。                                                                                                                                                |
|  void           | deleteOnExit()                                               | 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。                                                                                                                            |
|  boolean        | equals(Object obj)                                           | 测试此抽象路径名与给定对象是否相等。                                                                                                                                              |
|  boolean        | **exists()**                                                 | 测试此抽象路径名表示的文件或目录是否存在。                                                                                                                                        |
|  File           | getAbsoluteFile()                                            | 返回此抽象路径名的绝对路径名形式。                                                                                                                                                |
|  String         | getAbsolutePath()                                            | 返回此抽象路径名的绝对路径名字符串。                                                                                                                                              |
|  File           | getCanonicalFile()                                           | 返回此抽象路径名的规范形式。                                                                                                                                                      |
|  String         | getCanonicalPath()                                           | 返回此抽象路径名的规范路径名字符串。                                                                                                                                              |
|  long           | getFreeSpace()                                               | 返回此抽象路径名指定的分区中未分配的字节数。                                                                                                                                      |
|  String         | **getName()**                                                | 返回由此抽象路径名表示的文件或目录的名称。                                                                                                                                        |
|  String         | **getParent()**                                              | 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。                                                                                                   |
|  File           | getParentFile()                                              | 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。                                                                                                     |
|  String         | **getPath()**                                                | 将此抽象路径名转换为一个路径名字符串。                                                                                                                                            |
|  long           | getTotalSpace()                                              | 返回此抽象路径名指定的分区大小。                                                                                                                                                  |
|  long           | getUsableSpace()                                             | 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。                                                                                                                              |
|  int            | hashCode()                                                   | 计算此抽象路径名的哈希码。                                                                                                                                                        |
|  boolean        | isAbsolute()                                                 | 测试此抽象路径名是否为绝对路径名。                                                                                                                                                |
|  boolean        | **isDirectory()**                                            | 测试此抽象路径名表示的文件是否是一个目录。                                                                                                                                        |
|  boolean        | **isFile()**                                                 | 测试此抽象路径名表示的文件是否是一个标准文件。                                                                                                                                    |
|  boolean        | isHidden()                                                   | 测试此抽象路径名指定的文件是否是一个隐藏文件。                                                                                                                                    |
|  long           | lastModified()                                               | 返回此抽象路径名表示的文件最后一次被修改的时间。                                                                                                                                  |
|  long           | **length()**                                                 | 返回由此抽象路径名表示的文件的长度。                                                                                                                                              |
|  String\[\]     | list()                                                       | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。                                                                                                          |
|  String\[\]     | list(FilenameFilter filter)                                  | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。                                                                                            |
|  File\[\]       | listFiles()                                                  | 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。                                                                                                            |
|  File\[\]       | listFiles(FileFilter filter)                                 | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。                                                                                            |
|  File\[\]       | listFiles(FilenameFilter filter)                             | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。                                                                                            |
| static File\[\] | listRoots()                                                  | 列出可用的文件系统根。                                                                                                                                                            |
|  boolean        | **mkdir()**                                                  | 创建此抽象路径名指定的目录。                                                                                                                                                      |
|  boolean        | **mkdirs()**                                                 | 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。                                                                                                                        |
|  boolean        | **renameTo(File dest)**                                      | 重新命名此抽象路径名表示的文件。                                                                                                                                                  |
|  boolean        | setExecutable(boolean executable)                            | 设置此抽象路径名所有者执行权限的一个便捷方法。                                                                                                                                    |
|  boolean        | setExecutable(boolean executable, boolean ownerOnly)         | 设置此抽象路径名的所有者或所有用户的执行权限。                                                                                                                                    |
|  boolean        | setLastModified(long time)                                   | 设置此抽象路径名指定的文件或目录的最后一次修改时间。                                                                                                                              |
|  boolean        | setReadable(boolean readable)                                | 设置此抽象路径名所有者读权限的一个便捷方法。                                                                                                                                      |
|  boolean        | setReadable(boolean readable, boolean ownerOnly)             | 设置此抽象路径名的所有者或所有用户的读权限。                                                                                                                                      |
|  boolean        | setReadOnly()                                                | 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。                                                                                                                        |
|  boolean        | setWritable(boolean writable)                                | 设置此抽象路径名所有者写权限的一个便捷方法。                                                                                                                                      |
|  boolean        | setWritable(boolean writable, boolean ownerOnly)             | 设置此抽象路径名的所有者或所有用户的写权限。                                                                                                                                      |
|  String         | toString()                                                   | 返回此抽象路径名的路径名字符串。                                                                                                                                                  |
|  URI            | toURI()                                                      | 构造一个表示此抽象路径名的 file: URI。                                                                                                                                            |
|  URL            | toURL()                                                      | **已过时。** *此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。* |

## 字节流
&emsp;&emsp;字节流是按字节读/写二进制数据字节流有两个基本的类：**InputStream**类**OutputStream**类  
&emsp;&emsp;**InputStream**类用于处理**字节输入流**,**OutputStream**类用于处理**字节输出流**。它们都是**抽象类**,本身不能直接用来创建对象。所有字节处理流都由**InputStream**/**OutputStream**派生而来  
### InputStream常用方法

| 方法                                                | 说明                                                                                   |
|-----------------------------------------------------|----------------------------------------------------------------------------------------|
| **int read()**                                      | 读取一个字节,并将它返回                                                                |
| **int read(byte\[\] buffer)**                       | 将数据读入一个字节数组,同时返回读取的字节数。                                          |
| **int read(byte\[\] buffer,int offset,int length)** | 将数据读入一个字节数组,放到数组的offset指定的位置开始,并用length来指定读取的最大字节数 |
| void close()                                        | 关闭流。                                                                               |
| int available()                                     | 返回可以从中读取的字节数。                                                             |
| long skip(long n)                                   | 在输入流中跳过n个字节,将实际跳过的字节数返回。                                         |
| boolean markSupported()                             | 判断流是否支持标记功能。                                                               |
| void mark(int readlimit)                            | 在支持标记的输入流的当前位置设置一个标记。                                             |
| void reset()                                        | 返回到流的上一个标记。注意必须流支持标记功能。                                         |

### InputStream相关类

&emsp;&emsp;低级 **InputStream**类：  
> **InputStream**  
**ByteArrayInputStream**  
**PipedInputStream**  
**FileInputStream**  

&emsp;&emsp;高级 **InputStream**类  
> **DataInputStream**  
**BufferedInputStream**  

```java
package com.aotmd.test;  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileInputStream fis;  
        int n;  
        try {  
            fis = new FileInputStream("file1.txt");// 读取文件  
            byte[] a = new byte[256];  
            while ((n = fis.read(a)) != -1)System.out.write(a, 0, n);// 显示  
            fis.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
### OutputStream常用方法
&emsp;&emsp;Writer常用方法(写入方法)  

| 方法                                                   | 说明                                                   |
|--------------------------------------------------------|--------------------------------------------------------|
| **void write(int b)**                                  | 将参数b的低16位组成字节写入到流中。                    |
| **void write(byte\[\] buffer)**                        | 将字符数组buffer中的字节写入到流中。                   |
| **void write(byte\[\] buffer,int offset, int length)** | 将字节数组buffer中从offset开始的length字节写入到流中。 |
| void close()                                           | 关闭流                                                 |
| void flush()                                           | 刷空输岀流,并输岀所有被缓存的字节。                    |

### OutputStream相关类
&emsp;&emsp;低级 **OutputStream**类：  
> **OutputStream**  
**ByteArrayOutputStream**  
**PipedOutputStream**  

&emsp;&emsp;高级 **Outputstream**类：  
> **DataOutputStream**  
**BufferedOutputStream**  

```java
package com.aotmd.test;  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.PrintStream;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileOutputStream fos = null;  
        PrintStream out = null;  
        try {  
            fos = new FileOutputStream("file1.txt", true);//建立一个文件输出流,true追加  
            out = new PrintStream(fos);//建立一个PrintStream对象,它将作为标准输出流  
            out.println("这是一个测试串FileOutputStream");  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        } finally {  
            assert out != null;  
            out.close();  
            try {  
                fos.close();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
}
```
## 字符流
&emsp;&emsp;字待流有两个基本类：**Reader**和**Writer**  
&emsp;&emsp;1,**Reader**/**Writer**处理的是**字符类型**的数据。它处理流的方式是以**字符**为单位进行的。  
&emsp;&emsp;2,**Reader**/**Writer**和**InputStream**/**OutputStream**一样,也分为**节点流**(低级流)和**处理流**(高级流)。  
&emsp;&emsp;**Reader**和**InputStream**的差异  
&emsp;&emsp;**Reader**和**InputStream**一样,用于从流中读取数据。它和**InputStream**的区别在于,**InputStream**以**字节**为单位操作流,而**Reader**以**字符**为单位操作流。  
&emsp;&emsp;**Reader**类是所有输入字待流的父类,**Writer**类是所有输出字符流的父类。设计**Reader**和**Writer**继承层次结构主要是为了国际化。而旧的I/O流继承层次结构仅支持8位字节流,并且不能很好的处理16位的Unicode字符。由于Unicode用于字符国际化,所以添加字符流的继承层次结构就是在所有的I/O操作中都支持Unicode。  
### Reader常用方法

| 方法                                                | 说明                                                                     |
|-----------------------------------------------------|--------------------------------------------------------------------------|
| **int read()**                                      | 读取一个字符,并将它返回                                                  |
| **int read(char\[\] buffer)**                       | 将从流中读取的字符放到字符数组buffer中,返回读出的字符数。                |
| **int read(char\[\] buffer,int offset,int length)** | 将读出的字符放到字符数组的指定offet开始的空间,每次最多读出length个字符。 |
| void mark(int )                                     | 标记流中的位置                                                           |
| boolean MarkSupported()                             | 判断流是否支持mark()                                                     |
| boolean ready()                                     | 判断是否准备读取此流                                                     |

### Reader相关类
&emsp;&emsp;低级**Reader**类：  
> **CharArrayReader**  
**PipedReader**  
**StringReader**  
**FileReader**  

&emsp;&emsp;高级**Reader**类  
> **BufferedReader**  
**InputStreamReader**  
**LineNumberReader**  

```java
package com.aotmd.test;  
import java.io.BufferedReader;  
import java.io.FileNotFoundException;  
import java.io.FileReader;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileReader fr;  
        int reccount = 0;  
        try {  
            fr = new FileReader("file2.txt");  
            BufferedReader br = new BufferedReader(fr);  
            String record = "";  
            while ((record = br.readLine()) != null) {  
                reccount++;  
                System.out.println("Line" + reccount + ": " + record);  
            }  
            fr.close();  
            br.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
### Writer常用方法

| 方法                                                 | 说明                                                   |
|------------------------------------------------------|--------------------------------------------------------|
| **void write(int c)**                                | 将参数c的低16位组成字符写入到流中。                    |
| **void write(char\[\]buffer)**                       | 将字符数组buffer中的字符写入到流中。                   |
| **void write(char\[\]buffer,int offset,int length)** | 将字符数组buffer中从offset开始的length个字符写入到流中 |
| void write(String string)                            | 将string字符串写入到流中。                             |
| void write(String string,int offset,int length)      | 将字符string中从offset开始的length个字符写入到流中。   |
| Writer append(char c)                                | 将指定字符添加到此writer                               |
| void close()                                         | 关闭流                                                 |
| void flush()                                         | 刷空输岀流,并输岀所有被缓存的字节。                    |

### Writer相关类
&emsp;&emsp;低级**Writer**类：  
> **CharArrayWriter**
**StringWriter**
**PipedWriter**
**FileWriter**

&emsp;&emsp;高级**Writer**类  
> **BufferedWriter**
**OutputStreamWriter**
**PrintWrite**

```java
package com.aotmd.test;  
import java.io.FileWriter;  
import java.io.IOException;  
import java.io.PrintWriter;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileWriter fw;  
        PrintWriter out;  
        try {  
            fw = new FileWriter("file2.txt", true);//建立一个文件输出流,true追加  
            out = new PrintWriter(fw);//建立一个PrintWriter对象,它将作为标准输出流  
            out.println("这是一个测试串PrintWriter");  
            out.close();  
            fw.close();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
## 其他
**标准输入输出的重定向**
&emsp;&emsp;Java系统预先定义3个流对象;  
1. 标准输出设备**System.out**  
2. 标准输入设备**System.in**  
3. 标准错误设备**System.err**  

&emsp;&emsp;在默认情况下,标准输入设备是键盘,而标准输出设备是显示器,通过**System.setIn**方法和**System.setout**方法可以改变它们的默认输入/输出设备  
&emsp;&emsp;实例  
```java
package com.aotmd.test;  
import java.io.*;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileOutputStream fos = null;  
        PrintStream ps;  
        try {  
            fos = new FileOutputStream("Demo.txt", true);//建立一个文件输出流,并将它的append标记设置为true  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
        ps = new PrintStream(fos);// 建立一个PrintStream对象,它将作为标准输出流  
        System.setOut(ps);//将标准输出定向到PrintStream对象  
        System.out.println("该字符串会输出到文件中");//输出以条数据,它不再会在控制台输出,而是输出到了文件Demo.txt中  
    }  
}
```
&emsp;&emsp;**RandomAccessFile**类  
&emsp;&emsp;**RandomAccessFile**是一种特殊的文件流,可以用它在文件的任何地方查找或者插入数据  
&emsp;&emsp;**RandomAccessFile**同时实现了**Datalnput**和**DataOutput**接口,所以可以用它来读/写文件  
&emsp;&emsp;构造器  
&emsp;&emsp;**RandomAccessFile(java.io.File f,String mode)**  
&emsp;&emsp;**RandomAccessFile(String file,String mode)**  
```java
RandomAccessFile rf1 = new RandomAccessFile("toAppend.txt", "rw");  
rf1.seek(100);  
rf1.writeBytes( "123\n");  
rf1.close();
```
&emsp;&emsp;**FileOutputStream**流类  
&emsp;&emsp;**FileOutputStream(String fileName)** 参数**fileName**表示带路径的磁盘文件名。  
&emsp;&emsp;**FileOutputStream(File file)** 参数**file**表示为磁盘文件所建立的**File**对象名  

&emsp;&emsp;**FilelnputStream**流类  
&emsp;&emsp;**FilelnputStream(String fileName)** 参数**fileName**表示带路径的磁盘文件名。  
&emsp;&emsp;**FilelnputStream(File file)** 参数**file**表示为磁盘文件所建立的**File**对象名。
    
&emsp;&emsp;**DataOutputStream**流类  
&emsp;&emsp;使用**DataOutputStream**类向文件中写入各种类型数据的操作步骤是:  
1. 为磁盘文件建立**File**类对象;  
2. 为该**File**对象建立**FileOutputStream**类流对象,建立其与磁盘文件的连接;  
3. 为该**FileOutputStream**类对象建立**DataOutputStream**类对象,利用**DataOutputStream**类的**writelnt()**,**writeFloat()**, **writeDouble()**,**writeBoolean()**等方法分别尚文件中写入整型、单精度型、双精度型、布尔型等数据;  
4. 写入操作完成后,利用**close()**方法将流关闭,断开与磁盘文件的联系。  

&emsp;&emsp;以字符流方式向文件写入或从文件中读取数据,可以使用**Writer**和**Reader**类及其子类。  
&emsp;&emsp;**Writer**和**Reader**类都是抽象类,不能建立它们的对象,所以只能通过它们子类对象对文件进行操作。常用的 **Writer**类的子类包括**FileWriter**类和**BufferedFileWriter**类。  
&emsp;&emsp;**FileWriter**类构造方法如下:  
&emsp;&emsp;**FileWriter(String fileName)** 参数**fileName**表示带路径的磁盘文件名。  
&emsp;&emsp;**FileWriter(File file);** 参数**file**表示为磁盘文件所建立的**File**对象名。  
&emsp;&emsp;注;使用**FileWriter**进行文件操作时,为了减少磁盘读写次数,**常使用具有缓冲功能的BufferedWriter类。**  
## 缓存流
&emsp;&emsp;缓存流是计算机领域中输入输出流的一种常见形式。包括**BufferedInputStream**/ **BufferedOutputStream** 类和**BufferedReader**/ **BufferedWriter**类。  
&emsp;&emsp;这种流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出,通过**减少系统**资源的**读写次数**来**加快**程序的执行。**BufferedOutputstream** 或**BufferedWriter** 类仅仅在缓冲区满或调用**flush()**方法时才将数据写到目的地。  
&emsp;&emsp;缓存流是过滤流,在创建具体流时需要给出一个**InputStream** / **OutputStream** 类型的流座位前端流,并可以指明缓冲区的大小。  
&emsp;&emsp;**public BufferedInputStream(InputStream in)**  
&emsp;&emsp;**public BufferedInputStream(InputStream in,int size)**  
&emsp;&emsp;**BufferedInputStream** / **BufferedOutputStream**类提供**InputStream** /**OutputStream** 中定义的方法,例如 **read()** , **skip()**,**write()**等,并支持基于标签机制的回读。  
&emsp;&emsp;**BufferedReader**类中增加了一个有用的方法 **readLine()**,该方法读一行字符返回。行的结束标志是换行符“**\n**”或回车符“**\r**”,或回车符+换行符。  
&emsp;&emsp;**BufferedWriter**中也相应增加了一个方法**newLine()**,该方法写一个行分隔符。分隔符由系统特性**line.separator** 指定,可以是“**\n**”。  
&emsp;&emsp;**public class BufferedWriter extends Writer**  
&emsp;&emsp;将文本写入字符输出流,缓冲各个字符,从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小,或者接受默认的大小。在大多数情况下,默认值就足够大了。该类提供了**newLine()**方法,它使用平台自己的行分隔符概念,此概念由系统属性 **line.separator** 定义。并非所有平台都使用新行符('\n')来终止各行。因此调用此方法来终止每个输出行要**优于**直接写入新行符。 通常 **Writer** 将其输出立即发送到底层字符或字节流。除非要求提示输出,否则**建议用BufferedWriter包装所有其write()操作**可能开销很高的**Writer**(如 **FileWriters**和**OutputStreamWriters**)。例如:  
&emsp;&emsp;PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out")));  
&emsp;&emsp;将缓冲**PrintWriter**对文件的输出。如果没有缓冲,则每次调用**print()**方法会导致将字符转换为字节,然后立即写入到文件,而这是极其低效的。  
&emsp;&emsp;**BufferedReader**同理  
```java
package a1;  
import java.io.BufferedReader;  
import java.io.FileNotFoundException;  
import java.io.FileReader;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileReader fr;  
        int reccount = 0;  
        try {  
            fr = new FileReader("file2.txt");  
            *BufferedReader br = new BufferedReader(fr);*  
                String record = "";  
            while ((record = br.readLine()) != null) {  
                reccount++;  
                System.out.println("Line" + reccount + ": " + record);  
            }  
            fr.close();  
            br.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
## DataOutputStream/DataInputStream
&emsp;&emsp;数据输出流允许应用程序以与机器无关方式将Java基本数据类型写到底层输出流。  
&emsp;&emsp;可以使用**DataOutputStream**和**DataInputStream**写入和读取数据。  
&emsp;&emsp;在IO包中提供了两个与平台无关的数据操作流  
&emsp;&emsp;数据输出流：**DataOutputStream**  
&emsp;&emsp;数据输入流：**DataInputStream**  
&emsp;&emsp;通常按照一定格式将输入输出,再按照一定格式将数据输入。  
&emsp;&emsp;要想使用数据输出流和输入流,则**肯定要用户指定数据的保存格式**。必须按指定的格式保存数据,才可以将数据输入流将数据读取进来。  
&emsp;&emsp;**DataOutputStreams**是**OutputStream**的子类。  
&emsp;&emsp;**public class DataOutputStream extends FilterOutputStream implements DataOutput**  
&emsp;&emsp;此类继承自**FillterOutputStream**类,同时实现**DataOutput**接口。在**DataOutput**接口定义了一系列写入各种数据的方法。  
&emsp;&emsp;**DataOutput**接口定义了一系列的**writeXXX()**的操作,可以写入各种类型数据。  
&emsp;&emsp;要想使用**DataOutputStream**写入数据的话,则必须指定好数据的输出格式。  
&emsp;&emsp;**DataOutputStream**  
&emsp;&emsp;**字段**  
&emsp;&emsp;到目前为止写入数据输出流的字节数。  
&emsp;&emsp;**protected int written**  
&emsp;&emsp;**构造方法**  
&emsp;&emsp;创建一个新的数据输出流,将数据写入指定基础输出流。  
&emsp;&emsp;**DataOutputStream(OutputStream out)**  
&emsp;&emsp;**写方法**  
&emsp;&emsp;(1)基本数据类型写入方法：八种基本类型：六种数字类型(四个整数型,两个浮点型),一种字符类型,还有一种布尔型。  

| 方法                         | 说明                                                                                                                         |
|------------------------------|------------------------------------------------------------------------------------------------------------------------------|
| void writeByte(int v)        | 将一个byte值以1-byte值形式写出到基础输出流中。                                                                               |
| void writeShort(int v)       | 将一个short值以2-byte值形式写入基础输出流中,先写入高字节。                                                                   |
| void writeInt(int v)         | 将一个int值以4-byte值形式写入基础输出流中,先写入高字节。                                                                     |
| void writeLong(long v)       | 将一个long值以8-byte值形式写入基础输出流中,先写入高字节。                                                                    |
| void writeFloat(float v)     | 使用Float类中的floatToIntBits方法将float参数转换为一个int值,然后将该int值以4-byte值形式写入基础输出流中,先写入高字节。       |
| void writeDouble(double v)   | 使用Double类中的doubleToLongBits方法将double参数转换为一个long值,然后将该long值以8-byte值形式写入基础输出流中,先写入高字节。 |
| void writeChar(int v)        | 将一个char值以2-byte值形式写入基础输出流中,先写入高字节。                                                                    |
| void writeBoolean(boolean v) | 将一个boolean值以1-byte值形式写入基础输出流。                                                                                |

&emsp;&emsp;(2)字节数组的写入方法  
&emsp;&emsp;**void write(byte\[\] b, int off, int len)** 将指定 **byte** 数组中从偏移量 **off** 开始的 **len** 个字节写入基础输出  
&emsp;&emsp;(3)只写入int的低八位  
&emsp;&emsp;**void write(int b)** 将指定字节(参数**b**的八个低位)写入基础输出流。  
&emsp;&emsp;(4)写入字符串的方法  
&emsp;&emsp;**void writeBytes(String s)** 将字符串按字节顺序写出到基础输出流中。  
&emsp;&emsp;**void writeChars(String s)** 采用**UTF-16be**方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。  
&emsp;&emsp;**void writeUTF(String str)** 以与机器无关方式使用**UTF-8**修改版编码将一个字符串写入基础  
&emsp;&emsp;4.其他方法  
&emsp;&emsp;**void flush()** 清空此数据输出流。写入文件  
&emsp;&emsp;**int size()** 返回计数器 **written** 的当前值,即到目前为止写入此数据输出流的字节数。  
&emsp;&emsp;**DataInputStream**  
&emsp;&emsp;**构造方法**  
&emsp;&emsp;使用指定的底层 **InputStream** 创建一个 **DataInputStream**。  
&emsp;&emsp;**DataInputStream(InputStream in)**  
&emsp;&emsp;**读方法**  

&emsp;&emsp;1.基本类型读取方法：  

| 方法                  | 说明                                                                                                                                                                                                       |
|-----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| byte readByte()       | 读取并返回一个输入字节。该字节被看作是 -128 到 127(包含)范围内的一个有符号值。                                                                                                                             |
| int readInt()         | 读取四个输入字节并返回一个 int 值。                                                                                                                                                                        |
| short readShort()     | 参见 DataInput 的 readShort 方法的常规协定。                                                                                                                                                               |
| long readLong()       | 读取八个输入字节并返回一个 long 值。                                                                                                                                                                       |
| float readFloat()     | 读取四个输入字节并返回一个 float 值。                                                                                                                                                                      |
| double readDouble()   | 读取八个输入字节并返回一个 double 值。实现这一点的方法是：   先使用与 readlong 方法完全相同的方式构造一个 long 值, 然后使用与 Double.longBitsToDouble 方法完全相同的方式将此 long 值转换成一个 double 值。 |
| boolean readBoolean() | 读取一个输入字节,如果该字节不是零,则返回 true,如果是零,则返回 false。                                                                                                                                      |
| char readChar()       | 读取两个输入字节并返回一个 char 值。                                                                                                                                                                       |

&emsp;&emsp;2.字符串读取方法  
&emsp;&emsp;**String readUTF();** 读入一个已使用 UTF-8 修改版格式编码的字符串。  
&emsp;&emsp;**static String readUTF(DataInput in)** 从流 in 中读取用 UTF-8 修改版格式编码的 Unicode 字符格式的字符串;然后以 **String** 形式返回此字符串。  
&emsp;&emsp;可以看到**DataInputStream**中读取字符串**只有readUTF()**方法,**没有**与**DataOutputStream**对应的：  
&emsp;&emsp;**void writeBytes(String s)** 将字符串按字节顺序写出到基础输出流中。  
&emsp;&emsp;**void writeChars(String s)** 采用UTF-16be方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。  
&emsp;&emsp;使用**DataOutputStream**的这两个方法写入字符串时,**DataInputStream**来读取可能比较**麻烦**。  
&emsp;&emsp;3.无符号整数读取方法  
&emsp;&emsp;**DataInputStream**中并没有写入无符号整数的方法,这两个方法是不是用不到？  
&emsp;&emsp;**int readUnsignedByte();**读取一个输入字节,将它左侧补零 (zero-extend) 转变为 **int** 类型,并返回结果,所以结果的范围是 0 到 255。如果接口 **DataOutput** 的 **writeByte** 方法的参数是 0 到 255 之间的值,则此方法适用于读取用 **writeByte** 写入的字节。  
&emsp;&emsp;**int readUnsignedShort();**读取两个输入字节,并返回 0 到 65535 范围内的一个 **int** 值。如果接口 **DataOutput** 的 **writeShort** 方法的参数是 0 到 65535 范围内的值,则此方法适用于读取用 **writeShort** 写入的字节。  

&emsp;&emsp;4.读取字节数组的方法：  

| 方法                                         | 说明                                                                                      |
|----------------------------------------------|-------------------------------------------------------------------------------------------|
| int read(byte\[\] b)                         | 从包含的输入流中读取一定数量的字节,并将它们存储到缓冲区数组 **b** 中。                    |
| int read(byte\[\] b, int off, int len)       | 从包含的输入流中将最多 **len** 个字节读入一个 **byte** 数组中。                           |
| void readFully(byte\[\] b)                   | 从输入流中读取一些字节,并将它们存储在缓冲区数组 **b** 中。读取的字节数等于 **b** 的长度。 |
| void readFully(byte\[\] b, int off, int len) | 从输入流中读取 **len** 个字节到字节数组**b**,**从**b的**off**下标开始读入。               |

&emsp;&emsp;5.同样是读取字节数组的方法,**read(byte\[\] b)**和**readFully(byte\[\] b)**的区别：  
&emsp;&emsp;其实**read(byte\[\] b)**方法和**readFully(byte \[\]b)**都是利用**InputStream**中**read()**方法,每次读取的也是一个字节,只是读取字节数组的方式不同.  
&emsp;&emsp;**read(byte\[\] b)**方法实质是读取流上的字节直到流上**没有**字节为止,如果当声明的字节数组长度**大于**流上的数据长度时就提前返回  
&emsp;&emsp;**readFully(byte\[\] b)**方法是读取流上**指定长度**的字节数组,也就是说如果声明了长度为**len**的字节数组,**readFully(byte\[\] b)**方法只有读取**len**长度个字节的时候才返回,否则**阻塞等待**,如果超时,则会抛出异常 **EOFException**。  
&emsp;&emsp;那么当发送了长度为**len**的字节,那么为什么用**read**方法用户收不全呢,揪其原因我们发现消息在网络中传输是没那么理想的,我们发的那部分字节数组在传送过程中可能在接受信息方的缓存当中或者在传输线路,极端情况下可能在发送方的缓存当中,这样就不在流上,所以**read**方法提前返回了,这样就造成了各种错误。  
&emsp;&emsp;**readFully()**源码：  
```java
public void readFully(byte[] b, int off, int len, boolean copy) throws IOException { 
    while (len > 0) {  
        int n = read(b, off, len, copy);  
        if (n < 0) {  
            throw new EOFException();  
        }  
        off += n;  
        len -= n;  
    }  
}
```
&emsp;&emsp;**readFully**方法并不是说一下就把整个文件读完了,不用去管是否到达文件末尾的异常。**readFully**只是在读取数据的时候,会一直把缓冲区读满,否则一直处于阻塞状态而等待读取。  
&emsp;&emsp;**read**方法只是将字节流中的数据读完。那么数据在TCP协议传送的过程中,可能输入流接受到的数据并不完全,只是其中的一部分。  
&emsp;&emsp;如果这时候的缓冲区没有满的话,**readFully**将会继续等待,直到缓冲区装满。  
&emsp;&emsp;某些时候,你可能需要读出特定的长度的字段。比如一些数据的头信息之类的,这时候如果你用**read**去读,那么可能还没有读完就个你返回来了。但是如果去用**readFully**读,那么就会完整的给你读出来。但是在更多的时候,如果不是确定要用特定长度的数据。还是用**read**去读。用**readFully**有点危险。  
&emsp;&emsp;6.跳过n个字节：  
&emsp;&emsp;**int skipBytes(int n)** 试图在输入流中跳过数据的**n**个字节,并丢弃跳过的字节。  
&emsp;&emsp;**实例**  

```java
package com.aotmd.test;  
import java.io.*;  
public class NoteTest  
{  
    public static void main(String[] args) throws IOException  
    {  
        FileOutputStream out = new FileOutputStream("testDataOutputStream.txt");  
        DataOutputStream dos = new DataOutputStream(out);  
        byte b = 20;  
        short s = 30;  
        int a = 900;  
        float f = 12.3f;  
        long l = 800l;  
        double d = 14.23;  
        boolean flag = true;  
        char ch = '中';  
        dos.writeByte(b);// 写入byte类型数据  
        dos.writeShort(s);// 写入short类型数据  
        dos.writeInt(a);// 写入int类型  
        dos.writeFloat(f);// 写入float类型  
        dos.writeLong(l);// 写入long类型  
        dos.writeDouble(d);// 写入double类型  
        dos.writeBoolean(flag);  
        dos.writeChar(ch);// 写入char类型  
        dos.close();  
        out.close();  
        FileInputStream in = new FileInputStream("testDataOutputStream.txt");  
        DataInputStream dif = new DataInputStream(in);  
        byte btemp;  
        short stemp;  
        int atemp;  
        float ftemp;  
        long ltemp;  
        double dtemp;  
        boolean flagtemp;  
        char chtemp;  
        btemp = dif.readByte();  
        stemp = dif.readShort();  
        atemp = dif.readInt();  
        ftemp = dif.readFloat();  
        ltemp = dif.readLong();  
        dtemp = dif.readDouble();  
        flagtemp = dif.readBoolean();  
        chtemp = dif.readChar();  
        // stringtemp=dif.read  
        System.out.println(btemp);  
        System.out.println(stemp);  
        System.out.println(atemp);  
        System.out.println(ftemp);  
        System.out.println(ltemp);  
        System.out.println(dtemp);  
        System.out.println(flagtemp);  
        System.out.println(chtemp);  
        dif.close();  
        in.close();  
    }  
}
```
&emsp;&emsp;输出:  
```text
20
30
900
12.3
800
14.23
true
中
```
&emsp;&emsp;**实例二**  
```java
package com.aotmd.test;  
import java.io.DataOutputStream;  
import java.io.File;  
import java.io.FileOutputStream;  
public class NoteTest {  
    public static void main(String[] args) throws Exception { // 所有异常抛出  
        DataOutputStream dos; // 声明数据输出流对象  
        File f = new File("d:" + File.separator + "order.txt"); // 文件的保存路径  
        dos = new DataOutputStream(new FileOutputStream(f)); // 实例化数据输出流对象  
        String[] names = {"衬衣", "手套", "围巾"}; // 商品名称  
        float[] prices = {98.3f, 30.3f, 50.5f}; // 商品价格  
        int[] nums = {3, 2, 1}; // 商品数量  
        for (int i = 0; i < names.length; i++) { // 循环输出  
            dos.writeChars(names[i]); // 写入字符串,注意,这边少数writeChars(),不是writechar(*。  
            dos.writeChar('\t'); // 写入分隔符,这边是读取writechar()。  
            dos.writeFloat(prices[i]); // 写入价格  
            dos.writeChar('\t'); // 写入分隔符  
            dos.writeInt(nums[i]); // 写入数量  
            dos.writeChar('\n'); // 换行  
        }  
        dos.close(); // 关闭输出流  
    }  
}
```
&emsp;&emsp;代码生成的文件  
```text
886c 8863 0009 42c4 999a 0009 0000 0003
000a 624b 5957 0009 41f2 6666 0009 0000
0002 000a 56f4 5dfe 0009 424a 0000 0009
0000 0001 000a
```
&emsp;&emsp;使用**DataOutpputStream**写入的数据要使用**DataInputStream**取出进来,  
```java
package com.aotmd.test;  
import java.io.DataInputStream;  
import java.io.File;  
import java.io.FileInputStream;  
public class NoteTest {  
    public static void main(String args[]) throws Exception { // 所有异常抛出  
        DataInputStream dis = null; // 声明数据输入流对象  
        File f = new File("d:" + File.separator + "order.txt"); // 文件的保存路径  
        dis = new DataInputStream(new FileInputStream(f)); // 实例化数据输入流对象  
        String name = null; // 接收名称  
        float price = 0.0f; // 接收价格  
        int num = 0; // 接收数量  
        char temp[] = null; // 接收商品名称  
        int len = 0; // 保存读取数据的个数  
        char c = 0; // '\u0000'  
        try {  
            while (true) {  
                temp = new char[200]; // 开辟空间  
                len = 0;  
                while ((c = dis.readChar()) != '\t') { // 接收内容,因为直到读取到'\t'才完成了读取一个字符串,未读取到表示还有内容。  
                    temp[len] = c;  
                    len++; // 读取长度加1  
                }  
                name = new String(temp, 0, len); // 将字符数组变为String  
                price = dis.readFloat(); // 读取价格  
                dis.readChar(); // 读取\t  
                num = dis.readInt(); // 读取int  
                dis.readChar(); // 读取\n  
                System.out.printf("名称：%s;价格：%5.2f;数量：%d\n", name, price, num);  
            }  
        } catch (Exception e) {  
        }  
        dis.close();  
    }  
}
```
&emsp;&emsp;执行结果：  
```text
名称：衬衣;价格：98.30;数量：3
名称：手套;价格：30.30;数量：2
名称：围巾;价格：50.50;数量：1
```
&emsp;&emsp;**DataInputStream**读取字符串,只能通过**readchar(),**一个个读取,不像**DataOutpputStream**一样还区分**writechars()**,**writechar()**。  
# GUI
&emsp;&emsp;**JFrame**  
&emsp;&emsp;**构造方法**  

| 方法                                           | 说明                                                                   |
|------------------------------------------------|------------------------------------------------------------------------|
| JFrame()                                       | 构造一个初始时不可见的新窗体。                                         |
| JFrame(GraphicsConfiguration gc)               | 以屏幕设备的指定 GraphicsConfiguration 和空白标题创建一个 Frame。      |
| JFrame(String title)                           | 创建一个新的、初始不可见的、具有指定标题的 Frame。                     |
| JFrame(String title, GraphicsConfiguration gc) | 创建一个具有指定标题和指定屏幕设备的 GraphicsConfiguration 的 JFrame。 |

&emsp;&emsp;**常用方法**  

| 方法                                    | 说明                                   |
|-----------------------------------------|----------------------------------------|
| add()                                   | 将组件添加到窗口                       |
| is/setVisible()                         | 获取/设置窗体的可视状态。              |
| get/setTitle()                          | 获取/设置窗体的标题。                  |
| get/setState()                          | 获取/设置窗体的的最小化,最大化等状态。 |
| get/setLocation()                       | 获取/设置窗体在屏幕上应当出现的位置。  |
| get/setSize()                           | 获取/设置窗体的大小。                  |
| setDefaultCloseOperation(int operation) | 设置单击窗体上的关闭按钮时的默认操作。 |
| getContentPane()                        | 获取窗体的内容面板                     |

&emsp;&emsp;**setDefaultCloseOperation**  
&emsp;&emsp;**public void setDefaultCloseOperation(int operation)**  
&emsp;&emsp;设置用户在此窗体上发起"**close**"时默认执行的操作。必须指定以下选项之一：  
&emsp;&emsp;值依次为**0-3**  
&emsp;&emsp;**DO_NOTHING_ON_CLOSE**(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 **WindowListener** 对象的 **windowClosing** 方法中处理该操作。  
&emsp;&emsp;**HIDE_ON_CLOSE**(在 **WindowConstants** 中定义)：调用任意已注册的 **WindowListener** 对象后自动隐藏该窗体。  
&emsp;&emsp;**DISPOSE_ON_CLOSE**(在 **WindowConstants** 中定义)：调用任意已注册 **WindowListener** 的对象后自动隐藏并释放该窗体。  
&emsp;&emsp;**EXIT_ON_CLOSE**(在 **JFrame** 中定义)：使用 **System exit** 方法退出应用程序。仅在应用程序中使用。  
&emsp;&emsp;默认情况下,该值被设置为 **HIDE_ON_CLOSE**。更改此属性的值将导致激发属性更改事件,其属性名称为 "**defaultCloseOperation**"。  
&emsp;&emsp;注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机**可能**会终止。  
&emsp;&emsp;**frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);**  
# 网络
&emsp;&emsp;常见服务和对应端口号  

| 端口 | 对应服务   |
|------|------------|
| 7    | Echo服务器 |
| 21   | Ftp        |
| 23   | telnet     |
| 25   | SMTP       |
| 79   | Finger     |
| 80   | HTTP       |

## URL类

| 构造方法                                                         | 说明                                                                  |
|------------------------------------------------------------------|-----------------------------------------------------------------------|
| public URL(String spec);                                         | URL u1 =new URL("http://home.netscape.com/home/");                    |
| public URL(URL context, String spec);                            | URL u2=new URL(u1, "welcome.html");                                   |
| public URL(String protocol, String host, String file);           | URL u3=new URL("http", "www.sun.com",developers/index.html");         |
| public URL (String protocol, String host, int port, String file) | URL u4 = new URL("http", "www.sun.com", 80,"developers/index.html" ); |

## URLConnection类
&emsp;&emsp;**Uonnection**类支持**URL**连接的输入/输出流方式的通信,并可以获得**URL**对象资源的相关信息。它是所有应用程序和**URL**连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。  
&emsp;&emsp;常用的成员方法：  

| 方法                                 | 说明                           |
|--------------------------------------|--------------------------------|
| void setUseCaches(boolean uescaches) | 设置是否允许使用高速缓冲存储器 |
| object getContent()                  | 获取当前URL连接的信息内容      |
| String getContentType()              | 返回连接类型的头域值           |
| int getContentLength()               | 返回当前连接长度的头域值       |
| long getDate()                       | 返回当前日期头域值             |
| long getLastModified()               | 返回最后修改时间头域值         |
| inputStream getInputStream()         | 返回连接的输入济               |
| outputStream getOutputStream()       | 返回连接的输出流               |

&emsp;&emsp;将baidu内容重定向到Demo.txt  
```java
package com.aotmd.test;  
import java.io.*;  
import java.net.URL;  
import java.net.URLConnection;  
import java.util.StringTokenizer;  
public class NoteTest {  
    public static void main(String[] args) throws IOException {  
        FileOutputStream fos = null;  
        PrintStream ps = null;  
        try {  
            fos = new FileOutputStream("Demo.txt", true);//建立一个文件输出流,并将它的append标记设置为true  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
        ps = new PrintStream(fos);// 建立一个PrintStream对象,它将作为标准输出流  
        System.setOut(ps);//将标准输出定向到PrintStream对象  
        URLConnection conn = null;  
        String nextLine = null;  
        StringTokenizer tokenizer = null;  
        URL url2 = new URL("http://www.baidu.com");  
        conn = url2.openConnection();  
        conn.setDoOutput(true);  
        conn.connect();  
        BufferedReader Reader1 = new BufferedReader(new InputStreamReader(conn.getInputStream()));  
        while ((nextLine = Reader1.readLine()) != null)  
            tokenizer = new StringTokenizer(nextLine);  
        while (tokenizer.hasMoreTokens()) {  
            String urlToken = tokenizer.nextToken();  
            System.out.println(urlToken);  
        }  
    }  
}
```
## Socket概念
&emsp;&emsp;两个Java应用程序可通过一个双向的网络通信连接实现**数据交换**,这个双向链路的一端称为一个**socket**.**socket**通常用来实现**client-server**连接。java.net包中定义的两个类**Socket**和**ServerSocket**,分别用来实现双向连接的**client**和**server**端.  
&emsp;&emsp;套接字(**Socket**)：表示一个系统的IP地址和端口号的结合。  
&emsp;&emsp;**TCP/IP**连接的一个端点用来处理两个流对象  
&emsp;&emsp;创建**TCP Socket**需要的四个信息：本地系统的**IP**本地应用程序使用的**TCP**端口号远程系统的**IP**远程应用程序相应的**TCP**端口号  

## Socket类
&emsp;&emsp;**Socket类构造器**  
> **Socket()**  
> **Socket(InetAddress address,int port)**  
> **Socket(InetAddress address,int port,InetAddress localAddr,int localPort)**  
> **Socket(String host,int port)**  
> **protected Socket(Socketlmpl impl)**  
> **Socket(String host,int port,InetAddress localAddr,int localPort)**  
> **Socket(InetAddress address, int port)**  
> **Socket(InetAddress address, int port,boolean stream);**  
> **Socket(String host, int port);**  
> **Socket(String host, int port, boolean stream);**  
> **ServerSocket(int port);**  
> **ServerSocket(int port, int count);**  

&emsp;&emsp;**Socket方法**  
> **getlnputStream()**  
> **getOutputStream()**  
> **close()**  

## ServerSocket类

&emsp;&emsp;ServerSocket类用于侦听一个客户端的Socket连接,如果没有连接,它将一直等待。  
&emsp;&emsp;**ServerSocket构造器**  

| 构造方法                                                 | 说明                                                                                   |
|----------------------------------------------------------|----------------------------------------------------------------------------------------|
| ServerSocket(int port)                                   | 用指定的端口**port**来创建一个侦听**Socket**                                           |
| ServerSocket(int port,int backlog)                       | 加上一个用来改变连接队列长度的参数**backlog**.                                         |
| ServerSocket(int port,int backlog,lnetAddress localAddr) | 在机器存在多个**IP**地址的情况下,允许通过**localAddr**这个参数来指定侦听的**IP**地址。 |

&emsp;&emsp;**ServerSocket方法**  
&emsp;&emsp;**Socket accept()**  
&emsp;&emsp;**close()**  
## 示例

&emsp;&emsp;服务端程序编写  
1.  调用**ServerSocket(int port)**创建一个服务端套接字，并绑定到指定端口上；
2.  调用**socket**类的**getOutputStream()**和**getlnputStream()**获取输入流和输出流
3.  关闭**socket**；

&emsp;&emsp;客户端程序编写  

1.  调用**Socket()**创建流套接字，并链接到服务端；
2.  调用**accept()**监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；
3.  调用**socket**类的**getOutputStream()**和**getInputStream()**获取输入流和输出流；
4.  关闭**socket**；

&emsp;&emsp;客户端Socket的建立  
```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings({"unused", "resource"})  
            Socket socket = new Socket("127.0.0.1", 2000);  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```
&emsp;&emsp;服务器端Socket的建立  
```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        ServerSocket server = null;  
        try {  
            server = new ServerSocket(2000);  
        } catch (IOException e) {  
            System.out.println("can not listen to :" + e);  
        }  
        Socket socket = null;  
        try {  
            socket = server.accept();  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```
&emsp;&emsp;打开输入/出流  
```java
PrintStream os = new PrintStream(new BufferedOutputStream(socket.getOutputStream());  
DataInputStream is = new DataInputStream(socket.getInputStream());
```
&emsp;&emsp;关闭Socket  
```java
os.close();is.close();socket.close();
```
&emsp;&emsp;简单的**client**/**server**程序  
```java
package com.aotmd.test;  
import java.io.*;  
import java.net.ConnectException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings("resource")  
            ServerSocket s = new ServerSocket(8888);  
            while (true) {  
                Socket s1 = s.accept();  
                OutputStream os = s1.getOutputStream();  
                DataOutputStream dos = new DataOutputStream(os);  
                dos.writeUTF("Hello," + s1.getInetAddress() + "port#" + s1.getPort() + "bye-bye!");  
                dos.close();  
                s1.close();  
                // s.close();  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        try {  
            Socket s1 = new Socket("127.0.0.1", 8888);  
            InputStream is =s1.getInputStream();  
            DataInputStream dis = new DataInputStream(is);  
            System.out.println(dis.readUTF());  
            dis.close();  
            s1.close();  
        } catch (ConnectException connExc) {  
            System.err.println("服务器连接失败！");  
        } catch (IOException e) {  
        }  
    }  
}
```
&emsp;&emsp;先运行服务器,然后运行客户端,会收到服务器发的信息.  
&emsp;&emsp;例子二  
```java
package com.aotmd.test;  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintStream;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        ServerSocket server;  
        try {  
            server = new ServerSocket(1234);  
            Socket sk = server.accept();  
            BufferedReader br = new BufferedReader(new InputStreamReader(sk.getInputStream()));  
            System.out.println(br.readLine());  
            br.close();  
            server.close();  
        } catch (IOException e) {  
            System.out.println(e);  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        Socket client;  
        PrintStream ps;  
        try {  
            client = new Socket("localhost", 1234);  
            System.out.println("连接成功！");  
            ps = new PrintStream(client.getOutputStream());  
            ps.println("客户端回显的对话");  
            client.close();  
        } catch (IOException e) {  
            System.out.println(e);  
        }  
    }  
}
```
## URL与Socket通信的区别
&emsp;&emsp;利用**URL**进行通信与利用**socket**进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：  
&emsp;&emsp;利用**socket**进行通信时，在服务器端运行一个**socket**通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在**socket**通信方式中，服务器是主动等待连接通信的到来。  
&emsp;&emsp;利用**URL**进行通信时，在服务器端常驻一个**CGI**程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在**URL**通信方式中，服务器是被动等待连接通信的到来。  

## UDP通信
&emsp;&emsp;在基于**TCP/IP**网络体系结构的网络中主要使用**TCP**和**UDP**（**UserDatagramProtocol**，用户数据报协议）来实现数据通信。**TCP**是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而**UDP**则是一种面向无连接的不可靠传输协议，它**不能**确保数据能正确到达目的端，但是它能提高网络通信的效率。  
&emsp;&emsp;**UDP Socket特性**  
&emsp;&emsp;通过UDP的UDP端口来实现UDP协议的网络通信。  
&emsp;&emsp;其工作过程如下：  
&emsp;&emsp;创建一个适当的要发送且注明收发人地址数据报；  
&emsp;&emsp;为一个特定的应用程序建立一个传输端口来传送和接收数据包；  
&emsp;&emsp;将数据报插入一个传输端口中进行传输；  
&emsp;&emsp;等待接收来自于传输端口的一个数据报；  
&emsp;&emsp;解码数据报以解开消息、接收者和其它信息；  
&emsp;&emsp;**Java UDP类**  
&emsp;&emsp;**DatagramSocket**  
&emsp;&emsp;用于接收和发送**UDP**的**Socket**实例。该类有3个构造函数：  
&emsp;&emsp;**DatagramSocket()**：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）  
&emsp;&emsp;**DatagramSocket(int port)**：创建实例，并固定监听**Port**端口的报文。通常用于服务端  
&emsp;&emsp;**DatagramSocket(int port,InetAddress localAddr)**：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自**LocalAddr**的报文。  
