---
layout: post
title: Java笔记
categories: Java
description: Java的基础笔记
keywords: Java
---
# 引言  
java的基础笔记，输入输出、字符串、编码、数组、继承、多态、内部类、枚举、record、BigDecimal、BigInteger、Random、SecureRandom。  


# 基础
## 基本数据类型
- 简单数据类型
  - 数值型
    - 整数类（byte(8)，short(16)，int(32)，long(64)）
    - 浮点类型（float(32)，double(64)）
  - 字符型（char(16)）
  - 布尔型（boolean(1)）
- 引用数据类型
  - 类（class）
  - 接口（interface）
  - 数组

- int型：不带L：100，200，9_000_000
- long型：必须带L：100L，200L，9_000_000_000_000L
- double型：不带F：1.0，2.3e10
- float型：必须带F：1.0F，2.3e10F

中间的`_`可以随意加。`1_2_3_4`，浮点数也可以，比如`12_3.45`，不过为了规范，还是应该三个添加一个最好。  

`long l1 = 182L;` 因为`long`，`float`等字面值中均是数字开头，字母结尾，故变量名**不能数字开头**，避免与变量值歧义，编译不过。  

整数运算在除数为`0`时会报错，而浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值：  

- `NaN`表示Not a Number
- `Infinity`表示无穷大
- `-Infinity`表示负无穷大

java中可以对**浮点数**求模。  

字符类型`char`表示一个字符。Java的`char`类型除了可表示标准的ASCII外，还可以表示一个Unicode字符。注意`char`类型使用单引号`'`，且仅有一个字符，要和双引号`"`的字符串类型区分开。  

`var`不是关键字，而是在Java 10中引入的一种类型推断的新特性。它用于声明局部变量时，可以根据赋值语句的类型推断变量的类型，从而简化代码编写。需要注意的是，虽然`var`可以用于声明局部变量，但不能用于声明方法参数、方法返回值、类的字段等其他地方。  

------

**位移\<\<\>\> \>\>\>**

左移加0,右移加**符号位**  

例如**int a=30;a\>\>36;**  

那么**36**大于**int的位数**,要进行除**32**取余,即**a\>\>4**  

无符号右移运算符**\>\>\>**  

用来将一个数的各二进制位无符号右移若干位,与运算符**\>\>相同**的是移出的低位被舍弃,但**不同**的是最高位**补0**,如:  

**a=00110111**,则**a\>\>\>2** 结果为 **00001101**  

**b=11010011**,则**b\>\>\>2** 结果为 **00110100**  

------

**处理无符号整型

在Java中，并没有无符号整型（Unsigned）的基本数据类型。`byte`、`short`、`int`和`long`都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。  

例如，byte是有符号整型，范围是`-128`~`+127`，但如果把`byte`看作无符号整型，它的范围就是`0`~`255`。把一个负的`byte`按无符号整型转换为`int`：  

```java
byte x = -1;
byte y = 127;
System.out.println(Byte.toUnsignedInt(x)); // 255
System.out.println(Byte.toUnsignedInt(y)); // 127
```
因为`byte`的`-1`的二进制表示是`11111111`，以无符号整型转换后的`int`就是`255`。  

类似的，可以把一个`short`按unsigned转换为`int`，把一个`int`按unsigned转换为`long`。  

负数在计算机中用补码表示，计算方法是除符号位外取反+1，-1的原码是10000001，取反=111111110，再+1=11111111之所以用补码不是原码是因为补码可以把减法转换为加法  

------

`Integer.toHexString(n)`则通过核心库自动把整数格式化为16进制。  

## 输入输出
**输入**  
- `nextInt()`: 读取输入的下一个整数。如果遇到非整数字符（如空格、换行符等），会停止读取，并将输入中的整数部分作为结果返回。
- `nextDouble()`: 读取输入的下一个浮点数（小数）。同样地，遇到非浮点数字符会停止读取，并将输入中的浮点数部分作为结果返回。
- `next()`: 读取输入的下一个单词（以空格分隔的字符串）。遇到空格、换行符等会停止读取，并将输入中的单词部分作为结果返回。
- `nextLine()`: 读取输入的下一行文本（包括换行符）。它会读取输入直到换行符为止，并将包括换行符在内的整行文本作为结果返回。

```java
import java.util.Scanner;
Scanner scanner=new Scanner(System.in);
int m=scanner.nextInt();//读整数
double d=nextDouble()//读小数
String s = scanner.next();//读一串
scanner.nextLine();//读一行
```
`System.out`代表标准输出流，而`System.in`代表标准输入流。  

**输出**  

有回车  `System.out.println();`  

无回车  `System.out.print();`  

格式化输出使用`System.out.printf()`，不想打印只想生成字符串则使用`String.format()`。  

| 占位符 | 说明                             | 占位符 | 说明                               |
| :----- | :------------------------------- | ------ | ---------------------------------- |
| %d     | 格式化输出整数                   | %%     | 转义%，代指一个%                   |
| %x     | 格式化输出十六进制整数           | %8d    | 输出补到8位，不足在**前**面补空格  |
| %f     | 格式化输出浮点数                 | %-8d   | 输出补到8位，不足在**后**面补空格  |
| %e     | 格式化输出科学计数法表示的浮点数 | %08d   | 输出补到8位，不足则**前**面补**0** |
| %s     | 格式化字符串                     | %6.3f  | 输出补到6位,小数位占3位            |

详细的格式化参数请参考JDK文档[java.util.Formatter](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Formatter.html#syntax)  
## 字符串
**`args[0]`**是命令行执行的第一个字符串  `public static void main(String[] args){}`，以此类推。  

### 字符类型
字符类型`char`是**基本数据类型**，它是`character`的缩写。一个`char`保存一个Unicode字符：  
```java
char c1 = 'A';char c2 = '中';
```
因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用**一个**`char`类型表示，它们都占用**两个字节**。要显示一个字符的Unicode编码，只需将`char`类型直接赋值给`int`类型即可：  
```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
```
还可以直接用转义字符`\u`+Unicode编码来表示一个字符：  
```java
// 注意是十六进制:
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```
### 字符串类型
字符串类型`String`是**引用类型**，`\`是转义字符，两个`\\`表示一个`\`字符：  
常见的转义字符包括：  
- `\"` 表示字符`"`
- `\'` 表示字符`'`
- `\\` 表示字符`\`
- `\n` 表示换行符
- `\r` 表示回车符
- `\t` 表示Tab
- `\u####` 表示一个Unicode编码的字符

Java编译器对`String`有特殊处理，即可以直接用`"..."`来表示一个字符串。实际上字符串在`String`内部是通过一个`char[]`数组表示的，因此，按下面的写法也是可以的：  
```java
String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'});
```

------

**字符串连接**  

Java的编译器对字符串做了特殊照顾，可以使用`+`连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。  

引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`。  

------

**多行字符串**  

从**Java 13**开始，字符串可以用`"""..."""`表示多行字符串（Text Blocks）了。多行字符串前面共同的空格会被去掉，即：  

```java
String s = """
...........SELECT * FROM
...........  users
...........WHERE id > 100
...........ORDER BY name DESC
...........""";
```
用`.`标注的空格都会被去掉。如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：  
```java
String s = """
.........  SELECT * FROM
.........    users
.........WHERE id > 100
.........  ORDER BY name DESC
.........  """;
```
总是以最短的行首空格为基准。  

------

### 不可变特性
Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。字符串会维护在常量池内，而字符串变量指向常量池中的字符串。  

这意味着一旦字符串对象被创建，它的值就不能被修改。当你对字符串进行操作时，实际上是创建了一个新的字符串对象，而原始字符串对象保持不变。  

这种不可变性带来了一些优点，例如：  

- 线程安全：由于字符串是不可变的，多个线程可以安全地共享字符串对象而无需担心数据竞争。
- 缓存哈希值：由于字符串的不可变性，可以缓存字符串的哈希值，提高性能。
- 安全性：不可变字符串可以避免在运行时被修改，提高代码的安全性。

另外，字符串常量池是Java中用于存储字符串常量的特殊区域，它可以减少内存占用，提高性能。当你创建一个字符串常量时，如果常量池中已经存在相同内容的字符串，则会直接返回常量池中的字符串引用，而不会创建新的字符串对象。  

因此，了解字符串的不可变性和字符串常量池的特性有助于更好地理解和利用Java中的字符串。  

------

判断值类型的变量是否相等，可以使用`==`运算符。但是，判断引用类型的变量是否相等，`==`表示“引用是否相等”。要判断引用类型的变量内容是否相等，必须使用`equals()`方法。  
```java
String s1 = "hello";
String s2 = "HELLO".toLowerCase();
System.out.println(s1);
System.out.println(s2);
if (s1 == s2) {
    System.out.println("s1 == s2");
} else {
    System.out.println("s1 != s2");
}
```
调用`"HELLO".toLowerCase()`会创建一个新的**字符串对象**，因为在Java中字符串是不可变的，任何对字符串的修改操作都会创建一个新的字符串对象。因此，`"HELLO".toLowerCase()`会在堆内存中创建一个新的字符串对象，该对象存储小写形式的字符串。因此，`String s2 = "HELLO".toLowerCase();`中的`s2`引用的是**堆**内存中新创建的对象，其内存地址与字符串常量池中的地址不同。  
### Obect.equals()
判断两个字符串是否相等在java中,用的是**equals();**  

例;A字符串和B和字符串比较:  

```java
String a="123",b="456";  
if (a.equals(b)) {  
    System.out.println("相等");  
}
```
**equals()**是**Object**的方法,所以对所有对象都适用。**默认**为:  
```java
public boolean equals(Object obj) {  
    return (this == obj);  
}
```
**String.equals()**  
```java
public boolean equals(Object anObject) {  
    if (this == anObject) {  
        return true;  
    }  
    if (anObject instanceof String) {  
        String aString = (String)anObject;  
        if (coder() == aString.coder()) {  
            return isLatin1() ? StringLatin1.equals(value, aString.value) 
                : StringUTF16.equals(value, aString.value);  
        }  
    }  
    return false;  
}
```
**String**类重写**equals**方法时,首先判断如果是自己直接返回**true**,如果不是自己,判断参数是否为**String**类型,不是则返回**false**。之后就是比较字符串内容是否相等了。  

堆和常量池的区别:  

Java的存储空间：寄存器、栈、**堆**、静态存储区、**常量存储区(常量池)**、其他存储位置。  

此处重点介绍堆和常量存储区：  

**堆**：存储**new**的对象;  **常量池**：用来存储**final static**、**String**的常量。  

**Object.equals**与**String.equals**的区别  

**Object.equals(==)**：**比较内存地址;**  

**String.equals: 比较内容,不管内存地址。**  

**Object.equals**相等,**String.equals一定**相等;  

**String.equals**相等,**Object.equals不一定**相等。  

实例  

```java
// 维护在常量池里面  
String a="hello";  
String b="hello";  
// new出来的所有对象都在堆内存中  
// 只要是new出现来的都是新对象  
String c=new String("hello");  
String d=new String("hello");  
// 对比内存地址  
System.out.println("a==b = " + (a == b));  
System.out.println("a==c = " + (a == c));  
System.out.println("c==d = " + (c == d));  
// 对比内容  
System.out.println("a.equals(b) = " + a.equals(b));  
System.out.println("a.equals(c) = " + a.equals(c));  
System.out.println("c.equals(d) = " + c.equals(d));
```
结果:  
```text
a==b = true
a==c = false
c==d = false
a.equals(b) = true
a.equals(c) = true
c.equals(d) = true
```
**a**,**b**都是常量,**a**和**b**都是指向常量存储区中的常量**'hello'**,所以无论内容还是内存地址都是一样的,因此**a==b**以及**a.equals(b)**都是**true**;  

**c,d**都是变量,他们都是**new**出来的对象,里面存在两个**hello**变量,**c**和**d**分别指向自己的**hello**变量,所以**c**和**d**内容一样,但是内存地址不一样,因此**c==d**是**false**,但是**c.equals(d)**为**true**。  

### 常用方法

- `equals(Object obj)`: 比较两个字符串值是否相等。
- `equalsIgnoreCase(String anotherString)`: 比较两个字符串值是否相等，忽略大小写。
- `length()`: 返回字符串的长度。
- `charAt(int index)`: 返回指定索引处的字符。
- `substring(int beginIndex)`: 返回从指定索引开始到字符串末尾的子字符串。
- `substring(int beginIndex, int endIndex)`: 返回从beginIndex开始到endIndex-1的子字符串。
- `indexOf(String str)`: 返回指定子字符串在原字符串中第一次出现的索引。
- `lastIndexOf(String str)`: 返回指定子字符串在原字符串中最后一次出现的索引。
- `contains(CharSequence s)`: 判断是否包含指定的字符序列。
- `startsWith(String prefix)`: 判断字符串是否以指定前缀开头。
- `endsWith(String suffix)`: 判断字符串是否以指定后缀结尾。
- `isEmpty()`: 判断字符串是否为空。
- `isBlank()`: 判断字符串是否只有空白字符。
- `toUpperCase()`: 将字符串转换为大写。
- `toLowerCase()`: 将字符串转换为小写。
- `trim()`: 去除字符串两端的空白字符。
- `strip()`: 去除字符串两端的空白字符，包括中文空格。
- `replace(char oldChar, char newChar)`: 替换字符串中的字符。
- `replace(String old, String new)`: 替换字符串中的old为new。
- `replaceAll(String regex, String new)`: 正则替换。
- `split(String regex)`: 根据给定正则表达式分隔字符串。
- `String.join(CharSequence delimiter, CharSequence... elements)`: 使用指定分隔符delimiter连接多个字符串。
- `String.format(String format, Object... args)`: 使用指定格式化字符串和参数创建格式化字符串。
- `formatted(Object... args)`: 格式化字符串，同上，只是format变成了调用方。。
- `matches(String regex)`: 判断字符串是否匹配指定的正则表达式。
- `String.valueOf(Object o)`:转换为字符串。

### 字符串转其他类型
将**radix**进制的**s**转换为十进制数。`Integer.parseInt(String s[,int radix=10])`  **radix**的范围是在2~36之间,超出范围会**抛异常**，**s**的长度也**不能超出**7,否则也会抛异常。  

要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为`int`类型：  

```java
int n1 = Integer.parseInt("123"); // 123
int n2 = Integer.parseInt("ff", 16); // 按十六进制转换，255
```
把字符串转换为`boolean`类型：  
```java
boolean b1 = Boolean.parseBoolean("true"); // true
boolean b2 = Boolean.parseBoolean("FALSE"); // false
```
要特别注意，`Integer`有个`getInteger(String)`方法，它不是将字符串转换为`int`，而是把该字符串对应的系统变量转换为`Integer`：  
```java
Integer.getInteger("java.version"); // 版本号，11
```
`String`和`char[]`类型可以互相转换，方法是：  
```
char[] cs = "Hello".toCharArray(); // String -> char[]
String s = new String(cs); // char[] -> String
```
如果修改了`char[]`数组，`String`并不会改变。  
```java
char[] cs = "Hello".toCharArray();
String s = new String(cs);
System.out.println(s);
cs[0] = 'X';
System.out.println(s);
```
这是因为通过`new String(char[])`创建新的`String`实例时，它并不会直接引用传入的`char[]`数组，而是会复制一份，所以，修改外部的`char[]`数组不会影响`String`实例内部的`char[]`数组，因为这是两个不同的数组。  

从`String`的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。  

###  字符编码
在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从`0`到`127`，最高位始终为`0`，称为`ASCII`编码。例如，字符`'A'`的编码是`0x41`，字符`'1'`的编码是`0x31`。  

如果要把汉字也纳入计算机编码，很显然一个字节是不够的。`GB2312`标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为`1`，以便和`ASCII`编码区分开。例如，汉字`'中'`的`GB2312`编码是`0xd6d0`。  

类似的，日文有`Shift_JIS`编码，韩文有`EUC-KR`编码，这些编码因为标准不统一，同时使用，就会产生冲突。  

为了统一全球所有语言的编码，全球统一码联盟发布了`Unicode`编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。  

`Unicode`编码需要两个或者更多字节表示，我们可以比较中英文字符在`ASCII`、`GB2312`和`Unicode`的编码：  

英文字符`'A'`的`ASCII`编码和`Unicode`编码：  

```ascii
         ┌────┐
ASCII:   │ 41 │
         └────┘
         ┌────┬────┐
Unicode: │ 00 │ 41 │
         └────┴────┘
```
英文字符的`Unicode`编码就是简单地在前面添加一个`00`字节。  

中文字符`'中'`的`GB2312`编码和`Unicode`编码：  

```ascii
         ┌────┬────┐
GB2312:  │ d6 │ d0 │
         └────┴────┘
         ┌────┬────┐
Unicode: │ 4e │ 2d │
         └────┴────┘
```
那我们经常使用的`UTF-8`又是什么编码呢？因为英文字符的`Unicode`编码高字节总是`00`，包含大量英文的文本会浪费空间，所以，出现了`UTF-8`编码，它是一种变长编码，用来把固定长度的`Unicode`编码变成1～4字节的变长编码。通过`UTF-8`编码，英文字符`'A'`的`UTF-8`编码变为`0x41`，正好和`ASCII`码一致，而中文`'中'`的`UTF-8`编码为3字节`0xe4b8ad`。  

`UTF-8`编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为`UTF-8`编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。  

在Java中，`char`类型实际上就是两个字节的`Unicode`编码。如果我们要手动把字符串转换成其他编码，可以这样做：  

```java
byte[] b1 = "Hello".getBytes(); // 按系统默认编码转换，不推荐
byte[] b2 = "Hello".getBytes("UTF-8"); // 按UTF-8编码转换
byte[] b2 = "Hello".getBytes("GBK"); // 按GBK编码转换
byte[] b3 = "Hello".getBytes(StandardCharsets.UTF_8); // 按UTF-8编码转换
```
注意：转换编码后，就不再是`char`类型，而是`byte`类型表示的数组。  

如果要把已知编码的`byte[]`转换为`String`，可以这样做：  

```java
String s1 = new String(b, "GBK"); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换
```
始终牢记：Java的`String`和`char`在内存中总是以Unicode编码表示。  

对于不同版本的JDK，`String`类在内存中有不同的优化方式。具体来说，早期JDK版本的`String`总是以`char[]`存储，它的定义如下：  

```java
public final class String {
    private final char[] value;
    private final int offset;
    private final int count;
}
```
而较新的JDK版本的`String`则以`byte[]`存储：如果`String`仅包含ASCII字符，则每个`byte`存储一个字符，否则，每两个`byte`存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的`String`通常仅包含ASCII字符：  
```java
public final class String {
    private final byte[] value;
    private final byte coder; // 0 = LATIN1, 1 = UTF16
```
对于使用者来说，`String`内部的优化不影响任何已有代码，因为它的`public`方法签名是不变的。  
### 字符串拼接
**StringBuilder**  
Java编译器对`String`做了特殊处理，使得我们可以直接用`+`拼接字符串。  
```java
String s = "";
for (int i = 0; i < 1000; i++) {
    s = s + "," + i;
}
```
虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。  

为了能高效拼接字符串，Java标准库提供了`StringBuilder`，它是一个可变对象，可以预分配缓冲区，这样，往`StringBuilder`中新增字符时，不会创建新的临时对象。`StringBuilder`还可以进行链式调用。使用append()方法添加字符串，然后使用toString()方法返回拼接后的字符串。  

对于普通的字符串`+`操作，并不需要我们将其改写为`StringBuilder`，因为Java编译器在编译时就自动把多个连续的`+`操作编码为`StringConcatFactory`的操作。在运行期，`StringConcatFactory`会自动把字符串连接操作优化为数组复制或者`StringBuilder`操作。  

`StringBuffer`，是Java早期的一个`StringBuilder`的线程安全版本，它通过同步来保证多个线程操作`StringBuffer`也是安全的，但是同步会带来执行速度的下降。`StringBuilder`和`StringBuffer`接口完全相同，现在完全没有必要使用`StringBuffer`。  

**StringJoiner**  

要高效拼接字符串，应该使用`StringBuilder`。  

很多时候，我们拼接的字符串像这样：  

```java
String[] names = {"Bob", "Alice", "Grace"};
var sb = new StringBuilder();
sb.append("Hello ");
for (String name : names) {
    sb.append(name).append(",");
}
// 注意去掉最后的", ":
sb.delete(sb.length() - 1, sb.length());
sb.append("!");
System.out.println(sb.toString());
```
类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个`StringJoiner`来干这个事，构造方法可以在第二个参数和第三个参数传入开头的结尾：  
```java
String[] names = {"Bob", "Alice", "Grace"};
var sj = new StringJoiner(",", "Hello ", "!");
for (String name : names) {
    sj.add(name);
}
System.out.println(sj.toString());
```
**String.join()**  

`String`还提供了一个静态方法`join()`，这个方法在内部使用了`StringJoiner`来拼接字符串，在不需要指定“开头”和“结尾”的时候，用`String.join()`更方便：  

```java
String[] names = {"Bob", "Alice", "Grace"};
var s = String.join(", ", names);
```
## 数组
定义一个数组类型的变量，使用数组类型`类型[]`，例如，`int[]`。和单个基本类型变量不同，数组变量初始化**必须**使用`new int[5]`表示创建一个可容纳5个`int`元素的数组。  
- 数组所有元素初始化为默认值，整型都是`0`，浮点型是`0.0`，布尔型是`false`；
- 数组一旦创建后，**大小**就**不可改变**。

要访问数组中的某一个元素，需要使用索引。数组索引从`0`开始，例如，5个元素的数组，索引范围是`0`~`4`。  

可以修改数组中的某一个元素，使用赋值语句，例如，`ns[1] = 79;`。  

可以用`数组变量.length`获取数组大小。  

数组是引用类型，在使用索引访问数组元素时，如果**索引超出范围**，运行时将报错。  

可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：  

```java
 int[] ns = new int[] { 68, 79, 91, 85, 62 };
```
**还可以进一步简写为**：  
```java
int[] ns = { 68, 79, 91, 85, 62 };
```
对于**简单数据类型**的数组,当对其进行初始化时,会将对应的值赋给对应的各个数组元素。  

在定义数组的时候,系统会给这个数组分配用于存放这个数组的内存空间：它会在**堆(Heap)**内存空间中给数组分配—个空间用于存放数组变量。  

**引用数据类型**数组在创建的时候也是首先给数组元素分配**內存空间**然后给这些数组元素一个默认的初始值**null.**  

在进行**引用数据类型**数组的初始化的时候,和**简单数据类型**数组的初始化有些**不同**,因为数组**本身是引用类**型,而现在**数组元素也是**引用类型,所以这个时候需要给数组元素**所引用**的对象**也分配**内存空间。  

```java
String[] arr = new String[10];  
arr[0] = new String("one");  
arr[1] = new String("two");  
arr[2] = new String("three");  
arr[3] = new String("Iou");  
arr[4] = new String("five");  
arr[5] = new String("six");  
arr[6] = new String("seven");  
arr[7] = new String("eight");  
arr[8] = new String("nine");  
arr[9] = new String("ten");  
System.out.println(Arrays.toString(arr));
```

------

数组**没有length()**这个方法,**String有length()**这个方法。  
```java
int[] a =new int[8];  
System.out.println(a.length);//8  
String s = "012345678";  
int length = s.length();  
System.out.println(length);//9
```
**s.charAt(n)**  

获取**字符串**的第**n+1**个字符  

```java
String s="hello world";  
System.out.println(s.charAt(0));//h
```
**import java.util.Arrays;**  

**Arrays.toString(arr)**  
格式化的将数组内容转为字符串  

```java
int[] b ={1,2,3,4,5};  
System.out.println(Arrays.toString(b));//[1, 2, 3, 4, 5]
```
**Arrays.sort(arr)**  

对数组进行**升序**排序  

```java
int[] a = {12, 3, 19, 2, 10, 13};  
System.out.println("before sort:");  
for (int value : a) System.out.print(value + " ");  
System.out.println();  
Arrays.sort(a);  
System.out.println("after sort:");  
for (int value : a) System.out.print(value + " ");
```
输出:  
```text
before sort:
12 3 19 2 10 13
after sort:
2 3 10 12 13 19
```
数组可直接相互**热拷贝**(a,b**相同指向**)  
```java
int[] a={1,2,3},b=a;  
System.out.println(Arrays.toString(a));//[1, 2, 3]  
a[0]=9;  
System.out.println(Arrays.toString(b));//[9, 2, 3]
```
冷拷贝  

**System.arraycopy(src, srcPos, dest, destPos, length)**  

从**src**\[**srcPos**\]开始复制**length**个元素到**dest**\[**destPos**\]的对应位置上.  

| 参数    | 说明                     |
| ------- | ------------------------ |
| src     | 源数组。                 |
| srcPos  | 源数组中的起始位置。     |
| dest    | 目标数组。               |
| destPos | 目标数据中的起始位置。   |
| ength   | 要复制的数组元素的数量。 |

```java
int[] a ={1,2,3,4,5,6,7,8,9,10};  
int[] b ={100,200,300,400,500,600,700,800,900,100};  
System.arraycopy(a,2,b,5,5);  
System.out.println("b = " + Arrays.toString(b));//b = [100, 200, 300, 400, 500, 3, 4, 5, 6, 7]
```
完整复制:  
```java
int[] a ={12, 3, 19, 2, 10, 13},b=new int[a.length];  
System.arraycopy(a,0,b,0,a.length);  
System.out.println(Arrays.toString(b));//[12, 3, 19, 2, 10, 13]
```
## 多维数组
当使用**new**来创建多维数组时,不必指定每一维的大小而**只需要**指定**最左边**的维的大小就可以了。如果你指定了其中的某一维的大小,那么所有处于这一维**左边**的各维的大小**都要**指定。  

动态初始化  

```java
int[][][] a = new int[2][2][4];  
int[][] ab = new int[2][];
```
静态初始化  
```java
double[][][] a2 = {  
    {
        {1.1, 2.2}, {3.3, 4.4}
    },{
        {5.5, 6.6}, {7.7, 8.8}
    },{
        {9.9, 1.2}, {2.3, 3.4}
    },  
};  
System.out.println(Arrays.deepToString(a2));
```
多维数组也可以通过数组声明和初始化分开的动态初始化方法来对数组进行初始化  
```java
double[][][] a2 = new double[2][3][4];
```
java中多维数组的声明和初始化应按从高维到低维的顺序进行  
```java
int[][] a = new int[3][];  
a[0] = new int[2];  
a[1] = new int[4];  
a[2] = new int[3];
```
获取某维长度例子:  
```java
int[][] x = {
    {1, 2}, {3, 4, 5}, {6}, {}
};  
System.out.println(x[1].length);//3  
System.out.println(x.length);//4
```
`Arrays.deepToString()`可以输出多维数组  
## 流程控制
`switch`语句根据`switch (表达式)`计算的结果，跳转到匹配的`case`结果，然后继续执行后续语句，直到遇到`break`结束执行。字符串匹配时，是比较“内容相等”。  
```java
switch (option) {
    case 3:
        ...
            break;
    case 2:
        ...
            break;
    case 1:
        ...
            break;
    default:
        ...
}
```
使用`switch`时，注意`case`语句并没有花括号`{}`，而且，`case`语句具有“穿透性”，漏写`break`将导致意想不到的结果。  

从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且**不需要**`break`语句，还可以直接返回值。  

如果有多条语句，需要用`{}`括起来，若这时需要返回值则需要用`yield`。还可以使用多个匹配项，用逗号分隔：  

```java
String fruit = "pear";
int opt = switch (fruit) {
    case "apple" -> 1;
    case "pear", "mango" -> {
        System.out.println("pear or mango");
        yield 2;
    }
    default -> 0;
};// 注意赋值语句要以;结束
System.out.println("opt = " + opt);
```

------

使用`for`循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。`break`结束整个循环`continue`结束本次循环，整个循环继续执行。  

使用label跳出多重循环（尽量不要使用）。  

```java
OUTER:  
//outer label  
for (int i = 0; i < 4; i++) {  
    INNER:  
    //inter label  
    for (int j = 0; j < 4; j++) {  
        System.out.print("轮次: " + (i*4+j+1));  
        if (i == 1) {  
            System.out.println(" 未执行完");  
            break INNER;//跳出内层for(),执行下一轮  
        }  
        System.out.println(" 完整执行");  
    }  
}
```
结果:  
```text
轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
轮次: 9 完整执行
轮次: 10 完整执行
轮次: 11 完整执行
轮次: 12 完整执行
轮次: 13 完整执行
轮次: 14 完整执行
轮次: 15 完整执行
轮次: 16 完整执行
```
```java
OUTER:  
//outer label  
for (int i = 0; i < 4; i++) {  
    INNER:  
    //inter label  
    for (int j = 0; j < 4; j++) {  
        System.out.print("轮次: " + (i*4+j+1));  
        if (i == 1) {  
            System.out.println(" 未执行完");  
            break OUTER;//跳出外层for(),执行下一个语句  
        }  
        System.out.println(" 完整执行");  
    }  
}
```
结果:  
```text
轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
```
## java关键字表

| abstract     | assert     | boolean | break     | byte      | continue   |
|--------------|------------|---------|-----------|-----------|------------|
| case         | catch      | char    | class     | const     | double     |
| default      | do         | else    | enum      | extends   | final      |
| finally      | float      | for     | goto      | if        | implements |
| import       | instanceof | int     | interface | long      | native     |
| new          | null       | package | private   | protected | public     |
| return       | short      | static  | strictfp  | super     | switch     |
| synchronized | this       | throw   | throws    | transient | try        |
| void         | volatile   | while   |           |           |            |

**volatile** 关键字用于标记字段可能会被多个线程同时访问，告诉编译器不要对这个字段进行优化，因为它的值可能会在其他线程中更改。这可以确保每次读取字段时都从内存中读取最新的值，而不是使用缓存中的旧值。  

**transient** 关键字用于告诉编译器在序列化时忽略字段。当对象被序列化时，**transient** 修饰的字段的值不会被保存。  

**native**本地方法，由本地其他语言代码实现  

**synchronized** 关键字用于实现线程同步，确保多个线程在访问共享资源时不会发生冲突。当一个线程访问一个对象的 **synchronized** 方法或代码块时，其他线程必须等待，直到该线程执行完成释放锁。  

**java.lang.Runnable**多线程接口。  

`java.lang.Runnable`是一个接口，用于表示可以由线程执行的任务。它只包含一个方法`run()`，该方法定义了线程要执行的代码。通过实现`Runnable`接口并重写`run()`方法，可以创建一个可运行的任务，然后将其传递给`Thread`类的构造函数，从而创建一个线程并启动它。  

```java
public interface Runnable {
    public abstract void run();
}
```
`run()`方法中包含了线程的执行逻辑，当线程启动时，会调用`run()`方法来执行任务。实现`Runnable`接口的类可以实现自己的逻辑，例如：  
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Hello, I am a runnable task.");
    }
}
public class Main {
    public static void main(String[] args) {
        Runnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start();
    }
}
```
在上面的例子中，`MyRunnable`实现了`Runnable`接口，并在`run()`方法中定义了要执行的任务。然后，创建一个`Thread`对象，并将`MyRunnable`实例传递给`Thread`的构造函数，最后调用`start()`方法启动线程，线程会执行`MyRunnable`中的`run()`方法。  
# 面向对象基础
## 包
当一个大型程序交由数个不同的程序人员开发时,用到相同的类名是很有可能的, Java程序开发中为了避免这种情况,提供了一个包的概念(**package**) 。  

同一个包内的类名**不允许重复**,不同包内**可以有**相同名称的类。包允许将类组合成较小的单元,类似于文件夹;在包与包之间对于类的访问权限能提供更有力的约束。  

使用包很简单,通过关键字**package** 声明,作为Java源文件的**第一条语句**,指明该源文件定义的类所在的包。**package**语句一般格式为:  

**package packageName;**  

包名可以是一个合法的标识符,也可以是若干个标识符加"**.**"号分割而成,点号就是文件夹的分隔.  

```java
package tom;  
package sun.com.cn;  
```
注意只能有一个包声明，以上只为格式例子。  

如果省略了**package**语句,类将保存在一个缺省的没有名称的包中;尽管缺省包很方便,但对于大型的程序,它是不恰当的;请尽量为自己编写的类定义具体的包。  

在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。  

包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。  

**import**  

在一个`class`中，我们总会引用其他的`class`，如果要使用ArrayList，可以使用完整类名：  

```java
java.util.List<String> list = new java.util.ArrayList<>();
```
很显然，每次写完整类名比较痛苦。那么还可以使用**import**语句。  

使用**import**语句可以引入包中的类。Java源文件中**可以**有**多个import**语句,它们在程序中的位置是有要求的,**必须**写在**package**语句和**源文件**的类定义**之间**。  

要引入`java.util`包中的`Date`类,使用：  

```java
import java.util.Date;
```
如果要引入一个包中的全部类,则可以用星号来代替,如:**import java.awt.\*;**  

还有一种`import static`的语法，它可以导入一个类的静态字段和静态方法：  

```java
package com.aotmd;
// 导入System类的所有静态字段和静态方法:
import static java.lang.System.*;
public class Main {
    public static void main(String[] args) {
        // 相当于调用System.out.println(…)
        out.println("Hello, world!");
    }
}
```
`import static`很少使用。  

Java编译器最终编译出的`.class`文件只使用*完整类名*，因此，在代码中，当编译器遇到一个`class`名称时：  

- 如果是完整类名，就直接根据完整类名查找这个`class`；
- 如果是简单类名，按下面的顺序依次查找：
  - 查找当前`package`是否存在这个`class`；
  - 查找`import`的包是否包含这个`class`；
  - 查找`java.lang`包是否包含这个`class`。

如果按照上面的规则还无法确定类名，则编译报错。  

因此，编写class的时候，编译器会自动帮我们做两个import动作：  

- 默认自动`import`当前`package`的其他`class`；
- 默认自动`import java.lang.*`。注意：自动导入的是`java.lang`包，但类似`java.lang.reflect`这些包仍需要手动导入。

如果有两个`class`名称相同，例如，`mr.jun.Arrays`和`java.util.Arrays`，那么只能`import`其中一个，另一个必须写完整类名。  
## 类
类是一个独立的单位,它有一个类名,其内部包括成员变量,用于描述属性;还包括类的成员方法,用于描述行为。因此,类也被认为是种抽象数据类型,这种数据类型不但包括数据,还包括方法。  

包含**main**方法的主类必須定义为**public**。  

在一个.java中可以有**多个**类,但只能有一个类为**public**修饰符,且该类的名称必须与文件名称相同.  

**class**为Java定义类的关键字,必须写在**修饰符**和**类名**中间,使用空格隔开.  

类的名字要符合Java的命名规范,同时名字要有意义能够反映出这个类的内容,**第一个字母一般为大写**.  

定义类的最终目的是要使用这些类,**创建**并操作某类的对象是使用该类的最主要手段。  

**创建类的实例对象**  

**类名对象名=new类名(\[参数1,参数2…\]);**  

例：  

```java
NoteTest t=new NoteTest();
```
通过运算符“**.**”,对象可以实现对**自己变量**的访问及对**自己方法**的调用。  

------

### 构造方法  
构造方法是让编程人员在编写代码的时候可以更方便,少写点代码,还可以在构造方法里面加入一些初始化代码.  

**构造方法**是类中的一种特殊方法,是为对象**初始化**操作编写的方法,用它来定义对象的初始状态。每个类都有**构造方法**,它也是由**方法名**、**参数**和**方法体**组成。构造**方法名必须**与**类名相同**,它**没有返回值类型**,用户**不能直接调用**它,**只能**通过**new**对象实例化时由虚拟机**自动调用**.  

因为是由虚拟机来调用构造方法,所以构造方法一般应定义成 **public**  

**每个**对象在生成时都**必须**执行构造方法,而且只能执行一次;如果构造方法调用失败,那么对象也无法创建;  

在没有定义构造方法的情况下,类会**自动**产生一个无参数的默认构造方法,这个默认的构造方法什么都不做;一旦**显式**地定义了构造方法,默认的无参构造方法自动消失,若此时还需要无参构造方法,则需要显示地重新定义。  

一个类可以有多个**构造方法**,**构造方法可以被重载**  

```java
class User {  
    public String uid,username,password;  
    public User() {}  
    public User(String uid, String username, String password) {  
        this.uid = uid;  
        this.username = username;  
        this.password = password;  
    }  
}
```
### this
**this**就是指代当前对象 ,**this可以**出现在**实例方法**和**构造方法**中,但**不可以**出现在**类方法**中。  

当**局部变量**和**成员变量**的名字**相同**时,成员变量就会被隐藏,这时如果想在成员方法中使用成员变量,就必须便用关键字**this**.  

语法：  

> **this.成员变量名**  
>
> **this.成员方法名()**  
>
> **this()**  

通过**this()**可以调用自己的其他**构造方法**.  

在使用**this**调用构造方法的时候有以下规范:  

所有的**构造方法**是在对象实例化的时候被默认调用而且是在调用普通方法**之前**调用,所以使用"**this()**”**调用构造方法**的操作,一定要放在构造方法的**首行**,首行指第一条语句,且在一个构造方法里**只能调用一个**;  

如果一个类之中存在多个构造方法,且这些构造方法都使用了**this()**互相调用,那么至少要保留一个构造方法没有调用其他构造方法,以作为程序的出口。(不能陷入死循环)  

**this不能**用在**static**方法中！(java中类的方法池中都有一个隐含的参数**this**,他表示本对象的引用但是**static**方法是没有这个隐含参数的,因为**static**方法和类的实例无关它只在类装载的时候初始化,很多书都把静态变量称作类级变量)  

### 类的封装
在设计一个类时,应该对成员变量的访问作出一些**限定**,不允许外界随意访问.这就需要实现类的封装。  

所谓类的封装是指在定义一个类时,将类中的属性**私有化**,即使用 **private**关键字来修饰,私有属性只能在它所在**类中**被访问,如果外界想要访问私有属性,需要使用**公有**方法进行间接调用,其中包括用于获取属性值的 getXxx方法和设置属性值的 setXxx方法。  

| 访问修饰符 | 本类 | 同包子类 | 同包非子类 | 不同包子类 | 不同包且非子类 |
|------------|------|----------|------------|------------|----------------|
| private    | 是   | 否       | 否         | 否         | 否             |
| 默认       | 是   | 是       | 是         | 否         | 否             |
| protected  | 是   | 是       | 是         | 是         | 否             |
| public     | 是   | 是       | 是         | 是         | 是             |

### tostring()
**public String toString()**返回该对象的字符串表示。通常,**ToString**方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。  

```java
public class Test{  
    private int a,b;  
    public Test(int a, int b) { this.a = a;this.b = b; }  
    public static void main(String[] args) {  
        System.out.println(new Test(1,2));//默认调用toString()  
    }  
    @Override  
    public String toString() {  
        return "Test{a=" + a + ", b=" + b + '}';  
    }  
}
```
### 实例方法，类方法  
实例方法就是对象方法,和类方法的区别是,类方法有**static**关键字,**不需要实例**,**直接类名调用**，类属性也是如此。  
```java
public class NoteTest {  
    public static int a=1;//类属性  
    public int b=2;//实例属性  
    public void f1(){};//实例方法  
    public static void f2() {}//类方法  
    public static void main(String args[]){//类方法  
        NoteTest noteTest=new NoteTest();  
        System.out.println(noteTest.b);  
        noteTest.f1();  
        System.out.println(NoteTest.a);  
        NoteTest.f2();  
    }  
}
```
类方法，类属性也可以通过实例调用，但这没有意义。这通常是不推荐的做法，因为类方法和类属性是与类相关联的，而不是与实例相关联的。正确的做法是通过类名直接调用类方法和访问类属性。通过实例调用类方法和类属性可能会造成混淆，不利于代码的清晰性和维护性。  

在代码中，实例对象能访问类字段只是因为编译器可以根据实例类型自动转换为`类名.静态字段`来访问静态对象。对于类方法也是如此。  

静态方法（类方法）属于类而不属于实例，因此，静态方法内部，无法访问`this`变量，也无法访问实例字段，它只能访问静态字段（类字段/类属性）。  

## 方法
**方法**是完成特定功能的、相对独立的程序段。**方法**一旦定义,就可以在不同的程序段中多次调用,故方法可以增强程序结构的清晰度,提高编程效率。在Java程序中,**方法只能在类**中声明,格式如下:  

> **\[修饰符\] 返回值类型 方法名 \[(参数表)\]{**  
>
> **声明部分**  
>
> **语句部分**  
>
> **}**  

方法声明包括方法头和方法体2部分  

1. 修饰符可以是公共访问控制符**public**、私有访冋控制符**private**、保护访问控制符 **protected**等。  
2. 类型标识符反映方法完成其功能后返回的运算结果的数据类型。如果方法**没有返回值**,用**void**关键字指明。  
3. 方法名要符合标识符的命名规则,不要与Java中的关键字**重名**。  
4. 参数表指定在**调用**该方法时,应该传递的参数的个数和数据类型。  
5. 对于**有返回值**的方法,其方法体中至少有一条`return`语句。
6. 对于**没有返回值**的方法，可以用`return;`终止执行方法。
7. 方法声明**不能嵌套**,即不能在方法中再声明其它的方法。  

对于有返回值的方法作为表达式或表达式的一部分来调用,其在表达式中出现的形式为：  

**方法名(\[实际参数表\])**  

```java
public class NoteTest {  
    static int act(){  
        return 1;  
    }  
    public static void main(String[] args) {  
        System.out.println("act() = " + act());  
    }  
}
```
在调用一个带有**形式参数**的方法时,必须为方法提供**实际参数**,完成实际参数与形式参数的结合,称为参数传递,然后用实际参数执行所调用的方法体。**在Java中**,参数传递是以**传值**的方式进行,即**将实际参数的值传递给形式参数.**同构造方法一样，普通方法也可以进行重载。  
### 可变参数
可变参数用`类型...`定义，可变参数相当于数组类型。Java中的可变参数（varargs）实际上是一种**语法糖**，编译器会将传递给可变参数的参数**封装成一个数组**，因此可以像处理数组一样处理这些参数。这种语法糖使得方法的调用更加简洁，不再需要手动创建数组来传递参数。  

如果对带有可变参数的方法传入`null`，编译器会不知道怎么处理，编译器无法确定应该创建一个空数组还是一个包含一个`null`元素的数组。这种情况下，编译器会产生一个警告（warning），提示可能会有`NullPointerException`的风险。因此，在使用可变参数时，应该**避免**传入`null`。  

### 递归程序

```java
public class NoteTest {  
    static int test(int n){  
        if (n==1) return 1;  
        return test(n-1)*n;  
    }  
    public static void main(String[] args) {  
        System.out.println("5! = " + test(5));//5! = 120  
    }  
}
```
## 继承
最高层是**最普遍**的、**最一般**的情况,往下每一层都比上一层**更具体**,并包含有高层的特征,通过这样的层次结构使下层的类能自动享用上层类的特点和性质;  

继承其实就是自动地共享被继承类中成员属性和成员方法的机制。  

继承是利用现有的类创建新类的过程,现有的类称作基类(或父类),创建的新类称作派生类(子类)  

在Java中实现继承需要使用到**extends**关键字;  



> **\[访问修饰符\] class 派生类名 extends 基类名{**  
>
> **成员列表**  
>
> **}**  

如:  
```java
class Student extends User{}
```
在Java中，每个类都具有父类。如果一个类没有声明父类，则默认情况下会继承`java.lang.Object`。  
**严禁定义与父类重名的字段**  
在Java中，严禁定义与父类重名的字段是为了避免可能引起的混淆和语义歧义。具体来说，这样的限制主要是为了维护良好的代码可读性和可维护性，避免潜在的错误和困惑。当子类定义了与父类同名的字段时，可能会导致以下问题：  
1. 语义歧义：同名字段可能具有不同的含义，这会使代码的意图变得模糊，增加理解和维护的难度。
2. 可见性问题：如果子类定义了与父类同名的字段，可能会掩盖父类的字段，导致无法访问父类的字段，从而造成错误或者逻辑混乱。
3. 潜在的错误：当同名字段在父类和子类中同时存在时，应用继承关系的代码可能会对同名字段产生矛盾的假设，从而引发潜在的错误。

为了避免上述问题，Java语言规范明确禁止在子类中定义与父类同名的字段。如果子类需要引用父类的字段，应该通过**super**关键字或者在父类中提供合适的访问方法。  
总之，严禁定义与父类重名的字段是为了保证代码的清晰性、可读性和可维护性，以及避免可能引起的混淆和错误。  
### 继承的作用  
- 引入继承,实现了代码重用;  
- 引入继承,实现了递增式的程序设计。  
- 继承是能自动传播代码和重用代码的有力工具;  
- 继承能够在某些比较一般的类的基础上建造、建立和扩充新类;  
- 能减少代码和数据的重复冗余度,并通过增强一致性来减少模块间的接口和界面,从而增强了程序的可维护性。  
- 能清晰地体现出类与类之间的层次结构关系。  

### 继承的限制  
一个子类只能够继承一个父类,存在**单继承**局限，子类不会继承任何父类的构造方法。  
子类可以获得**除private**权限**以外**的所有父类属性,但是：  
在创建子类的对象时**默认**先执行调用父类的无参构造方法，然后再执行子类自己的**构造方法**。要取消这个默认行为，子类可以在自己的**构造方法**中使用**super**关键字来调用父类的**含参数构造方法**,但这个调用语句**必须**是子类构造方法的**第一个**可执行语句。  
若不显示的进行**super**,则会自动调用**super()**;若此时父类没有**无参构造函数**则会出错.  
```java
class Father {  
    public Father(int a) {  
        System.out.println("父类带参构造函数");  
    }  
}  
class Son extends Father {  
    public Son() {  
        super(1);//必须  
        System.out.println("子类无参构造函数");  
    }  
}
```
### super  
- 在**子类的构造方法**中,**super**关键字可以**显式**地调用父类的构造方法,用于将参数传递给它;需要注意的是：**该语句必须是子类构造方法的第一条语句。**  其一般语法是：  `super(实际参数);`  
- 如果父类和子类中有**同名成员**,在子类中默认访问是属于自己的那一个成员;  **super**可以访问父类的**变量**或**方法**，值得注意的是，`super`关键字访问的是父类中已经实例化的成员，而**不会影响**到子类中的同名成员。 

**super**关键字可以明确地指定要访问父类中的成员;前提条件是：父类中的该成员**不是private**的。  这种用法中**不需要**像**构造方法**中一样需要限定为第一条语句.  

其一般语法是：  

> **super.成员名;**  
>
> **super.方法名();**  

```java
class User {  
    public String uid;  
    public User(String uid) {  
        this.uid = uid;  
    }  
    @Override  
    public String toString() {  
        return "User{uid='" + uid + '\\' + '}';  
    }  
}  
class Student extends User{  
    public String username;  
    public Student(String uid,String username) {  
        super(uid);//必须,否则自动调用super(),然后报错  
        this.username=username;  
    }  
    @Override  
    public String toString() {  
        String s="";  
        s=super.toString()+"\nStudent{uid='" + uid + '\\' + ", username='" + username + '\\' + '}';;  
        return s;  
    }  
    public static void main(String[] args) {  
        System.out.println(new Student("1", "张三"));  
    }  
}
```
### final  
**final**修饰符可以修饰类、成员变量和方法。  
- 对于类，**final**表示该类不能被继承，即它是一个最终类，不能有子类。
- 对于方法，**final**表示该方法不能被子类重写，即它是一个最终方法。
- 对于变量，**final**表示只能被赋值一次，这意味着一旦被赋值后，就不能再改变它的值。 

当编译器确定一个**方法**是**final**的时候，它会使用内联（inline）机制，将方法调用直接替换为方法体的内容，这样可以避免方法调用的开销，提高执行效率。这种优化是可能的，因为**final**方法是不能被子类重写的，所以在编译时就可以确定调用的是哪个方法。  
### 阻止继承  
正常情况下，只要某个class没有`final`修饰符，那么任何类都可以从该class继承。  

从**Java 15**开始，允许使用`sealed`修饰class，并通过`permits`明确写出能够从该class继承的子类名称。例如，定义一个`Shape`类：  

```java
public sealed class Shape permits Rect, Circle, Triangle {}
```
上述`Shape`类就是一个`sealed`类，它只允许指定的3个类继承它。这种`sealed`类主要用于一些框架，防止继承被滥用。  
### 构造代码块/初始化块、静态代码块  
构造代码块和静态代码块的作用是在对象创建和类加载时执行特定的初始化操作，可以用来进行一些必要的预处理或初始化工作。  

构造代码块：  

- 构造代码块用于在**创建对象时**执行初始化操作。
- 构造代码块没有任何修饰符（如 public、private、protected）。
- **每次**创建对象时，构造代码块都会被执行，且**优先于**构造方法执行。
- 构造代码块中的代码实际上会被自动插入到每个构造方法的**最前面**。

静态代码块：  
- 静态代码块用于在**类被加载时**执行初始化操作，**仅执行一次**。
- 静态代码块使用 `static` 关键字修饰。
- 静态代码块在类加载时自动执行，且优先于构造代码块和构造方法执行。

```java
class HelloA {
    public HelloA() {
        System.out.println("helloA");
    }
    {
        System.out.println("AAA");
    }
    static {
        System.out.println("AAA static");
    }
}
class HelloB extends HelloA {
    public HelloB() {
        System.out.println("Hellob");
    }
    {
        System.out.println("BBB");
    }
    static {
        System.out.println("BBB static");
    }
    public static void main(String[] args) {
        new HelloB();
    }
}
```
父类静态代码块->子类静态代码块->父类构造代码块->父类构造方法->子类构造代码块->子类构造方法  

在Java中，类的初始化过程如下：  

1. 加载：查找并加载类的字节码文件，创建一个 `Class` 对象。
2. 连接：
   - 验证：确保字节码文件的正确性。
   - 准备：为类的静态变量分配内存，并设置默认初始值。
   - 解析：将符号引用转换为直接引用。
3. 初始化：
   - 执行类的静态代码块和静态字段的赋值操作。
   - 如果有父类，先初始化父类。

在实例化对象时，会先初始化类。初始化类的过程包括执行静态代码块和静态字段的赋值操作。然后执行构造方法。  

`HelloA`和`HelloB`都有静态代码块和构造代码块，按照上面的顺序执行会是这样的：  

1. 加载`HelloA`类和`HelloB`类。
2. 连接：
   - 验证、准备、解析。
3. 初始化`HelloA`类：
   - 执行`HelloA`类的静态代码块和静态字段的赋值操作。
4. 初始化`HelloB`类：
   - 执行`HelloB`类的静态代码块和静态字段的赋值操作。
5. 创建`HelloB`对象：
   - 执行`HelloA`的构造代码块和构造方法。
   - 执行`HelloB`的构造代码块和构造方法。

因此，最终的输出顺序是：  
```text
AAA static
BBB static
AAA
helloA
BBB
Hellob
```
## 多态
多态是面向对象的最后一个主要特征,它本身主要分为两个方面：  

方法的多态性：**重载**与**覆写**  

- **重载**：同一个方法名称,根据不同的参数类型及个数可以完成不同的功能;  
- **覆写**：同一个方法,根据操作的子类不同,所完成的功能也不同。  

对象的多态性：父子类对象的转换。  
- **向上转型**：子类对象变为父类对象,格式：**父类 父类对象=子类实例**,自动;  
- **向下转型**：父类对象变为子类对象,格式：**子类 子类对象=(子类)父类实例**,强制;  

**向上转型、向下转型**  

向上转型是将子类的实例赋值给父类的引用变量，通过父类引用来访问子类对象。子类在向上转型为父类后，只能使用父类中定义过的方法和属性，而无法直接使用子类特有的方法和属性。  

在向上转型后，如果需要重新使用子类特有的方法和属性，需要进行向下转型。向下转型是将父类的引用变量重新指向子类对象，并将其类型更改为子类类型，可以使用子类特有的方法和属性。  

在向下转型的时候，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。因此，向下转型很可能会失败。失败的时候，Java虚拟机会报`ClassCastException`。  

向上转型是编译时的概念，因为编译器只会检查类型是否匹配。在运行时，Java会自动调用实际对象的方法，即实现了向上转型的多态特性。  

为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型。`instanceof`实际上判断一个变量所指向的实例是否是**指定类型**，或者这个类型的**子类**。如果一个引用变量为`null`，那么对任何`instanceof`的判断都为`false`。  

从**Java 14**开始，判断`instanceof`后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：  

```java
Object obj = "hello";
if (obj instanceof String) {
    String s = (String) obj;
    System.out.println(s.toUpperCase());
}
```
可以改写如下：  
```java
Object obj = "hello";
if (obj instanceof String s) {
    // 可以直接使用变量s:
    System.out.println(s.toUpperCase());
}
```
这种使用`instanceof`的写法更加简洁。  

**方法覆盖（重写/覆写）**  

在类的继承体系结构中,如果子类中出现了与父类中**相同**原型的方法,那么认为子类中的方法**覆盖**了父类中的方法(也称为方法重写);通过**子类**的实例调用被覆盖的方法时,将**总是调用子类中的方法**,而父类中的方法将被**隐藏**。这是因为在运行时，Java 虚拟机会动态地确定对象的实际类型，并调用该实际类型中的方法。这种行为称为动态方法调度（Dynamic Method Dispatch）。 加上`@Override`可以让编译器帮助检查是否进行了**正确的覆盖** 。  

```java
package com.aotmd.test;  
public class NoteTest {//用于容纳main方法  
    public static void main(String[] args){  
        ParentClass parobj=new ParentClass();  
        parobj.fun();//父类的实例调用此方法  
        ChildClass chiobj=new ChildClass();  
        chiobj.fun();//子类的实例调用此方法  
    }  
}  
class ParentClass{//定义父类  
    public void fun(){  
        System.out.println("这是父类中的方法。");  
    }  
}  
class ChildClass extends ParentClass {//子类继承于父类  
    public void fun(){//子类覆盖父类中的方法  
        System.out.println("这是子类中的方法。");  
    }  
}
```
**区分方法覆盖和方法重载**  

方法覆盖(重写)和方法重载是两个极易混淆的概念,必须严格区分;  

方法覆盖出现的前提条件之一是**必须有继承**发生的情况下,而且要求父类和子类中的方法**必须同原型**;  

方法重载时,继承并不是必需的,它**只要求方法名称相同**,而参数列表则**必须不同**,换言之,各方法的**原型**其实是**不同**的。  

父类的引用指向哪个类的实例就调用哪个类中的方法;同样是使用父类的引用,调用同一个名称的方法,却可以得到不同的调用结果，这就是多态。即：同一方法,多种形态;实际上多态包括**动态多态**和**静态多态**。  

- 静态多态也称为编译时多态,即在编译时决定调用哪个方法;  静态多态一般是指**方法重载**;  只要构成了方法重载,就可以认为形成了静态多态的条件; 静态多态与是否发生继承没有必然联系。  
- 动态多态也称为运行时多态,即在运行时才能确定调用哪个方法;形成动态多态**必须要有继承**的情况存在;在继承中必须要有**方法覆盖**;必须由基类的引用指向派生类的实例,并且通过基类的引用调用被覆盖的方法;  

方法签名指的是一个方法的名称、参数列表以及参数类型的组合。它用于区分相同名称但参数不同的方法，是方法重载的重要依据。方法签名包括方法名、参数类型和参数数目，不包括方法的返回值类型。例如，以下是一个方法的签名：  `public void printArray(int[] arr)` ，方法名为`printArray`，参数类型为`int[]`，参数数目为`1`，没有返回值类型。  
实例  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        Person p=new Person("小张", 18);  
        System.out.println(p.getPerson());  
        p=new Student("小李", 20,"中国工学院","一年级");  
        System.out.println(p.getPerson());  
        p=new GraduateStudent("小花", 22,"中国工学院","一年级","李");  
        System.out.println(p.getPerson());  
    }  
}  
class Person{  
    protected String name;  
    protected int age;  
    public Person(String name, int age) {  
        super();  
        this.name = name;  
        this.age = age;  
    }  
    public String getPerson(){  
        return "姓名:"+name+" 年龄:"+age;  
    }  
}  
class Student extends Person{  
    protected String school;  
    protected String grade;  
    public Student(String name, int age, String school, String grade) {  
        super(name, age);  
        this.school = school;  
        this.grade = grade;  
    }  
    public String getPerson() {  
        return super.getPerson()+" 学校:"+school+" 班级:"+age;  
    }  
}  
class GraduateStudent extends Student{  
    protected String mentor;  
    public GraduateStudent(String name, int age, String school, String grade, String mentor) {  
        super(name, age, school, grade);  
        this.mentor = mentor;  
    }  
    public String getPerson() {  
        return super.getPerson()+" 导师:"+mentor;  
    }  
}
```
输出:  
```text
姓名:小张 年龄:18
姓名:小李 年龄:20 学校:中国工学院 班级:20
姓名:小花 年龄:22 学校:中国工学院 班级:22 导师:李
```
## 抽象类
如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：  
```java
class Person {
    public abstract void run();
}
```
把一个方法声明为`abstract`，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，`Person`类也无法被实例化。**必须**把`Person`类本身也声明为`abstract`，才能正确编译它：  
```java
abstract class Person {
    public abstract void run();
}
```
抽象类不能被实例化，但抽象类中可以定义非抽象方法，用以为子类提供默认的实现。  

子类继承抽象类后，如果不是抽象类，则必须实现抽象类中的所有抽象方法，否则子类也必须定义为抽象类。因此，抽象方法实际上相当于定义了“规范”，让子类实现自己的逻辑，从而实现多态性。  

**使用抽象类数组（new I[]并不是实例化，而是数组特定写法）**：  

```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        Abst[] absts=new Abst[]{new A(),new A()};
    }
}
abstract class Abst{ }
class A extends Abst{}
```
实际上就是（参见[数组简写](#数组)）：  
```java
A a1=new A();
A a2=new A();
Abst[] absts={a1,a2};
```
## 接口
接口关键字:**interface**  

如果某个类中的所有方法**都是**抽象方法,那么可以考虑将该类定义为接口;  

Java中的接口是一个特殊的抽象类,可以利用接口实现多态,同时接口也弥补了Java单一继承的弱点。一般便用接口声明**方法或常量**,接口中的方法**只能**是声明,**不能是具体的实现**。  

接口就是某个事物对外提供的一些功能的**申明**  

语法格式如下:  

> **\[修饰符\] interface 接口名\[extends父接口名列表\]{**  
>
> **\[public\] \[static\] \[final\]常量;**  
>
> **\[public\] \[abstract\]方法;**  
>
> **}**  


| 名词                    | 解释                                                |
| ----------------------- | --------------------------------------------------- |
| 修饰符                  | 可选,指定接口的访问权限,可选值为**public**。        |
| 接口名                  | 必选,用于指定接口的名称,一般情况下,要求首字母大写。 |
| **extends**父接口名列表 | 可选,用于继承哪些接口，可继承多个。                 |
| 方法                    | 接口中的方法**只有定义**而没有被实现。              |

接口定义的所有方法默认都是`public abstract`的，而所有变量也都是`public static final`的。  

与抽象类相似,接口同样**不可以**实例化,只能用于实现;如果某类要**实现接口**,则使用**implements**关键字.  **\[访问权限\]class类名implements接口名{ 成员列表｝**  

```java
public class MyClass implements IMyInterface {}
```
一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`，如果有一个以上接口被实现,则用**逗号**隔开接口名称,如下所示;  
```java
class demo implements myinterface,myconstants{}
```
接口调用  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        ICalc ICalc4 =new Calc();  
        System.out.println(ICalc4.add(1,2));  
    }  
}  
interface ICalc {  
    int add(int x, int y);  
    int sub(int x, int y);  
}  
class Calc implements ICalc {  
    public int add(int x, int y) { return x+y; }  
    public int sub(int x, int y) { return x-y; }  
}
```
------

**default**  

`default`方法是**Java 8**引入的接口新特性之一，它允许在接口中定义具有默认实现的方法。在接口中使用`default`关键字修饰的方法可以在接口中**直接实现**，而不需要实现类去实现这个方法。这样的好处是可以向现有的接口添加新的方法，而不会影响到已有的实现类，因为它们可以选择性地覆盖默认实现。  

```java
interface Animal {
    void eat();
    default void sleep() {
        System.out.println("Animal sleeps");
    }
}
class Dog implements Animal {
    public void eat() {
        System.out.println("Dog eats");
    }
}
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Output: Dog eats
        dog.sleep(); // Output: Animal sleeps
    }
}
```
需要注意的是，如果一个类实现了多个接口，而这些接口中有**相同签名**的`default`方法，那么实现类**必须覆盖**这个方法并**明确指定**调用哪个接口的方法。  

一个接口可以定义多个`default`方法。在实现类中，如果要调用**特定**接口的`default`方法，可以使用`接口名.super.方法名()`的语法来指定调用哪个接口的方法。例如：  

```java
interface Animal {
    default void eat() {
        System.out.println("Animal eats");
    }
    default void sleep() {
        System.out.println("Animal sleeps");
    }
}
interface Pet {
    default void play() {
        System.out.println("Pet plays");
    }
}
class Dog implements Animal, Pet {
    public void eat() {
        Animal.super.eat(); // 调用Animal接口的eat方法
    }
    public void sleep() {
        Animal.super.sleep(); // 调用Animal接口的sleep方法
    }
    public void play() {
        Pet.super.play(); // 调用Pet接口的play方法
    }
}
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // Output: Animal eats
        dog.sleep(); // Output: Animal sleeps
        dog.play();  // Output: Pet plays
    }
}
```
接口中的默认方法（default method）**可以调用接口中的抽象方法**：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        I i=new A();
        i.out();
    }
}
interface I{
    void hi();
    default void out(){hi();}
}
class A implements I{
    @Override
    public void hi() {
        System.out.println("测试");
    }
}
```

------

**使用接口数组（new I[]并不是实例化，而是数组特定写法）**：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        I[] i=new I[]{new A(),new A()};
    }
}
interface I{}
class A implements I{}
```
实际上就是（参见[数组简写](#数组)）：  
```java
A a1=new A();
A a2=new A();
I[] i={a1,a2};
```
**抽象类与接口的异同**  

| 异同点     | abstract class                   | interface                            |
| :--------- | :------------------------------- | ------------------------------------ |
| 实例化     | 不能                             | 不能                                 |
| 构造方法   | 可以，为了让子类调用并完成初始化 | 不能                                 |
| 初始化块   | 可以                             | 不能，接口中只有常量，不需要。       |
| 继承       | 只能继承抽象类，使用：`extends`  | 只能继承接口，使用：`extends`        |
| 被继承     | 只能`extends`一个抽象类          | 可以`implements`多个接口             |
| 字段       | 可以                             | **只能**定义**静态常量属性**，即只读 |
| 抽象方法   | 可以定义                         | 可以定义                             |
| 非抽象方法 | **可以**包含普通方法，静态方法   | 可以定义default方法                  |

## 内部类
### 内部类
有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。  

如果一个类定义在另一个类的内部，这个类就是Inner Class：  

```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        Outer.Inner inner=new Outer().new Inner();
    }
}
class Outer {
    class Inner {
        {
            System.out.println("已实例化");
        }
    }
}
```
上述定义的`Outer`是一个普通类，而`Inner`是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。  

要实例化一个`Inner`，必须首先创建一个`Outer`的实例，然后，调用`Outer`实例的`new`来创建`Inner`实例。这是因为Inner Class除了有一个`this`指向它自己，还**隐含**地持有一个Outer Class实例，可以用`Outer.this`访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。  

如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问外部类`private`的权限。  

包含内部类的外部类，在这个外部类里面，也可以使用内部类本身`private`的字段。  

观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而`Inner`类被编译为`Outer$Inner.class`。  

非静态内部类**不能**有静态成员变量，因为非静态内部类的实例是依赖于外部类实例存在的，而静态成员变量是不依赖于实例存在的。如果非静态内部类有静态成员变量，会导致内部类的实例和外部类实例之间产生不一致。  

### 匿名类  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) {
        new Outer();
    }
}
class Outer {
    public Outer() {
        I i=new I(){
            @Override
            public void out() {
                System.out.println("匿名类");
            }
        };
        i.out();
    }
}
interface I{
    void out();
}
```
我们在方法内部实例化了一个`I`。`I`本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了`I`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`I`。  

如果匿名类实现的接口只有一个方法，则可以用lamda表达式来简化代码：  

```java
I i= () -> System.out.println("匿名类");
i.out();
```
匿名类和Inner Class一样，可以访问Outer Class的`private`字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。  

观察Java编译器编译后的`.class`文件可以发现，`Outer`类被编译为`Outer.class`，而匿名类被编译为`Outer$1.class`。如果有多个匿名类，Java编译器会将每个匿名类依次命名为`Outer$1`、`Outer$2`、`Outer$3`……  

除了接口外，匿名类也完全可以继承自普通类。  

```java
Map<String, String> map1 = new HashMap<>();
Map<String, String> map2 = new HashMap<>() {}; // 匿名类!
Map<String, String> map3 = new HashMap<String, String>() {// 匿名类!
    public int a=0;
    public int out(){
        return 0;
    }
    {
        put("A", "1");
        put("B", "2");
    }
};
System.out.println(map3.get("A"));
```
匿名类是一种在使用过程中直接定义类的方式，适合于创建一次性的、不需要重复使用的类。在使用匿名类时，有几个要注意的地方：  
1. **作用域**：匿名类的作用域只在定义的地方，超出该作用域就无法再次使用。
2. **继承与实现**：可以继承一个类，也可以实现一个接口，但不能同时做到。在匿名类中可以重写父类的方法或实现接口的方法。
3. **访问权限**：匿名类可以访问外部类的成员变量和方法，但是外部类不能直接访问匿名类的成员变量和方法。
4. **初始化块**：可以在匿名类中使用初始化块来进行一些初始化操作，类似于构造方法，但并不是真正的构造方法，匿名类没有显式的构造方法。
5. **变量捕获**：如果在匿名类中使用了外部的变量，该变量必须是`final`或者是事实上的`final`（即在初始化后不再改变），否则编译会报错。

非静态内部类**不能**有静态成员变量，因为非静态内部类的实例是依赖于外部类实例存在的，而静态成员变量是不依赖于实例存在的。如果非静态内部类有静态成员变量，会导致内部类的实例和外部类实例之间产生不一致。  
### 静态内部类
顾名思义，就是内部内加上`static`，既然有类方法，类字段，那么这个就叫类类吧，既然有实例方法,实例字段,那么不带`static`的就叫实例类。  

用`static`修饰的内部类和Inner Class有很大的不同，它不再依附于`Outer`的实例，而是一个完全独立的类，因此无法引用`Outer.this`，但它可以访问`Outer`的`private`**静态**字段和**静态**方法。如果把`StaticNested`移到`Outer`之外，就失去了访问`private`的权限。  

## 编译和运行
```batch
 javac -d < destination directory> <java files>
```
将编译java文件得到的class 文件输出到指定目录 `destination directory`， 如果java 文件属于某个包`com.hello`，则会自动生成包名对应的文件目录 `com/hello`，如：**javac –d . Demo.java**  
```batch
 java -cp  or -classpath <class file path> <class name>
```
明确指出用户的类库路径，覆盖环境变量获得的**CLASSPATH**，如果不通过-cp 设置 **CLASSPATH**，当前目录默认为用户的类库路径，此时如果**class**文件包含在当前目录子文件中，同样会报**ClassNotFoundException** 。如：**java -cp 绝对路径 com.Test**  

指定编码：**javac -encoding UTF-8**  

Java 11新增功能，可以直接运行一个**单文件**源码：`java Hello.java`  

假设我们创建了如下的目录结构：  

```ascii
work
├── bin
└── src
    └── com
        └── itranswarp
            ├── sample
            │   └── Main.java
            └── world
                └── Person.java
```
其中，`bin`目录用于存放编译后的`class`文件，`src`目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？首先，确保当前目录是`work`目录然后，编译`src`目录下的所有Java文件：  
```batch
$ javac -d ./bin src/**/*.java
```
命令行`-d`指定输出的`class`文件存放`bin`目录，后面的参数`src/**/*.java`表示`src`目录下的所有`.java`文件，包括任意深度的子目录。  

注意：Windows不支持`**`这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有`.java`文件：  

```batch
C:\work> javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java
```
如果编译无误，则`javac`命令没有任何输出。可以在`bin`目录下看到如下`class`文件：  
```ascii
bin
└── com
    └── itranswarp
        ├── sample
        │   └── Main.class
        └── world
            └── Person.class
```
现在，我们就可以直接运行`class`文件了。根据当前目录的位置确定classpath，例如，当前目录仍为`work`，则classpath为`bin`或者`./bin`：  
```batch
$ java -cp bin com.itranswarp.sample.Main 
Hello, world!
```
### classpath
`classpath`是JVM用到的一个环境变量，它用来指示JVM如何搜索`class`。  

因为Java是编译型语言，源码文件是`.java`，而编译后的`.class`文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个`abc.xyz.Hello`的类，应该去哪搜索对应的`Hello.class`文件。  

所以，`classpath`就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用`;`分隔，带空格的目录用`""`括起来，可能长这样：  

```batch
C:\work\project1\bin;C:\shared;"D:\My Documents\project1\bin"
```
在Linux系统上，用`:`分隔，可能长这样：  
```batch
/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin
```
现在我们假设`classpath`是`.;C:\work\project1\bin;C:\shared`，当JVM在加载`abc.xyz.Hello`这个类时，会依次查找：  
- <当前目录>\abc\xyz\Hello.class
- C:\work\project1\bin\abc\xyz\Hello.class
- C:\shared\abc\xyz\Hello.class

注意到`.`代表当前目录。如果JVM在某个路径下找到了对应的`class`文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。  

`classpath`的设定方法有两种：  

- 在系统环境变量中设置`classpath`环境变量，不推荐；强烈不推荐在系统环境变量中设置`classpath`，那样会污染整个系统环境。
- 在启动JVM时设置`classpath`变量，推荐。

在启动JVM时设置`classpath`才是推荐的做法。实际上就是给`java`命令传入`-classpath`或`-cp`参数：  
```batch
java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```
或者使用`-cp`的简写：  
```batch
java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello
```
没有设置系统环境变量，也没有传入`-cp`参数，那么JVM**默认**的`classpath`为`.`，即当前目录：  
```batch
java abc.xyz.Hello
```
上述命令告诉JVM只在当前目录搜索`Hello.class`。  

在IDE中运行Java程序，IDE自动传入的`-cp`参数是当前工程的`bin`目录和引入的jar包。  

通常，我们在自己编写的`class`中，会引用Java核心库的`class`，例如，`String`、`ArrayList`等。不需要告诉JVM如何去Java核心库查找`class`，JVM怎么可能笨到连自己的核心库在哪都不知道？不要把任何Java核心库添加到classpath中。默认的当前目录`.`对于绝大多数情况都够用了。  

假设我们有一个编译后的`Hello.class`，它的包名是`com.example`，当前目录是`C:\work`，那么，目录结构必须如下：  

```ascii
C:\work
└─ com
   └─ example
      └─ Hello.class
```
运行这个`Hello.class`必须在当前目录下使用如下命令：  
```batch
C:\work> java -cp . com.example.Hello
```
JVM根据classpath设置的`.`在当前目录下查找`com.example.Hello`，即实际搜索文件必须位于`com/example/Hello.class`。如果指定的`.class`文件不存在，或者目录结构和包名对不上，均会报错。  
### jar包
如果有很多`.class`文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。  

jar包就是用来干这个事的，它可以把`package`组织的目录层级，以及各个目录下的所有文件（包括`.class`文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。  

jar包实际上就是一个zip格式的**压缩文件**，而jar包相当于目录。如果我们要执行一个jar包的`class`，就可以把jar包放到`classpath`中：  

```batch
java -cp ./hello.jar abc.xyz.Hello
```
这样JVM会自动在`hello.jar`文件里去搜索某个类。  

那么问题来了：如何创建jar包？  

因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功。  

假设编译输出的目录结构是这样：  

```ascii
package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
```
这里需要特别注意的是，jar包里的第一层目录，不能是`bin`，而应该是`hong`、`ming`、`mr`。  

jar包还可以包含一个特殊的`/META-INF/MANIFEST.MF`文件，`MANIFEST.MF`是纯文本，可以指定`Main-Class`和其它信息。JVM会自动读取这个`MANIFEST.MF`文件，如果存在`Main-Class`，我们就不必在命令行指定启动的类名，而是用更方便的命令：  

```batch
java -jar hello.jar
```
在大型项目中，不可能手动编写`MANIFEST.MF`文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如[Maven](https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200)，可以非常方便地创建jar包。  
### class版本
通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是`java.exe`这个程序的版本：  
```bash
$ java -version
java version "17" 2021-09-14 LTS
```
而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。  

如果用Java 11编译一个Java程序，输出的class文件版本默认就是55，这个class既可以在Java 11上运行，也可以在Java 17上运行，因为Java 17支持的class文件版本是61，表示“最多支持到版本61”。查看class版本可以用`javap -v`。  

如果用Java 17编译一个Java程序，输出的class文件版本默认就是61，它可以在Java 17、Java 18上运行，但不可能在Java 11上运行，因为Java 11支持的class版本最多到55。如果使用低于Java 17的JVM运行，会得到一个`UnsupportedClassVersionError`，错误信息类似：  

```text
java.lang.UnsupportedClassVersionError: Xxx has been compiled by a more recent version of the Java Runtime...
```
只要看到`UnsupportedClassVersionError`就表示当前要加载的class文件版本超过了JVM的能力，必须使用更高版本的JVM才能运行。  

我们也可以用Java 17编译一个Java程序，指定输出的class版本要兼容Java 11（即class版本55），这样编译生成的class文件就可以在Java >=11的环境中运行。  

指定编译输出有两种方式，一种是在`javac`命令行中用参数`--release`设置：  

```batch
$ javac --release 11 Main.java
```
参数`--release 11`表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。  

第二种方式是用参数`--source`指定源码版本，用参数`--target`指定输出class版本：  

```batch
$ javac --source 9 --target 11 Main.java
```
上述命令如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本。注意`--release`参数和`--source --target`参数只能二选一，不能同时设置。  

然而，指定版本如果低于当前的JDK版本，会有一些潜在的问题。例如，我们用Java 17编译`Hello.java`，参数设置`--source 9`和`--target 11`：  

```java
public class Hello {
    public static void hello(String name) {
        System.out.println("hello".indent(4));
    }
}
```
用低于Java 11的JVM运行`Hello`会得到一个`LinkageError`，因为无法加载`Hello.class`文件，而用Java 11运行`Hello`会得到一个`NoSuchMethodError`，因为`String.indent()`方法是从Java 12才添加进来的，Java 11的`String`版本根本没有`indent()`方法。  

注：如果使用--release 11则会在编译时检查该方法是否在Java 11中存在。  

**因此，如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class。**  

如果使用`javac`编译时不指定任何版本参数，那么相当于使用`--release 当前版本`编译，即源码版本和输出版本均为当前版本。  

**源码版本**  

在编写源代码的时候，我们通常会预设一个源码的版本。在编译的时候，如果用`--source`或`--release`指定源码版本，则使用指定的源码版本检查语法。  

例如，使用了lambda表达式的源码版本至少要为8才能编译，使用了`var`关键字的源码版本至少要为10才能编译，使用`switch`表达式的源码版本至少要为12才能编译，且12和13版本需要启用`--enable-preview`参数。  

### 模块
从Java 9开始，JDK又引入了模块（Module）。  

什么是模块？这要从Java 9之前的版本说起。  

我们知道，`.class`文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆`.class`文件，很不便于管理，所以，`jar`文件就是`class`文件的容器。  

在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫`rt.jar`，一共有60多M。  

如果是自己开发的程序，除了一个自己的`app.jar`以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：  

```bash
java -cp app.jar:a.jar:b.jar:c.jar com.Main
```
**注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。**  

如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出`ClassNotFoundException`。  

所以，jar只是用于存放class的容器，它并不关心class之间的依赖。  

从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果`a.jar`必须依赖另一个`b.jar`才能运行，那我们应该给`a.jar`加点说明啥的，让程序在编译和运行的时候能自动定位到`b.jar`，这种自带“依赖关系”的class容器就是模块。  

为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的`rt.jar`分拆成了几十个模块，这些模块以`.jmod`扩展名标识，可以在`$JAVA_HOME/jmods`目录下找到它们：  

- java.base.jmod
- java.compiler.jmod
- java.datatransfer.jmod
- java.desktop.jmod
- ...

这些`.jmod`文件每一个都是一个模块，模块名就是文件名。例如：模块`java.base`对应的文件就是`java.base.jmod`。模块之间的依赖关系已经被写入到模块内的`module-info.class`文件了。所有的模块都直接或间接地依赖`java.base`模块，只有`java.base`模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从`Object`直接或间接继承而来。  

把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。  

**编写模块**  

那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以`oop-module`工程为例，它的目录结构如下：  

```ascii
oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
```
其中，`bin`目录存放编译后的class文件，`src`目录存放源码，按包名的目录结构存放，仅仅在`src`目录下多了一个`module-info.java`这个文件，这就是模块的描述文件。在这个模块中，它长这样：  
```java
module hello.world {
	requires java.base; // 可不写，任何模块都会自动引入java.base
	requires java.xml;
}
```
其中，`module`是关键字，后面的`hello.world`是模块的名称，它的命名规范与包一致。花括号的`requires xxx;`表示这个模块需要引用的其他模块名。除了`java.base`可以被自动引入外，这里我们引入了一个`java.xml`的模块。  

当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，`Main.java`代码如下：  

```java
package com.itranswarp.sample;
// 必须引入java.xml模块后才能使用其中的类:
import javax.xml.XMLConstants;
public class Main {
	public static void main(String[] args) {
		Greeting g = new Greeting();
		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));
	}
}
```
如果把`requires java.xml;`从`module-info.java`中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。  

下面，我们用JDK提供的命令行工具来编译并创建模块。  

首先，我们把工作目录切换到`oop-module`，在当前目录下编译所有的`.java`文件，并存放到`bin`目录下，命令如下：  

```bash
$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java
```
如果编译成功，现在项目结构如下：  
```ascii
oop-module
├── bin
│   ├── com
│   │   └── itranswarp
│   │       └── sample
│   │           ├── Greeting.class
│   │           └── Main.class
│   └── module-info.class
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
```
注意到`src`目录下的`module-info.java`被编译到`bin`目录下的`module-info.class`。  

下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入`--main-class`参数，让这个jar包能自己定位`main`方法所在的类：  

```bash
$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .
```
现在我们就在当前目录下得到了`hello.jar`这个jar包，它和普通jar包并无区别，可以直接使用命令`java -jar hello.jar`来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的`jmod`命令把一个jar包转换成模块：  
```bash
$ jmod create --class-path hello.jar hello.jmod
```
于是，在当前目录下我们又得到了`hello.jmod`这个模块文件，这就是最后打包出来的传说中的模块！  

**运行模块**  

要运行一个jar，我们使用`java -jar xxx.jar`命令。要运行一个模块，我们只需要指定模块名。试试：  

```bash
$ java --module-path hello.jmod --module hello.world
```
结果是一个错误：  
```bash
Error occurred during initialization of boot layer
java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod
```
原因是`.jmod`不能被放入`--module-path`中。换成`.jar`就没问题了：  
```bash
$ java --module-path hello.jar --module hello.world
Hello, xml!
```
那我们辛辛苦苦创建的`hello.jmod`有什么用？答案是我们可以用它来打包JRE。  

**打包JRE**  

前面讲了，为了支持模块化，**Java 9**首先带头把自己的一个巨大无比的`rt.jar`拆成了几十个`.jmod`模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。  

过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？  

现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了`jlink`命令来干这件事。命令如下：  

```bash
$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/
```
我们在`--module-path`参数指定了我们自己的模块`hello.jmod`，然后，在`--add-modules`参数中指定了我们用到的3个模块`java.base`、`java.xml`和`hello.world`，用`,`分隔。最后，在`--output`参数指定输出目录。  

现在，在当前目录下，我们可以找到`jre`目录，这是一个完整的并且带有我们自己`hello.jmod`模块的JRE。试试直接运行这个JRE：  

```bash
$ jre/bin/java --module hello.world
Hello, xml!
```
要分发我们自己的Java应用程序，只需要把这个`jre`目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。  

**访问权限**  

前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。  

确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。  

举个例子：我们编写的模块`hello.world`用到了模块`java.xml`的一个类`javax.xml.XMLConstants`，我们之所以能直接使用这个类，是因为模块`java.xml`的`module-info.java`中声明了若干导出：  

```java
module java.xml {
    exports java.xml;
    exports javax.xml.catalog;
    exports javax.xml.datatype;
    ...
}
```
只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的`hello.world`模块中的`com.itranswarp.sample.Greeting`类，我们必须将其导出：  
```java
module hello.world {
    exports com.itranswarp.sample;
    requires java.base;
	requires java.xml;
}
```
因此，模块进一步隔离了代码的访问权限。  
## 装箱拆箱  
**Double.parseDouble**方法是把数字类型的字符串,转换成**double**类型  

**Double.valueOf**方法是把数字类型的字符串,转换成**Double**类型  

可以看出大体是没有任何区别,就是返回值的**类型**区别  

```java
double a=Double.parseDouble("123");  
Double b=Double.valueOf("123");
```
**valueOf**方法在返回的时候**new Double()**,所以返回的是**Double**。  

**intValue()**表示拆箱，将对象类型转换为基础类型  

**valueOf()**表示装箱，将基础类型转换为对象类型  

因为`int`和`Integer`可以互相转换，所以，Java编译器可以帮助我们**自动**在`int`和`Integer`之间转型。自动装箱和自动拆箱只发生在编译阶段（JDK>=1.5），目的是为了少写代码。装箱和拆箱会影响代码的执行效率，因为编译后的`class`代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报`NullPointerException`，比如:`Integer n = null;int i=n;`  

所有的包装类型都是不变类。`Integer`的核心代码如下：  

```java
public final class Integer {
    private final int value;
}
```
因此，一旦创建了`Integer`对象，该对象就是不变的。但实际我们代码，这样是不会报错的：  
```java
Integer num = 5;
num = num + 1;
System.out.println(num);
```
原因：`num`是一个`Integer`对象，初始值为5。当我们执行`num + 1`时，实际上创建了一个新的`Integer`对象来表示6，然后将其赋值给`num`。  
```java
Integer x = 127;
Integer y = 127;
Integer m = 99999;
Integer n = 99999;
System.out.println("x == y: " + (x==y)); // true
System.out.println("m == n: " + (m==n)); // false
System.out.println("x.equals(y): " + x.equals(y)); // true
System.out.println("m.equals(n): " + m.equals(n)); // true
```
`==`比较，较小的两个相同的`Integer`返回`true`，较大的两个相同的`Integer`返回`false`，这是因为`Integer`是不变类，编译器把`Integer x = 127;`自动变为`Integer x = Integer.valueOf(127);`，为了节省内存，`Integer.valueOf()`对于较小的数，始终返回相同的实例。  

`Integer`本身会缓存[-128,127]的整数，所以当你值在这个范围内时，就会直接取出`Integer`,不会`new`一个新的`Integer`，因此`==`为`true`, 而当数超过这个范围时，就会`new`一个新的`Integer`，不同的`Integer`对象，因此`==`为`false`。  

因此，`==`比较“恰好”为`true`，但我们绝不能因为Java标准库的`Integer`内部有缓存优化就用`==`比较，必须用`equals()`方法比较两个`Integer`。 按照语义编程，而不是针对特定的底层实现去“优化”。  

因为`Integer.valueOf()`可能始终返回同一个`Integer`实例，因此，在我们自己创建`Integer`的时候，以下两种方法：  

- 方法1：`Integer n = new Integer(100);`
- 方法2：`Integer n = Integer.valueOf(100);`

方法2更好，因为方法1总是创建新的`Integer`实例，方法2把内部优化留给`Integer`的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。  

我们把能创建“新”对象的静态方法称为静态工厂方法。`Integer.valueOf()`就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。  

Java的包装类型还定义了一些有用的静态变量  

```java
// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:
Boolean t = Boolean.TRUE;
Boolean f = Boolean.FALSE;
// int可表示的最大/最小值:
int max = Integer.MAX_VALUE; // 2147483647
int min = Integer.MIN_VALUE; // -2147483648
// long类型占用的bit和byte数量:
int sizeOfLong = Long.SIZE; // 64 (bits)
int bytesOfLong = Long.BYTES; // 8 (bytes)
```
所有的整数和浮点数的包装类型都继承自`Number`，因此，可以非常方便地直接通过包装类型获取各种基本类型：  
```java
// 向上转型为Number:
Number num = new Integer(999);
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();
```
## JavaBean
如果读写方法符合以下这种命名规范：  
```java
// 读方法:
public Type getXyz()
// 写方法:
public void setXyz(Type value)
```
那么这种`class`被称为`JavaBean`，上面的字段是`xyz`，那么读写方法名分别以`get`和`set`开头，并且后接大写字母开头的字段名`Xyz`，因此两个读写方法名分别是`getXyz()`和`setXyz()`。`boolean`字段比较特殊，它的读方法一般命名为`isXyz()`。  

IDEA：**alt+/** 内容辅助，在类内右键-生成Getter和Setter..  。  

要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的`Introspector`：  

```java
package com.aotmd;
import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
public class Main {
    public static void main(String[] args) throws Exception {
        BeanInfo info = Introspector.getBeanInfo(Person.class);
        for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
            System.out.println(pd.getName());
            System.out.println("  " + pd.getReadMethod());
            System.out.println("  " + pd.getWriteMethod());
        }
    }
}
class Person {
    private String name;
    private int age;
    public String getName() {return name;}
    public void setName(String name) {this.name = name;}
    public int getAge() {return age;}
    public void setAge(int age) {this.age = age;}
}
```
运行上述代码，可以列出所有的属性，以及对应的读写方法。注意`class`属性是从`Object`继承的`getClass()`方法带来的。  
## 枚举
在Java中，我们可以通过`static final`来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的`int`表示：  
```java
public class Weekday {
    public static final int SUN = 0;
    public static final int MON = 1;
    public static final int TUE = 2;
    public static final int WED = 3;
    public static final int THU = 4;
    public static final int FRI = 5;
    public static final int SAT = 6;
}
```
使用常量的时候，可以这么引用：  
```java
int day=0;
if (day == Weekday.SAT || day == Weekday.SUN) {
    // TODO: work at home
}
```
也可以把常量定义为字符串类型，例如，定义3种颜色的常量：  
```java
public class Color {
    public static final String RED = "r";
    public static final String GREEN = "g";
    public static final String BLUE = "b";
}
```
使用常量的时候，可以这么引用：  
```java
String color = "r"
if (Color.RED.equals(color)) {
}
```
无论是`int`常量还是`String`常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：  
```java
if (weekday == 6 || weekday == 7) {
    if (tasks == Weekday.MON) {
    }
}
```
假设`weekday`表示星期几，`tasks`表示任务，`Weekday.MON`表示星期一。`6`和`7`并不能直观地表达出是星期六和星期日，`tasks`被用来表示星期几的任务，这种用法并不符合语义。  

上述代码编译和运行均不会报错，但存在两个问题：  

- 注意到`Weekday`定义的常量范围是`0`~`6`，并不包含`7`，但是在代码中可以使用`6`和`7`来表示星期六和星期日。这种情况下，编译器无法检查出不在枚举范围内的值，因为`6`和`7`是合法的`int`值，但却不是合法的星期枚举值。
- 定义的常量虽然可以表示星期值，但它们仍然是`int`类型的常量，可以与其他`int`类型的变量进行比较，这并不符合枚举值的语义。虽然使用`tasks == Weekday.MON`来判断`tasks`是否是星期一的任务，虽然可以正常运行，但这种比较并不直观，容易引起误解。

------

**enum**  

为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用`enum`来定义枚举类：  

```java
public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day == Weekday.SAT || day == Weekday.SUN) {
            System.out.println("Work at home!");
        } else {
            System.out.println("Work at office!");
        }
    }
}
enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
```
注意到定义枚举类是通过关键字`enum`实现的，我们只需依次列出枚举的常量名。  

和`int`定义的常量相比，使用`enum`定义枚举有如下好处：  

首先，`enum`常量本身带有类型信息，即`Weekday.SUN`类型是`Weekday`，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：  

```java
int day = 1;
if (day == Weekday.SUN) { // Compile error: bad operand types for binary operator '=='
}
```
其次，不可能引用到非枚举的值，因为无法通过编译。  

最后，不同类型的枚举**不能**互相**比较**或者赋值，因为类型不符。例如，不能给一个`Weekday`枚举类型的变量赋值为`Color`枚举类型的值：  

```
Weekday x = Weekday.SUN; // ok!
Weekday y = Color.RED; // Compile error: incompatible types
```
这就使得编译器可以在编译期自动检查出所有可能的潜在错误。  

**enum的比较**  

使用`enum`定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用`equals()`方法，如果使用`==`比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用`equals()`方法，但`enum`类型可以例外。  

这是因为`enum`类型的每个常量在JVM中只有一个唯一实例，所以可以直接用`==`比较：  

```java
if (day == Weekday.FRI) { // ok!
}
if (day.equals(Weekday.SUN)) { // ok, but more code!
}
```
**enum类型**  

通过`enum`定义的枚举类，和其他的`class`有什么区别？  

答案是**没有任何区别**。`enum`定义的类型就是`class`，只不过它有以下几个特点：  

- 定义的`enum`类型总是继承自`java.lang.Enum`，且无法被继承；
- 只能定义出`enum`的实例，而无法通过`new`操作符创建`enum`的实例；
- 定义的每个实例都是引用类型的唯一实例；
- 可以将`enum`类型用于`switch`语句。

例如，我们定义的`Color`枚举类：  
```java
public enum Color {
    RED, GREEN, BLUE;
}
```
编译器编译出的`class`大概就像这样：  
```java
public final class Color extends Enum { // 继承自Enum，标记为final class
    // 每个实例均为全局唯一:
    public static final Color RED = new Color();
    public static final Color GREEN = new Color();
    public static final Color BLUE = new Color();
    // private构造方法，确保外部无法调用new操作符:
    private Color() {}
}
```
所以，编译后的`enum`类和普通`class`并**没有任何区别**。但是我们自己无法按定义普通`class`那样来定义`enum`，必须使用`enum`关键字，这是Java语法规定的。  

因为`enum`是一个`class`，每个枚举的值都是`class`实例，因此，这些实例有一些方法：  

**name()**  

返回常量名，例如：  

```java
String s = Weekday.SUN.name(); // "SUN"
```
**ordinal()**  

返回定义的常量的**顺序**，从0开始计数，例如：  

```java
int n = Weekday.MON.ordinal(); // 1
```
改变枚举常量定义的顺序就会导致`ordinal()`返回值发生变化。例如：  
```java
public enum Weekday {SUN, MON, TUE, WED, THU, FRI, SAT;}
```
和  
```java
public enum Weekday {MON, TUE, WED, THU, FRI, SAT, SUN;}
```
的`ordinal`就是不同的。如果在代码中编写了类似`if(x.ordinal()==1)`这样的语句，就要**保证**`enum`的枚举**顺序不能变**。新增的常量必须放在最后。  

`Weekday`的枚举常量如果要和`int`转换，使用`ordinal()`不是非常方便？比如这样写：  

```java
int task = Weekday.MON.ordinal();
```
但是，如果不小心修改了枚举的**顺序**，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就**不要依靠**`ordinal()`的返回值。因为`enum`本身是`class`，所以我们可以定义`private`的**构造方法**，并且，给每个枚举常量添加字段：  
```java
public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) {
            System.out.println("Work at home!");
        } else {
            System.out.println("Work at office!");
        }
    }
}
enum Weekday {
    MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6), SUN(0);
    public final int dayValue;
    private Weekday(int dayValue) {
        this.dayValue = dayValue;
    }
}
```
这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个`int`值。  

注意：**枚举类的字段**也**可以**是非`final`类型，即可以在运行期修改，但是不推荐这样做！  

默认情况下，对枚举常量调用`toString()`会返回和`name()`一样的字符串。但是，`toString()`可以被覆写，而`name()`则不行，因此判断枚举常量的**名字**，要始终使用`name()`方法，绝不能调用`toString()`！覆写`toString()`的目的是在输出时更有可读性。。可以给`Weekday`添加`toString()`方法：  

```java
public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        if (day.dayValue == 6 || day.dayValue == 0) {
            System.out.println("Today is " + day + ". Work at home!");
        } else {
            System.out.println("Today is " + day + ". Work at office!");
        }
    }
}
enum Weekday {
    MON(1, "星期一"), TUE(2, "星期二"), WED(3, "星期三"), THU(4, "星期四"), FRI(5, "星期五"), SAT(6, "星期六"), SUN(0, "星期日");
    public final int dayValue;
    private final String chinese;
    private Weekday(int dayValue, String chinese) {
        this.dayValue = dayValue;
        this.chinese = chinese;
    }
    @Override
    public String toString() {
        return this.chinese;
    }
}
```
**values()**  

`enum`类中有一个名为`values()`的方法，它返回包含枚举类中所有枚举常量的数组。该方法在`java.lang.Enum`类中被定义为`final`，因此所有枚举类都可以直接使用该方法。  

```java
enum Weekday {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
public class Main {
    public static void main(String[] args) {
        Weekday[] weekdays = Weekday.values();
        for (Weekday day : weekdays) {
            System.out.println(day);
        }
    }
}
```
该示例定义了一个`Weekday`枚举类，然后通过调用`values()`方法获取所有枚举常量，并使用`for`循环遍历打印每个枚举常量的名称。`values()`方法是枚举类中的一个便捷方法，用于获取所有枚举常量，方便对枚举类进行遍历和操作。  

------

**switch**  

最后，枚举类可以应用在`switch`语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比`int`、`String`类型更适合用在`switch`语句中：  

```java
public class Main {
    public static void main(String[] args) {
        Weekday day = Weekday.SUN;
        switch(day) {
            case MON:
            case TUE:
            case WED:
            case THU:
            case FRI:
                System.out.println("Today is " + day + ". Work at office!");
                break;
            case SAT:
            case SUN:
                System.out.println("Today is " + day + ". Work at home!");
                break;
            default:
                throw new RuntimeException("cannot process " + day);
        }
    }
}
enum Weekday {
    MON, TUE, WED, THU, FRI, SAT, SUN;
}
```
加上`default`语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。  

不能用  

```java
case Weekday.MON:
```
而只能用  
```java
case MON:
```
在`Switch()`里面已经写了是 `day`，而`day`的类型是`Weekday`，所以`case`后面的`Weekday`就省略了，因为所有的`case`类型必须是`Weekday`。  

`switch`语句中的`case`标签必须使用枚举常量的非限定名称，而不是枚举类的名称，是因为Java语言规定了这样的语法规则。  

在`switch`语句中，`case`标签用于匹配要执行的代码块。在枚举类型中，每个枚举常量都是一个实例，因此在`switch`语句中，应该匹配的是枚举常量的值，而不是枚举类本身。  

使用枚举常量的非限定名称作为`case`标签可以让代码更清晰易读，并且可以避免混淆。如果允许在`switch`语句中使用枚举类的名称，可能会导致代码不够清晰，不容易理解。  

因此，Java语言规定了`switch`语句中的`case`标签必须使用枚举常量的非限定名称，以确保代码的正确性和清晰性。  

------

```java
public class Main{
    public static void main(String[] args) {
        int a=0;
        switch (a){
            case X.y: break;
        }
    }
}
class X {
    static final int y = Integer.parseInt(System.getProperty("NUMBER_OF_PROCESSORS"));
}
```
case只能比较常量，不能比较变量，所以要在编译期计算常量的值。  

这种final定义：  

```java
class X {
    static final int y = 1;
}
```
编译期能计算出来，所以可以用 case X.y，编译器麻溜地把代码直接替换成 case 1  

这种final定义：  

```java
class X {
    static final int y = Integer.parseInt(System.getProperty("NUMBER_OF_PROCESSORS"));
}
```
编译期算不出来，只能运行才知道，所以不能用`case X.y`  
## record
使用`String`、`Integer`等类型的时候，这些类型都是不变类，一个不变类具有以下特点：  
1. 定义class时使用`final`，无法派生子类；
2. 每个字段使用`final`，保证创建实例后无法修改任何字段。

假设我们希望定义一个`Point`类，有`x`、`y`两个变量，同时它是一个不变类，可以这么写：  
```java
public final class Point {
    private final int x;
    private final int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public int x() {
        return this.x;
    }
    public int y() {
        return this.y;
    }
}
```
为了保证不变类的比较，还需要正确覆写`equals()`和`hashCode()`方法，这样才能在集合类中正常使用。这些代码写起来都非常简单，但是很繁琐。  

**record**  

从**Java 14**开始，引入了新的`Record`类。 `record` 类的目的是为了简化创建不可变数据对象的过程。它自动为类生成 `equals()`、`hashCode()`、`toString()` 方法，同时提供了一个简洁的声明方式来定义类的属性。通过使用 `record`，可以更加简洁地定义数据模型，避免编写大量样板代码，提高代码的可读性和可维护性。  

定义`Record`类时，使用关键字`record`。把上述`Point`类改写为`Record`类，代码如下：  

```java
record Point(int x, int y) {}
```
把上述定义改写为class，相当于以下代码：  
```java
final class Point extends Record {
    private final int x;
    private final int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public int x() {
        return this.x;
    }
    public int y() {
        return this.y;
    }
    public String toString() {
        return String.format("Point[x=%s, y=%s]", x, y);
    }
    public boolean equals(Object o) {
        ...
    }
    public int hashCode() {
        ...
    }
}
```
除了用`final`修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写`toString()`、`equals()`和`hashCode()`方法。  

换句话说，使用`record`关键字，可以一行写出一个不变类。  

和`enum`类似，我们自己不能直接从`Record`派生，只能通过`record`关键字由编译器实现继承。  

**构造方法**  

编译器默认按照`record`声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？  

假设`Point`类的`x`、`y`不允许负数，我们就得给`Point`的构造方法加上检查逻辑：  

```java
public record Point(int x, int y) {
    public Point {
        if (x < 0 || y < 0) {
            throw new IllegalArgumentException();
        }
    }
}
```
注意到方法`public Point {...}`被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：  
```java
public final class Point extends Record {
    public Point(int x, int y) {
        // 这是我们编写的Compact Constructor:
        if (x < 0 || y < 0) {
            throw new IllegalArgumentException();
        }
        // 这是编译器继续生成的赋值代码:
        this.x = x;
        this.y = y;
    }
    ...
}
```
作为`record`的`Point`仍然可以添加静态方法。一种常用的静态方法是`of()`方法，用来创建`Point`：  
```java
public record Point(int x, int y) {
    public static Point of() {
        return new Point(0, 0);
    }
    public static Point of(int x, int y) {
        return new Point(x, y);
    }
}
```
这样我们可以写出更简洁的代码：  
```java
var z = Point.of();
var p = Point.of(123, 456);
```
还可以手动写构造方法：  
```java
public class Main{
    public static void main(String[] args) {
        C c = new C(1, 2);
        System.out.println(c.a());
        System.out.println(c.b());
    }
}
record C(int a,int b){
    public C(int a,int b) {
        this.a=a;
        this.b=b;
    }
}
```
如果不需要在赋值前后做某些事情，则没有必要这样写。也可以写多个构造方法：  
```java
package com.aotmd;
public class Main{
    public static void main(String[] args) {
        C c = new C(1, 2);
        System.out.println(c);
        C c2 = new C();
        System.out.println(c2);
    }
}
record C(int a,int b){
    public C(int a) {
        this(a,2);
        System.out.println("一参");
    }
    public C(){
        this(1);
        System.out.println("无参");
    }
}
```
最后必须传递到自动生成的构造方法，Java中的`record`类在定义非规范记录构造函数（non-canonical record constructor）时，必须委托给其他构造函数。这意味着非规范记录构造函数的第一条语句必须是对其他构造函数的调用。且非规范记录构造函数**必须**最终委托给自动生成的构造函数，否则会导致编译错误。这意味着在构造函数体内的调用链**必须最终**指向自动生成的构造函数。  
## BigInteger
在Java中，由CPU原生提供的整型最大范围是64位`long`型整数。使用`long`型整数可以直接通过CPU指令进行计算，速度非常快。  

如果我们使用的整数范围超过了`long`型怎么办？这个时候，就只能用软件来模拟一个大整数。`java.math.BigInteger`就是用来表示任意大小的整数。`BigInteger`内部用一个`int[]`数组来模拟一个非常大的整数：  

```java
BigInteger bi = new BigInteger("1234567890");
System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000
```
对`BigInteger`做运算的时候，只能使用实例方法，例如，加法运算：  
```java
BigInteger i1 = new BigInteger("1234567890");
BigInteger i2 = new BigInteger("12345678901234567890");
BigInteger sum = i1.add(i2); // 12345678902469135780
```
和`long`型整数运算比，`BigInteger`不会有范围限制，但缺点是速度比较慢。  

也可以把`BigInteger`转换成`long`型：  

```java
BigInteger i = new BigInteger("123456789000");
System.out.println(i.longValue()); // 123456789000
System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range
```
使用`longValueExact()`方法时，如果超出了`long`型的范围，会抛出`ArithmeticException`。  

`BigInteger`和`Integer`、`Long`一样，也是不可变类，并且也继承自`Number`类。因为`Number`定义了转换为基本类型的几个方法：  

- 转换为`byte`：`byteValue()`
- 转换为`short`：`shortValue()`
- 转换为`int`：`intValue()`
- 转换为`long`：`longValue()`
- 转换为`float`：`floatValue()`
- 转换为`double`：`doubleValue()`

通过上述方法，可以把`BigInteger`转换成基本类型。  

如果`BigInteger`表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。  

如果需要**准确**地转换成基本类型，可以使用`intValueExact()`、`longValueExact()`等方法，在转换时如果超出范围，将直接抛出`ArithmeticException`异常。  

`BigInteger`转换基本类型，为什么没有`floatValueExact()`方法。  

`BigInteger`是一个整数类型，而浮点数类型包括`float`和`double`。因为浮点数类型是具有小数点的，所以在进行类型转换时可能发生**精度损失**或**溢出**等情况。因此，`BigInteger`类没有提供`floatValueExact()`方法，以避免精度损失问题。  

## BigDecimal
和`BigInteger`类似，`BigDecimal`可以表示一个任意大小且精度完全准确的浮点数。  
```java
BigDecimal bd = new BigDecimal("123.4567");
System.out.println(bd.multiply(bd)); // 15241.55677489
```
`BigDecimal`用`scale()`表示小数位数，例如：  
```java
BigDecimal d1 = new BigDecimal("123.45");
BigDecimal d2 = new BigDecimal("123.4500");
BigDecimal d3 = new BigDecimal("1234500");
System.out.println(d1.scale()); // 2,两位小数
System.out.println(d2.scale()); // 4
System.out.println(d3.scale()); // 0
```
通过`BigDecimal`的`stripTrailingZeros()`方法，可以将一个`BigDecimal`格式化为一个相等的，但去掉了末尾0的`BigDecimal`：  
```java
BigDecimal d1 = new BigDecimal("123.4500");
BigDecimal d2 = d1.stripTrailingZeros();
System.out.println(d1.scale()); // 4
System.out.println(d2.scale()); // 2,因为去掉了00
BigDecimal d3 = new BigDecimal("1234500");
BigDecimal d4 = d3.stripTrailingZeros();
System.out.println(d3.scale()); // 0
System.out.println(d4.scale()); // -2
```
如果一个`BigDecimal`的`scale()`返回**负数**，例如，`-2`，表示这个数是个整数，并且末尾有2个0。  

可以对一个`BigDecimal`设置它的`scale`，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：  

```java
BigDecimal d1 = new BigDecimal("123.456789");
BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568
BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567
System.out.println(d2);
System.out.println(d3);
```
对`BigDecimal`做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：  
```java
BigDecimal d1 = new BigDecimal("123.456");
BigDecimal d2 = new BigDecimal("23.456789");
BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入
BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽
```
还可以对`BigDecimal`做除法的同时求余数：  
```java
BigDecimal n = new BigDecimal("12.345");
BigDecimal m = new BigDecimal("0.12");
BigDecimal[] dr = n.divideAndRemainder(m);
System.out.println(dr[0]); // 102
System.out.println(dr[1]); // 0.105
```
调用`divideAndRemainder()`方法时，返回的数组包含两个`BigDecimal`，分别是商和余数，其中商总是整数，余数不会大于除数。可以利用这个方法判断两个`BigDecimal`是否是整数倍数：  
```java
BigDecimal n = new BigDecimal("12.75");
BigDecimal m = new BigDecimal("0.15");
BigDecimal[] dr = n.divideAndRemainder(m);
if (dr[1].signum() == 0) {// n是m的整数倍
}
```
**比较BigDecimal**  

在比较两个`BigDecimal`的值是否相等时，要特别注意，使用`equals()`方法不但要求两个`BigDecimal`的值相等，还要求它们的`scale()`相等：  

```java
BigDecimal d1 = new BigDecimal("123.456");
BigDecimal d2 = new BigDecimal("123.45600");
System.out.println(d1.equals(d2)); // false,因为scale不同
System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为3
System.out.println(d1.compareTo(d2)); // 0
```
必须使用`compareTo()`方法来比较，它根据两个值的大小分别返回负数、正数和`0`，分别表示小于、大于和等于。  

总是使用`compareTo()`比较两个`BigDecimal`的值，不要使用`equals()`！  

如果查看`BigDecimal`的源码，可以发现，实际上一个`BigDecimal`是通过一个`BigInteger`和一个`scale`来表示的，即`BigInteger`表示一个完整的整数，而`scale`表示小数位数：  

```java
public class BigDecimal extends Number implements Comparable<BigDecimal> {
    private final BigInteger intVal;
    private final int scale;
}
```
`BigDecimal`也是从`Number`继承的，也是不可变对象。  

`BigDecimal`用于表示精确的小数，常用于**财务计算**；  

## 常用工具类
### Math
顾名思义，`Math`类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：  

求绝对值：  

```java
Math.abs(-100); // 100
Math.abs(-7.8); // 7.8
```
取最大或最小值：  
```java
Math.max(100, 99); // 100
Math.min(1.2, 2.3); // 1.2
```
计算x的y次方：  
```java
Math.pow(2, 10); // 2的10次方=1024
```
计算√x：  
```java
Math.sqrt(2); // 1.414...
```
计算e的x次方：  
```java
Math.exp(2); // 7.389...
```
计算以e为底的对数：  
```java
Math.log(4); // 1.386...
```
计算以10为底的对数：  
```java
Math.log10(100); // 2
```
三角函数：  
```java
Math.sin(3.14); // 0.00159...
Math.cos(3.14); // -0.9999...
Math.tan(3.14); // -0.0015...
Math.asin(1.0); // 1.57079...
Math.acos(1.0); // 0.0
```
Math还提供了几个数学常量：  
```java
double pi = Math.PI; // 3.14159...
double e = Math.E; // 2.7182818...
Math.sin(Math.PI / 6); // sin(π/6) = 0.5
```
生成一个随机数x，x的范围是`0 <= x < 1`：  
```java
Math.random(); // 0.53907... 每次都不一样
```
如果我们要生成一个区间在`[MIN, MAX)`的随机数，可以借助`Math.random()`实现，计算如下：  
```java
double x = Math.random(); // x的范围是[0,1)
double min = 10;
double max = 50;
double y = x * (max - min) + min; // y的范围是[10,50)
long n = (long) y; // n的范围是[10,50)的整数
System.out.println(y);
System.out.println(n);
```
Java标准库还提供了一个`StrictMath`，它提供了和`Math`几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，`StrictMath`保证所有平台计算结果都是完全相同的，而`Math`会尽量针对平台优化计算速度，所以，绝大多数情况下，使用`Math`就足够了。  
### HexFormat
需要**JDK版本17**，在处理`byte[]`数组时，我们经常需要与十六进制字符串转换，自己写起来比较麻烦，用Java标准库提供的`HexFormat`则可以方便地帮我们转换。  

要将`byte[]`数组转换为十六进制字符串，可以用`formatHex()`方法：  

```java
byte[] data = "Hello".getBytes();
HexFormat hf = HexFormat.of();
String hexData = hf.formatHex(data); // 48656c6c6f
```
如果要定制转换格式，则使用定制的`HexFormat`实例：  
```java
// 分隔符为空格，添加前缀0x，大写字母:
HexFormat hf = HexFormat.ofDelimiter(" ").withPrefix("0x").withUpperCase();
System.out.println(hf.formatHex("Hello".getBytes())); // 0x48 0x65 0x6C 0x6C 0x6F;
```
从十六进制字符串到`byte[]`数组转换，使用`parseHex()`方法：  
```java
byte[] bs = HexFormat.of().parseHex("48656c6c6f");
```
### Random
`Random`用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。  

要生成一个随机数，可以使用`nextInt()`、`nextLong()`、`nextFloat()`、`nextDouble()`：  

```java
Random r = new Random();
r.nextInt(); // 2071575453,每次都不一样
r.nextInt(10); // 5,生成一个[0,10)之间的int
r.nextLong(); // 8811649292570369305,每次都不一样
r.nextFloat(); // 0.54335...生成一个[0,1)之间的float
r.nextDouble(); // 0.3716...生成一个[0,1)之间的double
```
每次运行程序，生成的随机数都是不同的，这是因为我们创建`Random`实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。  

如果我们在创建`Random`实例时指定一个种子，就会得到完全确定的随机数序列：  

```java
Random r = new Random(12345);
for (int i = 0; i < 10; i++) {
System.out.println(r.nextInt(100));
}
// 51, 80, 41, 28, 55...
```
前面我们使用的`Math.random()`实际上内部调用了`Random`类，所以它也是伪随机数，只是我们无法指定种子。  
### SecureRandom
有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，`SecureRandom`就是用来创建安全的随机数的：  
```java
SecureRandom sr = new SecureRandom();
System.out.println(sr.nextInt(100));
```
`SecureRandom`无法指定种子，它使用RNG（random number generator）算法。JDK的`SecureRandom`实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：  
```java
import java.util.Arrays;
import java.security.SecureRandom;
import java.security.NoSuchAlgorithmException;
public class Main {
    public static void main(String[] args) {
        SecureRandom sr = null;
        try {
            sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器
        } catch (NoSuchAlgorithmException e) {
            sr = new SecureRandom(); // 获取普通的安全随机数生成器
        }
        byte[] buffer = new byte[16];
        sr.nextBytes(buffer); // 用安全随机数填充buffer
        System.out.println(Arrays.toString(buffer));
    }
}
```
`SecureRandom`的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。  

在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用`SecureRandom`来产生安全的随机数。  