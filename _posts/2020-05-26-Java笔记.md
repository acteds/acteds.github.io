---
layout: post
title: Java笔记
categories: Java
description: Java的基础笔记
keywords: Java
---
# 引言  
&emsp;&emsp;java的基础笔记。    


# 基础
## 杂
&emsp;&emsp;输入:  
```java
import java.util.Scanner;
Scanner scanner=new Scanner(System.in);
int m=scanner.nextInt();
String s = scanner.next();//读一串
scanner.nextLine();//读一行
```
&emsp;&emsp;输出:  
&emsp;&emsp;有回车  
```java
System.out.println();
```
&emsp;&emsp;无回车  
```java
System.out.print();
```
&emsp;&emsp;**final** 最终的,无法修改,被继承,被重写。可以修饰类,成员变量,和方法,修饰变量表示只能赋值**一次**.  
&emsp;&emsp;**volatile** 关键字用于标记字段可能会被多个线程同时访问，告诉编译器不要对这个字段进行优化，因为它的值可能会在其他线程中更改。这可以确保每次读取字段时都从内存中读取最新的值，而不是使用缓存中的旧值。  
&emsp;&emsp;**transient** 关键字用于告诉编译器在序列化时忽略字段。当对象被序列化时，**transient** 修饰的字段的值不会被保存。  
&emsp;&emsp;**native**本地方法，由本地其他语言代码实现  
&emsp;&emsp;**synchronized** 关键字用于实现线程同步，确保多个线程在访问共享资源时不会发生冲突。当一个线程访问一个对象的 **synchronized** 方法或代码块时，其他线程必须等待，直到该线程执行完成释放锁。  
&emsp;&emsp;**java.lang.Runnable**多线程接口。  
&emsp;&emsp;**args\[0\]**是命令行执行的第一个字符串  
```java
public static void main(String[] args) { }
```
&emsp;&emsp;**alt+/** 内容辅助  
&emsp;&emsp;在类内右键-生成Getter和Setter..  
```java
byte a[]="hello".getBytes();//使用平台的默认字符集将此String编码为字节序列，将结果存储到新的字节数组中。
```
&emsp;&emsp;浮点类型除以0会得到一个**无穷大值**,而整型数据除以0会出现一个**异常**;  
&emsp;&emsp;java中可以对**浮点数**求模。  
&emsp;&emsp;将**radix**进制的**s**转换为十进制数。  
&emsp;&emsp;**Integer.parseInt(String s\[,int radix=10\])**   
&emsp;&emsp;**radix**的范围是在2~36之间,超出范围会**抛异常**  
&emsp;&emsp;**s**的长度也**不能超出**7,否则也会抛异常。  
&emsp;&emsp;分割字符串:  
```java
String s = sc.nextLine();
String[] si=s.split(" ");//以空格为分隔符切分字符串s并分别赋值给si[]
for(int i=0;i<si.length;i++)
    System.out.println(si[i]);
```
## 位移\<\<\>\> \>\>\>
&emsp;&emsp;左移加0,右移加**符号位**  
&emsp;&emsp;例如**int a=30;a\>\>36;**  
&emsp;&emsp;那么**36**大于**int的位数**,要进行除**32**取余,即**a\>\>4**  
&emsp;&emsp;无符号右移运算符**\>\>\>**  
&emsp;&emsp;用来将一个数的各二进制位无符号右移若干位,与运算符**\>\>相同**的是移出的低位被舍弃,但**不同**的是最高位**补0**,如:  
&emsp;&emsp;**a=00110111**,则**a\>\>\>2** 结果为 **00001101**  
&emsp;&emsp;**b=11010011**,则**b\>\>\>2** 结果为 **00110100**  
## 基本数据类型
- 简单数据类型
  - 数值型
    - 整数类（byte(8)，short(16)，int(32)，long(64)）
    - 浮点类型（float(32)，double(64)）
  - 字符型（char(16)）
  - 布尔型（boolean(1)）
- 引用数据类型
  - 类（class）
  - 接口（interface）
  - 数组
## java关键字表

| abstract     | assert     | boolean | break     | byte      | continue   |
|--------------|------------|---------|-----------|-----------|------------|
| case         | catch      | char    | class     | const     | double     |
| default      | do         | else    | enum      | extends   | final      |
| finally      | float      | for     | goto      | if        | implements |
| import       | instanceof | int     | interface | long      | native     |
| new          | null       | package | private   | protected | public     |
| return       | short      | static  | strictfp  | super     | switch     |
| synchronized | this       | throw   | throws    | transient | try        |
| void         | volatile   | while   |           |           |            |

## label
```java
OUTER:  
//outer label  
for (int i = 0; i < 4; i++) {  
    INNER:  
    //inter label  
    for (int j = 0; j < 4; j++) {  
        System.out.print("轮次: " + (i*4+j+1));  
        if (i == 1) {  
            System.out.println(" 未执行完");  
            break INNER;//跳出内层for(),执行下一轮  
        }  
        System.out.println(" 完整执行");  
    }  
}
```
&emsp;&emsp;结果:  
```text
轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
轮次: 9 完整执行
轮次: 10 完整执行
轮次: 11 完整执行
轮次: 12 完整执行
轮次: 13 完整执行
轮次: 14 完整执行
轮次: 15 完整执行
轮次: 16 完整执行
```
```java
OUTER:  
//outer label  
for (int i = 0; i < 4; i++) {  
    INNER:  
    //inter label  
    for (int j = 0; j < 4; j++) {  
        System.out.print("轮次: " + (i*4+j+1));  
        if (i == 1) {  
            System.out.println(" 未执行完");  
            break OUTER;//跳出外层for(),执行下一个语句  
        }  
        System.out.println(" 完整执行");  
    }  
}
```
&emsp;&emsp;结果:  
```text
轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
```
# 方法说明
## Object.equals()
&emsp;&emsp;判断两个字符串是否相等在java中,用的是**equals();**  
&emsp;&emsp;例;A字符串和B和字符串比较:  
```java
String a="123",b="456";  
if (a.equals(b)) {  
    System.out.println("相等");  
}
```
**equals()**是**Object**的方法,所以对所有对象都适用。默认为:
```java
public boolean equals(Object obj) {  
    return (this == obj);  
}
```
**String.equals()**
```java
public boolean equals(Object anObject) {  
    if (this == anObject) {  
        return true;  
    }  
    if (anObject instanceof String) {  
        String aString = (String)anObject;  
        if (coder() == aString.coder()) {  
            return isLatin1() ? StringLatin1.equals(value, aString.value)  
                : StringUTF16.equals(value, aString.value);  
        }  
    }  
    return false;  
}
```
&emsp;&emsp;**String**类重写**equals**方法时,都做了些什么?  
&emsp;&emsp;首先判断如果是自己直接返回**true**,如果不是自己,判断参数是否为**String**类型,不是则返回**false**。之后就是比较字符串内容是否相等了。  
&emsp;&emsp;堆和常量池的区别:  
&emsp;&emsp;Java的存储空间：寄存器、栈、**堆**、静态存储区、**常量存储区(常量池)**、其他存储位置。  
&emsp;&emsp;此处重点介绍堆和常量存储区：  
&emsp;&emsp;**堆**：存储**new**的对象;  
&emsp;&emsp;**常量池**：用来存储**final static**、**String**的常量。  
&emsp;&emsp;**Object.equals**与**String.equals**的区别  
&emsp;&emsp;**Object.equals(==)**：**比较内存地址;**  
&emsp;&emsp;**String.equals: 比较内容,不管内存地址。**  
&emsp;&emsp;总结：  
&emsp;&emsp;**Object.equals**相等,**String.equals一定**相等;  
&emsp;&emsp;**String.equals**相等,**Object.equals不一定**相等。  
&emsp;&emsp;实例  
```java
// 维护在常量池里面  
String a="hello";  
String b="hello";  
// new出来的所有对象都在堆内存中  
// 只要是new出现来的都是新对象  
String c=new String("hello");  
String d=new String("hello");  
// 对比内存地址  
System.out.println("a==b = " + (a == b));  
System.out.println("a==c = " + (a == c));  
System.out.println("c==d = " + (c == d));  
// 对比内容  
System.out.println("a.equals(b) = " + a.equals(b));  
System.out.println("a.equals(c) = " + a.equals(c));  
System.out.println("c.equals(d) = " + c.equals(d));
```
&emsp;&emsp;结果:  
```text
a==b = true
a==c = false
c==d = false
a.equals(b) = true
a.equals(c) = true
c.equals(d) = true
```
&emsp;&emsp;**a**,**b**都是常量,**a**和**b**都是指向常量存储区中的常量**'hello'**,所以无论内容还是内存地址都是一样的,因此**a==b**以及**a.equals(b)**都是**true**;  
&emsp;&emsp;**c,d**都是变量,他们都是**new**出来的对象,里面存在两个**hello**变量,**c**和**d**分别指向自己的**hello**变量,所以**c**和**d**内容一样,但是内存地址不一样,因此**c==d**是**false**,但是**c.equals(d)**为**true**。  
## Random();
```java
import java.util.Random;
Random rand = new Random();  
int i = rand.nextInt(100);  
System.out.println("i = " + i);
```
&emsp;&emsp;返回一个**伪随机数**,它是取自此随机数生成器序列的、在 0(包括)和100(不包括)之间均匀分布的 **int** 值  
## Double.valueOf()
&emsp;&emsp;**Double.parseDouble**方法是把数字类型的字符串,转换成**double**类型  
&emsp;&emsp;**Double.valueOf**方法是把数字类型的字符串,转换成**Double**类型  
&emsp;&emsp;可以看出大体是没有任何区别,就是返回值的**类型**区别！  
```java
double a=Double.parseDouble("123");  
Double b=Double.valueOf("123");
```
&emsp;&emsp;**valueOf**方法在返回的时候**new Double()**,所以返回的是**Double**。  
## tostring()
&emsp;&emsp;**public String toString()**返回该对象的字符串表示。通常,**ToString**方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。  
```java
public class Test{  
    private int a,b;  
    public Test(int a, int b) { this.a = a;this.b = b; }  
    public static void main(String[] args) {  
        System.out.println(new Test(1,2));//默认调用toString()  
    }  
    @Override  
    public String toString() {  
        return "Test{a=" + a + ", b=" + b + '}';  
    }  
}
```
## intValue(),valueOf()
&emsp;&emsp;**intValue()**表示拆箱  
&emsp;&emsp;将对象类型转换为基础类型  
&emsp;&emsp;**valueOf()**表示装箱  
&emsp;&emsp;将基础类型转换为对象类型  
```java
int a = 1;  
Integer ao=Integer.valueOf(a);  
int aoi=ao.intValue();  
System.out.println(aoi);
```
# 多维数组
&emsp;&emsp;当使用**new**来创建多维数组时,不必指定每一维的大小而**只需要**指定**最左边**的维的大小就可以了。如果你指定了其中的某一维的大小,那么所有处于这一维**左边**的各维的大小**都要**指定。  
&emsp;&emsp;动态初始化  
```java
int[][][] a = new int[2][2][4];  
int[][] ab = new int[2][];
```
&emsp;&emsp;静态初始化  
```java
double[][][] a2 = {  
    {
        {1.1, 2.2}, {3.3, 4.4}
    },{
        {5.5, 6.6}, {7.7, 8.8}
    },{
        {9.9, 1.2}, {2.3, 3.4}
    },  
};  
System.out.println(Arrays.deepToString(a2));
```
&emsp;&emsp;多维数组也可以通过数组声明和初始化分开的动态初始化方法来对数组进行初始化  
```java
double[][][] a2 = new double[2][3][4];
```
&emsp;&emsp;java中多维数组的声明和初始化应按从高维到低维的顺序进行  
```java
int[][] a = new int[3][];  
a[0] = new int[2];  
a[1] = new int[4];  
a[2] = new int[3];
```
&emsp;&emsp;获取某维长度例子:  
```java
int[][] x = {
    {1, 2}, {3, 4, 5}, {6}, {}
};  
System.out.println(x[1].length);//3  
System.out.println(x.length);//4
```
&emsp;&emsp;对于**简单数据类型**的数组,当对其进行初始化时,会将对应的值赋给对应的各个数组元素。  
```java
int[] arr = new int[10];  
for(int i=0;i<10;i++){arr[i]=i;}  
System.out.println(Arrays.toString(arr));
```
&emsp;&emsp;在定义数组的时候,系统会给这个数组分配用于存放这个数组的内存空间：它会在**堆(Heap)**内存空间中给数组分配—个空间用于存放数组变量。  
&emsp;&emsp;**引用数据类型**数组在创建的时候也是首先给数组元素分配**內存空间**然后给这些数组元素一个默认的初始值**null.**  
&emsp;&emsp;在进行**引用数据类型**数组的初始化的时候,和**简单数据类型**数组的初始化有些**不同**,因为数组**本身是引用类**型,而现在**数组元素也是**引用类型,所以这个时候需要给数组元素**所引用**的对象**也分配**内存空间。  
```java
String[] arr = new String[10];  
arr[0] = new String("one");  
arr[1] = new String("two");  
arr[2] = new String("three");  
arr[3] = new String("Iou");  
arr[4] = new String("five");  
arr[5] = new String("six");  
arr[6] = new String("seven");  
arr[7] = new String("eight");  
arr[8] = new String("nine");  
arr[9] = new String("ten");  
System.out.println(Arrays.toString(arr));
```
&emsp;&emsp;数组**没有length()**这个方法,**String有length()**这个方法。  
```java
int[] a =new int[8];  
System.out.println(a.length);//8  
String s = "012345678";  
int length = s.length();  
System.out.println(length);//9
```
&emsp;&emsp;**s.charAt(n)**  
&emsp;&emsp;获取**字符串**的第**n+1**个字符  
```java
String s="hello world";  
System.out.println(s.charAt(0));//h
```
&emsp;&emsp;**import java.util.Arrays;**  
&emsp;&emsp;**Arrays.toString(arr)**  
&emsp;&emsp;格式化的将数组内容转为字符串  
```java
int[] b ={1,2,3,4,5};  
System.out.println(Arrays.toString(b));//[1, 2, 3, 4, 5]
```
&emsp;&emsp;**Arrays.sort(arr)**  
&emsp;&emsp;对数组进行**升序**排序  
```java
int[] a = {12, 3, 19, 2, 10, 13};  
System.out.println("before sort:");  
for (int value : a) System.out.print(value + " ");  
System.out.println();  
Arrays.sort(a);  
System.out.println("after sort:");  
for (int value : a) System.out.print(value + " ");
```
&emsp;&emsp;输出:  
```text
before sort:
12 3 19 2 10 13
after sort:
2 3 10 12 13 19
```
&emsp;&emsp;数组可直接相互**热拷贝**(a,b**相同指向**)  
```java
int[] a={1,2,3},b=a;  
System.out.println(Arrays.toString(a));//[1, 2, 3]  
a[0]=9;  
System.out.println(Arrays.toString(b));//[9, 2, 3]
```
&emsp;&emsp;冷拷贝  
&emsp;&emsp;**System.arraycopy(src, srcPos, dest, destPos, length)**  
&emsp;&emsp;从**src**\[**srcPos**\]开始复制**length**个元素到**dest**\[**destPos**\]的对应位置上.  

| 参数    | 说明                     |
|---------|--------------------------|
| src     | 源数组。                 |
| srcPos  | 源数组中的起始位置。     |
| dest    | 目标数组。               |
| destPos | 目标数据中的起始位置。   |
| ength   | 要复制的数组元素的数量。 |

```java
int[] a ={1,2,3,4,5,6,7,8,9,10};  
int[] b ={100,200,300,400,500,600,700,800,900,100};  
System.arraycopy(a,2,b,5,5);  
System.out.println("b = " + Arrays.toString(b));//b = [100, 200, 300, 400, 500, 3, 4, 5, 6, 7]
```
&emsp;&emsp;完整复制:  
```java
int[] a ={12, 3, 19, 2, 10, 13},b=new int[a.length];  
System.arraycopy(a,0,b,0,a.length);  
System.out.println(Arrays.toString(b));//[12, 3, 19, 2, 10, 13]
```
# 类
## 包
&emsp;&emsp;当一个大型程序交由数个不同的程序人员开发时,用到相同的类名是很有可能的, Java程序开发中为了避免这种情况,提供了一个包的概念(**package**) 。  
&emsp;&emsp;同一个包内的类名**不允许重复**,不同包内**可以有**相同名称的类。包允许将类组合成较小的单元,类似于文件夹;在包与包之间对于类的访问权限能提供更有力的约束。  
&emsp;&emsp;**多包javac生成**  
&emsp;&emsp;**javac –d . Demo.java**  
&emsp;&emsp;使用包很简单,通过关键字**package** 声明,作为Java源文件的**第一条语句**,指明该源文件定义的类所在的包。 package语句一般格式为;  
&emsp;&emsp;**package packageName;**  
&emsp;&emsp;包名可以是一个合法的标识符,也可以是若干个标识符加"**.**"分割而成,点号就是文件夹的分隔.  
&emsp;&emsp;**package tom;**  
&emsp;&emsp;**package sun.com.cn;**  
&emsp;&emsp;如果省略了**package**语句,类将保存在一个缺省的没有名称的包中;尽管缺省包很方便,但对于大型的程序,它是不恰当的;请尽量为自己编写的类定义具体的包。  
&emsp;&emsp;**import**  
&emsp;&emsp;在编写程序时,除了自己编写类外,还经常需要使用Java提供的许多类,这些类可能在不同的包中,使用**import**语句可以引入包中的类。  
&emsp;&emsp;在一个Java源文件中**可以**有**多个import**语句,它们在程序中的位置是有要求的,**必须**写在**package**语句和**源文件**的类定义**之间**。  
&emsp;&emsp;要引入java.util包中的Date类,使用**import java.util.Date;**  
&emsp;&emsp;如果要引入一个包中的全部类,则可以用星号来代替,如:**import java.awt.\*;**  
&emsp;&emsp;ITest .java  
```java
package com.aotmd.test.a1;  
public interface ITest {  
    int add(int x ,int y);  
    int sub(int x,int y);  
}
```
&emsp;&emsp;Test .java  
```java
package com.aotmd.test.a2;  
import com.aotmd.test.a1.ITest;  
public class Test implements ITest {  
    @Override  
    public int add(int x, int y) {  
        return x+y;  
    }  
    @Override  
    public int sub(int x, int y) {  
        return x-y;  
    }  
}
```
## 类
&emsp;&emsp;类是一个独立的单位,它有一个类名,其内部包括成员变量,用于描述属性;还包括类的成员方法,用于描述行为。因此,类也被认为是种抽象数据类型,这种数据类型不但包括数据,还包括方法。  
&emsp;&emsp;包含**main**方法的主类必須定义为**public**。  
&emsp;&emsp;在一个.java中可以有**多个**类,但只能有一个类为**public**修饰符,且该类的名称必须与文件名称相同.  
&emsp;&emsp;**class**为Java定义类的关键字,必须写在**修饰符**和**类名**中间,使用空格隔开.  
&emsp;&emsp;类的名字要符合Java的命名规范,同时名字要有意义能够反映出这个类的内容,**第一个字母一般为大写**.  
&emsp;&emsp;定义类的最终目的是要使用这些类,**创建**并操作某类的对象是使用该类的最主要手段。  
  
&emsp;&emsp;**创建类的实例对象**  
&emsp;&emsp;**类名对象名=new类名(\[参数1,参数2…\]);**  
&emsp;&emsp;例：  
```java
NoteTest t=new NoteTest();
```
  
&emsp;&emsp;**对象的使用**  
&emsp;&emsp;通过运算符“**.**”,对象可以实现对**自己变量**的访问及对**自己方法**的调用。  
&emsp;&emsp;子类可以在自己的**构造方法**中使用**super**关键字来调用父类的**含参数构造方法**,但这个调用语句**必须**是子类构造方法的**第一个**可执行语句。  
&emsp;&emsp;子类**无条件**地继承父类的无参构造方法。  
&emsp;&emsp;在创建子类的对象时,将先执行继承自**父类**的**无参构造方法**,然后再执行子类自己的**构造方法**。  
&emsp;&emsp;对于子类的构造方法说明,java 子类的构造方法都必须要**super()**吗？  
&emsp;&emsp;**不是必须,但是会自动调用super();**  
&emsp;&emsp;若不显示的进行**super**,则会自动**super()**;若此时父类没有**无参构造函数**则会出错.  
```java
class Father {  
    public Father(int a) {  
        System.out.println("父类带参构造函数");  
    }  
}  
class Son extends Father {  
    public Son() {  
        super(1);//必须  
        System.out.println("子类无参构造函数");  
    }  
}
```
  
&emsp;&emsp;**构造方法**  
&emsp;&emsp;**构造方法**是类中的一种特殊方法,是为对象初始化操作编写的方法,用它来定义对象的初始状态。每个类都有**构造方法**,它也是由**方法名**、**参数**和**方法体**组成。构造**方法名必须**与**类名相同**,它**没有返回值类型**,用户**不能直接调用**它,**只能**通过**new**对象实例化时由虚拟机**自动调用**.  
&emsp;&emsp;因为是由虚拟机来调用构造方法,所以构造方法一般应定义成 **public**  
&emsp;&emsp;**每个**对象在生成时都**必须**执行构造方法,而且只能执行一次;如果构造方法调用失败,那么对象也无法创建;  
&emsp;&emsp;在没有定义构造方法的情况下,类会**自动**产生一个无参数的默认构造方法,这个默认的构造方法什么都不做;一旦显式地定义了构造方法,默认的无参构造方法自动消失,若需要无参构造方法,则需要显示地重新定义。  
&emsp;&emsp;构造器是让编程人员在编写代码的时候可以更方便,少写点代码,还可以在构造器里面加入一些初始化代码.  
&emsp;&emsp;一个类可以有多个**构造方法**,**构造方法可以被重载**  
```java
class User {  
    public String uid,username,password;  
    public User() {}  
    public User(String uid, String username, String password) {  
        this.uid = uid;  
        this.username = username;  
        this.password = password;  
    }  
}
```
&emsp;&emsp;**this**就是指代(在局部访问全局变量时c++用的是**：：**)  
&emsp;&emsp;**this**关键字表示某个对象,**this可以**出现在**实例方法**和**构造方法**中,但**不可以**出现在**类方法**中.  
&emsp;&emsp;当**局部变量**和**成员变量**的名字**相同**时,成员变量就会被隐藏,这时如果想在成员方法中使用成员变量,就必须便用关键字**this**.  
&emsp;&emsp;**this.成员变量名**  
&emsp;&emsp;**this.成员方法名()**  
&emsp;&emsp;**this()**  
&emsp;&emsp;通过**this()**可以调用**构造方法**.  
&emsp;&emsp;在使用this调用构造方法的时候有以下规范:  
&emsp;&emsp;所有的**构造方法**是在对象实例化的时候被默认调用而且是在调用普通方法**之前**调用,所以使用"**this()**”**调用构造方法**的操作,一定要放在构造方法的**首行**,首行指第一条语句,且在一个构造方法里只能调用一个;  
&emsp;&emsp;如果一个类之中存在了多个构造方法的话,并且这些构造方法都使用了**this()**互相调用,那么至少要保留一个构造方法没有调用其他构造,以作为程序的出口。(不能陷入死循环)  
&emsp;&emsp;**this不能**用在**static**方法中！(java中类的方法池中都有一个隐含的参数**this**,他表示本对象的引用但是**static**方法是没有这个隐含参数的,因为**static**方法和类的实例无关它只在类装载的时候初始化,很多书都把静态变量称作类级变量)  
  
&emsp;&emsp;**类的封装**  
&emsp;&emsp;在设计一个类时,应该对成员变量的访问作出一些**限定**,不允许外界随意访问.这就需要实现类的封装。  
&emsp;&emsp;所谓类的封装是指在定义一个类时,将类中的属性**私有化**,即使用 **private**关键字来修饰,私有属性只能在它所在**类中**被访问,如果外界想要访问私有属性,需要使用**公有**方法进行间接调用,其中包括用于获取属性值的 getXxx方法和设置属性值的 setXxx方法。  

| 访问修饰符 | 本类 | 同包子类 | 同包非子类 | 不同包子类 | 不同包且非子类 |
|------------|------|----------|------------|------------|----------------|
| private    | 是   | 否       | 否         | 否         | 否             |
| 默认       | 是   | 是       | 是         | 否         | 否             |
| protected  | 是   | 是       | 是         | 是         | 否             |
| public     | 是   | 是       | 是         | 是         | 是             |

## 方法
&emsp;&emsp;**方法**是完成特定功能的、相对独立的程序段。**方法**一旦定义,就可以在不同的程序段中多次调用,故方法可以增强程序结构的清晰度,提高编程效率在Java程序中,**方法只能在类**中声明,格式如下:  
&emsp;&emsp;**\[修饰符\] 返回值类型 方法名 \[(参数表)\]{**  
&emsp;&emsp;**声明部分**  
&emsp;&emsp;**语句部分**  
&emsp;&emsp;**}**  
&emsp;&emsp;方法声明包括方法头和方法体2部分  

1. 修饰符可以是公共访问控制符**public**、私有访冋控制符**private**、保护访问控制符 **protected**等。  
2. 类型标识符反映方法完成其功能后返回的运算结果的数据类型。如果方法**没有返回值**,用**void**关键字指明。  
3. 方法名要符合标识符的命名规则,不要与Java中的关键字**重名**。  
4. 参数表指定在**调用**该方法时,应该传递的参数的个数和数据类型。  
5. 对于有返回值的方法,其方法体中至少有一条return语句。方法声明**不能嵌套**,即不能在方法中再声明其它的方法。  

&emsp;&emsp;对于有返回值的方法作为表达式或表达式的一部分来调用,其在表达式中出现的形式为：  
&emsp;&emsp;**方法名(\[实际参数表\])**  

```java
public class NoteTest {  
    static int act(){  
        return 1;  
    }  
    public static void main(String[] args) {  
        System.out.println("act() = " + act());  
    }  
}
```
&emsp;&emsp;在调用一个带有**形式参数**的方法时,必须为方法提供**实际参数**,完成实际参数与形式参数的结合,称为参数传递,然后用实际参数执行所调用的方法体。**在Java中**,参数传递是以**传值**的方式进行,即**将实际参数的值传递给形式参数.**  
&emsp;&emsp;**递归程序**  
```java
public class NoteTest {  
    static int test(int n){  
        if (n==1) return 1;  
        return test(n-1)*n;  
    }  
    public static void main(String[] args) {  
        System.out.println("5! = " + test(5));//5! = 120  
    }  
}
```
## 继承
&emsp;&emsp;最高层是**最普遍**的、**最一般**的情况,往下每一层都比上一层**更具体**,并包含有高层的特征,通过这样的层次结构使下层的类能自动享用上层类的特点和性质;  
&emsp;&emsp;继承其实就是自动地共享被继承类中成员属性和成员方法的机制。  
&emsp;&emsp;继承是利用现有的类创建新类的过程,现有的类称作基类(或父类),创建的新类称作派生类(子类)  
&emsp;&emsp;在Java中实现继承需要使用到**extends**关键字;  
> **\[访问修饰符\] class 派生类名 extends 基类名{**  
**成员列表**  
**}**  

&emsp;&emsp;如:  
```java
class Student extends User{}
```
&emsp;&emsp;**继承的作用:**  
- 引入继承,实现了代码重用;  
- 引入继承,实现了递增式的程序设计。  
- 继承是能自动传播代码和重用代码的有力工具;  
- 继承能够在某些比较一般的类的基础上建造、建立和扩充新类;  
- 能减少代码和数据的重复冗余度,并通过增强一致性来减少模块间的接口和界面,从而增强了程序的可维护性。  
- 能清晰地体现出类与类之间的层次结构关系。  
  
&emsp;&emsp;**继承的限制:**  
&emsp;&emsp;一个子类只能够继承一个父类,存在**单继承**局限.  
&emsp;&emsp;子类可以获得除**private**权限以外的所有父类属性,但是：  
&emsp;&emsp;1、在子类继承父类的时候,子类必须调用父类的构造方法。在继承关系之中,如果要实例化子类对象,会默认**先调用**父类构造方法,之后再调用子类构造方法,默认情况下,子类会找到父类之中的**无参构造方法**。  
&emsp;&emsp;2、如果父类**有**默认无参构造方法,子类实例化时会自动调用,但如果父类**没有**默认构造方法,即无形参构方法,则子类构造方法**必须**通过**super**调用父类的构造方法。  
  
&emsp;&emsp;**super**  
&emsp;&emsp;在**子类的构造方法**中,**super**关键字可以**显式**地调用父类的构造方法,用于将参数传递给它;需要注意的是：**该语句必须是子类构造方法的第一条语句。**  
&emsp;&emsp;其一般语法是：  
&emsp;&emsp;**super(实际参数);**  
&emsp;&emsp;如果父类和子类中有**同名成员**,在子类中默认访问是属于自己的那一个成员;  
&emsp;&emsp;**super**可以访问父类的**变量**或**方法**但已实例化的不会变.  
&emsp;&emsp;**super**关键字可以明确地指定要访问父类中的成员;前提条件是：父类中的该成员**不是private**的。  
&emsp;&emsp;在该种用法中**不需要**像**构造方法**中一样需要限定为第一条语句.  
&emsp;&emsp;其一般语法是：  
&emsp;&emsp;**super.成员名;**  
&emsp;&emsp;**super.方法名;**  
```java
class User {  
    public String uid;  
    public User(String uid) {  
        this.uid = uid;  
    }  
    @Override  
    public String toString() {  
        return "User{uid='" + uid + '\\' + '}';  
    }  
}  
class Student extends User{  
    public String username;  
    public Student(String uid,String username) {  
        super(uid);//必须,否则自动调用super(),然后报错  
        this.username=username;  
    }  
    @Override  
    public String toString() {  
        String s="";  
        s=super.toString()+"\nStudent{uid='" + uid + '\\' + ", username='" + username + '\\' + '}';;  
        return s;  
    }  
    public static void main(String[] args) {  
        System.out.println(new Student("1", "张三"));  
    }  
}
```
&emsp;&emsp;**final**  
&emsp;&emsp;如果一个类**不允许**其子类**覆盖**某个方法,则可以把这个**方法**声明为**final**方法。  
&emsp;&emsp;使用**final**方法的原因有二：  
&emsp;&emsp;第一、把方法锁定,防止任何继承类修改它的意义和实现。  
&emsp;&emsp;第二、高效。编译器在遇到调用**final**方法时候会转入内嵌机制,大大提高执行效率。  
&emsp;&emsp;你肯定会问,为什么不让子类重写,说个通俗点的例子。  
&emsp;&emsp;比如一个Father类有一个JiQiao()方法,假如这个JiQiao()方法是一个父亲做某种事的正确技巧,他希望他的子孙类可以继承使用,但不要扭曲此技巧,所以使用**final**修饰保护。  
&emsp;&emsp;你可以不用,但并不能代表它不可以存在,因为还是会有用到的时候。  
  
&emsp;&emsp;**实例方法**  
&emsp;&emsp;实例方法就是对象方法,和类方法的区别是,类方法有**static**关键字,**不需要实例**,**直接类名调用**  

```java
public class NoteTest {  
    public static int a=1;//类属性  
    public int b=2;//实例属性  
    public void f1(){};//实例方法  
    public static void f2() {}//类方法  
    public static void main(String args[]){  
        NoteTest noteTest=new NoteTest();  
        System.out.println(noteTest.b);  
        noteTest.f1();  
        System.out.println(NoteTest.a);  
        NoteTest.f2();  
    }  
}
```
## 多态
&emsp;&emsp;多态是面向对象的最后一个主要特征,它本身主要分为两个方面：  
&emsp;&emsp;方法的多态性：**重载**与**覆写**  
&emsp;&emsp;**重载**：同一个方法名称,根据不同的参数类型及个数可以完成不同的功能;  
&emsp;&emsp;**覆写**：同一个方法,根据操作的子类不同,所完成的功能也不同。  
&emsp;&emsp;对象的多态性：父子类对象的转换。  
&emsp;&emsp;**向上转型**：子类对象变为父类对象,格式：**父类 父类对象=子类实例**,自动;  
&emsp;&emsp;**向下转型**：父类对象变为子类对象,格式：**子类 子类对象=(子类)父类实例**,强制;  
  
&emsp;&emsp;**方法覆盖**  
&emsp;&emsp;在类的继承体系结构中,如果子类中出现了与父类中**相同**原型的方法,那么认为子类中的方法**覆盖**了父类中的方法(也称为方法重写);通过**子类**的实例调用被覆盖的方法时,将**总是**调用子类中的方法,而父类中的方法将被**隐藏**。  
```java
package com.aotmd.test;  
public class NoteTest {//用于容纳main方法  
    public static void main(String[] args){  
        ParentClass parobj=new ParentClass();  
        parobj.fun();//父类的实例调用此方法  
        ChildClass chiobj=new ChildClass();  
        chiobj.fun();//子类的实例调用此方法  
    }  
}  
class ParentClass{//定义父类  
    public void fun(){  
        System.out.println("这是父类中的方法。");  
    }  
}  
class ChildClass extends ParentClass {//子类继承于父类  
    public void fun(){//子类覆盖父类中的方法  
        System.out.println("这是子类中的方法。");  
    }  
}
```
&emsp;&emsp;**区分方法覆盖和方法重载**  
&emsp;&emsp;方法覆盖(重写)和方法重载是两个极易混淆的概念,必须严格区分;  
&emsp;&emsp;方法覆盖出现的前提条件之一是**必须有继承**发生的情况下,而且要求父类和子类中的方法**必须同原型**;  
&emsp;&emsp;方法重载时,继承并不是必需的,它**只要求方法名称相同**,而参数列表则**必须不同**,换言之,各方法的**原型**其实是**不同**的。  
&emsp;&emsp;**引用转型**  
&emsp;&emsp;**基类的引用可以指向派生类的对象**,如：  
&emsp;&emsp;BaseClass obj=new DerivedClass();这样的语句是合法的;  
&emsp;&emsp;但是**派生类的引用则不可以指向基类的对象**,如：  
&emsp;&emsp;DerivedClass obj=new BaseClass();这样的语句将引发错误。  
&emsp;&emsp;既然基类的引用可以指向派生类的实例,如果基类和派生类中存在方法覆盖的情况,那么通过基类的引用将会调用到哪个类中的方法呢？  
&emsp;&emsp;如果基类和派生类中存在方法覆盖（重写）的情况，通过基类的引用调用方法时会调用派生类中的方法，即调用被重写的方法。这是因为在运行时，Java 虚拟机会动态地确定对象的实际类型，并调用该实际类型中的方法。这种行为称为动态方法调度（Dynamic Method Dispatch）。  
&emsp;&emsp;定义一个抽象类**shape**应以计算面积,从中派生出计算长方形,梯形,圆形面积的派生类,程序中通过基类有指针来调用派生类中的虚函数,计算不同形状的面积。派生类就是子类  
&emsp;&emsp;**-----------java(由c++修改)----------**  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        Shape pShape;  
        Rect rect = new Rect(3, 5);  
        Circle circle = new Circle(4);  
        Trapezium trapezium = new Trapezium(3.5, 5.5, 7);  
        pShape = rect;  
        System.out.println("矩形面积:" + pShape.Area());  
        pShape = circle;  
        System.out.println("圆形面积:" + pShape.Area());  
        pShape = trapezium;  
        System.out.println("梯形面积:" + pShape.Area());  
    }  
}  
abstract class Shape //抽象基类  
{  
    protected double s;  
    public  
        //Shape(){s=0;} //构造函数  
        abstract double Area();  
    //virtual double Area()=0; //面积计算函数(纯虚函数)  
}  
class Rect extends Shape //派生类——矩形  
{  
    private double width;  
    private double height;  
    public Rect(double w, double h) //构造函数  
    {  
        width = w; //宽  
        height = h; //高  
    }  
    public double Area() //面积计算函数(实现)  
    {  
        s = width * height;  
        return s;  
    }  
}  
class Circle extends Shape //派生类——圆形  
{  
    private double radius; //半径  
    public Circle(double r) {  
        radius = r;  
    } //构造函数  
    public double Area() //面积计算函数(实现)  
    {  
        s = 3.14159 * radius * radius;  
        return s;  
    }  
}  
class Trapezium extends Shape //派生类——梯形  
{  
    private double top, bottom, height; //上底//下底//高  
    public Trapezium(double t, double b, double h) //构造函数  
    {  
        top = t;  
        bottom = b;  
        height = h;  
    }  
    public double Area() //面积计算函数(实现)  
    {  
        s = (top + bottom) * height / 2;  
        return s;  
    }  
}
```
&emsp;&emsp;**-------------------------c++-----------------------**  
```c++
#include <iostream>
using namespace std;
class Shape //抽象基类
{
protected:
    double s;
public:
    //Shape(){s=0;} //构造函数
    virtual double Area() = 0; //面积计算函数(纯虚函数)
};
class Rect : public Shape //派生类——矩形
{
private:
    double width;
    double height;
public:
    Rect(double w, double h) //构造函数
    {
        width = w;  //宽
        height = h; //高
    }
    double Area() //面积计算函数(实现)
    {
        s = width * height;
        return s;
    }
};
class Circle : public Shape //派生类——圆形
{
private:
    double radius; //半径
public:
    Circle(double r) { radius = r; } //构造函数
    double Area()                    //面积计算函数(实现)
    {
        s = 3.14159 * radius * radius;
        return s;
    }
};
class Trapezium : public Shape //派生类——梯形
{
private:
    double top;    //上底
    double bottom; //下底
    double height; //高
public:
    Trapezium(double t, double b, double h) //构造函数
    {
        top = t;
        bottom = b;
        height = h;
    }
    double Area() //面积计算函数(实现)
    {
        s = (top + bottom) * height / 2;
        return s;
    }
};
main()
{
    Shape *pShape; //声明抽象基类指针
    Rect rect(3, 5);
    Circle circle(4);
    Trapezium trapezium(3.5, 5.5, 7);
    pShape = &rect; //抽象基类指针指向矩形
    cout << "矩形面积;" << pShape->Area() << endl;
    pShape = &circle; //抽象基类指针指向圆形
    cout << "圆形面积;" << pShape->Area() << endl;
    pShape = &trapezium; //抽象基类指针指向梯形
    cout << "梯形面积;" << pShape->Area() << endl;
}
```
&emsp;&emsp;java:  
&emsp;&emsp;抽象基类定义;  
&emsp;&emsp;**abstract class Shape{}**  
&emsp;&emsp;派生类;  
&emsp;&emsp;**class Rect extends Shape{}**  
&emsp;&emsp;c++:  
&emsp;&emsp;抽象基类定义;  
&emsp;&emsp;**class Shape{}**  
&emsp;&emsp;派生类;  
&emsp;&emsp;**class Rect:public Shape{}**  
&emsp;&emsp;从上例中可以看出,父类的引用指向哪个类的实例就调用哪个类中的方法;同样是使用父类的引用,调用同一个名称的方法,却可以得到不同的调用结果,这就是Java中的多态,即：同一方法,多种形态;实际上多态包括**动态多态**和**静态多态**。  
&emsp;&emsp;**静态多态**  
&emsp;&emsp;·静态多态也称为编译时多态,即在编译时决定调用哪个方法;  
&emsp;&emsp;·静态多态一般是指**方法重载**;  
&emsp;&emsp;·只要构成了方法重载,就可以认为形成了静态多态的条件;  
&emsp;&emsp;·静态多态与是否发生继承没有必然联系。  
&emsp;&emsp;**动态多态**  
&emsp;&emsp;动态多态也称为运行时多态,即在运行时才能确定调用哪个方法;形成动态多态必须具体以下条件：  
&emsp;&emsp;必须要有继承的情况存在;在继承中必须要有**方法覆盖**;必须由基类的引用指向派生类的实例,并且通过基类的引用调用被覆盖的方法;由上述条件可以看出,继承是实现动态多态的首要前提。  
&emsp;&emsp;实例  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        Person p=new Person("小张", 18);  
        System.out.println(p.getPerson());  
        p=new Student("小李", 20,"中国工学院","一年级");  
        System.out.println(p.getPerson());  
        p=new GraduateStudent("小花", 22,"中国工学院","一年级","李");  
        System.out.println(p.getPerson());  
    }  
}  
class Person{  
    protected String name;  
    protected int age;  
    public Person(String name, int age) {  
        super();  
        this.name = name;  
        this.age = age;  
    }  
    public String getPerson(){  
        return "姓名:"+name+" 年龄:"+age;  
    }  
}  
class Student extends Person{  
    protected String school;  
    protected String grade;  
    public Student(String name, int age, String school, String grade) {  
        super(name, age);  
        this.school = school;  
        this.grade = grade;  
    }  
    public String getPerson() {  
        return super.getPerson()+" 学校:"+school+" 班级:"+age;  
    }  
}  
class GraduateStudent extends Student{  
    protected String mentor;  
    public GraduateStudent(String name, int age, String school, String grade, String mentor) {  
        super(name, age, school, grade);  
        this.mentor = mentor;  
    }  
    public String getPerson() {  
        return super.getPerson()+" 导师:"+mentor;  
    }  
}
```
&emsp;&emsp;输出:  
```text
姓名:小张 年龄:18
姓名:小李 年龄:20 学校:中国工学院 班级:20
姓名:小花 年龄:22 学校:中国工学院 班级:22 导师:李
```
## 接口
&emsp;&emsp;接口关键字:**interface**  
&emsp;&emsp;如果某个类中的所有方法都是抽象方法,那么可以考虑将该类定义为接口;  
&emsp;&emsp;Java中的接口是一个特殊的抽象类,可以利用接口实现多态,同时接口也弥补了Java单一继承的弱点。一般便用接口声明**方法或常量**,接口中的方法**只能**是声明,**不能是具体的实现**。  
&emsp;&emsp;接口就是某个事物对外提供的一些功能的**申明**  
&emsp;&emsp;语法格式如下:  

> **\[修饰符\] interface 接口名\[extends父接口名列表\]{**  
> **\[public\] \[static\] \[final\]常量;**  
> **\[public\] \[abstract\]方法;**  
> **}**  

| 名词                    | 解释                                                                                          |
|-------------------------|-----------------------------------------------------------------------------------------------|
| 修饰符                  | 可选,甩于指定接口的访问权限,可选值为**public**。如果省略则使用默认的访问权限。                |
| 接口名                  | 必选,用于指定接口的名称,接口名必须是合法的Java标识符。一般情况下,要求首字母大写。             |
| **extends**父接口名列表 | 可选参数,用于指定要定义的接口继承于哪个父接口。当使用**extends**关键字时,父接口名为必选参数。 |
| 方法                    | 接口中的方法**只有定义**而没有被实现。                                                        |

&emsp;&emsp;与抽象类相似,接口同样**不可以**实例化,只能用于实现;如果某类要**实现接口**,则使用**implements**关键字.  
&emsp;&emsp;**\[访问权限\]class类名implements接口名{**  
&emsp;&emsp;**成员列表**  
&emsp;&emsp;**｝**  

```java
public class MyClass implements IMyInterface {}
```
&emsp;&emsp;如果有一个以上接口被实现,则用**逗号**隔开接口名称,如下所示;  
```java
class demo implements myinterface,myconstants{}
```
&emsp;&emsp;接口调用  
```java
package com.aotmd.test;  
public class NoteTest {  
    public static void main(String[] args) {  
        ICalc ICalc4 =new Calc();  
        System.out.println(ICalc4.add(1,2));  
    }  
}  
interface ICalc {  
    int add(int x, int y);  
    int sub(int x, int y);  
}  
class Calc implements ICalc {  
    public int add(int x, int y) { return x+y; }  
    public int sub(int x, int y) { return x-y; }  
}
```
&emsp;&emsp;**接口**与**抽象类**的共同点如下;  
- **接口**与**抽象类**都**不能**被**实例化**,能被其他类实现和继承
- **接口**和**抽象类**中**都可以包含**抽象方法,实现**接口**或继承**抽象类**的普通子类都必须实现这些抽象方法。

&emsp;&emsp;**接口**与**抽象类**的用法差别如下;  
- **接口**中**只能**包含**抽象方法**,**不能**包含普通方法;**抽象类**中**可以**包含普通方法。
- **接口**中**不能**定义**静态方法**;**抽象类**中**可以**定义静态方法。
- **接口**中**只能**定义**静态常量属性**,**不能**定义**普通属性**;**抽象类**里**可以**定义静态常量属性,也**可以**定义普通属性。
- **接口不能**包含构造器;**抽象类可以**包含构造器,**抽象类**里的构造器为了让其子类调用并完成初始化操作。
- **接口**中**不能**包含初始化块,但**抽象类可以**包含初始化块。
- 一个类最多只能有一个直接父类,包括**抽象类**;但是一个类可以实现多个**接口**。

# 异常
&emsp;&emsp;异常处理是通过5个关键字来实现的：  

| 关键词  | 说明                                  |
|---------|---------------------------------------|
| try     | 执行可能产生异常的代码                |
| catch   | 捕获异常                              |
| throw   | 抛出异常,手动抛出异常                 |
| throws  | 声明异常,声明方法可能要抛出的各种异常 |
| finally | 无论是否发生异常代码总能执行          |

&emsp;&emsp;Java语言中的异常也是通过一个对象来表示的,程序运行时抛出的异常实际上就是一个异常对象。该对象中不仅封装了错误信息,还提供了些处理方法。  
&emsp;&emsp;**String getMessage()**在**Exception**类中定义的方法,被继承到**所有**的异常类中,用于获得与异常相关的描述信息。  
&emsp;&emsp;**void printstackTrace()**在**Exception**类中定义的方法,用于在控制台上显示有关异常的信息,不但有异常的原因,还涉及产生异常的代码行。  
&emsp;&emsp;**try{**  
&emsp;&emsp;**//可能发生异常的代码段**  
&emsp;&emsp;**} catch (异常类型 e){**  
&emsp;&emsp;**//对异常进行处理的代码段**  
&emsp;&emsp;**}finally{**  
&emsp;&emsp;**//始终执行的代码段**  
&emsp;&emsp;**}**  
&emsp;&emsp;**//其他代码段**  
  
&emsp;&emsp;在**try**发生异常则程序跳到**catch**块中执行,否则不执行**catch**块语句;**catch**块代码处理完后,程序仍会向下执行而不会异常终止。发生异常语句后面的代码**不会被执行**;  
&emsp;&emsp;如果希望语句无论是否发生异常都要执行,可在**try..catch**句后添加**finally**块;无论是否发生异常, **finally**块都将**执行**;**finally**块是可选的,可视具体情况决定是否添加;**finally**块必须和**try**块一起使用,不能单独存在。  
&emsp;&emsp;如果某个函数中的代码有可能引发异常,可以使用**try/catch**块进行处理,这种处理方式成为"内部处理"  
&emsp;&emsp;如果不方便在函数内部进行处理,也可以将异常往函数外部传递,这就要使用到关键字**throws**;**throws**用于将函数内部产生的异常抛给主调函数;  
  
&emsp;&emsp;抛出异常:  
&emsp;&emsp;**返回值类型 函数名(参数列表) throws异常类型｛代码段｝**  
&emsp;&emsp;当调用带有**throws**关键字的函数时,则**必须**放在**try/catch**块中进行监控,否则编译器将会报错;  
  
&emsp;&emsp;有时候,在**try**块中的代码段将有可能产生**多种**不同类型的**异常**,而我们又需要针对不同的异常类型进行不同的处理方式,那么我们就可以**使用多重catch**块,来分别捕获不同类型的异常  
&emsp;&emsp;虽然多重**catch**块可以同时监视多个不同类型的异常,但是**try**块中一旦有某个异常产生,程序就会跳转到与之异常类型**最匹配**的**catch**块中执行,然后执行**finally**块(如果有**finally**块的话)或之后的语句;也就是说,多重**catch**块只会捕捉到**最先产生的异常**,而不是把所有的异常全部捕捉完;即：不论有多少个**catch**块,**最多**只会执行其中的**一个**;请注意**catch**块的书写顺序：类层次**越低的越往上写,越高的越往下写**。  
&emsp;&emsp;有时候,整个语句块可以产生异常,而其中的某个部分又可能产生另外的异常,而我们需要分别进行处理;这样,就可以通过嵌套**try/catch**块来完成;嵌套**try/catc**h块就是在一个**try/catch**块中包含有另外的**try/catch**块。  
  
&emsp;&emsp;**异常类型**  
&emsp;&emsp;产生异常的原因多种多样,大致有：系统资源不可用：如内存分配失败,文件打开失败,数据源连接失败等等;程序控制不当：如被零除,负数开方,数组下标越界等等。  
&emsp;&emsp;当异常发生时,程序一般会作出如下反应：发生异常的部分产生系统定义的错误信息;程序意外终止,并将控制权返回操作系统;程序中所有已分配资源的状态保持不变,这样将会导致资源泄漏。那么我们就必须对有可能产生的异常进行处理。  
&emsp;&emsp;自定义异常类一般继承于**Exception**类;**Exception**类是绝大部分异常类的父类,在异常类型不明的情况下,可以都认为是**Exception**.  
&emsp;&emsp;**Throwable**有两个直接子类,它们是：  
&emsp;&emsp;**Error**类：称为**错误类**,通常是指**系统**中的**内部错误**以及资源耗尽的错误,是比较严重的,仅靠修改程序本身是**不能**恢复执行的  
&emsp;&emsp;**Exception**类：称为**异常类**,表示程序本身**可以**处理的错误。在开发Java程序过程中进行的异常处理,主要就是针对**Exception**类及其子类的异常处理。  
&emsp;&emsp;Java 根据各个类库也定义了一些其他的异常,下面的表中列出了 Java 的非检查性异常。  

| 异常                            | 描述                                                                                                                |
|---------------------------------|---------------------------------------------------------------------------------------------------------------------|
| ArithmeticException             | 当出现异常的运算条件时,抛出此异常。例如,一个整数"除以零"时,抛出此类的一个实例。                                     |
| ArrayIndexOutOfBoundsException  | 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小,则该索引为非法索引。                                 |
| ArrayStoreException             | 试图将错误类型的对象存储到一个对象数组时抛出的异常。                                                                |
| ClassCastException              | 当试图将对象强制转换为不是实例的子类时,抛出该异常。                                                                 |
| IllegalArgumentException        | 抛出的异常表明向方法传递了一个不合法或不正确的参数。                                                                |
| IllegalMonitorStateException    | 抛出的异常表明某一线程已经试图等待对象的监视器,或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。     |
| IllegalStateException           | 在非法或不适当的时间调用方法时产生的信号。换句话说,即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 |
| IllegalThreadStateException     | 线程没有处于请求操作所要求的适当状态时抛出的异常。                                                                  |
| IndexOutOfBoundsException       | 指示某排序索引(例如对数组、字符串或向量的排序)超出范围时抛出。                                                      |
| NegativeArraySizeException      | 如果应用程序试图创建大小为负的数组,则抛出该异常。                                                                   |
| NullPointerException            | 当应用程序试图在需要对象的地方使用 null 时,抛出该异常                                                               |
| NumberFormatException           | 当应用程序试图将字符串转换成一种数值类型,但该字符串不能转换为适当格式时,抛出该异常。                                |
| SecurityException               | 由安全管理器抛出的异常,指示存在安全侵犯。                                                                           |
| StringIndexOutOfBoundsException | 此异常由 String 方法抛出,指示索引或者为负,或者超出字符串的大小。                                                    |
| UnsupportedOperationException   | 当不支持请求的操作时,抛出该异常。                                                                                   |

&emsp;&emsp;下面的表中列出了 Java 定义在 **java.lang** 包中的检查性异常类。  

| 异常                       | 描述                                                                                                                           |
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| ClassNotFoundException     | 应用程序试图加载类时,找不到相应的类,抛出该异常。                                                                               |
| CloneNotSupportedException | 当调用 Object 类中的 clone 方法克隆对象,但该对象的类无法实现 Cloneable 接口时,抛出该异常。                                     |
| IllegalAccessException     | 拒绝访问一个类的时候,抛出该异常。                                                                                              |
| InstantiationException     | 当试图使用 Class 类中的 newInstance 方法创建一个类的实例,而指定的类对象因为是一个接口或是一个抽象类而无法实例化时,抛出该异常。 |
| InterruptedException       | 一个线程被另一个线程中断,抛出该异常。                                                                                          |
| NoSuchFieldException       | 请求的变量不存在                                                                                                               |
| NoSuchMethodException      | 请求的方法不存在                                                                                                               |

&emsp;&emsp;**throws**  
&emsp;&emsp;定义一个方法的时候可以使用**throws**关键字声明。使用**throws**关键字声明的方法表示此方法不处理异常,而交给方法**调用处**进行处理。当调用带有**throws**关键字的函数时,则**必须**放在**try/catch**块中进行,否编器将会报错;同样地,如果不便进行监控处理,也可以继续使用**throws**往外抛出异常但不太推荐此种做法。(外抛不需要**try/catch**)  
&emsp;&emsp;**throws**关键字格式：  
&emsp;&emsp;**public 返回值类型 方法名称(参数列表)*throws* 异常类{};**  
&emsp;&emsp;假设定义一个除法,对于除法操作可能出现异常,可能不会。所以对于这种方法最好将它使用**throws**关键字声明,一旦出现异常,则应该交给调用处处理。  
```java
class Math {  
    public int div(int i, int j) throws Exception {// 定义除法操作,如果有异常,则交给被调用处处理  
        return i / j;// 计算,但是此处有可能出现异常  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        Math m = new Math();// 实例化Math类对象  
        try {  
            System.out.println("除法操作：" + m.div(10, 0));  
        } catch (Exception e) {  
            e.printStackTrace();// 打印异常  
        }  
    }  
}
```
&emsp;&emsp;因为**div**使用了**throws**关键字声明,所以调用此方法的时候,方法**必须进行异常处理**。  
```java
class Math {  
    public int div(int i, int j) throws Exception {// 定义除法操作,如果有异常,则交给被调用处处理  
        return i / j;// 计算,但是此处有可能出现异常  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) throws Exception {  
        Math m = new Math();// 实例化Math类对象  
        System.out.println("除法操作：" + m.div(10, 0));  
    }  
}
```
&emsp;&emsp;在本程序中,主方法不处理任何异常,而交给JAVA中最大头**JVM**,所以如果在主方法使用了**throws**关键字,则表示一切异常交给**JVM**进行处理。默认处理方式也是**JVM**完成。  
&emsp;&emsp;**throw**  
&emsp;&emsp;**throw new Exception("自己抛着玩的。")**  
&emsp;&emsp;手动抛出一个异常,抛出一个异常类的实例化对象.执行流程将在**throw**语句后立即停止,转而寻找与之类型相匹配的**catch**块  
&emsp;&emsp;在异常处理中,**try**语句捕获的是一个异常对象,那么此异常对象也可以自己抛出。  
```java
public class NoteTest {  
    public static void main(String[] args) throws Exception {  
        throw new Exception("自己抛着玩的。");// 抛出异常的实例化对象  
    }  
}
```
&emsp;&emsp;在一般开发中**try,catch,finally,throw,throws**联合使用的情况是最多的。  
&emsp;&emsp;例如,现在要使用一个相除的方法,但是在操作之前必须打印“运算开始”的信息,结束之后必须打印“异常结束”。如果有异常,需要把异常交给异常调用处处理。面对这样要求,必须全部使用以上关键字。  
```java
class Math {  
    public int div(int i, int j) throws Exception { // 定义除法操作,如果有异常,则交给被调用处处理  
        System.out.println("***** 计算开始 *****");  
        int temp = i / j; // 计算,但是此处有可能出现异常  
        System.out.println("***** 计算结束 *****");  
        return temp;  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        Math m = new Math();  
        try {  
            System.out.println("除法操作：" + m.div(10, 0));  
        } catch (Exception e) {  
            System.out.println("异常产生：" + e);  
            }  
    }  
    }
```
&emsp;&emsp;运行结果：  
```text
***** 计算开始 *****
异常产生：java.lang.ArithmeticException: / by zero
```
&emsp;&emsp;以上没有计算结束,因为没有异常发生了,直接中断程序操作。所以要抛出异常对象,给方法调用处处理,使用**throw**关键字。  
```java
class Math {  
    public int div(int i, int j) throws Exception { // 定义除法操作,如果有异常,则交给被调用处处理  
        System.out.println("***** 计算开始 *****");  
        int temp = 0; // 计算,但是此处有可能出现异常  
        try {  
            temp = i / j;  
        } catch (Exception e) {  
            throw e;  
        } finally {  
            System.out.println("***** 计算结束 *****");  
        }  
        return temp;  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        Math m = new Math();  
        try {  
            System.out.println("除法操作：" + m.div(10, 0));  
        } catch (Exception e) {  
            System.out.println("异常产生：" + e);  
        }  
    }  
}
```
&emsp;&emsp;**Exception**与**runtimeException**的区别是面试中经常出现的问题。  
```java
String str = "123" ; // 定义字符串,全部由数字组成  
int temp = Integer.parseInt(str) ; // 将字符串变为int类型  
System.out.println(temp * temp) ; // 计算乘方
```
&emsp;&emsp;parseInt()的定义格式：  
```java
public static int parseInt(String s) throws NumberFormatException
```
&emsp;&emsp;此方法明明使用了**throws**关键字抛出异常,为什么不用处理,也可以编译通过？  
&emsp;&emsp;在JAVA异常处理机制中:  
- 如果抛出的是**EXception**的类型,则**必须**进行**try ..catch**进行处理。  
- 如果抛出的是**RuntimeException**的类型,则**可以不使用try..catch**处理,一旦发生异常之后,将由JVM处理。  

&emsp;&emsp;为了保证程序的健康性,在有可能出现异常的时候还是老实使用**try..catch**处理。  
  
&emsp;&emsp;**自定义异常类。**  
&emsp;&emsp;只需要继承**Exception**类就可以自定义异常类。因为JAVA中提供的都是标准异常类(包括一些异常信息),如果需要自己想要的异常信息就可以自定义异常类。**Exception**类是绝大部分异常类的父类,在异常类型不明的情况下,可以都认为是**Exception**.  
```java
class MyException extends Exception {// 自定义异常类,继承Exception类  
    public MyException(String msg) {  
        super(msg);// 调用Exception类中有一个参数的构造方法,传递错误信息  
    }  
}  
public class NoteTest {  
    public static void main(String args[]) {  
        try {  
            throw new MyException("自定义异常。");// 抛出异常  
        } catch (Exception e) {  
            System.out.println(e);//打印错误信息:MyException: 自定义异常。  
        }  
    }  
}
```
&emsp;&emsp;**总结**  
&emsp;&emsp;**throw**与**throws**关键字联合使用问题。  
&emsp;&emsp;**throw**：抛出异常。  
&emsp;&emsp;**throws**：在方法声明处使用,表示此方法不处理异常,而在调用此方法处处理异常。  
&emsp;&emsp;**Exception**是必须处理的,而**RuntimeException**异常是可以不处理的。但是为了保证程序正常运行,最好处理。  
&emsp;&emsp;如果自定义异常,直接继承异常即可。  
# 文件 
## I/O流概述
&emsp;&emsp;**文件**是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。  
&emsp;&emsp;“流”是一个抽象的概念,它代表任何有能力输出数据的数据源对象或者是有能力接收数据的接收端对象。  
&emsp;&emsp;**java.io**包中最重要的就是五个类和一个接口：  
&emsp;&emsp;**File OutputStream InputStream Reader Writer**  
&emsp;&emsp;**serializable** 数据的序列化接口，可以按照流式序列化保存对象。  
## I/O流的分类
&emsp;&emsp;&nbsp;  
### 按照不同的方式,将流分为不同的类型按数据流动方向
&emsp;&emsp;输入流：只能从中读取字节数据,而不能向其写出数据  
&emsp;&emsp;输出流：只能向其写入字节数据,而不能从中读取数据  
&emsp;&emsp;输入流和输出流分别通过**抽象类InputStream和 OutputStream**来实现  
### 按照流所处理的数据类型
&emsp;&emsp;字节流：用于处理字节数据  
&emsp;&emsp;字节流是按字节读/写二进制数据字节流有两个基本的类：  
&emsp;&emsp;**InputStream**类**OutputStream**类  
&emsp;&emsp;**InputStream**类用于处理字节输入流,**OutputStream**类用于处理字节输出流。  
&emsp;&emsp;字符流：用于处理 Unicode字符数据  
&emsp;&emsp;字符流的输入/输出数据是字符码即Unicode字符。  
&emsp;&emsp;字符流有两个基本类：**Reader**类和 **Writer**类。**Reader**类用于处理字符输入流,**Writer**类用于处理字符输出流  
### 按照流所处理的源
&emsp;&emsp;节点流(低级流)：向一个特定的IO设备读/写数据的流  
&emsp;&emsp;处理流(高级流)：对已存在的流进行连接和封装的流  
&emsp;&emsp;处理流是“处理流的流”,它用来处理其他的流。  
### 说明
&emsp;&emsp;所有从 **InputStream**或 **Reader**派生的类都有一个基本的**read()**方法,用读取的字节或者读取字节数组;  
&emsp;&emsp;所有从 **OutputStream**或 **Writer**派生的类都有一个基本的 **write()**方法,用于写入单一的字节或者整个字节数组。  
&emsp;&emsp;但在实际应用中我们一般很少使用单一的流类来产生输入输出流,而是使用这两个方法绐其他的流类提供数锯,也就是说,通过多个流对象的连接和封装使用实际的流。  
## File

| 构造函数                          | 说明                                                                            |
|-----------------------------------|---------------------------------------------------------------------------------|
| File(File parent, String child)   | 根据 **parent** 抽象路径名和 **child** 路径名字符串创建一个新 **File** 实例。   |
| File(String pathname)             | 通过将给定路径名字符串转换为抽象路径名来创建一个新 **File** 实例。              |
| File(String parent, String child) | 根据 **parent** 路径名字符串和 **child** 路径名字符串创建一个新 **File** 实例。 |
| File(URI uri)                     | 通过将给定的 **file: URI** 转换为一个抽象路径名来创建一个新的 **File** 实例。   |

```java
File file=new File("D:"+ File.separator+"a.txt");  
File file2=new File("D:\\a.txt");  
File file3=new File("D:","a.txt");  
File file4=new File(file,"a.txt");
```

| 返回类型        | 方法                                                         | 说明                                                                                                                                                                              |
|-----------------|--------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  boolean        | canExecute()                                                 | 测试应用程序是否可以执行此抽象路径名表示的文件。                                                                                                                                  |
|  boolean        | canRead()                                                    | 测试应用程序是否可以读取此抽象路径名表示的文件。                                                                                                                                  |
|  boolean        | canWrite()                                                   | 测试应用程序是否可以修改此抽象路径名表示的文件。                                                                                                                                  |
|  int            | compareTo(File pathname)                                     | 按字母顺序比较两个抽象路径名。                                                                                                                                                    |
|  boolean        | createNewFile()                                              | 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。                                                                                                      |
| static File     | createTempFile(String prefix, String suffix)                 | 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。                                                                                                                |
| static File     | createTempFile(String prefix, String suffix, File directory) | 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。                                                                                                            |
|  boolean        | delete()                                                     | 删除此抽象路径名表示的文件或目录。                                                                                                                                                |
|  void           | deleteOnExit()                                               | 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。                                                                                                                            |
|  boolean        | equals(Object obj)                                           | 测试此抽象路径名与给定对象是否相等。                                                                                                                                              |
|  boolean        | **exists()**                                                 | 测试此抽象路径名表示的文件或目录是否存在。                                                                                                                                        |
|  File           | getAbsoluteFile()                                            | 返回此抽象路径名的绝对路径名形式。                                                                                                                                                |
|  String         | getAbsolutePath()                                            | 返回此抽象路径名的绝对路径名字符串。                                                                                                                                              |
|  File           | getCanonicalFile()                                           | 返回此抽象路径名的规范形式。                                                                                                                                                      |
|  String         | getCanonicalPath()                                           | 返回此抽象路径名的规范路径名字符串。                                                                                                                                              |
|  long           | getFreeSpace()                                               | 返回此抽象路径名指定的分区中未分配的字节数。                                                                                                                                      |
|  String         | **getName()**                                                | 返回由此抽象路径名表示的文件或目录的名称。                                                                                                                                        |
|  String         | **getParent()**                                              | 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。                                                                                                   |
|  File           | getParentFile()                                              | 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。                                                                                                     |
|  String         | **getPath()**                                                | 将此抽象路径名转换为一个路径名字符串。                                                                                                                                            |
|  long           | getTotalSpace()                                              | 返回此抽象路径名指定的分区大小。                                                                                                                                                  |
|  long           | getUsableSpace()                                             | 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。                                                                                                                              |
|  int            | hashCode()                                                   | 计算此抽象路径名的哈希码。                                                                                                                                                        |
|  boolean        | isAbsolute()                                                 | 测试此抽象路径名是否为绝对路径名。                                                                                                                                                |
|  boolean        | **isDirectory()**                                            | 测试此抽象路径名表示的文件是否是一个目录。                                                                                                                                        |
|  boolean        | **isFile()**                                                 | 测试此抽象路径名表示的文件是否是一个标准文件。                                                                                                                                    |
|  boolean        | isHidden()                                                   | 测试此抽象路径名指定的文件是否是一个隐藏文件。                                                                                                                                    |
|  long           | lastModified()                                               | 返回此抽象路径名表示的文件最后一次被修改的时间。                                                                                                                                  |
|  long           | **length()**                                                 | 返回由此抽象路径名表示的文件的长度。                                                                                                                                              |
|  String\[\]     | list()                                                       | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。                                                                                                          |
|  String\[\]     | list(FilenameFilter filter)                                  | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。                                                                                            |
|  File\[\]       | listFiles()                                                  | 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。                                                                                                            |
|  File\[\]       | listFiles(FileFilter filter)                                 | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。                                                                                            |
|  File\[\]       | listFiles(FilenameFilter filter)                             | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。                                                                                            |
| static File\[\] | listRoots()                                                  | 列出可用的文件系统根。                                                                                                                                                            |
|  boolean        | **mkdir()**                                                  | 创建此抽象路径名指定的目录。                                                                                                                                                      |
|  boolean        | **mkdirs()**                                                 | 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。                                                                                                                        |
|  boolean        | **renameTo(File dest)**                                      | 重新命名此抽象路径名表示的文件。                                                                                                                                                  |
|  boolean        | setExecutable(boolean executable)                            | 设置此抽象路径名所有者执行权限的一个便捷方法。                                                                                                                                    |
|  boolean        | setExecutable(boolean executable, boolean ownerOnly)         | 设置此抽象路径名的所有者或所有用户的执行权限。                                                                                                                                    |
|  boolean        | setLastModified(long time)                                   | 设置此抽象路径名指定的文件或目录的最后一次修改时间。                                                                                                                              |
|  boolean        | setReadable(boolean readable)                                | 设置此抽象路径名所有者读权限的一个便捷方法。                                                                                                                                      |
|  boolean        | setReadable(boolean readable, boolean ownerOnly)             | 设置此抽象路径名的所有者或所有用户的读权限。                                                                                                                                      |
|  boolean        | setReadOnly()                                                | 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。                                                                                                                        |
|  boolean        | setWritable(boolean writable)                                | 设置此抽象路径名所有者写权限的一个便捷方法。                                                                                                                                      |
|  boolean        | setWritable(boolean writable, boolean ownerOnly)             | 设置此抽象路径名的所有者或所有用户的写权限。                                                                                                                                      |
|  String         | toString()                                                   | 返回此抽象路径名的路径名字符串。                                                                                                                                                  |
|  URI            | toURI()                                                      | 构造一个表示此抽象路径名的 file: URI。                                                                                                                                            |
|  URL            | toURL()                                                      | **已过时。** *此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。* |

## 字节流
&emsp;&emsp;字节流是按字节读/写二进制数据字节流有两个基本的类：**InputStream**类**OutputStream**类  
&emsp;&emsp;**InputStream**类用于处理**字节输入流**,**OutputStream**类用于处理**字节输出流**。它们都是**抽象类**,本身不能直接用来创建对象。所有字节处理流都由**InputStream**/**OutputStream**派生而来  
### InputStream常用方法

| 方法                                                | 说明                                                                                   |
|-----------------------------------------------------|----------------------------------------------------------------------------------------|
| **int read()**                                      | 读取一个字节,并将它返回                                                                |
| **int read(byte\[\] buffer)**                       | 将数据读入一个字节数组,同时返回读取的字节数。                                          |
| **int read(byte\[\] buffer,int offset,int length)** | 将数据读入一个字节数组,放到数组的offset指定的位置开始,并用length来指定读取的最大字节数 |
| void close()                                        | 关闭流。                                                                               |
| int available()                                     | 返回可以从中读取的字节数。                                                             |
| long skip(long n)                                   | 在输入流中跳过n个字节,将实际跳过的字节数返回。                                         |
| boolean markSupported()                             | 判断流是否支持标记功能。                                                               |
| void mark(int readlimit)                            | 在支持标记的输入流的当前位置设置一个标记。                                             |
| void reset()                                        | 返回到流的上一个标记。注意必须流支持标记功能。                                         |

### InputStream相关类

&emsp;&emsp;低级 **InputStream**类：  
> **InputStream**  
**ByteArrayInputStream**  
**PipedInputStream**  
**FileInputStream**  

&emsp;&emsp;高级 **InputStream**类  
> **DataInputStream**  
**BufferedInputStream**  

```java
package com.aotmd.test;  
import java.io.FileInputStream;  
import java.io.FileNotFoundException;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileInputStream fis;  
        int n;  
        try {  
            fis = new FileInputStream("file1.txt");// 读取文件  
            byte[] a = new byte[256];  
            while ((n = fis.read(a)) != -1)System.out.write(a, 0, n);// 显示  
            fis.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
### OutputStream常用方法
&emsp;&emsp;Writer常用方法(写入方法)  

| 方法                                                   | 说明                                                   |
|--------------------------------------------------------|--------------------------------------------------------|
| **void write(int b)**                                  | 将参数b的低16位组成字节写入到流中。                    |
| **void write(byte\[\] buffer)**                        | 将字符数组buffer中的字节写入到流中。                   |
| **void write(byte\[\] buffer,int offset, int length)** | 将字节数组buffer中从offset开始的length字节写入到流中。 |
| void close()                                           | 关闭流                                                 |
| void flush()                                           | 刷空输岀流,并输岀所有被缓存的字节。                    |

### OutputStream相关类
&emsp;&emsp;低级 **OutputStream**类：  
> **OutputStream**  
**ByteArrayOutputStream**  
**PipedOutputStream**  

&emsp;&emsp;高级 **Outputstream**类：  
> **DataOutputStream**  
**BufferedOutputStream**  

```java
package com.aotmd.test;  
import java.io.FileNotFoundException;  
import java.io.FileOutputStream;  
import java.io.IOException;  
import java.io.PrintStream;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileOutputStream fos = null;  
        PrintStream out = null;  
        try {  
            fos = new FileOutputStream("file1.txt", true);//建立一个文件输出流,true追加  
            out = new PrintStream(fos);//建立一个PrintStream对象,它将作为标准输出流  
            out.println("这是一个测试串FileOutputStream");  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        } finally {  
            assert out != null;  
            out.close();  
            try {  
                fos.close();  
            } catch (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    }  
}
```
## 字符流
&emsp;&emsp;字待流有两个基本类：**Reader**和**Writer**  
&emsp;&emsp;1,**Reader**/**Writer**处理的是**字符类型**的数据。它处理流的方式是以**字符**为单位进行的。  
&emsp;&emsp;2,**Reader**/**Writer**和**InputStream**/**OutputStream**一样,也分为**节点流**(低级流)和**处理流**(高级流)。  
&emsp;&emsp;**Reader**和**InputStream**的差异  
&emsp;&emsp;**Reader**和**InputStream**一样,用于从流中读取数据。它和**InputStream**的区别在于,**InputStream**以**字节**为单位操作流,而**Reader**以**字符**为单位操作流。  
&emsp;&emsp;**Reader**类是所有输入字待流的父类,**Writer**类是所有输出字符流的父类。设计**Reader**和**Writer**继承层次结构主要是为了国际化。而旧的I/O流继承层次结构仅支持8位字节流,并且不能很好的处理16位的Unicode字符。由于Unicode用于字符国际化,所以添加字符流的继承层次结构就是在所有的I/O操作中都支持Unicode。  
### Reader常用方法

| 方法                                                | 说明                                                                     |
|-----------------------------------------------------|--------------------------------------------------------------------------|
| **int read()**                                      | 读取一个字符,并将它返回                                                  |
| **int read(char\[\] buffer)**                       | 将从流中读取的字符放到字符数组buffer中,返回读出的字符数。                |
| **int read(char\[\] buffer,int offset,int length)** | 将读出的字符放到字符数组的指定offet开始的空间,每次最多读出length个字符。 |
| void mark(int )                                     | 标记流中的位置                                                           |
| boolean MarkSupported()                             | 判断流是否支持mark()                                                     |
| boolean ready()                                     | 判断是否准备读取此流                                                     |

### Reader相关类
&emsp;&emsp;低级**Reader**类：  
> **CharArrayReader**  
**PipedReader**  
**StringReader**  
**FileReader**  

&emsp;&emsp;高级**Reader**类  
> **BufferedReader**  
**InputStreamReader**  
**LineNumberReader**  

```java
package com.aotmd.test;  
import java.io.BufferedReader;  
import java.io.FileNotFoundException;  
import java.io.FileReader;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileReader fr;  
        int reccount = 0;  
        try {  
            fr = new FileReader("file2.txt");  
            BufferedReader br = new BufferedReader(fr);  
            String record = "";  
            while ((record = br.readLine()) != null) {  
                reccount++;  
                System.out.println("Line" + reccount + ": " + record);  
            }  
            fr.close();  
            br.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
### Writer常用方法

| 方法                                                 | 说明                                                   |
|------------------------------------------------------|--------------------------------------------------------|
| **void write(int c)**                                | 将参数c的低16位组成字符写入到流中。                    |
| **void write(char\[\]buffer)**                       | 将字符数组buffer中的字符写入到流中。                   |
| **void write(char\[\]buffer,int offset,int length)** | 将字符数组buffer中从offset开始的length个字符写入到流中 |
| void write(String string)                            | 将string字符串写入到流中。                             |
| void write(String string,int offset,int length)      | 将字符string中从offset开始的length个字符写入到流中。   |
| Writer append(char c)                                | 将指定字符添加到此writer                               |
| void close()                                         | 关闭流                                                 |
| void flush()                                         | 刷空输岀流,并输岀所有被缓存的字节。                    |

### Writer相关类
&emsp;&emsp;低级**Writer**类：  
> **CharArrayWriter**
**StringWriter**
**PipedWriter**
**FileWriter**

&emsp;&emsp;高级**Writer**类  
> **BufferedWriter**
**OutputStreamWriter**
**PrintWrite**

```java
package com.aotmd.test;  
import java.io.FileWriter;  
import java.io.IOException;  
import java.io.PrintWriter;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileWriter fw;  
        PrintWriter out;  
        try {  
            fw = new FileWriter("file2.txt", true);//建立一个文件输出流,true追加  
            out = new PrintWriter(fw);//建立一个PrintWriter对象,它将作为标准输出流  
            out.println("这是一个测试串PrintWriter");  
            out.close();  
            fw.close();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
## 其他
**标准输入输出的重定向**
&emsp;&emsp;Java系统预先定义3个流对象;  
1. 标准输出设备**System.out**  
2. 标准输入设备**System.in**  
3. 标准错误设备**System.err**  

&emsp;&emsp;在默认情况下,标准输入设备是键盘,而标准输出设备是显示器,通过**System.setIn**方法和**System.setout**方法可以改变它们的默认输入/输出设备  
&emsp;&emsp;实例  
```java
package com.aotmd.test;  
import java.io.*;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileOutputStream fos = null;  
        PrintStream ps;  
        try {  
            fos = new FileOutputStream("Demo.txt", true);//建立一个文件输出流,并将它的append标记设置为true  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
        ps = new PrintStream(fos);// 建立一个PrintStream对象,它将作为标准输出流  
        System.setOut(ps);//将标准输出定向到PrintStream对象  
        System.out.println("该字符串会输出到文件中");//输出以条数据,它不再会在控制台输出,而是输出到了文件Demo.txt中  
    }  
}
```
&emsp;&emsp;**RandomAccessFile**类  
&emsp;&emsp;**RandomAccessFile**是一种特殊的文件流,可以用它在文件的任何地方查找或者插入数据  
&emsp;&emsp;**RandomAccessFile**同时实现了**Datalnput**和**DataOutput**接口,所以可以用它来读/写文件  
&emsp;&emsp;构造器  
&emsp;&emsp;**RandomAccessFile(java.io.File f,String mode)**  
&emsp;&emsp;**RandomAccessFile(String file,String mode)**  
```java
RandomAccessFile rf1 = new RandomAccessFile("toAppend.txt", "rw");  
rf1.seek(100);  
rf1.writeBytes( "123\n");  
rf1.close();
```
&emsp;&emsp;**FileOutputStream**流类  
&emsp;&emsp;**FileOutputStream(String fileName)** 参数**fileName**表示带路径的磁盘文件名。  
&emsp;&emsp;**FileOutputStream(File file)** 参数**file**表示为磁盘文件所建立的**File**对象名  

&emsp;&emsp;**FilelnputStream**流类  
&emsp;&emsp;**FilelnputStream(String fileName)** 参数**fileName**表示带路径的磁盘文件名。  
&emsp;&emsp;**FilelnputStream(File file)** 参数**file**表示为磁盘文件所建立的**File**对象名。
    
&emsp;&emsp;**DataOutputStream**流类  
&emsp;&emsp;使用**DataOutputStream**类向文件中写入各种类型数据的操作步骤是:  
1. 为磁盘文件建立**File**类对象;  
2. 为该**File**对象建立**FileOutputStream**类流对象,建立其与磁盘文件的连接;  
3. 为该**FileOutputStream**类对象建立**DataOutputStream**类对象,利用**DataOutputStream**类的**writelnt()**,**writeFloat()**, **writeDouble()**,**writeBoolean()**等方法分别尚文件中写入整型、单精度型、双精度型、布尔型等数据;  
4. 写入操作完成后,利用**close()**方法将流关闭,断开与磁盘文件的联系。  

&emsp;&emsp;以字符流方式向文件写入或从文件中读取数据,可以使用**Writer**和**Reader**类及其子类。  
&emsp;&emsp;**Writer**和**Reader**类都是抽象类,不能建立它们的对象,所以只能通过它们子类对象对文件进行操作。常用的 **Writer**类的子类包括**FileWriter**类和**BufferedFileWriter**类。  
&emsp;&emsp;**FileWriter**类构造方法如下:  
&emsp;&emsp;**FileWriter(String fileName)** 参数**fileName**表示带路径的磁盘文件名。  
&emsp;&emsp;**FileWriter(File file);** 参数**file**表示为磁盘文件所建立的**File**对象名。  
&emsp;&emsp;注;使用**FileWriter**进行文件操作时,为了减少磁盘读写次数,**常使用具有缓冲功能的BufferedWriter类。**  
## 缓存流
&emsp;&emsp;缓存流是计算机领域中输入输出流的一种常见形式。包括**BufferedInputStream**/ **BufferedOutputStream** 类和**BufferedReader**/ **BufferedWriter**类。  
&emsp;&emsp;这种流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出,通过**减少系统**资源的**读写次数**来**加快**程序的执行。**BufferedOutputstream** 或**BufferedWriter** 类仅仅在缓冲区满或调用**flush()**方法时才将数据写到目的地。  
&emsp;&emsp;缓存流是过滤流,在创建具体流时需要给出一个**InputStream** / **OutputStream** 类型的流座位前端流,并可以指明缓冲区的大小。  
&emsp;&emsp;**public BufferedInputStream(InputStream in)**  
&emsp;&emsp;**public BufferedInputStream(InputStream in,int size)**  
&emsp;&emsp;**BufferedInputStream** / **BufferedOutputStream**类提供**InputStream** /**OutputStream** 中定义的方法,例如 **read()** , **skip()**,**write()**等,并支持基于标签机制的回读。  
&emsp;&emsp;**BufferedReader**类中增加了一个有用的方法 **readLine()**,该方法读一行字符返回。行的结束标志是换行符“**\n**”或回车符“**\r**”,或回车符+换行符。  
&emsp;&emsp;**BufferedWriter**中也相应增加了一个方法**newLine()**,该方法写一个行分隔符。分隔符由系统特性**line.separator** 指定,可以是“**\n**”。  
&emsp;&emsp;**public class BufferedWriter extends Writer**  
&emsp;&emsp;将文本写入字符输出流,缓冲各个字符,从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小,或者接受默认的大小。在大多数情况下,默认值就足够大了。该类提供了**newLine()**方法,它使用平台自己的行分隔符概念,此概念由系统属性 **line.separator** 定义。并非所有平台都使用新行符('\n')来终止各行。因此调用此方法来终止每个输出行要**优于**直接写入新行符。 通常 **Writer** 将其输出立即发送到底层字符或字节流。除非要求提示输出,否则**建议用BufferedWriter包装所有其write()操作**可能开销很高的**Writer**(如 **FileWriters**和**OutputStreamWriters**)。例如:  
&emsp;&emsp;PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out")));  
&emsp;&emsp;将缓冲**PrintWriter**对文件的输出。如果没有缓冲,则每次调用**print()**方法会导致将字符转换为字节,然后立即写入到文件,而这是极其低效的。  
&emsp;&emsp;**BufferedReader**同理  
```java
package a1;  
import java.io.BufferedReader;  
import java.io.FileNotFoundException;  
import java.io.FileReader;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileReader fr;  
        int reccount = 0;  
        try {  
            fr = new FileReader("file2.txt");  
            *BufferedReader br = new BufferedReader(fr);*  
                String record = "";  
            while ((record = br.readLine()) != null) {  
                reccount++;  
                System.out.println("Line" + reccount + ": " + record);  
            }  
            fr.close();  
            br.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
## DataOutputStream/DataInputStream
&emsp;&emsp;数据输出流允许应用程序以与机器无关方式将Java基本数据类型写到底层输出流。  
&emsp;&emsp;可以使用**DataOutputStream**和**DataInputStream**写入和读取数据。  
&emsp;&emsp;在IO包中提供了两个与平台无关的数据操作流  
&emsp;&emsp;数据输出流：**DataOutputStream**  
&emsp;&emsp;数据输入流：**DataInputStream**  
&emsp;&emsp;通常按照一定格式将输入输出,再按照一定格式将数据输入。  
&emsp;&emsp;要想使用数据输出流和输入流,则**肯定要用户指定数据的保存格式**。必须按指定的格式保存数据,才可以将数据输入流将数据读取进来。  
&emsp;&emsp;**DataOutputStreams**是**OutputStream**的子类。  
&emsp;&emsp;**public class DataOutputStream extends FilterOutputStream implements DataOutput**  
&emsp;&emsp;此类继承自**FillterOutputStream**类,同时实现**DataOutput**接口。在**DataOutput**接口定义了一系列写入各种数据的方法。  
&emsp;&emsp;**DataOutput**接口定义了一系列的**writeXXX()**的操作,可以写入各种类型数据。  
&emsp;&emsp;要想使用**DataOutputStream**写入数据的话,则必须指定好数据的输出格式。  
&emsp;&emsp;**DataOutputStream**  
&emsp;&emsp;**字段**  
&emsp;&emsp;到目前为止写入数据输出流的字节数。  
&emsp;&emsp;**protected int written**  
&emsp;&emsp;**构造方法**  
&emsp;&emsp;创建一个新的数据输出流,将数据写入指定基础输出流。  
&emsp;&emsp;**DataOutputStream(OutputStream out)**  
&emsp;&emsp;**写方法**  
&emsp;&emsp;(1)基本数据类型写入方法：八种基本类型：六种数字类型(四个整数型,两个浮点型),一种字符类型,还有一种布尔型。  

| 方法                         | 说明                                                                                                                         |
|------------------------------|------------------------------------------------------------------------------------------------------------------------------|
| void writeByte(int v)        | 将一个byte值以1-byte值形式写出到基础输出流中。                                                                               |
| void writeShort(int v)       | 将一个short值以2-byte值形式写入基础输出流中,先写入高字节。                                                                   |
| void writeInt(int v)         | 将一个int值以4-byte值形式写入基础输出流中,先写入高字节。                                                                     |
| void writeLong(long v)       | 将一个long值以8-byte值形式写入基础输出流中,先写入高字节。                                                                    |
| void writeFloat(float v)     | 使用Float类中的floatToIntBits方法将float参数转换为一个int值,然后将该int值以4-byte值形式写入基础输出流中,先写入高字节。       |
| void writeDouble(double v)   | 使用Double类中的doubleToLongBits方法将double参数转换为一个long值,然后将该long值以8-byte值形式写入基础输出流中,先写入高字节。 |
| void writeChar(int v)        | 将一个char值以2-byte值形式写入基础输出流中,先写入高字节。                                                                    |
| void writeBoolean(boolean v) | 将一个boolean值以1-byte值形式写入基础输出流。                                                                                |

&emsp;&emsp;(2)字节数组的写入方法  
&emsp;&emsp;**void write(byte\[\] b, int off, int len)** 将指定 **byte** 数组中从偏移量 **off** 开始的 **len** 个字节写入基础输出  
&emsp;&emsp;(3)只写入int的低八位  
&emsp;&emsp;**void write(int b)** 将指定字节(参数**b**的八个低位)写入基础输出流。  
&emsp;&emsp;(4)写入字符串的方法  
&emsp;&emsp;**void writeBytes(String s)** 将字符串按字节顺序写出到基础输出流中。  
&emsp;&emsp;**void writeChars(String s)** 采用**UTF-16be**方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。  
&emsp;&emsp;**void writeUTF(String str)** 以与机器无关方式使用**UTF-8**修改版编码将一个字符串写入基础  
&emsp;&emsp;4.其他方法  
&emsp;&emsp;**void flush()** 清空此数据输出流。写入文件  
&emsp;&emsp;**int size()** 返回计数器 **written** 的当前值,即到目前为止写入此数据输出流的字节数。  
&emsp;&emsp;**DataInputStream**  
&emsp;&emsp;**构造方法**  
&emsp;&emsp;使用指定的底层 **InputStream** 创建一个 **DataInputStream**。  
&emsp;&emsp;**DataInputStream(InputStream in)**  
&emsp;&emsp;**读方法**  

&emsp;&emsp;1.基本类型读取方法：  

| 方法                  | 说明                                                                                                                                                                                                       |
|-----------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| byte readByte()       | 读取并返回一个输入字节。该字节被看作是 -128 到 127(包含)范围内的一个有符号值。                                                                                                                             |
| int readInt()         | 读取四个输入字节并返回一个 int 值。                                                                                                                                                                        |
| short readShort()     | 参见 DataInput 的 readShort 方法的常规协定。                                                                                                                                                               |
| long readLong()       | 读取八个输入字节并返回一个 long 值。                                                                                                                                                                       |
| float readFloat()     | 读取四个输入字节并返回一个 float 值。                                                                                                                                                                      |
| double readDouble()   | 读取八个输入字节并返回一个 double 值。实现这一点的方法是：   先使用与 readlong 方法完全相同的方式构造一个 long 值, 然后使用与 Double.longBitsToDouble 方法完全相同的方式将此 long 值转换成一个 double 值。 |
| boolean readBoolean() | 读取一个输入字节,如果该字节不是零,则返回 true,如果是零,则返回 false。                                                                                                                                      |
| char readChar()       | 读取两个输入字节并返回一个 char 值。                                                                                                                                                                       |

&emsp;&emsp;2.字符串读取方法  
&emsp;&emsp;**String readUTF();** 读入一个已使用 UTF-8 修改版格式编码的字符串。  
&emsp;&emsp;**static String readUTF(DataInput in)** 从流 in 中读取用 UTF-8 修改版格式编码的 Unicode 字符格式的字符串;然后以 **String** 形式返回此字符串。  
&emsp;&emsp;可以看到**DataInputStream**中读取字符串**只有readUTF()**方法,**没有**与**DataOutputStream**对应的：  
&emsp;&emsp;**void writeBytes(String s)** 将字符串按字节顺序写出到基础输出流中。  
&emsp;&emsp;**void writeChars(String s)** 采用UTF-16be方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。  
&emsp;&emsp;使用**DataOutputStream**的这两个方法写入字符串时,**DataInputStream**来读取可能比较**麻烦**。  
&emsp;&emsp;3.无符号整数读取方法  
&emsp;&emsp;**DataInputStream**中并没有写入无符号整数的方法,这两个方法是不是用不到？  
&emsp;&emsp;**int readUnsignedByte();**读取一个输入字节,将它左侧补零 (zero-extend) 转变为 **int** 类型,并返回结果,所以结果的范围是 0 到 255。如果接口 **DataOutput** 的 **writeByte** 方法的参数是 0 到 255 之间的值,则此方法适用于读取用 **writeByte** 写入的字节。  
&emsp;&emsp;**int readUnsignedShort();**读取两个输入字节,并返回 0 到 65535 范围内的一个 **int** 值。如果接口 **DataOutput** 的 **writeShort** 方法的参数是 0 到 65535 范围内的值,则此方法适用于读取用 **writeShort** 写入的字节。  

&emsp;&emsp;4.读取字节数组的方法：  

| 方法                                         | 说明                                                                                      |
|----------------------------------------------|-------------------------------------------------------------------------------------------|
| int read(byte\[\] b)                         | 从包含的输入流中读取一定数量的字节,并将它们存储到缓冲区数组 **b** 中。                    |
| int read(byte\[\] b, int off, int len)       | 从包含的输入流中将最多 **len** 个字节读入一个 **byte** 数组中。                           |
| void readFully(byte\[\] b)                   | 从输入流中读取一些字节,并将它们存储在缓冲区数组 **b** 中。读取的字节数等于 **b** 的长度。 |
| void readFully(byte\[\] b, int off, int len) | 从输入流中读取 **len** 个字节到字节数组**b**,**从**b的**off**下标开始读入。               |

&emsp;&emsp;5.同样是读取字节数组的方法,**read(byte\[\] b)**和**readFully(byte\[\] b)**的区别：  
&emsp;&emsp;其实**read(byte\[\] b)**方法和**readFully(byte \[\]b)**都是利用**InputStream**中**read()**方法,每次读取的也是一个字节,只是读取字节数组的方式不同.  
&emsp;&emsp;**read(byte\[\] b)**方法实质是读取流上的字节直到流上**没有**字节为止,如果当声明的字节数组长度**大于**流上的数据长度时就提前返回  
&emsp;&emsp;**readFully(byte\[\] b)**方法是读取流上**指定长度**的字节数组,也就是说如果声明了长度为**len**的字节数组,**readFully(byte\[\] b)**方法只有读取**len**长度个字节的时候才返回,否则**阻塞等待**,如果超时,则会抛出异常 **EOFException**。  
&emsp;&emsp;那么当发送了长度为**len**的字节,那么为什么用**read**方法用户收不全呢,揪其原因我们发现消息在网络中传输是没那么理想的,我们发的那部分字节数组在传送过程中可能在接受信息方的缓存当中或者在传输线路,极端情况下可能在发送方的缓存当中,这样就不在流上,所以**read**方法提前返回了,这样就造成了各种错误。  
&emsp;&emsp;**readFully()**源码：  
```java
public void readFully(byte[] b, int off, int len, boolean copy) throws IOException { 
    while (len > 0) {  
        int n = read(b, off, len, copy);  
        if (n < 0) {  
            throw new EOFException();  
        }  
        off += n;  
        len -= n;  
    }  
}
```
&emsp;&emsp;**readFully**方法并不是说一下就把整个文件读完了,不用去管是否到达文件末尾的异常。**readFully**只是在读取数据的时候,会一直把缓冲区读满,否则一直处于阻塞状态而等待读取。  
&emsp;&emsp;**read**方法只是将字节流中的数据读完。那么数据在TCP协议传送的过程中,可能输入流接受到的数据并不完全,只是其中的一部分。  
&emsp;&emsp;如果这时候的缓冲区没有满的话,**readFully**将会继续等待,直到缓冲区装满。  
&emsp;&emsp;某些时候,你可能需要读出特定的长度的字段。比如一些数据的头信息之类的,这时候如果你用**read**去读,那么可能还没有读完就个你返回来了。但是如果去用**readFully**读,那么就会完整的给你读出来。但是在更多的时候,如果不是确定要用特定长度的数据。还是用**read**去读。用**readFully**有点危险。  
&emsp;&emsp;6.跳过n个字节：  
&emsp;&emsp;**int skipBytes(int n)** 试图在输入流中跳过数据的**n**个字节,并丢弃跳过的字节。  
&emsp;&emsp;**实例**  

```java
package com.aotmd.test;  
import java.io.*;  
public class NoteTest  
{  
    public static void main(String[] args) throws IOException  
    {  
        FileOutputStream out = new FileOutputStream("testDataOutputStream.txt");  
        DataOutputStream dos = new DataOutputStream(out);  
        byte b = 20;  
        short s = 30;  
        int a = 900;  
        float f = 12.3f;  
        long l = 800l;  
        double d = 14.23;  
        boolean flag = true;  
        char ch = '中';  
        dos.writeByte(b);// 写入byte类型数据  
        dos.writeShort(s);// 写入short类型数据  
        dos.writeInt(a);// 写入int类型  
        dos.writeFloat(f);// 写入float类型  
        dos.writeLong(l);// 写入long类型  
        dos.writeDouble(d);// 写入double类型  
        dos.writeBoolean(flag);  
        dos.writeChar(ch);// 写入char类型  
        dos.close();  
        out.close();  
        FileInputStream in = new FileInputStream("testDataOutputStream.txt");  
        DataInputStream dif = new DataInputStream(in);  
        byte btemp;  
        short stemp;  
        int atemp;  
        float ftemp;  
        long ltemp;  
        double dtemp;  
        boolean flagtemp;  
        char chtemp;  
        btemp = dif.readByte();  
        stemp = dif.readShort();  
        atemp = dif.readInt();  
        ftemp = dif.readFloat();  
        ltemp = dif.readLong();  
        dtemp = dif.readDouble();  
        flagtemp = dif.readBoolean();  
        chtemp = dif.readChar();  
        // stringtemp=dif.read  
        System.out.println(btemp);  
        System.out.println(stemp);  
        System.out.println(atemp);  
        System.out.println(ftemp);  
        System.out.println(ltemp);  
        System.out.println(dtemp);  
        System.out.println(flagtemp);  
        System.out.println(chtemp);  
        dif.close();  
        in.close();  
    }  
}
```
&emsp;&emsp;输出:  
```text
20
30
900
12.3
800
14.23
true
中
```
&emsp;&emsp;**实例二**  
```java
package com.aotmd.test;  
import java.io.DataOutputStream;  
import java.io.File;  
import java.io.FileOutputStream;  
public class NoteTest {  
    public static void main(String[] args) throws Exception { // 所有异常抛出  
        DataOutputStream dos; // 声明数据输出流对象  
        File f = new File("d:" + File.separator + "order.txt"); // 文件的保存路径  
        dos = new DataOutputStream(new FileOutputStream(f)); // 实例化数据输出流对象  
        String[] names = {"衬衣", "手套", "围巾"}; // 商品名称  
        float[] prices = {98.3f, 30.3f, 50.5f}; // 商品价格  
        int[] nums = {3, 2, 1}; // 商品数量  
        for (int i = 0; i < names.length; i++) { // 循环输出  
            dos.writeChars(names[i]); // 写入字符串,注意,这边少数writeChars(),不是writechar(*。  
            dos.writeChar('\t'); // 写入分隔符,这边是读取writechar()。  
            dos.writeFloat(prices[i]); // 写入价格  
            dos.writeChar('\t'); // 写入分隔符  
            dos.writeInt(nums[i]); // 写入数量  
            dos.writeChar('\n'); // 换行  
        }  
        dos.close(); // 关闭输出流  
    }  
}
```
&emsp;&emsp;代码生成的文件  
```text
886c 8863 0009 42c4 999a 0009 0000 0003
000a 624b 5957 0009 41f2 6666 0009 0000
0002 000a 56f4 5dfe 0009 424a 0000 0009
0000 0001 000a
```
&emsp;&emsp;使用**DataOutpputStream**写入的数据要使用**DataInputStream**取出进来,  
```java
package com.aotmd.test;  
import java.io.DataInputStream;  
import java.io.File;  
import java.io.FileInputStream;  
public class NoteTest {  
    public static void main(String args[]) throws Exception { // 所有异常抛出  
        DataInputStream dis = null; // 声明数据输入流对象  
        File f = new File("d:" + File.separator + "order.txt"); // 文件的保存路径  
        dis = new DataInputStream(new FileInputStream(f)); // 实例化数据输入流对象  
        String name = null; // 接收名称  
        float price = 0.0f; // 接收价格  
        int num = 0; // 接收数量  
        char temp[] = null; // 接收商品名称  
        int len = 0; // 保存读取数据的个数  
        char c = 0; // '\u0000'  
        try {  
            while (true) {  
                temp = new char[200]; // 开辟空间  
                len = 0;  
                while ((c = dis.readChar()) != '\t') { // 接收内容,因为直到读取到'\t'才完成了读取一个字符串,未读取到表示还有内容。  
                    temp[len] = c;  
                    len++; // 读取长度加1  
                }  
                name = new String(temp, 0, len); // 将字符数组变为String  
                price = dis.readFloat(); // 读取价格  
                dis.readChar(); // 读取\t  
                num = dis.readInt(); // 读取int  
                dis.readChar(); // 读取\n  
                System.out.printf("名称：%s;价格：%5.2f;数量：%d\n", name, price, num);  
            }  
        } catch (Exception e) {  
        }  
        dis.close();  
    }  
}
```
&emsp;&emsp;执行结果：  
```text
名称：衬衣;价格：98.30;数量：3
名称：手套;价格：30.30;数量：2
名称：围巾;价格：50.50;数量：1
```
&emsp;&emsp;**DataInputStream**读取字符串,只能通过**readchar(),**一个个读取,不像**DataOutpputStream**一样还区分**writechars()**,**writechar()**。  
# GUI
&emsp;&emsp;**JFrame**  
&emsp;&emsp;**构造方法**  

| 方法                                           | 说明                                                                   |
|------------------------------------------------|------------------------------------------------------------------------|
| JFrame()                                       | 构造一个初始时不可见的新窗体。                                         |
| JFrame(GraphicsConfiguration gc)               | 以屏幕设备的指定 GraphicsConfiguration 和空白标题创建一个 Frame。      |
| JFrame(String title)                           | 创建一个新的、初始不可见的、具有指定标题的 Frame。                     |
| JFrame(String title, GraphicsConfiguration gc) | 创建一个具有指定标题和指定屏幕设备的 GraphicsConfiguration 的 JFrame。 |

&emsp;&emsp;**常用方法**  

| 方法                                    | 说明                                   |
|-----------------------------------------|----------------------------------------|
| add()                                   | 将组件添加到窗口                       |
| is/setVisible()                         | 获取/设置窗体的可视状态。              |
| get/setTitle()                          | 获取/设置窗体的标题。                  |
| get/setState()                          | 获取/设置窗体的的最小化,最大化等状态。 |
| get/setLocation()                       | 获取/设置窗体在屏幕上应当出现的位置。  |
| get/setSize()                           | 获取/设置窗体的大小。                  |
| setDefaultCloseOperation(int operation) | 设置单击窗体上的关闭按钮时的默认操作。 |
| getContentPane()                        | 获取窗体的内容面板                     |

&emsp;&emsp;**setDefaultCloseOperation**  
&emsp;&emsp;**public void setDefaultCloseOperation(int operation)**  
&emsp;&emsp;设置用户在此窗体上发起"**close**"时默认执行的操作。必须指定以下选项之一：  
&emsp;&emsp;值依次为**0-3**  
&emsp;&emsp;**DO_NOTHING_ON_CLOSE**(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 **WindowListener** 对象的 **windowClosing** 方法中处理该操作。  
&emsp;&emsp;**HIDE_ON_CLOSE**(在 **WindowConstants** 中定义)：调用任意已注册的 **WindowListener** 对象后自动隐藏该窗体。  
&emsp;&emsp;**DISPOSE_ON_CLOSE**(在 **WindowConstants** 中定义)：调用任意已注册 **WindowListener** 的对象后自动隐藏并释放该窗体。  
&emsp;&emsp;**EXIT_ON_CLOSE**(在 **JFrame** 中定义)：使用 **System exit** 方法退出应用程序。仅在应用程序中使用。  
&emsp;&emsp;默认情况下,该值被设置为 **HIDE_ON_CLOSE**。更改此属性的值将导致激发属性更改事件,其属性名称为 "**defaultCloseOperation**"。  
&emsp;&emsp;注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机**可能**会终止。  
&emsp;&emsp;**frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);**  
# 网络
&emsp;&emsp;常见服务和对应端口号  

| 端口 | 对应服务   |
|------|------------|
| 7    | Echo服务器 |
| 21   | Ftp        |
| 23   | telnet     |
| 25   | SMTP       |
| 79   | Finger     |
| 80   | HTTP       |

## URL类

| 构造方法                                                         | 说明                                                                  |
|------------------------------------------------------------------|-----------------------------------------------------------------------|
| public URL(String spec);                                         | URL u1 =new URL("http://home.netscape.com/home/");                    |
| public URL(URL context, String spec);                            | URL u2=new URL(u1, "welcome.html");                                   |
| public URL(String protocol, String host, String file);           | URL u3=new URL("http", "www.sun.com",developers/index.html");         |
| public URL (String protocol, String host, int port, String file) | URL u4 = new URL("http", "www.sun.com", 80,"developers/index.html" ); |

## URLConnection类
&emsp;&emsp;**Uonnection**类支持**URL**连接的输入/输出流方式的通信,并可以获得**URL**对象资源的相关信息。它是所有应用程序和**URL**连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。  
&emsp;&emsp;常用的成员方法：  

| 方法                                 | 说明                           |
|--------------------------------------|--------------------------------|
| void setUseCaches(boolean uescaches) | 设置是否允许使用高速缓冲存储器 |
| object getContent()                  | 获取当前URL连接的信息内容      |
| String getContentType()              | 返回连接类型的头域值           |
| int getContentLength()               | 返回当前连接长度的头域值       |
| long getDate()                       | 返回当前日期头域值             |
| long getLastModified()               | 返回最后修改时间头域值         |
| inputStream getInputStream()         | 返回连接的输入济               |
| outputStream getOutputStream()       | 返回连接的输出流               |

&emsp;&emsp;将baidu内容重定向到Demo.txt  
```java
package com.aotmd.test;  
import java.io.*;  
import java.net.URL;  
import java.net.URLConnection;  
import java.util.StringTokenizer;  
public class NoteTest {  
    public static void main(String[] args) throws IOException {  
        FileOutputStream fos = null;  
        PrintStream ps = null;  
        try {  
            fos = new FileOutputStream("Demo.txt", true);//建立一个文件输出流,并将它的append标记设置为true  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
        ps = new PrintStream(fos);// 建立一个PrintStream对象,它将作为标准输出流  
        System.setOut(ps);//将标准输出定向到PrintStream对象  
        URLConnection conn = null;  
        String nextLine = null;  
        StringTokenizer tokenizer = null;  
        URL url2 = new URL("http://www.baidu.com");  
        conn = url2.openConnection();  
        conn.setDoOutput(true);  
        conn.connect();  
        BufferedReader Reader1 = new BufferedReader(new InputStreamReader(conn.getInputStream()));  
        while ((nextLine = Reader1.readLine()) != null)  
            tokenizer = new StringTokenizer(nextLine);  
        while (tokenizer.hasMoreTokens()) {  
            String urlToken = tokenizer.nextToken();  
            System.out.println(urlToken);  
        }  
    }  
}
```
## Socket概念
&emsp;&emsp;两个Java应用程序可通过一个双向的网络通信连接实现**数据交换**,这个双向链路的一端称为一个**socket**.**socket**通常用来实现**client-server**连接。java.net包中定义的两个类**Socket**和**ServerSocket**,分别用来实现双向连接的**client**和**server**端.  
&emsp;&emsp;套接字(**Socket**)：表示一个系统的IP地址和端口号的结合。  
&emsp;&emsp;**TCP/IP**连接的一个端点用来处理两个流对象  
&emsp;&emsp;创建**TCP Socket**需要的四个信息：本地系统的**IP**本地应用程序使用的**TCP**端口号远程系统的**IP**远程应用程序相应的**TCP**端口号  

## Socket类
&emsp;&emsp;**Socket类构造器**  
> **Socket()**  
> **Socket(InetAddress address,int port)**  
> **Socket(InetAddress address,int port,InetAddress localAddr,int localPort)**  
> **Socket(String host,int port)**  
> **protected Socket(Socketlmpl impl)**  
> **Socket(String host,int port,InetAddress localAddr,int localPort)**  
> **Socket(InetAddress address, int port)**  
> **Socket(InetAddress address, int port,boolean stream);**  
> **Socket(String host, int port);**  
> **Socket(String host, int port, boolean stream);**  
> **ServerSocket(int port);**  
> **ServerSocket(int port, int count);**  

&emsp;&emsp;**Socket方法**  
> **getlnputStream()**  
> **getOutputStream()**  
> **close()**  

## ServerSocket类

&emsp;&emsp;ServerSocket类用于侦听一个客户端的Socket连接,如果没有连接,它将一直等待。  
&emsp;&emsp;**ServerSocket构造器**  

| 构造方法                                                 | 说明                                                                                   |
|----------------------------------------------------------|----------------------------------------------------------------------------------------|
| ServerSocket(int port)                                   | 用指定的端口**port**来创建一个侦听**Socket**                                           |
| ServerSocket(int port,int backlog)                       | 加上一个用来改变连接队列长度的参数**backlog**.                                         |
| ServerSocket(int port,int backlog,lnetAddress localAddr) | 在机器存在多个**IP**地址的情况下,允许通过**localAddr**这个参数来指定侦听的**IP**地址。 |

&emsp;&emsp;**ServerSocket方法**  
&emsp;&emsp;**Socket accept()**  
&emsp;&emsp;**close()**  
## 示例

&emsp;&emsp;服务端程序编写  
1.  调用**ServerSocket(int port)**创建一个服务端套接字，并绑定到指定端口上；
2.  调用**socket**类的**getOutputStream()**和**getlnputStream()**获取输入流和输出流
3.  关闭**socket**；

&emsp;&emsp;客户端程序编写  

1.  调用**Socket()**创建流套接字，并链接到服务端；
2.  调用**accept()**监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；
3.  调用**socket**类的**getOutputStream()**和**getInputStream()**获取输入流和输出流；
4.  关闭**socket**；

&emsp;&emsp;客户端Socket的建立  
```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings({"unused", "resource"})  
            Socket socket = new Socket("127.0.0.1", 2000);  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```
&emsp;&emsp;服务器端Socket的建立  
```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        ServerSocket server = null;  
        try {  
            server = new ServerSocket(2000);  
        } catch (IOException e) {  
            System.out.println("can not listen to :" + e);  
        }  
        Socket socket = null;  
        try {  
            socket = server.accept();  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```
&emsp;&emsp;打开输入/出流  
```java
PrintStream os = new PrintStream(new BufferedOutputStream(socket.getOutputStream());  
DataInputStream is = new DataInputStream(socket.getInputStream());
```
&emsp;&emsp;关闭Socket  
```java
os.close();is.close();socket.close();
```
&emsp;&emsp;简单的**client**/**server**程序  
```java
package com.aotmd.test;  
import java.io.*;  
import java.net.ConnectException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings("resource")  
            ServerSocket s = new ServerSocket(8888);  
            while (true) {  
                Socket s1 = s.accept();  
                OutputStream os = s1.getOutputStream();  
                DataOutputStream dos = new DataOutputStream(os);  
                dos.writeUTF("Hello," + s1.getInetAddress() + "port#" + s1.getPort() + "bye-bye!");  
                dos.close();  
                s1.close();  
                // s.close();  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        try {  
            Socket s1 = new Socket("127.0.0.1", 8888);  
            InputStream is =s1.getInputStream();  
            DataInputStream dis = new DataInputStream(is);  
            System.out.println(dis.readUTF());  
            dis.close();  
            s1.close();  
        } catch (ConnectException connExc) {  
            System.err.println("服务器连接失败！");  
        } catch (IOException e) {  
        }  
    }  
}
```
&emsp;&emsp;先运行服务器,然后运行客户端,会收到服务器发的信息.  
&emsp;&emsp;例子二  
```java
package com.aotmd.test;  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintStream;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        ServerSocket server;  
        try {  
            server = new ServerSocket(1234);  
            Socket sk = server.accept();  
            BufferedReader br = new BufferedReader(new InputStreamReader(sk.getInputStream()));  
            System.out.println(br.readLine());  
            br.close();  
            server.close();  
        } catch (IOException e) {  
            System.out.println(e);  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        Socket client;  
        PrintStream ps;  
        try {  
            client = new Socket("localhost", 1234);  
            System.out.println("连接成功！");  
            ps = new PrintStream(client.getOutputStream());  
            ps.println("客户端回显的对话");  
            client.close();  
        } catch (IOException e) {  
            System.out.println(e);  
        }  
    }  
}
```
## URL与Socket通信的区别
&emsp;&emsp;利用**URL**进行通信与利用**socket**进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：  
&emsp;&emsp;利用**socket**进行通信时，在服务器端运行一个**socket**通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在**socket**通信方式中，服务器是主动等待连接通信的到来。  
&emsp;&emsp;利用**URL**进行通信时，在服务器端常驻一个**CGI**程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在**URL**通信方式中，服务器是被动等待连接通信的到来。  

## UDP通信
&emsp;&emsp;在基于**TCP/IP**网络体系结构的网络中主要使用**TCP**和**UDP**（**UserDatagramProtocol**，用户数据报协议）来实现数据通信。**TCP**是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而**UDP**则是一种面向无连接的不可靠传输协议，它**不能**确保数据能正确到达目的端，但是它能提高网络通信的效率。  
&emsp;&emsp;**UDP Socket特性**  
&emsp;&emsp;通过UDP的UDP端口来实现UDP协议的网络通信。  
&emsp;&emsp;其工作过程如下：  
&emsp;&emsp;创建一个适当的要发送且注明收发人地址数据报；  
&emsp;&emsp;为一个特定的应用程序建立一个传输端口来传送和接收数据包；  
&emsp;&emsp;将数据报插入一个传输端口中进行传输；  
&emsp;&emsp;等待接收来自于传输端口的一个数据报；  
&emsp;&emsp;解码数据报以解开消息、接收者和其它信息；  
&emsp;&emsp;**Java UDP类**  
&emsp;&emsp;**DatagramSocket**  
&emsp;&emsp;用于接收和发送**UDP**的**Socket**实例。该类有3个构造函数：  
&emsp;&emsp;**DatagramSocket()**：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）  
&emsp;&emsp;**DatagramSocket(int port)**：创建实例，并固定监听**Port**端口的报文。通常用于服务端  
&emsp;&emsp;**DatagramSocket(int port,InetAddress localAddr)**：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自**LocalAddr**的报文。  
