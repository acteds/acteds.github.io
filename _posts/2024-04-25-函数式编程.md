---
layout: post
title: 函数式编程
categories: Java
description: Java笔记
keywords: Java
---
# 引言
Lambda、方法引用、Stream。



# 函数式编程

函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。

Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带`this`参数的函数。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数，函数式编程最早是数学家阿隆佐·邱奇研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。从**Java 8**开始，Java支持函数式编程。

## Lambda表达式

在Java程序中，经常遇到一大堆**单方法接口**，即一个接口只定义了一个方法：`Comparator`、`Runnable`、`Callable`。

以`Comparator`为例，调用`Arrays.sort()`时，可以传入一个`Comparator`实例，以匿名类方式编写如下：

```java
String[] array = ...
Arrays.sort(array, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return s1.compareTo(s2);
    }
});
```

从**Java 8**开始，可以用Lambda表达式替换**单方法接口**：

```java
Arrays.sort(array, (s1, s2) -> {
    return s1.compareTo(s2);
});
```

参数是`(s1, s2)`，参数类型可以省略，因为编译器可以自动推断出`String`类型。`-> { ... }`表示方法体，所有代码写在内部即可。Lambda表达式没有`class`定义，因此写法非常简洁。

如果只有一行`return xxx`的代码，完全可以用更简单的写法：`Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));`。返回值的类型也是由编译器自动推断的，这里推断出的返回值是`int`，因此，只要返回`int`，编译器就不会报错。

## 函数式接口

函数式接口是Java中的一个概念，它是指**只包含一个抽象方法的接口**。函数式接口可以用作Lambda表达式的类型，从而支持函数式编程的特性。在Java中，函数式接口可以通过`@FunctionalInterface`注解来**标识**，确保接口只包含一个抽象方法（同`@Override`注解只是用来让IDE检查的）。  

如`Callable`接口：

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

`Comparator`接口：

```java
@FunctionalInterface
public interface Comparator<T> {

    int compare(T o1, T o2);

    boolean equals(Object obj);

    default Comparator<T> reversed() {
        return Collections.reverseOrder(this);
    }

    default Comparator<T> thenComparing(Comparator<? super T> other) {
        ...
    }
    ...
}
```

虽然`Comparator`接口有很多方法，但只有一个抽象方法`int compare(T o1, T o2)`，其他的方法都是`default`方法或`static`方法。`boolean equals(Object obj)`是`Object`定义的方法，不算在接口方法内。因此，`Comparator`也是一个`FunctionalInterface`。

当使用函数式接口时，编译器会根据**Lambda表达式**或**方法引用**的上下文，将其**转换为函数式接口的实例**，并在需要时调用相应的方法。这些实例可以在运行时被JVM执行。  

因此，函数式接口的调用是在运行时由**JVM执行**的，**编译器**负责将**Lambda表达式**或**方法引用**转换为**函数式接口**的实例，以便在程序运行时进行调用。  

## 柯里化

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 柯里化（currying）的技巧，将一个多参数的方法转换为一系列单参数的方法。
        Function<Integer, Runnable> cr2 =
                (v1) -> () -> Main.staticMethod(v1);
        cr2.apply(1).run();
        
        Function<Integer, Function<Integer, Consumer<String>>> cr3 =
                (v1) -> (v2) -> (v3) -> Main.staticMethod(v1, v2, v3);
        cr3.apply(1).apply(2).accept("Consumer");
        
        Function<Integer, 自定义接口<Integer, Integer, Integer>> cr =
                (v1) -> (v4, v5, v6) -> Main.staticMethod(v1, v4, v5, v6);
        cr.apply(1).随便(3, 4, 5);
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V> {
    void 随便(T t, U u, V v);
}
```

柯里化是一种函数式编程的技术，通过这种技巧可以将**多参数函数**转换为一系列接受**单个参数的函数**。在柯里化中，每个函数只接受一个参数，并返回一个接受下一个参数的函数，直到接受完所有参数后返回最终结果。

1. `cr2`是一个`Function<Integer, Runnable>`，它接受一个整数参数，并返回一个`Runnable`，这个`Runnable`调用了`Main.staticMethod`方法。
2. `cr3`是一个`Function<Integer, Function<Integer, Consumer<String>>>`，它接受两个整数参数，并返回一个`Consumer<String>`，这个`Consumer<String>`调用了`Main.staticMethod`方法。
3. `cr`是一个`Function<Integer, 自定义接口<Integer, Integer, Integer>>`，它接受一个整数参数，并返回一个自定义接口的实例，这个自定义接口接受三个整数参数，并调用了`Main.staticMethod`方法。

通过柯里化，可以更灵活地使用多参数方法，将其转换为一系列单参数方法，使得代码更加模块化和易于理解。  也可以为多个参数。

拆解一个比较复杂的：

```java
public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    @Test
    void test() {
        t0<t1<Integer, t2<Double,String, f3<Boolean,Float,Person>>>> cr=
            ()->a->(b,c)->(d,e,f)->Main.staticMethod(a,b,c,d,e,f);
        cr.f0().f1(1).f2(2.3,"你好").n3(true,4.5f,new Person("小明",18));
        // 拆解：
        t0<t1<Integer, t2<Double,String, f3<Boolean,Float,Person>>>> cr2=
            ()-> {
                System.out.println("无参数");
                return a -> {
                    System.out.println("一个参数");
                    return (b, c) -> {
                        System.out.println("两个参数");
                        return (d, e, f) -> {
                            System.out.println("三个参数");
                            Main.staticMethod(a, b, c, d, e, f);
                        };
                    };
                };
            };
        t1<Integer, t2<Double,String, f3<Boolean,Float,Person>>> t1=cr2.f0();
        t2<Double,String, f3<Boolean,Float,Person>> t2=t1.f1(1);
        f3<Boolean,Float,Person> f3=t2.f2(2.3,"你好");
        f3.n3(true,4.5f,new Person("小明",18));
        //当然，泛型参数也可以不按顺序来，可以把第一个泛型参数当返回值，可能会被打。
    }
}
@FunctionalInterface
interface t0<T>{
    T f0();
}
@FunctionalInterface
interface t1<T,U>{
    U f1(T t);
}
@FunctionalInterface
interface t2<T,U,V>{
    V f2(T t,U u);
}
@FunctionalInterface
interface f3<T, U, V> {
    void n3(T t, U u, V v);
}
class Person{
    String nane;
    int age;

    public Person(String nane, int age) {
        this.nane = nane;
        this.age = age;
    }

    @Override
    public String toString() {return "Person{nane='" + nane + '\'' + ", age=" + age + '}'; }
}
```

JavaScript实现无限递归调用比较麻烦，而Java则很简单：

JavaScript：

```javascript
function add( ...args ) {
    let sum = 0;
    for (var i = 0; i < args.length; i++) {
        sum+=args[i];
    }
    let fn = function( ...args2 ) {
        return add( sum , ...args2 )
    }
    fn.toString = function() {
        return sum
    }
    return fn
}
console.log(add(1)(2)(3)(4).toString()); // 输出 10
console.log(add(1, 2)(3)(4, 5).toString()); // 输出 15
```

将上面的代码硬转为Java是这样的：

```java
public class Main {

    @Test
    void test() {
        T t=new T() {
            @Override
            public T2 f(Integer... i) {
                var o=new Object(){
                    int sum=0;
                };
                for (Integer integer : i) {
                    o.sum += integer;
                }
                T t=this;
                T2 t2=new T2() {
                    @Override
                    public T2 f(Integer... i) {
                        int sum2=0;
                        for (Integer integer : i) {
                            sum2 += integer;
                        }
                        return t.f(o.sum,sum2);
                    }
                    @Override
                    public String toString() {
                        return String.valueOf(o.sum);
                    }
                };
                return t2;
            }
        };
        System.out.println(t.f(1,2,3,4,5).f(6));//21
        System.out.println(t.f(1).f(2,3).f(4,5,6));//21
    }
}
@FunctionalInterface
interface T{
    T2 f(Integer ...i);
}
@FunctionalInterface
interface T2{
    T2 f(Integer ...i);
}
```

实际上完全不用这么麻烦：

```java
public class Main {
    @Test
    void test() {
        T t=new T() {
            int sum=0;
            @Override
            public T f(Integer... i) {
                for (Integer integer : i) {
                    sum += integer;
                }
                return this;
            }
            @Override
            public String toString() {
                int temp=sum;
                sum=0;
                return String.valueOf(temp);
            }
        };
        System.out.println(t.f(1,2,3,4,5).f(6));//21
        System.out.println(t.f(1).f(2,3).f(4,5,6));//21
    }
}
@FunctionalInterface
interface T{
    T f(Integer ...i);
}
```



## 方法引用

| 引用类型         | 方法引用示例           | 对应调用示例               |
| ---------------- | ---------------------- | -------------------------- |
| 静态方法引用     | `Main::staticMethod`   | `Main.staticMethod(...)`   |
| 实例方法引用     | `main::instanceMethod` | `main.instanceMethod(...)` |
| 构造方法引用     | `Main::new`            | `new Main(...)`            |
| 数组构造方法引用 | `Main[]::new`          | `new Main[?]`              |

这些方法引用可以简化代码，使其更易读和易维护。  

### 无参引用调用

| 类型     | 接口        | 代码                                            | 等效调用                 |
| -------- | ----------- | ----------------------------------------------- | ------------------------ |
| 静态方法 | Runnable    | `Runnable r=Main::staticMethod;r.run();`        | `Main.staticMethod();`   |
| 实例方法 | Runnable    | `Runnable r=main::instanceMethod;r.run();`      | `main.instanceMethod();` |
| 构造方法 | Supplier    | `Supplier<Main> s=Main::new;s.get();`           | `new Main();`            |
| 数组     | IntFunction | `IntFunction<Main[]> g=Main[]::new;g.apply(5);` | `new Main[5];`           |

实例：  

```java
package com.aotmd;
import java.util.function.IntFunction;
import java.util.function.Supplier;
public class Main {
    public static void staticMethod() {System.out.println("静态方法");}
    public void instanceMethod() {System.out.println("实例方法");}
    public Main() {System.out.println("构造方法");}
    public static void main(String[] args) {
        // 静态方法引用
        Runnable r1 = Main::staticMethod;//只能调用无参
        r1.run();//Main.staticMethod()
        // 实例方法引用
        Main main = new Main();
        Runnable r2 = main::instanceMethod;//只能调用无参
        r2.run();//main.instanceMethod()
        // 构造方法引用
        Supplier<Main> supplier = Main::new;//只能调用无参
        Main main2 = supplier.get();//new Main()
        // 数组构造方法引用
        IntFunction<Main[]> generator = Main[]::new;//只能调用无参
        Main[] array = generator.apply(5);//new Main[5]
    }
}
```

------

### 带参引用调用和柯里化（无返回值）

| 类型       | 接口                                           | 说明              |
| ---------- | ---------------------------------------------- | ----------------- |
| 无参方法   | Runnable                                       | `run()`调用       |
| 一个参数   | Consumer`<T>`                                  | `.accept(T)`调用  |
| 两个参数   | BiConsumer<T,U>                                | `accept(T,U)`调用 |
| 更多个参数 | 自定义函数式接口，并使用`@FunctionalInterface` | 调用随便          |

实例：  

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 方法引用
        Runnable a=Main::staticMethod;
        a.run();
        
        Consumer<String> c = Main::staticMethod;
        c.accept("Hello");
        
        BiConsumer<String,String> b=Main::staticMethod;
        b.accept("123","123");
        
        自定义接口<String,String,String> t=Main::staticMethod;
        t.随便("123","345","456");
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V> {
    void 随便(T t, U u, V v);
}
```

------

### 带参引用调用构造方法（有返回值）

| 类型       | 接口                                           | 说明             |
| ---------- | ---------------------------------------------- | ---------------- |
| 无参方法   | Supplier<类名>                                 | `get()`调用      |
| 一个参数   | Function<T,类名>                               | `apply(T)`调用   |
| 两个参数   | BiFunction<T,U,类名>                           | `apply(T,U)`调用 |
| 更多个参数 | 自定义函数式接口，并使用`@FunctionalInterface` | 调用随便         |

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.*;

public class Main {
    public Main(Object ...s) {
        System.out.println("构造方法："+Arrays.toString(s));
    }

    public static void main(String[] args) {
        // 构造方法引用
        Supplier<Main> supplier = Main::new;
        Main main1 = supplier.get();

        Function<String, Main> constructor = Main::new;
        Main main2 = constructor.apply("你好");

        BiFunction<Integer, String, Main> constructor2 = Main::new;
        Main main3 = constructor2.apply(1, "你好");

        自定义接口<Integer, String, Boolean, Main> constructor3 = Main::new;
        Main main4 = constructor3.随便(1, "你好", true);
        //柯里化
        自定义接口<Integer, String, Boolean, 自定义接口<Integer, String, Boolean, Main>> cr4 =
                (v1, v2, v3) -> (v4, v5, v6) -> new Main(v1, v2, v3, v4, v5, v6);
        Main main5 = cr4.随便(1, "你好", true).随便(1, "你好", true);
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V, R> {
    R 随便(T t, U u, V v);
}
```

------

### 展开一个`Main::new;`

```java
package com.aotmd;

import java.util.Arrays;

public class Main {
    public Main(Object ...s) {
        System.out.println("构造方法："+Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 方法引用
        接口<String,Main> f1=Main::new;
        // Lambda
        接口<String, Main> f2 = (s) -> {
            return new Main(s);
        };
        // 匿名内部类
        接口<String, Main> f3 = new 接口<String, Main>() {
            @Override
            public Main 方法(String s) {
                return new Main(s);
            }
        };
        // 普通内部类
        接口<String, Main> f4 =new Main().new A();
        // 静态内部类
        接口<String, Main> f5 =new Main.B();
        // 外部类
        接口<String, Main> f6 =new C();

        f1.方法(String.valueOf(f1.getClass()));
        f2.方法(String.valueOf(f2.getClass()));
        f3.方法(String.valueOf(f3.getClass()));
        f4.方法(String.valueOf(f4.getClass()));
        f5.方法(String.valueOf(f5.getClass()));
        f6.方法(String.valueOf(f6.getClass()));
    }
    class A implements 接口<String, Main> {
        @Override
        public Main 方法(String s) {
            return new Main(s);
        }
    }
    static class B implements 接口<String, Main> {
        @Override
        public Main 方法(String s) {
            return new Main(s);
        }
    }
}
class C implements 接口<String, Main> {
    @Override
    public Main 方法(String s) {
        return new Main(s);
    }
}
@FunctionalInterface
interface 接口<T, R> {
    R 方法(T t);
}
```

控制台：  

```java
构造方法：[]
构造方法：[class com.aotmd.Main$$Lambda$14/0x00000008000c0b40]
构造方法：[class com.aotmd.Main$$Lambda$15/0x00000008000c0d80]
构造方法：[class com.aotmd.Main$1]
构造方法：[class com.aotmd.Main$A]
构造方法：[class com.aotmd.Main$B]
构造方法：[class com.aotmd.C]
```

从上到下，越来越易懂。  

