---
layout: post
title: 函数式编程
categories: Java
description: Java笔记
keywords: Java
---
# 引言
Lambda、方法引用、Stream。



# 函数式接口

函数式接口是Java中的一个概念，它是指只包含一个抽象方法的接口。函数式接口可以用作Lambda表达式的类型，从而支持函数式编程的特性。在Java中，函数式接口可以通过`@FunctionalInterface`注解来标识，确保接口只包含一个抽象方法。  

当使用函数式接口时，编译器会根据**Lambda表达式**或**方法引用**的上下文，将其**转换为函数式接口的实**例，并在需要时调用相应的方法。这些实例可以在运行时被JVM执行。  

因此，函数式接口的调用是在运行时由**JVM执行**的，**编译器**负责将**Lambda表达式**或**方法引用**转换为**函数式接口**的实例，以便在程序运行时进行调用。  

### 方法引用：

| 引用类型         | 方法引用示例           | 对应调用示例               |
| ---------------- | ---------------------- | -------------------------- |
| 静态方法引用     | `Main::staticMethod`   | `Main.staticMethod(...)`   |
| 实例方法引用     | `main::instanceMethod` | `main.instanceMethod(...)` |
| 构造方法引用     | `Main::new`            | `new Main(...)`            |
| 数组构造方法引用 | `Main[]::new`          | `new Main[?]`              |

这些方法引用可以简化代码，使其更易读和易维护。  

### 无参引用调用：  

| 类型     | 接口        | 代码                                            | 等效调用                 |
| -------- | ----------- | ----------------------------------------------- | ------------------------ |
| 静态方法 | Runnable    | `Runnable r=Main::staticMethod;r.run();`        | `Main.staticMethod();`   |
| 实例方法 | Runnable    | `Runnable r=main::instanceMethod;r.run();`      | `main.instanceMethod();` |
| 构造方法 | Supplier    | `Supplier<Main> s=Main::new;s.get();`           | `new Main();`            |
| 数组     | IntFunction | `IntFunction<Main[]> g=Main[]::new;g.apply(5);` | `new Main[5];`           |

实例：  

```java
package com.aotmd;
import java.util.function.IntFunction;
import java.util.function.Supplier;
public class Main {
    public static void staticMethod() {System.out.println("静态方法");}
    public void instanceMethod() {System.out.println("实例方法");}
    public Main() {System.out.println("构造方法");}
    public static void main(String[] args) {
        // 静态方法引用
        Runnable r1 = Main::staticMethod;//只能调用无参
        r1.run();//Main.staticMethod()
        // 实例方法引用
        Main main = new Main();
        Runnable r2 = main::instanceMethod;//只能调用无参
        r2.run();//main.instanceMethod()
        // 构造方法引用
        Supplier<Main> supplier = Main::new;//只能调用无参
        Main main2 = supplier.get();//new Main()
        // 数组构造方法引用
        IntFunction<Main[]> generator = Main[]::new;//只能调用无参
        Main[] array = generator.apply(5);//new Main[5]
    }
}
```

------

### 带参引用调用方法：  

| 类型       | 接口                                           | 说明              |
| ---------- | ---------------------------------------------- | ----------------- |
| 无参方法   | Runnable                                       | `run()`调用       |
| 一个参数   | Consumer`<T>`                                  | `.accept(T)`调用  |
| 两个参数   | BiConsumer<T,U>                                | `accept(T,U)`调用 |
| 更多个参数 | 自定义函数式接口，并使用`@FunctionalInterface` | 调用随便          |

实例：  

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 方法引用
        Runnable a=Main::staticMethod;
        a.run();
        
        Consumer<String> c = Main::staticMethod;
        c.accept("Hello");
        
        BiConsumer<String,String> b=Main::staticMethod;
        b.accept("123","123");
        
        自定义接口<String,String,String> t=Main::staticMethod;
        t.随便("123","345","456");
        
        // 柯里化（currying）的技巧，将一个多参数的方法转换为一系列单参数的方法。
        Function<Integer, Runnable> cr2 =
                (v1) -> () -> Main.staticMethod(v1);
        cr2.apply(1).run();
        
        Function<Integer, Function<Integer, Consumer<String>>> cr3 =
                (v1) -> (v2) -> (v3) -> Main.staticMethod(v1, v2, v3);
        cr3.apply(1).apply(2).accept("Consumer");
        
        Function<Integer, 自定义接口<Integer, Integer, Integer>> cr =
                (v1) -> (v4, v5, v6) -> Main.staticMethod(v1, v4, v5, v6);
        cr.apply(1).随便(3, 4, 5);
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V> {
    void 随便(T t, U u, V v);
}
```

柯里化是一种函数式编程的技术，通过这种技巧可以将多参数函数转换为一系列接受单个参数的函数。  

1. `cr2`是一个`Function<Integer, Runnable>`，它接受一个整数参数，并返回一个`Runnable`，这个`Runnable`调用了`Main.staticMethod`方法。
2. `cr3`是一个`Function<Integer, Function<Integer, Consumer<String>>>`，它接受两个整数参数，并返回一个`Consumer<String>`，这个`Consumer<String>`调用了`Main.staticMethod`方法。
3. `cr`是一个`Function<Integer, 自定义接口<Integer, Integer, Integer>>`，它接受一个整数参数，并返回一个自定义接口的实例，这个自定义接口接受三个整数参数，并调用了`Main.staticMethod`方法。

通过柯里化，可以更灵活地使用多参数方法，将其转换为一系列单参数方法，使得代码更加模块化和易于理解。  

------

### 带参引用调用构造方法：  

| 类型       | 接口                                           | 说明             |
| ---------- | ---------------------------------------------- | ---------------- |
| 无参方法   | Supplier<类名>                                 | `get()`调用      |
| 一个参数   | Function<T,类名>                               | `apply(T)`调用   |
| 两个参数   | BiFunction<T,U,类名>                           | `apply(T,U)`调用 |
| 更多个参数 | 自定义函数式接口，并使用`@FunctionalInterface` | 调用随便         |

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.*;

public class Main {
    public Main(Object ...s) {
        System.out.println("构造方法："+Arrays.toString(s));
    }

    public static void main(String[] args) {
        // 构造方法引用
        Supplier<Main> supplier = Main::new;
        Main main1 = supplier.get();

        Function<String, Main> constructor = Main::new;
        Main main2 = constructor.apply("你好");

        BiFunction<Integer, String, Main> constructor2 = Main::new;
        Main main3 = constructor2.apply(1, "你好");

        自定义接口<Integer, String, Boolean, Main> constructor3 = Main::new;
        Main main4 = constructor3.随便(1, "你好", true);
        //柯里化
        自定义接口<Integer, String, Boolean, 自定义接口<Integer, String, Boolean, Main>> cr4 =
                (v1, v2, v3) -> (v4, v5, v6) -> new Main(v1, v2, v3, v4, v5, v6);
        Main main5 = cr4.随便(1, "你好", true).随便(1, "你好", true);
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V, R> {
    R 随便(T t, U u, V v);
}
```

------

### 展开一个`Main::new;`

```java
package com.aotmd;

import java.util.Arrays;

public class Main {
    public Main(Object ...s) {
        System.out.println("构造方法："+Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 方法引用
        接口<String,Main> f1=Main::new;
        // Lambda
        接口<String, Main> f2 = (s) -> {
            return new Main(s);
        };
        // 匿名内部类
        接口<String, Main> f3 = new 接口<String, Main>() {
            @Override
            public Main 方法(String s) {
                return new Main(s);
            }
        };
        // 普通内部类
        接口<String, Main> f4 =new Main().new A();
        // 静态内部类
        接口<String, Main> f5 =new Main.B();
        // 外部类
        接口<String, Main> f6 =new C();

        f1.方法(String.valueOf(f1.getClass()));
        f2.方法(String.valueOf(f2.getClass()));
        f3.方法(String.valueOf(f3.getClass()));
        f4.方法(String.valueOf(f4.getClass()));
        f5.方法(String.valueOf(f5.getClass()));
        f6.方法(String.valueOf(f6.getClass()));
    }
    class A implements 接口<String, Main> {
        @Override
        public Main 方法(String s) {
            return new Main(s);
        }
    }
    static class B implements 接口<String, Main> {
        @Override
        public Main 方法(String s) {
            return new Main(s);
        }
    }
}
class C implements 接口<String, Main> {
    @Override
    public Main 方法(String s) {
        return new Main(s);
    }
}
@FunctionalInterface
interface 接口<T, R> {
    R 方法(T t);
}
```

控制台：  

```java
构造方法：[]
构造方法：[class com.aotmd.Main$$Lambda$14/0x00000008000c0b40]
构造方法：[class com.aotmd.Main$$Lambda$15/0x00000008000c0d80]
构造方法：[class com.aotmd.Main$1]
构造方法：[class com.aotmd.Main$A]
构造方法：[class com.aotmd.Main$B]
构造方法：[class com.aotmd.C]
```

从上到下，越来越易懂。  

