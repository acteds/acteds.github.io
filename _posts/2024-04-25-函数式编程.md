---
layout: post
title: 函数式编程
categories: Java
description: Java笔记
keywords: Java
---
# 引言
Lambda、方法引用、Stream。



# 函数式编程

函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。

Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带`this`参数的函数。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数，函数式编程最早是数学家阿隆佐·邱奇研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。从**Java 8**开始，Java支持函数式编程。

## Lambda表达式

在Java程序中，经常遇到一大堆**单方法接口**，即一个接口只定义了一个方法：`Comparator`、`Runnable`、`Callable`。

以`Comparator`为例，调用`Arrays.sort()`时，可以传入一个`Comparator`实例，以匿名类方式编写如下：

```java
String[] array = ...
Arrays.sort(array, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return s1.compareTo(s2);
    }
});
```

从**Java 8**开始，可以用Lambda表达式替换**单方法接口**：

```java
Arrays.sort(array, (s1, s2) -> {
    return s1.compareTo(s2);
});
```

参数是`(s1, s2)`，参数类型可以省略，因为编译器可以自动推断出`String`类型。`-> { ... }`表示方法体，所有代码写在内部即可。Lambda表达式没有`class`定义，因此写法非常简洁。

如果只有一行`return xxx`的代码，完全可以用更简单的写法：`Arrays.sort(array, (s1, s2) -> s1.compareTo(s2));`。返回值的类型也是由编译器自动推断的，这里推断出的返回值是`int`，因此，只要返回`int`，编译器就不会报错。

## 函数式接口

函数式接口是Java中的一个概念，它是指**只包含一个抽象方法的接口**。函数式接口可以用作Lambda表达式的类型，从而支持函数式编程的特性。在Java中，函数式接口可以通过`@FunctionalInterface`注解来**标识**，确保接口只包含一个抽象方法（同`@Override`注解只是用来让IDE检查的）。  

如`Callable`接口：

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

`Comparator`接口：

```java
@FunctionalInterface
public interface Comparator<T> {

    int compare(T o1, T o2);

    boolean equals(Object obj);

    default Comparator<T> reversed() {
        return Collections.reverseOrder(this);
    }

    default Comparator<T> thenComparing(Comparator<? super T> other) {
        ...
    }
    ...
}
```

虽然`Comparator`接口有很多方法，但只有一个抽象方法`int compare(T o1, T o2)`，其他的方法都是`default`方法或`static`方法。`boolean equals(Object obj)`是`Object`定义的方法，不算在接口方法内。因此，`Comparator`也是一个`FunctionalInterface`。

当使用函数式接口时，编译器会根据**Lambda表达式**或**方法引用**的上下文，将其**转换为函数式接口的实例**，并在需要时调用相应的方法。这些实例可以在运行时被JVM执行。  

因此，函数式接口的调用是在运行时由**JVM执行**的，**编译器**负责将**Lambda表达式**或**方法引用**转换为**函数式接口**的实例，以便在程序运行时进行调用。  

## 柯里化

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 柯里化（currying）的技巧，将一个多参数的方法转换为一系列单参数的方法。
        Function<Integer, Runnable> cr2 =
                (v1) -> () -> Main.staticMethod(v1);
        cr2.apply(1).run();
        
        Function<Integer, Function<Integer, Consumer<String>>> cr3 =
                (v1) -> (v2) -> (v3) -> Main.staticMethod(v1, v2, v3);
        cr3.apply(1).apply(2).accept("Consumer");
        
        Function<Integer, 自定义接口<Integer, Integer, Integer>> cr =
                (v1) -> (v4, v5, v6) -> Main.staticMethod(v1, v4, v5, v6);
        cr.apply(1).随便(3, 4, 5);
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V> {
    void 随便(T t, U u, V v);
}
```

柯里化是一种函数式编程的技术，通过这种技巧可以将**多参数函数**转换为一系列接受**单个参数的函数**。在柯里化中，每个函数只接受一个参数，并返回一个接受下一个参数的函数，直到接受完所有参数后返回最终结果。

1. `cr2`是一个`Function<Integer, Runnable>`，它接受一个整数参数，并返回一个`Runnable`，这个`Runnable`调用了`Main.staticMethod`方法。
2. `cr3`是一个`Function<Integer, Function<Integer, Consumer<String>>>`，它接受两个整数参数，并返回一个`Consumer<String>`，这个`Consumer<String>`调用了`Main.staticMethod`方法。
3. `cr`是一个`Function<Integer, 自定义接口<Integer, Integer, Integer>>`，它接受一个整数参数，并返回一个自定义接口的实例，这个自定义接口接受三个整数参数，并调用了`Main.staticMethod`方法。

通过柯里化，可以更灵活地使用多参数方法，将其转换为一系列单参数方法，使得代码更加模块化和易于理解。  也可以为多个参数。

拆解一个比较复杂的：

```java
public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    @Test
    void test() {
        t0<t1<Integer, t2<Double,String, f3<Boolean,Float,Person>>>> cr=
            ()->a->(b,c)->(d,e,f)->Main.staticMethod(a,b,c,d,e,f);
        cr.f0().f1(1).f2(2.3,"你好").n3(true,4.5f,new Person("小明",18));
        // 拆解：
        t0<t1<Integer, t2<Double,String, f3<Boolean,Float,Person>>>> cr2=
            ()-> {
                System.out.println("无参数");
                return a -> {
                    System.out.println("一个参数");
                    return (b, c) -> {
                        System.out.println("两个参数");
                        return (d, e, f) -> {
                            System.out.println("三个参数");
                            Main.staticMethod(a, b, c, d, e, f);
                        };
                    };
                };
            };
        t1<Integer, t2<Double,String, f3<Boolean,Float,Person>>> t1=cr2.f0();
        t2<Double,String, f3<Boolean,Float,Person>> t2=t1.f1(1);
        f3<Boolean,Float,Person> f3=t2.f2(2.3,"你好");
        f3.n3(true,4.5f,new Person("小明",18));
        //当然，泛型参数也可以不按顺序来，可以把第一个泛型参数当返回值，可能会被打。
    }
}
@FunctionalInterface
interface t0<T>{
    T f0();
}
@FunctionalInterface
interface t1<T,U>{
    U f1(T t);
}
@FunctionalInterface
interface t2<T,U,V>{
    V f2(T t,U u);
}
@FunctionalInterface
interface f3<T, U, V> {
    void n3(T t, U u, V v);
}
class Person{
    String nane;
    int age;

    public Person(String nane, int age) {
        this.nane = nane;
        this.age = age;
    }

    @Override
    public String toString() {return "Person{nane='" + nane + '\'' + ", age=" + age + '}'; }
}
```

JavaScript实现无限递归调用比较麻烦，而Java则很简单：

JavaScript：

```javascript
function add( ...args ) {
    let sum = 0;
    for (var i = 0; i < args.length; i++) {
        sum+=args[i];
    }
    let fn = function( ...args2 ) {
        return add( sum , ...args2 )
    }
    fn.toString = function() {
        return sum
    }
    return fn
}
console.log(add(1)(2)(3)(4).toString()); // 输出 10
console.log(add(1, 2)(3)(4, 5).toString()); // 输出 15
```

将上面的代码硬转为Java是这样的：

```java
public class Main {

    @Test
    void test() {
        T t=new T() {
            @Override
            public T2 f(Integer... i) {
                var o=new Object(){
                    int sum=0;
                };
                for (Integer integer : i) {
                    o.sum += integer;
                }
                T t=this;
                T2 t2=new T2() {
                    @Override
                    public T2 f(Integer... i) {
                        int sum2=0;
                        for (Integer integer : i) {
                            sum2 += integer;
                        }
                        return t.f(o.sum,sum2);
                    }
                    @Override
                    public String toString() {
                        return String.valueOf(o.sum);
                    }
                };
                return t2;
            }
        };
        System.out.println(t.f(1,2,3,4,5).f(6));//21
        System.out.println(t.f(1).f(2,3).f(4,5,6));//21
    }
}
@FunctionalInterface
interface T{
    T2 f(Integer ...i);
}
@FunctionalInterface
interface T2{
    T2 f(Integer ...i);
}
```

实际上完全不用这么麻烦：

```java
public class Main {
    @Test
    void test() {
        T t=new T() {
            int sum=0;
            @Override
            public T f(Integer... i) {
                for (Integer integer : i) {
                    sum += integer;
                }
                return this;
            }
            @Override
            public String toString() {
                int temp=sum;
                sum=0;
                return String.valueOf(temp);
            }
        };
        System.out.println(t.f(1,2,3,4,5).f(6));//21
        System.out.println(t.f(1).f(2,3).f(4,5,6));//21
    }
}
@FunctionalInterface
interface T{
    T f(Integer ...i);
}
```



## 方法引用

| 引用类型         | 方法引用示例           | 对应调用示例               |
| ---------------- | ---------------------- | -------------------------- |
| 静态方法引用     | `Main::staticMethod`   | `Main.staticMethod(...)`   |
| 实例方法引用     | `main::instanceMethod` | `main.instanceMethod(...)` |
| 构造方法引用     | `Main::new`            | `new Main(...)`            |
| 数组构造方法引用 | `Main[]::new`          | `new Main[?]`              |

方法引用，是指如果某个方法签名和单方法接口签名恰好一致，就可以直接传入方法引用。 在这里，方法签名只看参数类型和返回类型，**不看方法名称**，也不看类的继承关系。

```java
String[] array = new String[] { "Apple", "Orange", "Banana", "Lemon" };
Arrays.sort(array, String::compareTo);
System.out.println(String.join(", ", array));
```

对于`String.compareTo()`：

```java
public final class String {
    public int compareTo(String o) {
        ...
    }
}
```

这个方法的签名只有一个参数，为什么和`int compare(T t, T t)`能匹配呢？

因为使用`类名::实例方法`这样的方法引用，则会有一个**隐含**的`this`参数，`String`类的`compareTo()`方法在实际调用的时候，**第一个隐含参数总是传入`this`**，相当于静态方法：

```java
public static int compareTo(String this, String o);
```

所以，`String.compareTo()`方法也可作为方法引用传入。

`类名::实例方法`这种方法引用形式，实际上是一种语法糖，它可以理解为对`实例::实例方法`的一种特殊情况。

使用`类名::实例方法`方法引用，实例：

```java
public class Main {
    String instanceMethod(){
        return "123";
    }
   static String call(I i){
        return  i.func(new Main());
   }

    @Test
    void test() {
        System.out.println(Main.call(Main::instanceMethod));
    }
}
interface I{
    String func(Main a);
}
```

这种方法引用需要一个接收者参数，因此`I`接口的`func`方法需要接收一个`Main`类型的参数。

有点类似通过反射的形式调用方法：

```java
public class Main {
    String instanceMethod(){
        return "123";
    }
    static String ref(Class<?> c,String name) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        return (String) c.getDeclaredMethod(name).invoke(new Main());
    }

    @Test
    void test() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        System.out.println(Main.ref(Main.class,"instanceMethod"));
    }
}
```

使用`实例::实例方法`方法引用，则没有隐含参数：

```java
public class Main {
    String instanceMethod(){
        return "123";
    }
   static String call(I i){
        return  i.func();
   }

    @Test
    void test() {
        Main main = new Main();
        System.out.println(Main.call(main::instanceMethod));
    }
}
interface I{
    String func();
}
```

这种方法引用不需要接收者参数，因为实例本身已经确定了。

### 无参引用调用

| 类型     | 常用接口    | 代码                                            | 等效调用                 |
| -------- | ----------- | ----------------------------------------------- | ------------------------ |
| 静态方法 | Runnable    | `Runnable r=Main::staticMethod;r.run();`        | `Main.staticMethod();`   |
| 实例方法 | Runnable    | `Runnable r=main::instanceMethod;r.run();`      | `main.instanceMethod();` |
| 构造方法 | Supplier    | `Supplier<Main> s=Main::new;s.get();`           | `new Main();`            |
| 数组     | IntFunction | `IntFunction<Main[]> g=Main[]::new;g.apply(5);` | `new Main[5];`           |

实例：  

```java
package com.aotmd;
import java.util.function.IntFunction;
import java.util.function.Supplier;
public class Main {
    public static void staticMethod() {System.out.println("静态方法");}
    public void instanceMethod() {System.out.println("实例方法");}
    public Main() {System.out.println("构造方法");}
    public static void main(String[] args) {
        // 静态方法引用
        Runnable r1 = Main::staticMethod;//只能调用无参
        r1.run();//Main.staticMethod()
        // 实例方法引用
        Main main = new Main();
        Runnable r2 = main::instanceMethod;//只能调用无参
        r2.run();//main.instanceMethod()
        // 构造方法引用
        Supplier<Main> supplier = Main::new;//只能调用无参
        Main main2 = supplier.get();//new Main()
        // 数组构造方法引用
        IntFunction<Main[]> generator = Main[]::new;//只能调用无参
        Main[] array = generator.apply(5);//new Main[5]
    }
}
```

------

### 带参引用调用和柯里化（无返回值）

| 类型       | 接口                                           | 说明              |
| ---------- | ---------------------------------------------- | ----------------- |
| 无参方法   | Runnable                                       | `run()`调用       |
| 一个参数   | Consumer`<T>`                                  | `accept(T)`调用   |
| 两个参数   | BiConsumer<T,U>                                | `accept(T,U)`调用 |
| 更多个参数 | 自定义函数式接口，并使用`@FunctionalInterface` | 调用随便          |

实例：  

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

public class Main {
    public static void staticMethod(Object ... s) {
        System.out.println("静态方法:"+ Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 方法引用
        Runnable a=Main::staticMethod;
        a.run();
        
        Consumer<String> c = Main::staticMethod;
        c.accept("Hello");
        
        BiConsumer<String,String> b=Main::staticMethod;
        b.accept("123","123");
        
        自定义接口<String,String,String> t=Main::staticMethod;
        t.随便("123","345","456");
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V> {
    void 随便(T t, U u, V v);
}
```

------

### 带参引用调用构造方法（有返回值）

| 类型       | 接口                                           | 说明             |
| ---------- | ---------------------------------------------- | ---------------- |
| 无参方法   | Supplier<类名>                                 | `get()`调用      |
| 一个参数   | Function<T,类名>                               | `apply(T)`调用   |
| 两个参数   | BiFunction<T,U,类名>                           | `apply(T,U)`调用 |
| 更多个参数 | 自定义函数式接口，并使用`@FunctionalInterface` | 调用随便         |

```java
package com.aotmd;

import java.util.Arrays;
import java.util.function.*;

public class Main {
    public Main(Object ...s) {
        System.out.println("构造方法："+Arrays.toString(s));
    }

    public static void main(String[] args) {
        // 构造方法引用
        Supplier<Main> supplier = Main::new;
        Main main1 = supplier.get();

        Function<String, Main> constructor = Main::new;
        Main main2 = constructor.apply("你好");

        BiFunction<Integer, String, Main> constructor2 = Main::new;
        Main main3 = constructor2.apply(1, "你好");

        自定义接口<Integer, String, Boolean, Main> constructor3 = Main::new;
        Main main4 = constructor3.随便(1, "你好", true);
        //柯里化
        自定义接口<Integer, String, Boolean, 自定义接口<Integer, String, Boolean, Main>> cr4 =
                (v1, v2, v3) -> (v4, v5, v6) -> new Main(v1, v2, v3, v4, v5, v6);
        Main main5 = cr4.随便(1, "你好", true).随便(1, "你好", true);
    }
}
@FunctionalInterface
interface 自定义接口<T, U, V, R> {
    R 随便(T t, U u, V v);
}
```

------

### 展开一个`Main::new;`

```java
package com.aotmd;

import java.util.Arrays;

public class Main {
    public Main(Object ...s) {
        System.out.println("构造方法："+Arrays.toString(s));
    }
    public static void main(String[] args) {
        // 方法引用
        接口<String,Main> f1=Main::new;
        // Lambda
        接口<String, Main> f2 = (s) -> {
            return new Main(s);
        };
        // 匿名内部类
        接口<String, Main> f3 = new 接口<String, Main>() {
            @Override
            public Main 方法(String s) {
                return new Main(s);
            }
        };
        // 普通内部类
        接口<String, Main> f4 =new Main().new A();
        // 静态内部类
        接口<String, Main> f5 =new Main.B();
        // 外部类
        接口<String, Main> f6 =new C();

        f1.方法(String.valueOf(f1.getClass()));
        f2.方法(String.valueOf(f2.getClass()));
        f3.方法(String.valueOf(f3.getClass()));
        f4.方法(String.valueOf(f4.getClass()));
        f5.方法(String.valueOf(f5.getClass()));
        f6.方法(String.valueOf(f6.getClass()));
    }
    class A implements 接口<String, Main> {
        @Override
        public Main 方法(String s) {
            return new Main(s);
        }
    }
    static class B implements 接口<String, Main> {
        @Override
        public Main 方法(String s) {
            return new Main(s);
        }
    }
}
class C implements 接口<String, Main> {
    @Override
    public Main 方法(String s) {
        return new Main(s);
    }
}
@FunctionalInterface
interface 接口<T, R> {
    R 方法(T t);
}
```

控制台：  

```java
构造方法：[]
构造方法：[class com.aotmd.Main$$Lambda$14/0x00000008000c0b40]
构造方法：[class com.aotmd.Main$$Lambda$15/0x00000008000c0d80]
构造方法：[class com.aotmd.Main$1]
构造方法：[class com.aotmd.Main$A]
构造方法：[class com.aotmd.Main$B]
构造方法：[class com.aotmd.C]
```

从上到下，越来越易懂。  

## Stream

Java从8开始，不但引入了Lambda表达式，还引入了一个全新的**流式**API：Stream API。它位于`java.util.stream`包中。

这个`Stream`不同于`java.io`的`InputStream`和`OutputStream`，它代表的是**任意**Java对象的序列。两者对比如下：

|      | `java.io`                | `java.util.stream`         |
| :--- | :----------------------- | -------------------------- |
| 存储 | 顺序读写的`byte`或`char` | 顺序输出的任意Java对象实例 |
| 用途 | 序列化至文件或网络       | 内存计算／业务逻辑         |

这个`Stream`和`List`也不一样，`List`存储的每个元素都是已经存储在内存中的某个Java对象，而`Stream`输出的元素可能并没有预先存储在内存中，而是**实时计算**出来的。`List`的用途是操作一组已存在的Java对象，而`Stream`实现的是**惰性计算**，两者对比如下：

|      | `java.util.List`         | `java.util.stream`   |
| :--- | :----------------------- | -------------------- |
| 元素 | 已分配并存储在内存       | 可能未分配，实时计算 |
| 用途 | 操作一组已存在的Java对象 | 惰性计算             |

如果要表示一个全体自然数的集合，显然，用`List`是不可能写出来的，因为自然数是无限的，内存再大也没法放到`List`中。但是，用`Stream`可以做到：

```java
Stream<BigInteger> naturals = createNaturalStream(); // 全体自然数
```

先不考虑`createNaturalStream()`方法是如何实现。

可以对每个自然数做一个平方，这样就把这个`Stream`转换成了另一个`Stream`：

```java
Stream<BigInteger> naturals = createNaturalStream(); // 全体自然数
Stream<BigInteger> streamNxN = naturals.map(n -> n.multiply(n)); // 全体自然数的平方
```

因为这个`streamNxN`也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用`limit()`方法截取前100个元素，最后用`forEach()`处理每个元素，这样，就打印出了前100个自然数的平方：

```java
Stream<BigInteger> naturals = createNaturalStream();
naturals.map(n -> n.multiply(n)) // 1, 4, 9, 16, 25...
        .limit(100)
        .forEach(System.out::println);
```

它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。

`Stream`的另一个特点是，一个`Stream`可以轻易地转换为另一个`Stream`，而不是修改原`Stream`本身。

最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。

```java
Stream<BigInteger> naturals = createNaturalStream(); // 不计算
Stream<BigInteger> s2 = naturals.map(BigInteger::multiply); // 不计算
Stream<BigInteger> s3 = s2.limit(100); // 不计算
s3.forEach(System.out::println); // 计算
```

惰性计算的特点是：一个`Stream`转换为另一个`Stream`时，实际上只存储了转换规则，并没有任何计算发生。

例如，创建一个全体自然数的`Stream`，不会进行计算，把它转换为上述`s2`这个`Stream`，也不会进行计算。再把`s2`这个无限`Stream`转换为`s3`这个有限的`Stream`，也不会进行计算。只有最后，调用`forEach`确实需要`Stream`输出的元素时，才进行计算。

通常把`Stream`的操作写成链式操作，代码更简洁：

```java
createNaturalStream()
    .map(BigInteger::multiply)
    .limit(100)
    .forEach(System.out::println);
```

因此，Stream API的基本用法就是：创建一个`Stream`，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：

```java
int result = createNaturalStream() // 创建Stream
             .filter(n -> n % 2 == 0) // 任意个转换
             .map(n -> n * n) // 任意个转换
             .limit(100) // 任意个转换
             .sum(); // 最终计算结果
```

### 创建`Stream`

要使用`Stream`，就必须先创建它，创建`Stream`有很多种方法。

#### `Stream.of`

创建`Stream`最简单的方式是直接用`Stream.of()`静态方法，传入可变参数即创建了一个能输出确定元素的`Stream`：

```java
Stream<String> stream = Stream.of("A", "B", "C", "D");
// forEach()方法相当于内部循环调用，
// 可传入符合Consumer接口的void accept(T t)的方法引用：
stream.forEach(System.out::println);
```

#### 基于数组或集合

```java
String[] array = {"A", "B", "C"};
Stream<String> stream1 = Arrays.stream(array);
stream1.forEach(System.out::println);

List<String> list = List.of("X", "Y", "Z");
Stream<String> stream2 = list.stream();
stream2.forEach(System.out::println);
```

把数组变成`Stream`使用`Arrays.stream()`方法。对于`Collection`（`List`、`Set`、`Queue`等），直接调用`stream()`方法就可以获得`Stream`。

上述创建`Stream`的方法都是把一个现有的序列变为`Stream`，它的元素是固定的。

#### `Stream.iterate`

创建`Stream`还可以通过`Stream.generate()`方法，它需要传入一个`Supplier`接口对象：

```java
Stream<String> s = Stream.generate(Supplier<String> sp);
```

基于`Supplier`创建的`Stream`会不断调用`Supplier.get()`方法来不断产生下一个元素，这种`Stream`保存的不是元素，而是算法，它可以用来表示**无限序列**。

例如，编写一个能不断生成自然数的`Supplier`，它的代码非常简单，每次调用`get()`方法，就生成下一个自然数：

```java
Stream<Long> natual = Stream.generate(new Supplier<>() {
    long n = 0;
    @Override
    public Long get() {
        n++;
        return n;
    }
});
// 注意：无限序列必须先变成有限序列再打印:
natual.limit(20).forEach(System.out::println);
```

不过它并不能代表所有自然数，因为`long`是有极限的,最大`2^63-1`。如果用`List`表示，即便在`int`范围内，也会占用巨大的内存，而`Stream`几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。

对于**无限序列**，如果直接调用`forEach()`或者`count()`这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用**`limit()`**方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用`forEach()`或者`count()`操作就没有问题。

`BigInteger`虽然没有极限，但`limit`方法只能传入`long`型，因此改成`BigInteger`，也没用：

```java
Stream<BigInteger> natual = Stream.generate(new Supplier<>() {
    private BigInteger n = BigInteger.ZERO;
    @Override
    public BigInteger get() {
        BigInteger result = n;
        n = n.add(BigInteger.ONE);
        return result;
    }
});
natual.limit(20).forEach(System.out::println);
```

#### `Stream.iterate`

`Stream.iterate()`方法的方法签名如下：

```java
static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
```

其中：
- `T`：流中元素的类型。
- `seed`：初始值，即流的第一个元素。
- `f`：生成流中后续元素的函数，它接受一个参数（前一个元素）并返回一个结果（下一个元素）。

`Stream.iterate()`方法会生成一个无限长度的流，从初始值开始，根据指定的函数生成后续的元素。要使这种流变为有限流，通常需要使用`limit()`方法来限制流的长度。

`UnaryOperator<T>`的方法签名如下：

```java
public interface UnaryOperator<T> extends Function<T, T> {}
```

而`Function<T, R>`是这样的：

```java
public interface Function<T, R> {
    R apply(T t);
}
```

因此`UnaryOperator<T>`，实际上就是这这样的：

```java
public interface UnaryOperator<T> {
    T apply(T t);
}
```

示例：

```java
Stream<Integer> stream = Stream.iterate(0, n -> n + 2);
```

斐波那契：

```java
Stream.iterate(new long[]{1, 1}, f -> new long[]{f[1], f[0] + f[1]})
        .limit(10)
        .mapToLong(f -> f[0])
        .forEach(s -> System.out.print(s + " "));
```

#### 其他方法

创建`Stream`的第三种方法是通过一些API提供的接口，直接获得`Stream`。

例如，`Files`类的`lines()`方法可以把一个文件变成一个`Stream`，每个元素代表文件的一行内容：

```java
try (Stream<String> lines = Files.lines(Paths.get("1.xml"))) {
    lines.forEach(System.out::println);
} catch (IOException e) {
    throw new RuntimeException(e);
}
```

此方法对于按行遍历文本文件十分有用。

正则表达式的`Pattern`对象有一个`splitAsStream()`方法，可以直接把一个长字符串分割成`Stream`序列而不是数组：

```java
Pattern p = Pattern.compile("\\s+");
Stream<String> s = p.splitAsStream("The quick brown fox jumps over the lazy dog");
s.forEach(System.out::println);
```

#### 基本类型

因为Java的泛型不支持基本类型，所以无法用`Stream<int>`这样的类型，会发生编译错误。为了保存`int`，只能使用`Stream<Integer>`，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了`IntStream`、`LongStream`和`DoubleStream`这三种使用基本类型的`Stream`，它们的使用方法和泛型`Stream`没有大的区别，设计这三个`Stream`的目的是提高运行效率：

```java
// 将int[]数组变为IntStream:
IntStream is = Arrays.stream(new int[] { 1, 2, 3 });
// 将Stream<String>转换为LongStream:
LongStream ls = List.of("1", "2", "3").stream().mapToLong(Long::parseLong);

is.forEach(System.out::println);
ls.forEach(System.out::println);
```

### `map`方法

`Stream.map()`是`Stream`最常用的一个转换方法，它**把一个`Stream`转换为另一个`Stream`**。

`map`操作，就是把一种操作运算，映射到一个序列的**每一个元素上**。例如，对`x`计算它的平方，可以使用函数`f(x) = x * x`。我们把这个函数映射到一个序列1，2，3，4，5上，就得到了另一个序列1，4，9，16，25。传入的方法需符合`Function`接口

```java
Stream<Integer> s = Stream.of(1, 2, 3, 4, 5);
Stream<Integer> s2 = s.map(n -> n * n);
s2.forEach(System.out::println);
```

### `Filter`方法

`Stream.filter()`是`Stream`的另一个常用**转换**方法。

`filter()`操作，就是对一个`Stream`的所有元素进行判断，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的`Stream`。

`filter()`方法接收的对象是`Predicate`接口对象，它定义了一个`test()`方法，负责判断元素是否符合条件：

```java
@FunctionalInterface
public interface Predicate<T> {
    // 判断元素t是否符合条件:
    boolean test(T t);
}
```

示例：

```java
public class Main {
    @Test
    void test() {
        IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
                .filter(Main::singular)
                .forEach(System.out::println);
    }
    static boolean singular(int t){
        return  t % 2 != 0;
    }
}
```

对对象操作：

```java
public class Main {
    @Test
    void test() {
        List<Person> persons = List.of(new Person("小明", 88), new Person("小黑", 62), new Person("小白", 45), new Person("小黄", 78), new Person("小红", 99), new Person("小林", 58));
        persons.stream()
            .filter(
                person -> person.score >= 60
            ).map(
                person -> person.name
            ).forEach(
                System.out::println
            );
    }

}
class Person {
    String name;
    int score;

    Person(String name, int score) {
        this.name = name;
        this.score = score;
    }
}
```

### `reduce`方法

`Stream.reduce()`是`Stream`的一个聚合方法，可以把一个`Stream`的所有元素按照聚合函数聚合成一个结果。

```java
int sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
    .reduce(0,(acc, n) -> acc + n);
System.out.println(sum); // 45
```

`reduce`的参数`identity`表示初始值。

```java
T reduce(T identity, BinaryOperator<T> accumulator);
```

`BinaryOperator`接口，定义了一个`apply()`方法，负责把上次累加的结果和本次的元素 进行运算，并返回累加的结果：

```java
@FunctionalInterface
public interface BinaryOperator<T> {
    // Bi操作：两个输入，一个输出
    T apply(T t, T u);
}
```

换成普通形式：

```java
int[] a={1, 2, 3, 4, 5, 6, 7, 8, 9};
int acc=0;
for (int n : a) {
    acc=acc + n;
}
int sum=acc;
System.out.println(sum); // 45
```

如果去掉初始值`identity`，会得到一个`Optional<Integer>`：

```java
Optional<Integer> sum = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
    .reduce((acc, n) -> acc + n);
if (sum.isPresent()) {
    System.out.println(sum.get());
}
```

因为`Stream`的元素有可能是0个，这样就没法调用`reduce()`的聚合函数了，因此会返回`Optional`对象，需要进一步判断结果是否存在。

注意：计算求积时，初始值必须设置为`1`。

将配置文件的每一行配置通过`map()`和`reduce()`操作聚合成一个`Map<String, String>`：

```java
List<String> props = List.of("profile=native", "debug=true", "logging=warn", "interval=500");
Map<String, String> map = props.stream()
        // 把k=v转换为Map[k]=v:
        .map(kv -> {
            String[] ss = kv.split("=", 2);
            return Map.of(ss[0], ss[1]);//Java8 及以下版本:Collections.singletonMap(ss[0], ss[1]);
        })
        // 把所有Map聚合到一个Map:
        .reduce(new HashMap<>(), (m, kv) -> {
            m.putAll(kv);
            return m;
        });
System.out.println(map);
```



一些`reduce`的特例：

`min(Comparator<? super T> comparator)`：返回流中的最小元素。

```java
Optional<T> minElement = stream.min((a, b) -> a.compareTo(b));
```

等于：

```java
Stream<Integer> integerStream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
Optional<Integer> minElement = integerStream.min(Integer::compareTo);
minElement.ifPresent(System.out::println);

Stream<Integer> integerStream2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
Optional<Integer> minElement2 = integerStream2.reduce(
        BinaryOperator.minBy(Integer::compareTo)
);
minElement2.ifPresent(System.out::println);
```

------

`max(Comparator<? super T> comparator)`：返回流中的最大元素。

```java
Optional<T> maxElement = stream.max((a, b) -> a.compareTo(b));
```

等于：（把之前的代码里的`min`换成`max`就行了）

------

针对`IntStream`、`LongStream`和`DoubleStream`，还额外提供了以下聚合方法：

`sum()`：返回流中元素的和。

```java
int sum = intStream.sum();
```

等于：

```java
IntStream integerStream = IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
int sum1 = integerStream.sum();
System.out.println(sum1);

Stream<Integer> integerStream2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
int sum2 = integerStream2.reduce(
        0,Integer::sum
);
System.out.println(sum2);
```

`average()`：返回流中元素的平均值。

```java
OptionalDouble average = doubleStream.average();
```

### `collect`方法

等于：

```java
IntStream integerStream = IntStream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
OptionalDouble average1 = integerStream.average();
average1.ifPresent(System.out::println);

Stream<Integer> integerStream2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
long[] average = integerStream2.collect(() -> new long[2],
        (ll, i) -> {
            ll[0]++;
            ll[1] += i;
        },
        (ll, rr) -> {
            ll[0] += rr[0];
            ll[1] += rr[1];
        });
System.out.println((double) average[1] / average[0]);
```

这段代码使用了 `collect` 方法来计算整数流的平均值。具体来说，它创建了一个 `long` 数组，数组的第一个元素用于存储流中的元素数量，第二个元素用于存储流中所有元素的总和。然后使用三个参数的 `collect` 方法来对流进行归约操作，将每个元素的值累加到总和中，并且每处理一个元素，计数器加1。最后，通过将总和除以元素数量得到平均值，并将结果转换为 `double` 类型进行打印。具体解释：

1. `() -> new long[2]`：创建一个新的 `long` 数组作为收集器的初始值，数组的第一个元素表示元素数量，第二个元素表示元素总和。
2. `(ll, i) -> { ll[0]++; ll[1] += i; }`：累加器函数，用于处理流中的每个元素。对于每个元素，将计数器加1，并将元素的值累加到总和中。
3. `(ll, rr) -> { ll[0] += rr[0]; ll[1] += rr[1]; }`：组合器函数，用于将两个部分结果合并为一个结果。在**并行流**的情况下，可能会有多个部分结果需要**合并**。
4. 最终得到的 `long[]` 数组中，第一个元素表示元素数量，第二个元素表示元素总和。通过将总和除以元素数量，得到平均值。

定义：

```java
<R> R collect(Supplier<R> supplier,
              BiConsumer<R, ? super T> accumulator,
              BiConsumer<R, R> combiner);
```

`collect`方法是一个终结操作，用于对流的元素执行可变的归约操作。可变的归约是指归约的结果是一个可变的结果容器，比如一个`ArrayList`，在归约过程中通过更新结果的状态来包含元素，而不是通过替换结果来包含元素。

在**并行流**的情况下，`collect`操作可以进行并行化，而不需要额外的同步。

`collect`方法的参数包括：

- `supplier`：一个函数，用于创建一个新的可变结果容器。对于并行执行，这个函数可能会被多次调用，并且必须每次返回一个新的值。
- `accumulator`：一个关联的、无副作用、无状态的函数，用于将一个元素合并到结果容器中。
- `combiner`：一个关联的、无副作用、无状态的函数，用于**合并两个部分结果容器**。这个函数必须与累加器函数兼容，它的作用是将第二个结果容器中的元素合并到第一个结果容器中。

`collect`方法的返回值是归约的结果。

JDK 中有许多现有类，其签名非常适合与方法引用一起用作的 `collect()`参数。例如，以下内容会将字符串累积成一个 `ArrayList`：

```java
 List<String> asList = stringStream
     .collect(ArrayList::new, ArrayList::add,ArrayList::addAll);
```

以下将获取字符串流并将它们连接成一个字符串：

```java
String concat = stringStream
    .collect(StringBuilder::new, 
             StringBuilder::append,
             StringBuilder::append
            ).toString();
```

测试并行合并：无并行：

```java
Stream<Integer> integerStream2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
long[] average = integerStream2.collect(() -> new long[2],
        (ll, i) -> {
            ll[0]++;
            ll[1] += i;
        },
        (ll, rr) -> {
            System.out.println("合并操作");//无输出
            ll[0] += rr[0];
            ll[1] += rr[1];
        });
System.out.println((double) average[1] / average[0]);
```

有并行：

```java
Stream<Integer> integerStream2 = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
long[] average = integerStream2.parallel().collect(() -> new long[2],
        (ll, i) -> {
            ll[0]++;
            ll[1] += i;
        },
        (ll, rr) -> {
            System.out.println("合并操作");//输出八次
            ll[0] += rr[0];
            ll[1] += rr[1];
        });
System.out.println((double) average[1] / average[0]);
```

正常。

### 区分转换与聚合

`map()`、`filter()`、`reduce()`。这些操作对`Stream`来说可以分为两类，一类是转换操作，即把一个`Stream`转换为另一个`Stream`，例如`map()`和`filter()`，另一类是聚合操作，即对`Stream`的每个元素进行计算，得到一个确定的结果，例如`reduce()`。

区分这两种操作是非常重要的，因为对于`Stream`来说，对其进行转换操作并不会触发任何计算。

```java
Stream<Long> s1 = Stream.generate(new Supplier<>() {
    long n = 0;
    @Override
    public Long get() {
        n++;
        System.out.println("得到参数："+n);
        return n;
    }
});
Stream<Long> s2 = s1.map(n -> n * n);
Stream<Long> s3 = s2.map(n -> n - 1);
Stream<Long> s4 = s3.limit(10);
System.out.println(s4); // 除此外，无其他输出
```

转换操作只是保存了转换规则，无论对一个`Stream`转换多少次，都不会有任何实际计算发生。

而聚合操作则不一样，聚合操作会立刻促使`Stream`输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，对一个`Stream`进行聚合操作，会触发一系列连锁反应。

```java
Stream<Long> s1 = Stream.generate(new Supplier<>() {
    long n = 0;
    @Override
    public Long get() {
        n++;
        System.out.println("得到参数："+n);
        return n;
    }
});
Stream<Long> s2 = s1.map(n -> n * n);
Stream<Long> s3 = s2.map(n -> n - 1);
Stream<Long> s4 = s3.limit(10);
s4.reduce(0L, Long::sum);
```

控制台：

```text
得到参数：1
得到参数：2
得到参数：3
得到参数：4
得到参数：5
得到参数：6
得到参数：7
得到参数：8
得到参数：9
得到参数：10
```

聚合操作是真正需要从`Stream`请求数据的，对一个`Stream`做聚合计算后，结果就不是一个`Stream`，而是一个其他的Java对象。



### 转换为其他类型

`collect(Collectors.toList())`：将流中的元素收集到一个`List`中。

```java
List<T> list = stream.collect(Collectors.toList());
```

------

`collect(Collectors.toSet())`：将流中的元素收集到一个`Set`中。

```java
Set<T> set = stream.collect(Collectors.toSet());
```

------

`collect(Collectors.joining(delimiter))`：将流中的元素拼接成一个字符串。

```java
String result = stream.collect(Collectors.joining(", "));
```

------

`toArray()` 是 `Stream` 类中的一个聚合方法，用于将流中的元素收集到一个数组中。该方法没有参数，返回一个包含流中所有元素的数组，语法如下：`Object[] toArray();`。

如果要将流中的元素收集到特定类型的数组中，可以使用带有 `IntFunction<A[]> generator` 参数的重载方法 `toArray(IntFunction<A[]> generator)`，其中 `generator` 是一个数组生成器函数，用于创建指定类型的数组。例如，如果要将流中的元素收集到一个 `String` 数组中，可以这样使用：

```java
String[] array = stream.toArray(String[]::new);
```

------

`collect(Collectors.toMap(keyMapper, valueMapper))`：将流中的元素收集到一个`Map`中，可以指定key和value的映射关系。

```java
List<String> list = Arrays.asList("apple", "banana", "cherry");
Map<Integer, String> map = list.stream().collect(Collectors.toMap(String::length, s -> s));
System.out.println(map);//{5=apple, 6=banana, 6=cherry}，注意到键的唯一性。
```

------

示例1：

```java
Stream<Integer> s1 = Stream.of(1, 2, 3, 4, 5)
Integer[] array = s1.toArray(Integer[]::new);
System.out.println(Arrays.toString(array));

Stream<Integer> s2 = Stream.of(1, 2, 3, 4, 5)
List<Integer> collect = s2.collect(Collectors.toList());
System.out.println(collect);
```

示例2：

```java
String[] array = new String[]{" 2019-12-31 ", "2020 - 01-09 ", "2020- 05 - 01 ", "2022 - 02 - 01", " 2025-01 -01"};
LocalDate[] array2 = Arrays.stream(array)
    .map(s -> s.replaceAll("\\s", ""))
    .map(LocalDate::parse)
    .toArray(LocalDate[]::new);

for (LocalDate localDate : array2) {
    System.out.println(localDate);
}
```

### 其他聚合方法

`collect(Collectors.groupingBy(classifier))`：根据指定的**分类器**对流中的元素进行**分组**。

```java
List<String> list = Arrays.asList("apple", "banana", "cherry");
Map<Integer, List<String>> groupedByLength = list.stream().collect(
    	Collectors.groupingBy(String::length)
	);
System.out.println(groupedByLength);//{5=[apple], 6=[banana, cherry]}
```

还可以指定聚合的类型：

```java
List<String> list = List.of("Apple", "Banana", "Blackberry", "Coconut", "Avocado", "Cherry", "Apricots");
Map<Object, Set<String>> groups = list.stream().collect(
    Collectors.groupingBy(
        s -> s.substring(0, 1), 
        Collectors.toSet()
    )
);
System.out.println(groups);//{A=[Apple, Avocado, Apricots], B=[Banana, Blackberry], C=[Coconut, Cherry]}
```

分组输出使用`Collectors.groupingBy()`，它需要提供两个函数：一个是分组的key，这里使用`s -> s.substring(0, 1)`，表示只要首字母相同的`String`分到一组，第二个是分组的value，这里直接使用`Collectors.toSet()`，表示输出为`Set`。

还支持嵌套分组：

```java
public class Main {
    @Test
    void test() {
        Address[] addresses = new Address[]{
                new Address("湖南省", "长沙市", "岳麓区"),
                new Address("湖南省", "长沙市", "雨花区"),
                new Address("湖南省", "永州市", "零陵区"),
                new Address("湖南省", "永州市", "冷水滩区"),
                new Address("江苏省", "南京市", "建邺区"),
                new Address("江苏省", "南京市", "秦淮区"),
                new Address("江苏省", "苏州市", "吴江区"),
                new Address("江苏省", "苏州市", "姑苏区"),
        };
        Map<String, Map<String, List<Address>>> addressGrouping =
                Arrays.stream(addresses)
                .collect(
                        Collectors.groupingBy(
                                Address::province,
                                Collectors.groupingBy(
                                        Address::city
                                )
                        )

                );
        System.out.println(addressGrouping.toString().replaceAll("=",":"));
    }
}

class Address {
    String province,city,district;

    Address(String province, String city, String district) {
        this.province = province;
        this.city = city;
        this.district = district;
    }

    public String province() {
        return province;
    }
    public String city() {
        return city;
    }
    public String district() {
        return district;
    }
    @Override
    public String toString() {
        return String.format("{province=\"%s\", city=\"%s\", district=\"%s\"}", province, city, district);
    }
}
```

控制台：

```json
{
    江苏省: {
        苏州市: [
            {province: "江苏省", city: "苏州市", district: "吴江区"},
            {province: "江苏省", city: "苏州市", district: "姑苏区"}
        ],
        南京市: [
            {province: "江苏省", city: "南京市", district: "建邺区"},
            {province: "江苏省", city: "南京市", district: "秦淮区"}
        ]
    },
    湖南省: {
        长沙市: [
            {province: "湖南省", city: "长沙市", district: "岳麓区"},
            {province: "湖南省", city: "长沙市", district: "雨花区"}
        ],
        永州市: [
            {province: "湖南省", city: "永州市", district: "零陵区"},
            {province: "湖南省", city: "永州市", district: "冷水滩区"}
        ]
    }
}
```



------

`collect(Collectors.partitioningBy(predicate))`：根据指定的**条件**对流中的元素进行**分区**，将满足条件的元素放入一个分区，不满足条件的放入另一个分区。

```java
List<String> list = Arrays.asList("apple", "banana", "cherry");
Map<Boolean, List<String>> partitioned = list.stream().collect(Collectors.partitioningBy(s -> s.startsWith("a")));
System.out.println(partitioned);//{false=[banana, cherry], true=[apple]}
```

------

`anyMatch(Predicate<? super T> predicate)`：判断流中**是否存在**满足指定条件的元素。

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
boolean anyMatch = list.stream().anyMatch(n -> n % 2 == 0);
System.out.println(anyMatch);//true，因为流中有偶数元素。
```

------

`allMatch(Predicate<? super T> predicate)`：判断流中的**所有元素**是否**都满足**指定条件。

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
boolean allMatch = list.stream().allMatch(n -> n > 0);
System.out.println(allMatch);//true，因为流中所有元素都大于0。
```

------

`noneMatch(Predicate<? super T> predicate)`：判断流中是否**不存在**满足指定条件的元素。

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
boolean noneMatch = list.stream().noneMatch(n -> n < 0);
System.out.println(noneMatch);//true，因为流中所有元素都不小于0。
```

------

`forEach()`，可以循环处理`Stream`的每个元素。

```java
Stream<String> stream = Stream.of("A", "B", "C", "D");
stream.forEach(System.out::println);
```



### 其他转换操作

排序`sorted()`方法：

```java
List<String> list = List.of("Orange", "apple", "Banana")
    .stream()
    .sorted()
    .collect(Collectors.toList());
System.out.println(list);
```

此方法要求`Stream`的每个元素必须实现`Comparable`接口。如果要自定义排序，传入指定的`Comparator`即可：

```java
List<String> list = List.of("Orange", "apple", "Banana")
    .stream()
    .sorted(String::compareToIgnoreCase)
    .collect(Collectors.toList());
```

------

去重，可以直接用`distinct()`：

```java
List.of("A", "B", "A", "C", "B", "D")
    .stream()
    .distinct()
    .collect(Collectors.toList()); // [A, B, C, D]
```

------

截取操作常用于把一个无限的`Stream`转换成有限的`Stream`，`skip()`用于跳过当前`Stream`的前N个元素，`limit()`用于截取当前`Stream`最多前N个元素：

```java
List.of("A", "B", "C", "D", "E", "F")
    .stream()
    .skip(2) // 跳过A, B
    .limit(3) // 截取C, D, E
    .collect(Collectors.toList()); // [C, D, E]
```

------

合并，将两个`Stream`合并为一个`Stream`可以使用`Stream`的静态方法`concat()`：

```java
Stream<String> s1 = List.of("A", "B", "C").stream();
Stream<String> s2 = List.of("D", "E").stream();
// 合并:
Stream<String> s = Stream.concat(s1, s2);
System.out.println(s.collect(Collectors.toList())); // [A, B, C, D, E]
```

------

如果`Stream`的元素是集合：

```java
Stream<List<Integer>> s = Stream.of(
        Arrays.asList(1, 2, 3),
        Arrays.asList(4, 5, 6),
        Arrays.asList(7, 8, 9));
```

而我们希望把上述`Stream`转换为`Stream<Integer>`，就可以使用`flatMap()`：

```java
Stream<Integer> i = s.flatMap(list -> list.stream());
```

`flatMap()`，是指把`Stream`的每个元素（这里是`List`）映射为`Stream`，然后合并成一个新的`Stream`。

------

并行，把一个普通`Stream`转换为可以并行处理的`Stream`非常简单，只需要用`parallel()`进行转换：

```java
Stream<String> s = ...
String[] result = s.parallel() // 变成一个可以并行处理的Stream
                   .sorted() // 可以进行并行排序
                   .toArray(String[]::new);
```

经过`parallel()`转换后的`Stream`只要可能，就会对后续操作进行并行处理。不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升。

也可以通过`parallelStream()`**直接创建一个并行流**：

```java
Stream<String> parallelStream = Arrays.asList("a", "b", "c").parallelStream();
```



### 特殊的方法

调试方法：`peek(Consumer<? super T> action)`：对流中的每个元素执行操作，并返回一个新的流。

   ```java
   List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
   Stream<Integer> peeked = list.stream()
                                .peek(System.out::println);
   ```

此方法需要在流真正计算的时候才会运行，即后面需要接聚合方法。

------

`findFirst()`：返回流中的第一个元素。

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> first = list.stream().findFirst();
first.ifPresent(System.out::println);//1，因为流中的第一个元素是1。
```

不会遍历流，只会取第一个：

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> first = list.stream()
        .peek(System.out::println)//1
        .findFirst();
first.ifPresent(System.out::println);//1
```

------

`findAny()`：返回流中的任意一个元素。

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> any = list.stream().findAny();
any.ifPresent(System.out::println);//输出结果为任意一个流中的元素。
```

不会遍历流，只会取一个：

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Optional<Integer> any = list.stream()
        .peek(System.out::println)//输出结果为任意一个流中的元素。
        .findAny();
any.ifPresent(System.out::println);//与peek相同
```

------

`count()`：返回流中元素的数量。

```java
long count = stream.count();
```

`peek`可能无输出，即可能不会遍历流，但还是会关闭流

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Stream<Integer> stream = list.stream();
long count = stream
        .peek(System.out::println)//无输出
        .count();
System.out.println(count);//5
```

在调用 `count` 操作时。如果流源（如 `List`）已知其包含的元素数量，并且管道中的中间操作不改变元素数量（即它们是非破坏性的），则可以直接从源头计算数量，而无需实际遍历流或评估中间操作。

`list` 的大小是已知的，而 `peek` 操作是非破坏性的（它只是简单地打印元素）。因此，流实现可以直接使用 `List` 的大小来确定计数，而无需实际打印元素或评估 `peek` 操作。

这种优化对于在不完全处理流的情况下确定计数很有用。然而，重要的是要注意，它依赖于特定的条件（已知大小，非破坏性的中间操作），并不总是适用。

依然会消耗流：

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
Stream<Integer> stream = list.stream();
long count = stream
        .peek(System.out::println)//无输出
        .count();
stream.forEach(System.out::println);//异常：流已关闭
System.out.println(count);
```

### `Collectors`的方法

`Collectors` 类提供了许多静态工厂方法，用于创建各种收集器，可以用于将流中的元素收集到不同类型的集合中，或进行分组、分区等操作。

#### 基本收集器

- `toList()`：将流中的元素收集到一个 `List` 中。
- `toSet()`：将流中的元素收集到一个 `Set` 中。
- `toMap(keyMapper, valueMapper, mergeFunction)`：将流中的元素收集到一个 `Map` 中，可以指定 key 和 value 的映射关系，并使用指定的合并函数在收集过程中处理相同的键值对。
- `toConcurrentMap(keyMapper, valueMapper)`：将流中的元素收集到一个并发 `Map` 中，可以指定 key 和 value 的映射关系。
- `toConcurrentMap(keyMapper, valueMapper, mergeFunction)`：将流中的元素收集到一个并发 `Map` 中，可以指定 key 和 value 的映射关系，并使用指定的合并函数在收集过程中处理相同的键值对，在合并函数中，如果遇到相同的键，则将旧值与新值用 "|" 连接起来。
- `joining()`：将流中的元素连接成一个字符串。
- `joining(delimiter)`：将流中的元素连接成一个字符串，使用指定的分隔符。
- `joining(delimiter, prefix, suffix)`：将流中的元素连接成一个字符串，使用指定的分隔符、前缀和后缀。

------

#### 汇总统计收集器

- `counting()`：计算流中元素的数量，返回一个 `long` 值。
- `summarizingInt()`, `summarizingLong()`, `summarizingDouble()`：对流中的元素进行汇总统计，返回一个包含 count、sum、min、average、max 等统计信息的 `IntSummaryStatistics`、`LongSummaryStatistics` 或 `DoubleSummaryStatistics` 对象。
- `averagingInt()`, `averagingLong()`, `averagingDouble()`：平均值，返回一个 `double` 值。
- `summingInt()`，`summingLong()`，`summingDouble()`：求和。

------

#### 最大最小值收集器

- `maxBy(comparator)`：根据指定的比较器找到流中的最大元素。
- `minBy(comparator)`：根据指定的比较器找到流中的最小元素。

------

#### 分组和分区收集器

- `groupingBy(classifier)`：根据指定的分类器对流中的元素进行分组。
- `groupingBy(classifier, downstream)`：根据指定的分类器对流中的元素进行分组，并将结果传递给另一个收集器进行进一步的收集。
- `groupingBy(classifier, supplier, downstream)`：根据指定的分类器对流中的元素进行分组，并使用指定的供应商提供 Map 初始容量，并将结果传递给另一个收集器进行进一步的收集。
- `groupingByConcurrent(classifier)`：根据指定的分类器对流中的元素进行分组，并将结果放入一个并发 `Map` 中。
- `groupingByConcurrent(classifier, downstream)`：根据指定的分类器对流中的元素进行分组，并将结果传递给另一个收集器进行进一步的收集，最终放入一个并发 `Map` 中。
- `groupingByConcurrent(classifier, supplier, downstream)`：根据指定的分类器对流中的元素进行分组，并使用指定的供应商提供 Map 初始容量，并将结果传递给另一个收集器进行进一步的收集，最终放入一个并发 `Map` 中。
- `partitioningBy(predicate)`：根据指定的条件对流中的元素进行分区。
- `partitioningBy(predicate, downstream)`：根据指定的条件对流中的元素进行分区，并将结果传递给另一个收集器进行进一步的收集。

------

#### 其他收集器

- `reducing(op)`：使用累加器函数递归地将流中的元素进行归约操作。
- `reducing(identity, op)`：使用给定的初始值和累加器函数递归地将流中的元素进行归约操作。
- `reducing(mapper, op)`：使用映射函数对流中的元素进行归约操作。
- `mapping(mapper, downstream)`：对流中的元素进行映射，并将结果传递给另一个收集器进行进一步的收集。
- `collectingAndThen(downstream, finisher)`：对收集器的结果应用一个转换函数。
- `filtering(predicate, downstream)`：根据指定的条件对流中的元素进行过滤，并将结果传递给另一个收集器进行进一步的收集。
- `flatMapping(mapper, downstream)`：对流中的元素进行扁平化映射，并将结果传递给另一个收集器进行进一步的收集。
- `teeing(first, second, merger)`：对流中的元素应用两个收集器，然后使用提供的合并器对两个结果进行合并。

这些方法提供了丰富的功能，可以灵活地处理流中的元素，进行分组、分区、汇总统计等操作，使得流式编程更加便捷和高效。

#### 示例

这里给出上述方法的一些示例代码：

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// counting()，'collect(counting())' 可被替换为 'count()'
long count = numbers.stream().collect(Collectors.counting());
System.out.println("Count: " + count);

// summarizingInt()，count，sum，min，average，max
IntSummaryStatistics stats = numbers.stream().collect(Collectors.summarizingInt(Integer::intValue));
System.out.println("Summarizing statistics: " + stats);

// averagingInt()，同average
double average = numbers.stream().collect(Collectors.averagingInt(Integer::intValue));
System.out.println("Average: " + average);

// reducing(),'collect(reducing())' 可被替换为 'reduce()'
int sum = numbers.stream().collect(Collectors.reducing(0, Integer::sum));
System.out.println("Sum: " + sum);

// collectingAndThen()，
String result = numbers.stream()
    .map(String::valueOf)
    .collect(Collectors.collectingAndThen(Collectors.joining(", "), s -> "[" + s + "]"));
System.out.println("Result: " + result);


// toMap(keyMapper, valueMapper, mergeFunction)
Map<Integer, String> map = numbers.stream()
    .collect(Collectors.toMap(
        num -> num,
        num -> "value" + num,
        (existing, replacement) -> existing + "|" + replacement));
System.out.println("Map: " + map);

// toConcurrentMap(keyMapper, valueMapper)
Map<Integer, String> concurrentMap1 = numbers.parallelStream()
    .collect(Collectors.toConcurrentMap(
        num -> num,
        num -> "value" + num));
System.out.println("Concurrent map: " + concurrentMap1);

// toConcurrentMap(keyMapper, valueMapper, mergeFunction)
Map<Integer, String> concurrentMap = numbers.parallelStream()
    .collect(Collectors.toConcurrentMap(
        num -> num,
        num -> "value" + num,
        //在合并函数中，如果遇到相同的键，则将旧值与新值用 "|" 连接起来。
        (existing, replacement) -> existing + "|" + replacement));
System.out.println("Concurrent map: " + concurrentMap);

// mapping(mapper, downstream)，'collect(mapping())' 可被替换为 'map().collect()'
List<String> mappedList = numbers.stream()
    .collect(Collectors.mapping(
        num -> "value" + num,
        Collectors.toList()));
System.out.println("Mapped list: " + mappedList);

// filtering(predicate, downstream)，同filter
List<Integer> filteredMap = numbers.stream()
    .collect(Collectors.filtering(
        num -> num % 2 == 0,
        Collectors.toList()));
System.out.println("Filtered map: " + filteredMap);

// flatMapping(mapper, downstream)，同flat
List<List<Integer>> nestedList = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6),
    Arrays.asList(7, 8, 9)
);
List<Integer> flattenedList = nestedList.stream()
    .collect(Collectors.flatMapping(
        List::stream,
        Collectors.toList()));
System.out.println("Flattened list: " + flattenedList);
```



联合使用：

```java
package test;

import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;


public class Main {
    @Test
    void test() {

        Product prod1 = new Product(1L, 1, new BigDecimal("15.5"), "面包", "零食");
        Product prod2 = new Product(2L, 2, new BigDecimal("20"), "饼干", "零食");
        Product prod3 = new Product(3L, 3, new BigDecimal("30"), "月饼", "零食");
        Product prod4 = new Product(4L, 3, new BigDecimal("10"), "青岛啤酒", "啤酒");
        Product prod5 = new Product(5L, 10, new BigDecimal("15"), "百威啤酒", "啤酒");
        List<Product> prodList = List.of(prod1,prod2,prod3,prod4,prod5);
        Map<String, Long> prodMap = prodList.stream().collect(
            Collectors.groupingBy(
                Product::getCategory,
                //求总数
                Collectors.counting()
            )
        );
        System.out.println(prodMap);

        Map<String, Integer> prodMap2 = prodList.stream().collect(
            Collectors.groupingBy(
                Product::getCategory,
                //求和
                Collectors.summingInt(
                    Product::getNum
                )
            )
        );
        System.out.println(prodMap2);

        /*把收集器的结果转换为另一种类型,String表示Category，Product表示每个分组中num属性最大的Product对象。*/
        Map<String, Product> prodMap3 = prodList.stream().collect(
            Collectors.groupingBy(//按Category分组
                Product::getCategory,
                Collectors.collectingAndThen(//对结果进行转换
                    Collectors.maxBy(//对每个分组中的元素取num属性最大的Product对象。
                        Comparator.comparingInt(Product::getNum)
                    ),
                    //这一步并没有直接得到最大的Product对象，而是得到了一个Optional<Product>对象
                    // ，因为有可能某个分组为空，所以需要用Optional来包装结果。
                    Optional::get
                )
            )
        );
        System.out.println(prodMap3);

        /*联合其他收集器*/
        Map<String, Set<String>> prodMap4 = prodList.stream().collect(
            Collectors.groupingBy(
                Product::getCategory,
                Collectors.mapping(
                    /*只取name，并放入set去重*/
                    Product::getName,
                    Collectors.toSet()
                )
            )
        );
        System.out.println(prodMap4);
    }
}
class Product{
    private final Long id;
    private final Integer num;
    private final BigDecimal price;
    private final String name;
    private final String category;

    public Long getId() {
        return id;
    }

    public Integer getNum() {
        return num;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public String getName() {
        return name;
    }

    public String getCategory() {
        return category;
    }

    Product(Long id, Integer num, BigDecimal price, String name, String category) {
        this.id = id;
        this.num = num;
        this.price = price;
        this.name = name;
        this.category = category;
    }

    @Override
    public String toString() {
        return String.format("Product{id=%d, num=%d, price=%s, name='%s', category='%s'}", id, num, price, name, category);
    }
}
```

说明一下比较复杂的

`prodMap3`：

按照`Product`对象的`Category`属性进行分组，并且对每个分组中的元素取`num`属性最大的`Product`对象。

具体来说，代码的执行步骤如下：

1. `prodList.stream()`：将`prodList`转换为一个`Stream`流。
2. `Collectors.groupingBy(Product::getCategory)`：使用`Collectors.groupingBy`方法按照`Product`对象的`Category`属性进行分组，得到一个`Map<String, List<Product>>`，其中`String`表示`Category`，`List<Product>`表示属于该`Category`的所有`Product`对象列表。
3. `Collectors.maxBy(Comparator.comparingInt(Product::getNum))`：使用`Collectors.maxBy`方法和`Comparator.comparingInt`方法找出每个分组中`num`属性最大的`Product`对象。这一步并没有直接得到最大的`Product`对象，而是得到了一个`Optional<Product>`对象，因为有可能某个分组为空，所以需要用`Optional`来包装结果。
4. `Collectors.collectingAndThen(..., Optional::get)`：使用`Collectors.collectingAndThen`方法对上一步得到的`Optional<Product>`对象进行处理，通过`Optional::get`方法获取其中的`Product`对象。这样就得到了每个分组中`num`属性最大的`Product`对象。
5. 最终，整个表达式将返回一个`Map<String, Product>`，其中`String`表示`Category`，`Product`表示每个分组中`num`属性最大的`Product`对象。



`prodMap4`：

按照 `Product` 对象的 `Category` 属性进行分组，并且将每个分组中的 `Product` 对象的 `Name` 属性收集到一个 `Set` 中。

具体来说，代码的执行步骤如下：

1. `prodList.stream()`：将 `prodList` 转换为一个 `Stream` 流。
2. `Collectors.groupingBy(Product::getCategory)`：使用 `Collectors.groupingBy` 方法按照 `Product` 对象的 `Category` 属性进行分组，得到一个 `Map<String, List<Product>>`，其中 `String` 表示 `Category`，`List<Product>` 表示属于该 `Category` 的所有 `Product` 对象列表。
3. `Collectors.mapping(Product::getName, Collectors.toSet())`：使用 `Collectors.mapping` 方法将每个分组中的 `Product` 对象转换为其 `Name` 属性，并将结果收集到一个 `Set` 中。这样就得到了一个 `Map<String, Set<String>>`，其中 `String` 表示 `Category`，`Set<String>` 表示每个分组中的 `Name` 属性集合。
4. 最终，整个表达式将返回一个 `Map<String, Set<String>>`，其中 `String` 表示 `Category`，`Set<String>` 表示每个分组中的 `Name` 属性集合。
