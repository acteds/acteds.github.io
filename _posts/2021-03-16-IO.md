---
layout: post
title: I/O
categories: Java
description: Java笔记
keywords: Java
---
# 引言
java的I/O笔记，常见的字节流和字符流，以及Filter模式、序列化、读取chasspath资源、读取zip、读取jar、重定向标准输入输出、机器无关的输入输出流、随意读写的输入输出流、缓存流、工具类。  


# I/O
**文件**是用来保存计算机的数据而文件处理是任何种编程语言所必备的一项重要功能,只有具备这一功能才可以支持处理大量持久性数据的商业应用。  

`java.io`包中最重要的就是五个类和一个接口：  

1. **`File`类**：用于表示文件和目录的路径名抽象表示形式。它提供了创建、删除、重命名等操作文件和目录的方法，以及获取文件属性的方法。
2. **`OutputStream`类**：所有输出流的基类，用于向输出目标写入字节流。它是一个抽象类，定义了写入字节流的基本方法，如`write(int b)`、`flush()`和`close()`。
3. **`InputStream`类**：所有输入流的基类，用于从输入源读取字节流。它也是一个抽象类，定义了读取字节流的基本方法，如`read()`、`available()`和`close()`。
4. **`Reader`类**：所有字符输入流的基类，用于从输入源读取字符流。它也是一个抽象类，定义了读取字符流的基本方法，如`read(char[] cbuf, int off, int len)`、`skip(long n)`和`close()`。
5. **`Writer`类**：所有字符输出流的基类，用于向输出目标写入字符流。它也是一个抽象类，定义了写入字符流的基本方法，如`write(String str, int off, int len)`、`flush()`和`close()`。
6. **`Serializable`接口**：用于标记类的对象可以被序列化。实现`Serializable`接口的类可以将其对象转换为字节序列，以便存储或传输。序列化后的对象可以在需要时进行反序列化，恢复成原始对象。

**按照不同的方式,将流分为不同的类型按数据流动方向**：  
- 输入流：只能从中读取字节数据,而不能向其写出数据，通过抽象类`InputStream` 实现。
- 输出流：只能向其写入字节数据,而不能从中读取数据 ，通过抽象类 `OutputStream`实现。

**按照流所处理的数据类型**：  
- 字节流：用于处理**字节**数据  
- 字符流：用于处理 Unicode**字符**数据  

**按照流所处理的源**：  
- 节点流(低级流)：向一个特定的IO设备读/写数据的流。  
- 处理流(高级流)：对已存在的流进行连接和封装的流。处理流是“处理流的流”,它用来处理其他的流。 

所有从 `InputStream`或 `Reader`派生的类**都有**一个基本的`read()`方法,用读取的字节或者读取字节数组;  

所有从 `OutputStream`或 `Writer`派生的类**都有**一个基本的 `write()`方法,用于写入单一的字节或者整个字节数组。  

**一般很少使用单一的流类来产生输入输出流**,而是使用这两个方法绐其他的流类提供数锯,也就是说,通过**多个**流对象的连接和封装使用实际的流。  

------

如果我们需要读写的是字符，并且字符**不全是**单字节表示的ASCII字符，那么，按照`char`来读写显然更方便，这种流称为**字符流**。  

Java提供了`Reader`和`Writer`表示**字符流**，**字符流**传输的**最小数据单位**是`char`。  

例如，我们把`char[]`数组`Hi你好`这4个字符用`Writer`字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符`H`和`i`各占一个字节，中文字符`你好`各占3个字节：  

```txt
0x48
0x69
0xe4bda0
0xe5a5bd
```
反过来，我们用`Reader`读取以UTF-8编码的这8个字节，会从`Reader`中得到`Hi你好`这4个字符。  

`Reader`和`Writer`**本质上**是一个能自动编解码的`InputStream`和`OutputStream`。  

使用`Reader`，数据源虽然是**字节**，但我们读入的数据都是`char`类型的字符，原因是`Reader`内部把读入的`byte`做了编码，转换成了`char`。使用`InputStream`，我们读入的数据和原始二进制数据一模一样，是`byte[]`数组，但是我们可以自己把二进制`byte[]`数组按照某种编码转换为字符串。究竟使用`Reader`还是`InputStream`，要取决于具体的使用场景。  

如果数据源不是文本，就**只能**使用`InputStream`，如果数据源是文本，使用`Reader`更方便一些。`Writer`和`OutputStream`是类似的。  

------

## File

| 构造方法                          | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| File(File parent, String child)   | 根据 `parent` 抽象路径名和 `child` 路径名字符串创建一个新 `File` 实例。 |
| File(String pathname)             | 通过将给定路径名字符串转换为抽象路径名来创建一个新 `File` 实例。 |
| File(String parent, String child) | 根据 `parent` 路径名字符串和 `child` 路径名字符串创建一个新 `File` 实例。 |
| File(URI uri)                     | 通过将给定的 `file: URI` 转换为一个抽象路径名来创建一个新的 `File` 实例。 |

`File`对象可以用绝对路径或相对路径来构造。在Windows中，路径分隔符是`\`，在Java中需要用`\\`表示；而在Linux中，路径分隔符是`/`。为了方便跨平台使用，Java提供了`File.separator`来表示当前系统的路径分隔符。  

**绝对路径：**  

```java
File file1=new File(file,"a.txt");
File file2=new File("D:","a.txt");  
File file3=new File("D:"+ File.separator+"a.txt");  
File file4=new File("D:\\a.txt");  
URI uri = new URI("file:///path/to/file.txt");
File file5 = new File(uri);
```
**相对路径：**  

传入相对路径时，相对路径前面加上当前目录就是绝对路径：  

```java
// 假设当前目录是C:\Docs
File f1 = new File("sub\\javac"); // 绝对路径是C:\Docs\sub\javac
File f3 = new File(".\\sub\\javac"); // 绝对路径是C:\Docs\sub\javac
File f3 = new File("..\\sub\\javac"); // 绝对路径是C:\sub\javac
```
可以用`.`表示当前目录，`..`表示上级目录。  

关于`getPath()`、`getAbsolutePath()`和`getCanonicalPath()`方法：  

- `getPath()`：返回构造方法传入的路径。如果路径是相对路径，则返回的是相对于当前工作目录的路径；如果路径是绝对路径，则返回的是完整的路径。
- `getAbsolutePath()`：返回绝对路径。无论构造方法传入的是相对路径还是绝对路径，都返回绝对路径。
- `getCanonicalPath()`：返回规范路径。规范路径是绝对路径的一种表示形式，它会解析所有的符号链接、相对路径等，使得最终的路径没有多余的部分。

在实际应用中，通常使用`getCanonicalPath()`获取文件的规范路径，以确保路径的唯一性和规范性。  

------

### 文件和目录  
`File`对象可以**表示文件也可以表示目录**，即使传入的文件或目录不存在也不会出错。只有在调用`File`对象的方法时才会进行磁盘操作。例如，可以使用`isFile()`和`isDirectory()`方法来判断`File`对象是否表示文件或目录。对于文件，还可以使用`canRead()`、`canWrite()`、`canExecute()`和`length()`等方法来检查文件的权限和大小。对于目录，`canExecute()`表示是否可以列出其包含的文件和子目录。  

当File对象表示一个文件时：  

- `createNewFile()`方法用于创建一个新文件，如果文件已存在则返回 false。  
- `delete()`方法用于删除文件或者空目录，如果删除成功则返回 true。

File对象如果表示一个目录，可以通过以下方法创建和删除目录：  
- `boolean mkdir()`：创建当前File对象表示的目录；
- `boolean mkdirs()`：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；
- `boolean delete()`：删除当前File对象表示的目录，当前目录必须为空才能删除成功。

**临时文件**  

有些时候，程序需要读写一些临时文件，File对象提供了`createTempFile()`来创建一个临时文件，以及`deleteOnExit()`在JVM退出时自动删除该文件。  

```java
File f = File.createTempFile("tmp-", ".txt"); // 提供临时文件的前缀和后缀
f.deleteOnExit(); // JVM退出时自动删除
System.out.println(f.isFile());//true
System.out.println(f.getAbsolutePath());//C:\Users\*\AppData\Local\Temp\tmp-13660335841682657349.txt
```
**遍历文件和目录**  

当File对象表示一个目录时，可以使用`list()`和`listFiles()`列出目录下的文件和子目录名。还`listFiles()`提供了一系列重载方法，可以**过滤**不想要的文件和目录：  

```java
File f = new File("C:\\Windows");
File[] fs2 = f.listFiles(new FilenameFilter() { // 仅列出.exe文件
    public boolean accept(File dir, String name) {
        return name.endsWith(".exe"); // 返回true表示接受该文件
    }
});
if (fs2 != null) {
    for (File temp : fs2) {
        System.out.println(temp);
    }
}
```
因为接口只有一个方法，因此匿名类可以写为lambda形式：  
```java
File[] fs2 = f.listFiles((dir, name) -> name.endsWith(".exe"));
```
### 详细方法  

| 返回类型        | 方法                                                         | 说明                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean         | canExecute()                                                 | 测试应用程序是否可以执行此抽象路径名表示的文件。             |
| boolean         | canRead()                                                    | 测试应用程序是否可以读取此抽象路径名表示的文件。             |
| boolean         | canWrite()                                                   | 测试应用程序是否可以修改此抽象路径名表示的文件。             |
| int             | compareTo(File pathname)                                     | 按字母顺序比较两个抽象路径名。                               |
| boolean         | createNewFile()                                              | 当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。 |
| static File     | createTempFile(String prefix, String suffix)                 | 在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。 |
| static File     | createTempFile(String prefix, String suffix, File directory) | 在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。 |
| boolean         | delete()                                                     | 删除此抽象路径名表示的文件或目录。                           |
| void            | deleteOnExit()                                               | 在虚拟机终止时，请求删除此抽象路径名表示的文件或目录。       |
| boolean         | equals(Object obj)                                           | 测试此抽象路径名与给定对象是否相等。                         |
| boolean         | **exists()**                                                 | 测试此抽象路径名表示的文件或目录是否存在。                   |
| File            | getAbsoluteFile()                                            | 返回此抽象路径名的绝对路径名形式。                           |
| String          | **getAbsolutePath()**                                        | 返回此抽象路径名的绝对路径名字符串。                         |
| File            | getCanonicalFile()                                           | 返回此抽象路径名的规范形式。                                 |
| String          | **getCanonicalPath()**                                       | 返回此抽象路径名的规范路径名字符串。                         |
| long            | getFreeSpace()                                               | 返回此抽象路径名指定的分区中未分配的字节数。                 |
| String          | **getName()**                                                | 返回由此抽象路径名表示的文件或目录的名称。                   |
| String          | **getParent()**                                              | 返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回 null。 |
| File            | getParentFile()                                              | 返回此抽象路径名父目录的抽象路径名；如果此路径名没有指定父目录，则返回 null。 |
| String          | **getPath()**                                                | 将此抽象路径名转换为一个路径名字符串，返回构造方法传入的路径。 |
| long            | getTotalSpace()                                              | 返回此抽象路径名指定的分区大小。                             |
| long            | getUsableSpace()                                             | 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。         |
| int             | hashCode()                                                   | 计算此抽象路径名的哈希码。                                   |
| boolean         | isAbsolute()                                                 | 测试此抽象路径名是否为绝对路径名。                           |
| boolean         | **isDirectory()**                                            | 测试此抽象路径名表示的文件是否是一个目录。                   |
| boolean         | **isFile()**                                                 | 测试此抽象路径名表示的文件是否是一个标准文件。               |
| boolean         | isHidden()                                                   | 测试此抽象路径名指定的文件是否是一个隐藏文件。               |
| long            | lastModified()                                               | 返回此抽象路径名表示的文件最后一次被修改的时间。             |
| long            | **length()**                                                 | 返回由此抽象路径名表示的文件的长度。                         |
| String\[\]      | list()                                                       | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 |
| String\[\]      | list(FilenameFilter filter)                                  | 返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。 |
| File\[\]        | listFiles()                                                  | 返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 |
| File\[\]        | listFiles(FileFilter filter)                                 | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 |
| File\[\]        | listFiles(FilenameFilter filter)                             | 返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 |
| static File\[\] | listRoots()                                                  | 列出可用的文件系统根。                                       |
| boolean         | **mkdir()**                                                  | 创建此抽象路径名指定的目录。                                 |
| boolean         | **mkdirs()**                                                 | 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。   |
| boolean         | **renameTo(File dest)**                                      | 重新命名此抽象路径名表示的文件。                             |
| boolean         | setExecutable(boolean executable)                            | 设置此抽象路径名所有者执行权限的一个便捷方法。               |
| boolean         | setExecutable(boolean executable, boolean ownerOnly)         | 设置此抽象路径名的所有者或所有用户的执行权限。               |
| boolean         | setLastModified(long time)                                   | 设置此抽象路径名指定的文件或目录的最后一次修改时间。         |
| boolean         | setReadable(boolean readable)                                | 设置此抽象路径名所有者读权限的一个便捷方法。                 |
| boolean         | setReadable(boolean readable, boolean ownerOnly)             | 设置此抽象路径名的所有者或所有用户的读权限。                 |
| boolean         | setReadOnly()                                                | 标记此抽象路径名指定的文件或目录，从而只能对其进行读操作。   |
| boolean         | setWritable(boolean writable)                                | 设置此抽象路径名所有者写权限的一个便捷方法。                 |
| boolean         | setWritable(boolean writable, boolean ownerOnly)             | 设置此抽象路径名的所有者或所有用户的写权限。                 |
| String          | toString()                                                   | 返回此抽象路径名的路径名字符串。                             |
| URI             | toURI()                                                      | 构造一个表示此抽象路径名的 file: URI。                       |
| URL             | toURL()                                                      | **已过时。** *此方法不会自动转义 URL 中的非法字符。建议新的代码使用以下方式将抽象路径名转换为 URL：首先通过 toURI 方法将其转换为 URI，然后通过 URI.toURL 方法将 URI 装换为 URL。* |

## 字节流
字节流是按字节读/写二进制数据字节流有两个基本的类：`InputStream`类`OutputStream`类  

`InputStream`类用于处理**字节输入流**,`OutputStream`类用于处理**字节输出流**。它们都是**抽象类**,本身**不能直接用来创建对象**。所有字节处理流都由`InputStream`/`OutputStream`派生而来  

### InputStream
**InputStream常用方法**  

| 方法                                                | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| **int read()**                                      | 读取一个字节，并返回字节表示的`int`值（0~255），如果已读到末尾，返回`-1`表示不能继续读取了。 |
| **int read(byte\[\] buffer)**                       | 将数据读入一个字节数组,同时返回读取的字节数，若没有更多数据了则返回`-1`。 |
| **int read(byte\[\] buffer,int offset,int length)** | 将数据读入一个字节数组,放到**数组**的`offset`指定的位置开始,并用`length`来指定读取的最大字节数，若没有更多数据了则返回`-1`。 |
| void close()                                        | 关闭流。                                                     |
| int available()                                     | 返回可以从中读取的字节数。                                   |
| long skip(long n)                                   | 在输入流中跳过n个字节,将实际跳过的字节数返回。               |
| boolean markSupported()                             | 判断流是否支持标记功能。                                     |
| void mark(int readlimit)                            | 在支持标记的输入流的当前位置设置一个标记。                   |
| void reset()                                        | 返回到流的上一个标记。注意必须流支持标记功能。               |

**InputStream相关类**  

**低级 `InputStream`类：**  

- `InputStream`：抽象类，所有输入流的基类。
- `ByteArrayInputStream`：从字节数组读取数据的输入流。
- `PipedInputStream`：与`PipedOutputStream`配合使用，用于线程间通信。
- `FileInputStream`：从文件中读取数据的输入流。

**高级 `InputStream`类：**  
- `DataInputStream`：允许应用程序以适当方式从底层输入流中读取基本 Java 数据类型。
- `BufferedInputStream`：带有缓冲区的输入流，提高了从文件读取数据的性能。

#### FileInputStream
`FileInputStream`是`InputStream`的一个子类。顾名思义，`FileInputStream`就是从文件流中读取数据。  

一个一个读：  

```java
FileInputStream fis;
int n;
fis = new FileInputStream("./log/output.log");// 读取文件
while ((n = fis.read()) != -1)
    System.out.print((char)n);
fis.close();
```
**缓冲**  

在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。`InputStream`提供了两个重载方法来支持读取多个字节：  

- `int read(byte[] b)`：读取若干字节并填充到`byte[]`数组，返回读取的字节数
- `int read(byte[] b, int off, int len)`：指定`byte[]`数组的偏移量和最大填充数

利用上述方法一次读取多个字节时，需要先定义一个`byte[]`数组作为缓冲区，`read()`方法会尽可能多地读取字节到缓冲区， 但**不会超过**缓冲区的大小。`read()`方法的返回实际读取了多少个字节。如果返回`-1`，表示没有更多的数据了。  
```java
FileInputStream fis;
int n;
fis = new FileInputStream("./log/output.log");// 读取文件
byte[] a = new byte[256];
while ((n = fis.read(a)) != -1)
    System.out.write(a, 0, n);// 显示
fis.close();
```
在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。  

`InputStream`和`OutputStream`都是通过`close()`方法来关闭流。关闭流就会释放对应的底层资源。  

还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成`IOException`异常并抛出。因此，所有与IO操作相关的代码都必须正确处理`IOException`。  

因此，需要用`try ... finally`来保证`InputStream`在无论是否发生IO错误的时候都能够正确地关闭：  

```java
FileInputStream fis = null;
int n;
try {
    fis = new FileInputStream("./log/output.log");// 读取文件
    byte[] a = new byte[256];
    while ((n = fis.read(a)) != -1)
        System.out.write(a, 0, n);// 显示
  
} catch (FileNotFoundException e) {
    System.out.println("没有文件");
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fis != null) {
        fis.close();
    }
}
```
用`try ... finally`来编写上述代码会感觉比较复杂，更好的写法是利用**Java 7**引入的新的`try(resource)`的语法，只需要编写`try`语句，让编译器自动为我们关闭资源。  
```java
int n;
try (FileInputStream fis = new FileInputStream("./log/output.log")) {
    // 读取文件
    byte[] a = new byte[256];
    while ((n = fis.read(a)) != -1)
        System.out.write(a, 0, n);// 显示
} catch (FileNotFoundException e) {
    System.out.println("没有文件");
} catch (IOException e) {
    e.printStackTrace();
}
```
实际上，编译器并不会特别地为`InputStream`加上自动关闭。编译器只看`try(resource = ...)`中的对象是否实现了`java.lang.AutoCloseable`接口，如果实现了，就自动加上`finally`语句并调用`close()`方法。`InputStream`和`OutputStream`都实现了这个接口，因此，都可以用在`try(resource)`中。  

在调用`InputStream`的`read()`方法读取数据时，我们说`read()`方法是阻塞（Blocking）的。它的意思是，对于下面的代码：  
```java
int n;
n = input.read(); // 必须等待read()方法返回才能执行下一行代码
int m = n;
```
执行到第二行代码时，必须等`read()`方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定`read()`方法调用到底要花费多长时间。  
#### ByteArrayInputStream
`ByteArrayInputStream`可以在内存中**模拟**一个`InputStream`：  
```java
byte[] data={65,66,67,68};
try (InputStream input = new ByteArrayInputStream(data)) {
    int n;
    while ((n = input.read()) != -1) {
        System.out.println((char)n);
    }
}
```
`ByteArrayInputStream`实际上是把一个`byte[]`数组在内存中变成一个`InputStream`，虽然实际应用不多，但**测试**的时候，可以用它来构造一个`InputStream`。  
### OutputStream
**OutputStream常用方法**  

Writer常用方法(写入方法)  

| 方法                                                   | 说明                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| **void write(int b)**                                  | 将参数`b`的低8位组成字节写入到流中。                         |
| **void write(byte\[\] buffer)**                        | 将字符数组`buffer`中的字节写入到流中。                       |
| **void write(byte\[\] buffer,int offset, int length)** | 将字节数组`buffer`中从`offset`开始的`length`字节写入到流中。 |
| void close()                                           | 关闭流                                                       |
| void flush()                                           | 刷空输岀流,并输岀所有被缓存的字节。                          |

**OutputStream相关类**  

**低级 `OutputStream`类：**  

- `OutputStream`：抽象类，所有输出流的基类。
- `FileOutputStream`：向文件写入数据的输出流。
- `ByteArrayOutputStream`：将数据写入字节数组的输出流。
- `PipedOutputStream`：与`PipedInputStream`配合使用，用于线程间通信。

**高级 `OutputStream`类：**  
- `DataOutputStream`：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。
- `BufferedOutputStream`：带有缓冲区的输出流，提高了写入文件的性能。

**其他常见 `OutputStream`类：**  
- `ObjectOutputStream`：将对象写入流中的输出流。
- `FilterOutputStream`：添加功能的抽象输出流。
- `PrintStream`：用于写入各种数据值表示形式的输出流。

`void write(int b)`会写入一个字节到输出流。要注意的是，虽然传入的是`int`参数，但只会写入一个字节，即只写入`int`最低8位表示字节的部分（相当于`b & 0xff`）。  

`OutputStream`也提供了`close()`方法关闭输出流，以便释放系统资源。`OutputStream`还提供了一个`flush()`方法，它的目的是将缓冲区的内容**真正**输出到目的地。  

为什么要有`flush()`？因为向磁盘、网络写入数据的时候，出于效率的考虑，**操作系统**并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个`byte[]`数组），等到缓冲区写满了，再**一次性写入**文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以`OutputStream`有个`flush()`方法，能**强制**把缓冲区内容输出。  

通常情况下，我们**不需要调用**这个`flush()`方法，因为缓冲区写满了`OutputStream`会自动调用它，并且，在调用`close()`方法关闭`OutputStream`之前，也会自动调用`flush()`方法。  

但是，在某些情况下，我们必须手动调用`flush()`方法。举个栗子：  

小明正在开发一款在线聊天软件，当用户输入一句话后，就通过`OutputStream`的`write()`方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息。  

原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。  

解决办法就是每输入一句话后，立刻调用`flush()`，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。  

实际上，`InputStream`也有缓冲区。例如，从`FileInputStream`读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用`int read()`读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用`read()`，则会触发操作系统的下一次读取并再次填满缓冲区。  

#### FileOutputStream
```java
OutputStream output = new FileOutputStream("out/readme.txt");
output.write(72); // H
output.write("Hello".getBytes(StandardCharsets.UTF_8)); // Hello
output.close();
```
和`InputStream`一样，`OutputStream`的`write()`方法也是阻塞的。  
#### ByteArrayOutputStream
`ByteArrayOutputStream`可以在内存中模拟一个`OutputStream`。  
```java
byte[] data;
try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {
    output.write("Hello ".getBytes(StandardCharsets.UTF_8));
    output.write("world!".getBytes(StandardCharsets.UTF_8));
    data = output.toByteArray();
}
System.out.println(new String(data, StandardCharsets.UTF_8));
```
`ByteArrayOutputStream`实际上是把一个`byte[]`数组在内存中变成一个`OutputStream`，虽然实际应用不多，但**测试**的时候，可以用它来构造一个`OutputStream`。  
#### PrintStream
`PrintStream`是一种`FilterOutputStream`，它在`OutputStream`的接口上，额外提供了一些写入各种数据类型的方法：  
- 写入`int`：`print(int)`
- 写入`boolean`：`print(boolean)`
- 写入`String`：`print(String)`
- 写入`Object`：`print(Object)`，实际上相当于`print(object.toString())`
- ...

以及对应的一组`println()`方法，它会自动加上换行符。  

我们经常使用的`System.out.println()`实际上就是使用`PrintStream`打印各种数据。其中，`System.out`是系统默认提供的`PrintStream`，表示标准输出，而`System.err`是系统默认提供的标准错误输出：  

```java
System.out.print(12345); // 输出12345
System.out.print(new Object()); // 输出类似java.lang.Object@3c7a835a
System.out.println("Hello"); // 输出Hello并换行
```
`PrintStream`和`OutputStream`相比，除了添加了一组`print()`/`println()`方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出`IOException`，这样我们在编写代码的时候，就不必捕获`IOException`。实例：  

```java
FileOutputStream fos = null;
PrintStream out = null;
try {
    fos = new FileOutputStream("file1.txt", true);//建立一个文件输出流,true追加
    out = new PrintStream(fos);//建立一个PrintStream对象,它将作为标准输出流
    out.println("这是一个测试串FileOutputStream");
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    if (out != null) {
        out.close();
    }
    try {
        if (fos != null) {
            fos.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
修改简化后：  
```java
//建立一个文件输出流,true追加,建立一个PrintStream对象,它将作为标准输出流
try(FileOutputStream fos =new FileOutputStream("file1.txt", true);
    PrintStream out = new PrintStream(fos)) {
    out.println("这是一个测试串FileOutputStream");
} catch (FileNotFoundException e) {
    e.printStackTrace();
}
```
同时操作多个`AutoCloseable`资源时，还可以在`try(resource) { ... }`语句中可以同时写出多个资源，**用`;`隔开**。例如，同时读写两个文件：  
```java
// 读取input.txt，写入output.txt:
try (InputStream input = new FileInputStream("input.txt");
     OutputStream output = new FileOutputStream("output.txt")){
    input.transferTo(output);
}
```
`transferTo`方法是`InputStream`的一个扩展方法，用于将输入流的数据直接传输到指定的输出流中，从而避免了显式的循环读取和写入操作。在这个例子中，`transferTo`方法将`input.txt`文件的内容直接传输到`output.txt`文件中，效率比逐字节或逐块地读取和写入要高。这种方式可以提高文件传输的效率，特别是当处理大文件时。  
## 字符流
字待流有两个基本类：`Reader`和`Writer`  

1,`Reader`/`Writer`处理的是**字符类型**的数据。它处理流的方式是以**字符**为单位进行的。  

2,`Reader`/`Writer`和`InputStream`/`OutputStream`一样,也分为**节点流**(低级流)和**处理流**(高级流)。  

`Reader`类是所有输入字符流的父类,`Writer`类是所有输出字符流的父类。设计`Reader`和`Writer`继承层次结构主要是为了国际化。而旧的I/O流继承层次结构仅支持8位字节流,并且**不能很好的处理**16位的Unicode字符。由于Unicode用于字符国际化,所以添加字符流的继承层次结构就是在所有的I/O操作中都支持Unicode。  

`Writer`和`Reader`类都是抽象类,不能建立它们的对象,所以只能通过它们子类对象对文件进行操作。  

### Reader
`Reader`和`InputStream`的区别如下：  

| InputStream                             | Reader                                    |
| :-------------------------------------- | :---------------------------------------- |
| **字节**流，以`byte`为单位              | **字符**流，以`char`为单位                |
| 读取**字节**（-1，0~255）：`int read()` | 读取**字符**（-1，0~65535）：`int read()` |
| 读到**字节数组**：`int read(byte[] b)`  | 读到**字符数组**：`int read(char[] c)`    |

**Reader常用方法**  

| 方法                                                | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| **int read()**                                      | 读取一个字符,并将它返回，如果已读到末尾，返回`-1`。          |
| **int read(char\[\] buffer)**                       | 将从流中读取的字符放到字符数组`buffer`中,返回读出的字符数，如果已读到末尾，返回`-1`。 |
| **int read(char\[\] buffer,int offset,int length)** | 将读取的字符存入字符数组 `buffer` 中的指定位置，从 `offset` 开始，最多读取 `length` 个字符。 |
| void mark(int n)                                    | 标记流中的当前位置，后续调用 `reset()` 方法可以回到该位置。  |
| boolean MarkSupported()                             | 判断流是否支持标记操作。                                     |
| boolean ready()                                     | 判断流是否已经准备好进行读取操作。                           |

**Reader相关类**  

**低级 `Reader`类：**  

- `CharArrayReader`：从字符数组读取数据的`Reader`。
- `PipedReader`：与`PipedWriter`配合使用，用于线程间通信的`Reader`。
- `StringReader`：从字符串读取数据的`Reader`。
- `FileReader`：从文件读取数据的`Reader`。

**高级 `Reader`类：**  
- `BufferedReader`：带有缓冲区的`Reader`，提高了从输入流读取数据的性能。
- `InputStreamReader`：将字节流转换为字符流的`Reader`。
- `LineNumberReader`：继承自`BufferedReader`，可以记录行号的`Reader`。

#### FileReader
`FileReader`是`Reader`的一个子类，它可以打开文件并获取`Reader`。  

下面的代码演示了如何完整地读取一个`FileReader`的所有字符：  

```java
// 创建一个FileReader对象,字符编码是???
try(Reader reader = new FileReader("src/readme.txt")) {
    int n;
    // 反复调用read()方法，直到返回-1
    while ((n = reader.read())!=-1) {
        System.out.println((char)n); // 打印char
    }
} catch (IOException e) {
    throw new RuntimeException(e);
}
```
如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为`FileReader`默认的编码与系统相关，例如，Windows系统的默认编码可能是`GBK`，打开一个`UTF-8`编码的文本文件就会出现乱码。  

要避免乱码问题，我们需要在创建`FileReader`时指定编码：  

```java
Reader reader = new FileReader("src/readme.txt", StandardCharsets.UTF_8);
```
带 Charset 参数的`FileReader`的构造方法在 **Java 11** 中加入。**Java 8** 中可以使用 `InputStreamReader` 包装 `FileInputStream` 自行构建。  
#### CharArrayReader
`CharArrayReader`可以在内存中模拟一个`Reader`，它的作用实际上是把一个**`char[]`数组**变成一个`Reader`，这和`ByteArrayInputStream`非常类似：  
```java
try (Reader reader = new CharArrayReader("Hello".toCharArray())) {}
```
#### StringReader
`StringReader`可以**直接把`String`作为数据源**，它和`CharArrayReader`几乎一样：  
```java
try (Reader reader = new StringReader("Hello")) {}
```
#### InputStreamReader
`Reader`和`InputStream`有什么关系？  

除了特殊的`CharArrayReader`和`StringReader`，普通的`Reader`实际上是**基于`InputStream`构造**的，`Reader`从`InputStream`中读入字节流（`byte`），然后，根据编码设置，再转换为`char`就可以实现字符流。如果我们查看`FileReader`的源码，它在内部实际上持有一个`FileInputStream`。  

既然`Reader`本质上是一个基于`InputStream`的`byte`到`char`的转换器，那么，如果我们已经有一个`InputStream`，想把它转换为`Reader`，是完全可行的。`InputStreamReader`就是这样一个转换器，它可以把**任何**`InputStream`转换为`Reader`。示例代码如下：  

```java
// 持有InputStream:
InputStream input = new FileInputStream("src/readme.txt");
// 变换为Reader:
Reader reader = new InputStreamReader(input, "UTF-8");
```
构造`InputStreamReader`时，我们需要传入`InputStream`，还需要指定编码，就可以得到一个`Reader`对象。上述代码实际上就是`FileReader`的一种实现方式。  
### Writer
`Writer`和`OutputStream`的区别如下：  

| OutputStream                                   | Writer                                           |
| :--------------------------------------------- | :----------------------------------------------- |
| **字节**流，以`byte`为单位                     | **字符**流，以`char`为单位                       |
| 写入**字节**（**0~255**）：`void write(int b)` | 写入**字符**（**0~65535**）：`void write(int c)` |
| 写入**字节**数组：`void write(byte[] b)`       | 写入**字符**数组：`void write(char[] c)`         |
| 无对应方法                                     | 写入String：`void write(String s)`               |

**Writer常用方法**  

| 方法                                                 | 说明                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| **void write(int c)**                                | 将参数`c`的低16位组成的字符写入到流中。这个方法通常用于写入单个字符的数据。 |
| **void write(char\[\]buffer)**                       | 将字符数组`buffer`中的所有字符写入到流中。                   |
| **void write(char\[\]buffer,int offset,int length)** | 将字符数组`buffer`中从`offset`位置开始的`length`个字符写入到流中。 |
| void write(String string)                            | 将字符串`string`写入到流中。                                 |
| void write(String string,int offset,int length)      | 将字符串`string`中从`offset`位置开始的`length`个字符写入到流中。 |
| Writer append(char c)                                | 将指定字符添加到此`writer`                                   |
| void close()                                         | 关闭流                                                       |
| void flush()                                         | 刷新输出流，并将缓冲区中的数据输出。                         |

**Writer相关类**  

**低级 `Writer`类：**  

- `FileWriter`：将字符写入到文件的`Writer`。
- `CharArrayWriter`：将字符写入到字符数组的`Writer`。
- `StringWriter`：将字符写入到字符串的`Writer`。
- `PipedWriter`：与`PipedReader`配合使用，用于线程间通信的`Writer`。

**高级 `Writer`类：**  
- `BufferedWriter`：带有缓冲区的`Writer`，提高了向输出流写入数据的性能。
- `OutputStreamWriter`：将字符流转换为字节流的`Writer`。
- `PrintWriter`：带有打印功能的`Writer`，可以方便地向输出流写入各种数据类型的值。

#### FileWriter
使用`FileWriter`进行文件操作时,为了减少磁盘读写次数,**常使用具有缓冲功能的`BufferedWriter`类。**  

`FileWriter`就是向文件中写入字符流的`Writer`。它的使用方法和`FileReader`类似：  

```java
try (Writer writer = new FileWriter("readme.txt", StandardCharsets.UTF_8)) {
    writer.write('H'); // 写入单个字符
    writer.write("Hello".toCharArray()); // 写入char[]
    writer.write("Hello"); // 写入String
}
```
#### CharArrayWriter
`CharArrayWriter`可以在内存中创建一个`Writer`，它的作用实际上是构造一个缓冲区，可以写入`char`，最后得到写入的`char[]`数组，这和`ByteArrayOutputStream`非常类似：  
```java
try (CharArrayWriter writer = new CharArrayWriter()) {
    writer.write(65);
    writer.write(66);
    writer.write(67);
    char[] data = writer.toCharArray(); // { 'A', 'B', 'C' }
}
```
#### StringWriter
`StringWriter`也是一个基于内存的`Writer`，它和`CharArrayWriter`类似。实际上，`StringWriter`在内部维护了一个`StringBuffer`，并对外提供了`Writer`接口。  
```java
try (StringWriter writer = new StringWriter()) {
    writer.write(65);
    writer.write(66);
    writer.write(67);
    String data = writer.toString(); // ABC
    System.out.println(data);
}
```
#### OutputStreamWriter
除了`CharArrayWriter`和`StringWriter`外，普通的Writer实际上是**基于`OutputStream`构造**的，它接收`char`，然后在内部自动转换成一个或多个`byte`，并写入`OutputStream`。因此，`OutputStreamWriter`就是一个将任意的`OutputStream`转换为`Writer`的转换器：  
```java
try (Writer writer = new OutputStreamWriter(new FileOutputStream("readme.txt"), "UTF-8")) {}
```
上述代码实际上就是`FileWriter`的一种实现方式。这和上一节的`InputStreamReader`是一样的。  
#### PrintWriter
`PrintStream`最终输出的总是`byte`数据，而`PrintWriter`则是**扩展**了`Writer`接口，它的`print()`/`println()`方法最终输出的是`char`数据。两者的使用方法几乎是一模一样的：  
```java
StringWriter buffer = new StringWriter();
try (PrintWriter pw = new PrintWriter(buffer)) {
    pw.println("Hello");
    pw.println(12345);
    pw.println(true);
}
System.out.println(buffer);
```
## Filter模式
Java的IO标准库提供的`InputStream`根据来源可以包括：  
- `FileInputStream`：从文件读取数据，是最终数据源；
- `ServletInputStream`：从HTTP请求读取数据，是最终数据源；
- `Socket.getInputStream()`：从TCP连接读取数据，是最终数据源；
- ...

如果我们要给`FileInputStream`添加缓冲功能，则可以从`FileInputStream`派生一个类：  
```java
BufferedFileInputStream extends FileInputStream
```
如果要给`FileInputStream`添加计算签名的功能，类似的，也可以从`FileInputStream`派生一个类：  
```java
DigestFileInputStream extends FileInputStream
```
如果要给`FileInputStream`添加加密/解密功能，还是可以从`FileInputStream`派生一个类：  
```java
CipherFileInputStream extends FileInputStream
```
如果要给`FileInputStream`添加缓冲和签名的功能，那么我们还需要派生`BufferedDigestFileInputStream`。如果要给`FileInputStream`添加缓冲和加解密的功能，则需要派生`BufferedCipherFileInputStream`。  

我们发现，给`FileInputStream`添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：  

```ascii
                          ┌─────────────────┐
                          │ FileInputStream │
                          └─────────────────┘
                                   ▲
             ┌───────────┬─────────┼─────────┬───────────┐
             │           │         │         │           │
┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐
│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│
└───────────────────────┘│└─────────────────┘│└─────────────────────┘
                         │                   │
    ┌─────────────────────────────┐ ┌─────────────────────────────┐
    │BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│
    └─────────────────────────────┘ └─────────────────────────────┘
```
这还只是针对`FileInputStream`设计，如果针对另一种`InputStream`设计，很快会出现子类爆炸的情况。  

因此，直接使用继承，为各种`InputStream`附加更多的功能，根本无法控制代码的复杂度，很快就会失控。  

为了解决依赖继承会导致子类数量失控的问题，JDK首先将`InputStream`分为两大类：  

一类是直接提供数据的基础`InputStream`，例如：  

- FileInputStream
- ByteArrayInputStream
- ServletInputStream
- ...

一类是提供额外附加功能的`InputStream`，例如：  
- BufferedInputStream
- DigestInputStream
- CipherInputStream
- ...

当我们需要给一个“基础”`InputStream`附加各种功能时，我们先确定这个能提供数据源的`InputStream`，因为我们需要的数据总得来自某个地方，例如，`FileInputStream`，数据来源自文件：  
```java
InputStream file = new FileInputStream("test.gz");
```
紧接着，我们希望`FileInputStream`能提供缓冲的功能来提高读取的效率，因此我们用`BufferedInputStream`包装这个`InputStream`，得到的包装类型是`BufferedInputStream`，但它仍然被视为一个`InputStream`：  
```java
InputStream buffered = new BufferedInputStream(file);
```
最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个`GZIPInputStream`：  
```java
InputStream gzip = new GZIPInputStream(buffered);
```
无论我们包装多少次，得到的对象始终是`InputStream`，我们直接用`InputStream`来引用它，就可以正常读取：  
```ascii
┌─────────────────────────┐
│GZIPInputStream          │
│┌───────────────────────┐│
││BufferedFileInputStream││
││┌─────────────────────┐││
│││   FileInputStream   │││
││└─────────────────────┘││
│└───────────────────────┘│
└─────────────────────────┘
```
上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator），Filter模式可以在运行期动态增加功能。它可以让我们通过少量的类来实现各种功能的组合：  
```ascii
                 ┌─────────────┐
                 │ InputStream │
                 └─────────────┘
                       ▲ ▲
┌────────────────────┐ │ │ ┌─────────────────┐
│  FileInputStream   │─┤ └─│FilterInputStream│
└────────────────────┘ │   └─────────────────┘
┌────────────────────┐ │     ▲ ┌───────────────────┐
│ByteArrayInputStream│─┤     ├─│BufferedInputStream│
└────────────────────┘ │     │ └───────────────────┘
┌────────────────────┐ │     │ ┌───────────────────┐
│ ServletInputStream │─┘     ├─│  DataInputStream  │
└────────────────────┘       │ └───────────────────┘
                             │ ┌───────────────────┐
                             └─│CheckedInputStream │
                               └───────────────────┘
```
类似的，`OutputStream`也是以这种模式来提供各种功能：  
```ascii
                  ┌─────────────┐
                  │OutputStream │
                  └─────────────┘
                        ▲ ▲
┌─────────────────────┐ │ │ ┌──────────────────┐
│  FileOutputStream   │─┤ └─│FilterOutputStream│
└─────────────────────┘ │   └──────────────────┘
┌─────────────────────┐ │     ▲ ┌────────────────────┐
│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│
└─────────────────────┘ │     │ └────────────────────┘
┌─────────────────────┐ │     │ ┌────────────────────┐
│ ServletOutputStream │─┘     ├─│  DataOutputStream  │
└─────────────────────┘       │ └────────────────────┘
                              │ ┌────────────────────┐
                              └─│CheckedOutputStream │
                                └────────────────────┘
```
**编写FilterInputStream**  

也可以自己编写`FilterInputStream`，以便可以把自己的`FilterInputStream`“叠加”到任何一个`InputStream`中。  

下面的例子演示了如何编写一个`CountInputStream`，它的作用是对输入的字节进行计数：  

```java
package com.aotmd;
import java.io.*;
import java.nio.charset.StandardCharsets;
public class Main {
    public static void main(String[] args) throws IOException {
        byte[] data = "hello, world!".getBytes(StandardCharsets.UTF_8);
        try (CountInputStream input = new CountInputStream(new ByteArrayInputStream(data))) {
            int n;
            while ((n = input.read()) != -1) {
                System.out.print((char)n);
            }
            System.out.println("\nTotal read " + input.getBytesRead() + " bytes");
        }
    }
}
class CountInputStream extends FilterInputStream {
    private int count = 0;
    CountInputStream(InputStream in) {
        super(in);
    }
    public int getBytesRead() {
        return this.count;
    }
    public int read() throws IOException {
        int n = in.read();
        if (n != -1) {
            this.count ++;
        }
        return n;
    }
    public int read(byte[] b, int off, int len) throws IOException {
        int n = in.read(b, off, len);
        if (n != -1) {
            this.count += n;
        }
        return n;
    }
}
```
注意到在叠加多个`FilterInputStream`，我们只需要持有最外层的`InputStream`，并且，当最外层的`InputStream`关闭时（在`try(resource)`块的结束处自动关闭），内层的`InputStream`的`close()`方法也会被自动调用，并最终调用到最核心的“基础”`InputStream`，因此不存在资源泄露。  
## 序列化
序列化是指把一个Java对象变成二进制内容，本质上就是一个`byte[]`数组。  

序列化后可以把`byte[]`保存到文件中，或者把`byte[]`通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。  

有序列化，就有反序列化，即把一个二进制内容（也就是`byte[]`数组）变回Java对象。有了反序列化，保存到文件中的`byte[]`数组又可以“变回”Java对象，或者从网络上读取`byte[]`并把它“变回”Java对象。  

一个Java对象要能序列化，必须实现一个特殊的`java.io.Serializable`接口，它的定义如下：  

```java
public interface Serializable {}
```
`Serializable`接口**没有定义任何方法**，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身**贴了个“标记”**，并没有增加任何方法。  

------

**序列化**  

把一个Java对象变为`byte[]`数组，需要使用`ObjectOutputStream`。它负责把一个Java对象写入一个字节流：  

```java
ByteArrayOutputStream buffer = new ByteArrayOutputStream();
try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {
    output.writeInt(12345);// 写入int
    output.writeUTF("Hello");// 写入String
    output.writeObject(Double.valueOf(123.456));// 写入Object
}
System.out.println(Arrays.toString(buffer.toByteArray()));
```
`ObjectOutputStream`既可以写入基本类型，如`int`，`boolean`，也可以写入`String`（以UTF-8编码），**还可以写入实现了`Serializable`接口的`Object`**。  

因为写入`Object`时需要大量的类型信息，所以写入的内容很大。  

------

**反序列化**  

和`ObjectOutputStream`相反，`ObjectInputStream`负责从一个字节流读取Java对象：  

```java
try (ObjectInputStream input = new ObjectInputStream(...)) {
    int n = input.readInt();
    String s = input.readUTF();
    Double d = (Double) input.readObject();
}
```
除了能读取基本类型和`String`类型外，调用`readObject()`可以**直接返回一个`Object`对象**。要把它变成一个特定类型**，必须强制转型**。  

`readObject()`可能抛出的异常有：  

- `ClassNotFoundException`：没有找到对应的Class；
- `InvalidClassException`：Class不匹配。

对于`ClassNotFoundException`，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，`Person`对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序**并没有定义**`Person`类，所以**无法反序列化**。  

对于`InvalidClassException`，这种情况常见于序列化的`Person`对象定义了一个`int`类型的`age`字段，但是反序列化时，`Person`类定义的`age`字段被改成了`long`类型，所以导致**class不兼容**。  

为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的`serialVersionUID`静态变量，用于标识Java类的**序列化“版本”**，通常可以由IDE自动生成。如果增加或修改了字段，可以改变`serialVersionUID`的值，这样就能**自动阻止不匹配的class版本**：  

```java
public class Person implements Serializable {
    private static final long serialVersionUID = 2709425275741743919L;
}
```
要特别注意反序列化的几个**重要特点**：  
1.  实现了`Serializable`接口的类，在反序列化时**构造方法不会被调用**。这是因为反序列化是通过**读取**对象的**序列化数据**来**重新构建对象**，而不是通过**调用**构造方法来**创建对象**的。
2.  如果一个类**没有实现**`Serializable`接口，但它是某个实现了`Serializable`接口的**父类**，那么在反序列化子类时，JVM会自动调用**父类的无参构造方法**，并且父类无参构造方法里的代码**也会被执行**。这是因为反序列化**需要**对整个继承层次进行处理，以便**正确**地重建对象的状态。

这些规则在Java的序列化和反序列化机制中起着**重要作用**，确保对象在序列化和反序列化过程中能够正确地恢复其状态。  

因为Java的序列化机制可以导致一个实例能直接从`byte[]`数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的`byte[]`数组被反序列化后可以执行特定的Java代码，从而导致**严重的安全漏洞**。  

实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的**通用数据结构**来实现，只输出**基本类型**（包括String）的内容，而不存储任何与代码相关的信息。  

## 读取classpath资源
很多Java程序启动的时候，都需要读取配置文件。例如，从一个`.properties`文件中读取配置：  
```java
String conf = "C:\\conf\\default.properties";
try (InputStream input = new FileInputStream(conf)) {}
```
这段代码要正常执行，必须在C盘创建`conf`目录，然后在目录里创建`default.properties`文件。但是，在Linux系统上，路径和Windows的又不一样。  

因此，从磁盘的固定目录读取配置文件，不是一个好的办法。  

有没有**路径无关**的读取文件的方式呢？  

我们知道，Java存放`.class`的目录或jar包**也可以包含任意其他类型的文件**，例如：  

- 配置文件，例如`.properties`；
- 图片文件，例如`.jpg`；
- 文本文件，例如`.txt`，`.csv`；
- ……

从classpath读取文件就**可以**避免不同环境下文件路径不一致的问题：如果我们把`default.properties`文件放到classpath中，就不用关心它的实际存放路径。  

在classpath中的资源文件，路径总是以`/`开头，我们先获取当前的`Class`对象，然后调用`getResourceAsStream()`就可以直接从classpath读取任意的资源文件：  

```java
try (InputStream input = getClass().getResourceAsStream("/default.properties")) {}
```
调用`getResourceAsStream()`需要特别注意的一点是，如果资源文件不存在，它将返回`null`。因此，我们需要检查返回的`InputStream`是否为`null`。  

如果我们把默认的配置放到**jar包中**，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：  

```java
Properties props = new Properties();
props.load(inputStreamFromClassPath("/default.properties"));
props.load(inputStreamFromFile("./conf.properties"));
```
这样读取配置文件，应用程序启动就更加灵活。  
## ZipInputStream
`ZipInputStream`是一种`FilterInputStream`，它可以**直接读取zip包**的内容：  
```ascii
┌───────────────────┐
│    InputStream    │
└───────────────────┘
          ▲
          │
┌───────────────────┐
│ FilterInputStream │
└───────────────────┘
          ▲
          │
┌───────────────────┐
│InflaterInputStream│
└───────────────────┘
          ▲
          │
┌───────────────────┐
│  ZipInputStream   │
└───────────────────┘
          ▲
          │
┌───────────────────┐
│  JarInputStream   │
└───────────────────┘
```
另一个`JarInputStream`是从`ZipInputStream`派生，它继承了`ZipInputStream`的功能，并增加了直接读取JAR文件中`MANIFEST.MF`文件的能力。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。  

------

**读取zip包**  

要创建一个`ZipInputStream`，通常是传入一个`FileInputStream`作为数据源，然后，循环调用`getNextEntry()`，直到返回`null`，表示zip流结束。  

一个`ZipEntry`表示一个**压缩的文件或目录**，如果是压缩的文件，我们就用`read()`方法不断读取，直到返回`-1`：  

```java
try (ZipInputStream zip = new ZipInputStream(new FileInputStream(...))) {
    ZipEntry entry = null;
    while ((entry = zip.getNextEntry()) != null) {
        String name = entry.getName();
        if (!entry.isDirectory()) {
            int n;
            while ((n = zip.read()) != -1) {
                ...
            }
        }
    }
}
```

------

**写入zip包**  

`ZipOutputStream`是一种`FilterOutputStream`，它可以直接写入内容到zip包。  

要先创建一个`ZipOutputStream`，通常是包装一个`FileOutputStream`，然后，每写入一个文件前，先调用`putNextEntry()`，然后用`write()`写入`byte[]`数据，写入完毕后调用`closeEntry()`结束这个文件的打包。  

```java
try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(...))) {
    File[] files = ...
    for (File file : files) {
        zip.putNextEntry(new ZipEntry(file.getName()));
        zip.write(Files.readAllBytes(file.toPath()));
        zip.closeEntry();
    }
}
```
上面的代码**没有考虑文件的目录结构**。如果要**实现**目录层次结构，`new ZipEntry(name)`传入的`name`要用相对路径。  
## 重定向标准输入输出
Java系统**预先**定义了3个流对象：  
1. 标准输出设备`System.out`  
2. 标准输入设备`System.in`  
3. 标准错误设备`System.err`  

在**默认**情况下,**标准输入设备是键盘,而标准输出设备是控制台**,而通过`System.setIn`方法和`System.setout`方法可以改变它们的默认输入/输出设备。  

实例：  

```java
//建立一个文件输出流,并将它的append标记设置为true,建立一个PrintStream对象,它将作为标准输出流
PrintStream ps =new PrintStream(new FileOutputStream("Demo.txt", true));
//将标准输出定向到PrintStream对象
System.setOut(ps);
//输出以条数据,它不再会在控制台输出,而是输出到了文件Demo.txt中
System.out.println("该字符串会输出到文件中");
```
也可以hook后都输出  
```java
/**
 * @author aotmd
 * @version 1.0
 * @date 2021/2/27 20:29
 */
public class 重写控制台也输出日志 {
    private static final PrintStream originalOut = System.out;
    private static OutputStreamWriter fos;
    /**
     * 也输出日志,重写println(string)
     * @param file 日志文件路径
     * @param addTo 追加模式
     * @param addTime 文件名称是否追加时间
     */
    public static void consoleToLog(String file,boolean addTo,boolean addTime){
        //设置日期格式
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String time = addTime ? " " + df.format(new Date()) : "";
        file = file.substring(0, file.lastIndexOf("."));
        try {
            fos=new OutputStreamWriter(new FileOutputStream(file+time+".txt",addTo), StandardCharsets.UTF_8);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return;
        }
        System.setOut(new PrintStream(originalOut) {
            @Override
            public void println(String s) {
                outputLog(s+"\n");
                super.println(s);
            }

        });
    }

    private static void outputLog(String x) {
        try {
            fos.write(x);
            fos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void restoreConsole() {
        System.setOut(originalOut);
        try {
            if (fos != null) {
                fos.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
## DataOutputStream
数据输入输出出流允许应用程序以与**机器无关**方式将Java基本数据类型写到底层输出流。  

数据输出流：`DataOutputStream`  

数据输入流：`DataInputStream`  

**要想使用数据输出流和输入流,要按照一定格式输出数据,再按照相同的格式输入数据。**  

`DataOutputStreams`是`OutputStream`的子类。继承自`FillterOutputStream`类,同时实现`DataOutput`接口。在`DataOutput`接口定义了一系列写入各种数据的方法。  

### DataOutputStream  
```java
public class DataOutputStream extends FilterOutputStream implements DataOutput{} 
```
**字段**  

`protected int written`：到目前为止写入数据输出流的字节数。  

**构造方法**  

`DataOutputStream(OutputStream out)`  ：创建一个新的数据输出流,将数据写入指定基础输出流。  

**写方法**  

**(1)基本数据类型写入方法：**  

八种基本类型：六种数字类型(四个整数型,两个浮点型),一种字符类型,还有一种布尔型。  

| 方法                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| void writeByte(int v)        | 将一个`byte`值以1-byte值形式写出到基础输出流中。             |
| void writeShort(int v)       | 将一个**short**值以2-byte值形式写入基础输出流中,先写入高字节。 |
| void writeInt(int v)         | 将一个`int`值以4-byte值形式写入基础输出流中,先写入高字节。   |
| void writeLong(long v)       | 将一个`long`值以8-byte值形式写入基础输出流中,先写入高字节。  |
| void writeFloat(float v)     | 使用`Float`类中的floatToIntBits方法将float参数转换为一个int值,然后将该int值以4-byte值形式写入基础输出流中,先写入高字节。 |
| void writeDouble(double v)   | 使用`Double`类中的doubleToLongBits方法将double参数转换为一个long值,然后将该long值以8-byte值形式写入基础输出流中,先写入高字节。 |
| void writeChar(int v)        | 将一个`char`值以2-byte值形式写入基础输出流中,先写入高字节。  |
| void writeBoolean(boolean v) | 将一个`boolean`值以1-byte值形式写入基础输出流。              |

**(2)字节数组的写入方法**  

`void write(byte[] b, int off, int len)` 将指定`b`数组中从偏移量 `off` 开始的 `len` 个字节写入基础输出  

**(3)只写入`int`的低八位**  

`void write(int b)` 将指定字节(参数`b`的八个低位)写入基础输出流。  

**(4)写入字符串的方法**  

`void writeBytes(String s)` 将字符串按字节顺序写出到基础输出流中。  

`void writeChars(String s)` 采用`UTF-16be`方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。  

`void writeUTF(String str)` 以与机器无关方式使用`UTF-8`修改版编码将一个字符串写入基础  

**其他方法**  

`void flush()` 清空此数据输出流。写入文件  

`int size()` 返回计数器 `written` 的当前值,即到目前为止写入此数据输出流的字节数。  

------

### DataInputStream  
**构造方法**  

`DataInputStream(InputStream in)`：使用指定的底层 `InputStream` 创建一个 `DataInputStream`。  

**读方法**  

**1.基本类型读取方法：**  

| 方法                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| byte readByte()       | 读取并返回一个输入字节。该字节被看作是 -128 到 127(包含)范围内的一个有符号值。 |
| int readInt()         | 读取四个输入字节并返回一个 `int` 值。                        |
| short readShort()     | 读取两个字节并返回一个`short`值。                            |
| long readLong()       | 读取八个输入字节并返回一个 `long` 值。                       |
| float readFloat()     | 读取四个输入字节并返回一个 `float` 值。                      |
| double readDouble()   | 读取八个输入字节并返回一个 `double` 值。实现这一点的方法是：   先使用与 `readlong` 方法完全相同的方式构造一个 `long` 值, 然后使用与 `Double.longBitsToDouble` 方法完全相同的方式将此 `long` 值转换成一个 `double` 值。 |
| boolean readBoolean() | 读取一个输入字节,如果该字节不是零,则返回 `true`,如果是零,则返回 `false`。 |
| char readChar()       | 读取两个输入字节并返回一个 `char` 值。                       |

**2.字符串读取方法**  

`String readUTF();` 读入一个已使用 UTF-8 修改版格式编码的字符串。  

`static String readUTF(DataInput in)` 从流 in 中读取用 UTF-8 修改版格式编码的 Unicode 字符格式的字符串;然后以 `String` 形式返回此字符串。  

可以看到`DataInputStream`中读取字符串**只有`readUTF()`**方法,**没有**与`DataOutputStream`对应的：  

`void writeBytes(String s)` 将字符串按字节顺序写出到基础输出流中。  

`void writeChars(String s)` 采用`UTF-16be`方式写入,也就是java字符串的编码将字符串按字符顺序写入基础输出流。  

因此使用`DataOutputStream`的这两个方法写入字符串时,`DataInputStream`来读取可能比较**麻烦**。  

**3.无符号整数读取方法**  

`DataInputStream`中并没有写入无符号整数的方法,这两个方法**是不是用不到**？  

`int readUnsignedByte();`读取一个输入字节,将它左侧补零 (zero-extend) 转变为 `int` 类型,并返回结果,所以结果的范围是 0 到 255。如果接口 `DataOutput` 的 `writeByte` 方法的参数是 0 到 255 之间的值,则此方法适用于读取用 `writeByte` 写入的字节。  

`int readUnsignedShort();`读取两个输入字节,并返回 0 到 65535 范围内的一个 `int` 值。如果接口 `DataOutput` 的 `writeShort` 方法的参数是 0 到 65535 范围内的值,则此方法适用于读取用 `writeShort` 写入的字节。  

**4.读取字节数组的方法：**  

| 方法                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| int read(byte\[\] b)                         | 从包含的输入流中读取一定数量的字节,并将它们存储到缓冲区数组 `b` 中。 |
| int read(byte\[\] b, int off, int len)       | 从包含的输入流中将最多 `len` 个字节读入一个 `byte` 数组中。  |
| void readFully(byte\[\] b)                   | 从输入流中读取一些字节,并将它们存储在缓冲区数组 `b` 中。读取的字节数等于 `b` 的长度。 |
| void readFully(byte\[\] b, int off, int len) | 从输入流中读取 `len` 个字节到字节数组`b`,从`b`的`off`下标开始读入。 |

**5.同样是读取字节数组的方法,`read(byte[] b)`和`readFully(byte[] b)`的区别：**  

其实`read(byte[] b)`方法和`readFully(byte []b)`都是利用`InputStream`中`read()`方法,每次读取的也是一个字节,只是读取字节数组的方式不同.  

`read(byte[] b)`方法实质是读取流上的字节直到流上**没有**字节为止,如果当声明的字节数组长度**大于**流上的数据长度时就提前返回  

`readFully(byte[] b)`方法是读取流上**指定长度**的字节数组,也就是说如果声明了长度为`len`的字节数组,`readFully(byte[] b)`方法只有读取`len`长度个字节的时候才返回,否则**阻塞等待**,如果超时,则会抛出异常 `EOFException`。  

那么当发送了长度为`len`的字节,那么为什么用`read`方法用户收不全呢,揪其原因我们发现消息在网络中传输是没那么理想的,我们发的那部分字节数组在传送过程中可能在接受信息方的缓存当中或者在传输线路,极端情况下可能在发送方的缓存当中,这样就不在流上,所以`read`方法提前返回了,这样就造成了各种错误。  

`readFully()`源码：  

```java
public void readFully(byte[] b, int off, int len, boolean copy) throws IOException { 
    while (len > 0) {  
        int n = read(b, off, len, copy);  
        if (n < 0) {  
            throw new EOFException();  
        }  
        off += n;  
        len -= n;  
    }  
}
```
`readFully`方法并不是说一下就把整个文件读完了,不用去管是否到达文件末尾的异常。`readFully`只是在读取数据的时候,**会一直把缓冲区读满**,否则一直处于阻塞状态而等待读取。  

`read`方法只是将字节流中的数据读完。那么数据在TCP协议传送的过程中,可能输入流接受到的数据并不完全,只是其中的一部分。  

如果这时候的缓冲区没有满的话,`readFully`将会继续等待,直到缓冲区装满。  

某些时候,你可能需要读出特定的长度的字段。比如一些数据的头信息之类的,这时候如果你用`read`去读,那么可能还没有读完就个你返回来了。但是如果去用`readFully`读,那么就会完整的给你读出来。但是在更多的时候,如果不是确定要用特定长度的数据。还是用`read`去读。用`readFully`有点危险。  

**6.跳过n个字节：**  

`int skipBytes(int n)` 试图在输入流中跳过数据的`n`个字节,并丢弃跳过的字节。  

**实例**  

```java
package com.aotmd.test;  
import java.io.*;  
public class NoteTest  
{  
    public static void main(String[] args) throws IOException  
    {  
        FileOutputStream out = new FileOutputStream("testDataOutputStream.txt");  
        DataOutputStream dos = new DataOutputStream(out);  
        byte b = 20;  
        short s = 30;  
        int a = 900;  
        float f = 12.3f;  
        long l = 800l;  
        double d = 14.23;  
        boolean flag = true;  
        char ch = '中';  
        dos.writeByte(b);// 写入byte类型数据  
        dos.writeShort(s);// 写入short类型数据  
        dos.writeInt(a);// 写入int类型  
        dos.writeFloat(f);// 写入float类型  
        dos.writeLong(l);// 写入long类型  
        dos.writeDouble(d);// 写入double类型  
        dos.writeBoolean(flag);  
        dos.writeChar(ch);// 写入char类型  
        dos.close();  
        out.close();  
        FileInputStream in = new FileInputStream("testDataOutputStream.txt");  
        DataInputStream dif = new DataInputStream(in);  
        byte btemp;  
        short stemp;  
        int atemp;  
        float ftemp;  
        long ltemp;  
        double dtemp;  
        boolean flagtemp;  
        char chtemp;  
        btemp = dif.readByte();  
        stemp = dif.readShort();  
        atemp = dif.readInt();  
        ftemp = dif.readFloat();  
        ltemp = dif.readLong();  
        dtemp = dif.readDouble();  
        flagtemp = dif.readBoolean();  
        chtemp = dif.readChar();  
        // stringtemp=dif.read  
        System.out.println(btemp);  
        System.out.println(stemp);  
        System.out.println(atemp);  
        System.out.println(ftemp);  
        System.out.println(ltemp);  
        System.out.println(dtemp);  
        System.out.println(flagtemp);  
        System.out.println(chtemp);  
        dif.close();  
        in.close();  
    }  
}
```
输出:  
```text
20
30
900
12.3
800
14.23
true
中
```
**实例二**  
```java
package com.aotmd.test;  
import java.io.DataOutputStream;  
import java.io.File;  
import java.io.FileOutputStream;  
public class NoteTest {  
    public static void main(String[] args) throws Exception { // 所有异常抛出  
        DataOutputStream dos; // 声明数据输出流对象  
        File f = new File("d:" + File.separator + "order.txt"); // 文件的保存路径  
        dos = new DataOutputStream(new FileOutputStream(f)); // 实例化数据输出流对象  
        String[] names = {"衬衣", "手套", "围巾"}; // 商品名称  
        float[] prices = {98.3f, 30.3f, 50.5f}; // 商品价格  
        int[] nums = {3, 2, 1}; // 商品数量  
        for (int i = 0; i < names.length; i++) { // 循环输出  
            dos.writeChars(names[i]); // 写入字符串,注意,这边是writeChars(),不是writechar。  
            dos.writeChar('\t'); // 写入分隔符,这边是读取writechar()。  
            dos.writeFloat(prices[i]); // 写入价格  
            dos.writeChar('\t'); // 写入分隔符  
            dos.writeInt(nums[i]); // 写入数量  
            dos.writeChar('\n'); // 换行  
        }  
        dos.close(); // 关闭输出流  
    }  
}
```
代码生成的文件  
```text
886c 8863 0009 42c4 999a 0009 0000 0003
000a 624b 5957 0009 41f2 6666 0009 0000
0002 000a 56f4 5dfe 0009 424a 0000 0009
0000 0001 000a
```
使用`DataOutpputStream`写入的数据要使用`DataInputStream`取出进来,  
```java
package com.aotmd.test;  
import java.io.DataInputStream;  
import java.io.File;  
import java.io.FileInputStream;  
public class NoteTest {  
    public static void main(String args[]) throws Exception { // 所有异常抛出  
        DataInputStream dis = null; // 声明数据输入流对象  
        File f = new File("d:" + File.separator + "order.txt"); // 文件的保存路径  
        dis = new DataInputStream(new FileInputStream(f)); // 实例化数据输入流对象  
        String name = null; // 接收名称  
        float price = 0.0f; // 接收价格  
        int num = 0; // 接收数量  
        char temp[] = null; // 接收商品名称  
        int len = 0; // 保存读取数据的个数  
        char c = 0; // '\u0000'  
        try {  
            while (true) {  
                temp = new char[200]; // 开辟空间  
                len = 0;  
                while ((c = dis.readChar()) != '\t') { // 接收内容,因为直到读取到'\t'才完成了读取一个字符串,未读取到表示还有内容。  
                    temp[len] = c;  
                    len++; // 读取长度加1  
                }  
                name = new String(temp, 0, len); // 将字符数组变为String  
                price = dis.readFloat(); // 读取价格  
                dis.readChar(); // 读取\t  
                num = dis.readInt(); // 读取int  
                dis.readChar(); // 读取\n  
                System.out.printf("名称：%s;价格：%5.2f;数量：%d\n", name, price, num);  
            }  
        } catch (Exception e) {  
        }  
        dis.close();  
    }  
}
```
执行结果：  
```text
名称：衬衣;价格：98.30;数量：3
名称：手套;价格：30.30;数量：2
名称：围巾;价格：50.50;数量：1
```
`DataInputStream`读取字符串,只能通过`readchar(),`一个个读取,不像`DataOutpputStream`一样还区分`writechars()`,`writechar()`。  
## RandomAccessFile  
`RandomAccessFile`是一种特殊的文件流,可以用它在文件的任何地方查找或者插入数据。  

`RandomAccessFile`同时实现了`Datalnput`和`DataOutput`接口,所以可以用它来读/写文件。  

`RandomAccessFile`是一个**独立的类**，不是基于`InputStream`或`OutputStream`的子类，它可以直接操作文件，实现了对文件的随机读写。  

**主要方法**：  

- `seek(long pos)`：将文件指针定位到指定位置。
- `getFilePointer()`：返回文件指针的当前位置。
- `length()`：返回文件的长度。
- `read()`：从文件中读取一个字节，并将文件指针后移一位。
- `read(byte[] b, int off, int len)`：从文件中读取字节到字节数组中的指定位置。
- `readBoolean()`、`readByte()`、`readShort()`、`readChar()`、`readInt()`、`readLong()`、`readFloat()`、`readDouble()`：分别读取基本数据类型的值。
- `readUTF()`：以UTF-8格式从文件中读取一个字符串。
- `write(int b)`、`write(byte[] b, int off, int len)`：分别写入一个字节或字节数组到文件中。
- `writeBoolean(boolean v)`、`writeByte(int v)`、`writeShort(int v)`、`writeChar(int v)`、`writeInt(int v)`、`writeLong(long v)`、`writeFloat(float v)`、`writeDouble(double v)`：分别写入基本数据类型的值到文件中。
- `writeUTF(String str)`：以UTF-8格式将字符串写入文件。
- `close()`：关闭文件。

**构造器**  
- `RandomAccessFile(File file, String mode)`：使用指定的文件对象和访问模式创建一个新的`RandomAccessFile`实例。访问模式可以是 `"r"`（只读）、`"rw"`（读写）、`"rws"`（读写并同步文件内容）、`"rwd"`（读写并同步文件内容和元数据）。

- `RandomAccessFile(String filename, String mode)`：使用指定的文件名和访问模式创建一个新的`RandomAccessFile`实例。访问模式可以是 `"r"`（只读）、`"rw"`（读写）、`"rws"`（读写并同步文件内容）、`"rwd"`（读写并同步文件内容和元数据）。

```java
try(RandomAccessFile raf = new RandomAccessFile("toAppend.txt", "rw")) {
    raf.seek(10);
    raf.writeUTF("你好！\n");
    raf.writeUTF("世界！\n");
    raf.seek(10);
    System.out.println(raf.readUTF());
}
```
控制台：  
```txt
你好！

进程已结束，退出代码为 0
```
文件内容（具有占位符，方便读取）：  
```txt
  
你好！
 
世界！

```
## 缓存流Buffered
缓存流是计算机领域中输入输出流的一种常见形式。包括`BufferedInputStream`/ `BufferedOutputStream` 类和`BufferedReader`/ `BufferedWriter`类。  

这种流把数据从原始流成块读入或把数据积累到一个大数据块后再成批写出,通过**减少系统**资源的**读写次数**来**加快**程序的执行。`BufferedOutputstream` 或`BufferedWriter` 类仅仅在缓冲区满或调用`flush()`方法时才将数据写到目的地。  

`BufferedInputStream`实际上默认`buffer`是为8192字节，无论调用`read()`还是`read(byte[],int,int)`，它都先以默认大小为8192字节去读数据，再根据实际请求的数据量返回。  

缓存流是过滤流,在创建具体流时需要给出一个`InputStream` / `OutputStream` 类型的流作为前端流,并**可以指明缓冲区的大小**。  

**构造方法**：  
1. `BufferedInputStream(InputStream in)`：使用指定的输入流创建一个新的缓冲输入流对象，默认缓冲区大小为 8192 字节（8 KB）。
2. `BufferedInputStream(InputStream in, int size)`：使用指定的输入流创建一个新的缓冲输入流对象，并指定缓冲区大小为 `size` 字节。

**方法：**  

`BufferedInputStream` / `BufferedOutputStream`类提供`InputStream` /`OutputStream` 中定义的方法,例如 `read()` , `skip()`,`write()`等,并支持基于标签机制的回读。  

`BufferedReader`类中**增加**了一个有用的方法 `readLine()`,该方法读一行字符返回。行的结束标志是换行符“`\n`”或回车符“`\r`”,或回车符+换行符。  

`BufferedWriter`中也**相应增加**了一个方法`newLine()`,该方法写一个行分隔符。分隔符由系统特性`line.separator` 指定,可以是“`\n`”。  

```java
public class BufferedWriter extends Writer{}  
```
它将文本写入字符输出流,缓冲各个字符,从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小,或者接受默认的大小。在大多数情况下,默认值就足够大了。  

该类还提供了`newLine()`方法,并使用平台自己的行分隔符概念,此概念由系统属性 `line.separator` 定义。并非所有平台都使用新行符('\n')来终止各行，因此调用此方法来终止每个输出行要**优于**直接写入新行符。  

通常 `Writer` 将其输出立即发送到底层字符或字节流，除非要求提示输出,否则**建议用`BufferedWriter`包装所有其`write()`操作**可能开销很高的`Writer`(如 `FileWriters`和`OutputStreamWriters`)。例如:  

```java
PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter("foo.out")));  
```
将缓冲`PrintWriter`对文件的输出。如果没有缓冲,则每次调用`print()`方法会导致将字符转换为字节,然后立即写入到文件,而这是极其低效的。  

`BufferedReader`同理  

```java
package a1;  
import java.io.BufferedReader;  
import java.io.FileNotFoundException;  
import java.io.FileReader;  
import java.io.IOException;  
public class NoteTest {  
    public static void main(String[] args) {  
        FileReader fr;  
        int reccount = 0;  
        try {  
            fr = new FileReader("file2.txt");  
            BufferedReader br = new BufferedReader(fr);  
                String record = "";  
            while ((record = br.readLine()) != null) {  
                reccount++;  
                System.out.println("Line" + reccount + ": " + record);  
            }  
            fr.close();  
            br.close();  
        } catch (FileNotFoundException e) {  
            System.out.println("没有文件");  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}
```
## Files
同步IO是指，读写IO时代码必须等待数据返回后**才**继续执行后续代码，它的优点是**代码编写简单**，缺点是CPU执行效率低。  

而异步IO是指，读写IO时仅发出请求，然后立刻执行**后续代码**，它的优点是CPU执行效率高，缺点是**代码编写复杂**。  

Java标准库的包`java.io`提供了同步IO，而`java.nio`则是异步IO。上面我们讨论的`InputStream`、`OutputStream`、`Reader`和`Writer`都是同步IO的抽象类，对应的具体实现类，以文件为例，有`FileInputStream`、`FileOutputStream`、`FileReader`和`FileWriter`。  

尽管`Files`工具类和`Path`对象位于Java NIO包内，但它们提供的方法通常是同步的，即方法调用会阻塞当前线程直到操作完成。要实现异步文件操作，需要使用Java NIO的异步通道（AsynchronousChannel）和异步文件I/O API。这些API提供了异步读取和写入文件的功能，可以在文件操作过程中继续执行其他任务，提高程序的并发性能。  

从**JDK 7**开始，提供了`Files`这个工具类，能极大地方便我们读写文件。  

Java标准库还提供了一个`Path`对象，它位于`java.nio.file`包。`Path`对象和`File`对象类似，但操作更加简单.  

```java
Path p1 = Paths.get(".", "project", "study"); // 构造一个Path对象
System.out.println(p1);
Path p2 = p1.toAbsolutePath(); // 转换为绝对路径
System.out.println(p2);
Path p3 = p2.normalize(); // 转换为规范路径
System.out.println(p3);
File f = p3.toFile(); // 转换为File对象
System.out.println(f);
for (Path p : Paths.get("..").toAbsolutePath()) { // 可以直接遍历Path
    System.out.println("  " + p);
}
```
如果需要对目录进行复杂的拼接、遍历等操作，使用`Path`对象更方便。  

虽然`Files`是`java.nio`包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个`byte[]`，可以这么写：  

```java
byte[] data = Files.readAllBytes(Path.of("/path/to/file.txt"));
```
如果是文本文件，可以把一个文件的全部内容读取为`String`：  
```java
// 默认使用UTF-8编码读取:
String content1 = Files.readString(Path.of("/path/to/file.txt"));
// 可指定编码:
String content2 = Files.readString(Path.of("/path", "to", "file.txt"), StandardCharsets.ISO_8859_1);
// 按行读取并返回每行内容:
List<String> lines = Files.readAllLines(Path.of("/path/to/file.txt"));
```
写入文件也非常方便：  
```java
// 写入二进制文件:
byte[] data = ...
Files.write(Path.of("/path/to/file.txt"), data);
// 写入文本并指定编码:
Files.writeString(Path.of("/path/to/file.txt"), "文本内容...", StandardCharsets.ISO_8859_1);
// 按行写入文本:
List<String> lines = ...
Files.write(Path.of("/path/to/file.txt"), lines);
```
此外，`Files`工具类还有`copy()`、`delete()`、`exists()`、`move()`等快捷方法操作文件和目录。  
最后需要特别注意的是，`Files`提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。  