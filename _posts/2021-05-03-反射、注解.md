---
layout: post
title: Java反射、注解、泛型
categories: Java
description: Java笔记
keywords: Java
---
# 引言  
&emsp;&emsp;java反射、注解、泛型部分笔记。


# 反射
&emsp;&emsp;获取**class**的**Class**实例:  
&emsp;&emsp;直接通过**class**的静态变量**class**获取：  
```java
Class cls = String.class;
```
&emsp;&emsp;通过实例变量提供的`getClass()`方法获取：  
```java
String s = "Hello";
Class cls = s.getClass();
```
&emsp;&emsp;通过静态方法`Class.forName()`获取：  
```java
Class cls = Class.forName("java.lang.String");
```
## **Class实例基本信息:**

| 返回值      | 方法名                  | 作用                                                         |
| ----------- | ----------------------- | ------------------------------------------------------------ |
| String      | getName()               | 返回类的完全限定名。                                         |
| String      | getSimpleName()         | 返回类的简单名称，不包含包名部分。                           |
| String      | getPackage().getName()  | 返回类所在包的名称。                                         |
| boolean     | isInterface()           | 判断是否为接口。                                             |
| boolean     | isEnum()                | 判断是否为枚举类型。                                         |
| boolean     | isArray()               | 判断是否为数组类型。                                         |
| boolean     | isPrimitive()           | 判断是否为基本数据类型。                                     |
| Class       | getSuperclass()         | 返回表示该类的父类的 Class 对象。                            |
| int         | getModifiers()          | 返回表示类或接口的 Java 语言修饰符的整数。例如，public、static 等修饰符。 |
| Class[]     | getInterfaces()         | 返回一个包含表示**该类**实现的接口的 Class 对象的数组。(接口同理) |
| ClassLoader | getClassLoader()        | 返回该类的类加载器。                                         |
| boolean     | isAssignableFrom(Class) | 判断当前 `Class` 对象所表示的类或接口与指定 `Class` 参数表示的类或接口是否相同，或是否是其超类或超接口。 |

## **访问字段的方法**

| 返回值  | 方法名                        | 作用                                              |
| ------- | ----------------------------- | ------------------------------------------------- |
| Field   | getField(String name)         | 根据字段名获取某个public的field（包括父类继承）   |
| Field   | getDeclaredField(String name) | 根据字段名获取当前类的某个field（不包括父类继承） |
| Field[] | getFields()                   | 获取所有public的field（包括父类继承）             |
| Field[] | getDeclaredFields()           | 获取当前类的所有field（不包括父类继承）           |

&emsp;&emsp;一个`Field`对象包含了一个字段的所有信息：  
- `getName()`：返回字段名称，例如，`"name"`；
- `getType()`：返回字段类型，也是一个`Class`实例，例如，`String.class`；
- `getModifiers()`：返回字段的修饰符，它是一个`int`，不同的bit表示不同的含义。

&emsp;&emsp;**Field的方法**  

| 返回值 | 方法名                 | 作用                                     |
| ------ | ---------------------- | ---------------------------------------- |
| void   | set(Object o,Object v) | 设置指定对象o上此 Field 表示的字段的值为v。 |
| Object | get(Object o)          | 返回指定对象o上此 Field 表示的字段的值。  |
| void   | setAccessible(boolean) | 将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有字段) |

&emsp;&emsp;通过使用`Field`对象的`get(实例变量)`可以得到该`Fileld`对应的字段在指定实例变量的值  
&emsp;&emsp;通过使用`Field`对象的`set(实例变量,新值)`可以设置该`Fileld`对应的字段在指定实例变量的值  
&emsp;&emsp;默认是不允许访问`private`字段的,可以通过调用`Field`的`setAccessible(true)`实现访问。  
```java
import java.lang.reflect.Field;
public class Main {
    public static void main(String[] args) throws Exception {
        Object p = new Person("Xiao Ming");
        Class c = p.getClass();
        Field f = c.getDeclaredField("name");
        f.setAccessible(true);
        System.out.println(f.get(p)); // "Xiao Ming"
        f.set(p,"你好");
        System.out.println(f.get(p));
    }
}
class Person {
    private String name;
    public Person(String name) {
        this.name = name;
    }
}
```
## **访问方法的方法**

| 返回值   | 方法名                                                     | 作用                                                         |
| -------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| Method   | getMethod(String name, Class<?>... parameterTypes)         | 获取某个`public`的`Method`（包括父类继承）name:方法名,parameterTypes:形式参数的Class |
| Method   | getDeclaredMethod(String name, Class<?>... parameterTypes) | 获取当前类的某个`Method`（不包括父类继承）name:方法名,parameterTypes:形式参数的Class |
| Method[] | getMethods()                                               | 获取所有`public`的`Method`（包括父类继承）                   |
| Method[] | getDeclaredMethods()                                       | 获取当前类的所有`Method`（不包括父类继承）                   |

&emsp;&emsp;一个`Method`对象包含一个方法的所有信息：  
- `getName()`：返回方法名称，例如：`"getScore"`；
- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；
- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；
- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的bit表示不同的含义。

&emsp;&emsp;**Method的方法**  

| 返回值 | 方法名                         | 作用                                                         |
| ------ | ------------------------------ | ------------------------------------------------------------ |
|        | invoke(Object o,Object ...arg) | 调用指定对象o上此 Method表示的方法,方法的形式参数为arg。若为静态方法,则o设置为null, |
| void   | setAccessible(boolean b)       | 将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法) |

```java
// String对象:
String s = "Hello world";
// 获取String substring(int)方法，参数为int:
Method m = String.class.getMethod("substring", int.class);
// 在s对象上调用该方法并获取结果:
String r = (String) m.invoke(s, 6);
// 打印调用结果:
System.out.println(r);
```
## 访问构造方法的方法

| 返回值        | 方法名                               | 作用                                            |
| ------------- | ------------------------------------ | ----------------------------------------------- |
| Object        | newInstance()                        | 只能调用公有的无参数构造方法。                  |
| Constructor   | getConstructor(Class ... arg)        | 获取指定类的指定**公有**构造方法,arg为形式参数. |
| Constructor   | getDeclaredConstructor(Class... arg) | 获取指定类的构造方法,arg为形式参数.             |
| Constructor[] | getConstructors()                    | 返回该类的所有**公有**构造方法。                |
| Constructor[] | getDeclaredConstructors()            | 返回该类的所有构造方法。                        |

&emsp;&emsp;**Constructor 的方法**  

| 返回值 | 方法名                     | 作用                                                         |
| ------ | -------------------------- | ------------------------------------------------------------ |
| Object | newInstance(Object ...arg) | 调用构造方法,参数为arg。                                     |
| void   | setAccessible(boolean b)   | 将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法) |

```java
// 获取String的Class实例:String s=new Stirng();
Class cls = String.class;
// 调用构造方法:
String s = (String) cls.newInstance();
System.out.println(s);
// 获取构造方法Integer(int):Integer n1=new Integer(123);
Constructor cons1 = Integer.class.getConstructor(int.class);
// 调用构造方法:
Integer n1 = (Integer) cons1.newInstance(123);
System.out.println(n1);
```
## 动态代理
&emsp;&emsp;有没有可能不编写实现类，直接在运行期创建某个`interface`的实例呢？  
&emsp;&emsp;这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个`interface`的实例。  
&emsp;&emsp;什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：  
&emsp;&emsp;定义接口：  
```java
public interface Hello {
    void morning(String name);
}
```
&emsp;&emsp;编写实现类：  
```java
public class HelloWorld implements Hello {
    public void morning(String name) {
        System.out.println("Good morning, " + name);
    }
}
```
&emsp;&emsp;创建实例，转型为接口并调用：  
```java
Hello hello = new HelloWorld();
hello.morning("Bob");
```
&emsp;&emsp;这种方式就是我们通常编写代码的方式。  
&emsp;&emsp;还有一种方式是动态代码，我们仍然先定义了接口`Hello`，但是我们并不去编写实现类，而是直接通过JDK提供的一个`Proxy.newProxyInstance()`创建了一个`Hello`接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。  
&emsp;&emsp;一个最简单的动态代理实现如下：  
```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class Main {
    public static void main(String[] args) {
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                if (method.getName().equals("morning")) {
                    System.out.println("Good morning, " + args[0]);
                }
                return null;
            }
        };
        Hello hello = (Hello) Proxy.newProxyInstance(
            Hello.class.getClassLoader(), // 传入ClassLoader
            new Class[] { Hello.class }, // 传入要实现的接口
            handler); // 传入处理调用方法的InvocationHandler
        hello.morning("Bob");
    }
}

interface Hello {
    void morning(String name);
}
```
&emsp;&emsp;在运行期动态创建一个`interface`实例的方法如下：  
&emsp;&emsp;定义一个`InvocationHandler`实例，它负责实现接口的方法调用；  
&emsp;&emsp;通过`Proxy.newProxyInstance()`创建`interface`实例，它需要3个参数：  
1. 使用的`ClassLoader`，通常就是接口类的`ClassLoader`；
2. 需要实现的接口数组，至少需要传入一个接口进去；
3. 用来处理接口方法调用的`InvocationHandler`实例。

&emsp;&emsp;将返回的`Object`强制转型为接口。  
&emsp;&emsp;动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：  
```java
public class HelloDynamicProxy implements Hello {
    InvocationHandler handler;
    public HelloDynamicProxy(InvocationHandler handler) {
        this.handler = handler;
    }
    public void morning(String name) {
        handler.invoke(
           this,
           Hello.class.getMethod("morning", String.class),
           new Object[] { name });
    }
}
```
&emsp;&emsp;其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。  
# 注解
&emsp;&emsp;注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。  
&emsp;&emsp;Java的注解可以分为三类：  
&emsp;&emsp;第一类是由编译器使用的注解，例如：  
- `@Override`：让编译器检查该方法是否正确地实现了覆写；
- `@SuppressWarnings`：告诉编译器忽略此处代码产生的警告。

&emsp;&emsp;这类注解不会被编译进入`.class`文件，它们在编译后就被编译器扔掉了。  
&emsp;&emsp;第二类是由工具处理`.class`文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入`.class`文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。  
&emsp;&emsp;第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了`@PostConstruct`的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。  

&emsp;&emsp;定义一个注解时，还可以定义配置参数。配置参数可以包括：  
- 所有基本类型；
- String；
- 枚举类型；
- 基本类型、String、Class以及枚举的数组。

&emsp;&emsp;因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。  
&emsp;&emsp;注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。  
&emsp;&emsp;此外，大部分注解会有一个名为`value`的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。即从`@Check(value=99)`省略为`@check(99)`。  
## 定义注解
&emsp;&emsp;Java语言使用`@interface`语法来定义注解（`Annotation`），它的格式如下：  
```java
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```
&emsp;&emsp;注解的参数类似无参数方法，可以用`default`设定一个默认值（强烈推荐）。最常用的参数应当命名为`value`。  
### 元注解
&emsp;&emsp;有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。  
#### @Target
&emsp;&emsp;最常用的元注解是`@Target`。使用`@Target`可以定义`Annotation`能够被应用于源码的哪些位置：  
- 类或接口：`ElementType.TYPE`；
- 字段：`ElementType.FIELD`；
- 方法：`ElementType.METHOD`；
- 构造方法：`ElementType.CONSTRUCTOR`；
- 方法参数：`ElementType.PARAMETER`。

&emsp;&emsp;例如，定义注解`@Report`可用在方法上，我们必须添加一个`@Target(ElementType.METHOD)`：  
```java
@Target(ElementType.METHOD)
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```
&emsp;&emsp;定义注解`@Report`可用在方法或字段上，可以把`@Target`注解参数变为数组`{ ElementType.METHOD, ElementType.FIELD }`：  
&emsp;&emsp;实际上`@Target`定义的`value`是`ElementType[]`数组，只有一个元素时，可以省略数组的写法。  
#### @Retention
&emsp;&emsp;另一个重要的元注解`@Retention`定义了`Annotation`的生命周期：  
- 仅编译期：`RetentionPolicy.SOURCE`；
- 仅class文件：`RetentionPolicy.CLASS`；
- 运行期：`RetentionPolicy.RUNTIME`。

&emsp;&emsp;如果`@Retention`不存在，则该`Annotation`默认为`CLASS`。因为通常我们自定义的`Annotation`都是`RUNTIME`，所以，务必要加上`@Retention(RetentionPolicy.RUNTIME)`这个元注解：  
```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```
#### @Repeatable
&emsp;&emsp;使用`@Repeatable`这个元注解可以定义`Annotation`是否可重复。这个注解应用不是特别广泛。`@Reports`是一个容器注解，用来包裹多个`@Report`注解。  
```java
@Repeatable(Reports.class)
@Target(ElementType.TYPE)
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}

@Target(ElementType.TYPE)
public @interface Reports {
    Report[] value();
}
```
&emsp;&emsp;经过`@Repeatable`修饰后，在某个类型声明处，就可以添加多个`@Report`注解：  
```java
@Report(type=1, level="debug")
@Report(type=2, level="warning")
public class Hello {
}
```
#### @Inherited
&emsp;&emsp;使用`@Inherited`定义子类是否可继承父类定义的`Annotation`。`@Inherited`仅针对`@Target(ElementType.TYPE)`类型的`annotation`有效，并且仅针对`class`的继承，对`interface`的继承无效。  
## 处理注解
&emsp;&emsp;Java的注解本身对代码逻辑没有任何影响。根据`@Retention`的配置：  
- `SOURCE`类型的注解在编译期就被丢掉了；
- `CLASS`类型的注解仅保存在class文件中，它们不会被加载进JVM；
- `RUNTIME`类型的注解会被加载进JVM，并且在运行期可以被程序读取。

&emsp;&emsp;如何使用注解完全由工具决定。`SOURCE`类型的注解主要由编译器使用，因此我们一般只使用，不编写。`CLASS`类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有`RUNTIME`类型的注解不但要使用，还经常需要编写。  
&emsp;&emsp;因此，我们只讨论如何读取`RUNTIME`类型的注解。  
&emsp;&emsp;因为注解定义后也是一种`class`，所有的注解都继承自`java.lang.annotation.Annotation`，因此，读取注解，需要使用反射API。  
&emsp;&emsp;Java提供的使用反射API读取`Annotation`的方法包括：  
&emsp;&emsp;判断某个注解是否存在于`Class`、`Field`、`Method`或`Constructor`：  
- `Class.isAnnotationPresent(Class)`
- `Field.isAnnotationPresent(Class)`
- `Method.isAnnotationPresent(Class)`
- `Constructor.isAnnotationPresent(Class)`

&emsp;&emsp;例如：  
```java
// 判断@Report是否存在于Person类:
Person.class.isAnnotationPresent(Report.class);
```
&emsp;&emsp;使用反射API读取Annotation：  
- `Class.getAnnotation(Class)`
- `Field.getAnnotation(Class)`
- `Method.getAnnotation(Class)`
- `Constructor.getAnnotation(Class)`

&emsp;&emsp;例如：  
```java
// 获取Person定义的@Report注解:
Report report = Person.class.getAnnotation(Report.class);
int type = report.type();
String level = report.level();
```
&emsp;&emsp;读取方法、字段和构造方法的`Annotation`和Class类似。但要读取方法参数的`Annotation`就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：  
```java
public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {}
```
&emsp;&emsp;要读取方法参数的注解，先用反射获取`Method`实例，然后读取方法参数的所有注解：  
```java
// 获取Method实例:
Method m = Main.class.getDeclaredMethod("hello", String.class, String.class);
// 获取所有参数的Annotation:
Annotation[][] annos = m.getParameterAnnotations();
// 第一个参数（索引为0）的所有Annotation:
Annotation[] annosOfName = annos[0];
for (Annotation anno : annosOfName) {
    if (anno instanceof Range) {
        Range r = (Range) anno; // @Range注解
        System.out.printf("%d", r.max());
    }
    if (anno instanceof NotNull) {
         NotNull n = (NotNull) anno; // @NotNull注解
        System.out.println("已捕获NotNull");
    }
}
```
## 尝试手搓**@NotNull @Range**
&emsp;&emsp;但对于方法的形式参数，Java的反射机制并不能直接获取参数的值,因此失败了。如果需要在方法运行时对参数进行检查，可以使用面向切面编程（AOP）结合反射来实现。  
&emsp;&emsp;不过对于对象的字段，可以直接通过反射获取字段的值，并进行判断。但要注意判断的时机需要另外的事件来触发。  
```java
package com.aotmd;

import java.lang.annotation.*;
import java.lang.reflect.Field;

public class Main {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        checkField(myClass);
    }

    private static void checkField(Object obj) {
        try {
            Field[] fields = obj.getClass().getDeclaredFields();
            for (Field field : fields) {
                Annotation[] annotations = field.getAnnotations();
                NotNull n = null;
                for (Annotation annotation : annotations) {
                    Class<? extends Annotation> aClass = annotation.annotationType();
                    field.setAccessible(true);
                    Object value = field.get(obj);

                    if (aClass == NotNull.class) {
                        n = notNullDispose((NotNull) annotation, value);
                    } else if (aClass == Range.class) {
                        rangeDispose(field, (Range) annotation, value, n);
                    }
                }
            }
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    private static void rangeDispose(Field field, Range annotation, Object value, NotNull n) {
        if (value instanceof String) {
            String s = (String) value;
            if (s.length() < annotation.min() || s.length() > annotation.max()) {
                String text;
                if (n != null) {
                    text = n.value() + "=" + s + " 无效,长度必须不小于:" + annotation.min() + ",不大于:" + annotation.max();
                } else {
                    text = field.getName() + "=" + s + " 无效,长度必须不小于:" + annotation.min() + ",不大于:" + annotation.max();
                }
                System.out.println(text);
//              throw new IllegalArgumentException(text);
            }
        }
    }

    private static NotNull notNullDispose(NotNull annotation, Object value) {
        NotNull n;
        n = annotation;
        if (value == null) {
            System.out.println(n.value() + " 不能为空");
//          throw new IllegalArgumentException(n.value() + " 不能为空");
        }
        return n;
    }
}
class MyClass {
    @NotNull("名称")
    private String name = null;
    @NotNull("地址")
    @Range(max = 5)
    private String address = "123456";
}
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
@interface NotNull {
    String value() default "";
}
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
@interface Range {
    int min() default 0;

    int max() default 255;
}
```
# 泛型
&emsp;&emsp;泛型就是编写模板代码来适应任意类型；  
&emsp;&emsp;泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；  
&emsp;&emsp;注意泛型的继承关系：可以把`ArrayList<Integer>`向上转型为`List<Integer>`（`T`不能变！），但不能把`ArrayList<Integer>`向上转型为`ArrayList<Number>`（`T`不能变成父类）。  
&emsp;&emsp;使用`ArrayList`时，如果不定义泛型类型时，泛型类型实际上就是`Object`  
&emsp;&emsp;编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。  
```java
&emsp;&emsp;List<Number> list = new ArrayList<Number>();  
```
&emsp;&emsp;编译器看到泛型类型`List<Number>`就可以自动推断出后面的`ArrayList<T>`的泛型类型必须是`ArrayList<Number>`，因此，可以把代码简写为：  
```java
// 可以省略后面的Number，编译器可以自动推断泛型类型：
List<Number> list = new ArrayList<>();
```
&emsp;&emsp;除了`ArrayList<T>`使用了泛型，还可以在接口中使用泛型。例如，`Arrays.sort(Object[])`可以对任意数组进行排序，但待排序的元素必须实现`Comparable<T>`这个泛型接口。  
&emsp;&emsp;写法:  
```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```
## 静态方法
&emsp;&emsp;编写泛型类时，要特别注意，泛型类型`<T>`不能用于静态方法。  
&emsp;&emsp;例如：  
```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public T getLast() { ... }
    // 对静态方法使用<T>:
    public static Pair<T> create(T first, T last) {
        return new Pair<T>(first, last);
    }
}
```
&emsp;&emsp;上述代码会导致编译错误，我们无法在静态方法`create()`的方法参数和返回类型上使用泛型类型`T`。  
&emsp;&emsp;可以在`static`修饰符后面加一个`<T>`，编译就能通过：  
```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public T getLast() { ... }
    // 可以编译通过:
    public static <T> Pair<T> create(T first, T last) {
        return new Pair<T>(first, last);
    }
}
```
&emsp;&emsp;但实际上，这个`<T>`和`Pair<T>`类型的`<T>`已经没有任何关系了。  
&emsp;&emsp;对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的`create()`静态方法，我们应该把它改为另一种泛型类型，例如，`<K>`;这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。`public static <T> Pair<T> create(T first, T last) {` `static <T> `这个`T`就是语法标识,调用`create`:  
```java
Pair.<String>create("123","456");
```
- 泛型类型是在实例化对象时确定的，而静态方法是在类加载时就可以直接调用的，无需创建对象实例。所以静态方法中的返回值、参数等不能依赖泛型类型<T>，必须将静态方法的泛型类型和实例类型的泛型类型区分开。  
- 此外，静态方法是与类本身相关联的，而不是与类的实例相关联的。因此，即使创建了一个类的实例，静态方法也无法访问实例的泛型类型。静态方法由于随着类的加载而加载，不能访问类的泛型（因为在创建对象的时候才确定），因此必须定义自己的泛型类型。  

## 多个泛型类型
&emsp;&emsp;泛型还可以定义多种类型。例如，我们希望`Pair`不总是存储两个类型一样的对象，就可以使用类型`<T, K>`：  
```java
public class Pair<T, K> {
    private T first;
    private K last;
    public Pair(T first, K last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() { ... }
    public K getLast() { ... }
}
```
&emsp;&emsp;使用的时候，需要指出两种类型：  
```java
Pair<String, Integer> p = new Pair<>("test", 123);
```
&emsp;&emsp;Java标准库的`Map<K, V>`就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。  

## 擦拭法

&emsp;&emsp;所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。因此编译器把类型`<T>`视为`Object`；编译器根据`<T>`实现安全的强制转型。  
&emsp;&emsp;例如，我们编写了一个泛型类`Pair<T>`，这是编译器看到的代码：  
```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```
&emsp;&emsp;而虚拟机根本不知道泛型。这是虚拟机执行的代码：  
```java
public class Pair {
    private Object first;
    private Object last;
    public Pair(Object first, Object last) {
        this.first = first;
        this.last = last;
    }
    public Object getFirst() {
        return first;
    }
    public Object getLast() {
        return last;
    }
}
```
&emsp;&emsp;使用泛型的时候，我们编写的代码也是编译器看到的代码：  
```java
Pair<String> p = new Pair<>("Hello", "world");
String first = p.getFirst();
String last = p.getLast();
```
&emsp;&emsp;而虚拟机执行的代码并没有泛型：  
```java
Pair p = new Pair("Hello", "world");
String first = (String) p.getFirst();
String last = (String) p.getLast();
```
&emsp;&emsp;Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型`T`视为`Object`处理，但是，在需要转型的时候，编译器会根据`T`的类型自动为我们实行安全地强制转型。  
&emsp;&emsp;局限一：`<T>`不能是基本类型，例如`int`，因为实际类型是`Object`，`Object`类型无法持有基本类型：  
```
Pair<int> p = new Pair<>(1, 2); // compile error!
```
&emsp;&emsp;局限二：无法取得带泛型的`Class`。观察以下代码：  
```java
public class Main {
    public static void main(String[] args) {
        Pair<String> p1 = new Pair<>("Hello", "world");
        Pair<Integer> p2 = new Pair<>(123, 456);
        Class c1 = p1.getClass();
        Class c2 = p2.getClass();
        System.out.println(c1==c2); // true
        System.out.println(c1==Pair.class); // true
    }
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```
&emsp;&emsp;因为`T`是`Object`，我们对`Pair<String>`和`Pair<Integer>`类型获取`Class`时，获取到的是同一个`Class`，也就是`Pair`类的`Class`。  
&emsp;&emsp;换句话说，所有泛型实例，无论`T`的类型是什么，`getClass()`返回同一个`Class`实例，因为编译后它们全部都是`Pair<Object>`。  
&emsp;&emsp;局限三：无法判断带泛型的类型：  
```java
Pair<Integer> p = new Pair<>(123, 456);
// Compile error:
if (p instanceof Pair<String>) {
}
```
&emsp;&emsp;原因和前面一样，并不存在`Pair<String>.class`，而是只有唯一的`Pair.class`。  
&emsp;&emsp;局限四：不能实例化`T`类型：  
```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair() {
        // Compile error:
        first = new T();
        last = new T();
    }
}
```
&emsp;&emsp;上述代码无法通过编译，因为构造方法的两行语句：  
```java
first = new T();
last = new T();
```
&emsp;&emsp;擦拭后实际上变成了：  
```java
first = new Object();
last = new Object();
```
&emsp;&emsp;这样一来，创建`new Pair<String>()`和创建`new Pair<Integer>()`就全部成了`Object`，显然编译器要阻止这种类型不对的代码。  
&emsp;&emsp;要实例化`T`类型，我们必须借助额外的`Class<T>`参数：  
```java
public class Pair<T> {
    private T first;
    private T last;
    public Pair(Class<T> clazz) {
        first = clazz.newInstance();
        last = clazz.newInstance();
    }
}
```
&emsp;&emsp;上述代码借助`Class<T>`参数并通过反射来实例化`T`类型，使用的时候，也必须传入`Class<T>`。例如：  
```java
Pair<String> pair = new Pair<>(String.class);
```
&emsp;&emsp;因为传入了`Class<String>`的实例，所以我们借助`String.class`就可以实例化`String`类型。  
### 不恰当的覆写方法
&emsp;&emsp;有些时候，一个看似正确定义的方法会无法通过编译。例如：  
```java
public class Pair<T> {
    public boolean equals(T t) {
        return this == t;
    }
}
```
&emsp;&emsp;这是因为，定义的`equals(T t)`方法实际上会被擦拭成`equals(Object t)`，而这个方法是继承自`Object`的，编译器会阻止一个实际上会变成覆写的泛型方法定义。  
&emsp;&emsp;换个方法名，避开与`Object.equals(Object)`的冲突就可以成功编译：  
```java
public class Pair<T> {
    public boolean same(T t) {
        return this == t;
    }
}
```
### 泛型继承
&emsp;&emsp;一个类可以继承自一个泛型类。例如：父类的类型是`Pair<Integer>`，子类的类型是`IntPair`，可以这么继承：  
```java
public class IntPair extends Pair<Integer> {
}
```
&emsp;&emsp;使用的时候，因为子类`IntPair`并没有泛型类型，所以，正常使用即可：  
```java
IntPair ip = new IntPair(1, 2);
```
&emsp;&emsp;前面讲了，我们无法获取`Pair<T>`的`T`类型，即给定一个变量`Pair<Integer> p`，无法从`p`中获取到`Integer`类型。  
&emsp;&emsp;但是，在父类是泛型类型的情况下，编译器就必须把类型`T`（对`IntPair`来说，也就是`Integer`类型）保存到子类的class文件中，不然编译器就不知道`IntPair`只能存取`Integer`这种类型。  
&emsp;&emsp;在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：`IntPair`可以获取到父类的泛型类型`Integer`。获取父类的泛型类型代码比较复杂：  
```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
public class Main {
    public static void main(String[] args) {
        Class<IntPair> clazz = IntPair.class;
        Type t = clazz.getGenericSuperclass();
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) t;
            Type[] types = pt.getActualTypeArguments(); // 可能有多个泛型类型
            Type firstType = types[0]; // 取第一个泛型类型
            Class<?> typeClass = (Class<?>) firstType;
            System.out.println(typeClass); // Integer
        }
    }
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
class IntPair extends Pair<Integer> {
    public IntPair(Integer first, Integer last) {
        super(first, last);
    }
}
```
&emsp;&emsp;因为Java引入了泛型，所以，只用`Class`来标识类型已经不够了。实际上，Java的类型系统结构如下：  
```ascii
                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
```
### 小结
&emsp;&emsp;Java的泛型是采用擦拭法实现的；  
&emsp;&emsp;擦拭法决定了泛型`<T>`：  
- 不能是基本类型，例如：`int`；
- 不能获取带泛型类型的`Class`，例如：`Pair<String>.class`；
- 不能判断带泛型类型的类型，例如：`x instanceof Pair<String>`；
- 不能实例化`T`类型，例如：`new T()`。

&emsp;&emsp;泛型方法要防止重复定义方法，例如：`public boolean equals(T obj)`；  
&emsp;&emsp;子类可以获取父类的泛型类型`<T>`。  
## extends通配符
&emsp;&emsp;我们前面已经讲到了泛型的继承关系：`Pair<Integer>`不是`Pair<Number>`的子类。  
&emsp;&emsp;假设我们定义了`Pair<T>`：  
```java
public class Pair<T> { ... }
```
&emsp;&emsp;然后，我们又针对`Pair<Number>`类型写了一个静态方法，它接收的参数类型是`Pair<Number>`：  
```java
public class PairHelper {
    static int add(Pair<Number> p) {
        Number first = p.getFirst();
        Number last = p.getLast();
        return first.intValue() + last.intValue();
    }
}
```
&emsp;&emsp;上述代码是可以正常编译的。使用的时候，我们传入：  
```java
int sum = PairHelper.add(new Pair<Number>(1, 2));
```
&emsp;&emsp;注意：传入的类型是`Pair<Number>`，实际参数类型是`(Integer, Integer)`。  
&emsp;&emsp;既然实际参数是`Integer`类型，试试传入`Pair<Integer>`：  
```java
public class Main {
    public static void main(String[] args) {
        Pair<Integer> p = new Pair<>(123, 456);
        int n = add(p);
        System.out.println(n);
    }
    static int add(Pair<Number> p) {
        Number first = p.getFirst();
        Number last = p.getLast();
        return first.intValue() + last.intValue();
    }
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```
&emsp;&emsp;直接运行，会得到一个编译错误：  
```java
incompatible types: Pair<Integer> cannot be converted to Pair<Number>
```
&emsp;&emsp;原因很明显，因为`Pair<Integer>`不是`Pair<Number>`的子类，因此，`add(Pair<Number>)`不接受参数类型`Pair<Integer>`。  
&emsp;&emsp;但是从`add()`方法的代码可知，传入`Pair<Integer>`是完全符合内部代码的类型规范，因为语句：  
```java
Number first = p.getFirst();
Number last = p.getLast();
```
&emsp;&emsp;实际类型是`Integer`，引用类型是`Number`，没有问题。问题在于方法参数类型定死了只能传入`Pair<Number>`。  
&emsp;&emsp;有没有办法使得方法参数接受`Pair<Integer>`？办法是有的，这就是使用`Pair<? extends Number>`使得方法接收所有泛型类型为`Number`或`Number`子类的`Pair`类型。我们把代码改写如下：  
```java
public class Main {
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
}
```
&emsp;&emsp;这样一来，给方法传入`Pair<Integer>`类型时，它符合参数`Pair<? extends Number>`类型。这种使用`<? extends Number>`的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型`T`的上界限定在`Number`了。  
&emsp;&emsp;除了可以传入`Pair<Integer>`类型，我们还可以传入`Pair<Double>`类型，`Pair<BigDecimal>`类型等等，因为`Double`和`BigDecimal`都是`Number`的子类。  
&emsp;&emsp;如果我们考察对`Pair<? extends Number>`类型调用`getFirst()`方法，实际的方法签名变成了：  
```java
<? extends Number> getFirst();
```
&emsp;&emsp;即返回值是`Number`或`Number`的子类，因此，可以安全赋值给`Number`类型的变量：  
```java
Number x = p.getFirst();
```
&emsp;&emsp;然后，我们不可预测实际类型就是`Integer`，例如，下面的代码是无法通过编译的：  
```java
Integer x = p.getFirst();
```
&emsp;&emsp;这是因为实际的返回类型可能是`Integer`，也可能是`Double`或者其他类型，编译器只能确定类型一定是`Number`的子类（包括`Number`类型本身），但具体类型无法确定。  
&emsp;&emsp;我们再来考察一下`Pair<T>`的`set`方法：  
```java
public class Main {
    public static void main(String[] args) {
        Pair<Integer> p = new Pair<>(123, 456);
        int n = add(p);
        System.out.println(n);
    }
    static int add(Pair<? extends Number> p) {
        Number first = p.getFirst();
        Number last = p.getLast();
        p.setFirst(new Integer(first.intValue() + 100));
        p.setLast(new Integer(last.intValue() + 100));
        return p.getFirst().intValue() + p.getFirst().intValue();
    }
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
    public void setFirst(T first) {
        this.first = first;
    }
    public void setLast(T last) {
        this.last = last;
    }
}
```
&emsp;&emsp;不出意外，我们会得到一个编译错误：  
```text
incompatible types: Integer cannot be converted to CAP#1
where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
```
&emsp;&emsp;编译错误发生在`p.setFirst()`传入的参数是`Integer`类型。有些童鞋会问了，既然`p`的定义是`Pair<? extends Number>`，那么`setFirst(? extends Number)`为什么不能传入`Integer`？  
&emsp;&emsp;原因还在于擦拭法。如果我们传入的`p`是`Pair<Double>`，显然它满足参数定义`Pair<? extends Number>`，然而，`Pair<Double>`的`setFirst()`显然无法接受`Integer`类型。  
&emsp;&emsp;这就是`<? extends Number>`通配符的一个重要限制：方法参数签名`setFirst(? extends Number)`无法传递任何`Number`的子类型给`setFirst(? extends Number)`。  
&emsp;&emsp;这里唯一的例外是可以给方法参数传入`null`：  
```java
p.setFirst(null); // ok, 但是后面会抛出NullPointerException
p.getFirst().intValue(); // NullPointerException
```
### extends通配符的作用
&emsp;&emsp;如果我们考察Java标准库的`java.util.List<T>`接口，它实现的是一个类似“可变数组”的列表，主要功能包括：  
```java
public interface List<T> {
    int size(); // 获取个数
    T get(int index); // 根据索引获取指定元素
    void add(T t); // 添加一个新元素
    void remove(T t); // 删除一个已有元素
}
```
&emsp;&emsp;现在，让我们定义一个方法来处理列表的每个元素：  
```java
int sumOfList(List<? extends Integer> list) {
    int sum = 0;
    for (int i=0; i<list.size(); i++) {
        Integer n = list.get(i);
        sum = sum + n;
    }
    return sum;
}
```
&emsp;&emsp;为什么我们定义的方法参数类型是`List<? extends Integer>`而不是`List<Integer>`？从方法内部代码看，传入`List<? extends Integer>`或者`List<Integer>`是完全一样的，但是，注意到`List<? extends Integer>`的限制：  
- 允许调用`get()`方法获取`Integer`的引用；
- 不允许调用`set(? extends Integer)`方法并传入任何`Integer`的引用（`null`除外）。
&emsp;&emsp;因此，方法参数类型`List<? extends Integer>`表明了该方法内部只会读取`List`的元素，不会修改`List`的元素（因为无法调用`add(? extends Integer)`、`remove(? extends Integer)`这些方法。换句话说，这是一个对参数`List<? extends Integer>`进行只读的方法（恶意调用`set(null)`除外）。  
### 使用extends限定T类型
&emsp;&emsp;在定义泛型类型`Pair<T>`的时候，也可以使用`extends`通配符来限定`T`的类型：  
```java
public class Pair<T extends Number> { ... }
```
&emsp;&emsp;现在，我们只能定义：  
```java
Pair<Number> p1 = null;
Pair<Integer> p2 = new Pair<>(1, 2);
Pair<Double> p3 = null;
```
&emsp;&emsp;因为`Number`、`Integer`和`Double`都符合`<T extends Number>`。  
&emsp;&emsp;非`Number`类型将无法通过编译：  
```java
Pair<String> p1 = null; // compile error!
Pair<Object> p2 = null; // compile error!
```
&emsp;&emsp;因为`String`、`Object`都不符合`<T extends Number>`，因为它们不是`Number`类型或`Number`的子类。  

### 小结
&emsp;&emsp;使用类似`<? extends Number>`通配符作为方法参数时表示：  
- 方法内部可以调用获取`Number`引用的方法，例如：`Number n = obj.getFirst();`；
- 方法内部无法调用传入`Number`引用的方法（`null`除外），例如：`obj.setFirst(Number n);`。

&emsp;&emsp;即一句话总结：使用`extends`通配符表示可以读，不能写。  
&emsp;&emsp;使用类似`<T extends Number>`定义泛型类时表示：  
- 泛型类型限定为`Number`以及`Number`的子类。

## super通配符
&emsp;&emsp;我们前面已经讲到了泛型的继承关系：`Pair<Integer>`不是`Pair<Number>`的子类。  
&emsp;&emsp;考察下面的`set`方法：  
```java
void set(Pair<Integer> p, Integer first, Integer last) {
    p.setFirst(first);
    p.setLast(last);
}
```
&emsp;&emsp;传入`Pair<Integer>`是允许的，但是传入`Pair<Number>`是不允许的。  
&emsp;&emsp;和`extends`通配符相反，这次，我们希望接受`Pair<Integer>`类型，以及`Pair<Number>`、`Pair<Object>`，因为`Number`和`Object`是`Integer`的父类，`setFirst(Number)`和`setFirst(Object)`实际上允许接受`Integer`类型。  
&emsp;&emsp;我们使用`super`通配符来改写这个方法：  
```java
void set(Pair<? super Integer> p, Integer first, Integer last) {
    p.setFirst(first);
    p.setLast(last);
}
```
&emsp;&emsp;注意到`Pair<? super Integer>`表示，方法参数接受所有泛型类型为`Integer`或`Integer`父类的`Pair`类型。  
&emsp;&emsp;下面的代码可以被正常编译：  
```java
public class Main {
    public static void main(String[] args) {
        Pair<Number> p1 = new Pair<>(12.3, 4.56);
        Pair<Integer> p2 = new Pair<>(123, 456);
        setSame(p1, 100);
        setSame(p2, 200);
        System.out.println(p1.getFirst() + ", " + p1.getLast());
        System.out.println(p2.getFirst() + ", " + p2.getLast());
    }
    static void setSame(Pair<? super Integer> p, Integer n) {
        p.setFirst(n);
        p.setLast(n);
    }
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
    public void setFirst(T first) {
        this.first = first;
    }
    public void setLast(T last) {
        this.last = last;
    }
}
```
&emsp;&emsp;考察`Pair<? super Integer>`的`setFirst()`方法，它的方法签名实际上是：  
```java
void setFirst(? super Integer);
```
&emsp;&emsp;因此，可以安全地传入`Integer`类型。  
&emsp;&emsp;再考察`Pair<? super Integer>`的`getFirst()`方法，它的方法签名实际上是：  
```java
? super Integer getFirst();
```
&emsp;&emsp;这里注意到我们无法使用`Integer`类型来接收`getFirst()`的返回值，即下面的语句将无法通过编译：  
```java
Integer x = p.getFirst();
```
&emsp;&emsp;因为如果传入的实际类型是`Pair<Number>`，编译器无法将`Number`类型转型为`Integer`。  
&emsp;&emsp;注意：虽然`Number`是一个抽象类，我们无法直接实例化它。但是，即便`Number`不是抽象类，这里仍然无法通过编译。此外，传入`Pair<Object>`类型时，编译器也无法将`Object`类型转型为`Integer`。  
&emsp;&emsp;唯一可以接收`getFirst()`方法返回值的是`Object`类型：  
```java
Object obj = p.getFirst();
```
&emsp;&emsp;因此，使用`<? super Integer>`通配符表示：  
- 允许调用`set(? super Integer)`方法传入`Integer`的引用；
- 不允许调用`get()`方法获得`Integer`的引用。

&emsp;&emsp;唯一例外是可以获取`Object`的引用：`Object o = p.getFirst()`。  
&emsp;&emsp;换句话说，使用`<? super Integer>`通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。  

### 对比extends和super通配符
&emsp;&emsp;我们再回顾一下`extends`通配符。作为方法参数，`<? extends T>`类型和`<? super T>`类型的区别在于：  
- `<? extends T>`允许调用读方法`T get()`获取`T`的引用，但不允许调用写方法`set(T)`传入`T`的引用（传入`null`除外）；
- `<? super T>`允许调用写方法`set(T)`传入`T`的引用，但不允许调用读方法`T get()`获取`T`的引用（获取`Object`除外）。

&emsp;&emsp;一个是允许读不允许写，另一个是允许写不允许读。  
&emsp;&emsp;先记住上面的结论，我们来看Java标准库的`Collections`类定义的`copy()`方法：  
```java
public class Collections {
    // 把src的每个元素复制到dest中:
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (int i=0; i<src.size(); i++) {
            T t = src.get(i);
            dest.add(t);
        }
    }
}
```
&emsp;&emsp;它的作用是把一个`List`的每个元素依次添加到另一个`List`中。它的第一个参数是`List<? super T>`，表示目标`List`，第二个参数`List<? extends T>`，表示要复制的`List`。我们可以简单地用`for`循环实现复制。在`for`循环中，我们可以看到，对于类型`<? extends T>`的变量`src`，我们可以安全地获取类型`T`的引用，而对于类型`<? super T>`的变量`dest`，我们可以安全地传入`T`的引用。  
&emsp;&emsp;这个`copy()`方法的定义就完美地展示了`extends`和`super`的意图：  
- `copy()`方法内部不会读取`dest`，因为不能调用`dest.get()`来获取`T`的引用；
- `copy()`方法内部也不会修改`src`，因为不能调用`src.add(T)`。

&emsp;&emsp;这是由编译器检查来实现的。如果在方法代码中意外修改了`src`，或者意外读取了`dest`，就会导致一个编译错误：  
```java
public class Collections {
    // 把src的每个元素复制到dest中:
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        ...
        T t = dest.get(0); // compile error!
        src.add(t); // compile error!
    }
}
```
&emsp;&emsp;这个`copy()`方法的另一个好处是可以安全地把一个`List<Integer>`添加到`List<Number>`，但是无法反过来添加：  
```java
// copy List<Integer> to List<Number> ok:
List<Number> numList = ...;
List<Integer> intList = ...;
Collections.copy(numList, intList);
// ERROR: cannot copy List<Number> to List<Integer>:
Collections.copy(intList, numList);
```
&emsp;&emsp;而这些都是通过`super`和`extends`通配符，并由编译器强制检查来实现的。  
### PECS原则
&emsp;&emsp;何时使用`extends`，何时使用`super`？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。  
&emsp;&emsp;即：如果需要返回`T`，它是生产者（Producer），要使用`extends`通配符；如果需要写入`T`，它是消费者（Consumer），要使用`super`通配符。  
&emsp;&emsp;还是以`Collections`的`copy()`方法为例：  
```java
public class Collections {
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (int i=0; i<src.size(); i++) {
            T t = src.get(i); // src是producer
            dest.add(t); // dest是consumer
        }
    }
}
```
&emsp;&emsp;需要返回`T`的`src`是生产者，因此声明为`List<? extends T>`，需要写入`T`的`dest`是消费者，因此声明为`List<? super T>`。  
### 无限定通配符
&emsp;&emsp;我们已经讨论了`<? extends T>`和`<? super T>`作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个`?`：  
```java
void sample(Pair<?> p) {
}
```
&emsp;&emsp;因为`<?>`通配符既没有`extends`，也没有`super`，因此：  
- 不允许调用`set(T)`方法并传入引用（`null`除外）；
- 不允许调用`T get()`方法并获取`T`引用（只能获取`Object`引用）。

&emsp;&emsp;换句话说，既不能读，也不能写，那只能做一些`null`判断：  
```java
static boolean isNull(Pair<?> p) {
    return p.getFirst() == null || p.getLast() == null;
}
```
&emsp;&emsp;大多数情况下，可以引入泛型参数`<T>`消除`<?>`通配符：  
```java
static <T> boolean isNull(Pair<T> p) {
    return p.getFirst() == null || p.getLast() == null;
}
```
&emsp;&emsp;`<?>`通配符有一个独特的特点，就是：`Pair<?>`是所有`Pair<T>`的超类：  
```java
public class Main {
    public static void main(String[] args) {
        Pair<Integer> p = new Pair<>(123, 456);
        Pair<?> p2 = p; // 安全地向上转型
        System.out.println(p2.getFirst() + ", " + p2.getLast());
    }
}
class Pair<T> {
    private T first;
    private T last;
    public Pair(T first, T last) {
        this.first = first;
        this.last = last;
    }
    public T getFirst() {
        return first;
    }
    public T getLast() {
        return last;
    }
    public void setFirst(T first) {
        this.first = first;
    }
    public void setLast(T last) {
        this.last = last;
    }
}
```
&emsp;&emsp;上述代码是可以正常编译运行的，因为`Pair<Integer>`是`Pair<?>`的子类，可以安全地向上转型。  
### 小结
&emsp;&emsp;使用类似`<? super Integer>`通配符作为方法参数时表示：  
- 方法内部可以调用传入`Integer`引用的方法，例如：`obj.setFirst(Integer n);`；
- 方法内部无法调用获取`Integer`引用的方法（`Object`除外），例如：`Integer n = obj.getFirst();`。

&emsp;&emsp;即使用`super`通配符表示只能写不能读。  
&emsp;&emsp;使用`extends`和`super`通配符要遵循PECS原则。  
&emsp;&emsp;无限定通配符`<?>`很少使用，可以用`<T>`替换，同时它是所有`<T>`类型的超类。  
&emsp;&emsp;其实PECS原因就是java向上转型安全，而向下转型不安全  

## 泛型和反射
&emsp;&emsp;Java的部分反射API也是泛型。例如：`Class<T>`就是泛型：  
```java
// compile warning:
Class clazz = String.class;
String str = (String) clazz.newInstance();
// no warning:
Class<String> clazz = String.class;
String str = clazz.newInstance();
```
&emsp;&emsp;调用`Class`的`getSuperclass()`方法返回的`Class`类型是`Class<? super T>`：  
```java
Class<? super String> sup = String.class.getSuperclass();
```
&emsp;&emsp;构造方法`Constructor<T>`也是泛型：  
```java
Class<Integer> clazz = Integer.class;
Constructor<Integer> cons = clazz.getConstructor(int.class);
Integer i = cons.newInstance(123);
```
&emsp;&emsp;我们可以声明带泛型的数组，但不能用`new`操作符创建带泛型的数组：  
```java
Pair<String>[] ps = null; // ok
Pair<String>[] ps = new Pair<String>[2]; // compile error!
```
&emsp;&emsp;必须通过强制转型实现带泛型的数组：  
```java
@SuppressWarnings("unchecked")
Pair<String>[] ps = (Pair<String>[]) new Pair[2];
```
&emsp;&emsp;使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量`ps`，因为它的类型是泛型数组。但是，编译器不会检查变量`arr`，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作`arr`可能导致从`ps`获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：  
```java
Pair[] arr = new Pair[2];
Pair<String>[] ps = (Pair<String>[]) arr;
ps[0] = new Pair<String>("a", "b");
arr[1] = new Pair<Integer>(1, 2);
// ClassCastException:
Pair<String> p = ps[1];
String s = p.getFirst();
```

&emsp;&emsp;要安全地使用泛型数组，必须扔掉`arr`的引用：  
```java
@SuppressWarnings("unchecked")
Pair<String>[] ps = (Pair<String>[]) new Pair[2];
```
&emsp;&emsp;上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组`ps`进行操作，这种操作就是安全的。  
&emsp;&emsp;带泛型的数组实际上是编译器的类型擦除：  
```java
Pair[] arr = new Pair[2];
Pair<String>[] ps = (Pair<String>[]) arr;
System.out.println(ps.getClass() == Pair[].class); // true
String s1 = (String) arr[0].getFirst();
String s2 = ps[0].getFirst();
```
&emsp;&emsp;所以我们不能直接创建泛型数组`T[]`，因为擦拭后代码变为`Object[]`：  
```java
// compile error:
public class Abc<T> {
    T[] createArray() {
        return new T[5];
    }
}
```
&emsp;&emsp;必须借助`Class<T>`来创建泛型数组：  
```java
T[] createArray(Class<T> cls) {
    return (T[]) Array.newInstance(cls, 5);
}
```
&emsp;&emsp;我们还可以利用可变参数创建泛型数组`T[]`：  
```java
public class ArrayHelper {
    @SafeVarargs
    static <T> T[] asArray(T... objs) {
        return objs;
    }
}
String[] ss = ArrayHelper.asArray("a", "b", "c");
Integer[] ns = ArrayHelper.asArray(1, 2, 3);
```
### 谨慎使用泛型可变参数
&emsp;&emsp;在上面的例子中，我们看到，通过：  
```java
static <T> T[] asArray(T... objs) {
    return objs;
}
```
&emsp;&emsp;似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：  
```java
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        String[] arr = asArray("one", "two", "three");
        System.out.println(Arrays.toString(arr));
        // ClassCastException:
        String[] firstTwo = pickTwo("one", "two", "three");
        System.out.println(Arrays.toString(firstTwo));
    }
    static <K> K[] pickTwo(K k1, K k2, K k3) {
        return asArray(k1, k2);
    }
    static <T> T[] asArray(T... objs) {
        return objs;
    }
}
```

&emsp;&emsp;直接调用`asArray(T...)`似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生`ClassCastException`，原因还是因为擦拭法，在`pickTwo()`方法内部，编译器无法检测`K[]`的正确类型，因此返回了`Object[]`。  
&emsp;&emsp;如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用`@SafeVarargs`消除警告。  
&emsp;&emsp;如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。  
&emsp;&emsp;更详细的解释请参考《[Effective Java](https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/)》“Item 32: Combine generics and varargs judiciously”。  
### 小结
&emsp;&emsp;部分反射API是泛型，例如：`Class<T>`，`Constructor<T>`；  
&emsp;&emsp;可以声明带泛型的数组，但不能直接创建带泛型的数组，必须强制转型；  
&emsp;&emsp;可以通过`Array.newInstance(Class<T>, int)`创建`T[]`数组，需要强制转型；  
同时使用泛型和可变参数时需要特别小心。
