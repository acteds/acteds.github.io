---
layout: post
title: 批处理batch重点知识1.基础
categories: [windows, batch]
description: 批处理重点知识笔记
keywords: windows, batch
---
# 引言  
本篇文章介绍批处理的基础  


# 特性  
- **<font color="red">对于文件路径引用请加""不然有空格会出错，文件或文件夹请勿用特殊符号()空格等</font>**  
- 批处理命令的关键字不区分大小写  
- 在`.bat`或`.cmd`文件里写批处理命令,并双击执行,若出错或没有在末尾写**pause**命令,则在执行完成后会自动关闭控制台窗口. 
- **<font color='red'>在命令行窗口和批处理文件中`%`的写法略有差异：</font>**  
  - 在命令行窗口中，只需要一个百分号:%.  
  - 在批处理文件中，需要连续两个百分号:%%。 
- 注意在批处理文件保存时使用GBK编码,否则会导致中文乱码.  

# 控制台  
* **窗口半透明**: 在Win10中，CMD窗口支持半透明设计，可以通过手工设置或按下`Ctrl`+`Shift`+`加号/减号`实时调整透明度，方便编写代码查看底下效果。  
* **切换全屏**: Win10中的CMD可以点击右上角按钮或按下`Alt`+`回车`全屏，解决了以前只能半屏显示的问题。  
* **查阅命令历史**: 在CMD中按上、下箭头键调用之前执行过的命令，也可以按下`F7`查看并执行历史命令。  
* **拖拽文件夹快速输入路径**: 将文件夹拖入CMD窗口中，目标路径会自动出现在当前光标后，简化了输入长路径的步骤。  
* **预测补全**: 在CMD中按`Tab`键可以自动补全命令符后面的内容，多按几下`Tab`键CMD会提取当前路径下的文件或文件夹名称补入光标位置。  
* **Ctrl+C/V**: Win10的CMD支持`Ctrl`+`C`和`Ctrl`+`V`复制粘贴，也可以用鼠标右键快速粘贴剪贴板内容。  
* **搜索文本**: Win10的CMD新增了文本搜索功能，可以在输入过程中或输出完后任意搜索想要的内容，通过右击点搜索或按Ctrl+F实现，非常方便。  


# 显示内容 echo
显示内容到控制台:  
```batch
echo 文字或者变量
```
在当前脚本不显示执行语句:	  
```batch
echo off
```
在当前脚本显示执行语句:	  
```batch
echo on
```
在当前脚本不显示执行语句,同时使用`@`不显示本条执行语句:  	  
```batch
@echo off
```
空行输出:  
```batch
@echo off 

echo= 
echo, 
echo; 

echo+ 
echo/ 
echo[ 
echo] 

echo: 
echo. 
echo\
pause
```
这十种方法可以分为三组，每组的效率依次递减。[一般情况下使用第一组,它们的效率最高](http://demon.tw/reverse/cmd-internal-echo.html).  
# 注释  
在批处理中常见的注释形式：  

- **行注释**：使用 `rem` 关键字可以添加行注释，`rem` 后面的内容将被解释器忽略。
```batch
rem 注释内容
```
- **段注释**：通过在标签之前添加冒号 `:` 可以实现段注释，段注释可以跨越多行，并且可以包含命令和特殊字符，只要不包含与标签重名的标签行即可。
```batch
 goto start
  = 可以是多行文本，可以是命令
  = 可以包含重定向符号和其他特殊字符
  = 只要不包含:start这一行，就都是注释
 :start
```
- **其他注释形式**：
  - `::` 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）。
  - `echo` 注释内容（不能出现重定向符号和管道符号）`>nul`。
  - `if not exist nul` 注释内容（不能出现重定向符号和管道符号）。
  - `:注释内容`（注释文本不能与已有标签重名）。
  - `%注释内容%`（可以用作行间注释，不能出现重定向符号和管道符号）。
  - `goto 标签` 注释内容（可以用作说明 `goto` 的条件和执行内容）。
  - `:标签` 注释内容（可以用作标签下方段的执行内容）。


# 变量扩展  
在批处理脚本中，`%1` 和 `%2` 是用来表示传递给脚本的参数的变量。`%1` 表示第一个参数,`%2` 表示第二个参数。`%0`表示批处理脚本自己的变量。如果有更多传入参数,则以此类推。这些参数可以在执行脚本时通过命令行或拖动执行,传递给脚本，例如：  
```batch
myscript.bat arg1 arg2
```
`arg1` 将会被存储在 `%1` 中，`arg2` 将会被存储在 `%2` 中。  

## 与%1相关的变量扩展  :  

 变量扩展        | 说明                                                                                                              
-------------|-----------------------------------------------------------------------------------------------------------------
 %~1         | 删除引号 `"`，扩展 **%1**<br>1. 若字符串首尾同时存在引号，则删除首尾的引号；<br>2. 若字符串尾不存在引号，则删除字符串首的引号；<br>3. 如果字符串中间存在引号，或者只在尾部存在引号，则不删除。 
 %~f1        | 将 **%1**扩展到一个完全合格的路径名                                                                                           
 %~d1        | 将 **%1**扩展到一个驱动器号                                                                                               
 %~p1        | 将 **%1**扩展到一个路径                                                                                                 
 %~n1        | 将 **%1**扩展到一个文件名                                                                                                
 %~x1        | 将 **%1**扩展到一个文件扩展名                                                                                              
 %~s1        | 将 **%1**扩展到一个含有短名的路径                                                                                            
 %~a1        | 将 **%1**扩展到文件属性                                                                                                 
 %~t1        | 将 **%1**扩展到文件的日期/时间                                                                                             
 %~z1        | 将 **%1**扩展到文件的大小                                                                                                
 %~$PATH:1   | 在 **PATH** 环境变量目录里查找指定文件 **%1**,并将 **%1**扩展到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，那么会扩展为空字符串。                      
 %~dp1       | 将 **%1** 扩展到驱动器号和路径                                                                                             
 %~nx1       | 将 **%1** 扩展到文件名和扩展名                                                                                             
 %~dp$PATH:1 | 在 **PATH** 环境变量目录里查找指定文件 **%1**，并扩展到找到的第一个文件的驱动器号和路径。                                                           
 %~ftza1     | 将 **%1** 扩展到类似 DIR 的输出行。                                                                                        


## 与%VAR%相关的变量扩展  :

 变量扩展            | 说明                                                                                                      
-----------------|---------------------------------------------------------------------------------------------------------
 %VAR:str1=str2% | 将**VAR**中的**str1**替换为**str2**<br/>**str2**如果为空则可以达到删除的效果,**str1**前可以加'*'号匹配任意字符,例子:`%ABC:*B=%`的执行结果是`C` 
 %VAR:~0,-2%     | 提取**VAR** 变量除了最后两个字符的所有字符                                                                               
 %VAR:~2%        | 提取**VAR** 变量的除前两个的所有字符                                                                                  
 %VAR:~-2%       | 提取**VAR** 变量的最后两个                                                                                       
 %VAR:~2,5%      | 提取从第2个字符开始的5个字符                                                                                         

## 动态变量  :  
还有几个动态变量，运行 `set`命令是看不到的:  

 变量扩展|说明                  
-------------|-------------------
 %CD%             | 代表当前目录的字符串
 %DATE%           | 当前日期
 %TIME%           | 当前时间
 %RANDOM%         | 随机整数，介于0~32767
 %ERRORLEVEL%     | 当前 ERRORLEVEL 值
 %CMDEXTVERSION%  | 当前命令处理器扩展名版本号
 %CMDCMDLINE%     | 调用命令处理器的原始命令行

用`echo`命令可以查看每个变量值，如`echo %time%`,`%time%`精确到毫秒，在批处理需要延时处理时可以用到.  

# @ % %% : ::~()  
## @  :
`@` 是 Windows 命令行中的一个前缀，用于指示命令或语句在执行时不要显示在屏幕上。它通常用于隐藏命令的执行过程，使输出更清晰。例如：  
```batch
@echo off
@echo Hello, World!
```
`@echo off` 会关闭命令的回显，而 `@echo Hello, World!` 则会输出 "Hello, World!"，但不会显示 `echo` 命令本身。`@` 仅影响紧随其后的命令或语句，不会影响之前或之后的命令或语句。  

## %、%%  :  

- **变量引用**：在批处理中,当百分号成对出现，并且其间包含非特殊字符时，一般做变量引用处理。例如，`%var%` 表示引用名为 `var` 的变量的值。

- **形式参数引用**：`%` 也用于引用传递给批处理脚本的参数。形式参数以 `%0`、`%1`、`%2` 等形式表示，其中 `%0` 表示脚本自身的名称，`%1` 表示第一个参数，`%2` 表示第二个参数，以此类推。如果参数超过了 `%9`，则需要使用 `%*` 来表示所有参数。

- **赋予参数**：在调用批处理脚本时，参数和参数之间用逗号或空格隔开。例如，`myscript.bat param1 param2`，其中 `param1` 和 `param2` 就是传递给脚本的参数。

- **模运算**：在 `set /a` 语句中，`%` 用于表示两数相除取余数，即模运算。

- **百分号在命令行窗口和批处理文件中的写法**：在命令行窗口中，只需要一个百分号 `%`；在批处理文件中，需要连续两个百分号 `%%`。这是因为在批处理文件中，单个百分号被用作变量引用的标识符，因此需要使用两个百分号来表示一个实际的百分号字符。

## :、::  
`:` 用于定义标签，而 `::` 用于添加注释。在 `set` 语句中，`:` 还可以用于截取或替换字符串。  
- `:` 表示一个标签，用于标识批处理文件中的位置。例如，`:label` 表示一个名为 `label` 的标签，可以在脚本中使用 `goto label` 或 `call :label` 跳转到该标签处或调用该子过程。
- `::` 表示一个注释，用于在脚本中添加注释内容。`::` 后面的内容会被解释器忽略，不会执行。与 `rem` 命令相比，`::` 的注释更为清晰，因为它不会受到特殊字符的影响，而 `rem` 命令中的某些特殊字符可能会被解释。
- 在 `set` 语句中，当 `:` 和 `~` 同时使用时，`:` 表示截取字符串的功能。例如，`set var=%str:~0,1%` 表示截取变量 `str` 的第一个字符。当 `:` 和 `=` 同时使用时，`:` 起到替换字符串的功能。例如，`set var=%str:a=1%` 表示将变量 `str` 中的字符 `a` 替换为 `1`。  

## ~  
- 在 `set` 语句中，和 `:` 同时使用时，用于截取字符串的功能。例如，`set var=%str:~0,1%` 表示截取变量 `str` 的第一个字符。
- 在 `set /a` 语句中，`~` 是一元运算符号，表示将操作数字按位取反。例如，`set /a num=~1` 的执行结果是 `-2`，`set /a num=~0` 的结果是 `-1`。
- 在 `%1`、`for` 循环中的变量 `%a` 等中使用时，具体效果取决于上下文，通常是用于变量扩展。例如，在 `for` 循环中，`%~a` 可以获取 `%a` 的扩展属性。

## ()
() 用作代码块的起始和结束标志，用来执行多条语句作为一个整体，一般在`for`和`if`中用的比较多.示例:  
```batch
@echo off
set /a a=123
if not %a% == 123 (
	echo 不是123
) else (
	echo 是123
)
pause
```

# set  
`set`用来声明变量  
语法:  
```batch
SET [variable=[string]]
```
注意:SET命令不允许变量名称含有等号.  

## 一般用法:  
**设置变量**  

格式：`set 变量名=变量值`;被设定的变量以%变量名%引用  

**取消变量**  

格式：`set 变量名=`;取消后的变量若被引用%变量名%将为空  

**展示变量**  

格式：`set 变量名`;展示以变量名开头的所有变量的值  

**列出所有可用的变量**  

格式：`set`  

**设定数值型变量**(用 /a 参数时，在=后面的变量可以不加%直接引用)  
```batch
@echo off
set /a a=1+2*3
echo %a%
set /a a=a+a
echo %a%
pause
```
## set /p:
`set /p` 命令用于接受用户输入并将输入的内容赋值给变量。以下是一些示例用法：  

- **基本用法**：在控制台显示提示信息，然后接受用户输入赋值给变量 `a`。
  ```batch
  set /p a=请输入值
  ```

- **从文件中读取**：显示自定义的提示信息，然后将文件 `1.txt` 中的内容赋值给变量 `a`，通常表现为文件的第一行内容。
  ```batch
  set /p a=promptstring<1.txt
  ```

- **从空设备中读取**：显示自定义的提示信息，然后将空设备 `nul` 中的内容赋值给变量 `a`，实际上不会有内容被赋值，变量 `a` 保持未定义状态。
  ```batch
  set /p a=promptstring<nul
  ```

- **空变量**：显示自定义的提示信息，但不会将任何内容赋值给变量，仅作为显示之用。需要用户按回车键结束语句。
  ```batch
  set /p =promptstring
  ```

# call  
`call`命令用来从一个批处理脚本中调用另一个批处理脚本  
语法:  
```batch
call [ [Drive:] [Path] FileName [BatchParameters]] [:label [arguments]]  
```
参数:  
- **[Drive:][Path] FileName** 指定要调用的批处理程序的位置和名称。  
- **Filename** 参数必须是.bat 或 .cmd 扩展名的类型文件。  
- **BatchParameters** 指定批处理程序所需的命令行信息（即参数项）。  

使用`call`调用另一个批处理程序，不会终止父批处理程序。如果不用`call`而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件执行后续命令。  

`call` 命令可以在同一个批处理脚本中的不同部分之间进行跳转调用。  

在脚本或批处理文件外使用`call`没有作用，它不会在命令行起作用。  

`call`调用类似于函数调用的执行逻辑。  

调用标签:  

```batch
@echo off
call :label
echo 1
echo 2
:label
echo 3
echo 4
```
结果：  
```
3
4
请按任意键继续. . .
1
2
3
4
请按任意键继续. . .
```

`call`调用标签时也可以带参数:  
```batch
@echo off
call :loop Hello World!
pause>nul & goto :eof
:loop
echo %1
echo %2
:eof
exit
```
结果:
```
Hello
World!
```

# start
对于start概括两句话：“不同进程不能传值”，“相同进程单向传值，父传子”。  

对于call，“同一进程，变量互通”。（进程参数不能引用）  

**`start`与`call`命令的区别**：  

**调用范围不同**：`call`主要用来进行批处理的内部调用，如`call :pend` 和一些dos命令的调用如`call set test=2`，但也可以调用其他可执行文件。而`start`则不能进行内部调用，但其可以执行基本上所有的外部程序，还可以执行shell，如打开文件夹`start "" "%WINDIR%"`，安装网络打印机`start "" "\\IP\Printer"`等等。  

**调用方式不同**：`call`是严格意义上的调用，在`call`另一个批处理时是在同一窗体进程里执行。而start执行时则是在不同的窗口进程里执行的，使用 `start /b` 可以在后台执行程序，但其结果与前台执行不同。  

如:`call set test=2` 和 `start /b set test=2` 执行的结果相同，但后者有两个进程，且在窗口里要执行两次exit才能退出，因此使用`start`执行的批处理文件最好在最后写上`exit`，否则无法退出被调用的批处理的dos窗口。被`call`调用的批处理文件中如果存在`exit`则会直接结束原始调用的批处理程序。因此与`start`相反,不要使用`exit`退出,可以使用`goto :eof`来取代`exit`。  

**调用结果不同**：`call` 可以传递参数或变量给被调用的批处理，并且被调用的批处理也可以设置参数或变量以回传。而 `start` 只能传递参数或变量给被调用的批处理，无法回传参数或变量。  

**注意事项**：使用 `call` 调用其他批处理时，要注意使用不同的标签名来跳转，以避免跳转到原批处理中而导致执行不完整。  

# goto

在批处理中，`goto` 语句用于无条件地跳转到脚本中的指定标签处。标签是一个以冒号开头的标识符，用于标记脚本中的某一行。`goto` 语句的基本语法如下：  

```batch
goto label
```

`label` 是要跳转到的标签。例如：  

```batch
@echo off
echo Before the goto.
goto mylabel
echo This line will be skipped.
:mylabel
echo After the goto.
```

在上面的例子中，`goto mylabel` 会跳转到标签 `:mylabel` 处，执行标签处的命令。因此，输出将会是：  

```text
Before the goto.
After the goto.
```

需要注意的是，`goto` 语句是一个无条件跳转，会直接跳转到指定的标签处，而不会执行跳转语句之后的代码。如果要在条件满足时执行跳转，可以结合 `if` 语句使用。  

# &|&&||
## & 连接符
命令格式 :  
```batch
[...] command1 & command2
```
用来分隔一个命令行中的多个命令。cmd.exe 先运行第一个命令，然后运行第二个命令。  
```batch
echo 123&echo 456
```
## && 
命令格式:  
```batch
[...] command1 && command2 
```
只有在符号`&&`前面的命令执行成功时，才会执行该符号后面的命令。  
```batch 
cd 123&&echo 已进入123文件夹
```
## ||
命令格式:  
```batch
[...] command1 || command2
```
只有在符号`||`前面的命令执行失败时，才会执行符号`||`后面的命令。  
```batch
cd 123||echo 无法进入123文件夹
```
## | 管道符
命令格式:  
```batch
command1|command2
```
让前一命令的输出当做后一命令的输入  
```batch
help|more
```

# ><>>
使用重定向符号可以将输出结果保存到文件中。  

说明|数字
-----|-----
标准输入（stdin）    | 0
标准输出（stdout）   | 1
标准错误输出（stderr） | 2

`>`符号和`>>`符号为两个常用的重定向符号。  
`>`会将原始文件的内容清空，而`>>`会在文件后面追加内容，如果文件不存在则都会创建文件。  
```batch  
echo Hello World >file.txt
```
运行后，会将`Hello World`输出到`file.txt`中  
上述代码等价于下面的代码：  
```batch 
echo Hello World 1>file.txt
```

其中`1`的意思是代表将标准输出重定向，标准输出即正常的输出内容。  
而`2>file.txt`则代表将错误信息输出到`file.txt`中，这样`Hello World`会显示在屏幕上，只有报错的信息会保存在`file.txt`中  
```batch
echo Hello World >>file.txt
```
上面的语句使用了2个>，表示追加内容，如果`file.txt`内容不是空，则`Hello World`会在最后一行的后面另起一行保存。  

对于`<`符号,是这样使用的:  
```batch
set /p a=promptstring<1.txt
```
先显示`promptstring`，再把"<"管道号右边的1.txt文件中从第一个字符开始直到碰到回车符的内容赋值给变量a（通常表现为第一行）。  

0的使用(输入):输入0代表标准输入(stdin)，可以用来重定向输入。  
```batch
echo 123>a.txt
0<a.txt set /p a=123?
echo %a%
pause
```
将标准错误输出重定向到标准输出，并将输出结果丢弃:  
```batch
>nul 2>&1
```

`2>&1`是将标准错误输出重定向到标准输出,符号`>&`是一个整体，不可分开，分开后就不是上述含义了。  

比如有些人可能会这么想：`2`是标准错误输入，`1`是标准输出，`>`是重定向符号，那么”将标准错误输出重定向到标准输出”是不是就应该写成`2>1`就行了？这么做实际上是:将标准错误输出重定向到名为`1`的文件里去了  

在批处理中写成`2&>1`也是不可以的  

<details close>
  <summary>以下简写在批处理中是无法使用的:</summary>
  每次都写”1>nul 2>&1”太麻烦，能简写吗？有两种简写方式:`&>nul`,`>&nul`<br/>  
  上面两种方式都和”1>nul 2>&1”一个语义。<br/>  
  `&>`和`>&`语义上是没有任何区别的，但是第一中方式是最佳选择，一般使用第一种<br/>  
</details>
































