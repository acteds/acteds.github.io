# GUI

`JFrame`  
**构造方法**  

| 方法                                           | 说明                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| JFrame()                                       | 构造一个初始时不可见的新窗体。                               |
| JFrame(GraphicsConfiguration gc)               | 以屏幕设备的指定 GraphicsConfiguration 和空白标题创建一个 Frame。 |
| JFrame(String title)                           | 创建一个新的、初始不可见的、具有指定标题的 Frame。           |
| JFrame(String title, GraphicsConfiguration gc) | 创建一个具有指定标题和指定屏幕设备的 GraphicsConfiguration 的 JFrame。 |

**常用方法**  

| 方法                                    | 说明                                   |
| --------------------------------------- | -------------------------------------- |
| add()                                   | 将组件添加到窗口                       |
| is/setVisible()                         | 获取/设置窗体的可视状态。              |
| get/setTitle()                          | 获取/设置窗体的标题。                  |
| get/setState()                          | 获取/设置窗体的的最小化,最大化等状态。 |
| get/setLocation()                       | 获取/设置窗体在屏幕上应当出现的位置。  |
| get/setSize()                           | 获取/设置窗体的大小。                  |
| setDefaultCloseOperation(int operation) | 设置单击窗体上的关闭按钮时的默认操作。 |
| getContentPane()                        | 获取窗体的内容面板                     |

`setDefaultCloseOperation`  
`public void setDefaultCloseOperation(int operation)`  
设置用户在此窗体上发起"`close`"时默认执行的操作。必须指定以下选项之一：  
值依次为`0-3`  
`DO_NOTHING_ON_CLOSE`(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 `WindowListener` 对象的 `windowClosing` 方法中处理该操作。  
`HIDE_ON_CLOSE`(在 `WindowConstants` 中定义)：调用任意已注册的 `WindowListener` 对象后自动隐藏该窗体。  
`DISPOSE_ON_CLOSE`(在 `WindowConstants` 中定义)：调用任意已注册 `WindowListener` 的对象后自动隐藏并释放该窗体。  
`EXIT_ON_CLOSE`(在 `JFrame` 中定义)：使用 `System exit` 方法退出应用程序。仅在应用程序中使用。  
默认情况下,该值被设置为 `HIDE_ON_CLOSE`。更改此属性的值将导致激发属性更改事件,其属性名称为 "`defaultCloseOperation`"。  
注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机**可能**会终止。  
`frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);`  

# 网络

常见服务和对应端口号  

| 端口 | 对应服务   |
| ---- | ---------- |
| 7    | Echo服务器 |
| 21   | Ftp        |
| 23   | telnet     |
| 25   | SMTP       |
| 79   | Finger     |
| 80   | HTTP       |

## URL类

| 构造方法                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| public URL(String spec);                                     | URL u1 =new URL("http://home.netscape.com/home/");           |
| public URL(URL context, String spec);                        | URL u2=new URL(u1, "welcome.html");                          |
| public URL(String protocol, String host, String file);       | URL u3=new URL("http", "www.sun.com",developers/index.html"); |
| public URL (String protocol, String host, int port, String file) | URL u4 = new URL("http", "www.sun.com", 80,"developers/index.html" ); |

## URLConnection类

`Uonnection`类支持`URL`连接的输入/输出流方式的通信,并可以获得`URL`对象资源的相关信息。它是所有应用程序和`URL`连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。  
常用的成员方法：  

| 方法                                 | 说明                           |
| ------------------------------------ | ------------------------------ |
| void setUseCaches(boolean uescaches) | 设置是否允许使用高速缓冲存储器 |
| object getContent()                  | 获取当前URL连接的信息内容      |
| String getContentType()              | 返回连接类型的头域值           |
| int getContentLength()               | 返回当前连接长度的头域值       |
| long getDate()                       | 返回当前日期头域值             |
| long getLastModified()               | 返回最后修改时间头域值         |
| inputStream getInputStream()         | 返回连接的输入济               |
| outputStream getOutputStream()       | 返回连接的输出流               |

将baidu内容重定向到Demo.txt  

```java
package com.aotmd.test;  
import java.io.*;  
import java.net.URL;  
import java.net.URLConnection;  
import java.util.StringTokenizer;  
public class NoteTest {  
    public static void main(String[] args) throws IOException {  
        FileOutputStream fos = null;  
        PrintStream ps = null;  
        try {  
            fos = new FileOutputStream("Demo.txt", true);//建立一个文件输出流,并将它的append标记设置为true  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
        ps = new PrintStream(fos);// 建立一个PrintStream对象,它将作为标准输出流  
        System.setOut(ps);//将标准输出定向到PrintStream对象  
        URLConnection conn = null;  
        String nextLine = null;  
        StringTokenizer tokenizer = null;  
        URL url2 = new URL("http://www.baidu.com");  
        conn = url2.openConnection();  
        conn.setDoOutput(true);  
        conn.connect();  
        BufferedReader Reader1 = new BufferedReader(new InputStreamReader(conn.getInputStream()));  
        while ((nextLine = Reader1.readLine()) != null)  
            tokenizer = new StringTokenizer(nextLine);  
        while (tokenizer.hasMoreTokens()) {  
            String urlToken = tokenizer.nextToken();  
            System.out.println(urlToken);  
        }  
    }  
}
```

## Socket概念

两个Java应用程序可通过一个双向的网络通信连接实现**数据交换**,这个双向链路的一端称为一个`socket`.`socket`通常用来实现`client-server`连接。java.net包中定义的两个类`Socket`和`ServerSocket`,分别用来实现双向连接的`client`和`server`端.  
套接字(`Socket`)：表示一个系统的IP地址和端口号的结合。  
`TCP/IP`连接的一个端点用来处理两个流对象  
创建`TCP Socket`需要的四个信息：本地系统的`IP`本地应用程序使用的`TCP`端口号远程系统的`IP`远程应用程序相应的`TCP`端口号  

## Socket类

**Socket类构造器**  

> `Socket()`  
> `Socket(InetAddress address,int port)`  
> `Socket(InetAddress address,int port,InetAddress localAddr,int localPort)`  
> `Socket(String host,int port)`  
> `protected Socket(Socketlmpl impl)`  
> `Socket(String host,int port,InetAddress localAddr,int localPort)`  
> `Socket(InetAddress address, int port)`  
> `Socket(InetAddress address, int port,boolean stream);`  
> `Socket(String host, int port);`  
> `Socket(String host, int port, boolean stream);`  
> `ServerSocket(int port);`  
> `ServerSocket(int port, int count);`  

`Socket方法`  

> `getlnputStream()`  
> `getOutputStream()`  
> `close()`  

## ServerSocket类

ServerSocket类用于侦听一个客户端的Socket连接,如果没有连接,它将一直等待。  
**ServerSocket构造器**  

| 构造方法                                                 | 说明                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| ServerSocket(int port)                                   | 用指定的端口`port`来创建一个侦听`Socket`                     |
| ServerSocket(int port,int backlog)                       | 加上一个用来改变连接队列长度的参数`backlog`.                 |
| ServerSocket(int port,int backlog,lnetAddress localAddr) | 在机器存在多个`IP`地址的情况下,允许通过`localAddr`这个参数来指定侦听的`IP`地址。 |

**ServerSocket方法**  
`Socket accept()`  
`close()`  

## 示例

服务端程序编写  

1.  调用`ServerSocket(int port)`创建一个服务端套接字，并绑定到指定端口上；
2.  调用`socket`类的`getOutputStream()`和`getlnputStream()`获取输入流和输出流
3.  关闭`socket`；

客户端程序编写  

1.  调用`Socket()`创建流套接字，并链接到服务端；
2.  调用`accept()`监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；
3.  调用`socket`类的`getOutputStream()`和`getInputStream()`获取输入流和输出流；
4.  关闭`socket`；

客户端Socket的建立  

```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings({"unused", "resource"})  
            Socket socket = new Socket("127.0.0.1", 2000);  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```

服务器端Socket的建立  

```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        ServerSocket server = null;  
        try {  
            server = new ServerSocket(2000);  
        } catch (IOException e) {  
            System.out.println("can not listen to :" + e);  
        }  
        Socket socket = null;  
        try {  
            socket = server.accept();  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```

打开输入/出流  

```java
PrintStream os = new PrintStream(new BufferedOutputStream(socket.getOutputStream());  
DataInputStream is = new DataInputStream(socket.getInputStream());
```

关闭Socket  

```java
os.close();is.close();socket.close();
```

简单的`client`/`server`程序  

```java
package com.aotmd.test;  
import java.io.*;  
import java.net.ConnectException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings("resource")  
            ServerSocket s = new ServerSocket(8888);  
            while (true) {  
                Socket s1 = s.accept();  
                OutputStream os = s1.getOutputStream();  
                DataOutputStream dos = new DataOutputStream(os);  
                dos.writeUTF("Hello," + s1.getInetAddress() + "port#" + s1.getPort() + "bye-bye!");  
                dos.close();  
                s1.close();  
                // s.close();  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        try {  
            Socket s1 = new Socket("127.0.0.1", 8888);  
            InputStream is =s1.getInputStream();  
            DataInputStream dis = new DataInputStream(is);  
            System.out.println(dis.readUTF());  
            dis.close();  
            s1.close();  
        } catch (ConnectException connExc) {  
            System.err.println("服务器连接失败！");  
        } catch (IOException e) {  
        }  
    }  
}
```

先运行服务器,然后运行客户端,会收到服务器发的信息.  
例子二  

```java
package com.aotmd.test;  
import java.io.BufferedReader;  
import java.io.IOException;  
import java.io.InputStreamReader;  
import java.io.PrintStream;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        ServerSocket server;  
        try {  
            server = new ServerSocket(1234);  
            Socket sk = server.accept();  
            BufferedReader br = new BufferedReader(new InputStreamReader(sk.getInputStream()));  
            System.out.println(br.readLine());  
            br.close();  
            server.close();  
        } catch (IOException e) {  
            System.out.println(e);  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        Socket client;  
        PrintStream ps;  
        try {  
            client = new Socket("localhost", 1234);  
            System.out.println("连接成功！");  
            ps = new PrintStream(client.getOutputStream());  
            ps.println("客户端回显的对话");  
            client.close();  
        } catch (IOException e) {  
            System.out.println(e);  
        }  
    }  
}
```

## URL与Socket通信的区别

利用`URL`进行通信与利用`socket`进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：  
利用`socket`进行通信时，在服务器端运行一个`socket`通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在`socket`通信方式中，服务器是主动等待连接通信的到来。  
利用`URL`进行通信时，在服务器端常驻一个`CGI`程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在`URL`通信方式中，服务器是被动等待连接通信的到来。  

## UDP通信

在基于`TCP/IP`网络体系结构的网络中主要使用`TCP`和`UDP`（`UserDatagramProtocol`，用户数据报协议）来实现数据通信。`TCP`是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而`UDP`则是一种面向无连接的不可靠传输协议，它**不能**确保数据能正确到达目的端，但是它能提高网络通信的效率。  
**UDP Socket特性**  
通过UDP的UDP端口来实现UDP协议的网络通信。  
其工作过程如下：  
创建一个适当的要发送且注明收发人地址数据报；  
为一个特定的应用程序建立一个传输端口来传送和接收数据包；  
将数据报插入一个传输端口中进行传输；  
等待接收来自于传输端口的一个数据报；  
解码数据报以解开消息、接收者和其它信息；  
**Java UDP类**  
`DatagramSocket`  
用于接收和发送`UDP`的`Socket`实例。该类有3个构造函数：  
`DatagramSocket()`：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）  
`DatagramSocket(int port)`：创建实例，并固定监听`Port`端口的报文。通常用于服务端  
`DatagramSocket(int port,InetAddress localAddr)`：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自`LocalAddr`的报文。  