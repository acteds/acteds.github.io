

# 引言
一些零散的笔记。


# XML

XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。

例如，一个描述书籍的XML文档可能如下：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE note SYSTEM "book.dtd">
<book id="1">
    <name>Java核心技术</name>
    <author>Cay S. Horstmann</author>
    <isbn lang="CN">1234567</isbn>
    <tags>
        <tag>Java</tag>
        <tag>Network</tag>
    </tags>
    <pubDate/>
</book>
```

XML有几个特点：一是纯文本，默认使用UTF-8编码，二是可嵌套，适合表示结构化数据。如果把XML内容存为文件，那么它就是一个XML文件，例如`book.xml`。此外，XML内容经常通过网络作为消息传输。

XML有固定的结构，首行必定是`<?xml version="1.0"?>`，可以加上可选的编码。紧接着，如果以类似`<!DOCTYPE note SYSTEM "book.dtd">`声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。接下来是XML的文档内容，一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，`<isbn lang="CN">1234567</isbn>`包含一个属性`lang="CN"`，且元素必须正确嵌套。如果是空元素，可以用`<tag/>`表示。

由于使用了`<`、`>`以及引号等标识符，如果内容出现了特殊符号，需要使用`&???;`表示转义。例如，`Java<tm>`必须写成：

```
<name>Java&lt;tm&gt;</name>
```

常见的特殊字符如下：

| 字符 | 表示   |
| :--- | :----- |
| <    | `&lt;`   |
| >    | `&gt;`   |
| &    | `&amp;`  |
| "    | `&quot;` |
| '    | `&apos;` |

格式正确的XML（Well Formed）可以被解析器正常读取。而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证。

DTD文档可以指定一系列规则，例如：

- 根元素必须是`book`
- `book`元素必须包含`name`，`author`等指定元素
- `isbn`元素必须包含属性`lang`
- ...

如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。

和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。

XML是一个技术体系，除了经常用到的XML文档本身外，XML还支持：

- DTD和XSD：验证XML结构和数据是否有效；
- Namespace：XML节点和属性的名字空间；
- XSLT：把XML转化为另一种文本；
- XPath：一种XML节点查询语言；
- ...



因为XML是一种树形结构的文档，它有两种标准的解析API：

- DOM：一次性读取XML，并在内存中表示为树形结构；
- SAX：以流的形式读取XML，使用事件回调。

## 使用DOM解析

DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个树形结构处理，从根节点开始，每个节点都可以包含任意个子节点。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<book id="1">
    <name>Java核心技术</name>
    <author>Cay S. Horstmann</author>
    <isbn lang="CN">1234567</isbn>
    <tags>
        <tag>Java</tag>
        <tag>Network</tag>
    </tags>
    <pubDate/>
</book>
```

`document`代表XML文档，是真正的“根”，而`<book>`虽然是根元素，但它是`document`的一个子节点。

Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：

- Document：代表整个XML文档；
- Element：代表一个XML元素；
- Attribute：代表一个元素的某个属性。

使用DOM解析一个XML文档的代码如下：

```java
package test;

import org.junit.jupiter.api.Test;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.InputStream;

public class DemoTest {
    @Test
    void testNegative() throws IOException, SAXException, ParserConfigurationException {
        // 从文件、网络流或其他来源获取 XML 输入流
        InputStream input = DemoTest.class.getResourceAsStream("book.xml");
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        // 使用 DocumentBuilder 解析输入流，获取 Document 实例
        Document doc = db.parse(input);
        printNode(doc,0);
    }
    void printNode(Node n, int indent) {
        switch (n.getNodeType()) {
            case Node.DOCUMENT_NODE: // Document节点
                System.out.println(getRetraction(indent)+"Document: " + n.getNodeName());
                break;
            case Node.ELEMENT_NODE: // 元素节点
                System.out.println(getRetraction(indent)+"Element: " + n.getNodeName());
                break;
            case Node.TEXT_NODE: // 文本
                if (n.getNodeValue().matches("\\s+")){//为空则无视
                    break;
                }
                System.out.println(getRetraction(indent)+"Text = " + n.getNodeValue());
                break;
            case Node.ATTRIBUTE_NODE: // 属性
                System.out.println(getRetraction(indent)+"Attr: " + n.getNodeName() + " = " + n.getNodeValue());
                break;

            case Node.CDATA_SECTION_NODE:// 非解析文本
                System.out.println(getRetraction(indent)+ "CDATA: " + n.getNodeValue().trim());
                break;
            case Node.COMMENT_NODE:// 注释
                System.out.println(getRetraction(indent)+ "Comment: " + n.getNodeValue().trim());
                break;
            default: // 其他
                System.out.println(getRetraction(indent)+"NodeType: " + n.getNodeType() + ", NodeName: " + n.getNodeName());
        }
        if (n.hasAttributes()) {//有属性则递归
            NamedNodeMap as = n.getAttributes();// 获取标签内所有属性
            for (int i = 0; i < as.getLength(); i++) {
                printNode(as.item(i), indent+2);// 递归
            }
        }
        if (n.hasChildNodes()) {//有子节点则递归
            NodeList childNodes = n.getChildNodes();
            for (int i = 0; i < childNodes.getLength(); i++) {
                printNode(childNodes.item(i), indent+2);// 递归
            }
        }

    }

    private static String getRetraction(int indent) {
        StringBuilder s= new StringBuilder();
        for (int i = 0; i < indent; i++) {
            s.append(" ");
        }
        return s.toString();
    }
}
```

`DocumentBuilder.parse()`用于解析一个XML，它可以接收`InputStream`，`File`或者`URL`，如果解析无误，将获得一个`Document`对象，这个对象代表了整个`XML`文档的树形结构。

从根节点`Document`出发，可以遍历所有子节点，获取所有元素、属性、文本数据，还可以包括注释，这些节点被统称为`Node`，每个`Node`都有自己的`Type`，根据`Type`来区分一个`Node`到底是元素，还是属性，还是文本，等等。

使用DOM API时，如果要读取某个元素的文本，需要访问它的Text类型的子节点，所以使用起来还是比较繁琐的，且DOM解析速度慢，内存占用大。

------

`org.w3c.dom.Document` 接口表示整个 XML 文档，它是 DOM（Document Object Model） API 的核心接口之一。`Document` 对象提供了操作 XML 文档的方法，允许您访问和修改文档中的元素、属性和文本内容等。`Document` 接口定义了一些独有的方法：

- `Element getDocumentElement()`: 返回文档的根元素。
- `Element createElement(String tagName)`: 创建具有指定标签名称的新元素。
- `Text createTextNode(String data)`: 创建包含指定数据的新文本节点。
- `Attr createAttribute(String name)`: 创建具有指定名称的新属性节点。
- `Element getElementById(String elementId)`: 返回具有指定 ID 的元素。
- `Element createElementNS(String namespaceURI, String qualifiedName)`: 使用指定的命名空间URI和限定名称创建新元素。
- `Attr createAttributeNS(String namespaceURI, String qualifiedName)`: 使用指定的命名空间URI和限定名称创建新属性。
- `Node importNode(Node importedNode, boolean deep)`: 将节点从另一个文档导入到当前文档。

------

`org.w3c.dom.Node` 接口表示 DOM（Document Object Model）树中的一个节点，它是 DOM API 的核心接口之一。`Node` 接口定义了节点的通用属性和方法，所有 DOM 节点类型都实现了该接口，包括元素节点、文本节点、注释节点等。`Node` 接口的主要作用是：

1. **表示 DOM 树中的一个节点：** `Node` 接口表示 DOM 树中的一个节点，每个节点可以是一个元素、属性、文本内容、注释等。
2. **提供访问节点的方法：** `Node` 接口提供了一系列方法，用于访问和操作节点的属性、子节点和父节点等。
3. **定义节点类型：** `Node` 接口定义了表示不同类型节点的常量，如 `ELEMENT_NODE`、`TEXT_NODE`、`COMMENT_NODE` 等。
4. **节点关系：** `Node` 接口提供了方法来获取节点的父节点、子节点、兄弟节点等关系信息。
5. **节点操作：** `Node` 接口提供了方法来添加、移除、替换节点，以及克隆节点等操作。

以下是一些常用的 `Node` 接口方法：

1. **获取节点信息：**
   - **`String getNodeName()`: 返回节点的名称。**
   - **`String getNodeValue()`: 返回节点的值（仅适用于特定类型的节点，如文本节点）。**
   - **`short getNodeType()`: 返回节点的类型（例如，元素节点、文本节点等）。**
2. **获取父节点和子节点：**
   - `Node getParentNode()`: 返回父节点。
   - **`NodeList getChildNodes()`: 返回子节点列表。**
   - `Node getFirstChild()`: 返回第一个子节点。
   - `Node getLastChild()`: 返回最后一个子节点。
   - `Node getNextSibling()`: 返回下一个兄弟节点。
   - `Node getPreviousSibling()`: 返回上一个兄弟节点。
3. **操作节点：**
   - `Node appendChild(Node newChild)`: 将节点添加为最后一个子节点。
   - `Node removeChild(Node oldChild)`: 从子节点列表中删除指定的子节点。
   - `Node replaceChild(Node newChild, Node oldChild)`: 用新节点替换指定的子节点。
4. **判断节点关系：**
   - **`boolean hasChildNodes()`: 判断节点是否有子节点。**
   - **`boolean hasAttributes()`：判断节点是否有属性。**
   - `boolean isSameNode(Node other)`: 判断节点是否与另一个节点相同。
5. **其他方法：**
   - `Node cloneNode(boolean deep)`: 复制节点（如果 `deep` 为 true，则同时复制子树）。
   - `Document getOwnerDocument()`: 返回拥有当前节点的文档节点。
6. **获取属性节点：**
   - **`NamedNodeMap getAttributes()`: 返回包含节点所有属性的 `NamedNodeMap` 对象。**
7. **获取特定属性：**
   - `Node getAttributeNode(String name)`: 返回具有指定名称的属性节点。
   - `String getAttribute(String name)`: 返回具有指定名称的属性的值。
8. **添加和移除属性：**
   - `void setAttribute(String name, String value)`: 设置具有指定名称和值的属性。如果属性已存在，则替换旧值。
   - `void removeAttribute(String name)`: 删除具有指定名称的属性。
9. **判断属性是否存在：**
   - `boolean hasAttribute(String name)`: 判断节点是否具有指定名称的属性。



在 DOM（文档对象模型）中，不同类型的节点用不同的常量值表示，以便于区分节点的类型。这些常量由 `Node` 接口定义，可以通过 `Node` 接口的静态常量来访问。常见的节点类型包括：

- `Node.ELEMENT_NODE`：表示元素节点。
- `Node.ATTRIBUTE_NODE`：表示属性节点。
- `Node.TEXT_NODE`：表示文本节点。
- `Node.COMMENT_NODE`：表示注释节点。
- `Node.DOCUMENT_NODE`：表示文档节点。

`Node.DOCUMENT_NODE` 表示整个文档的根节点，即文档对象（Document Object）。在 DOM 中，文档对象是整个 XML 或 HTML 文档的入口点，通过文档对象可以访问文档的所有内容，包括元素、属性、文本等。通常，使用 `Document` 类型的实例表示文档对象。

例如，可以通过以下方式检查一个节点是否为文档节点：

```java
Node node = ...; // 获取一个节点
if (node.getNodeType() == Node.DOCUMENT_NODE) {
    // 这是一个文档节点
    Document document = (Document) node;
    // 可以对文档进行操作
}
```

通过比较节点的类型是否为 `Node.DOCUMENT_NODE`，可以判断节点是否为文档节点，从而进行相应的操作。

如果对`Document`进行了修改，要保存，则可以将修改后的内容保存到文件或其他输出流中。保存 `Document` 的常用方法是将其转换为字符串形式，然后将字符串写入文件或输出流中。

下面是一个简单的示例，演示了如何将修改后的 `Document` 保存到文件中：

```java
// 从文件、网络流或其他来源获取 XML 输入流
InputStream input = DemoTest.class.getResourceAsStream("book.xml");
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();
// 使用 DocumentBuilder 解析输入流，获取 Document 实例
Document doc = db.parse(input);
// 创建一个 Transformer 对象
Transformer transformer = TransformerFactory.newInstance().newTransformer();
DOMSource source = new DOMSource(doc);
// 将字符串写入文件中
StreamResult result = new StreamResult(new File("1.xml"));
// 使用 Transformer 将 Document 转换为字符串形式
transformer.transform(source, result);
```

## 使用SAX解析

使用DOM解析XML的优点是用起来省事，但它的主要缺点是内存占用太大。

另一种解析XML的方式是SAX。SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。

SAX解析会触发一系列事件：

- startDocument：开始读取XML文档；
- startElement：读取到了一个元素，例如`<book>`；
- characters：读取到了字符；
- endElement：读取到了一个结束的元素，例如`</book>`；
- endDocument：读取XML文档结束。

如果用SAX API解析XML，Java代码如下：

```java
InputStream input = DemoTest.class.getResourceAsStream("book.xml");
SAXParserFactory spf = SAXParserFactory.newInstance();
SAXParser saxParser = spf.newSAXParser();
saxParser.parse(input, new MyHandler());
```

关键代码`SAXParser.parse()`除了需要传入一个`InputStream`外，还需要传入一个回调对象，这个对象要继承自`DefaultHandler`：

```java
static class MyHandler extends DefaultHandler {
    public void startDocument() {
        print("文档开始");
    }
    public void endDocument() {
        print("文档结束");
    }
    public void startElement(String uri, String localName, String qName, Attributes attributes) {
        print("元素：", localName, qName);
        print("属性:");
        for (int i = 0; i < attributes.getLength(); i++) {
            print("  ",attributes.getLocalName(i),"=",attributes.getValue(i));
        }
    }
    public void endElement(String uri, String localName, String qName) {
        print("元素结束:", localName, qName);
    }
    public void characters(char[] ch, int start, int length) {
        print("文本:", new String(ch, start, length));
    }
    public void error(SAXParseException e) {
        print("错误:", e);
    }
    void print(Object... objs) {
        for (Object obj : objs) {
            System.out.print(obj);
            System.out.print(" ");
        }
        System.out.println();
    }
}
```

如果要读取`<name>`节点的文本，我们就必须在解析过程中根据`startElement()`和`endElement()`定位当前正在读取的节点，可以使用栈结构保存，每遇到一个`startElement()`入栈，每遇到一个`endElement()`出栈，这样，读到`characters()`时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。

SAX是一种流式解析XML的API；SAX通过事件触发，读取速度快，消耗内存少；调用方必须通过回调方法获得解析过程中的数据。

------

要创建 `SAXParser` 对象，通常使用 `SAXParserFactory` 工厂类：

```java
// 创建 SAXParserFactory 实例
SAXParserFactory factory = SAXParserFactory.newInstance();
// 指定是否验证 XML 文件，默认为 false
factory.setValidating(false);
// 指定是否命名空间感知，默认为 false
factory.setNamespaceAware(false);
// 创建 SAXParser 实例
SAXParser saxParser = factory.newSAXParser();
```

`SAXParser` 类是用于解析 `XML` 文档的类，它实现了 `XMLReader` 接口，提供了一系列方法来解析 `XML` 文档。以下是 `SAXParser` 类的一些常用方法：

- `parse(InputSource input, DefaultHandler handler)`：解析给定的输入源并使用指定的处理程序处理 `XML` 内容。
- **`parse(InputStream is, DefaultHandler dh)`：解析给定的输入流并使用指定的处理程序处理 `XML` 内容。**
- `parse(File f, DefaultHandler dh)`：解析给定的文件并使用指定的处理程序处理 `XML` 内容。
- `parse(String uri, DefaultHandler dh)`：解析给定的 `URI` 并使用指定的处理程序处理 `XML` 内容。
- `setContentHandler(ContentHandler handler)`：设置内容处理程序，用于处理 `XML` 文档中的内容。
- `setDTDHandler(DTDHandler handler)`：设置 `DTD` 处理程序，用于处理 `XML` 文档中的 `DTD` 声明。
- `setEntityResolver(EntityResolver resolver)`：设置实体解析器，用于解析 `XML` 文档中的实体。
- `setErrorHandler(ErrorHandler handler)`：设置错误处理程序，用于处理 `XML` 解析过程中的错误。
- `getXMLReader()`：获取与此 `SAXParser` 关联的 `XMLReader` 对象，用于解析 `XML` 文档。
- `getSchema()`：获取当前为 `SAXParser` 设置的 `XML Schema`。
- `isNamespaceAware()`：返回解析器是否为命名空间感知的布尔值。
- `isValidating()`：返回解析器是否验证 `XML` 内容的布尔值。

这些方法用于配置和操作 `SAXParser` 实例，以便解析 `XML` 文档并处理其内容。

`DefaultHandler` 是 `SAX` 解析器的默认处理程序，它实现了 `ContentHandler`、`DTDHandler`、`EntityResolver` 和 `ErrorHandler` 接口。这些接口定义了处理 `XML` 内容和解析过程中可能出现的各种情况的方法。以下是 `DefaultHandler` 中一些重要的方法和作用：

- **`startDocument()`：在解析文档开始时调用。**
- **`endDocument()`：在解析文档结束时调用。**
- **`startElement(String uri, String localName, String qName, Attributes attributes)`：在解析元素开始时调用。**
- **`endElement(String uri, String localName, String qName)`：在解析元素结束时调用。**
- **`characters(char[] ch, int start, int length)`：在解析字符数据时调用。**
- `startPrefixMapping(String prefix, String uri)`：在解析命名空间前缀映射时调用。
- `endPrefixMapping(String prefix)`：在解析命名空间前缀映射结束时调用。
- `processingInstruction(String target, String data)`：在解析处理指令时调用。
- `skippedEntity(String name)`：在解析实体时调用。
- `warning(SAXParseException e)`：在解析过程中遇到警告时调用。
- **`error(SAXParseException e)`：在解析过程中遇到可恢复错误时调用。**
- `fatalError(SAXParseException e)`：在解析过程中遇到致命错误时调用。

`DefaultHandler` 的作用是提供这些方法的默认实现，可以根据需要覆盖这些方法来处理 `XML` 解析过程中的事件。通常，可以创建一个继承自 `DefaultHandler` 的类，并重写其中的方法来实现自定义的 `XML` 处理逻辑。

`SAXParser` 本身并不能直接修改 `XML`，因为 `SAXParser` 是一种流式解析器，它按顺序读取 `XML` 文件并触发相应的事件，而不会将整个 `XML` 文档加载到内存中。因此，如果需要修改 `XML`，通常需要借助其他 `API` 或方法来实现。

## 使用StAX解析

StAX（Streaming API for XML）是用于处理 XML 的一种流式处理 API。与传统的 DOM（Document Object Model）和 SAX（Simple API for XML）相比，StAX 提供了一种更灵活的方式来读取和写入 XML 数据。

使用 StAX，可以逐个事件地处理 XML 文档，而不需要将整个文档加载到内存中（像 DOM 那样），也不需要像 SAX 那样完全依赖事件回调模型。相反，StAX 允许以迭代器的方式逐个读取或写入 XML 元素，使得处理 XML 数据变得更加简单和高效。

```java
InputStream input = DemoTest.class.getResourceAsStream("book.xml");
XMLInputFactory factory = XMLInputFactory.newInstance();
XMLStreamReader reader = factory.createXMLStreamReader(input);

while (reader.hasNext()) {
    int event = reader.next();
    switch (event) {
        case XMLStreamConstants.START_ELEMENT:
            System.out.println("元素： " + reader.getLocalName());
            for (int i = 0; i < reader.getAttributeCount(); i++) {
                System.out.println("  Attribute: " + reader.getAttributeLocalName(i) + "=" + reader.getAttributeValue(i));
            }
            break;
        case XMLStreamConstants.CHARACTERS:
            if (!reader.isWhiteSpace()) {
                System.out.println("文本: " + reader.getText());
            }
            break;
        case XMLStreamConstants.END_ELEMENT:
            System.out.println("元素结束: " + reader.getLocalName());
            break;
    }
}
reader.close();
input.close();
```

要使用 StAX 修改 XML，需要创建一个 `XMLInputFactory` 来读取 XML 文件，并创建一个 `XMLOutputFactory` 来写入修改后的 XML。示例：

```java
Deque<String> stack=new LinkedList<>();
// 创建输入和输出的 XML 工厂
XMLInputFactory inputFactory = XMLInputFactory.newInstance();
XMLOutputFactory outputFactory = XMLOutputFactory.newInstance();

// 创建 XML 输入和输出流
InputStream input = DemoTest.class.getResourceAsStream("book.xml");
OutputStream output = new FileOutputStream("book2.xml");
XMLStreamReader reader = inputFactory.createXMLStreamReader(input);
XMLStreamWriter writer = outputFactory.createXMLStreamWriter(output);
writer.writeStartDocument("UTF-8", "1.0"); // 写入XML声明
// 处理元素
while (reader.hasNext()) {
    int event = reader.next();
    switch (event) {
        case XMLStreamConstants.START_ELEMENT:
            // 处理开始元素
            String elementName = reader.getLocalName();
            stack.push(elementName);
            if ("book".equals(elementName)) {
                // 修改元素内容
                writer.writeStartElement("book2");
            } else {
                // 复制其他元素
                writer.writeStartElement(elementName);
            }
            for (int i = 0; i < reader.getAttributeCount(); i++) {
                writer.writeAttribute(reader.getAttributeLocalName(i),reader.getAttributeValue(i));
            }
            break;

        case XMLStreamConstants.CHARACTERS:
            if (!reader.isWhiteSpace()) {
                if("isbn".equals(stack.peek())){
                    writer.writeCharacters("666888");
                }else {
                    writer.writeCharacters(reader.getText());
                }
            }
            break;
        case XMLStreamConstants.END_ELEMENT:
            stack.pop();
            writer.writeEndElement();
            break;
    }
}

// 关闭流
reader.close();
writer.close();
input.close();
output.close();
```

这段代码的目标是读取一个 XML 文件并将其内容修改后写入另一个 XML 文件。在处理元素内容时，如果当前元素是 `isbn`，则将其内容修改为 "666888"，如果当前元素是`book`则修改为`book2`。

------

`XMLStreamReader` 是用于读取 XML 数据的接口，它允许逐个事件地读取 XML 文档的内容，并提供了一种低级别的、基于流的方式来解析 XML。通过 `XMLStreamReader`，可以逐步遍历 XML 文档的元素、属性、文本内容等，并根据需要对文档进行处理，如提取数据、修改内容等操作。这种基于流的解析方式相比于基于文档对象模型（DOM）的解析方式，更加高效，尤其适用于处理大型 XML 文件。

`XMLStreamReader` 提供了许多方法来读取 XML 文档的不同部分，以下是一些常用的方法：

- **`boolean hasNext()`：检查是否还有更多的事件要处理。**
- **`int next()`：移动到下一个 XML 事件，并返回事件的类型。**
- `int getEventType()`：返回当前事件的类型。
- `boolean isStartElement()`：检查当前事件是否是开始元素。
- `boolean isCharacters()`：检查当前事件是否是字符数据。
- `boolean isEndElement()`：检查当前事件是否是结束元素。
- `String getLocalName()`：返回当前元素的本地名称。
- **`int getAttributeCount()`：返回当前元素的属性数。**
- **`String getAttributeLocalName(int index)`：返回指定索引处属性的本地名称。**
- **`String getAttributeValue(int index)`：返回指定索引处属性的值。**
- **`String getText()`：返回当前元素的文本内容。**
- **`boolean isWhiteSpace()`：检查当前解析器位置是否位于空白字符上。**
- **`void close()`：关闭 `XMLStreamReader`。**

这些方法可以在处理 XML 文档时导航并提取所需的信息。

------

`XMLStreamWriter` 是用于写入 XML 数据的接口，它允许逐个事件地生成 XML 文档的内容，并提供了一种低级别的、基于流的方式来生成 XML。通过 `XMLStreamWriter`，可以逐步构建 XML 文档的元素、属性、文本内容等，并生成符合 XML 规范的 XML 数据。这种基于流的生成方式相比于基于文档对象模型（DOM）的生成方式，更加高效，尤其适用于生成大型 XML 文件。

常用的 `XMLStreamWriter` 方法包括：

- **`writeStartDocument(String version, String encoding)`：写入 XML 声明。**
- **`writeStartElement(String localName)`：写入开始元素。**
- **`writeAttribute(String localName, String value)`：写入元素属性。**
- **`writeCharacters(String text)`：写入文本内容。**
- **`writeEndElement()`：写入结束元素。**
- `writeEndDocument()`：写入 XML 结束标记。
- `flush()`：刷新缓冲区，确保所有数据都被写入底层流。
- **`close()`：关闭 `XMLStreamWriter`。**

------

`XMLStreamConstants` 是一个接口，定义了一组整数常量，用于表示 XML 解析器生成的各种事件类型。这些常量用于与 `XMLStreamReader` 和 `XMLStreamWriter` 一起使用，以便在处理 XML 文档时识别不同类型的事件。通过这些常量，可以方便地检查当前事件的类型，并根据需要执行相应的操作。

`XMLStreamConstants` 提供了以下常量：

- `START_ELEMENT`：表示开始元素事件。
- `END_ELEMENT`：表示结束元素事件。
- `CHARACTERS`：表示字符数据事件。
- `ATTRIBUTE`：表示属性事件。
- `NAMESPACE`：表示命名空间事件。
- `START_DOCUMENT`：表示开始文档事件。
- `END_DOCUMENT`：表示结束文档事件。
- `PROCESSING_INSTRUCTION`：表示处理指令事件。
- `COMMENT`：表示注释事件。
- `DTD`：表示 DTD 事件。
- `ENTITY_REFERENCE`：表示实体引用事件。
- `CDATA`：表示 CDATA 事件。
- `SPACE`：表示空格事件。



## 使用Jackson

XML文档的结构：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<book id="1">
    <name>Java核心技术</name>
    <author>Cay S. Horstmann</author>
    <isbn lang="CN">1234567</isbn>
    <tags>
        <tag>Java</tag>
        <tag>Network</tag>
    </tags>
    <pubDate/>
</book>
```

完全可以对应到一个定义好的JavaBean中：

```java
public class Book {
    public long id;
    public String name;
    public String author;
    public String isbn;
    public List<String> tags;
    public String pubDate;
}
```

Jackson第三方库可以轻松做到XML到JavaBean的转换。要使用Jackson，先添加一个Maven的依赖：

```xml
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml -->
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
    <version>2.17.0</version>
</dependency>
```

然后，定义好JavaBean，就可以用下面几行代码解析：

```java
InputStream input = Main.class.getResourceAsStream("/book.xml");
JacksonXmlModule module = new JacksonXmlModule();
XmlMapper mapper = new XmlMapper(module);
Book book = mapper.readValue(input, Book.class);
System.out.println(book.id);
System.out.println(book.name);
System.out.println(book.author);
System.out.println(book.isbn);
System.out.println(book.tags);
System.out.println(book.pubDate);
```

`XmlMapper`可以用`readValue(InputStream, Class)`直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：

```text
1
Java核心技术
Cay S. Horstmann
1234567
[Java, Network]
null
```

如果要解析的数据格式不是`Jackson`内置的标准格式，那么需要编写一点额外的扩展来告诉`Jackson`如何自定义解析，可以参考[Jackson](https://github.com/FasterXML/jackson)的[官方文档](https://github.com/FasterXML/jackson-annotations)。读取属性：

```java
package test;

import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

public class DemoTest {
    @Test
    void testNegative() throws IOException {
        InputStream input = DemoTest.class.getResourceAsStream("book.xml");
        JacksonXmlModule module = new JacksonXmlModule();
        // 默认使用“未包装”列表:
        //module.setDefaultUseWrapper(false);
        XmlMapper mapper = new XmlMapper(module);
        //自动忽略无法对应pojo的字段
        //mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        //字段为null，自动忽略，不再序列化
        //mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        //XML标签名:使用骆驼命名的属性名，
        //mapper.setPropertyNamingStrategy(PropertyNamingStrategy.UPPER_CAMEL_CASE);
        //设置转换模式
        mapper.enable(MapperFeature.USE_STD_BEAN_NAMING);
        Book book = mapper.readValue(input, Book.class);
        System.out.println(book.id);
        System.out.println(book.name);
        System.out.println(book.author);
        System.out.println("节点isbn的值为:" + book.isbn.value);
        System.out.println("节点isbn的属性lang的值为:" + book.isbn.lang);
        System.out.println("节点isbn的属性aa的值为:" + book.isbn.aa);
        System.out.println(book.tags);
        System.out.println(book.pubDate);
    }
}
class Book {
    public long id;
    public String name;
    public String author;
    @JacksonXmlProperty(localName = "isbn")
    public BookAttr isbn;
    public List<String> tags;
    public String pubDate;
}
class BookAttr {
    @JacksonXmlProperty(isAttribute = true, localName = "lang")
    public String lang;
    @JacksonXmlProperty(isAttribute = true, localName = "aa")
    public String aa;
    //测试一下
    @JacksonXmlText
    public String value;
}
```

# JSON

XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。

JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：

```javascript
{
    "id": 1,
    "name": "Java核心技术",
    "author": {
        "firstName": "Abc",
        "lastName": "Xyz"
    },
    "isbn": "1234567",
    "tags": ["Java", "Network"]
}
```

JSON作为数据传输的格式，有几个显著的优点：

- JSON只允许使用UTF-8编码，不存在编码问题；
- JSON只允许使用双引号作为key，特殊字符用`\`转义，格式简单；
- 浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。

因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：

- 键值对：`{"key": value}`
- 数组：`[1, 2, 3]`
- 字符串：`"abc"`
- 数值（整数和浮点数）：`12.34`
- 布尔值：`true`或`false`
- 空值：`null`

浏览器直接支持使用JavaScript对JSON进行读写：

```javascript
// JSON string to JavaScript object:
jsObj = JSON.parse(jsonStr);

// JavaScript object to JSON string:
jsonStr = JSON.stringify(jsObj);
```

开发Web应用的时候，使用JSON作为数据传输，在浏览器端非常方便。因为JSON天生适合JavaScript处理，绝大多数REST API都选择JSON作为数据传输格式。

在Java中，针对JSON也有标准的JSR 353 API。常用的用于解析JSON的第三方库有：`Jackson`、`Gson`、`Fastjson`。

使用`Jackson`：

```xml
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml -->
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
    <version>2.17.0</version>
</dependency>
```

就可以使用下面的代码解析一个JSON文件：

```java
public class DemoTest {
    @Test
    void testNegative() throws IOException {
        InputStream input = DemoTest.class.getResourceAsStream("book.json");
        System.out.println(input);
        ObjectMapper mapper = new ObjectMapper();
        // 反序列化时忽略不存在的JavaBean属性:
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        Book book = mapper.readValue(input, Book.class);
        System.out.println(book);
    }
}
class Book {
    public long id;
    public String name;
    public Map<String,String> author;
    public String isbn;
    public List<String> tags;

    @Override
    public String toString() {return "Book{id=" + id + ", name='" + name + '\'' + ", author=" + author + ", isbn='" + isbn + '\'' + ", tags=" + tags + '}'; }
}
```

核心代码是创建一个`ObjectMapper`对象。关闭`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`功能使得解析时如果JavaBean不存在该属性时解析不会报错。

还可以直接用Map接收：

```java
InputStream input = DemoTest.class.getResourceAsStream("book.json");
System.out.println(input);
ObjectMapper mapper = new ObjectMapper();
Map<String, Object> map = mapper.readValue(input, Map.class);
System.out.println(map);
```

------

把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：

```java
String json = mapper.writeValueAsString(book);
```

还可以生成带缩进和换行的JSON：

```java
String json=mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map);
```



------

要把JSON的某些值解析为特定的Java对象，例如`LocalDate`，也是完全可以的。例如：

```javascript
{
    "name": "Java核心技术",
    "pubDate": "2016-09-01"
}
```

要解析为：

```java
public class Book {
    public String name;
    public LocalDate pubDate;
}
```

只需要引入标准的JSR 310关于`JavaTime`的数据格式定义至Maven：

```xml
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.datatype/jackson-datatype-jsr310 -->
<dependency>
    <groupId>com.fasterxml.jackson.datatype</groupId>
    <artifactId>jackson-datatype-jsr310</artifactId>
    <version>2.17.0</version>
</dependency>
```

然后，在创建`ObjectMapper`时，注册一个新的`JavaTimeModule`：

```java
ObjectMapper mapper = new ObjectMapper().registerModule(new JavaTimeModule());
```

还可以自定义解析，假设`Book`类的`isbn`是一个`BigInteger`：

```java
public class Book {
	public String name;
	public BigInteger isbn;
}
```

但JSON数据并不是标准的整形格式：

```java
{
    "name": "Java核心技术",
    "isbn": "978-7-111-54742-6"
}
```

直接解析，肯定报错。这时，需要自定义一个`IsbnDeserializer`，用于解析含有非数字的字符串：

```java
public class IsbnDeserializer extends JsonDeserializer<BigInteger> {
    public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        // 读取原始的JSON字符串内容:
        String s = p.getValueAsString();
        if (s != null) {
            try {
                return new BigInteger(s.replace("-", ""));
            } catch (NumberFormatException e) {
                throw new JsonParseException(p, s, e);
            }
        }
        return null;
    }
}
```

然后，在`Book`类中使用注解标注：

```java
public class Book {
    public String name;
    // 表示反序列化isbn时使用自定义的IsbnDeserializer:
    @JsonDeserialize(using = IsbnDeserializer.class)
    public BigInteger isbn;
}
```

类似的，自定义序列化时我们需要自定义一个`IsbnSerializer`，然后在`Book`类中标注`@JsonSerialize(using = ...)`即可。

在反序列化时，`Jackson`要求Java类**需要一个默认的无参数构造方法**，否则，无法直接实例化此类。存在带参数构造方法的类，如果要反序列化，注意再提供一个无参数构造方法。

对于`enum`字段，Jackson按String类型处理，即：

```java
class Book {
    public DayOfWeek start = MONDAY;
}
```

序列化为：

```javascript
{
    "start": "MONDAY"
}
```

对于`record`类型（**Java 14** ），Jackson会自动找出它的带参数构造方法，并根据JSON的key进行匹配，可直接反序列化。对`record`类型的支持需要版本`2.12.0`以上。

# GUI

`JFrame`  **构造方法**  

| 方法                                             | 说明                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| `JFrame()`                                       | 构造一个初始时不可见的新窗体。                               |
| `JFrame(GraphicsConfiguration gc)`               | 以屏幕设备的指定 `GraphicsConfiguration` 和空白标题创建一个 `Frame`。 |
| `JFrame(String title)`                           | 创建一个新的、初始不可见的、具有指定标题的 `Frame`。         |
| `JFrame(String title, GraphicsConfiguration gc)` | 创建一个具有指定标题和指定屏幕设备的 `GraphicsConfiguration` 的 `JFrame`。 |

**常用方法**  

| 方法                                      | 说明                                   |
| ----------------------------------------- | -------------------------------------- |
| `add()`                                   | 将组件添加到窗口                       |
| `is/setVisible()`                         | 获取/设置窗体的可视状态。              |
| `get/setTitle()`                          | 获取/设置窗体的标题。                  |
| `get/setState()`                          | 获取/设置窗体的的最小化,最大化等状态。 |
| `get/setLocation()`                       | 获取/设置窗体在屏幕上应当出现的位置。  |
| `get/setSize()`                           | 获取/设置窗体的大小。                  |
| `setDefaultCloseOperation(int operation)` | 设置单击窗体上的关闭按钮时的默认操作。 |
| `getContentPane()`                        | 获取窗体的内容面板                     |

`setDefaultCloseOperation`  

`public void setDefaultCloseOperation(int operation)`  
设置用户在此窗体上发起"`close`"时默认执行的操作。必须指定以下选项之一：  

值依次为`0-3`  

`DO_NOTHING_ON_CLOSE`(在 WindowConstants 中定义)：不执行任何操作;要求程序在已注册的 `WindowListener` 对象的 `windowClosing` 方法中处理该操作。  

`HIDE_ON_CLOSE`(在 `WindowConstants` 中定义)：调用任意已注册的 `WindowListener` 对象后自动隐藏该窗体。  

`DISPOSE_ON_CLOSE`(在 `WindowConstants` 中定义)：调用任意已注册 `WindowListener` 的对象后自动隐藏并释放该窗体。  

`EXIT_ON_CLOSE`(在 `JFrame` 中定义)：使用 `System exit` 方法退出应用程序。仅在应用程序中使用。  

默认情况下,该值被设置为 `HIDE_ON_CLOSE`。更改此属性的值将导致激发属性更改事件,其属性名称为 "`defaultCloseOperation`"。  

注：当 Java 虚拟机 (VM) 中最后一个可显示窗口被释放后,虚拟机**可能**会终止。  
`frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);`  
