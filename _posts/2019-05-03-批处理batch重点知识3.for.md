---
layout: post
title: 批处理batch重点知识3.for
categories: [windows, batch]
description: 批处理重点知识笔记
keywords: windows, batch
---
# 引言  
本篇文章介绍批处理**for**语句的无参形式、带`/d`的子文件夹形式、带`/r`的遍历形式、带`/l`的循环形式、带`/f`的文本处理形式。  


# for 循环  
<font  color="red">bat文件中for里用%%i，cmd直接输入时用%i</font>  
## 一般格式：  
```batch
FOR [参数] %%变量名 IN (相关文件或命令) DO 执行的命令
```
## 无参数(子文件)  
```batch
FOR %%variable IN (set) DO command [command-parameters]
```
- **for**语句的形式变量`i`，可以换成26个字母中的任意一个，**区分大小写**，形式变量`i`也可以换成其他的字符，注意不要与`%0`～`%9`这10个形式变量发生冲突。  
- **in**和**do**之间的**set**表示的字符串或变量可以是一个，也可以是多个，用**空格键、跳格键、逗号、分号**或**等号分隔**；  
- **for**语句**依次提取** **set**中的每一个元素，把它的值赋予形式变量`i`，然后把`%%i`带到**do**后的**command**中参与命令的执行；直到集合中的所有元素都被遍历后才停止**for**循环.  

实例:  
显示结果分成了3行,每一行都从逗号处被切分；  

```batch
for %%I in (a,b,c) do echo %%I
```
直接显示`a.b.c`，**因为.号不是分隔符**  
```batch
for %%I in (a.b.c) do echo %%I
```
当set带有`*`或`?`号时会搜索当前工作路径相匹配的文件与文件夹路径.  
无参数时只会搜索当前目录下的文件，且不能匹配带隐藏属性的文件.  
显示当前目录下与`*.*`相匹配的文件(不遍历子文件夹）  
```batch
for %%i in (*.*) do echo %%i
```
显示`d:\7-Zip\`目录下与`*.*`相匹配的文件(不遍历子文件夹）  
```batch
for %%i in (d:\7-Zip\*.*) do @echo %%i
```
检测当前硬盘都有哪些分区,包括U盘和移动硬盘的分区  
```batch
@echo off
set str=c d e f g h i j k l m n o p q r s t u v w x y z
echo 当前硬盘的分区有：
for %%i in (%str%) do if exist %%i: echo %%i:
pause
```

##  **参数 /d(子文件夹)**
这个参数只能搜索当前目录的**子文件夹**，且不能匹配带隐藏属性的文件夹  
格式:  
```batch
for /d %%i in (元素集合) do 命令语句集合
```
当`元素集合`中包含有通配符`?`或`*`时，会匹配文件夹。如果没有包含通配符，则有`/d`参数和无`/d`参数效果一样.  
它**仅能匹配当前目录下的第一级文件夹**，或是指定位置的文件夹的下一级文件夹，而不能匹配更深层次的子文件夹。  
显示c盘根目录下的所有目录(不遍历子文件夹）  
```batch
for /d %%i in (c:\*) do @echo %%i
```
显示当前目录下名字只有1-3个字母的目录  
```batch
for /d %%i in (???) do @echo %%i
```

## 参数 /r(遍历)  
遍历文件夹(包括子文件夹)，但不能列举带隐藏属性的文件夹  
格式:  

```batch
for /r 文件夹 %%i in (元素集合) do 命令语句集合
```
列举`文件夹`及该文件夹路径下所有子文件夹，并把列举出来的文件夹路径与元素集合中的每一个元素拼接成形如“文件夹路径\元素”赋值给`%%i`,并执行一次**命令语句集合**.  
**当`元素集合`带以点号分隔的通配符`?`或`*`的时候**，把`元素集合`视为文件（不视为文件夹），整条语句的作用是匹配文件夹及其所有子文件夹下匹配的文件；**若不以点号分隔，则把`元素集合`视为文件夹**（不视为文件）；  
当省略掉文件夹时，则针对当前目录；  
将`d:\7zip`下的EXE文件输出  

```batch
for /r d:\7-zip %%i in (*.exe) do @echo %%i
```
将`d:\7zip`下的所有文件夹输出并加上**in**后面括号内的字符  
```batch
for /r d:\7-zip %%i in (任何没有通配符的字符) do @echo %%i
```
在`d:\7zip`列举`7z.dll`存在的目录  
```batch
for /r d:\7-zip %%i in (7z.dll) do @if exist %%i echo %%i
```
将`d:\7zip`下的所有文件夹输出并加上**in**内的字符,这里会输出3次  
```batch
for /r d:\7-zip %%i in (a b c) do echo %%i
```
**for /r /d是可以一起使用的**  
```batch
@echo off
For /r /d %%i in (*) do echo %%i
pause>nul
```
效果：  
显示当前目录下所有的文件夹(**包括子文件夹**)；等价于 `dir /ad /s /b`。  
`for /r /d `其实是对 `/d` 参数的扩展，`/d`参数本身只能处理第一层文件夹，但是加上`/r`参数后就可以处理所有的子文件夹；  
但`for /r /d`**依然不能处理隐藏文件夹**。  
这里给出使用`for /r /d`的一般条件：  
1. 要对文件夹进行操作（`dir /ad /s /b`可以显示，但不能对文件夹进行操作）；  
2. 不处理隐藏文件夹（说到底，还是`for /f` 和`dir`结合的命令更强大些）。  
**for /r** 与 **dir /ad /s**类似,它们有如下几个优缺点:  
**for /r：**  
- 只通过1条语句就可以同时实现获取目录路径和处理目录路径的操作；  
- 遍历文件夹的时候，是边列举边处理的，获取到一条路径就处理一条路径，内存占用小，处理大量路径的时候不会产生停顿感；  
- 不能获取到带隐藏属性的目录，会产生遗漏；不能获取带指定属性的目录  

**dir /ad /s：**  
- 能一次性获取带任意属性的目录，不会产生遗漏；能通过指定不同的参数获取带任意属性的目录，更具灵活性。  
- `dir /ad /s` 语句仅能获取到目录路径，若要实现进一步的处理，还需要嵌入 for /f 语句中才能实现，写法不够简洁；  
- 嵌入` for /f` 语句之后，需要写成 `for /f "delims=" %%i in ('dir /ad /b /s') do ……` 的格式，受 `for /f` 语句运行机制的制约，需要先列举完所有的路径放入内存之后，才能对每一条路径进行进一步的处理，处理大量路径时，内存占用量偏大，并且在前期会产生明显的停顿感，用户体验度不够好；  

## 参数 /L (循环)  

语法:  
```batch
FOR /L %variable IN (start,step,end) DO command [command-parameters]
```
与C语言的for差不多.  
```c
for(int a=start;a<=(或>=)end;a=a+step)
```
详解：  
在这个语句中，**start**、**step**和**end**都只能取整数，正负皆可，**start**指代起始值，**step**指代步长，**end**为终止值，具体含义为：从**start**开始计数，以**step**为步长，直至最接近 **end**的那个整数值为止，这之间有多少个数，**do**后的语句就执行多少次。  
实际上，**start**，**step**和**end**的值可正可负，甚至为0，限制非常宽松：  
- **步长step的值不能为0；**  
- **当步长step的值为正整数时，终止值end不能小于初始值start；**  
- **当步长step的值为负整数的时候，终止值end不能大于初始值start。**

换而言之，必须保证in和do之间能取到一个有效的数组序列。  
```c
for /l %%i in (2,1,5) do @set /p =%%i,<nul
```
输出2,3,4,5,  
```c
for /l %%i in (2,1,5) do @echo %%i,
```
输出2,回车3,回车4,回车5,回车  
```c
for /l %%i in (2 1 5) do @echo %%i,
```
输出2,回车3,回车4,回车5,回车  
**for /r**与**goto**如何选择:  
- 当循环次数**确定**的时候，首选 `for /l` 语句，也可使用`goto`语句但不推荐；  
- 当循环次数**不确定**的时候，用`goto`语句将是唯一的选择，因为，这个时候需要用`if`之类的条件语句来判断何时结束`goto`跳转。  
  
## 参数 /F (文件解析)  
`/f`参数用于解析文本。  
逐行显示**test.txt**全部文本内容:  
```batch
for /f %%i in (test.txt) do echo %%i
```
`/f`还具有以下几个参数:  
切片**delims=** (默认以`空格键`或`跳格键`切分)  
定点提取：**tokens=** （默认为**tokens=1**）  
跳过无关内容：**skip=**（默认为**skip=0**）  
忽略以指定字符打头的行：**eol=**（默认为**eol=;**）  
改变语法应对特殊符号:**usebackq**  
### 切片delims=  
如果**没有指定"delims=符号列表",**默认以空格键或跳格键作为字符串的切分字符  
通过写  `for /f "delims="`来禁用默认设置（不会将**"**做为分隔符）  
```batch
for /f "tokens=1,2 delims= eol=" %%i in (test.txt) do echo %%i
```
写在中间也是没问题的，不会将分隔符定义为空格，但**eol**会用"号进行判断行首  
```batch
for /f "delims=，" %%i in (test.txt) do echo %%i
```
`"delims=，"`表示以`，`号切割每行内容,并将第一段文字赋值给`%%i`.  
  
**可以一次性指定多个分隔符号**  
```batch
for /f "delims=.，" %%i in (test.txt) do echo %%i
```
如果要让**`"`**号当分隔符,那么就不能在**delims=**外面加引号了:  
```batch
@echo off
for /f usebackq^ delims^=^" %%i in ('内容1^"内容2') do echo %%i
pause
```
**`^`**号在批处理中是转义符号.  
**usebackq**是为了兼容**`in ('内容1^"内容2')`**,把双引号改写成单引号了,后面会详细说明.  
这样不写双引号，对特殊字符用`^`转义就可以将双引号当成一个分隔符  
如果要指定空格和其他分隔符，那么空格要放在最后（必须在"号前）,因为空格用来作为参数的分隔符. 即:**"delims=, "**。  
### 定点提取tokens=  
**tokens=**后面跟**数字**，可以跟多个，每个数字之间用逗号分隔。如 **`tokens=3,5,8`**，提取索引为3，5，8的文本内容，并分别赋值给`%%i`、`%%j`、`%%k`。文本切割由**delims=**处理，索引从1开始，**默认为tokens=1**  
实例：  
**text.txt**内容：  
```text
尺有所短，寸有所长，学好批处理没商量，考虑问题复杂化，解决问题简洁化。
```
**提取“学好批处理没商量”这句话**  
```batch
for /f "delims=， tokens=3" %%i in (test.txt) do echo %%i
```
如果 **tokens=** 后面指定了多个数字，如果形式变量为**%%i**，那么，第一个数字索引的内容会赋值给**%%i**，第二个就赋值给**%%j**，以此类推，**遵循字母的排序**，  
**批处理命令for...in..do %%a被用到了%%z还不够用怎么办？**  
汉字的unicode范围是：0x4E00~0x9FA5，可以用 bat+html 来列举  
```batch
@echo off
(
echo ^<pre^>
for /l %%a in (0x4E00 1 0x9FA5) do echo ^&#%%a;
echo ^</pre^>
)>汉字.html
```
然后从中抽取任意一段连续的字符都可以，例如  
```text
一丁丂七丄丅丆万丈三上下丌不与丏丐丑丒
```
实例：  
```batch
@echo off
for /f "tokens=1-31*" %%一 in ("a b c d e f g h i j k l m") do echo %%丈
pause
```
连续的数字可以只写**最小值**和**最大值**，中间用**短横**连起来。比如 `tokens=1,2,3,4,5` 可以简写为 `tokens=1-5` 。  
**\*号表示之后的全部内容**，都由一个变量接收,不再被**delims=**切割,有这几种写法:`"tokens=2,*"`,`"tokens=2*"`,他们都表示第二个索引代表的内容复制给第一个变量,之后的全部文本赋值给第二个变量。  
**跳过无关内容skip=N**  
简单来说就是跳过前N行，直接从第N+1行处理，N**是一个正整数**，表示要跳过的行数。例如：  
```batch
for /f "skip=2" %%i in (test.txt) do echo %%i
```
这段代码将跳过头两行内容，从第**3**行起显示test.txt中的信息。  
### 忽略以指定字符打头的行：eol=;  
**eol=只能指定1个字符。**  
默认为**eol=;**  
如果设置了**delims=;**则eol=;不会生效,即优先级低于**delims**。  
实例:  
```batch
for /f "eol=;" %%i in (test.txt) do echo %%i
```
如果要取消这个默认设置，只能说没有办法：可以将它指定为一个偏僻字符。  
如果在行尾：`"tokens=1,2 delims= eol="` **eol**会用`"`进行判断行首  
换成中间：**`"tokens=1,2 eol= delims="`** **eol**会用`空格`判断行首  
### for /f 的句式（以及usebackq）  
**for /f %%i in (……) do (……)** 语句有好几种变形语句具体格式为：  
```batch
for /f %%i in (文件名) do (……)
for /f %%i in ('命令语句') do (……)
for /f %%i in ("字符串") do (……)
```
**如果是文件，则无需包裹；如果是命令语句，则用单引号包裹；如果是字符串，则使用双引号括起来**。  
1、读取文本文件中的内容，应该使用第1条语句；  
```batch
for /f %%i in (test.txt) do echo %%i；
```
2、读取命令语句执行结果中的内容，应该使用第2条语句；  

显示当前目录下文件名中含有test字符串的文本文件  
```batch
for /f %%i in ('dir /a-d /b *test*.txt') do echo %%i
```
3、处理字符串，应该使用第3条语句；  
```batch
for /f %%i in ("12345678") do echo %%i
```
**usebackq参数用来应对一些特殊情况:**  
```batch
for /f "usebackq" %%i in ("文件名") do (……)
for /f "usebackq" %%i in (`命令语句`) do (……)
for /f "usebackq" %%i in ('字符串') do (……)
```
之前读取文件的**`文件名`**语法变成**`"文件名"`**。  
```batch
for /f "usebackq" %%i in ("test 1.txt") do echo %%i
```
之前读取命令语句执行结果中的内容,**单引号`'`**改为后引号**`**:  
```batch
for /f "usebackq" %%i in (`dir /a-d /b *test*.txt`) do echo %%i
```
之前的处理字符串，原来的**双引号`"`**要**改为单引号`'`**；  
```batch
for /f %%i in ('12345678') do echo %%i
```
特殊字符的处理:  
```batch
@echo off
for /f "usebackq delims=" %%i in (('^"/*?:\^" '：'"&^^ "^&，"''"。') do echo %%i 
pause
```
对于使用了**usebackq** 的**('\*')**或者没有**usebackq** 的**("\*")**的内容有以下规则:  
1. 双引号`"`必须成对出现，即双数，就近匹配（被`^`转义的双引号不算）  
2. 双引号内的内容会变成普通字符，双引号外的特殊符号要`^`转义（**^& "\|\<\>**等等）,**/\*?:\\**不用转义.  
3. 双引号内不能出现双引号，换个说法就是双引号内可以出现双引号，但需要使用两个双引号来表示一个双引号。  
4. 双引号不论是否被转义，都会显示出来。  