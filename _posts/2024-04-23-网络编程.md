---
layout: post
title: 网络编程
categories: Java
description: Java笔记
keywords: Java
---
# 引言
网络编程是指编写能够在计算机网络上进行通信的程序的过程。网络编程涉及使用各种协议和技术来实现不同类型的网络通信，例如传输文件、发送电子邮件、浏览网页等。在网络编程中，通常涉及两个或多个计算机之间的数据交换，这些计算机通过网络连接在一起。



# 网络编程


常见服务和对应端口号  

| 端口 | 对应服务   |
| ---- | ---------- |
| 7    | Echo服务器 |
| 21   | Ftp        |
| 23   | telnet     |
| 25   | SMTP       |
| 79   | Finger     |
| 80   | HTTP       |
| 110  | POP3       |
| 143  | IMAP       |
| 443  | HTTPS      |


## TCP通信

### Socket概念

一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于**特权端口**，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。

当Socket连接成功地在服务器端和客户端之间建立后：

- 对服务器端来说，它的Socket是指定的IP地址和指定的端口号；
- 对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。

Socket通常用来实现client-server连接。`java.net`包中定义的两个类`Socket`和`ServerSocket`,分别用来实现双向连接的`client`和`server`端.  

创建`TCP Socket`需要的四个信息：

- 本地系统的`IP`
- 本地应用程序使用的`TCP`端口号
- 远程系统的`IP`
- 远程应用程序相应的`TCP`端口号  

### InetAddress类

`InetAddress` 类表示互联网协议 (IP) 地址。它提供了一种将 IP 地址和主机名之间进行转换的方法，以及创建原始套接字时所需的一些其他方法。`InetAddress` 类是用于网络编程的基础之一，可以用来确定主机的 IP 地址，或者将 IP 地址转换为主机名。

要获取`InetAddress` 类实例，可以使用其静态方法：

- `InetAddress getByAddress(byte[] addr)`：根据原始 IP 地址获取 `InetAddress` 实例。
- `InetAddress getByAddress(String host, byte[] addr)`：根据主机名和原始 IP 地址获取 `InetAddress` 实例。
- `InetAddress getByName(String host)`：根据主机名获取 `InetAddress` 实例。
- `InetAddress[] getAllByName(String host)`：根据主机名获取所有与之关联的 `InetAddress` 实例数组。
- `InetAddress getLocalHost()`：获取本地主机的 `InetAddress` 实例。

这些静态方法可用于创建 `InetAddress` 实例，以便与网络通信。

`InetAddress` 类的常用方法包括：

- `getHostName()`：获取主机名。
- `getCanonicalHostName()`：获取主机的全限定域名。
- `getHostAddress()`：获取主机的 IP 地址字符串。
- `isReachable(int timeout)`：测试是否可以达到该主机，在指定的超时时间内。
- `isReachable(NetworkInterface netif, int ttl, int timeout)`：测试是否可以达到该主机，使用指定的网络接口和生存时间（TTL）。

这些方法可用于获取主机名、IP 地址、测试主机的可达性等操作。

### Socket类

`Socket` 类在 Java 网络编程中扮演着重要的角色，它用于实现网络中的两个端点之间的通信。一个 `Socket` 实例表示一个网络中的端点，它可以用于发送和接收数据。`Socket` 可以连接到远程主机的某个端口，以便与之通信，也可以监听本地端口，等待其他程序的连接请求。

总的来说，`Socket` 的主要作用包括：

- **建立连接：** 客户端使用 `Socket` 来连接到服务器端的主机和端口，从而建立网络连接。
- **发送和接收数据：** 通过 `Socket` 实例，可以发送数据到连接的另一端，并从另一端接收数据。
- **实现网络应用：** `Socket` 是实现网络应用的基础，例如 Web 客户端、服务器、邮件客户端等。

在 Java 中，`Socket` 类用于实现传输层的 TCP 协议，而 `ServerSocket` 则用于在服务器端监听和接受客户端连接请求。

**Socket类构造器**  

- `Socket()`: 创建一个未连接的Socket对象。
- **`Socket(InetAddress address, int port)`: 创建一个Socket对象，并将其连接到指定的远程地址和端口号。**
- `Socket(InetAddress address, int port, boolean stream)`: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，指定是否使用流模式。
- `Socket(InetAddress address, int port, InetAddress localAddr, int localPort)`: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，并绑定到指定的本地地址和端口号。
- `Socket(String host, int port)`: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号。
- `Socket(String host, int port, boolean stream)`: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，指定是否使用流模式。
- `Socket(String host, int port, InetAddress localAddr, int localPort)`: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，并绑定到指定的本地地址和端口号。
- `ServerSocket(int port)`: 创建一个`ServerSocket`对象，绑定到指定的端口号。
- `ServerSocket(int port, int count)`: 创建一个`ServerSocket`对象，绑定到指定的端口号，并指定等待连接的队列长度。

**Socket的常用方法**  

- `connect(SocketAddress endpoint)`: 连接到指定的远程端点。
- **`getInputStream()`: 返回此套接字的输入流。**
- **`getOutputStream()`: 返回此套接字的输出流。**
- `close()`: 关闭套接字连接。
- `isConnected()`: 返回套接字连接的状态。
- `isClosed()`: 返回套接字是否已关闭。
- **`getInetAddress()`: 获取远程连接的IP地址。**
- `getLocalAddress()`: 获取本地连接的IP地址。
- **`getPort()`: 获取远程连接的端口号。**
- `getLocalPort()`: 获取本地连接的端口号。
- `setSoTimeout(int timeout)`: 设置套接字的读取超时时间。
- `setKeepAlive(boolean on)`: 设置套接字是否在空闲时保持连接。
- `setTcpNoDelay(boolean on)`: 设置是否启用 Nagle 算法。

### ServerSocket类

`ServerSocket` 类是 Java 网络编程中用于创建服务器端的类。通过 `ServerSocket`，可以监听指定的端口，等待客户端的连接请求，并在建立连接后与客户端进行通信。

一般来说，使用 `ServerSocket` 的基本流程如下：

1. 创建一个 `ServerSocket` 实例，并指定服务器监听的端口。
2. 调用 `ServerSocket` 的 `accept()` 方法，该方法会阻塞程序，直到有客户端连接请求到达。
3. 一旦有连接请求到达，`accept()` 方法会返回一个 `Socket` 实例，代表与客户端的连接。
4. 使用返回的 `Socket` 实例与客户端进行通信，可以发送和接收数据。
5. 当通信结束后，关闭 `Socket` 实例，并继续等待下一个连接请求。

**构造器：**  

- **`ServerSocket(int port)`：用指定的端口`port`来创建一个侦听`Socket`。**
- `ServerSocket(int port, int backlog)`：加上一个用来改变连接队列长度的参数`backlog`。
- `ServerSocket(int port, int backlog, InetAddress localAddr)`：在机器存在多个`IP`地址的情况下，允许通过`localAddr`这个参数来指定侦听的`IP`地址。

**常用方法：**

- **`accept()`: 监听并接受到此套接字的连接。**
- `bind(SocketAddress endpoint)`: 将套接字绑定到特定的本地地址和端口。
- `close()`: 关闭套接字。
- `getInetAddress()`: 返回此套接字的本地地址。
- `getLocalPort()`: 返回此套接字绑定的本地端口。
- `setSoTimeout(int timeout)`: 设置通过`accept()`方法接受客户端连接的超时时间。
- `getSoTimeout()`: 获取通过`accept()`方法接受客户端连接的超时时间。

这些方法可用于管理`ServerSocket`的状态并与客户端进行通信。

### TCP使用实例

服务端程序编写  

1.  调用`ServerSocket(int port)`创建一个服务端套接字，并绑定到指定端口上；
2.  调用`accept()`监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；
3.  调用`socket`类的`getOutputStream()`和`getlnputStream()`获取输入流和输出流
4.  关闭`socket`；

客户端程序编写  

1.  调用`Socket()`创建流套接字，并链接到服务端；
2.  调用`socket`类的`getOutputStream()`和`getInputStream()`获取输入流和输出流；
3.  关闭`socket`；

客户端Socket的建立，链接服务器。  

```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        try {  
            Socket socket = new Socket("127.0.0.1", 2000);  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```

服务器端Socket的建立  

```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        ServerSocket server = null;  
        try {  
            server = new ServerSocket(2000);  
        } catch (IOException e) {  
            System.out.println("can not listen to :" + e);  
        }  
        Socket socket = null;  
        try {  
            socket = server.accept();  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```

打开输入/出流  

```java
PrintStream os = new PrintStream(new BufferedOutputStream(socket.getOutputStream());  
DataInputStream is = new DataInputStream(socket.getInputStream());
```

关闭Socket  

```java
os.close();is.close();socket.close();
```

简单的`client`/`server`程序  

```java
package com.aotmd.test;  
import java.io.*;  
import java.net.ConnectException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings("resource")  
            ServerSocket s = new ServerSocket(8888);  
            while (true) {  
                Socket s1 = s.accept();  
                OutputStream os = s1.getOutputStream();  
                DataOutputStream dos = new DataOutputStream(os);  
                dos.writeUTF("Hello," + s1.getInetAddress() + "port#" + s1.getPort() + "bye-bye!");  
                dos.close();  
                s1.close();  
                // s.close();  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        try {  
            Socket s1 = new Socket("127.0.0.1", 8888);  
            InputStream is =s1.getInputStream();  
            DataInputStream dis = new DataInputStream(is);  
            System.out.println(dis.readUTF());  
            dis.close();  
            s1.close();  
        } catch (ConnectException connExc) {  
            System.err.println("服务器连接失败！");  
        } catch (IOException e) {  
        }  
    }  
}
```

先运行服务器,然后运行客户端,会收到服务器发的信息.  

例子二  

```java
class Server1 {
    public static void main(String[] args) throws IOException {
        ServerSocket server = null;
        try {
            server = new ServerSocket(1234);
            while (true) {
                Socket sk = server.accept();
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sk.getOutputStream()));
                bw.write("你好，端口" + sk.getPort() + "，你成功连接了服务器：" + server.getLocalPort()+"\n");
                bw.flush();
                BufferedReader br = new BufferedReader(new InputStreamReader(sk.getInputStream()));
                System.out.println(sk.getPort() +":"+br.readLine());
                br.close();
                bw.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            server.close();
        }
    }
}
class Client1 {
    public static void main(String[] args) {
        Socket client;
        PrintStream ps;
        try {
            client = new Socket("localhost", 1234);
            BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
            System.out.println(br.readLine());
            ps = new PrintStream(client.getOutputStream());
            ps.println("哦，真好！");
            ps.flush();
            client.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

例子三：

服务端：

```java
class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(6666); // 监听指定端口
        System.out.println("服务器正在运行...");
        for (;;) {
            Socket sock = ss.accept();//每有一个新客户端就返回一个Socket
            System.out.println("connected from " + sock.getRemoteSocketAddress());
            // 用新线程处理
            Thread t = new Thread(()->{
                try (InputStream input = sock.getInputStream();
                     OutputStream output = sock.getOutputStream()
                ) {
                    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
                    BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
                    writer.write("你好!\n");//注意加换行符，要不然客户端不会结束读取。
                    writer.flush();
                    for (;;) {
                        String s = reader.readLine();//若没有新内容则阻塞。
                        if (s.equals("再见")) {
                            writer.write("再见\n");
                            writer.flush();
                            break;//结束线程
                        }
                        writer.write("好的: " + s + "\n");
                        writer.flush();
                    }
                } catch (Exception e) {
                    try {
                        sock.close();
                    } catch (IOException ioe) {
                    }
                    System.out.println("客户端已断开连接.");
                }
            });
            t.start();
        }
    }
}
```

代码`ss.accept()`表示每当有新的客户端连接进来后，就返回一个`Socket`实例，这个`Socket`实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，就必须为每个新的`Socket`创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。

如果没有客户端连接进来，`accept()`方法会阻塞并一直等待。如果有多个客户端同时连接进来，`ServerSocket`会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用`accept()`就可以获取新的连接。

客户端：

```java
class Client {
    public static void main(String[] args) throws IOException {
        Socket sock = new Socket("localhost", 6666); // 连接指定服务器端口
        try (InputStream input = sock.getInputStream();
             OutputStream output = sock.getOutputStream()) {
            var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
            var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
            Scanner scanner = new Scanner(System.in);
            System.out.println("[服务器] " + reader.readLine());
            for (;;) {
                System.out.print(">>> "); // 打印提示
                String s = scanner.nextLine(); // 读取一行输入
                writer.write(s);
                writer.newLine();//换行符
                writer.flush();
                String resp = reader.readLine();// 若没有新内容则阻塞。
                System.out.println("<<< " + resp);
                if (resp.equals("再见")) {
                    break;
                }
            }
        }
        sock.close();
        System.out.println("断开连接.");
    }
}
```

当Socket连接创建成功后，无论是服务器端，还是客户端，都使用`Socket`实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用`InputStream`和`OutputStream`来封装Socket的数据流，这样使用Socket的流，和普通IO流类似：

```java
// 用于读取网络数据:
InputStream in = sock.getInputStream();
// 用于写入网络数据:
OutputStream out = sock.getOutputStream();
```

如果不调用`flush()`，很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而又想强制把这些数据发送到网络，就必须调用`flush()`强制把缓冲区数据发送出去。

**URL与Socket通信的区别**

利用`URL`进行通信与利用`socket`进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：  

利用`socket`进行通信时，在服务器端运行一个`socket`通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在`socket`通信方式中，服务器是主动等待连接通信的到来。  

利用`URL`进行通信时，在服务器端常驻一个`CGI`程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在`URL`通信方式中，服务器是被动等待连接通信的到来。  

## UDP通信

在基于`TCP/IP`网络体系结构的网络中主要使用`TCP`和`UDP`（`UserDatagramProtocol`，用户数据报协议）来实现数据通信。`TCP`是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而`UDP`则是一种面向无连接的不可靠传输协议，它**不能**确保数据能正确到达目的端，但是它能**提高网络通信的效率**。  

在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。

**UDP Socket特性**  

通过UDP的UDP端口来实现UDP协议的网络通信。  

其工作过程如下：  

- 创建一个适当的要发送且注明收发人地址数据报；  
- 为一个特定的应用程序建立一个传输端口来传送和接收数据包；  
- 将数据报插入一个传输端口中进行传输；  
- 等待接收来自于传输端口的一个数据报；  
- 解码数据报以解开消息、接收者和其它信息；  

### DatagramSocket类

`DatagramSocket` 类是用于实现 UDP 协议的套接字。

构造方法：  

- `DatagramSocket()`：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）  
- **`DatagramSocket(int port)`：创建实例，并固定监听`Port`端口的报文。通常用于服务端**  
- `DatagramSocket(int port,InetAddress localAddr)`：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自`LocalAddr`的报文。  

方法：

- `void bind(SocketAddress addr)`：将套接字绑定到指定的本地地址和端口号。
- `void close()`：关闭套接字。
- **`void connect(InetAddress address, int port)`：将套接字连接到指定的远程主机和端口号。**
- `void disconnect()`：断开与远程主机的连接。
- `boolean getBroadcast()`：获取套接字的广播状态。
- `Object getOption(int optID)`：获取套接字选项的当前值。
- `int getPort()`：获取套接字绑定的本地端口号。
- `SocketAddress getLocalSocketAddress()`：获取套接字绑定的本地地址。
- `InetAddress getLocalAddress()`：获取套接字绑定的本地 IP 地址。
- `int getLocalPort()`：获取套接字绑定的本地端口号。
- `SocketAddress getRemoteSocketAddress()`：获取套接字连接的远程地址。
- `boolean isBound()`：检查套接字是否绑定到本地地址。
- `boolean isConnected()`：检查套接字是否连接到远程主机。
- **`void receive(DatagramPacket p)`：接收一个数据包。**
- **`void send(DatagramPacket p)`：发送一个数据包。**
- `void setBroadcast(boolean on)`：设置套接字的广播状态。
- `void setOption(int optID, Object value)`：设置套接字选项的值。
- **`void setSoTimeout(int timeout)`：设置套接字的超时时间（接收数据时的超时时间）。**
- `int getSoTimeout()`：获取套接字的超时时间。
- `String toString()`：返回套接字的字符串表示形式。

------

### DatagramPacket类

`DatagramPacket` 类表示数据报包，它包含了要发送或接收的数据以及目标地址和端口号等信息。

常用构造方法：

- **`DatagramPacket(byte[] buf, int length)`: 创建一个数据报包，用于发送长度为 `length` 的数据，数据存储在 `buf` 中。**
- `DatagramPacket(byte[] buf, int length, InetAddress address, int port)`: 创建一个数据报包，用于发送长度为 `length` 的数据到指定的地址和端口。
- `DatagramPacket(byte[] buf, int offset, int length)`: 创建一个数据报包，用于发送从 `buf` 的偏移量 `offset` 开始的 `length` 长度的数据。
- **`DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)`: 创建一个数据报包，用于发送从 `buf` 的偏移量 `offset` 开始的 `length` 长度的数据到指定的地址和端口。**
- `DatagramPacket(byte[] buf, int length, SocketAddress address)`: 创建一个数据报包，用于发送长度为 `length` 的数据到指定的地址和端口。
- `DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)`: 创建一个数据报包，用于发送从 `buf` 的偏移量 `offset` 开始的 `length` 长度的数据到指定的地址和端口。

这些构造方法可以用于创建不同类型的数据报包，以便发送或接收数据。

方法：

- `DatagramPacket(byte[] buf, int length)`：使用指定的缓冲区和长度创建一个 DatagramPacket，用于接收数据。
- `DatagramPacket(byte[] buf, int length, InetAddress address, int port)`：使用指定的缓冲区、长度、远程主机地址和端口号创建一个 DatagramPacket，用于发送数据。
- **`byte[] getData()`：返回数据缓冲区。**
- **`void setData(byte[] buf)`：设置数据缓冲区。**
- **`int getLength()`：返回数据缓冲区的长度。**
- `void setLength(int length)`：设置数据缓冲区的长度。
- `InetAddress getAddress()`：返回远程主机的地址。
- `void setAddress(InetAddress address)`：设置远程主机的地址。
- `int getPort()`：返回远程主机的端口号。
- `void setPort(int port)`：设置远程主机的端口号。
- `SocketAddress getSocketAddress()`：返回远程主机的地址和端口号。
- `void setSocketAddress(SocketAddress address)`：设置远程主机的地址和端口号。
- `void setData(byte[] buf, int offset, int length)`：设置数据缓冲区的一部分。
- `void setData(ByteBuffer buf)`：设置数据缓冲区。
- `ByteBuffer getData()`：返回数据缓冲区。
- **`int getOffset()`：返回数据缓冲区的偏移量。**
- `void setOffset(int offset)`：设置数据缓冲区的偏移量。
- `void setLength(int length, InetAddress address, int port)`：设置数据缓冲区的长度、远程主机地址和端口号。
- `void setAddress(InetAddress address, int port)`：设置远程主机的地址和端口号。
- `void setAddress(SocketAddress address)`：设置远程主机的地址和端口号。
- `SocketAddress getLocalSocketAddress()`：返回本地主机的地址和端口号。

这些方法可以在数据报包中读取和设置数据，以及获取目标地址和端口号等信息。

------

### UDP使用实例

在服务器端，使用UDP也需要监听指定的端口。

```java
DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口
for (;;) { // 无限循环
    // 数据缓冲区:
    byte[] buffer = new byte[1024];
    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
    ds.receive(packet); // 收取一个UDP数据包,阻塞
    // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度，将其按UTF-8编码转换为String:
    String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
    System.out.println(s);
    // 发送数据:
    byte[] data = "ACK".getBytes(StandardCharsets.UTF_8);
    packet.setData(data);//设置数据包。
    ds.send(packet);//发送
}
```

当服务器收到一个`DatagramPacket`后，通常必须立刻回复一个或多个UDP包，因为客户端地址在`DatagramPacket`中，每次收到的`DatagramPacket`可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。UDP 是无连接的协议，服务器在接收到 UDP 数据报后，通常需要**立即**给客户端发送响应，以确保通信的连续性和可靠性。没有响应的话，客户端**可能会超时或者认为连接失败**。

客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：

```java
DatagramSocket ds = new DatagramSocket();
ds.setSoTimeout(1000);//设置超时时间
ds.connect(InetAddress.getByName("localhost"), 6666); // 连接指定服务器和端口

byte[] data = "Hello".getBytes();
DatagramPacket packet = new DatagramPacket(data, data.length);
ds.send(packet);// 发送

byte[] buffer = new byte[1024];
packet = new DatagramPacket(buffer, buffer.length);
ds.receive(packet);// 收取一个UDP数据包,阻塞,超过超时时间则异常
String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());
System.out.println(resp);
ds.disconnect();// 关闭
ds.close();
```

客户端创建`DatagramSocket`实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用`setSoTimeout(1000)`设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。

客户端的`DatagramSocket`还调用了一个`connect()`方法“连接”到指定的服务器端。

这个`connect()`方法不是真连接，它是为了在客户端的`DatagramSocket`实例中保存服务器端的IP和端口号，确保这个`DatagramSocket`实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。

后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。

如果客户端认为通信结束，就可以调用`disconnect()`断开连接：

```java
ds.disconnect();
```

`disconnect()`也不是真正地断开连接，它只是清除了客户端`DatagramSocket`实例记录的远程服务器地址和端口号，这样，`DatagramSocket`实例就可以连接另一个服务器端。

如果客户端希望向两个不同的服务器发送UDP包，有两种方法：

1. 客户端可以创建两个`DatagramSocket`实例，用`connect()`连接到不同的服务器；
2. 客户端也可以不调用`connect()`方法，而是在创建`DatagramPacket`的时候指定服务器地址，这样可以用一个`DatagramSocket`实例发送`DatagramPacket`到不同的服务器。

不调用`connect()`方法的代码如下：

```java
DatagramSocket ds = new DatagramSocket();
ds.setSoTimeout(1000);
InetAddress localhost = InetAddress.getByName("localhost");
// 发送到localhost:6666:
byte[] data1 = "Hello".getBytes();
var packet1 = new DatagramPacket(data1, data1.length, localhost, 6666);
ds.send(packet1);
// 发送到localhost:8888:
byte[] data2 = "Hi".getBytes();
var packet2 = new DatagramPacket(data2, data2.length, localhost, 8888);
ds.send(packet2);
// 关闭:
ds.close();
```



## 发送Email

Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如`abc@example.com`，邮件软件比如Outlook都是用来收发邮件的。

使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。

传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：

```ascii
           ┌──────────┐    ┌──────────┐
           │PostOffice│    │PostOffice│     .───.
┌─────┐    ├──────────┤    ├──────────┤    (   ( )
│═══ ░│──▶│ ┌─┐ ┌┐┌┐  │──▶│ ┌─┐ ┌┐┌┐ │──▶ `─┬─'
└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
           └─┴─┴──────┘    └─┴─┴──────┘       │
```

电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：

```ascii
             ┌─────────┐    ┌─────────┐    ┌─────────┐
             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
│       │──▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀──│       │
└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
   MUA           MTA            MTA            MDA           MUA
```

类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；

邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；

最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。

电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。

MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。

MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。

SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，无需关心SMTP协议的底层原理，只需要使用`JavaMail`这个标准API就可以直接发送邮件。

注：若在web邮箱中设置了“保存到已发送”，使用客户端SMTP服务发信时，已发邮件也会自动同步到网页端“已发送”文件夹内。

------

假设准备使用自己的邮件地址`me@example.com`给小明发送邮件，已知小明的邮件地址是`xiaoming@somewhere.com`，发送邮件前，首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是`smtp.example.com`，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：

- QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；
- 163邮箱：SMTP服务器是smtp.163.com，端口是465；
- Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。

有了SMTP服务器的域名和端口号，还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。

使用`JavaMail`发送邮件，需要把`JavaMail`相关的两个依赖加入进来，注意版本号相同：

```xml
<!-- https://mvnrepository.com/artifact/jakarta.mail/jakarta.mail-api -->
<dependency>
    <groupId>jakarta.mail</groupId>
    <artifactId>jakarta.mail-api</artifactId>
    <version>2.0.1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.sun.mail/jakarta.mail -->
<dependency>
    <groupId>com.sun.mail</groupId>
    <artifactId>jakarta.mail</artifactId>
    <version>2.0.1</version>
</dependency>
```

这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：

```xml
<!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api -->
<dependency>
    <groupId>javax.mail</groupId>
    <artifactId>javax.mail-api</artifactId>
    <version>1.6.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.sun.mail/javax.mail -->
<dependency>
    <groupId>com.sun.mail</groupId>
    <artifactId>javax.mail</artifactId>
    <version>1.6.2</version>
</dependency>
```

并且代码引用的`jakarta.mail`需替换为`javax.mail`。

------

### 验证发送方信息

`Session`类是`JavaMail` API中表示邮件会话的类，它包含了创建和管理邮件的相关方法。以下是`Session`类的一些常用方法：

- **`getSession(Properties props, Authenticator authenticator)`：静态方法，用于获取`Session`实例。需要传入`Properties`对象和`Authenticator`对象来配置会话属性和认证信息。**
- `getTransport(String protocol)`：获取指定协议的`Transport`对象，用于发送邮件。
- `getStore(String protocol)`：获取指定协议的`Store`对象，用于接收邮件。
- `getDebug()`：获取调试模式的状态。
- **`setDebug(boolean debug)`：设置调试模式的状态。**
- `setProtocolForAddress(String type, String protocol)`：设置指定地址类型对应的协议。
- `setProvider(Provider provider)`：设置指定协议的提供者。
- `getProperty(String name)`：获取指定属性名的属性值。
- `setProperty(String name, String value)`：设置指定属性名的属性值。
- `getDefaultInstance(Properties props, Authenticator authenticator)`：静态方法，获取默认的`Session`实例。

这些方法可以帮配置和管理邮件会话，以及创建`Transport`和`Store`对象来发送和接收邮件。

------

`Session` 可以配置的一些常见属性包括：

- **`mail.smtp.host`: SMTP 服务器主机名。**
- **`mail.smtp.port`: SMTP 服务器端口号。**
- **`mail.smtp.auth`: 指定是否需要进行用户认证，通常为 `"true"`。**
- `mail.smtp.starttls.enable`: 指定是否启用 STARTTLS 加密，通常为 `"true"`。
- `mail.smtp.socketFactory.fallback`: 指定是否在连接失败时回退到普通套接字，通常为 `"false"`。
- `mail.smtp.socketFactory.port`: 指定用于创建 SMTP 套接字的端口号，通常与 `mail.smtp.port` 相同。
- `mail.smtp.connectiontimeout`: 设置连接超时时间，以毫秒为单位。
- `mail.smtp.timeout`: 设置读取超时时间，以毫秒为单位。
- `mail.smtp.writetimeout`: 设置写入超时时间，以毫秒为单位。
- `mail.smtp.from`：设置发件人地址。
- `mail.smtp.user`：设置 SMTP 认证的用户名。
- `mail.smtp.password`：设置 SMTP 认证的密码。
- **`mail.smtp.socketFactory.class`: 指定用于创建 SMTP 套接字的 `SocketFactory` 类的名称， 可以设置为 `javax.net.ssl.SSLSocketFactory`，用于创建 SSL 套接字。**
- **`mail.smtp.ssl.enable`：指定是否启用 SSL 安全连接。**
- `mail.smtp.ssl.trust`：指定信任的 SSL 服务器主机名列表。
- `mail.smtp.ssl.protocols`：指定使用的 SSL 协议列表。
- `mail.smtp.ssl.ciphersuites`：指定使用的 SSL 加密套件列表。

中间的协议名改成对应的协议。这些属性可以用于配置 `Session` 实例，以控制邮件发送的行为和连接设置。

------

通过`JavaMail` API连接到SMTP服务器上：

```java
import jakarta.mail.Authenticator;
import jakarta.mail.PasswordAuthentication;
import jakarta.mail.Session;
...
// 服务器地址:
String smtp = "smtp.163.com";
// 登录用户名:
String username = "XXX@163.com";
// 登录口令:
String password = "********";
// 连接到SMTP服务器587端口:
Properties props = new Properties();
props.put("mail.smtp.host", "smtp.163.com"); // SMTP主机名
props.put("mail.smtp.port", "587"); // 主机端口号
props.put("mail.smtp.auth", "true"); // 是否需要用户认证
props.put("mail.smtp.starttls.enable", "false"); // 不启用TLS加密
props.put("mail.smtp.ssl.enable", "true"); // 启用SSL加密
props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
// 获取Session实例:
Session session = Session.getInstance(props, new Authenticator() {
    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(username, password);
    }
});
// 设置debug模式便于调试:
session.setDebug(true);
```

以587端口为例，连接SMTP服务器时，需要准备一个`Properties`对象，填入相关信息。获取`Session`实例时，如果服务器需要认证，还需要传入一个`Authenticator`对象，用于提供用户名和密码进行身份验证。获取到`Session`实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。

SSL加密协议就用587端口，并改成以下代码：

```java
props.put("mail.smtp.port", "587"); // 主机端口号
props.put("mail.smtp.starttls.enable", "false"); // 不启用TLS加密
props.put("mail.smtp.ssl.enable", "true"); // 启用SSL加密
props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
```

TLS就用25端口（非SSL协议，看服务器传回的消息里表示会判断这个）：

```java
props.put("mail.smtp.port", "25"); // 主机端口号
props.put("mail.smtp.starttls.enable", "true"); // 启用TLS加密
```

### 发送邮件

`MimeMessage`是`Message`的实现类，用于创建多部分邮件消息。`MimeMessage`类提供了多个构造方法，主要用于创建不同类型的消息。以下是`MimeMessage`类的一些常用构造方法：

- **`MimeMessage(Session session)`：使用指定的`Session`对象创建`MimeMessage`实例。**
- `MimeMessage(Session session, InputStream is)`：使用指定的`Session`对象和输入流创建`MimeMessage`实例，从输入流中读取消息内容。
- `MimeMessage(MimeMessage source)`：使用另一个`MimeMessage`实例创建新的`MimeMessage`实例，复制源消息的内容。
- `MimeMessage(Session session, byte[] content)`：使用指定的`Session`对象和字节数组创建`MimeMessage`实例，字节数组包含消息的原始内容。
- `MimeMessage(Session session, InputStream is, InternetHeaders headers)`：使用指定的`Session`对象、输入流和邮件头信息创建`MimeMessage`实例，用于处理邮件头和消息内容分开的情况。

------

`MimeMessage`类提供了许多方法，用于**设置和获取邮件消息的各种属性和内容**。以下是`MimeMessage`类的一些常用方法：

- `setSubject(String subject)`：设置邮件的主题为指定的字符串。
- **`setSubject(String subject, String charset)`：设置邮件的主题为指定的字符串，并指定字符集。**
- `setSubject(MimeMessage.RecipientType type, String subject)`：设置邮件的特定类型（如收件人、抄送人、密送人）的主题。
- `setSubject(String subject, String charset, String encoding)`：设置邮件的主题为指定的字符串，并指定字符集和编码方式。
- `setSubject(String subject, String charset, String encoding, MimeUtility.EncodedWord.Encoder encoder)`：设置邮件的主题为指定的字符串，并指定字符集、编码方式和编码器。
- **`setFrom(Address address)`：设置发件人地址。**
- **`setRecipient(Message.RecipientType type, Address address)`：设置收件人、抄送人或密送人地址。**
   - `Message.RecipientType.TO`：主要收件人（"To"）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。
   - `Message.RecipientType.CC`：抄送（"Cc"），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。
   - `Message.RecipientType.BCC`：秘密抄送（"Bcc"），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。
- **`setContent(Object content, String contentType)`：设置邮件内容和内容类型。内容可以是字符串、字节数组或`Multipart`对象。**
- **`setText(String text)`：设置纯文本邮件的内容。可以指定第二个参数文字编码，还可以指定第三个参数设置消息的子类型html或plain：**
- `setSentDate(Date date)`：设置邮件的发送日期。
- `addHeader(String name, String value)`：添加邮件头。
- `saveChanges()`：保存对邮件的更改。
- `getSubject()`：获取邮件主题。
- `getFrom()`：获取发件人地址。
- `getRecipients(Message.RecipientType type)`：获取指定类型的收件人、抄送人或密送人地址。
- `getContent()`：获取邮件内容。
- `getSentDate()`：获取邮件发送日期。
- `getAllHeaders()`：获取所有邮件头。
- `getHeader(String name)`：根据名称获取邮件头的值。
- `removeHeader(String name)`：移除指定名称的邮件头。
- `getContentType()`：获取邮件内容类型。

这些方法可以对邮件消息进行各种操作，包括设置和获取邮件的属性、内容，以及添加和移除邮件头等。

------

`InternetAddress` 类用于表示**电子邮件地址**。它有几种不同的构造方法，可以根据需要选择使用：

- **`InternetAddress(String address)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例。**
- `InternetAddress(String address, boolean strict)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例，并指定是否启用严格模式。
- `InternetAddress(String address, String personal)`：使用给定的电子邮件地址字符串和个人名称创建一个 `InternetAddress` 实例。
- **`InternetAddress(String address, String personal, String charset)`：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 `InternetAddress` 实例。**
- `InternetAddress(String address, String personal, String charset, boolean strict)`：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 `InternetAddress` 实例。

------

`InternetAddress` 类还提供了一些常用的方法，用于处理电子邮件地址的操作，例如：

- `String getAddress()`：获取电子邮件地址的地址部分（不包括个人名称）。
- `String getPersonal()`：获取电子邮件地址的个人名称部分。
- `void setAddress(String address)`：设置电子邮件地址的地址部分。
- `void setPersonal(String personal)`：设置电子邮件地址的个人名称部分。
- `String getType()`：获取电子邮件地址的类型。
- `void setType(String type)`：设置电子邮件地址的类型。
- `boolean isGroup()`：检查该地址是否表示一个邮件组。
- `boolean isUnicodeSupported()`：检查是否支持 Unicode 编码。
- `String toString()`：将 `InternetAddress` 对象转换为字符串表示形式。

------

`Transport` 类用于**发送邮件消息**。以下是 `Transport` 类的一些常用方法：

- **`send(Message message)`：发送邮件消息。**
- `connect()`：连接到邮件服务器。
- `connect(String host, String user, String password)`：连接到指定主机的邮件服务器。
- `close()`：关闭连接。
- `addConnectionListener(ConnectionListener listener)`：添加连接监听器。
- `removeConnectionListener(ConnectionListener listener)`：移除连接监听器。
- `addTransportListener(TransportListener listener)`：添加传输监听器。
- `removeTransportListener(TransportListener listener)`：移除传输监听器。
- `isConnected()`：检查是否已连接到邮件服务器。
- `isSSL()`：检查是否使用 SSL 连接。
- `getURLName()`：获取连接的 URL 名称。
- `setURLName(URLName urlname)`：设置连接的 URL 名称。
- `setDebug(boolean debug)`：设置调试模式，用于输出调试信息。

这些方法可以连接到邮件服务器并发送邮件消息。

------

发送邮件时，需要构造一个`Message`对象，然后调用`Transport.send(Message)`即可完成发送：

```java
import jakarta.mail.internet.MimeMessage;
import jakarta.mail.internet.InternetAddress;
import jakarta.mail.MimeMessage;
import jakarta.mail.Transport;
...
MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress("xiaoming@somewhere.com"));
// 设置邮件主题:
message.setSubject("你好!", "UTF-8");
// 设置邮件正文:
message.setText("这是一幅邮件", "UTF-8");
// 发送:
Transport.send(message);
```

绝大多数邮件服务器要求**发送方地址和登录用户名必须一致**，否则发送将失败。

填入真实的地址，运行上述代码，可以在控制台看到`JavaMail`打印的调试信息：

```text
这是JavaMail打印的调试信息:
DEBUG: setDebug: Jakarta Mail version 2.0.1
DEBUG: getProvider() returning jakarta.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]
DEBUG SMTP: need username and password for authentication
DEBUG SMTP: protocolConnect returning false, host=smtp.163.com, user=XXX, password=<null>
DEBUG SMTP: useEhlo true, useAuth true
DEBUG SMTP: trying to connect to host "smtp.163.com", port 587, isSSL true
220 163.com Anti-spam GT for Coremail System (163com[20141201])
开始尝试连接smtp.163.comm:
DEBUG SMTP: connected to host "smtp.163.com", port: 587, ...
发送命令EHLO:
EHLO localhost
SMTP服务器响应250:
...
发送命令STARTTLS:
STARTTLS
SMTP服务器响应250:
...
尝试登录:
DEBUG SMTP: protocolConnect login, host=smtp.163.com, user=XXX@163.com, password=<non-null>
DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 
DEBUG SMTP: Using mechanism LOGIN
DEBUG SMTP: AUTH LOGIN command trace suppressed
登录成功:
DEBUG SMTP: AUTH LOGIN succeeded
DEBUG SMTP: use8bit false
开发发送邮件，设置FROM:
MAIL FROM:发件人
250 2.1.0 Sender OK
设置TO:
RCPT TO:收件人
250 2.1.5 Recipient OK
发送邮件数据:
DATA
服务器响应354:
354 End data with <CR><LF>.<CR><LF>
真正的邮件数据:
Date: 时间
From: 发送方
To: 收件方
Message-ID: <283383329.0.1713860754302@localhost>
邮件主题是编码后的文本:
Subject: =?UTF-8?B?5L2g5aW9IQ==?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

邮件正文是Base64编码的文本:
5oiR5Y+R5LqG5LiA5Lu96YKu5Lu2
发送成功:
DEBUG SMTP: message successfully delivered to mail server
发送QUIT命令:
QUIT
服务器响应221结束TCP连接:
221 Bye
```

从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在[SMTP协议](https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt)中了，查看具体的响应码就可以知道出错原因。

**发送HTML邮件**

发送HTML邮件和文本邮件是类似的，只需要把：

```java
message.setText("这是一幅邮件", "UTF-8");
```

改为：

```java
message.setText("<h1>这是一幅邮件</h1>", "UTF-8", "html");
```

传入的`body`是类似`<h1>Hello</h1><p>Hi, xxx</p>`这样的HTML字符串即可。

### 发送附件

`MimeMultipart` 是 `JavaMail` 中用于处理多部分 MIME 消息的类，`MimeMultipart` 类有多个构造方法，用于创建不同类型的多部分消息。以下是一些常用的构造方法：

- **`MimeMultipart()`：创建一个空的多部分消息，默认使用混合 (`mixed`) 类型。**
- `MimeMultipart(String subtype)`：根据指定的子类型创建一个空的多部分消息。常用的子类型包括 `related`（相关）、`alternative`（备选）、`mixed`（混合）等。例如：
   - `MimeMultipart("related")`：创建一个相关类型的多部分消息。
   - `MimeMultipart("alternative")`：创建一个备选类型的多部分消息。
- `MimeMultipart(javax.mail.internet.ContentType contentType)`：根据指定的 `ContentType` 对象创建一个空的多部分消息。ContentType 对象可以包含主类型、子类型、参数等信息。
- `MimeMultipart(InputStream is)`：从输入流中读取内容，并根据读取的内容创建一个多部分消息。

这些构造方法提供了不同的方式来创建 `MimeMultipart` 对象，以满足不同场景下的需求。

**常用方法包括：**

- **`addBodyPart(BodyPart part)`：将一个 `BodyPart` 对象添加到多部分消息中。**
- `removeBodyPart(int index)`：从多部分消息中移除指定索引位置的 `BodyPart` 对象。
- `getBodyPart(int index)`：获取多部分消息中指定索引位置的 `BodyPart` 对象。
- `getBodyPart(String CID)`：根据 Content-ID（CID）获取多部分消息中对应的 `BodyPart` 对象。
- `getBodyPartCount()`：获取多部分消息中 `BodyPart` 对象的数量。
- `setSubType(String subtype)`：设置多部分消息的子类型（subtype），例如 "mixed"、"alternative" 等。
- `setPreamble(String preamble)`：设置消息的开头部分（preamble）。
- `setEpilogue(String epilogue)`：设置消息的结尾部分（epilogue）。
- `writeTo(OutputStream os)`：将多部分消息写入输出流中。

------

`MimeBodyPart` 类用于表示邮件的各个部分，包括正文、附件等。它的构造方法相对简单，通常使用默认构造方法创建对象，然后使用 `setContent` 等方法设置内容。以下是 `MimeBodyPart` 的构造方法：

- **默认构造方法：`MimeBodyPart()`**
- 使用输入流构造方法：`MimeBodyPart(InputStream is)`
- 使用 `DataSource` 对象构造方法：`MimeBodyPart(DataSource ds)`

`MimeBodyPart` 类的方法如下：

- `addHeader(String name, String value)`：添加指定名称和值的头信息。
- `addHeaderLine(String line)`：添加包含完整头信息行的字符串。
- `setContentID(String cid)`：设置内容 ID。
- `setContentLanguage(String[] languages)`：设置内容语言。
- `setContentTransferEncoding(String encoding)`：设置内容传输编码。
- **`setDataHandler(DataHandler dh)`：设置数据处理程序。**
- `setDescription(String description)`：设置描述信息。
- `setDisposition(String disposition)`：设置附件描述。
- **`setFileName(String filename)`：设置文件名。**
- `setHeader(String name, String value)`：设置指定名称的头信息值。
- `setText(String text)`：设置文本内容。
- `updateHeaders()`：更新所有头信息。
- `addRecipient(Message.RecipientType type, Address address)`：添加接收者地址。
- `getAllHeaders()`：获取所有头信息。
- `getContentType()`：获取内容类型。
- `getDataHandler()`：获取数据处理程序。
- `getDescription()`：获取描述信息。
- `getDisposition()`：获取附件描述。
- `getFileName()`：获取文件名。
- `getHeader(String name)`：根据名称获取头信息值。
- `getInputStream()`：获取输入流。
- `getLineCount()`：获取行数。
- `getSize()`：获取大小。
- `getText()`：获取文本内容。
- `isMimeType(String mimeType)`：检查是否与指定的 MIME 类型匹配。
- `removeHeader(String name)`：移除指定名称的头信息。
- `setContent(Multipart mp)`：设置内容为多部分。
- **`setContent(Object obj, String type)`：设置内容对象和类型。**
- `setContent(Multipart mp)`：设置内容为多部分。
- `setContentID(String cid)`：设置内容 ID。
- `setContentLanguage(String[] languages)`：设置内容语言。
- `setDataHandler(DataHandler dh)`：设置数据处理程序。
- `setDisposition(String disposition)`：设置附件描述。
- `setFileName(String filename)`：设置文件名。
- **`setHeader(String name, String value)`：设置指定名称的头信息值。**
- `setText(String text)`：设置文本内容。
- `setText(String text, String charset)`：设置文本内容和字符集。

这些方法可以用于配置和操作 `MimeBodyPart` 对象的各种属性和内容。

------

`DataHandler` 的构造方法通常用于创建一个处理特定数据类型的数据处理程序对象。它有以下几个常用的构造方法：

- `DataHandler(Object obj, String mimeType)`：使用给定的对象和 MIME 类型创建一个 `DataHandler` 对象。这个构造方法通常用于将 Java 对象转换为数据处理程序。
- `DataHandler(URL url)`：使用给定的 URL 创建一个 `DataHandler` 对象。这个构造方法通常用于处理指向外部资源的 URL。
- `DataHandler(DataSource dataSource)`：使用给定的数据源创建一个 `DataHandler` 对象。这个构造方法通常用于处理数据源对象。

这些构造方法根据不同的数据类型和来源创建适当的数据处理程序对象，以便于在应用程序中处理和传输数据。

------

`ByteArrayDataSource` 的构造方法通常用于创建一个包含字节数组数据的数据源对象。它有以下两个常用的构造方法：

- `ByteArrayDataSource(byte[] data, String type)`：使用给定的字节数组和 MIME 类型创建一个 `ByteArrayDataSource` 对象。
- `ByteArrayDataSource(InputStream is, String type)`：使用给定的输入流和 MIME 类型创建一个 `ByteArrayDataSource` 对象。

这些构造方法将字节数组或输入流与 MIME 类型关联起来，以便于处理和传输数据。

------

常用文件的 MIME 类型如下：

- 文本文件：`text/plain`
- HTML 文件：`text/html`
- XML 文件：`application/xml`
- JSON 文件：`application/json`
- 图片文件：`image/jpeg`、`image/png`、`image/gif`、`image/webp`
- 视频文件：`video/mp4`、`video/quicktime`
- 音频文件：`audio/mpeg`、`audio/wav`
- PDF 文件：`application/pdf`
- Word 文档：`application/msword`、`application/vnd.openxmlformats-officedocument.wordprocessingml.document`
- Excel 表格：`application/vnd.ms-excel`、`application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
- PowerPoint 演示文稿：`application/vnd.ms-powerpoint`、`application/vnd.openxmlformats-officedocument.presentationml.presentation`
- 压缩文件：`application/zip`
- 二进制文件的 MIME 类型通常是 `application/octet-stream`。这个 MIME 类型通常用于表示未知的二进制数据类型，或者不属于其他已知 MIME 类型的二进制数据。

这些 MIME 类型可以帮助浏览器和其他应用程序识别文件的类型并采取相应的处理方式。

------

要在电子邮件中携带附件，就不能直接调用`message.setText()`方法，而是要构造一个`Multipart`对象：

```java
import jakarta.mail.internet.MimeBodyPart;
import jakarta.mail.internet.MimeMultipart;
import jakarta.mail.util.ByteArrayDataSource;
...
MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress("XXX"));
// 设置邮件主题:
message.setSubject("你好!", "UTF-8");
// 设置邮件正文:
Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent("<h1>这是一幅邮件</h1>", "text/html;charset=utf-8");
multipart.addBodyPart(textpart);
// 添加附件:
BodyPart annex = new MimeBodyPart();
annex.setFileName("附件1.7z");
annex.setDataHandler(new DataHandler(new ByteArrayDataSource(new FileInputStream("Maven.7z"), "application/octet-stream")));
multipart.addBodyPart(annex);
// 设置邮件内容为multipart:
message.setContent(multipart);
// 发送:
Transport.send(message);
```

一个`Multipart`对象可以添加若干个`BodyPart`，其中**第一个**`BodyPart`是文本，即邮件正文，后面的`BodyPart`是附件。

`BodyPart`依靠`setContent()`决定添加的内容。

如果添加文本，用`setContent("...", "text/plain;charset=utf-8")`添加纯文本，或者用`setContent("...", "text/html;charset=utf-8")`添加HTML文本。

如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个`DataHandler()`，传入文件的MIME类型。二进制文件可以用`application/octet-stream`，Word文档则是`application/msword`。

最后，通过`setContent()`把`Multipart`添加到`Message`中，即可发送。

`ByteArrayDataSource` 是 `javax.mail.util.ByteArrayDataSource` 类的一个子类，用于从字节数组中创建数据源对象。在这个特定的代码片段中，它的作用是将 `FileInputStream` 对象中的数据转换为字节数组，并将其作为数据源传递给 `DataHandler` 构造方法。

`DataHandler` 用于将数据封装为一种适合传输的格式，它可以处理各种类型的数据，如字节数组、文件、URL 等。在这里，`ByteArrayDataSource` 负责将文件中的数据读取到字节数组中，然后 `DataHandler` 将这个字节数组封装为一个数据处理程序，以便于传输和处理。

如果去掉`ByteArrayDataSource`，会报错：

```java
annex.setDataHandler(new DataHandler(new FileInputStream("3.png"), "image/png"));
```

报错是因为 `DataHandler` 的构造方法不接受 `FileInputStream` 对象作为参数，而是需要一个 `DataSource` 对象。`ByteArrayDataSource` 实现了 `DataSource` 接口，因此可以作为参数传递给 `DataHandler` 构造方法。如果直接将 `FileInputStream` 传递给 `DataHandler` 构造方法，它将无法识别并处理文件流，从而导致错误。因此，需要使用 `ByteArrayDataSource` 将文件流转换为 `DataSource` 对象，以便 `DataHandler` 可以正确处理图像数据。

### 发送内嵌图片的HTML邮件

`setHeader` 方法用于设置邮件头的值，其参数为邮件头的名称和对应的值。常用的邮件头包括但不限于：

- `From`：发件人地址。
- `To`：收件人地址。
- `Cc`：抄送地址。
- `Bcc`：密送地址。
- `Subject`：邮件主题。
- `Date`：邮件发送时间。
- `Content-Type`：内容类型。
- `Content-Disposition`：内容描述。
- **`Content-ID`：内容 ID。**
- `MIME-Version`：MIME 版本。
- `Reply-To`：回复地址。
- `Return-Path`：返回路径。
- `Message-ID`：消息 ID。

这些参数的设置可以根据邮件的需求和格式进行配置，以满足邮件发送的要求和格式规范。

------

HTML邮件中可以内嵌图片。如果给一个`<img src="http://example.com/test.jpg">`，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。

内嵌图片实际上也是一个附件，即邮件本身也是`Multipart`，但需要做一点额外的处理：

```java
MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress("XXX"));
// 设置邮件主题:
message.setSubject("你好!", "UTF-8");
// 设置邮件正文:
Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent("<h1>这是一个带图片的邮件</h1><p><img src='cid:img01'", "text/html;charset=utf-8");
multipart.addBodyPart(textpart);
// 添加附件:
BodyPart annex = new MimeBodyPart();
annex.setFileName("图片1.png");
annex.setDataHandler(new DataHandler(new ByteArrayDataSource(new FileInputStream("3.png"), "image/png")));
annex.setHeader("Content-ID","<img01>");
multipart.addBodyPart(annex);
// 设置邮件内容为multipart:
message.setContent(multipart);
// 发送:
Transport.send(message);
```

在HTML邮件中引用图片时，需要设定一个ID，用类似`<img src='cid:img01'">`引用，然后，在添加图片作为`BodyPart`时，除了要正确设置MIME类型（根据图片类型使用`image/jpeg`或`image/png`），还需要设置一个Header：`imagepart.setHeader("Content-ID", "<img01>");`。

### 发送给多个收件人

**设置收件人和发件人：**

- `addFrom(Address[] addresses)`: 添加发件人地址。
- `addFrom(String addresses)`: 添加发件人地址。
- `addRecipient(Message.RecipientType type, Address address)`: 添加指定类型的收件人地址。
- **`addRecipients(Message.RecipientType type, Address[] addresses)`: 添加指定类型的收件人地址。**
- **`addRecipients(Message.RecipientType type, String addresses)`: 添加指定类型的收件人地址。**
- `addRecipient(String type, String address)`: 添加指定类型的收件人地址。
- `addRecipients(String type, String addresses)`: 添加指定类型的收件人地址。
- `setFrom(Address address)`: 设置发件人地址。
- `setFrom(String address)`: 设置发件人地址。
- `setRecipient(Message.RecipientType type, Address address)`: 设置指定类型的收件人地址。
- `setRecipients(Message.RecipientType type, Address[] addresses)`: 设置指定类型的收件人地址。
- `setRecipients(Message.RecipientType type, String addresses)`: 设置指定类型的收件人地址。
- `setRecipient(String type, Address address)`: 设置指定类型的收件人地址。
- `setRecipients(String type, String addresses)`: 设置指定类型的收件人地址。
- `setReplyTo(Address[] addresses)`: 设置回复地址。

`Message.RecipientType`：

- `Message.RecipientType.TO`：主要收件人（"To"）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。
- `Message.RecipientType.CC`：抄送（"Cc"），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。
- `Message.RecipientType.BCC`：秘密抄送（"Bcc"），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。

------

要设置多个收件人，可以使用`addRecipients`方法或`setRecipients`方法。这些方法允许为消息的不同类型（如TO、CC、BCC）添加多个收件人。以下是使用这些方法设置多个收件人的示例：

```java
MimeMessage message = new MimeMessage(session);
// 添加多个收件人
message.addRecipients(Message.RecipientType.TO, "recipient1@example.com, recipient2@example.com");
// 或者使用数组
Address[] recipients = {
    new InternetAddress("recipient1@example.com"),
    new InternetAddress("recipient2@example.com")
};
message.addRecipients(Message.RecipientType.TO, recipients);
```

注意，在使用`addRecipients`方法时，**多个收件人应使用逗号分隔**。还可以使用类似的方法设置CC和BCC收件人。

`addRecipient`方法可以多次调用以添加多个收件人，而`setRecipient`方法会覆盖之前设置的收件人。因此，如果需要设置多个收件人，应该使用`addRecipient`方法。

如果需要设置收件人、抄送（CC）和密送（BCC）等多个收件人，应该使用`addRecipient`方法多次调用来添加不同类型的收件人。例如，可以按照以下方式设置多个收件人：

```java
message.setRecipient(Message.RecipientType.TO, new InternetAddress("recipient1@example.com"));
message.addRecipient(Message.RecipientType.TO, new InternetAddress("recipient2@example.com"));
message.addRecipient(Message.RecipientType.CC, new InternetAddress("cc@example.com"));
message.addRecipient(Message.RecipientType.BCC, new InternetAddress("bcc@example.com"));
```

而对于多个发件人，SMTP 协议规定邮件的 `From` 字段只能有一个发件人。如果需要发送给多个人，但每个人看到的发件人应该不同，可以考虑使用群发邮件的方式，即将所有收件人放在收件人列表中，但在邮件内容中区分不同的收件人。如果需要在邮件内容中显示不同的发件人，可以在邮件内容中自定义发件人的显示方式，例如在邮件正文中注明发件人姓名或其他标识。

### 设置别名

`InternetAddress` 类用于表示**电子邮件地址**。它有几种不同的构造方法，可以根据需要选择使用：

- `InternetAddress(String address)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例。
- `InternetAddress(String address, boolean strict)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例，并指定是否启用严格模式。
- `InternetAddress(String address, String personal)`：使用给定的电子邮件地址字符串和个人名称创建一个 `InternetAddress` 实例。
- **`InternetAddress(String address, String personal, String charset)`：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 `InternetAddress` 实例。**
- `InternetAddress(String address, String personal, String charset, boolean strict)`：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 `InternetAddress` 实例。

------

**`InternetAddress`可以很方便的设置别名**：

```java
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
```

**在字符串里，也可以设置别名**：

在字符串里给收件人设置别名的方法是使用 `<` 和 `>` 包裹完整的邮件地址，并在地址后面添加别名，格式如下：

```java
"别名1 <recipient1@example.com>, 别名2 <recipient2@example.com>"
```

例如，如果要将 "Alice" 和 "Bob" 添加到密送列表，可以这样做：

```java
message.addRecipients(Message.RecipientType.BCC, "Alice <alice@example.com>, Bob <bob@example.com>");
```

`InternetAddress`里也可以这样：

```java
InternetAddress address = new InternetAddress("别名 <recipient@example.com>");
```

但是不能同时设置字符集，那中文可能出问题，所以还是得这样：

```java
InternetAddress address = new InternetAddress("recipient@example.com>","别名","UTF-8");
```

或者这样：

```java
InternetAddress address = new InternetAddress("recipient@example.com");
address.setPersonal("别名", "UTF-8");
```



### 常见问题

如果用户名或口令错误，会导致`535`登录失败：

```
DEBUG SMTP: AUTH LOGIN failed
Exception in thread "main" javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
```

如果**登录用户和发件人不一致**，会导致`554`拒绝发送错误：

```
DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
```

有些时候，如果邮件主题和正文过于简单，会导致`554`被识别为垃圾邮件的错误：

```
DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
```

使用`JavaMail` API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；

某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。

## 接收Email

发送Email，客户端总是通过SMTP协议把邮件发送给MTA。

接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。

接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。

另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。

以下是 QQ 邮箱、163 邮箱和 Gmail 邮箱的 POP3 和 IMAP 服务器信息：

1. QQ 邮箱：
   - POP3 服务器：pop.qq.com
   - IMAP 服务器：imap.qq.com

2. 163 邮箱：
   - POP3 服务器：pop.163.com 或 pop3.163.com
   - IMAP 服务器：imap.163.com

3. Gmail 邮箱：
   - POP3 服务器：pop.gmail.com（默认端口号：995）
   - IMAP 服务器：imap.gmail.com（默认端口号：993）

对于 Gmail 邮箱，还需要启用“Less secure app access”或生成应用密码。Gmail 强制使用加密连接，请确保使用正确的端口号以及启用 SSL/TLS 加密连接。

**POP3与IMAP**

POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。

而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。

同时，**IMAP**像**POP3**那样提供了方便的邮件下载服务，让用户能进行离线阅读。**IMAP**提供的摘要浏览功能可以让你在阅读完所有的邮件到达时间、主题、发件人、大小等信息后才作出是否下载的决定。此外，**IMAP** 更好地支持了从多个不同设备中随时访问新邮件。

总之，**IMAP** 整体上为用户带来更为便捷和可靠的体验。**POP3** 更易丢失邮件或多次下载相同的邮件，而 **IMAP** 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。

### 登录邮箱

 `URLName` 类构造方法：

- `public URLName()`: 默认构造方法，创建一个空的 `URLName` 对象。
- `public URLName(String url)`: 使用给定的 URL 字符串创建一个 `URLName` 对象。该 URL 字符串应包含完整的 URL 信息，例如："protocol://host:port/file"。
- **`public URLName(String protocol, String host, int port, String file, String username, String password)`: 使用指定的协议、主机、端口、文件路径、用户名和密码创建一个 `URLName` 对象。用于表示需要身份验证的 URL。**
- `public URLName(String protocol, String host, int port, String file)`: 使用指定的协议、主机、端口和文件路径创建一个 `URLName` 对象，用户名和密码为空。通常用于表示不需要身份验证的 URL。
- `public URLName(URLName url)`: 复制构造方法，创建一个新的 `URLName` 对象，其内容与给定的 `URLName` 对象相同。

`URLName` 类中除了构造方法外还有一些常用的方法，例如：

- `public String getProtocol()`: 返回 URL 的协议部分。
- `public String getHost()`: 返回 URL 的主机部分。
- `public int getPort()`: 返回 URL 的端口部分。
- `public String getFile()`: 返回 URL 的文件路径部分。
- `public String getUsername()`: 返回 URL 的用户名部分。
- `public String getPassword()`: 返回 URL 的密码部分。
- `public void setProtocol(String protocol)`: 设置 URL 的协议部分。
- `public void setHost(String host)`: 设置 URL 的主机部分。
- `public void setPort(int port)`: 设置 URL 的端口部分。
- `public void setFile(String file)`: 设置 URL 的文件路径部分。
- `public void setUsername(String username)`: 设置 URL 的用户名部分。
- `public void setPassword(String password)`: 设置 URL 的密码部分。

------

#### POP3

使用POP3收取Email时，无需关心POP3协议底层，因为`JavaMail`提供了高层接口。首先需要连接到Store对象：

```java
package test;

import com.sun.mail.pop3.POP3SSLStore;
import jakarta.mail.MessagingException;
import jakarta.mail.Session;
import jakarta.mail.Store;
import jakarta.mail.URLName;
import org.junit.jupiter.api.Test;

import java.util.Properties;
public class DemoTest {
    @Test
    void testNegative() throws MessagingException {
        // 登录用户名:
        String username = "***@163.com";
        // 登录口令:
        String password = "***";
        // 主机端口号
        String port ="995";
        // pop3主机：
        String host="pop3.163.com";
        // 连接到pop3服务器995端口:
        Properties props = getProperties(host, port);
        // 获取Session实例:
        // 连接到Store:
        URLName url = new URLName("pop3s", host, Integer.parseInt(port), "", username, password);
        Session session = Session.getInstance(props, null);//静态方法，用于获取`Session`实例。
        session.setDebug(true); // 显示调试信息
        Store store = new POP3SSLStore(session, url);
        store.connect();
    }

    private static Properties getProperties(String host, String port) {
        Properties props = new Properties();
        props.put("mail.store.protocol", "pop3s"); // 协议名称
        props.put("mail.pop3.host", host); // pop3主机名
        props.put("mail.pop3.port", port); // 主机端口号
        props.put("mail.pop3.auth", "true"); // 是否需要用户认证
        props.put("mail.pop3.starttls.enable", "false"); // 关闭TLS加密
        props.put("mail.pop3.ssl.enable", "true"); // 启用SSL加密
        props.put("mail.pop3.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
        props.put("mail.pop3.socketFactory.port", port);
        return props;
    }
}
```

`POP3SSLStore` 是 `POP3Store` 的 SSL 安全版本。它们的构造方法应该是类似的：

```java
public POP3Store(Session session, URLName url)
```

这个构造方法接受一个 `Session` 对象和一个 `URLName` 对象作为参数，用于初始化 `POP3Store` 对象。`Session` 对象包含邮件会话的配置信息，而 `URLName` 对象包含用于连接到邮件服务器的 URL 信息。

实际上，`POP3SSLStore` 的构造方法内部调用了父类 `POP3Store` 的带有四个参数的构造方法，其中第一个参数是 `Session` 对象，第二个参数是 `URLName` 对象，第三个参数是字符串 `"pop3s"`，表示使用 POP3 协议的 SSL 安全版本，第四个参数是 `true`，表示要使用 SSL 连接。源码：

```java
public POP3SSLStore(Session session, URLName url) {
    super(session, url, "pop3s", true);
}
```

这样就可以使用 SSL 安全连接到 POP3 邮件服务器。

对于代码中的`pop3s`都可以改成`pop3`，因为使用`POP3SSLStore`已经定义了`pop3s`，即`pop3`的SSL安全版本：

```java
URLName url = new URLName("pop3s", host, Integer.parseInt(port), "", username, password);
props.put("mail.store.protocol", "pop3s"); // 协议名称
```

实际上整个`getProperties`方法都是多余的，协议也是多余的：

```java
// 登录用户名:
String username = "***@163.com";
// 登录口令:
String password = "***";
// 主机端口号
String port ="995";
// imap主机：
String host="pop3.163.com";
// 连接到pop3服务器995端口:
Properties props = new Properties();
// 获取Session实例:
// 连接到Store:
URLName url = new URLName("", host, Integer.parseInt(port), "", username, password);
Session session = Session.getInstance(props, null);
session.setDebug(true); // 显示调试信息
Store store = new POP3SSLStore(session, url);//调用就会自动设置pop3s
store.connect();
```

------

如果不需要使用 SSL 安全连接，可以使用 `POP3Store` 类而不是 `POP3SSLStore` 类。`POP3Store` 类用于表示普通的、非加密的 POP3 连接。在创建 `POP3Store` 对象时，可以直接指定协议为 `"pop3"`，而不是 `"pop3s"`，这样就可以使用非加密的方式连接到 POP3 邮件服务器。示例代码如下：

```java
Properties props = new Properties();
props.setProperty("mail.pop3.host", "pop3.163.com");//多余的操作
props.setProperty("mail.pop3.port", "110");//多余的操作
props.put("mail.pop3.ssl.enable", "false"); // 不启用SSL加密，这个也是多余的操作

Session session = Session.getInstance(props, null);
Store store = new POP3Store(session, new URLName("pop3", "pop3.163.com", 110, null, "username", "password"));
store.connect();
```

在这个示例中，创建了一个 `POP3Store` 对象，并指定了 POP3 邮件服务器的主机、端口、用户名和密码。连接时不需要指定使用 SSL，因为默认情况下 `POP3Store` 使用的是非加密的方式。

实际上`POP3Store`的构造方法定义如下：

```java
public POP3Store(Session session, URLName url) {
    this(session, url, "pop3", false);
}
public POP3Store(Session session, URLName url,
                 String name, boolean isSSL) {
    super(session, url);
    if (url != null)
        name = url.getProtocol();
    this.name = name;
    logger = new MailLogger(this.getClass(), "DEBUG POP3",
                            session.getDebug(), session.getDebugOut());

    if (!isSSL)
        isSSL = PropUtil.getBooleanProperty(session.getProperties(),
                                            "mail." + name + ".ssl.enable", false);
    if (isSSL)
        this.defaultPort = 995;
    else
        this.defaultPort = 110;
    this.isSSL = isSSL;
    ...
}
```

因此，只需要写主机地址和用户名及密码，但由于`URLName`这个构造方法要指定端口号，还是指定了`110`：

```java
// 登录用户名:
String username = "***@163.com";
// 登录口令:
String password = "***";
Properties props = new Properties();
Session session = Session.getInstance(props, null);
session.setDebug(true); // 显示调试信息
Store store = new POP3Store(session, new URLName("", "pop3.163.com", 110, null, username, password));
store.connect();
```

------

#### IMAP

使用IMAP协议的SSL安全连接方式（还是写规范点）：

```java
package test;

import com.sun.mail.pop3.POP3SSLStore;
import jakarta.mail.MessagingException;
import jakarta.mail.Session;
import jakarta.mail.Store;
import jakarta.mail.URLName;
import org.junit.jupiter.api.Test;

import java.util.Properties;
public class DemoTest {
    @Test
    void testNegative() throws MessagingException {
        // 登录用户名:
        String username = "***@163.com";
        // 登录口令:
        String password = "***";
        // 主机端口号
        String port ="993";
        // imap主机：
        String host="imap.163.com";
        // 连接到imap服务器993端口:
        Properties props = getProperties(host, port);
        // 获取Session实例:
        // 连接到Store:
        URLName url = new URLName("imaps", host, Integer.parseInt(port), "", username, password);
        Session session = Session.getInstance(props, null);//静态方法，用于获取`Session`实例。
        session.setDebug(true); // 显示调试信息
        Store store = session.getStore(url);//获取指定协议的`Store`对象，用于接收邮件。
        store.connect();
    }

    private static Properties getProperties(String host, String port) {
        Properties props = new Properties();
        props.put("mail.store.protocol", "imaps"); // 协议名称
        props.put("mail.imap.host", host); // imap主机名
        props.put("mail.imap.port", port); // 主机端口号
        props.put("mail.imap.auth", "true"); // 是否需要用户认证
        props.put("mail.imap.starttls.enable", "false"); // 关闭TLS加密
        props.put("mail.imap.ssl.enable", "true"); // 启用SSL加密
        props.put("mail.imap.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
        props.put("mail.imap.socketFactory.port", port);
        return props;
    }
}

```

修改的地方也就几处：`port`为`993`，`host`为`imap.163.com`，`Store`的获取方式改为：`session.getStore(url);`，注意协议都改为了：`imaps`，这里不能像前面`pop3`一样不加`s`一样能SSL安全连接。

同样的，`getProperties`方法也是多余的，`new URLName("imaps"...`里的`imaps`这次不是多余的了，因为调用的是`session.getStore(url);`这个一般方法。

**也可以改成`Store store = new IMAPSSLStore(session,url);`**

------

要改为非SSL安全连接的：只需要改`port`为`143`，协议改为：`imap`，`ssl`指定为`false`或者不写。即：

```java
String username = "***@163.com";
String password = "***";
String port ="143";
String host="imap.163.com";
Properties props = new Properties();
URLName url = new URLName("imap", host, Integer.parseInt(port), "", username, password);
Session session = Session.getInstance(props, null);//静态方法，用于获取`Session`实例。
session.setDebug(true); // 显示调试信息
Store store = session.getStore(url);//获取指定协议的`Store`对象，用于接收邮件。
store.connect();
```

**也可以改成`Store store = new IMAPStore(session,url);`**

### 查看邮箱

`Store` 类表示邮件存储的抽象类，它提供了一组方法用于连接到邮件服务器并访问邮件。下面是一些常用的 `Store` 类的方法：
- `void connect(String host, String user, String password)`：连接到指定主机的邮件服务器，使用指定的用户名和密码进行身份验证。
- `void connect()`：连接到之前设置的邮件服务器，使用之前设置的用户名和密码进行身份验证。
- `Folder getDefaultFolder()`：获取默认文件夹，通常是收件箱。
- **`Folder getFolder(String name)`：根据给定的文件夹名称获取文件夹对象。**
- `Folder[] getPersonalNamespaces()`：获取个人文件夹命名空间。
- `Folder[] getUserNamespaces(String user)`：获取给定用户的文件夹命名空间。
- `void close()`：关闭与邮件服务器的连接。
- `boolean isConnected()`：检查是否已连接到邮件服务器。
- `void addConnectionListener(ConnectionListener listener)`：添加连接监听器，以便在连接状态发生变化时接收通知。
- `void removeConnectionListener(ConnectionListener listener)`：移除连接监听器。

------

`Folder` 类表示邮件文件夹，它提供了一组方法用于管理和操作邮件文件夹中的邮件。下面是一些常用的 `Folder` 类的方法：

- `String getFullName()`：获取邮件文件夹的完整名称。
- `boolean exists()`：检查邮件文件夹是否存在。
- **`void open(int mode)`：打开邮件文件夹，并指定打开模式（只读、读写等）。**
- `boolean isOpen()`：检查邮件文件夹是否已打开。
- `void appendMessages(Message[] msgs)`：向邮件文件夹中追加邮件。
- `void delete(boolean recurse)`：删除邮件文件夹，可选择是否递归删除子文件夹。
- **`int getMessageCount()`：获取邮件文件夹中的邮件数量。**
- **`int getNewMessageCount()`：获取邮件文件夹中的新邮件数量。**
- **`int getUnreadMessageCount()`：获取邮件文件夹中的未读邮件数量。**
- **`int getDeletedMessageCount()`：获取邮件文件夹中已标记为删除的邮件数量。**
- **`Message[] getMessages()`：获取邮件文件夹中的所有邮件。**
- `Message getMessage(int msgnum)`：根据邮件序号获取邮件对象。
- `Message getMessage(int start,int end)`：根据邮件序号获取邮件对象。
- `Message[] search(SearchTerm term)`：根据指定的搜索条件搜索邮件。
- `void setFlags(Message[] msgs, Flags flag, boolean value)`：设置邮件的标志（例如，已读、已删除等）。
- `Message[] expunge()`：清除标记为已删除的邮件，并返回已删除的邮件数组。
- `void close(boolean expunge)`：关闭邮件文件夹，可选择是否删除已删除的邮件。
- `void addMessageChangedListener(MessageChangedListener listener)`：添加邮件变化监听器。
- `void removeMessageChangedListener(MessageChangedListener listener)`：移除邮件变化监听器。
- `void addFolderListener(FolderListener listener)`：添加文件夹监听器。
- `void removeFolderListener(FolderListener listener)`：移除文件夹监听器。

------

`MimeUtility` 类是 JavaMail API 中用于处理 MIME（Multipurpose Internet Mail Extensions）消息的实用工具类。它提供了一些方法来编码和解码 MIME 消息的各个部分，以及处理文本和二进制数据的方法。

以下是 `MimeUtility` 类的一些常用方法：

1. **编码方法**：
   - `encodeText(String text) throws UnsupportedEncodingException`：对文本进行 MIME 编码。
   - `encodeWord(String word) throws UnsupportedEncodingException`：对单词进行 MIME 编码。

2. **解码方法**：
   - **`decodeText(String text) throws UnsupportedEncodingException`：解码 MIME 编码的文本。**

3. **其他方法**：
   - `fold(int used, String s)`：根据 RFC 2822 规范折叠长行。
   - `unfold(String s)`：从折叠的行中还原原始行。
   - `encodeWord(String word, String charset, String encoding) throws UnsupportedEncodingException`：使用指定的字符集和编码对单词进行编码。
   - `decodeWord(String eword)` throws ParseException：解码 MIME 编码的单词。
   - `quote(String s, String specials)`：对字符串中的特殊字符进行引用。
   - `quote(String s)`：对字符串中的特殊字符进行引用，默认引用所有非 ASCII 字符。

这些方法可能会抛出 `UnsupportedEncodingException` 或 `ParseException` 异常，因此在使用时需要处理这些异常。

------

一个`Store`对象表示整个邮箱的存储，要收取邮件，需要通过`Store`访问指定的`Folder`（文件夹），**通常是`INBOX`表示收件箱**：

```java
// 获取收件箱:
Folder folder = store.getFolder("INBOX");
// 以读写方式打开:
folder.open(Folder.READ_WRITE);
// 打印邮件总数/新邮件数量/未读数量/已删除数量:
System.out.println("Total messages: " + folder.getMessageCount());
System.out.println("New messages: " + folder.getNewMessageCount());
System.out.println("Unread messages: " + folder.getUnreadMessageCount());
System.out.println("Deleted messages: " + folder.getDeletedMessageCount());
// 获取每一封邮件:
Message[] messages = folder.getMessages();
for (Message message : messages) {
    // 打印每一封邮件:
    printMessage((MimeMessage) message);
}
folder.close(true); // 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）
store.close();
```

获取到一个`Message`对象时，可以强制转型为`MimeMessage`，然后打印出邮件主题、发件人、收件人等信息：

```java
static void printMessage(MimeMessage msg) throws IOException, MessagingException {
    // 邮件主题:
    System.out.println("Subject: " + MimeUtility.decodeText(msg.getSubject()));
    // 发件人:
    Address[] froms = msg.getFrom();
    InternetAddress address = (InternetAddress) froms[0];
    System.out.println("From: " + getAddressInfo(address));
    // 收件人（可以有多个）:
    InternetAddress[] recipients = (InternetAddress[]) msg.getAllRecipients();
    for (InternetAddress recipient : recipients) {
        System.err.println("Recipient: " + getAddressInfo(recipient));
    }
    // 打印邮件内容
    String s = getBody(msg);
    System.err.println(MimeUtility.decodeText(s));
}

/**
 * 获取InternetAddress的字符串形式
 * @param address 地址
 * @return 字符串
 * @throws UnsupportedEncodingException 字符编码不支持。
 */
static String getAddressInfo(InternetAddress address) throws UnsupportedEncodingException {
    String personal = address.getPersonal();
    return personal == null ? address.getAddress() : (MimeUtility.decodeText(personal) + " <" + address.getAddress() + ">");
}
```

获取邮件的正文，一个`MimeMessage`对象也是一个`Part`对象，它可能只包含一个文本，也可能是一个`Multipart`对象，即由几个`Part`构成，因此，需要递归地解析出完整的正文：

```java
/**
 * 邮件内容
 * @param part 邮件部分内容
 * @return 字符串
 * @throws MessagingException
 * @throws IOException
 */
static String getBody(Part part) throws MessagingException, IOException {
    if (part.isMimeType("text/*")) {
        // Part是文本:
        return part.getContent().toString();
    }
    StringBuilder sb=new StringBuilder();
    if (part.isMimeType("multipart/*")) {
        // Part是一个Multipart对象:
        Multipart multipart = (Multipart) part.getContent();
        // 循环解析每个子Part:
        for (int i = 0; i < multipart.getCount(); i++) {
            BodyPart bodyPart = multipart.getBodyPart(i);
            String body = getBody(bodyPart);
            if (!body.isEmpty()) {
                sb.append(body);
            }
        }
    }
    return sb.toString();
}
```

------

**注意！网易邮箱对于IMAP协议收信有额外要求**：[imap连接提示Unsafe Login，被阻止的收信行为](https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2eda07326646e6eb0)

在`store.connect();`后面加上以下代码即可：

```java
store.connect();
Map<String,String> IAM = new HashMap<>();
IAM.put("name","myname");
IAM.put("version","1.0.0");
IAM.put("vendor","myclient");
IAM.put("support-email","testmail@test.com");
((IMAPStore)store).id(IAM);
```

发送IMAP ID命令（如果服务器支持）并从服务器返回结果。 ID命令向服务器标识客户端并将有关服务器的信息返回给客户端。

------

**获取最近的10封邮件：**

```java
// 获取邮件文件夹
Folder folder = store.getFolder("INBOX");
folder.open(Folder.READ_ONLY);
// 获取邮件总数
int totalMessages = folder.getMessageCount();
// 计算要获取的起始邮件号和结束邮件号
int startMessage = Math.max(1, totalMessages - 9); // 最近的第一封邮件
int endMessage = totalMessages; // 最近的最后一封邮件
// 获取最近的 10 封邮件
Message[] messages = folder.getMessages(startMessage, endMessage);
// 关闭邮件文件夹
folder.close();
```



### 保存附件

加个判断就行。

```java
static String getBody(Part part) throws MessagingException, IOException {
    if (part.isMimeType("text/*")) {
        // Part是文本:
        return part.getContent().toString();
    }
    StringBuilder sb=new StringBuilder();
    if (part.isMimeType("multipart/*")) {
        // Part是一个Multipart对象:
        Multipart multipart = (Multipart) part.getContent();
        // 循环解析每个子Part:
        for (int i = 0; i < multipart.getCount(); i++) {
            BodyPart bodyPart = multipart.getBodyPart(i);
            String body = getBody(bodyPart);
            if (!body.isEmpty()) {
                sb.append(body);
            }
            // 保存非文本类型的部分为文件
            saveAttachment(bodyPart, sb);
        }
    }

    return sb.toString();
}
private static void saveAttachment(BodyPart bodyPart, StringBuilder sb) throws MessagingException, IOException {
    if (!bodyPart.isMimeType("text/*")) {
        String fileName = bodyPart.getFileName();
        if (fileName != null && !fileName.isEmpty()) {
            InputStream inputStream = bodyPart.getInputStream();
            FileOutputStream outputStream = new FileOutputStream(fileName);
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                outputStream.write(buffer, 0, bytesRead);
            }
            outputStream.close();
            inputStream.close();
            sb.append("\n已保存的附件: ").append(fileName).append("\n");
        }
    }
}
```

### 删除邮件

`Folder` 类的删除方法：

- **`void open(int mode)`：打开邮件文件夹，并指定打开模式（只读、读写等）。**
   - `Folder.READ_ONLY`（值为 1）：只读模式，用于读取邮件但不能修改或删除邮件。
   - `Folder.READ_WRITE`（值为 2）：读写模式，用于读取、修改和删除邮件。
- **`void setFlags(Message[] msgs, Flags flag, boolean value)`：设置邮件的标志（例如，已读、已删除等）。**
- **`Message[] expunge()`：清除标记为已删除的邮件，并返回已删除的邮件数组。**
- `void close(boolean expunge)`：关闭邮件文件夹，可选择是否删除已删除的邮件。

------

在 JavaMail API 中，`Flags` 类表示邮件的标志。`Flags` 类提供了一些常量来表示不同的标志，可以使用这些常量来设置或检查邮件的标志。

构造方法：

- `Flags flags = new Flags();`：创建一个空的 `Flags` 对象。
- **`Flags flags = new Flags(Flags.Flag flag);`：创建一个包含指定标志的 `Flags` 对象。**
- `Flags flags = new Flags(Flags flags);`：创建一个包含另一个 `Flags` 对象中所有标志的 `Flags` 对象。

常用的方法：

- **`void add(Flags.Flag flag)`：添加指定的标志。**
- `void add(Flags flags)`：添加另一个 `Flags` 对象中的所有标志。
- `boolean contains(Flags.Flag flag)`：检查是否存在指定的标志。
- `boolean containsAll(Flags flags)`：检查是否存在另一个 `Flags` 对象中的所有标志。
- `boolean equals(Object obj)`：比较两个 `Flags` 对象是否相等。
- `Flags.Flag[] getSystemFlags()`：返回系统定义的所有标志。
- `Flags.Flag[] getUserFlags()`：返回用户定义的所有标志。
- `int hashCode()`：返回 `Flags` 对象的哈希码值。
- `void remove(Flags.Flag flag)`：移除指定的标志。
- `void remove(Flags flags)`：移除另一个 `Flags` 对象中的所有标志。
- `void set(Flags.Flag flag, boolean value)`：设置指定标志的状态。
- `void setFlags(Flags.Flag[] flags, boolean value)`：设置指定一组标志的状态。
- `void setUserFlags(Flags flags)`：设置用户定义的标志。

以下是 `Flags` 类中定义的一些常量：

- `Flags.Flag.ANSWERED`：已回复标志，表示邮件已被回复。
- **`Flags.Flag.DELETED`：已删除标志，表示邮件已被标记为删除。**
- `Flags.Flag.DRAFT`：草稿标志，表示邮件是草稿。
- `Flags.Flag.FLAGGED`：已标记标志，表示邮件已被标记。
- `Flags.Flag.RECENT`：最近标志，表示邮件是最近收到的。
- `Flags.Flag.SEEN`：已读标志，表示邮件已被阅读。
- `Flags.Flag.USER`：用户标志，表示用户定义的标志。

可以使用这些常量来创建 `Flags` 对象，并将其传递给 `Folder.setFlags()` 方法来设置邮件的标志。例如，要创建一个包含已读和已回复标志的 `Flags` 对象，可以使用以下代码：

```java
Flags flags = new Flags();
flags.add(Flags.Flag.SEEN);
flags.add(Flags.Flag.ANSWERED);
```

------

**批量删除邮件：**

```java
// 获取收件箱:
Folder folder = store.getFolder("INBOX");
// 以读写方式打开:
folder.open(Folder.READ_WRITE);
// 打印邮件总数/新邮件数量/未读数量/已删除数量:
System.out.println("Total messages: " + folder.getMessageCount());
System.out.println("New messages: " + folder.getNewMessageCount());
System.out.println("Unread messages: " + folder.getUnreadMessageCount());
System.out.println("Deleted messages: " + folder.getDeletedMessageCount());
// 获取每一封邮件:
Message[] messages = folder.getMessages();
Flags flags = new Flags(Flags.Flag.DELETED);
folder.setFlags(messages,flags,true);
folder.close(true); // 关闭邮件文件夹并删除标记为删除的邮件
```

实际上`Folder`的`setFlags`方法内部是这样的：

```java
for (int i = 0; i < msgs.length; i++) {
    try {
    msgs[i].setFlags(flag, value);
    } catch (MessageRemovedException me) {
    // This message is expunged, skip 
    }
}
```

因此可以直接在单个`Message`上调用：

```java
// 获取每一封邮件:
Message[] messages = folder.getMessages();
Flags flags = new Flags(Flags.Flag.DELETED);
messages[0].setFlags(flags,true);
messages[0].setFlag(Flags.Flag.DELETED,true);
//...
folder.close(true); // 关闭邮件文件夹并删除标记为删除的邮件
```

加`s`的表示可以设置多个，后面的`Boolean`值表示是设置还是取消，还可以通过`expunge()`方法删除。

试试用`folder.expunge();`删除标记为删除的邮件：

```java
// 获取每一封邮件:
Message[] messages = folder.getMessages();
messages[0].setFlag(Flags.Flag.DELETED,true);
folder.expunge();//删除标记为删除的邮件
folder.close(); // 关闭邮件文件夹
```

提示：

```text
 jakarta.mail.MethodNotSupportedException: Expunge not supported
```

在使用 POP3 协议时，`POP3Folder` 不支持 `expunge()` 方法，因此会抛出 `MethodNotSupportedException` 异常。因为 POP3 协议不支持在服务器上直接删除邮件，而是通过将邮件标记为删除，然后在下次会话中关闭连接时执行实际的删除操作。

如果需要在使用 POP3 协议时删除邮件，可以考虑以下方法：

- 在读取邮件时，将要删除的邮件标记为删除，但不执行 `expunge()` 操作。最后调用 `close(true)` 方法来执行实际的删除操作。
- 使用其他支持邮件删除的协议，如 IMAP。IMAP 协议支持在服务器上直接删除邮件。

**使用IMAP协议执行同样的代码：**

```java
// 获取每一封邮件:
Message[] messages = folder.getMessages();
messages[0].setFlag(Flags.Flag.DELETED,true);
folder.expunge();//删除标记为删除的邮件
//...
folder.close(); // 关闭邮件文件夹
```

正常删除。



## HTTP协议

HTTP是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。

HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。

当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用`80`端口和加密端口`443`，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。

HTTP请求的格式是固定的，由HTTP Header和HTTP Body两部分构成。第一行总是请求方法 路径 HTTP版本，例如，`GET / HTTP/1.1`表示使用`GET`请求，路径是`/`，版本是`HTTP/1.1`。

后续的每一行都是固定的`Header: Value`格式，即HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：

- Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；
- User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；
- Accept：表示客户端能处理的HTTP响应格式，`*/*`表示任意格式，`text/*`表示任意文本，`image/png`表示PNG格式的图片；
- Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。

如果是`GET`请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是`POST`请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：

```
POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

username=hello&password=123456
```

`POST`请求通常要设置`Content-Type`表示Body的类型，`Content-Length`表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。

此外，`GET`请求的参数必须附加在URL上，并以URLEncode方式编码，例如：`http://www.example.com/?a=1&b=K%26R`，参数分别是`a=1`和`b=K&R`。因为URL的长度限制，`GET`请求的参数不能太多，而`POST`请求的参数就没有长度限制，因为`POST`请求的参数必须放到Body中。并且，`POST`请求的参数不一定是URL编码，可以按任意格式编码，只需要在`Content-Type`中正确设置即可。常见的发送JSON的`POST`请求如下：

```
POST /login HTTP/1.1
Content-Type: application/json
Content-Length: 38

{"username":"bob","password":"123456"}
```

HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 133251

<!DOCTYPE html>
<html><body>
<h1>Hello</h1>
...
```

响应的第一行总是`HTTP版本 响应代码 响应说明`，例如，`HTTP/1.1 200 OK`表示版本是`HTTP/1.1`，响应代码是`200`，响应说明是`OK`。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：

- 1xx：表示一个提示性响应，例如101表示将切换协议，常见于`WebSocket`连接；
- 2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；
- 3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；
- 4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；
- 5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。

当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，`GET /logo.jpg HTTP/1.1`请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：

```
HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 18391

????JFIFHH??XExifMM?i&??X?...(二进制的JPEG图片)
```

因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。

对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率。

因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。

所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收。因此HTTP/2.0进一步提高了效率。

------

URL（统一资源定位符）用于标识互联网上的资源位置，是 Web 中最常用的概念之一。它指定了资源的位置和访问方式。通常包含以下几个部分：

1. **协议（Protocol）**：指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。
2. **主机名（Host）**：指定了资源所在的主机或服务器的域名或 IP 地址。
3. **端口（Port）**：指定了访问服务器的端口号。如果未指定，默认为协议的默认端口。
4. **路径（Path）**：指定了服务器上资源的路径。
5. **查询字符串（Query String）**：包含了向服务器传递的参数信息。
6. **片段标识符（Fragment Identifier）**：指定了资源中的特定部分。

例如，对于 URL `https://www.example.com:8080/index.html?query=example#section1`，协议为 HTTPS，主机名为 `www.example.com`，端口号为 `8080`，路径为 `/index.html`，查询字符串为 `query=example`，片段标识符为 `section1`。

URL 在 Web 开发中广泛用于定位和访问 Web 页面、图像、视频等各种资源。

**URL类构造方法**

`public URL(String spec);`：通过指定的字符串创建一个 URL 对象。

```java
URL u1 = new URL("http://home.netscape.com/home/");
```

`public URL(URL context, String spec);`：通过基于上下文 URL 和相对 URL 字符串创建一个 URL 对象。

```java
URL u1 = new URL("http://home.netscape.com/home/");
URL u2 = new URL(u1, "welcome.html");
```

`public URL(String protocol, String host, String file);`：通过指定协议、主机和文件路径创建一个 URL 对象。

```java
URL u3 = new URL("http", "www.sun.com", "developers/index.html");
```

`public URL(String protocol, String host, int port, String file);`：通过指定协议、主机、端口和文件路径创建一个 URL 对象。

```java
URL u4 = new URL("http", "www.sun.com", 80, "developers/index.html");
```

常用方法：

- `String getProtocol()`: 获取 URL 的协议部分，例如 `http`、`https` 等。
- `String getHost()`: 获取 URL 的主机名部分。
- `int getPort()`: 获取 URL 的端口号部分。
- `String getPath()`: 获取 URL 的路径部分。
- `String getQuery()`: 获取 URL 的查询部分。
- `String getFile()`: 获取 URL 的文件名部分。
- `URLConnection openConnection()`: 打开与此 URL 的连接，并返回一个 `URLConnection` 对象。
- `InputStream openStream()`: 打开与此 URL 的连接，并返回一个 `InputStream` 对象。
- `boolean equals(Object obj)`: 比较此 URL 与指定对象是否相等。
- `String toString()`: 返回 URL 的字符串表示形式。

------

**`URLConnection`抽象类**

`Uonnection`类支持`URL`连接的输入/输出流方式的通信,并可以获得`URL`对象资源的相关信息。它是所有应用程序和`URL`连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。  

常用的方法：  

- **`void connect()`: 打开与 URL 引用的资源的通信链接。**
- `Object getContent()`: 获取此 URLConnection 的内容。
- `String getHeaderField(int n)`: 返回与此 URLConnection 的给定字段相关联的值。
- `long getLastModified()`: 获取指定资源的最后修改日期。
- `int getContentLength()`: 获取指定资源的内容长度。
- `String getContentType()`: 获取指定资源的内容类型。
- **`InputStream getInputStream()`: 返回一个输入流，用于从连接到 URL 的资源读取数据。**
- `OutputStream getOutputStream()`: 返回一个输出流，用于将数据写入到与 URLConnection 关联的资源。
- **`void setDoOutput(boolean dooutput)`: 将 doOutput 字段的值设置为指定值。**
- `void setDoInput(boolean doinput)`: 将 doInput 字段的值设置为指定值。
- **`void setRequestMethod(String method)`: 设置请求方法。**
- **`void setRequestProperty(String key, String value)`: 设置指定的请求头字段的值。**
- `void addRequestProperty(String key, String value)`: 添加一个请求属性。
- `Map<String, List<String>> getHeaderFields()`: 返回与此 URLConnection 关联的请求头字段的映射。
- `String getContentEncoding()`: 返回指定资源的内容编码。
- `int getConnectTimeout()`: 返回与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。
- `int getReadTimeout()`: 返回从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。
- **`void setConnectTimeout(int timeout)`: 设置与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。**
- `void setReadTimeout(int timeout)`: 设置从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。
- **`void setUseCaches(boolean usecaches)`: 如果连接上的 `UseCaches` 标志为 true，则允许该连接使用它可以使用的任何缓存。如果为 false，则忽略缓存。默认为true。**

------

`HttpURLConnection` 是 `URLConnection` 的子类，提供了一些额外的方法，用于处理 HTTP 请求和响应。以下是 `HttpURLConnection` 比 `URLConnection` 多出的一些方法：

- `getHeaderFieldKey(int n)`：返回指定索引处的响应头字段名称。
- `getHeaderField(int n)`：返回指定索引处的响应头字段的值。
- **`getHeaderFields()`：返回一个包含所有响应头字段的映射。**
- `getRequestMethod()`：返回此连接的请求方法。
- `setRequestMethod(String method)`：设置请求方法（如 GET、POST 等）。
- **`getResponseCode()`：获取 HTTP 响应代码。**
- `getResponseMessage()`：获取 HTTP 响应消息。
- `usingProxy()`：返回一个布尔值，指示是否通过代理进行连接。
- `disconnect()`：关闭连接并释放与该连接关联的所有系统资源。

这些方法使得 `HttpURLConnection` 更适合处理 HTTP 请求和响应，而 `URLConnection` 则是更通用的类，可以处理不仅限于 HTTP 的多种协议。

------

因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而使用Java进行HTTP客户端编程仅限于获得响应内容。

示例：将`baidu`内容重定向到`Demo.txt`  

```java
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("Demo.txt", true)));
URL url2 = new URL("https://www.baidu.com");
URLConnection conn = url2.openConnection();
conn.setDoOutput(true);
conn.connect();
String nextLine;
StringBuilder sb=new StringBuilder();
BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
while ((nextLine = br.readLine()) != null){
    sb.append(nextLine);
}
bw.write(sb.toString());
bw.close();
br.close();
```

详细点的：

```java
URL url = new URL("https://www.baidu.com");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("GET");
conn.setUseCaches(false);
conn.setConnectTimeout(5000); // 请求超时5秒
// 设置HTTP头:
conn.setRequestProperty("Accept", "*/*");
conn.setRequestProperty("User-Agent", "Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)");
// 连接并发送HTTP请求:
conn.connect();
// 判断HTTP响应是否200:
if (conn.getResponseCode() != 200) {
    throw new RuntimeException("bad response");
}
// 获取所有响应Header:
Map<String, List<String>> map = conn.getHeaderFields();
for (String key : map.keySet()) {
    System.out.println(key + ": " + map.get(key));
}
// 获取响应内容:
String nextLine;
StringBuilder sb=new StringBuilder();
BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
while ((nextLine = br.readLine()) != null){
    sb.append(nextLine);
}
System.out.println(sb);
br.close();
```

------

从**Java 11**开始，引入了新的`HttpClient`，它使用链式调用的API，能大大简化HTTP的处理。首先需要创建一个全局`HttpClient`实例，因为`HttpClient`内部使用线程池优化多个HTTP连接，可以复用：

```java
static HttpClient httpClient = HttpClient.newBuilder().build();
```

```java
static HttpClient httpClient = HttpClient.newBuilder().build();
@Test
void testNegative() throws IOException, URISyntaxException, InterruptedException {
    HttpRequest request = HttpRequest.newBuilder(new URI("https://www.baidu.com"))
            .header("User-Agent","Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)")
            .header("Accept","*/*")
            .timeout(Duration.ofSeconds(5))
            .version(HttpClient.Version.HTTP_2)
            .GET()
            .build();

    HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
    if (response.statusCode()!=200) {
        throw new RuntimeException("bad response");
    }
    // 获取所有响应Header:
    Map<String, List<String>> map = response.headers().map();
    for (String key : map.keySet()) {
        System.out.println(key + ": " + map.get(key));
    }
    System.out.println(response.body());
}
```

如果要获取图片这样的二进制内容，只需要把`HttpResponse.BodyHandlers.ofString()`换成`HttpResponse.BodyHandlers.ofByteArray()`，就可以获得一个`HttpResponse<byte[]>`对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用`HttpResponse.BodyHandlers.ofInputStream()`获取一个`InputStream`流。

如果要使用`POST`请求，需要准备好发送的Body数据并正确设置`Content-Type`：

```java
String url = "http://www.example.com/login";
String body = "username=bob&password=123456";
HttpRequest request = HttpRequest.newBuilder(new URI(url))
    // 设置Header:
    .header("Accept", "*/*")
    .header("Content-Type", "application/x-www-form-urlencoded")
    // 设置超时:
    .timeout(Duration.ofSeconds(5))
    // 设置版本:
    .version(Version.HTTP_2)
    // 使用POST并设置Body:
    .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build();
HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
String s = response.body();
```

------

`HttpRequest` 类是 Java 11 中引入的，用于表示 HTTP 请求的类。以下是一些常用的 `HttpRequest` 方法：

- `builder(URI uri)`: 静态方法，返回一个新的 `HttpRequest.Builder` 对象，用于构建 HTTP 请求。
- `method()`: 返回 HTTP 请求方法，如 GET、POST、PUT 等。
- `uri()`: 返回请求的 URI。
- `headers()`: 返回请求头信息，以 `Map<String, List<String>>` 的形式表示。
- `bodyPublisher()`: 返回请求体的发布器（`BodyPublisher`），用于发送请求体数据。
- `version()`: 返回 HTTP 协议版本。
- `expectContinue()`: 返回一个布尔值，指示是否期望服务器在发送响应之前先发送一个 100 Continue 响应。
- `timeout()`: 返回超时时间。
- `copy()`: 复制当前请求的副本。
- `toString()`: 将请求对象转换为字符串表示。

------

`HttpRequest` 类中的静态方法通常用于创建 `HttpRequest` 实例或处理 `HttpRequest` 请求。以下是一些常用的静态方法：
- `static HttpRequest.Builder newBuilder()`：创建一个新的 `HttpRequest.Builder` 实例，用于构建 `HttpRequest` 对象。
- **`static HttpRequest.Builder newBuilder(URI uri)`：创建一个新的 `HttpRequest.Builder` 实例，并传入URI用于构建 `HttpRequest` 对象。**
- `static HttpRequest.BodyPublishers ofByteArray(byte[] body)`：创建一个发布指定字节数组作为请求主体的 `HttpRequest.BodyPublisher` 实例。
- `static HttpRequest.BodyPublishers ofInputStream(Supplier<InputStream> bodySupplier)`：创建一个发布从提供的 `InputStream` 读取数据作为请求主体的 `HttpRequest.BodyPublisher` 实例。
- `static HttpRequest.BodyPublishers ofString(String body)`：创建一个发布指定字符串作为请求主体的 `HttpRequest.BodyPublisher` 实例。
- `static HttpRequest.BodyPublishers ofFile(Path file)`：创建一个发布指定文件内容作为请求主体的 `HttpRequest.BodyPublisher` 实例。

------

`HttpRequest.Builder` 类用于构建 `HttpRequest` 对象。以下是该类的方法：
- **`GET()`：设置请求方法为 GET。**
- **`POST(BodyPublisher bodyPublisher)`：设置请求方法为 POST，并指定请求体的发布器。**
- `PUT(BodyPublisher bodyPublisher)`：设置请求方法为 PUT，并指定请求体的发布器。
- `DELETE()`：设置请求方法为 DELETE。
- **`header(String name, String value)`：添加请求头。**
- `headers(Map<String, List<String>> headers)`：添加多个请求头。
- `method(String method)`：设置请求方法。
- `uri(URI uri)`：设置请求的 URI。
- **`version(HttpClient.Version version)`：设置 HTTP 协议版本。**
- `timeout(Duration duration)`：设置超时时间。
- `expectContinue(boolean enable)`：设置是否期望服务器在发送响应之前先发送一个 100 Continue 响应。
- **`build()`：构建并返回 `HttpRequest` 对象。**

------

`URI` 类的构造方法如下：
- **`URI(String uri)`：根据给定的 URI 字符串创建 `URI` 对象。该字符串必须符合 URI 的语法规则。**
- **`URI(String scheme, String ssp, String fragment)`**：使用指定的方案、特定部分和片段创建 `URI` 对象。方案和特定部分之间用冒号分隔。
- **`URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)`**：使用指定的参数创建 `URI` 对象。参数包括方案、用户信息、主机、端口、路径、查询和片段。

------

`Duration` 类表示一段时间的持续时间，它提供了用于处理持续时间的方法。以下是 `Duration` 类的一些主要方法：
- `static Duration between(Temporal startInclusive, Temporal endExclusive)`：返回两个时间点之间的持续时间。
- `static Duration ofDays(long days)`：创建指定天数的持续时间。
- `static Duration ofHours(long hours)`：创建指定小时数的持续时间。
- `static Duration ofMinutes(long minutes)`：创建指定分钟数的持续时间。
- **`static Duration ofSeconds(long seconds)`：创建指定秒数的持续时间。**
- `static Duration ofMillis(long millis)`：创建指定毫秒数的持续时间。
- `static Duration ofNanos(long nanos)`：创建指定纳秒数的持续时间。
- `long toDays()`：获取持续时间的天数部分。
- `long toHours()`：获取持续时间的小时数部分。
- `long toMinutes()`：获取持续时间的分钟数部分。
- `long toSeconds()`：获取持续时间的秒数部分。
- `long toMillis()`：获取持续时间的毫秒数部分。
- `long toNanos()`：获取持续时间的纳秒数部分。
- `Duration plus(Duration duration)`：将另一个持续时间添加到此持续时间。
- `Duration minus(Duration duration)`：从此持续时间中减去另一个持续时间。
- `Duration multipliedBy(long multiplicand)`：将此持续时间乘以指定的数量。
- `Duration dividedBy(long divisor)`：将此持续时间除以指定的数量。
- `boolean isNegative()`：检查持续时间是否为负数。
- `boolean isZero()`：检查持续时间是否为零。

------

`HttpClient.Version` 是一个枚举类，表示 HTTP 客户端支持的协议版本。它包含以下字段：
- `HTTP_1_1`：表示 HTTP/1.1 协议版本。
- **`HTTP_2`：表示 HTTP/2 协议版本。**

------

`BodyPublishers` 类提供了以下静态方法来创建不同类型的 `BodyPublisher` 实例：

- `ofByteArray(byte[] body)`：将指定的字节数组作为请求主体发送。
- `ofByteArrays(Iterable<byte[]> bodies)`：按顺序将多个字节数组作为请求主体发送。
- `ofFile(Path file)`：将指定文件的内容作为请求主体发送。
- `ofInputStream(Supplier<? extends InputStream> streamSupplier)`：从提供的 `InputStream` 中发送请求主体。
- `ofString(String body)`：将指定的字符串作为请求主体发送。
- **`ofString(String body, Charset charset)`：将指定的字符串以指定的字符集编码作为请求主体发送。**

这些方法提供了灵活的方式来创建不同类型的请求主体，并使其适应于不同的请求场景。

------

`HttpClient` 类提供了执行 HTTP 请求和处理 HTTP 响应的方法。以下是一些常用的方法：
- **`send(HttpRequest request, BodyHandler<T> responseBodyHandler)`：发送 HTTP 请求并返回响**应。`request` 参数是要发送的请求，`responseBodyHandler` 参数指定如何处理响应主体。
- `sendAsync(HttpRequest request, BodyHandler<T> responseBodyHandler)`：异步发送 HTTP 请求并返回 `CompletableFuture<HttpResponse<T>>`，可以在未来的某个时间点获取响应。
- `newBuilder()`：创建一个新的 `HttpClient.Builder` 实例，用于构建 `HttpClient` 对象。
- `followRedirects()`：启用重定向（默认情况下启用）。
- `version()`：获取当前 `HttpClient` 实例使用的协议版本。
- `sslContext()`：获取当前 `HttpClient` 实例使用的 SSL 上下文。
- `proxy()`：获取当前 `HttpClient` 实例使用的代理。
- `authenticator()`：获取当前 `HttpClient` 实例使用的身份验证器。

------

`HttpResponse` 类表示 HTTP 响应，并提供了访问响应状态、头信息和主体的方法。以下是一些常用的方法：
- `statusCode()`：返回响应的状态码。
- `body()`：返回响应的主体作为 `HttpResponse.BodySubscriber`。
- `headers()`：返回包含响应头信息的 `Map`。
- `bodyHandler()`：返回用于处理响应主体的 `BodyHandler`。
- `version()`：返回 HTTP 版本。
- `uri()`：返回请求的 URI。
- `request()`：返回生成此响应的请求。
- `previousResponse()`：如果重定向发生，则返回之前的响应。
- `sslSession()`：返回 SSL 会话。

------

`HttpResponse.BodyHandlers` 类是一个工具类，提供了一些静态方法用于创建不同类型的 `BodyHandler` 实例，以便处理 HTTP 响应主体。以下是一些常用的静态方法：
- **`ofString()`：返回一个 `BodyHandler`，用于将响应主体作为字符串处理。**
- **`ofByteArray()`：返回一个 `BodyHandler`，用于将响应主体作为字节数组处理。**
- `ofInputStream()`：返回一个 `BodyHandler`，用于将响应主体作为输入流处理。
- `ofFile(Path file)`：返回一个 `BodyHandler`，用于将响应主体保存到指定文件。



## RMI远程调用

Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。

提供服务的一方称之为服务器，而实现远程调用的一方称之为客户端。

服务器会提供一个`WorldClock`服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：

```java
LocalDateTime getLocalDateTime(String zoneId);
```

要实现RMI，服务器和客户端必须共享同一个接口。定义一个`WorldClock`接口，代码如下：

```java
public interface WorldClock extends Remote {
    LocalDateTime getLocalDateTime(String zoneId) throws RemoteException;
}
```

Java的RMI规定此接口**必须派生自`java.rmi.Remote`**，并在每个方法声明抛出`RemoteException`，因为远程方法调用缺乏本地调用的可靠性，远程调用总是存在失败的可能。

下一步是编写服务器的实现类，因为客户端请求的调用方法`getLocalDateTime()`最终会通过这个实现类返回结果。实现类`WorldClockService`代码如下：

```java
public class WorldClockService implements WorldClock {
    @Override
    public LocalDateTime getLocalDateTime(String zoneId) throws RemoteException {
        return LocalDateTime.now(ZoneId.of(zoneId)).withNano(0);
    }
}
```

现在，服务器端的服务相关代码就编写完毕。需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：

```java
public class Server {
    public static void main(String[] args) throws RemoteException {
        System.out.println("create World clock remote service...");
        // 实例化一个WorldClock:
        WorldClock worldClock = new WorldClockService();
        // 将此服务转换为远程服务接口:
        WorldClock skeleton = (WorldClock) UnicastRemoteObject.exportObject(worldClock, 0);// 第二个参数为0，表明任何合适的端口都可用来监听客户连接。
        // 将RMI服务注册到1099端口:
        Registry registry = LocateRegistry.createRegistry(1099);
        // 注册此服务，服务名为"WorldClock":
        registry.rebind("WorldClock", skeleton);
    }
}
```

上述代码主要目的是通过RMI提供的相关类，将我们自己的`WorldClock`实例注册到RMI服务上。RMI的默认端口是`1099`，最后一步注册服务时通过`rebind()`指定服务名称为`"WorldClock"`。

下一步就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此要把`WorldClock.java`这个接口文件复制到客户端，然后在客户端实现RMI调用：

```java
public class Client {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        // 连接到服务器localhost，端口1099:
        Registry registry = LocateRegistry.getRegistry("localhost", 1099);
        // 查找名称为"WorldClock"的服务并强制转型为WorldClock接口:
        WorldClock worldClock = (WorldClock) registry.lookup("WorldClock");
        // 正常调用接口方法:
        LocalDateTime now = worldClock.getLocalDateTime("Asia/Shanghai");
        // 打印调用结果:
        System.out.println(now);
    }
}
```

先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。

对客户端来说，客户端持有的`WorldClock`接口实际上对应了一个“实现类”，它是由`Registry`内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的`WorldClockService`，而是`Registry`自动生成的代码。

把客户端的“实现类”称为`stub`，而服务器端的网络服务类称为`skeleton`，它会真正调用服务器端的`WorldClockService`，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：

```ascii
┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
  ┌─────────────┐                                 ┌─────────────┐
│ │   Service   │ │         │                     │   Service   │ │
  └─────────────┘                                 └─────────────┘
│        ▲        │         │                            ▲        │
         │                                               │
│        │        │         │                            │        │
  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐
│ │ Client Stub ├─┼─────────┼>│Server Skeleton│──>│Service Impl │ │
  └─────────────┘             └───────────────┘   └─────────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。

Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如[gRPC](https://grpc.io/)。

------

`Remote`接口，用于标识那些方法可以从非本地虚拟机调用的接口。任何作为远程对象的对象必须直接或间接实现这个接口。

`UnicastRemoteObject` 类是用于导出远程对象的抽象类。它提供了导出远程对象所需的基本功能。在Java RMI中，远程对象必须继承自 `UnicastRemoteObject` 类或调用 `exportObject` 方法来导出对象，以便能够被远程客户端访问。

实现类可以实现任意数量的远程接口，并且可以扩展其他远程实现类。RMI提供了一些便利类，远程对象实现可以扩展这些类以方便远程对象的创建。这些类包括`java.rmi.server.UnicastRemoteObject`和`java.rmi.activation.Activatable`。

`UnicastRemoteObject` 类的作用包括：

- 导出远程对象：通过继承 `UnicastRemoteObject` 类或调用 `exportObject` 方法，可以将一个普通的Java对象转换为远程对象，使其能够接收远程调用。
- 远程对象的生命周期管理：`UnicastRemoteObject` 类提供了一些方法用于管理远程对象的生命周期，如 `unexportObject` 方法用于取消导出远程对象。
- RMI通信的基础支持：`UnicastRemoteObject` 类提供了与RMI通信相关的基础支持，如实现了 `Remote` 接口以标识远程对象，同时提供了一些内部实现用于处理远程调用。

`UnicastRemoteObject` 类包含以下重要的方法：

1. `UnicastRemoteObject()`：构造一个新的 `UnicastRemoteObject` 对象。
2. `UnicastRemoteObject(int port)`：在指定端口上创建一个新的 `UnicastRemoteObject` 对象。
3. `UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)`：在指定端口上创建一个新的 `UnicastRemoteObject` 对象，使用指定的客户端和服务器端套接字工厂。
4. `static RemoteStub exportObject(Remote obj)`：导出远程对象并返回其 stub。
5. **`static RemoteStub exportObject(Remote obj, int port)`：导出远程对象并返回其 stub，在指定端口上监听。参数 `obj` 是要导出的远程对象，参数 `port` 是要监听的端口号。如果端口号为 0，则系统会自动选择一个可用的端口。**
6. `static boolean unexportObject(Remote obj, boolean force)`：取消导出远程对象。
7. `static Object toStub(Remote obj)`：返回远程对象的 stub。

这些方法用于导出和管理远程对象，使其能够被远程客户端访问。

------

`LocateRegistry` 类是 Java RMI 中用于定位远程注册表的工具类。它提供了一组静态方法，用于获取远程注册表的引用。`LocateRegistry` 类的方法包括：

`LocateRegistry` 类的方法包括：

- **`static Registry getRegistry(String host, int port)`：返回指定主机和端口上的远程注册表引用。**
- `static Registry getRegistry(String host, int port, RMIClientSocketFactory csf)`：返回指定主机和端口上的远程注册表引用，并使用指定的客户端套接字工厂创建套接字连接。
- `static Registry getRegistry(String host, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)`：返回指定主机和端口上的远程注册表引用，并使用指定的客户端套接字工厂和服务器套接字工厂创建套接字连接。
- **`static Registry createRegistry(int port)`：在本地主机上的指定端口上创建并返回远程注册表引用。**

------

`Registry` 类是 Java RMI 中的一个类，用于提供远程对象的注册和查找服务。它允许远程客户端查找和访问在远程主机上注册的远程对象。

`Registry` 类的主要方法包括：

- `void bind(String name, Remote obj)`：将指定的远程对象与指定的名称在此注册表中进行绑定。
- `void unbind(String name)`：从此注册表中移除指定名称的绑定。
- **`Remote lookup(String name)`：返回指定名称绑定的远程对象的引用。**
- **`void rebind(String name, Remote obj)`：将指定的远程对象与指定的名称在此注册表中进行重新绑定。**
- `String[] list()`：返回此注册表中的所有绑定名称的数组。

这些方法允许远程对象在注册表中注册、查找和解绑，从而实现了远程对象之间的通信和访问。












