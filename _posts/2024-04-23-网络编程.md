---
layout: post
title: 网络编程
categories: Java
description: Java笔记
keywords: Java
---

# 网络编程

常见服务和对应端口号  

| 端口 | 对应服务   |
| ---- | ---------- |
| 7    | Echo服务器 |
| 21   | Ftp        |
| 23   | telnet     |
| 25   | SMTP       |
| 79   | Finger     |
| 80   | HTTP       |
| 443  | HTTPS      |



## URL类

| 构造方法                                                     | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `public URL(String spec);`                                   | `URL u1 =new URL("http://home.netscape.com/home/");`         |
| `public URL(URL context, String spec);`                      | `URL u2=new URL(u1, "welcome.html");`                        |
| `public URL(String protocol, String host, String file);`     | `URL u3=new URL("http", "www.sun.com",developers/index.html");` |
| `public URL (String protocol, String host, int port, String file)` | `URL u4 = new URL("http", "www.sun.com", 80,"developers/index.html" );` |

`java.net.URL` 类提供了许多用于处理 URL 的方法。以下是一些常用方法：

| 方法                             | 描述                                                 |
| -------------------------------- | ---------------------------------------------------- |
| `String getProtocol()`           | 获取 URL 的协议部分，例如 `http`、`https` 等。       |
| `String getHost()`               | 获取 URL 的主机名部分。                              |
| `int getPort()`                  | 获取 URL 的端口号部分。                              |
| `String getPath()`               | 获取 URL 的路径部分。                                |
| `String getQuery()`              | 获取 URL 的查询部分。                                |
| `String getFile()`               | 获取 URL 的文件名部分。                              |
| `URLConnection openConnection()` | 打开与此 URL 的连接，并返回一个 URLConnection 对象。 |
| `InputStream openStream()`       | 打开与此 URL 的连接，并返回一个 InputStream 对象。   |
| `boolean equals(Object obj)`     | 比较此 URL 与指定对象是否相等。                      |
| `String toString()`              | 返回 URL 的字符串表示形式。                          |

## URLConnection抽象类

`Uonnection`类支持`URL`连接的输入/输出流方式的通信,并可以获得`URL`对象资源的相关信息。它是所有应用程序和`URL`连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。  

常用的方法：  

| 方法                                                | 说明                                                         |
| --------------------------------------------------- | ------------------------------------------------------------ |
| `void connect()`                                    | 打开与 URL 引用的资源的通信链接。                            |
| `Object getContent()`                               | 获取此 URLConnection 的内容。                                |
| `String getHeaderField(int n)`                      | 返回与此 URLConnection 的给定字段相关联的值。                |
| `long getLastModified()`                            | 获取指定资源的最后修改日期。                                 |
| `int getContentLength()`                            | 获取指定资源的内容长度。                                     |
| `String getContentType()`                           | 获取指定资源的内容类型。                                     |
| `InputStream getInputStream()`                      | 返回一个输入流，用于从连接到 URL 的资源读取数据。            |
| `OutputStream getOutputStream()`                    | 返回一个输出流，用于将数据写入到与 URLConnection 关联的资源。 |
| `void setDoOutput(boolean dooutput)`                | 将 doOutput 字段的值设置为指定值。                           |
| `void setDoInput(boolean doinput)`                  | 将 doInput 字段的值设置为指定值。                            |
| `void setRequestMethod(String method)`              | 设置请求方法。                                               |
| `void setRequestProperty(String key, String value)` | 设置指定的请求头字段的值。                                   |
| `void addRequestProperty(String key, String value)` | 添加一个请求属性。                                           |
| `Map<String, List<String>> getHeaderFields()`       | 返回与此 URLConnection 关联的请求头字段的映射。              |
| `String getContentEncoding()`                       | 返回指定资源的内容编码。                                     |
| `int getConnectTimeout()`                           | 返回与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。 |
| `int getReadTimeout()`                              | 返回从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。 |
| `void setConnectTimeout(int timeout)`               | 设置与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。 |
| `void setReadTimeout(int timeout)`                  | 设置从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。 |

示例：将baidu内容重定向到Demo.txt  

```java
BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("Demo.txt", true)));
URL url2 = new URL("https://www.baidu.com");
URLConnection conn = url2.openConnection();
conn.setDoOutput(true);
conn.connect();
String nextLine;
StringBuilder sb=new StringBuilder();
BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
while ((nextLine = br.readLine()) != null){
    sb.append(nextLine);
}
bw.write(sb.toString());
bw.close();
br.close();
```

## TCP通信

### Socket概念

一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于**特权端口**，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。

使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。

当Socket连接成功地在服务器端和客户端之间建立后：

- 对服务器端来说，它的Socket是指定的IP地址和指定的端口号；
- 对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。

Socket通常用来实现client-server连接。`java.net`包中定义的两个类`Socket`和`ServerSocket`,分别用来实现双向连接的`client`和`server`端.  

创建`TCP Socket`需要的四个信息：

- 本地系统的`IP`
- 本地应用程序使用的`TCP`端口号
- 远程系统的`IP`
- 远程应用程序相应的`TCP`端口号  

### InetAddress类

要获取`InetAddress` 类实例，可以使用其静态方法：

1. `InetAddress getByAddress(byte[] addr)`：根据原始 IP 地址获取 InetAddress 实例。
2. `InetAddress getByAddress(String host, byte[] addr)`：根据主机名和原始 IP 地址获取 InetAddress 实例。
3. `InetAddress getByName(String host)`：根据主机名获取 InetAddress 实例。
4. `InetAddress[] getAllByName(String host)`：根据主机名获取所有与之关联的 InetAddress 实例数组。
5. `InetAddress getLocalHost()`：获取本地主机的 InetAddress 实例。

这些静态方法可用于创建 InetAddress 实例，以便与网络通信。

`InetAddress` 类的常用方法包括：

1. `getHostName()`：获取主机名。
2. `getCanonicalHostName()`：获取主机的全限定域名。
3. `getHostAddress()`：获取主机的 IP 地址字符串。
4. `isReachable(int timeout)`：测试是否可以达到该主机，在指定的超时时间内。
5. `isReachable(NetworkInterface netif, int ttl, int timeout)`：测试是否可以达到该主机，使用指定的网络接口和生存时间（TTL）。

这些方法可用于获取主机名、IP 地址、测试主机的可达性等操作。

### Socket类

**Socket类构造器**  

- `Socket()`: 创建一个未连接的Socket对象。
- `Socket(InetAddress address, int port)`: 创建一个Socket对象，并将其连接到指定的远程地址和端口号。
- `Socket(InetAddress address, int port, boolean stream)`: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，指定是否使用流模式。
- `Socket(InetAddress address, int port, InetAddress localAddr, int localPort)`: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，并绑定到指定的本地地址和端口号。
- `Socket(String host, int port)`: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号。
- `Socket(String host, int port, boolean stream)`: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，指定是否使用流模式。
- `Socket(String host, int port, InetAddress localAddr, int localPort)`: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，并绑定到指定的本地地址和端口号。
- `ServerSocket(int port)`: 创建一个ServerSocket对象，绑定到指定的端口号。
- `ServerSocket(int port, int count)`: 创建一个ServerSocket对象，绑定到指定的端口号，并指定等待连接的队列长度。

**Socket的常用方法**  

- `connect(SocketAddress endpoint)`: 连接到指定的远程端点。
- `getInputStream()`: 返回此套接字的输入流。
- `getOutputStream()`: 返回此套接字的输出流。
- `close()`: 关闭套接字连接。
- `isConnected()`: 返回套接字连接的状态。
- `isClosed()`: 返回套接字是否已关闭。
- `getInetAddress()`: 获取远程连接的IP地址。
- `getLocalAddress()`: 获取本地连接的IP地址。
- `getPort()`: 获取远程连接的端口号。
- `getLocalPort()`: 获取本地连接的端口号。
- `setSoTimeout(int timeout)`: 设置套接字的读取超时时间。
- `setKeepAlive(boolean on)`: 设置套接字是否在空闲时保持连接。
- `setTcpNoDelay(boolean on)`: 设置是否启用 Nagle 算法。

### ServerSocket类

ServerSocket类用于侦听一个客户端的Socket连接,如果没有连接,它将一直等待。  

**ServerSocket构造器**  

| 构造方法                                                   | 说明                                                         |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| `ServerSocket(int port)`                                   | 用指定的端口`port`来创建一个侦听`Socket`                     |
| `ServerSocket(int port,int backlog)`                       | 加上一个用来改变连接队列长度的参数`backlog`.                 |
| `ServerSocket(int port,int backlog,lnetAddress localAddr)` | 在机器存在多个`IP`地址的情况下,允许通过`localAddr`这个参数来指定侦听的`IP`地址。 |

**ServerSocket类的常用方法包括**

- `accept()`: 监听并接受到此套接字的连接。
- `bind(SocketAddress endpoint)`: 将套接字绑定到特定的本地地址和端口。
- `close()`: 关闭套接字。
- `getInetAddress()`: 返回此套接字的本地地址。
- `getLocalPort()`: 返回此套接字绑定的本地端口。
- `setSoTimeout(int timeout)`: 设置通过`accept()`方法接受客户端连接的超时时间。
- `getSoTimeout()`: 获取通过`accept()`方法接受客户端连接的超时时间。

这些方法可用于管理ServerSocket的状态并与客户端进行通信。

### TCP使用实例

服务端程序编写  

1.  调用`ServerSocket(int port)`创建一个服务端套接字，并绑定到指定端口上；
2.  调用`accept()`监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；
3.  调用`socket`类的`getOutputStream()`和`getlnputStream()`获取输入流和输出流
4.  关闭`socket`；

客户端程序编写  

1.  调用`Socket()`创建流套接字，并链接到服务端；
3.  调用`socket`类的`getOutputStream()`和`getInputStream()`获取输入流和输出流；
4.  关闭`socket`；

客户端Socket的建立，链接服务器。  

```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        try {  
            Socket socket = new Socket("127.0.0.1", 2000);  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```

服务器端Socket的建立  

```java
package com.aotmd.test;  
import java.io.IOException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
        ServerSocket server = null;  
        try {  
            server = new ServerSocket(2000);  
        } catch (IOException e) {  
            System.out.println("can not listen to :" + e);  
        }  
        Socket socket = null;  
        try {  
            socket = server.accept();  
        } catch (IOException e) {  
            System.out.println("Error:" + e);  
        }  
    }  
}
```

打开输入/出流  

```java
PrintStream os = new PrintStream(new BufferedOutputStream(socket.getOutputStream());  
DataInputStream is = new DataInputStream(socket.getInputStream());
```

关闭Socket  

```java
os.close();is.close();socket.close();
```

简单的`client`/`server`程序  

```java
package com.aotmd.test;  
import java.io.*;  
import java.net.ConnectException;  
import java.net.ServerSocket;  
import java.net.Socket;  
public class NoteTest {  
    public static void main(String[] args) {  
    }  
}  
class Server1 {  
    public static void main(String[] args) {  
        try {  
            @SuppressWarnings("resource")  
            ServerSocket s = new ServerSocket(8888);  
            while (true) {  
                Socket s1 = s.accept();  
                OutputStream os = s1.getOutputStream();  
                DataOutputStream dos = new DataOutputStream(os);  
                dos.writeUTF("Hello," + s1.getInetAddress() + "port#" + s1.getPort() + "bye-bye!");  
                dos.close();  
                s1.close();  
                // s.close();  
            }  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
}  
class Client1 {  
    public static void main(String[] args) {  
        try {  
            Socket s1 = new Socket("127.0.0.1", 8888);  
            InputStream is =s1.getInputStream();  
            DataInputStream dis = new DataInputStream(is);  
            System.out.println(dis.readUTF());  
            dis.close();  
            s1.close();  
        } catch (ConnectException connExc) {  
            System.err.println("服务器连接失败！");  
        } catch (IOException e) {  
        }  
    }  
}
```

先运行服务器,然后运行客户端,会收到服务器发的信息.  

例子二  

```java
class Server1 {
    public static void main(String[] args) throws IOException {
        ServerSocket server = null;
        try {
            server = new ServerSocket(1234);
            while (true) {
                Socket sk = server.accept();
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sk.getOutputStream()));
                bw.write("你好，端口" + sk.getPort() + "，你成功连接了服务器：" + server.getLocalPort()+"\n");
                bw.flush();
                BufferedReader br = new BufferedReader(new InputStreamReader(sk.getInputStream()));
                System.out.println(sk.getPort() +":"+br.readLine());
                br.close();
                bw.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            server.close();
        }
    }
}
class Client1 {
    public static void main(String[] args) {
        Socket client;
        PrintStream ps;
        try {
            client = new Socket("localhost", 1234);
            BufferedReader br = new BufferedReader(new InputStreamReader(client.getInputStream()));
            System.out.println(br.readLine());
            ps = new PrintStream(client.getOutputStream());
            ps.println("哦，真好！");
            ps.flush();
            client.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

例子三：

服务端：

```java
class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(6666); // 监听指定端口
        System.out.println("服务器正在运行...");
        for (;;) {
            Socket sock = ss.accept();//每有一个新客户端就返回一个Socket
            System.out.println("connected from " + sock.getRemoteSocketAddress());
            // 用新线程处理
            Thread t = new Thread(()->{
                try (InputStream input = sock.getInputStream();
                     OutputStream output = sock.getOutputStream()
                ) {
                    BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
                    BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
                    writer.write("你好!\n");//注意加换行符，要不然客户端不会结束读取。
                    writer.flush();
                    for (;;) {
                        String s = reader.readLine();//若没有新内容则阻塞。
                        if (s.equals("再见")) {
                            writer.write("再见\n");
                            writer.flush();
                            break;//结束线程
                        }
                        writer.write("好的: " + s + "\n");
                        writer.flush();
                    }
                } catch (Exception e) {
                    try {
                        sock.close();
                    } catch (IOException ioe) {
                    }
                    System.out.println("客户端已断开连接.");
                }
            });
            t.start();
        }
    }
}
```

代码`ss.accept()`表示每当有新的客户端连接进来后，就返回一个`Socket`实例，这个`Socket`实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，就必须为每个新的`Socket`创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。

如果没有客户端连接进来，`accept()`方法会阻塞并一直等待。如果有多个客户端同时连接进来，`ServerSocket`会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用`accept()`就可以获取新的连接。

客户端：

```java
class Client {
    public static void main(String[] args) throws IOException {
        Socket sock = new Socket("localhost", 6666); // 连接指定服务器端口
        try (InputStream input = sock.getInputStream();
             OutputStream output = sock.getOutputStream()) {
            var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
            var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
            Scanner scanner = new Scanner(System.in);
            System.out.println("[服务器] " + reader.readLine());
            for (;;) {
                System.out.print(">>> "); // 打印提示
                String s = scanner.nextLine(); // 读取一行输入
                writer.write(s);
                writer.newLine();//换行符
                writer.flush();
                String resp = reader.readLine();// 若没有新内容则阻塞。
                System.out.println("<<< " + resp);
                if (resp.equals("再见")) {
                    break;
                }
            }
        }
        sock.close();
        System.out.println("断开连接.");
    }
}
```

当Socket连接创建成功后，无论是服务器端，还是客户端，都使用`Socket`实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用`InputStream`和`OutputStream`来封装Socket的数据流，这样使用Socket的流，和普通IO流类似：

```java
// 用于读取网络数据:
InputStream in = sock.getInputStream();
// 用于写入网络数据:
OutputStream out = sock.getOutputStream();
```

如果不调用`flush()`，很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而又想强制把这些数据发送到网络，就必须调用`flush()`强制把缓冲区数据发送出去。

### URL与Socket通信的区别

利用`URL`进行通信与利用`socket`进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：  

利用`socket`进行通信时，在服务器端运行一个`socket`通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在`socket`通信方式中，服务器是主动等待连接通信的到来。  

利用`URL`进行通信时，在服务器端常驻一个`CGI`程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在`URL`通信方式中，服务器是被动等待连接通信的到来。  

## UDP通信

在基于`TCP/IP`网络体系结构的网络中主要使用`TCP`和`UDP`（`UserDatagramProtocol`，用户数据报协议）来实现数据通信。`TCP`是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而`UDP`则是一种面向无连接的不可靠传输协议，它**不能**确保数据能正确到达目的端，但是它能**提高网络通信的效率**。  

在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。

**UDP Socket特性**  

通过UDP的UDP端口来实现UDP协议的网络通信。  

其工作过程如下：  

- 创建一个适当的要发送且注明收发人地址数据报；  
- 为一个特定的应用程序建立一个传输端口来传送和接收数据包；  
- 将数据报插入一个传输端口中进行传输；  
- 等待接收来自于传输端口的一个数据报；  
- 解码数据报以解开消息、接收者和其它信息；  

### DatagramSocket类

`DatagramSocket` 类是用于实现 UDP 协议的套接字。

构造方法：  

- `DatagramSocket()`：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）  
- `DatagramSocket(int port)`：创建实例，并固定监听`Port`端口的报文。通常用于服务端  
- `DatagramSocket(int port,InetAddress localAddr)`：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自`LocalAddr`的报文。  

方法：

1. `void bind(SocketAddress addr)`：将套接字绑定到指定的本地地址和端口号。
2. `void close()`：关闭套接字。
3. `void connect(InetAddress address, int port)`：将套接字连接到指定的远程主机和端口号。
4. `void disconnect()`：断开与远程主机的连接。
5. `boolean getBroadcast()`：获取套接字的广播状态。
6. `Object getOption(int optID)`：获取套接字选项的当前值。
7. `int getPort()`：获取套接字绑定的本地端口号。
8. `SocketAddress getLocalSocketAddress()`：获取套接字绑定的本地地址。
9. `InetAddress getLocalAddress()`：获取套接字绑定的本地 IP 地址。
10. `int getLocalPort()`：获取套接字绑定的本地端口号。
11. `SocketAddress getRemoteSocketAddress()`：获取套接字连接的远程地址。
12. `boolean isBound()`：检查套接字是否绑定到本地地址。
13. `boolean isConnected()`：检查套接字是否连接到远程主机。
14. `void receive(DatagramPacket p)`：接收一个数据包。
15. `void send(DatagramPacket p)`：发送一个数据包。
16. `void setBroadcast(boolean on)`：设置套接字的广播状态。
17. `void setOption(int optID, Object value)`：设置套接字选项的值。
18. `void setSoTimeout(int timeout)`：设置套接字的超时时间（接收数据时的超时时间）。
19. `int getSoTimeout()`：获取套接字的超时时间。
20. `String toString()`：返回套接字的字符串表示形式。

------

### DatagramPacket类

`DatagramPacket` 类表示数据报包，它包含了要发送或接收的数据以及目标地址和端口号等信息。

常用构造方法：

- `DatagramPacket(byte[] buf, int length)`: 创建一个数据报包，用于发送长度为 `length` 的数据，数据存储在 `buf` 中。
- `DatagramPacket(byte[] buf, int length, InetAddress address, int port)`: 创建一个数据报包，用于发送长度为 `length` 的数据到指定的地址和端口。
- `DatagramPacket(byte[] buf, int offset, int length)`: 创建一个数据报包，用于发送从 `buf` 的偏移量 `offset` 开始的 `length` 长度的数据。
- `DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)`: 创建一个数据报包，用于发送从 `buf` 的偏移量 `offset` 开始的 `length` 长度的数据到指定的地址和端口。
- `DatagramPacket(byte[] buf, int length, SocketAddress address)`: 创建一个数据报包，用于发送长度为 `length` 的数据到指定的地址和端口。
- `DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)`: 创建一个数据报包，用于发送从 `buf` 的偏移量 `offset` 开始的 `length` 长度的数据到指定的地址和端口。

这些构造方法可以用于创建不同类型的数据报包，以便发送或接收数据。

`DatagramPacket` 类的常用方法包括：

- `getData()`: 返回数据报包中的数据字节数组。
- `getLength()`: 返回数据报包中数据的长度。
- `getAddress()`: 返回数据报包的目标地址。
- `getPort()`: 返回数据报包的目标端口号。
- `setData(byte[] buf)`: 设置数据报包的数据字节数组。
- `setLength(int length)`: 设置数据报包的数据长度。
- `setAddress(InetAddress address)`: 设置数据报包的目标地址。
- `setPort(int port)`: 设置数据报包的目标端口号。
- `getSocketAddress()`: 返回数据报包的套接字地址。
- `setSocketAddress(SocketAddress address)`: 设置数据报包的套接字地址。

这些方法可以在数据报包中读取和设置数据，以及获取目标地址和端口号等信息。

------

### UDP使用实例

在服务器端，使用UDP也需要监听指定的端口。

```java
DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口
for (;;) { // 无限循环
    // 数据缓冲区:
    byte[] buffer = new byte[1024];
    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
    ds.receive(packet); // 收取一个UDP数据包,阻塞
    // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度，将其按UTF-8编码转换为String:
    String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
    System.out.println(s);
    // 发送数据:
    byte[] data = "ACK".getBytes(StandardCharsets.UTF_8);
    packet.setData(data);//设置数据包。
    ds.send(packet);//发送
}
```

当服务器收到一个`DatagramPacket`后，通常必须立刻回复一个或多个UDP包，因为客户端地址在`DatagramPacket`中，每次收到的`DatagramPacket`可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。UDP 是无连接的协议，服务器在接收到 UDP 数据报后，通常需要**立即**给客户端发送响应，以确保通信的连续性和可靠性。没有响应的话，客户端**可能会超时或者认为连接失败**。

客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：

```java
DatagramSocket ds = new DatagramSocket();
ds.setSoTimeout(1000);//设置超时时间
ds.connect(InetAddress.getByName("localhost"), 6666); // 连接指定服务器和端口

byte[] data = "Hello".getBytes();
DatagramPacket packet = new DatagramPacket(data, data.length);
ds.send(packet);// 发送

byte[] buffer = new byte[1024];
packet = new DatagramPacket(buffer, buffer.length);
ds.receive(packet);// 收取一个UDP数据包,阻塞,超过超时时间则异常
String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());
System.out.println(resp);
ds.disconnect();// 关闭
ds.close();
```

客户端创建`DatagramSocket`实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用`setSoTimeout(1000)`设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。

客户端的`DatagramSocket`还调用了一个`connect()`方法“连接”到指定的服务器端。

这个`connect()`方法不是真连接，它是为了在客户端的`DatagramSocket`实例中保存服务器端的IP和端口号，确保这个`DatagramSocket`实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。

后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。

如果客户端认为通信结束，就可以调用`disconnect()`断开连接：

```java
ds.disconnect();
```

`disconnect()`也不是真正地断开连接，它只是清除了客户端`DatagramSocket`实例记录的远程服务器地址和端口号，这样，`DatagramSocket`实例就可以连接另一个服务器端。

如果客户端希望向两个不同的服务器发送UDP包，有两种方法：

1. 客户端可以创建两个`DatagramSocket`实例，用`connect()`连接到不同的服务器；
2. 客户端也可以不调用`connect()`方法，而是在创建`DatagramPacket`的时候指定服务器地址，这样可以用一个`DatagramSocket`实例发送`DatagramPacket`到不同的服务器。

不调用`connect()`方法的代码如下：

```java
DatagramSocket ds = new DatagramSocket();
ds.setSoTimeout(1000);
InetAddress localhost = InetAddress.getByName("localhost");
// 发送到localhost:6666:
byte[] data1 = "Hello".getBytes();
var packet1 = new DatagramPacket(data1, data1.length, localhost, 6666);
ds.send(packet1);
// 发送到localhost:8888:
byte[] data2 = "Hi".getBytes();
var packet2 = new DatagramPacket(data2, data2.length, localhost, 8888);
ds.send(packet2);
// 关闭:
ds.close();
```



## 发送Email

Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如`abc@example.com`，邮件软件比如Outlook都是用来收发邮件的。

使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。

传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：

```ascii
           ┌──────────┐    ┌──────────┐
           │PostOffice│    │PostOffice│     .───.
┌─────┐    ├──────────┤    ├──────────┤    (   ( )
│═══ ░│──▶│ ┌─┐ ┌┐┌┐  │──▶│ ┌─┐ ┌┐┌┐ │──▶ `─┬─'
└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
           └─┴─┴──────┘    └─┴─┴──────┘       │
```

电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：

```ascii
             ┌─────────┐    ┌─────────┐    ┌─────────┐
             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
│       │──▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀──│       │
└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
   MUA           MTA            MTA            MDA           MUA
```

类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；

邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；

最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。

电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。

MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。

MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。

SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，无需关心SMTP协议的底层原理，只需要使用`JavaMail`这个标准API就可以直接发送邮件。

------

假设准备使用自己的邮件地址`me@example.com`给小明发送邮件，已知小明的邮件地址是`xiaoming@somewhere.com`，发送邮件前，首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是`smtp.example.com`，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：

- QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；
- 163邮箱：SMTP服务器是smtp.163.com，端口是465；
- Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。

有了SMTP服务器的域名和端口号，还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。

使用`JavaMail`发送邮件，需要把`JavaMail`相关的两个依赖加入进来，注意版本号相同：

```xml
<!-- https://mvnrepository.com/artifact/jakarta.mail/jakarta.mail-api -->
<dependency>
    <groupId>jakarta.mail</groupId>
    <artifactId>jakarta.mail-api</artifactId>
    <version>2.0.1</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.sun.mail/jakarta.mail -->
<dependency>
    <groupId>com.sun.mail</groupId>
    <artifactId>jakarta.mail</artifactId>
    <version>2.0.1</version>
</dependency>
```

这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：

```xml
<!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api -->
<dependency>
    <groupId>javax.mail</groupId>
    <artifactId>javax.mail-api</artifactId>
    <version>1.6.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.sun.mail/javax.mail -->
<dependency>
    <groupId>com.sun.mail</groupId>
    <artifactId>javax.mail</artifactId>
    <version>1.6.2</version>
</dependency>
```

并且代码引用的`jakarta.mail`需替换为`javax.mail`。

------

### 验证发送方信息

`Session`类是`JavaMail` API中表示邮件会话的类，它包含了创建和管理邮件的相关方法。以下是`Session`类的一些常用方法：

1. `getSession(Properties props, Authenticator authenticator)`：静态方法，用于获取`Session`实例。需要传入`Properties`对象和`Authenticator`对象来配置会话属性和认证信息。
2. `getTransport(String protocol)`：获取指定协议的`Transport`对象，用于发送邮件。
3. `getStore(String protocol)`：获取指定协议的`Store`对象，用于接收邮件。
4. `getDebug()`：获取调试模式的状态。
5. `setDebug(boolean debug)`：设置调试模式的状态。
6. `setProtocolForAddress(String type, String protocol)`：设置指定地址类型对应的协议。
7. `setProvider(Provider provider)`：设置指定协议的提供者。
8. `getProperty(String name)`：获取指定属性名的属性值。
9. `setProperty(String name, String value)`：设置指定属性名的属性值。
10. **`getDefaultInstance(Properties props, Authenticator authenticator)`：静态方法，获取默认的`Session`实例。**

这些方法可以帮配置和管理邮件会话，以及创建`Transport`和`Store`对象来发送和接收邮件。

------

`Session` 可以配置的一些常见属性包括：

- `mail.smtp.host`: SMTP 服务器主机名。
- `mail.smtp.port`: SMTP 服务器端口号。
- `mail.smtp.auth`: 指定是否需要进行用户认证，通常为 `"true"`。
- `mail.smtp.starttls.enable`: 指定是否启用 STARTTLS 加密，通常为 `"true"`。
- `mail.smtp.socketFactory.class`: 指定用于创建 SMTP 套接字的 `SocketFactory` 类的名称。
- `mail.smtp.socketFactory.fallback`: 指定是否在连接失败时回退到普通套接字，通常为 `"false"`。
- `mail.smtp.socketFactory.port`: 指定用于创建 SMTP 套接字的端口号。
- `mail.smtp.connectiontimeout`: 指定连接超时时间。
- `mail.smtp.timeout`: 指定读取超时时间。
- `mail.smtp.writetimeout`: 指定写入超时时间。

这些属性可以用于配置 `Session` 实例，以控制邮件发送的行为和连接设置。

------

通过`JavaMail` API连接到SMTP服务器上：

```java
import jakarta.mail.Authenticator;
import jakarta.mail.PasswordAuthentication;
import jakarta.mail.Session;
...
// 服务器地址:
String smtp = "smtp.163.com";
// 登录用户名:
String username = "XXX@163.com";
// 登录口令:
String password = "********";
// 连接到SMTP服务器587端口:
Properties props = new Properties();
props.put("mail.smtp.host", "smtp.163.com"); // SMTP主机名
props.put("mail.smtp.port", "587"); // 主机端口号
props.put("mail.smtp.auth", "true"); // 是否需要用户认证
props.put("mail.smtp.starttls.enable", "false"); // 不启用TLS加密
props.put("mail.smtp.ssl.enable", "true"); // 启用SSL加密
props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
// 获取Session实例:
Session session = Session.getInstance(props, new Authenticator() {
    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(username, password);
    }
});
// 设置debug模式便于调试:
session.setDebug(true);
```

以587端口为例，连接SMTP服务器时，需要准备一个`Properties`对象，填入相关信息。获取`Session`实例时，如果服务器需要认证，还需要传入一个`Authenticator`对象，用于提供用户名和密码进行身份验证。获取到`Session`实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。

SSL加密协议就用587端口，并改成以下代码：

```java
props.put("mail.smtp.port", "587"); // 主机端口号
props.put("mail.smtp.starttls.enable", "false"); // 不启用TLS加密
props.put("mail.smtp.ssl.enable", "true"); // 启用SSL加密
props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
```

TLS就用25端口（非SSL协议，看服务器传回的消息里表示会判断这个）：

```java
props.put("mail.smtp.port", "25"); // 主机端口号
props.put("mail.smtp.starttls.enable", "true"); // 启用TLS加密
```

### 发送邮件

`MimeMessage`是`Message`的实现类，用于创建多部分邮件消息。`MimeMessage`类提供了多个构造方法，主要用于创建不同类型的消息。以下是`MimeMessage`类的一些常用构造方法：

1. **`MimeMessage(Session session)`：使用指定的`Session`对象创建`MimeMessage`实例。**
2. `MimeMessage(Session session, InputStream is)`：使用指定的`Session`对象和输入流创建`MimeMessage`实例，从输入流中读取消息内容。
3. `MimeMessage(MimeMessage source)`：使用另一个`MimeMessage`实例创建新的`MimeMessage`实例，复制源消息的内容。
4. `MimeMessage(Session session, byte[] content)`：使用指定的`Session`对象和字节数组创建`MimeMessage`实例，字节数组包含消息的原始内容。
5. `MimeMessage(Session session, InputStream is, InternetHeaders headers)`：使用指定的`Session`对象、输入流和邮件头信息创建`MimeMessage`实例，用于处理邮件头和消息内容分开的情况。

------

`MimeMessage`类提供了许多方法，用于**设置和获取邮件消息的各种属性和内容**。以下是`MimeMessage`类的一些常用方法：

1. **`setSubject(String subject)`：设置邮件主题。**
2. **`setFrom(Address address)`：设置发件人地址。**
3. **`setRecipient(Message.RecipientType type, Address address)`：设置收件人、抄送人或密送人地址。**
   - `Message.RecipientType.TO`：主要收件人（"To"）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。
   - `Message.RecipientType.CC`：抄送（"Cc"），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。
   - `Message.RecipientType.BCC`：秘密抄送（"Bcc"），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。
4. **`setContent(Object content, String contentType)`：设置邮件内容和内容类型。内容可以是字符串、字节数组或`Multipart`对象。**
5. **`setText(String text)`：设置纯文本邮件的内容。**
6. `setSentDate(Date date)`：设置邮件的发送日期。
7. `addHeader(String name, String value)`：添加邮件头。
8. `saveChanges()`：保存对邮件的更改。
9. `getSubject()`：获取邮件主题。
10. `getFrom()`：获取发件人地址。
11. `getRecipients(Message.RecipientType type)`：获取指定类型的收件人、抄送人或密送人地址。
12. `getContent()`：获取邮件内容。
13. `getSentDate()`：获取邮件发送日期。
14. `getAllHeaders()`：获取所有邮件头。
15. `getHeader(String name)`：根据名称获取邮件头的值。
16. `removeHeader(String name)`：移除指定名称的邮件头。
17. `getContentType()`：获取邮件内容类型。

这些方法可以对邮件消息进行各种操作，包括设置和获取邮件的属性、内容，以及添加和移除邮件头等。

------

`InternetAddress` 类用于表示**电子邮件地址**。它有几种不同的构造方法，可以根据需要选择使用：

1. `InternetAddress(String address)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例。
2. `InternetAddress(String address, boolean strict)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例，并指定是否启用严格模式。
3. `InternetAddress(String address, String personal)`：使用给定的电子邮件地址字符串和个人名称创建一个 `InternetAddress` 实例。
4. **`InternetAddress(String address, String personal, String charset)`：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 `InternetAddress` 实例。**
5. `InternetAddress(String address, String personal, String charset, boolean strict)`：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 `InternetAddress` 实例。

------

`InternetAddress` 类还提供了一些常用的方法，用于处理电子邮件地址的操作，例如：

1. `String getAddress()`：获取电子邮件地址的地址部分（不包括个人名称）。
2. `String getPersonal()`：获取电子邮件地址的个人名称部分。
3. `void setAddress(String address)`：设置电子邮件地址的地址部分。
4. `void setPersonal(String personal)`：设置电子邮件地址的个人名称部分。
5. `String getType()`：获取电子邮件地址的类型。
6. `void setType(String type)`：设置电子邮件地址的类型。
7. `boolean isGroup()`：检查该地址是否表示一个邮件组。
8. `boolean isUnicodeSupported()`：检查是否支持 Unicode 编码。
9. `String toString()`：将 `InternetAddress` 对象转换为字符串表示形式。

------

`Transport` 类用于**发送邮件消息**。以下是 `Transport` 类的一些常用方法：

1. **`send(Message message)`：发送邮件消息。**
2. `connect()`：连接到邮件服务器。
3. `connect(String host, String user, String password)`：连接到指定主机的邮件服务器。
4. `close()`：关闭连接。
5. `addConnectionListener(ConnectionListener listener)`：添加连接监听器。
6. `removeConnectionListener(ConnectionListener listener)`：移除连接监听器。
7. `addTransportListener(TransportListener listener)`：添加传输监听器。
8. `removeTransportListener(TransportListener listener)`：移除传输监听器。
9. `isConnected()`：检查是否已连接到邮件服务器。
10. `isSSL()`：检查是否使用 SSL 连接。
11. `getURLName()`：获取连接的 URL 名称。
12. `setURLName(URLName urlname)`：设置连接的 URL 名称。
13. `setDebug(boolean debug)`：设置调试模式，用于输出调试信息。

这些方法可以连接到邮件服务器并发送邮件消息。

------

发送邮件时，需要构造一个`Message`对象，然后调用`Transport.send(Message)`即可完成发送：

```java
import jakarta.mail.internet.MimeMessage;
import jakarta.mail.internet.InternetAddress;
import jakarta.mail.MimeMessage;
import jakarta.mail.Transport;
...
MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress("xiaoming@somewhere.com"));
// 设置邮件主题:
message.setSubject("你好!", "UTF-8");
// 设置邮件正文:
message.setText("这是一幅邮件", "UTF-8");
// 发送:
Transport.send(message);
```

绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。

填入真实的地址，运行上述代码，可以在控制台看到`JavaMail`打印的调试信息：

```text
这是JavaMail打印的调试信息:
DEBUG: setDebug: Jakarta Mail version 2.0.1
DEBUG: getProvider() returning jakarta.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]
DEBUG SMTP: need username and password for authentication
DEBUG SMTP: protocolConnect returning false, host=smtp.163.com, user=XXX, password=<null>
DEBUG SMTP: useEhlo true, useAuth true
DEBUG SMTP: trying to connect to host "smtp.163.com", port 587, isSSL true
220 163.com Anti-spam GT for Coremail System (163com[20141201])
开始尝试连接smtp.163.comm:
DEBUG SMTP: connected to host "smtp.163.com", port: 587, ...
发送命令EHLO:
EHLO localhost
SMTP服务器响应250:
...
发送命令STARTTLS:
STARTTLS
SMTP服务器响应250:
...
尝试登录:
DEBUG SMTP: protocolConnect login, host=smtp.163.com, user=XXX@163.com, password=<non-null>
DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 
DEBUG SMTP: Using mechanism LOGIN
DEBUG SMTP: AUTH LOGIN command trace suppressed
登录成功:
DEBUG SMTP: AUTH LOGIN succeeded
DEBUG SMTP: use8bit false
开发发送邮件，设置FROM:
MAIL FROM:发件人
250 2.1.0 Sender OK
设置TO:
RCPT TO:收件人
250 2.1.5 Recipient OK
发送邮件数据:
DATA
服务器响应354:
354 End data with <CR><LF>.<CR><LF>
真正的邮件数据:
Date: 时间
From: 发送方
To: 收件方
Message-ID: <283383329.0.1713860754302@localhost>
邮件主题是编码后的文本:
Subject: =?UTF-8?B?5L2g5aW9IQ==?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

邮件正文是Base64编码的文本:
5oiR5Y+R5LqG5LiA5Lu96YKu5Lu2
发送成功:
DEBUG SMTP: message successfully delivered to mail server
发送QUIT命令:
QUIT
服务器响应221结束TCP连接:
221 Bye
```

从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在[SMTP协议](https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt)中了，查看具体的响应码就可以知道出错原因。

**发送HTML邮件**

发送HTML邮件和文本邮件是类似的，只需要把：

```java
message.setText("这是一幅邮件", "UTF-8");
```

改为：

```java
message.setText("<h1>这是一幅邮件</h1>", "UTF-8", "html");
```

传入的`body`是类似`<h1>Hello</h1><p>Hi, xxx</p>`这样的HTML字符串即可。

### 发送附件

`MimeMultipart` 是 `JavaMail` 中用于处理多部分 MIME 消息的类，`MimeMultipart` 类有多个构造方法，用于创建不同类型的多部分消息。以下是一些常用的构造方法：

1. **`MimeMultipart()`：创建一个空的多部分消息，默认使用混合 (`mixed`) 类型。**
2. `MimeMultipart(String subtype)`：根据指定的子类型创建一个空的多部分消息。常用的子类型包括 `related`（相关）、`alternative`（备选）、`mixed`（混合）等。例如：
   - `MimeMultipart("related")`：创建一个相关类型的多部分消息。
   - `MimeMultipart("alternative")`：创建一个备选类型的多部分消息。
3. `MimeMultipart(javax.mail.internet.ContentType contentType)`：根据指定的 `ContentType` 对象创建一个空的多部分消息。ContentType 对象可以包含主类型、子类型、参数等信息。
4. `MimeMultipart(InputStream is)`：从输入流中读取内容，并根据读取的内容创建一个多部分消息。

这些构造方法提供了不同的方式来创建 `MimeMultipart` 对象，以满足不同场景下的需求。

**常用方法包括：**

1. **`addBodyPart(BodyPart part)`：将一个 `BodyPart` 对象添加到多部分消息中。**
2. `removeBodyPart(int index)`：从多部分消息中移除指定索引位置的 `BodyPart` 对象。
3. `getBodyPart(int index)`：获取多部分消息中指定索引位置的 `BodyPart` 对象。
4. `getBodyPart(String CID)`：根据 Content-ID（CID）获取多部分消息中对应的 `BodyPart` 对象。
5. `getBodyPartCount()`：获取多部分消息中 `BodyPart` 对象的数量。
6. `setSubType(String subtype)`：设置多部分消息的子类型（subtype），例如 "mixed"、"alternative" 等。
7. `setPreamble(String preamble)`：设置消息的开头部分（preamble）。
8. `setEpilogue(String epilogue)`：设置消息的结尾部分（epilogue）。
9. `writeTo(OutputStream os)`：将多部分消息写入输出流中。

------

`MimeBodyPart` 类用于表示邮件的各个部分，包括正文、附件等。它的构造方法相对简单，通常使用默认构造方法创建对象，然后使用 `setContent` 等方法设置内容。以下是 `MimeBodyPart` 的构造方法：

1. **默认构造方法：`MimeBodyPart()`**
2. 使用输入流构造方法：`MimeBodyPart(InputStream is)`
3. 使用 `DataSource` 对象构造方法：`MimeBodyPart(DataSource ds)`

`MimeBodyPart` 类的方法如下：

1. `addHeader(String name, String value)`：添加指定名称和值的头信息。
2. `addHeaderLine(String line)`：添加包含完整头信息行的字符串。
3. `setContentID(String cid)`：设置内容 ID。
4. `setContentLanguage(String[] languages)`：设置内容语言。
5. `setContentTransferEncoding(String encoding)`：设置内容传输编码。
6. **`setDataHandler(DataHandler dh)`：设置数据处理程序。**
7. `setDescription(String description)`：设置描述信息。
8. `setDisposition(String disposition)`：设置附件描述。
9. **`setFileName(String filename)`：设置文件名。**
10. `setHeader(String name, String value)`：设置指定名称的头信息值。
11. `setText(String text)`：设置文本内容。
12. `updateHeaders()`：更新所有头信息。
13. `addRecipient(Message.RecipientType type, Address address)`：添加接收者地址。
14. `getAllHeaders()`：获取所有头信息。
15. `getContentType()`：获取内容类型。
16. `getDataHandler()`：获取数据处理程序。
17. `getDescription()`：获取描述信息。
18. `getDisposition()`：获取附件描述。
19. `getFileName()`：获取文件名。
20. `getHeader(String name)`：根据名称获取头信息值。
21. `getInputStream()`：获取输入流。
22. `getLineCount()`：获取行数。
23. `getSize()`：获取大小。
24. `getText()`：获取文本内容。
25. `isMimeType(String mimeType)`：检查是否与指定的 MIME 类型匹配。
26. `removeHeader(String name)`：移除指定名称的头信息。
27. `setContent(Multipart mp)`：设置内容为多部分。
28. **`setContent(Object obj, String type)`：设置内容对象和类型。**
29. `setContent(Multipart mp)`：设置内容为多部分。
30. `setContentID(String cid)`：设置内容 ID。
31. `setContentLanguage(String[] languages)`：设置内容语言。
32. `setDataHandler(DataHandler dh)`：设置数据处理程序。
33. `setDisposition(String disposition)`：设置附件描述。
34. `setFileName(String filename)`：设置文件名。
35. **`setHeader(String name, String value)`：设置指定名称的头信息值。**
36. `setText(String text)`：设置文本内容。
37. `setText(String text, String charset)`：设置文本内容和字符集。

这些方法可以用于配置和操作 `MimeBodyPart` 对象的各种属性和内容。

------

`DataHandler` 的构造方法通常用于创建一个处理特定数据类型的数据处理程序对象。它有以下几个常用的构造方法：

1. `DataHandler(Object obj, String mimeType)`：使用给定的对象和 MIME 类型创建一个 `DataHandler` 对象。这个构造方法通常用于将 Java 对象转换为数据处理程序。
2. `DataHandler(URL url)`：使用给定的 URL 创建一个 `DataHandler` 对象。这个构造方法通常用于处理指向外部资源的 URL。
3. `DataHandler(DataSource dataSource)`：使用给定的数据源创建一个 `DataHandler` 对象。这个构造方法通常用于处理数据源对象。

这些构造方法根据不同的数据类型和来源创建适当的数据处理程序对象，以便于在应用程序中处理和传输数据。

------

`ByteArrayDataSource` 的构造方法通常用于创建一个包含字节数组数据的数据源对象。它有以下两个常用的构造方法：

1. `ByteArrayDataSource(byte[] data, String type)`：使用给定的字节数组和 MIME 类型创建一个 `ByteArrayDataSource` 对象。
2. `ByteArrayDataSource(InputStream is, String type)`：使用给定的输入流和 MIME 类型创建一个 `ByteArrayDataSource` 对象。

这些构造方法将字节数组或输入流与 MIME 类型关联起来，以便于处理和传输数据。

------

常用文件的 MIME 类型如下：

- 文本文件：`text/plain`
- HTML 文件：`text/html`
- XML 文件：`application/xml`
- JSON 文件：`application/json`
- 图片文件：`image/jpeg`、`image/png`、`image/gif`、`image/webp`
- 视频文件：`video/mp4`、`video/quicktime`
- 音频文件：`audio/mpeg`、`audio/wav`
- PDF 文件：`application/pdf`
- Word 文档：`application/msword`、`application/vnd.openxmlformats-officedocument.wordprocessingml.document`
- Excel 表格：`application/vnd.ms-excel`、`application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
- PowerPoint 演示文稿：`application/vnd.ms-powerpoint`、`application/vnd.openxmlformats-officedocument.presentationml.presentation`
- 压缩文件：`application/zip`
- 二进制文件的 MIME 类型通常是 `application/octet-stream`。这个 MIME 类型通常用于表示未知的二进制数据类型，或者不属于其他已知 MIME 类型的二进制数据。

这些 MIME 类型可以帮助浏览器和其他应用程序识别文件的类型并采取相应的处理方式。

------

要在电子邮件中携带附件，就不能直接调用`message.setText()`方法，而是要构造一个`Multipart`对象：

```java
import jakarta.mail.internet.MimeBodyPart;
import jakarta.mail.internet.MimeMultipart;
import jakarta.mail.util.ByteArrayDataSource;
...
MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress("XXX"));
// 设置邮件主题:
message.setSubject("你好!", "UTF-8");
// 设置邮件正文:
Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent("<h1>这是一幅邮件</h1>", "text/html;charset=utf-8");
multipart.addBodyPart(textpart);
// 添加附件:
BodyPart annex = new MimeBodyPart();
annex.setFileName("附件1.7z");
annex.setDataHandler(new DataHandler(new ByteArrayDataSource(new FileInputStream("Maven.7z"), "application/octet-stream")));
multipart.addBodyPart(annex);
// 设置邮件内容为multipart:
message.setContent(multipart);
// 发送:
Transport.send(message);
```

一个`Multipart`对象可以添加若干个`BodyPart`，其中**第一个**`BodyPart`是文本，即邮件正文，后面的`BodyPart`是附件。

`BodyPart`依靠`setContent()`决定添加的内容。

如果添加文本，用`setContent("...", "text/plain;charset=utf-8")`添加纯文本，或者用`setContent("...", "text/html;charset=utf-8")`添加HTML文本。

如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个`DataHandler()`，传入文件的MIME类型。二进制文件可以用`application/octet-stream`，Word文档则是`application/msword`。

最后，通过`setContent()`把`Multipart`添加到`Message`中，即可发送。

`ByteArrayDataSource` 是 `javax.mail.util.ByteArrayDataSource` 类的一个子类，用于从字节数组中创建数据源对象。在这个特定的代码片段中，它的作用是将 `FileInputStream` 对象中的数据转换为字节数组，并将其作为数据源传递给 `DataHandler` 构造方法。

`DataHandler` 用于将数据封装为一种适合传输的格式，它可以处理各种类型的数据，如字节数组、文件、URL 等。在这里，`ByteArrayDataSource` 负责将文件中的数据读取到字节数组中，然后 `DataHandler` 将这个字节数组封装为一个数据处理程序，以便于传输和处理。

如果去掉`ByteArrayDataSource`，会报错：

```java
annex.setDataHandler(new DataHandler(new FileInputStream("3.png"), "image/png"));
```

报错是因为 `DataHandler` 的构造方法不接受 `FileInputStream` 对象作为参数，而是需要一个 `DataSource` 对象。`ByteArrayDataSource` 实现了 `DataSource` 接口，因此可以作为参数传递给 `DataHandler` 构造方法。如果直接将 `FileInputStream` 传递给 `DataHandler` 构造方法，它将无法识别并处理文件流，从而导致错误。因此，需要使用 `ByteArrayDataSource` 将文件流转换为 `DataSource` 对象，以便 `DataHandler` 可以正确处理图像数据。

### 发送内嵌图片的HTML邮件

`setHeader` 方法用于设置邮件头的值，其参数为邮件头的名称和对应的值。常用的邮件头包括但不限于：

1. `From`：发件人地址。
2. `To`：收件人地址。
3. `Cc`：抄送地址。
4. `Bcc`：密送地址。
5. `Subject`：邮件主题。
6. `Date`：邮件发送时间。
7. `Content-Type`：内容类型。
8. `Content-Disposition`：内容描述。
9. **`Content-ID`：内容 ID。**
10. `MIME-Version`：MIME 版本。
11. `Reply-To`：回复地址。
12. `Return-Path`：返回路径。
13. `Message-ID`：消息 ID。

这些参数的设置可以根据邮件的需求和格式进行配置，以满足邮件发送的要求和格式规范。

------

HTML邮件中可以内嵌图片。如果给一个`<img src="http://example.com/test.jpg">`，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。

内嵌图片实际上也是一个附件，即邮件本身也是`Multipart`，但需要做一点额外的处理：

```java
MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress("XXX"));
// 设置邮件主题:
message.setSubject("你好!", "UTF-8");
// 设置邮件正文:
Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent("<h1>这是一个带图片的邮件</h1><p><img src='cid:img01'", "text/html;charset=utf-8");
multipart.addBodyPart(textpart);
// 添加附件:
BodyPart annex = new MimeBodyPart();
annex.setFileName("图片1.png");
annex.setDataHandler(new DataHandler(new ByteArrayDataSource(new FileInputStream("3.png"), "image/png")));
annex.setHeader("Content-ID","<img01>");
multipart.addBodyPart(annex);
// 设置邮件内容为multipart:
message.setContent(multipart);
// 发送:
Transport.send(message);
```

在HTML邮件中引用图片时，需要设定一个ID，用类似`<img src=\"cid:img01\">`引用，然后，在添加图片作为`BodyPart`时，除了要正确设置MIME类型（根据图片类型使用`image/jpeg`或`image/png`），还需要设置一个Header：`imagepart.setHeader("Content-ID", "<img01>");`。

### 发送给多个收件人

**设置收件人和发件人：**

- `addFrom(Address[] addresses)`: 添加发件人地址。
- `addFrom(String addresses)`: 添加发件人地址。
- `addRecipient(Message.RecipientType type, Address address)`: 添加指定类型的收件人地址。
- `addRecipients(Message.RecipientType type, Address[] addresses)`: 添加指定类型的收件人地址。
- `addRecipients(Message.RecipientType type, String addresses)`: 添加指定类型的收件人地址。
- `addRecipient(String type, String address)`: 添加指定类型的收件人地址。
- `addRecipients(String type, String addresses)`: 添加指定类型的收件人地址。
- `setFrom(Address address)`: 设置发件人地址。
- `setFrom(String address)`: 设置发件人地址。
- `setRecipient(Message.RecipientType type, Address address)`: 设置指定类型的收件人地址。
- `setRecipients(Message.RecipientType type, Address[] addresses)`: 设置指定类型的收件人地址。
- `setRecipients(Message.RecipientType type, String addresses)`: 设置指定类型的收件人地址。
- `setRecipient(String type, Address address)`: 设置指定类型的收件人地址。
- `setRecipients(String type, String addresses)`: 设置指定类型的收件人地址。
- `setReplyTo(Address[] addresses)`: 设置回复地址。

`Message.RecipientType`：

- `Message.RecipientType.TO`：主要收件人（"To"）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。
- `Message.RecipientType.CC`：抄送（"Cc"），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。
- `Message.RecipientType.BCC`：秘密抄送（"Bcc"），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。

------

要设置多个收件人，可以使用`addRecipients`方法或`setRecipients`方法。这些方法允许为消息的不同类型（如TO、CC、BCC）添加多个收件人。以下是使用这些方法设置多个收件人的示例：

```java
MimeMessage message = new MimeMessage(session);
// 添加多个收件人
message.addRecipients(Message.RecipientType.TO, "recipient1@example.com, recipient2@example.com");
// 或者使用数组
Address[] recipients = {
    new InternetAddress("recipient1@example.com"),
    new InternetAddress("recipient2@example.com")
};
message.addRecipients(Message.RecipientType.TO, recipients);
```

注意，在使用`addRecipients`方法时，**多个收件人应使用逗号分隔**。还可以使用类似的方法设置CC和BCC收件人。

`addRecipient`方法可以多次调用以添加多个收件人，而`setRecipient`方法会覆盖之前设置的收件人。因此，如果需要设置多个收件人，应该使用`addRecipient`方法。

如果需要设置收件人、抄送（CC）和密送（BCC）等多个收件人，应该使用`addRecipient`方法多次调用来添加不同类型的收件人。例如，可以按照以下方式设置多个收件人：

```java
message.setRecipient(Message.RecipientType.TO, new InternetAddress("recipient1@example.com"));
message.addRecipient(Message.RecipientType.TO, new InternetAddress("recipient2@example.com"));
message.addRecipient(Message.RecipientType.CC, new InternetAddress("cc@example.com"));
message.addRecipient(Message.RecipientType.BCC, new InternetAddress("bcc@example.com"));
```

而对于多个发件人，SMTP 协议规定邮件的 `From` 字段只能有一个发件人。如果需要发送给多个人，但每个人看到的发件人应该不同，可以考虑使用群发邮件的方式，即将所有收件人放在收件人列表中，但在邮件内容中区分不同的收件人。如果需要在邮件内容中显示不同的发件人，可以在邮件内容中自定义发件人的显示方式，例如在邮件正文中注明发件人姓名或其他标识。

### 设置别名

`InternetAddress` 类用于表示**电子邮件地址**。它有几种不同的构造方法，可以根据需要选择使用：

1. `InternetAddress(String address)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例。
2. `InternetAddress(String address, boolean strict)`：使用给定的电子邮件地址字符串创建一个 `InternetAddress` 实例，并指定是否启用严格模式。
3. `InternetAddress(String address, String personal)`：使用给定的电子邮件地址字符串和个人名称创建一个 `InternetAddress` 实例。
4. **`InternetAddress(String address, String personal, String charset)`：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 `InternetAddress` 实例。**
5. `InternetAddress(String address, String personal, String charset, boolean strict)`：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 `InternetAddress` 实例。

------

**`InternetAddress`可以很方便的设置别名**：

```java
// 设置发送方地址:
message.setFrom(new InternetAddress(username,"Sora","UTF-8"));
```

**在字符串里，也可以设置别名**：

在字符串里给收件人设置别名的方法是使用 `<` 和 `>` 包裹完整的邮件地址，并在地址后面添加别名，格式如下：

```java
"别名1 <recipient1@example.com>, 别名2 <recipient2@example.com>"
```

例如，如果要将 "Alice" 和 "Bob" 添加到密送列表，可以这样做：

```java
message.addRecipients(Message.RecipientType.BCC, "Alice <alice@example.com>, Bob <bob@example.com>");
```

`InternetAddress`里也可以这样：

```java
InternetAddress address = new InternetAddress("别名 <recipient@example.com>");
```

但是不能同时设置字符集，那中文可能出问题，所以还是得这样：

```java
InternetAddress address = new InternetAddress("recipient@example.com>","别名","UTF-8");
```

或者这样：

```java
InternetAddress address = new InternetAddress("recipient@example.com");
address.setPersonal("别名", "UTF-8");
```



### 常见问题

如果用户名或口令错误，会导致`535`登录失败：

```
DEBUG SMTP: AUTH LOGIN failed
Exception in thread "main" javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
```

如果**登录用户和发件人不一致**，会导致`554`拒绝发送错误：

```
DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
```

有些时候，如果邮件主题和正文过于简单，会导致`554`被识别为垃圾邮件的错误：

```
DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
```

使用`JavaMail` API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；

某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。





