---
layout: post
title: Spring
categories: Java
description: Java笔记
keywords: Java
---

# 引言

Spring框架笔记。



# Spring

Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。

Spring Framework主要包括几个模块：

- 支持IoC和AOP的容器；
- 支持JDBC和ORM的数据访问模块；
- 支持声明式事务的模块；
- 支持基于Servlet的MVC开发；
- 支持基于Reactive的Web开发；
- 以及集成JMS、JavaMail、JMX、缓存等其他模块。

## IoC

容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。

通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。

Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

IoC全称Inversion of Control，直译为控制反转。

假定一个在线书店，通过`BookService`获取书籍：

```java
public class BookService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public Book getBook(long bookId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return book;
        }
    }
}
```

为了从数据库查询书籍，`BookService`持有一个`DataSource`。为了实例化一个`HikariDataSource`，又不得不实例化一个`HikariConfig`。

现在，继续编写`UserService`获取用户：

```java
public class UserService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public User getUser(long userId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return user;
        }
    }
}
```

因为`UserService`也需要访问数据库，因此，不得不也实例化一个`HikariDataSource`。

上述每个组件都采用了一种简单的通过`new`创建实例并持有的方式。会有以下缺点：

1. 实例化一个组件其实很难，例如，`BookService`和`UserService`要创建`HikariDataSource`，实际上需要读取配置，才能先实例化`HikariConfig`，再实例化`HikariDataSource`。
2. 没有必要让`BookService`和`UserService`分别创建`DataSource`实例，完全可以共享同一个`DataSource`，但谁负责创建`DataSource`，谁负责获取其他组件已经创建的`DataSource`，不好处理。
3. 很多组件需要销毁以便释放资源，例如`DataSource`，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？
4. 测试某个组件，例如`BookService`，是复杂的，因为必须要在真实的数据库环境下执行。

如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

因此，核心问题是：谁负责创建组件？谁负责根据依赖关系组装组件？销毁时，如何按依赖顺序正确销毁？解决这一问题的核心方案就是IoC。

传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：

`CartServlet`创建了`BookService`，在创建`BookService`的过程中，又创建了`DataSource`组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。

在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，`BookService`自己并不会创建`DataSource`，而是等待外部通过`setDataSource()`方法来注入一个`DataSource`：

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

不直接`new`一个`DataSource`，而是注入一个`DataSource`，这个小小的改动虽然简单，却带来了一系列好处：

1. `BookService`不再关心如何创建`DataSource`，因此，不必编写读取数据库配置之类的代码；
2. `DataSource`实例被注入到`BookService`，同样也可以注入到`UserService`，因此，共享一个组件非常简单；
3. 测试`BookService`更容易，因为注入的是`DataSource`，可以使用内存数据库，而不是真实的MySQL配置。

IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。

因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为`dataSource`的组件通过属性`dataSource`（即调用`setDataSource()`方法）注入到另外两个组件中。

依赖注入可以通过`set()`方法实现，也可以通过构造方法实现。

把`BookService`改造为通过构造方法注入，那么实现代码如下：

```java
public class BookService {
    private DataSource dataSource;

    public BookService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。

在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：

1. 应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；
2. 测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。

### IoC装配

首先引入依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

测试代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

编写一个特定的`application.xml`配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="b" class="com.aotmd.test.B" />
    <bean id="a" class="com.aotmd.test.A" >
        <constructor-arg index="0" ref="b"/>
    </bean>
</beans>
```

------

### Bean的配置

在 Spring中，XML配置文件的根元素是`< beans>`，其下包含了`<bean>`子元素，每个`<bean>`子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中。

`<bean>`元素中包含了多个*属性*。其常用属性如下：

| **属性** | **解释**                           |
| -------- | ---------------------------------- |
| id       | 实例化对象名称                     |
| name     | 可以为bean指定多个名称，用逗号分隔 |
| class    | 类文件的全局名称                   |
| scope    | 实例的生存空间或有效范围           |

`<bean>`元素中同样包含了多个*子*元素，其子元素如下

`constructor-arg`、`property`、`ref`、`value`、`list`、`set`、`map`、`entry`

### Bean的实例化

**构造方法实例化，使用类的无参数构造创建**

```java
<bean id="testdemo" class="dao.TestDemo"></bean>
```

**使用静态工厂实例化**

```java
<bean id="b2" class="SpringBean.Factory" factory-method="newBean"/>
```

参数：id 实例化对象名称，class 静态工厂绝对名称，factory-method 工厂的静态方法名称

```java
public class Factory {
    public static Bean newBean() {return new Bean();}
    public static void main(String[] args) {
        ApplicationContext ap=new ClassPathXmlApplicationContext("Factory.xml");
        ap.getBean("b2");
    }
}
class Bean{}
```

**实例工厂实例化**

```java
<bean id="factory" class="SpringBean.Factory" />
<bean id="b3" factory-bean="factory" factory-method="newBean2"/>
```

参数：id 实例化对象名称，factory-bean 实例化的工厂名称，factory-method 工厂的方法名称

```java
public class Factory {
    public Bean newBean2() {return new Bean();}
    public static void main(String[] args) {
        ApplicationContext ap=new ClassPathXmlApplicationContext("Factory.xml");
        ap.getBean("b3");
    }
}
class Bean{}
```

### 注入方式

对于构造方法注入，通过设置`constructor-arg`标签完成：

`constructor-arg`参数:`type` 形参类型，`name` 形参变量名，`value` 属性值，`ref` 引用实例对象，`index` 索引值。

```xml
<bean id="b" class="com.aotmd.test.B" />
<bean id="a" class="com.aotmd.test.A" >
    <constructor-arg index="0" ref="b"/>
</bean>
```

- 每个`<bean ...>`都有一个`id`标识，相当于Bean的唯一ID；
- 在`a`Bean中，通过`<constructor-arg index="0" ref="b"/>`以**构造方法注入**了另一个`b`Bean；
- Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。

把上述XML配置文件用Java代码写出来，就像这样：

```java
B b=new B();
A a=new A(b);
```

只不过Spring容器是通过读取XML文件后使用反射完成的。

其实这里不写`constructor-arg`，也可以，在 Spring XML 配置文件中，如果类 `A` 只有**一个构造函数**，并且这个构造函数需要一个 `B` 类型的参数，Spring 会自动匹配并注入所需的依赖。因此，如果只有一个构造函数并且只有一个参数类型可以匹配，则**可以省略** `<constructor-arg>` 标签。



还可以使用c命名空间简化注入,对应`constructor-arg`。

`beans`标签添加属性: `xmlns:c="http://www.springframework.org/schema/c"`。

使用c命名空间，直接在bean添加参数：

```java
<bean id="a1" class="com.aotmd.test.A" c:_0-ref="b"/>
<bean id="a2" class="com.aotmd.test.A" c:b-ref="b"/>
```

`c:_索引值` 对应 `index="索引值"`， 加`-ref`表示引用实例对象

`c:形参变量名` 对应 `name="形参变量名"`,加`-ref`表示引用实例对象，不加则是设置普通数据类型，上面的式子如果不加，则`"b"`视为字符串。

需要注意的是`c:b-ref`这种方式只对以debug方式编译的class有效，因为对于非debug方式编译的class文件Spring将无法获取到对应构造方法的`参数名`，因为被优化掉了。之前在JavaWeb有说，可以设置编译器参数：`-parameters`，保留形参变量名。

------

对于set方法注入，通过设置`property`标签完成：

如果要改成**通过`set`方法注入**，则xml修改为：

```xml
<bean id="a" class="com.aotmd.test.A" >
    <property name="b" ref="b"/>
</bean>
```

`property`参数： `name` 变量名，`value` 属性值，`ref` 引用实例对象。



同样的，可以使用p命名空间简化注入,对应`property`。

`beans`标签添加属性: `xmlns:p="http://www.springframework.org/schema/p"`。

使用p命名空间，直接在bean添加参数：

```xml
<bean id="a" class="com.aotmd.test.A" p:b-ref="b"/>
```

`p:变量名` 对应 `name="变量名"`，加`-ref`表示引用实例对象。

注意：`property`对应的是set方法，而**不是**对应的属性。如`name="world"`实际对应`setWorld()`方法，这个时候**不管**是否真的存在名为`world`的属性.

------

### 自动装配

Spring的`<bean>`元素中包含个 `autowire`属性，可通过设置 `autowire`的属性来自动装配Bean。自动装配，就是将一个Bean注入到其他Bean的Property中。autowire属性值及说明如下:

| 属性值      | 说明                                                        |
| ----------- | ----------------------------------------------------------- |
| default     | 默认值。                                                    |
| byName      | 根据 Property的Name自动装配。                               |
| byType      | 根据 Property的数据类型（TYPE）自动装配                     |
| constructor | 根据构造函数参数的数据类型。                                |
| autodetect  | 如果发现默认的构造函数，用constructor模式，否则用byType模式 |
| no          | 不适用自动装配，Bean依赖必须通过ref元素定义。               |

默认情况下，`autowire`属性的默认值为`default`。默认情况下Spring会根据`byName`的方式进行自动装配。如果Spring在容器中找到与属性名相同的Bean，则会将该Bean注入到相应的属性中。如果找不到与属性名相同的Bean，Spring会抛出`NoSuchBeanDefinitionException`异常。



### 注入的类型

如果注入的不是Bean，而是`boolean`、`int`、`String`这样的数据类型，则通过设置`value`注入（构造方法注入同理），例如，创建一个`HikariDataSource`：

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="maximumPoolSize" value="10" />
    <property name="autoCommit" value="true" />
</bean>
```

如果是Map类型，则通过嵌套`map`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="map">
        <map>
            <entry key="1" value="唱"/>
            <entry key="2" value="跳"/>
            <entry key="3" value="RAP" value-type="java.lang.String"/>
        </map>
    </property>
</bean>
```

如果是List类型，则通过嵌套`list`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg ref="b" index="0"/>
    <property name="list">
        <list><value>唱</value><value>跳</value><value>RAR</value></list>
    </property>
</bean>
```

如果是Set类型，则通过嵌套`set`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="set">
        <set><value >唱</value><value>跳</value><value>RAR</value></set>
    </property>
</bean>
```

前面有说name属性对应的是set方法，这里是`"set"`,所以对应`setList`方法，也可以改成其他的名字。

如果是数组，则通过嵌套`array`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="list">
        <array><value>唱</value><value>跳</value><value>RAR</value></array>
    </property>
</bean>
```

实例：

```java
public class Test{
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
class A {
    private B call;

    public A(Map<String,Object> map) {
        this.call = (B) map.get("key1");
        System.out.println(map);
    }

    public void setArray(String[] map) {
        System.out.println(Arrays.toString(map));
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A">
        <constructor-arg index="0">
            <map>
                <entry key="1" value="唱"/>
                <entry key="2" value="跳"/>
                <entry key="3" value="RAP" value-type="java.lang.String"/>
                <entry key="4" value="1" value-type="java.lang.Integer"/>
                <entry key="key1" value-ref="b"/>
            </map>
        </constructor-arg>
        <property name="array">
            <array><value>唱</value><value>跳</value><value>RAR</value></array>
        </property>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

控制台：

```text
{1=唱, 2=跳, 3=RAP, 4=1, key1=com.aotmd.test.B@53de625d}
[唱, 跳, RAR]
hello
```



### ApplicationContext

Spring容器就是`ApplicationContext`，它是一个接口，有很多实现类，这里选择`ClassPathXmlApplicationContext`，表示它会自动从classpath中查找指定的XML配置文件。

获得了`ApplicationContext`的实例，就获得了IoC容器的引用。从`ApplicationContext`中可以根据Bean的ID获取Bean，也可以根据Bean的类型获取Bean的引用：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
A a= appcon.getBean(A.class);
a.hello();
```

Spring还提供另一种IoC容器叫`BeanFactory`，使用方式和`ApplicationContext`类似：

```java
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("application.xml"));
A a = factory.getBean(A.class);
```

`BeanFactory`和`ApplicationContext`的区别在于，`BeanFactory`的实现是**按需创建**，即第一次获取Bean时才创建这个Bean，而`ApplicationContext`会一次性创建所有的Bean。实际上，`ApplicationContext`接口是从`BeanFactory`接口继承而来的，并且，`ApplicationContext`提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，总是使用`ApplicationContext`，很少会考虑使用`BeanFactory`。

------

创建 `ApplicationContext`接口实例通常有三种方法：

**通过`ClassPathXmlApplicationContext`创建**
`ClassPathXmlApplicationContext`将从类路径classPath目录寻找指定的XML配置文件：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
```

**通过`FileSystemXmlApplicationContext`创建**

`FileSystemXmlApplicationContext`将从指定文件的**绝对路径**中寻找XML配置文件，找到并装载完成`ApplicationContext`的实例化工作。采用绝对路径的加载方式将导致程序的灵活性变差， 一般**不推荐使用**。

```java
ApplicationContext appcon=new FileSystemXmlApplicationContext("C:\\XXX\\application.xml");
```

**通过Web服务器实例化`ApplicationContext`容器**

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
```

如果有多个Spring配置文件，则在`param-value`里，以逗号分隔，如果没有定义则默认加载`/WEB-INF/applicationContext.xml`文件，`contextConfigLocation`是参数值，固定不变。

Web服务器实例化`ApplicationContext`容器时，一般使用基于`org.springframework.web.context.ContextLoaderListener`的实现方法只需要在`web.xml`中添加代码:

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
```

需要web依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

使用，首先**获取`ServletContext`**，这里列出几种方法：

```java
ServletContext sc = request.getServletContext();
sc=((HttpServletRequest)request).getSession().getServletContext();
sc=this.getServletContext();
```

普通类获取方法（普通类若不经过服务器调用(如servlet调用)则会报`NullPointerException`）

```java
ServletContext sc = ContextLoader.getCurrentWebApplicationContext().getServletContext();
```

然后**通过`ServletContext`获取`ApplicationContext`：**

```java
ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc);// 这种方法 获取失败时返回null
@SuppressWarnings("unused")
WebApplicationContext ctx=WebApplicationContextUtils.getRequiredWebApplicationContext(sc);// 这种方法 获取失败时抛出异常
ac = WebApplicationContextUtils.getRequiredWebApplicationContext(sc);
```

------

**销毁**

对于手动加载的Spring，`ApplicationContext`怎么销毁:

在非Web应用中，手工加载Spring IoC容器，不能用`ApplicationContext`，要用`AbstractApplicationContext`。用完以后要记得调用`ctx.close()`关闭容器。如果不记得关闭容器，最典型的问题就是数据库连接不能释放。

```java
((AbstractApplicationContext)appcon).close();
```

### 完整实例

```java
@WebServlet("/test")
public class Test extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        // 这种方法 获取失败时返回null
        ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        A a= ac.getBean(A.class);
        a.hello();
    }
}
class A {
    private B call;

    public void setCall(B call) {
        this.call = call;
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A" >
        <property name="call" ref="b"/>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

web.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:application.xml</param-value>
    </context-param>
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
</web-app>
```

### Bean的生命周期

在Spring框架中，Bean的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段。Spring提供了多个接口和配置方式，允许开发者在这三个过程的前后进行操作。在Spring中，实例化是为Bean对象分配内存空间，初始化则是对Bean的属性进行设置。

对于singleton作用域的Bean，Spring容器可以精确地管理其生命周期，包括创建、初始化和销毁。而对于prototype作用域的Bean，Spring只负责创建实例，之后Bean的生命周期由客户端代码管理，Spring容器不再跟踪其状态。

Spring中Bean的生命周期可以参考Servlet的生命周期模型：实例化→初始化→请求处理→销毁。在singleton作用域下，Bean的生命周期包括以下阶段：

1. 根据Bean的配置实例化Bean。
2. 对实例化的Bean进行依赖注入，即对属性进行初始化。
3. 如果Bean实现了`BeanNameAware`接口，将调用其`setBeanName(String beanName)`方法，传递的是Bean在Spring配置文件中的id。
4. 如果Bean实现了`BeanFactoryAware`接口，将调用其`setBeanFactory`方法，传递的是当前Spring工厂实例的引用。
5. 如果Bean实现了`BeanFactoryPostProcessor`接口，将调用其`postProcessBeanFactory()`方法，允许在Bean工厂实例化Bean之前对Bean定义进行修改。实现该接口可以在容器实例化Bean之前对Bean定义进行一些自定义的处理。
6. 如果Bean实现了`ApplicationContextAware`接口，将调用其`setApplicationContext(ApplicationContext)`方法，传递的是Spring上下文实例的引用。
7. 如果Bean实现了`BeanPostProcessor`接口，将调用其`postProcessBeforeInitialization(Object obj, String beanName)`方法，在Bean初始化前对Bean进行操作。
8. 如果Bean实现了`InitializingBean`接口，将调用其`afterPropertiesSet`方法，Bean在属性设置完成后会调用该方法进行初始化操作。
9. 如果Bean在配置文件中配置了`init-method`属性，将自动调用配置的初始化方法。
10. 如果Bean实现了`BeanPostProcessor`接口，将调用其`postProcessBeforeInitialization()`和`postProcessAfterInitialization(Object obj, String beanName)`方法，允许在Bean初始化前后进行一些自定义处理操作。实现该接口可以在Bean初始化前后对Bean进行一些额外的处理。

注意：完成上述工作后，Bean可以被使用。由于是singleton作用域，因此调用的是同一个Bean实例。

10. 当Bean不再需要时，进入销毁阶段。如果Bean实现了`DisposableBean`接口，将调用其`destroy`方法来销毁Bean。
11. 如果在配置文件中通过`destroy-method`属性指定了Bean的销毁方法，将调用配置的销毁方法进行Bean的销毁操作。

在Spring中，通过实现特定接口或配置`<bean>`元素的属性，开发者可以影响Bean的生命周期过程。建议谨慎使用Bean实现接口，以避免过度耦合代码与Spring框架。

## 使用注解

使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，就可以直接从容器中获取Bean使用它们。

使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。

还可以使用Annotation配置，让Spring自动扫描Bean并组装它们。

原代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

xml：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg index="0" ref="b"/>
</bean>
<bean id="b" class="com.aotmd.test.B" />
```

使用注解后：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

`@Component`注解就相当于定义了一个Bean，默认名称为小写开头的类名，可以指定`value`显示设置Bean名称。这里是使用构造方法装配，也可以使用`@Autowired`把指定类型的Bean注入到指定的字段中，它可以写在set方法上，也可以写在字段上，还可以写在构造方法形参上。如：

```java
@Component
class A {
    private B b;

    public A(@Autowired B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
```

一般把`@Autowired`写在字段上：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
}
```

对于xml配置部分，通过标注`@Configuration`，表示`Test`是一个配置类，并且标注`@ComponentScan`告诉容器，自动搜索**当前配置类所在的包以及子包**的注解并装配。因此要特别注意包的层次结构。通常来说，启动配置类要位于自定义的顶层包。当然也可以指定要扫描的包`@ComponentScan("com.aotmd.test")`，这样就不用特定配置类的位置了。

如果不想使用配置类，也可以使用xml扫描注解：

```xml
<context:component-scan base-package="com.aotmd.test"/>
```

常用的装配注解：

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Component  | 描述Spring中的Bean，但是它时一个泛化的概念，仅仅表示一个组件（Bean）并且可以作用在任何层次； |
| @Repository | 用于将数据访问层（DAO）层的类标识为Spring中的Bean            |
| @Service    | 作用在业务层（service层），用于将业务层的类标识为Spring中的Bean |
| @Controller | 作用在控制层（如Spring MVC 的 controller层），用于将控制层的类标识为Spring中的Bean |
| @Autowired  | 该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。  通过@Autowired的使用来消除setter 和getter方法。默认按照Bean的**类型进行装配**。 |
| @Resource   | 该注解与@Autowired功能一样。区别在于，该注解默认是按照**名称**来装配注入的，只有当找不到与名称匹配的Bean才会按照类型来装配注入； @Resource注解有两个属性；name和type。name属性指定Bean实例名称，即按照名称来装配注入；type属性指定Bean类型，即按照Bean的类型进行装配 |
| @Qualifier  | 该注解与@Autowired注解配合使用。当@Autowired注解需要按照**名称**来装配注入，则需要结合该注解一起使用，Bean的实例名称由@Qualifier注解的参数指定。 |

注意: @Component @Repository @Service @Controller 注解默认无参数生成的Bean是**首字母小写**的类名,但若**类名第一第二都是大写**则将**类名**做为生成的Bean,若类名首字母是小写则一样以类名作为标识符。

上面几个注解中，虽然@Repository、@Service和@Controller等注解的功能与@Component相同，但为了使标注类的用途更加清晰（层次化），在实际开发中推荐使用@Repository标注数据访问层（DA0层）、使用@Service标注业务逻辑层（Service层）以及使用@Controller标注控制器层（控制层）。

### Configuration

`@Configuration`注解用于标识一个类是Spring的配置类，它通常与`@Bean`注解一起使用，用于定义Bean的创建和配置。主要作用包括：

1. **定义Bean**：在配置类中使用`@Bean`注解定义Bean的创建方法，Spring容器会根据这些方法创建相应的Bean实例。
2. **替代XML配置**：`@Configuration`注解可以替代传统的XML配置文件，通过Java类的方式来配置应用程序的Bean。
3. **组件扫描**：`@Configuration`注解通常与`@ComponentScan`注解一起使用，用于启用组件扫描，自动发现和注册Spring的Bean。
4. **条件化配置**：可以结合条件注解如`@ConditionalOnProperty`等，根据条件来决定是否应用某个配置。
5. **AOP支持**：`@Configuration`类中的方法可以使用`@Bean`注解来声明切面等AOP相关的Bean。
6. **配置属性绑定**：可以使用`@Value`注解将配置文件中的属性值注入到`@Configuration`类中的Bean中。

如果没有该注解，也可以正常使用，但它的缺陷是被调用的@Bean方法产生的实例在容器中不是唯一的：

```java
@ComponentScan
public class Test {

    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        appcon.getBean("a1");
        
    }
    @Bean("a1")
    A getA(){
        System.out.println(getB() == getB()); //结果是false，说明每调用一次getB()都会产生新的实例。加上@Configuration之后结果就是true了。
        return new A();
    }

    @Bean
    B getB(){
        return new B();
    }
    static class A{}
    static class B{}
}
```

### Prototype

对于Spring容器来说，把一个Bean标记为`@Component`后，它就会自动创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，调用`getBean(Class)`获取到的Bean总是同一个实例。

还有一种Bean，每次调用`getBean(Class)`，容器都返回一个**新的实例**，这种Bean称为Prototype（原型），它的生命周期和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的`@Scope`注解：

```java
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//"prototype"
```

即：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a1= (A)appcon.getBean("a");//test为配置文件中的id
        A a2= (A)appcon.getBean("a");//test为配置文件中的id
        System.out.println(a1==a2);//false
    }
}
/*默认bean名称为首字母小写*/
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//"prototype"
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

具体来说有如下几个作用域：

| **作用域名称**  | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| **singleton**   | 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例。 |
| **prototype**   | Spring容器每次获取prototype定义的Bean，容器都将创建一个新的Bean实例。 |
| **request**     | 在一次HTTP请求中容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **session**     | 在一个HTTP Session中，容器将返回同一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **application** | 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **websocket**   | 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用。 |

### 注入List

有些时候，会有一系列接口相同，不同实现类的Bean。例如，注册用户时，要对`email`、`password`和`name`这3个变量进行验证。为了便于扩展，先定义验证接口：

```java
interface Validator {
    void validate(User user);
}
```

然后，分别使用3个`Validator`对用户参数进行验证：

```java
@Component
class EmailValidator implements Validator {
    public void validate(User user) {
        if (!user.email.matches("^[a-z0-9]+@[a-z0-9]+\\.[a-z]{2,10}$")) {
            throw new IllegalArgumentException("invalid email: " + user.email);
        }
    }
}

@Component
class PasswordValidator implements Validator {
    public void validate(User user) {
        if (!user.password.matches("^.{6,20}$")) {
            throw new IllegalArgumentException("invalid password");
        }
    }
}

@Component
class NameValidator implements Validator {
    public void validate(User user) {
        if (user.name == null || user.name.trim().isEmpty() || user.name.length() > 20) {
            throw new IllegalArgumentException("invalid name: " + user.name);
        }
    }
}
```

最后，通过一个`Validators`作为入口进行验证：

```java
@Component
class Validators {
    @Autowired
    List<Validator> validators;

    public void validate(User user) {
        for (var validator : this.validators) {
            validator.validate(user);
        }
    }
}
```

启动：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        Validators validators= (Validators)appcon.getBean("validators");
        User user = new User("123@qq.com", "123123", "45ddf");
        validators.validate(user);
    }
}
```

`Validators`被注入了一个`List<Validator>`，Spring会自动把所有类型为`Validator`的Bean装配为一个`List`注入进来，这样一来，每新增一个`Validator`类型，就自动被Spring装配到`Validators`中了，非常方便。

因为Spring是通过扫描classpath获取到所有的Bean，而`List`是有序的，要指定`List`中Bean的顺序，可以加上`@Order`注解：

```java
@Order(1)
@Component
class EmailValidator implements Validator {}
@Order(2)
@Component
class PasswordValidator implements Validator {}
@Order(3)
@Component
class NameValidator implements Validator {}
```

### 可选注入

默认情况下，当标记了一个`@Autowired`后，Spring如果没有找到对应类型的Bean，它会**抛出`NoSuchBeanDefinitionException`异常**。可以给`@Autowired`增加一个`required = false`的参数，表示如果找不到就忽略，不抛出异常。这种方式非常适合有定义就使用定义，没有就使用默认值的情况。实例：

```java
@Component
class A {
    @Autowired(required = false)
    private B b;
    
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

### 创建第三方Bean

如果想给`A`注入`HikariDataSource`，但是这个类位于`com.zaxxer.hikari`包中，并且`HikariDataSource`也不可能有`@Component`注解，如何告诉IoC容器创建并配置`HikariDataSource`？

当然是在`@Configuration`类中编写一个Java方法创建并返回它，并注意给方法标记一个`@Bean`注解，这个方法返回一个`HikariDataSource`实例：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.jdbc();
    }
    @Bean(name = "dataSource")
    public HikariDataSource getDataSource(){
        Properties props = new Properties();
        props.setProperty("jdbcUrl","jdbc:mysql://localhost:3306/studentdb?characterEncoding=utf-8&serverTimezone=GMT%2B8&useSSL=false");
        props.setProperty("username","root");
        props.setProperty("password","123456");
        HikariConfig config = new HikariConfig(props);
        config.addDataSourceProperty("cachePrepStmts", "true");
        return new HikariDataSource(config);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private HikariDataSource dataSource;
    public void jdbc(){
        try(Connection connection = dataSource.getConnection()) {
            ResultSet resultSet = connection.prepareStatement("select name from student").executeQuery();
            while (resultSet.next()){
                System.out.println(resultSet.getString("name"));
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

Spring对标记为`@Bean`的方法只调用一次，因此返回的Bean仍然是单例。

### 初始化和销毁

有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。通常会定义一个`init()`方法进行初始化，定义一个`shutdown()`方法进行清理，需要引入JSR-250定义的Annotation。

```xml
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
```

然后在Bean的初始化和清理方法上标记`@PostConstruct`和`@PreDestroy`：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
    @PostConstruct
    public void init() {
        System.out.println("Init");
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("Shutdown");
    }
}
```

Spring容器会对上述Bean做如下初始化流程：

- 调用构造方法创建`A`实例；
- 根据`@Autowired`进行注入；
- 调用标记有`@PostConstruct`的`init()`方法进行初始化。

而销毁时，容器会首先调用标记有`@PreDestroy`的`shutdown()`方法。

Spring只根据Annotation查找**无参数**方法，对方法名不作要求。

如果shutdown() 没有调用，则需要手动调用`applicationContext.close()`，而不是等待进程结束。

在Spring框架中，Bean的生命周期经历了多个阶段，包括实例化、属性赋值、初始化、使用和销毁等过程。以下是典型的Bean生命周期：

1. **实例化（Instantiation）**：在这个阶段，Spring容器根据Bean的定义创建Bean的实例。

2. **属性赋值（Populate Properties）**：在实例化之后，Spring容器会根据配置文件或注解对Bean的属性进行赋值，包括基本类型的注入、引用类型的注入等。

3. **初始化（Initialization）**：在属性赋值完成之后，Spring容器会调用Bean的初始化方法（如果有定义的话），可以通过`@PostConstruct`注解或实现`InitializingBean`接口来定义初始化方法。

4. **使用（In Use）**：在初始化完成之后，Bean就可以被应用程序使用了，它会被注入到其他Bean中，或者被直接使用。

5. **销毁（Destruction）**：在Bean不再需要的时候，Spring容器会调用Bean的销毁方法（如果有定义的话），可以通过`@PreDestroy`注解或实现`DisposableBean`接口来定义销毁方法。



### 使用别名

默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个`DataSource`实例。

如果在`@Configuration`类中创建了多个同类型的Bean，在Spring 5.0之前的版本中，Spring会报`NoUniqueBeanDefinitionException`异常，意思是出现了重复的Bean定义。从Spring 5.0开始，默认情况下，Spring允许存在多个同类型的Bean定义，并且不会抛出异常。相反，它会将这些Bean注册为一个集合类型的Bean。

要避免这个异常，可以指定不同的名称：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
    @Bean("b1")
    public B b(){
        return new B();
    }
    @Bean("b2")
    public B b2(){
        return new B();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Qualifier("b1")
    @Autowired
    private B b;
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

可以用`@Bean("name")`指定别名，也可以用`@Bean`+`@Qualifier("name")`指定别名。

其实Bean的`name`默认就是方法名称。

### 注入选择问题

存在多个同类型的Bean时，注入时又会报错，即不知道注入哪个，因此要通过`@Qualifier("b1")`指定注入的Bean名称。

```java
@Component
class A {
    @Qualifier("b1")
    @Autowired
    private B b;
    public void hello(){
        b.hello();
    }
}
```

这里也可以把两个注解换成 `@Resource(name = "b1")`。

还可以把待注入的**变量名称**改为Bean名称，这样也可以指定注入的Bean名称：

```java
@Component
class A {
    @Autowired
    private B b1;
    public void hello(){
        b1.hello();
    }
}
```

也可以通过使用`@Primary`指定某个Bean，在注入时，如果没有指出Bean的名字，Spring会注入标记有`@Primary`的Bean。

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
    @Primary
    @Bean("b1")
    public B b(){
        return new B();
    }
    @Bean("b2")
    public B b2(){
        return new B();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private B b;//默认注入b1
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

若使用Spring boot，还能根据配置属性的值来决定是否应用这个配置。即注解：

```java
@Configuration
@ConditionalOnProperty(prefix = "class", name = "select", havingValue = "B")
class B｛｝
```

- `@Configuration`：注解表示这是一个配置类，它会被Spring容器扫描并加载。
- `@ConditionalOnProperty`：注解用于根据配置属性的值来决定是否应用这个配置。它有几个参数：
  - `prefix`：配置属性的前缀。在这个例子中，配置属性的前缀是`class`。
  - `name`：配置属性的名称。在这个例子中，配置属性的名称是`select`。
  - `havingValue`：期望的配置属性值。在这个例子中，期望的配置属性值是`B`。

如果满足了以上条件，即配置属性`class.select`的值为`B`，那么这个配置类中的配置将会生效。否则，这个配置类中的配置将会被忽略。

### 使用FactoryBean

用工厂模式创建Bean需要实现`FactoryBean`接口：

```java
@Component
class BFactoryBean implements FactoryBean<B>{

    @Override
    public B getObject() throws Exception {
        return new B();
    }

    @Override
    public Class<?> getObjectType() {
        return B.class;
    }
}
```

当一个Bean实现了`FactoryBean`接口后，Spring会先实例化这个工厂，然后调用`getObject()`创建真正的Bean。`getObjectType()`可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。

因此，如果定义了一个`FactoryBean`，要注意Spring创建的Bean实际上是这个`FactoryBean`的`getObject()`方法返回的Bean。为了和普通Bean区分，通常都以`XxxFactoryBean`命名。

由于可以用`@Bean`方法创建第三方Bean，本质上`@Bean`方法就是工厂方法，所以，`FactoryBean`已经用得越来越少了。











### 使用Resource

在Java程序中，经常会读取配置文件、资源文件等。使用Spring容器时，也可以把“文件”注入进来，方便程序读取。

例如，AppService需要读取`logo.txt`这个文件，通常情况下，需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。

Spring提供了一个`org.springframework.core.io.Resource`（注意不是`jarkata.annotation.Resource`或`javax.annotation.Resource`），它可以像`String`、`int`一样使用`@Value`注入：

```java
@Component
class A {
    @Value("classpath:/application.xml")
    private Resource resource;
    public void printResource(){
        try (var reader = new BufferedReader(
                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) {
            System.out.println(reader.lines().collect(Collectors.joining("\n")));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

注入`Resource`最常用的方式是通过classpath，即类似`classpath:/application.xml`表示在classpath中搜索`application.xml`文件，然后，直接调用`Resource.getInputStream()`就可以获取到输入流，避免了自己搜索文件的代码。

也可以直接指定文件的路径，例如：

```java
@Value("file:D:/application.xml")
```

### 注入配置

在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以`key=value`的形式写在`.properties`文件中。

例如，`MailService`根据配置的`app.zone=Asia/Shanghai`来决定使用哪个时区。要读取配置文件，可以使用上一节的`Resource`来读取位于classpath下的一个`app.properties`文件。但是，这样仍然比较繁琐。

Spring容器还提供了一个更简单的`@PropertySource`来自动读取配置文件。只需要在`@Configuration`配置类上再添加一个注解：

```java
@Configuration
@ComponentScan
@PropertySource("classpath:app.properties")
public class Test {
    @Value("${app.zone:Z}")
    String zoneId;
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        appcon.getBean(ZoneId.class);
        appcon.getBean(A.class).print();

    }
    @Bean
    ZoneId createZoneId(){
        System.out.println(zoneId);
        return ZoneId.of(zoneId);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Value("${app.zone:Z}")
    String zoneId;
    void print(){
        System.out.println(zoneId);
    }
}
```

app.properties：

```properties
app.zone=Asia/Shanghai
```

Spring容器看到`@PropertySource("app.properties")`注解后，自动读取这个配置文件，然后，使用`@Value`正常注入。

注入的字符串语法，它的格式如下：

- `"${app.zone}"`表示读取key为`app.zone`的value，如果key不存在，启动将报错；
- `"${app.zone:Z}"`表示读取key为`app.zone`的value，但如果key不存在，就使用默认值`Z`。

这样一来，就可以根据`app.zone`的配置来创建`ZoneId`。

还可以把注入的注解写到方法参数中：

```java
@Bean
ZoneId createZoneId(@Value("${app.zone:Z}") String zoneId){
    System.out.println(zoneId);
    return ZoneId.of(zoneId);
}
```

使用`@PropertySource`读取配置文件，然后通过`@Value`以`${key:defaultValue}`的形式注入，可以极大地简化读取配置的麻烦。

另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个`SmtpConfig`：

```java
@Component
class AppConfig {
    @Value("${app.zone:Z}")
    private String zoneId;

    public String getZoneId() {
        return zoneId;
    }
}
```

然后，在需要读取的地方，使用`#{appConfig.zoneId}`注入：

```java
@Bean
ZoneId createZoneId(@Value("#{appConfig.zoneId}") String zoneId){
    System.out.println(zoneId);
    return ZoneId.of(zoneId);
}
```

`#{}`这种注入语法，和`${key}`不同的是，`#{}`表示从JavaBean读取属性。`"#{appConfig.zoneId}"`的意思是，从名称为`appConfig`的Bean读取`zoneId`属性，即调用`getZoneId()`方法。

使用一个独立的JavaBean持有所有属性，然后在其他Bean中以`#{bean.property}`注入的好处是，多个Bean都可以引用同一个Bean的某个属性。如果`appConfig`决定从数据库中读取相关配置项，那么`createZoneId`注入的`@Value("#{appConfig.zoneId}")`仍然可以不修改正常运行。

### 使用条件装配

开发应用程序时，会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。

Spring为应用程序准备了Profile这一概念，用来表示不同的环境。分别定义开发、测试和生产这3个环境：

- native
- test
- production

创建某个Bean时，Spring容器可以根据注解`@Profile`来决定是否创建。例如，以下配置：

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Bean
    @Profile("!test")
    ZoneId createZoneId() {
        return ZoneId.systemDefault();
    }

    @Bean
    @Profile("test")
    ZoneId createZoneIdForTest() {
        return ZoneId.of("America/New_York");
    }
}
```

如果当前的Profile设置为`test`，则Spring容器会调用`createZoneIdForTest()`创建`ZoneId`，否则，调用`createZoneId()`创建`ZoneId`。注意到`@Profile("!test")`表示非test环境。

在运行程序时，加上JVM参数`-Dspring.profiles.active=test`就可以指定以`test`环境启动。

实际上，Spring允许指定多个Profile，例如：

```cmd
-Dspring.profiles.active=test,master
```

可以表示`test`环境，并使用`master`分支代码。要满足多个Profile条件，可以这样写：

```java
@Bean
@Profile({ "test", "master" }) // 满足test或master
ZoneId createZoneId() {
    ...
}
```

**使用Conditional**

除了根据`@Profile`条件来决定是否创建某个Bean外，Spring还可以根据`@Conditional`决定是否创建某个Bean。添加如下注解：

```java
@Bean("a1")
@Conditional(MainCondition.class)
A getA(){
    return new A();
}
```

它的意思是，如果满足`MainCondition`的条件，才会创建`a1`这个Bean。

```java
class MainCondition implements Condition{
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    	return false;
    }
}
```

这里直接返回`false`，因此Bean`a1`始终不会创建。

Spring只提供了`@Conditional`注解，具体判断逻辑还需要我们自己实现。

Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在`app.smtp=true`，则创建`a1`：

```java
@Bean("a1")
@ConditionalOnProperty(name="app.smtp", havingValue="true")
A getA(){
    return new A();
}
```

`@ConditionalOnProperty`是Spring Boot框架中的一个条件注解，用于根据属性的存在与否以及属性值来决定是否应该创建一个Bean。该注解有以下参数：

1. `name`：要检查的属性名。指定要检查的应用程序属性的名称。如果未指定`prefix`，则将直接检查指定名称的属性。如果指定了`prefix`，则会在`prefix`后面加上`.`再加上`name`来构成完整的属性名。

2. `havingValue`：属性必须具有的值。指定属性必须具有的值才能满足条件。默认值为空字符串。

3. `matchIfMissing`：如果属性不存在时是否应该匹配。指定当属性不存在时是否应该认为条件匹配。默认值为`false`，即属性不存在时条件不匹配。

4. `prefix`：属性名的前缀。指定属性名的前缀，用于构成完整的属性名。

5. `value`：属性的值。与`havingValue`参数相同，用于指定属性必须具有的值。

通过使用这些参数，可以根据应用程序的配置属性来动态地确定是否创建某个Bean。根据属性名、属性值、属性是否存在以及是否匹配等条件，可以灵活地控制Bean的创建过程。

如果当前classpath中存在类`javax.mail.Transport`，则创建`a1`：

```java
@Bean("a1")
@ConditionalOnClass(name = "javax.mail.Transport")
A getA(){
    return new A();
}
```

使用条件注解，能更灵活地装配Bean。

















