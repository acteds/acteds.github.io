---
layout: post
title: Spring
categories: Java
description: Java笔记
keywords: Java
typora-root-url: ./..
---

# 引言

Spring框架笔记。



# Spring

Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。

Spring Framework主要包括几个模块：

- 支持IoC和AOP的容器；
- 支持JDBC和ORM的数据访问模块；
- 支持声明式事务的模块；
- 支持基于Servlet的MVC开发；
- 支持基于Reactive的Web开发；
- 以及集成JMS、JavaMail、JMX、缓存等其他模块。

## IoC

容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。

通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。

Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

IoC全称Inversion of Control，直译为控制反转。

假定一个在线书店，通过`BookService`获取书籍：

```java
public class BookService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public Book getBook(long bookId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return book;
        }
    }
}
```

为了从数据库查询书籍，`BookService`持有一个`DataSource`。为了实例化一个`HikariDataSource`，又不得不实例化一个`HikariConfig`。

现在，继续编写`UserService`获取用户：

```java
public class UserService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public User getUser(long userId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return user;
        }
    }
}
```

因为`UserService`也需要访问数据库，因此，不得不也实例化一个`HikariDataSource`。

上述每个组件都采用了一种简单的通过`new`创建实例并持有的方式。会有以下缺点：

1. 实例化一个组件其实很难，例如，`BookService`和`UserService`要创建`HikariDataSource`，实际上需要读取配置，才能先实例化`HikariConfig`，再实例化`HikariDataSource`。
2. 没有必要让`BookService`和`UserService`分别创建`DataSource`实例，完全可以共享同一个`DataSource`，但谁负责创建`DataSource`，谁负责获取其他组件已经创建的`DataSource`，不好处理。
3. 很多组件需要销毁以便释放资源，例如`DataSource`，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？
4. 测试某个组件，例如`BookService`，是复杂的，因为必须要在真实的数据库环境下执行。

如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

因此，核心问题是：谁负责创建组件？谁负责根据依赖关系组装组件？销毁时，如何按依赖顺序正确销毁？解决这一问题的核心方案就是IoC。

传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：

`CartServlet`创建了`BookService`，在创建`BookService`的过程中，又创建了`DataSource`组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。

在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，`BookService`自己并不会创建`DataSource`，而是等待外部通过`setDataSource()`方法来注入一个`DataSource`：

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

不直接`new`一个`DataSource`，而是注入一个`DataSource`，这个小小的改动虽然简单，却带来了一系列好处：

1. `BookService`不再关心如何创建`DataSource`，因此，不必编写读取数据库配置之类的代码；
2. `DataSource`实例被注入到`BookService`，同样也可以注入到`UserService`，因此，共享一个组件非常简单；
3. 测试`BookService`更容易，因为注入的是`DataSource`，可以使用内存数据库，而不是真实的MySQL配置。

IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。

因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为`dataSource`的组件通过属性`dataSource`（即调用`setDataSource()`方法）注入到另外两个组件中。

依赖注入可以通过`set()`方法实现，也可以通过构造方法实现。

把`BookService`改造为通过构造方法注入，那么实现代码如下：

```java
public class BookService {
    private DataSource dataSource;

    public BookService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。

在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：

1. 应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；
2. 测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。

### IoC装配

首先引入依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

测试代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

编写一个特定的`application.xml`配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="b" class="com.aotmd.test.B" />
    <bean id="a" class="com.aotmd.test.A" >
        <constructor-arg index="0" ref="b"/>
    </bean>
</beans>
```

------

### Bean的配置

在 Spring中，XML配置文件的根元素是`< beans>`，其下包含了`<bean>`子元素，每个`<bean>`子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中。

`<bean>`元素中包含了多个*属性*。其常用属性如下：

| **属性** | **解释**                           |
| -------- | ---------------------------------- |
| id       | 实例化对象名称                     |
| name     | 可以为bean指定多个名称，用逗号分隔 |
| class    | 类文件的全局名称                   |
| scope    | 实例的生存空间或有效范围           |

`<bean>`元素中同样包含了多个*子*元素，其子元素如下

`constructor-arg`、`property`、`ref`、`value`、`list`、`set`、`map`、`entry`

### Bean的实例化

**构造方法实例化，使用类的无参数构造创建**

```java
<bean id="testdemo" class="dao.TestDemo"></bean>
```

**使用静态工厂实例化**

```java
<bean id="b2" class="SpringBean.Factory" factory-method="newBean"/>
```

参数：id 实例化对象名称，class 静态工厂绝对名称，factory-method 工厂的静态方法名称

```java
public class Factory {
    public static Bean newBean() {return new Bean();}
    public static void main(String[] args) {
        ApplicationContext ap=new ClassPathXmlApplicationContext("Factory.xml");
        ap.getBean("b2");
    }
}
class Bean{}
```

**实例工厂实例化**

```java
<bean id="factory" class="SpringBean.Factory" />
<bean id="b3" factory-bean="factory" factory-method="newBean2"/>
```

参数：id 实例化对象名称，factory-bean 实例化的工厂名称，factory-method 工厂的方法名称

```java
public class Factory {
    public Bean newBean2() {return new Bean();}
    public static void main(String[] args) {
        ApplicationContext ap=new ClassPathXmlApplicationContext("Factory.xml");
        ap.getBean("b3");
    }
}
class Bean{}
```

### 注入方式

对于构造方法注入，通过设置`constructor-arg`标签完成：

`constructor-arg`参数:`type` 形参类型，`name` 形参变量名，`value` 属性值，`ref` 引用实例对象，`index` 索引值。

```xml
<bean id="b" class="com.aotmd.test.B" />
<bean id="a" class="com.aotmd.test.A" >
    <constructor-arg index="0" ref="b"/>
</bean>
```

- 每个`<bean ...>`都有一个`id`标识，相当于Bean的唯一ID；
- 在`a`Bean中，通过`<constructor-arg index="0" ref="b"/>`以**构造方法注入**了另一个`b`Bean；
- Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。

把上述XML配置文件用Java代码写出来，就像这样：

```java
B b=new B();
A a=new A(b);
```

只不过Spring容器是通过读取XML文件后使用反射完成的。

其实这里不写`constructor-arg`，也可以，在 Spring XML 配置文件中，如果类 `A` 只有**一个构造函数**，并且这个构造函数需要一个 `B` 类型的参数，Spring 会自动匹配并注入所需的依赖。因此，如果只有一个构造函数并且只有一个参数类型可以匹配，则**可以省略** `<constructor-arg>` 标签。



还可以使用c命名空间简化注入,对应`constructor-arg`。

`beans`标签添加属性: `xmlns:c="http://www.springframework.org/schema/c"`。

使用c命名空间，直接在bean添加参数：

```java
<bean id="a1" class="com.aotmd.test.A" c:_0-ref="b"/>
<bean id="a2" class="com.aotmd.test.A" c:b-ref="b"/>
```

`c:_索引值` 对应 `index="索引值"`， 加`-ref`表示引用实例对象

`c:形参变量名` 对应 `name="形参变量名"`,加`-ref`表示引用实例对象，不加则是设置普通数据类型，上面的式子如果不加，则`"b"`视为字符串。

需要注意的是`c:b-ref`这种方式只对以debug方式编译的class有效，因为对于非debug方式编译的class文件Spring将无法获取到对应构造方法的`参数名`，因为被优化掉了。之前在JavaWeb有说，可以设置编译器参数：`-parameters`，保留形参变量名。

------

对于set方法注入，通过设置`property`标签完成：

如果要改成**通过`set`方法注入**，则xml修改为：

```xml
<bean id="a" class="com.aotmd.test.A" >
    <property name="b" ref="b"/>
</bean>
```

`property`参数： `name` 变量名，`value` 属性值，`ref` 引用实例对象。



同样的，可以使用p命名空间简化注入,对应`property`。

`beans`标签添加属性: `xmlns:p="http://www.springframework.org/schema/p"`。

使用p命名空间，直接在bean添加参数：

```xml
<bean id="a" class="com.aotmd.test.A" p:b-ref="b"/>
```

`p:变量名` 对应 `name="变量名"`，加`-ref`表示引用实例对象。

注意：`property`对应的是set方法，而**不是**对应的属性。如`name="world"`实际对应`setWorld()`方法，这个时候**不管**是否真的存在名为`world`的属性.

------

### 自动装配

Spring的`<bean>`元素中包含个 `autowire`属性，可通过设置 `autowire`的属性来自动装配Bean。自动装配，就是将一个Bean注入到其他Bean的Property中。autowire属性值及说明如下:

| 属性值      | 说明                                                        |
| ----------- | ----------------------------------------------------------- |
| default     | 默认值。                                                    |
| byName      | 根据 Property的Name自动装配。                               |
| byType      | 根据 Property的数据类型（TYPE）自动装配                     |
| constructor | 根据构造函数参数的数据类型。                                |
| autodetect  | 如果发现默认的构造函数，用constructor模式，否则用byType模式 |
| no          | 不适用自动装配，Bean依赖必须通过ref元素定义。               |

默认情况下，`autowire`属性的默认值为`default`。默认情况下Spring会根据`byName`的方式进行自动装配。如果Spring在容器中找到与属性名相同的Bean，则会将该Bean注入到相应的属性中。如果找不到与属性名相同的Bean，Spring会抛出`NoSuchBeanDefinitionException`异常。



### 注入的类型

如果注入的不是Bean，而是`boolean`、`int`、`String`这样的数据类型，则通过设置`value`注入（构造方法注入同理），例如，创建一个`HikariDataSource`：

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="maximumPoolSize" value="10" />
    <property name="autoCommit" value="true" />
</bean>
```

如果是Map类型，则通过嵌套`map`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="map">
        <map>
            <entry key="1" value="唱"/>
            <entry key="2" value="跳"/>
            <entry key="3" value="RAP" value-type="java.lang.String"/>
        </map>
    </property>
</bean>
```

如果是List类型，则通过嵌套`list`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg ref="b" index="0"/>
    <property name="list">
        <list><value>唱</value><value>跳</value><value>RAR</value></list>
    </property>
</bean>
```

如果是Set类型，则通过嵌套`set`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="set">
        <set><value >唱</value><value>跳</value><value>RAR</value></set>
    </property>
</bean>
```

前面有说name属性对应的是set方法，这里是`"set"`,所以对应`setList`方法，也可以改成其他的名字。

如果是数组，则通过嵌套`array`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="list">
        <array><value>唱</value><value>跳</value><value>RAR</value></array>
    </property>
</bean>
```

实例：

```java
public class Test{
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
class A {
    private B call;

    public A(Map<String,Object> map) {
        this.call = (B) map.get("key1");
        System.out.println(map);
    }

    public void setArray(String[] map) {
        System.out.println(Arrays.toString(map));
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A">
        <constructor-arg index="0">
            <map>
                <entry key="1" value="唱"/>
                <entry key="2" value="跳"/>
                <entry key="3" value="RAP" value-type="java.lang.String"/>
                <entry key="4" value="1" value-type="java.lang.Integer"/>
                <entry key="key1" value-ref="b"/>
            </map>
        </constructor-arg>
        <property name="array">
            <array><value>唱</value><value>跳</value><value>RAR</value></array>
        </property>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

控制台：

```text
{1=唱, 2=跳, 3=RAP, 4=1, key1=com.aotmd.test.B@53de625d}
[唱, 跳, RAR]
hello
```



### ApplicationContext

Spring容器就是`ApplicationContext`，它是一个接口，有很多实现类，这里选择`ClassPathXmlApplicationContext`，表示它会自动从classpath中查找指定的XML配置文件。

获得了`ApplicationContext`的实例，就获得了IoC容器的引用。从`ApplicationContext`中可以根据Bean的ID获取Bean，也可以根据Bean的类型获取Bean的引用：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
A a= appcon.getBean(A.class);
a.hello();
```

Spring还提供另一种IoC容器叫`BeanFactory`，使用方式和`ApplicationContext`类似：

```java
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("application.xml"));
A a = factory.getBean(A.class);
```

`BeanFactory`和`ApplicationContext`的区别在于，`BeanFactory`的实现是**按需创建**，即第一次获取Bean时才创建这个Bean，而`ApplicationContext`会一次性创建所有的Bean。实际上，`ApplicationContext`接口是从`BeanFactory`接口继承而来的，并且，`ApplicationContext`提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，总是使用`ApplicationContext`，很少会考虑使用`BeanFactory`。

------

创建 `ApplicationContext`接口实例通常有三种方法：

**通过`ClassPathXmlApplicationContext`创建**
`ClassPathXmlApplicationContext`将从类路径classPath目录寻找指定的XML配置文件：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
```

**通过`FileSystemXmlApplicationContext`创建**

`FileSystemXmlApplicationContext`将从指定文件的**绝对路径**中寻找XML配置文件，找到并装载完成`ApplicationContext`的实例化工作。采用绝对路径的加载方式将导致程序的灵活性变差， 一般**不推荐使用**。

```java
ApplicationContext appcon=new FileSystemXmlApplicationContext("C:\\XXX\\application.xml");
```

**通过Web服务器实例化`ApplicationContext`容器**

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
```

如果有多个Spring配置文件，则在`param-value`里，以逗号分隔，如果没有定义则默认加载`/WEB-INF/applicationContext.xml`文件，`contextConfigLocation`是参数值，固定不变。

Web服务器实例化`ApplicationContext`容器时，一般使用基于`org.springframework.web.context.ContextLoaderListener`的实现方法只需要在`web.xml`中添加代码:

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
```

需要web依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

使用，首先**获取`ServletContext`**，这里列出几种方法：

```java
ServletContext sc = request.getServletContext();
sc=((HttpServletRequest)request).getSession().getServletContext();
sc=this.getServletContext();
```

普通类获取方法（普通类若不经过服务器调用(如servlet调用)则会报`NullPointerException`）

```java
ServletContext sc = ContextLoader.getCurrentWebApplicationContext().getServletContext();
```

然后**通过`ServletContext`获取`ApplicationContext`：**

```java
ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc);// 这种方法 获取失败时返回null
@SuppressWarnings("unused")
WebApplicationContext ctx=WebApplicationContextUtils.getRequiredWebApplicationContext(sc);// 这种方法 获取失败时抛出异常
ac = WebApplicationContextUtils.getRequiredWebApplicationContext(sc);
```

------

**销毁**

对于手动加载的Spring，`ApplicationContext`怎么销毁:

在非Web应用中，手工加载Spring IoC容器，不能用`ApplicationContext`，要用`AbstractApplicationContext`。用完以后要记得调用`ctx.close()`关闭容器。如果不记得关闭容器，最典型的问题就是数据库连接不能释放。

```java
((AbstractApplicationContext)appcon).close();
```

### 完整实例

```java
@WebServlet("/test")
public class Test extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        // 这种方法 获取失败时返回null
        ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        A a= ac.getBean(A.class);
        a.hello();
    }
}
class A {
    private B call;

    public void setCall(B call) {
        this.call = call;
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A" >
        <property name="call" ref="b"/>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

web.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:application.xml</param-value>
    </context-param>
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
</web-app>
```

### Bean的生命周期

在Spring框架中，Bean的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段。Spring提供了多个接口和配置方式，允许开发者在这三个过程的前后进行操作。在Spring中，实例化是为Bean对象分配内存空间，初始化则是对Bean的属性进行设置。

对于singleton作用域的Bean，Spring容器可以精确地管理其生命周期，包括创建、初始化和销毁。而对于prototype作用域的Bean，Spring只负责创建实例，之后Bean的生命周期由客户端代码管理，Spring容器不再跟踪其状态。

Spring中Bean的生命周期可以参考Servlet的生命周期模型：实例化→初始化→请求处理→销毁。在singleton作用域下，Bean的生命周期包括以下阶段：

1. 根据Bean的配置实例化Bean。
2. 对实例化的Bean进行依赖注入，即对属性进行初始化。
3. 如果Bean实现了`BeanNameAware`接口，将调用其`setBeanName(String beanName)`方法，传递的是Bean在Spring配置文件中的id。
4. 如果Bean实现了`BeanFactoryAware`接口，将调用其`setBeanFactory`方法，传递的是当前Spring工厂实例的引用。
5. 如果Bean实现了`BeanFactoryPostProcessor`接口，将调用其`postProcessBeanFactory()`方法，允许在Bean工厂实例化Bean之前对Bean定义进行修改。实现该接口可以在容器实例化Bean之前对Bean定义进行一些自定义的处理。
6. 如果Bean实现了`ApplicationContextAware`接口，将调用其`setApplicationContext(ApplicationContext)`方法，传递的是Spring上下文实例的引用。
7. 如果Bean实现了`BeanPostProcessor`接口，将调用其`postProcessBeforeInitialization(Object obj, String beanName)`方法，在Bean初始化前对Bean进行操作。
8. 如果Bean实现了`InitializingBean`接口，将调用其`afterPropertiesSet`方法，Bean在属性设置完成后会调用该方法进行初始化操作。
9. 如果Bean在配置文件中配置了`init-method`属性，将自动调用配置的初始化方法。
10. 如果Bean实现了`BeanPostProcessor`接口，将调用其`postProcessBeforeInitialization()`和`postProcessAfterInitialization(Object obj, String beanName)`方法，允许在Bean初始化前后进行一些自定义处理操作。实现该接口可以在Bean初始化前后对Bean进行一些额外的处理。

注意：完成上述工作后，Bean可以被使用。由于是singleton作用域，因此调用的是同一个Bean实例。

1. 当Bean不再需要时，进入销毁阶段。如果Bean实现了`DisposableBean`接口，将调用其`destroy`方法来销毁Bean。
2. 如果在配置文件中通过`destroy-method`属性指定了Bean的销毁方法，将调用配置的销毁方法进行Bean的销毁操作。

在Spring中，通过实现特定接口或配置`<bean>`元素的属性，开发者可以影响Bean的生命周期过程。建议谨慎使用Bean实现接口，以避免过度耦合代码与Spring框架。

## 使用注解

使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，就可以直接从容器中获取Bean使用它们。

使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。

还可以使用Annotation配置，让Spring自动扫描Bean并组装它们。

原代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

xml：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg index="0" ref="b"/>
</bean>
<bean id="b" class="com.aotmd.test.B" />
```

使用注解后：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

`@Component`注解就相当于定义了一个Bean，默认名称为小写开头的类名，可以指定`value`显示设置Bean名称。这里是使用构造方法装配，也可以使用`@Autowired`把指定类型的Bean注入到指定的字段中，它可以写在set方法上，也可以写在字段上，还可以写在构造方法形参上。如：

```java
@Component
class A {
    private B b;

    public A(@Autowired B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
```

一般把`@Autowired`写在字段上：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
}
```

对于xml配置部分，通过标注`@Configuration`，表示`Test`是一个配置类，并且标注`@ComponentScan`告诉容器，自动搜索**当前配置类所在的包以及子包**的注解并装配。因此要特别注意包的层次结构。通常来说，启动配置类要位于自定义的顶层包。当然也可以指定要扫描的包`@ComponentScan("com.aotmd.test")`，这样就不用特定配置类的位置了。

如果不想使用配置类，也可以使用xml扫描注解：

```xml
<context:component-scan base-package="com.aotmd.test"/>
```

常用的装配注解：

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| `@Component`  | 描述Spring中的Bean，但是它时一个泛化的概念，仅仅表示一个组件（Bean）并且可以作用在任何层次； |
| `@Repository` | 用于将数据访问层（DAO）层的类标识为Spring中的Bean            |
| `@Service`    | 作用在业务层（service层），用于将业务层的类标识为Spring中的Bean |
| `@Controller` | 作用在控制层（如Spring MVC 的 controller层），用于将控制层的类标识为Spring中的Bean |
| `@Autowired`  | 该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。  通过`@Autowired`的使用来消除setter 和getter方法。默认按照Bean的**类型进行装配**。 |
| `@Resource`   | 该注解与`@Autowired`功能一样。区别在于，该注解默认是按照**名称**来装配注入的，只有当找不到与名称匹配的Bean才会按照类型来装配注入； `@Resource`注解有两个属性；`name`和`type`。`name`属性指定Bean实例名称，即按照名称来装配注入；`type`属性指定Bean类型，即按照Bean的类型进行装配 |
| `@Qualifier`  | 该注解与`@Autowired`注解配合使用。当`@Autowired`注解需要按照**名称**来装配注入，则需要结合该注解一起使用，Bean的实例名称由`@Qualifier`注解的参数指定。 |

注意: `@Component`、`@Repository`、`@Service`、`@Controller`注解默认无参数生成的Bean是**首字母小写**的类名,但若**类名第一第二都是大写**则将**类名**做为生成的Bean,若类名首字母是小写则一样以类名作为标识符。

上面几个注解中，虽然`@Repository`、`@Service`和`@Controller`等注解的功能与`@Component`相同，但为了使标注类的用途更加清晰（层次化），在实际开发中推荐使用`@Repository`标注数据访问层（DAO层）、使用`@Service`标注业务逻辑层（Service层）以及使用`@Controller`标注控制器层（控制层）。

### Configuration

`@Configuration`注解用于标识一个类是Spring的配置类，它通常与`@Bean`注解一起使用，用于定义Bean的创建和配置。主要作用包括：

1. **定义Bean**：在配置类中使用`@Bean`注解定义Bean的创建方法，Spring容器会根据这些方法创建相应的Bean实例。
2. **替代XML配置**：`@Configuration`注解可以替代传统的XML配置文件，通过Java类的方式来配置应用程序的Bean。
3. **组件扫描**：`@Configuration`注解通常与`@ComponentScan`注解一起使用，用于启用组件扫描，自动发现和注册Spring的Bean。
4. **条件化配置**：可以结合条件注解如`@ConditionalOnProperty`等，根据条件来决定是否应用某个配置。
5. **AOP支持**：`@Configuration`类中的方法可以使用`@Bean`注解来声明切面等AOP相关的Bean。
6. **配置属性绑定**：可以使用`@Value`注解将配置文件中的属性值注入到`@Configuration`类中的Bean中。

如果没有该注解，也可以正常使用，但它的缺陷是被调用的@Bean方法产生的实例在容器中不是唯一的：

```java
@ComponentScan
public class Test {

    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        appcon.getBean("a1");
        
    }
    @Bean("a1")
    A getA(){
        System.out.println(getB() == getB()); //结果是false，说明每调用一次getB()都会产生新的实例。加上@Configuration之后结果就是true了。
        return new A();
    }

    @Bean
    B getB(){
        return new B();
    }
    static class A{}
    static class B{}
}
```

### Prototype

对于Spring容器来说，把一个Bean标记为`@Component`后，它就会自动创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，调用`getBean(Class)`获取到的Bean总是同一个实例。

还有一种Bean，每次调用`getBean(Class)`，容器都返回一个**新的实例**，这种Bean称为Prototype（原型），它的生命周期和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的`@Scope`注解：

```java
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//"prototype"
```

即：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a1= (A)appcon.getBean("a");//test为配置文件中的id
        A a2= (A)appcon.getBean("a");//test为配置文件中的id
        System.out.println(a1==a2);//false
    }
}
/*默认bean名称为首字母小写*/
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//"prototype"
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

具体来说有如下几个作用域：

| **作用域名称**  | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| **singleton**   | 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例。 |
| **prototype**   | Spring容器每次获取prototype定义的Bean，容器都将创建一个新的Bean实例。 |
| **request**     | 在一次HTTP请求中容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **session**     | 在一个HTTP Session中，容器将返回同一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **application** | 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **websocket**   | 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用。 |

### 注入List

有些时候，会有一系列接口相同，不同实现类的Bean。例如，注册用户时，要对`email`、`password`和`name`这3个变量进行验证。为了便于扩展，先定义验证接口：

```java
interface Validator {
    void validate(User user);
}
```

然后，分别使用3个`Validator`对用户参数进行验证：

```java
@Component
class EmailValidator implements Validator {
    public void validate(User user) {
        if (!user.email.matches("^[a-z0-9]+@[a-z0-9]+\\.[a-z]{2,10}$")) {
            throw new IllegalArgumentException("invalid email: " + user.email);
        }
    }
}

@Component
class PasswordValidator implements Validator {
    public void validate(User user) {
        if (!user.password.matches("^.{6,20}$")) {
            throw new IllegalArgumentException("invalid password");
        }
    }
}

@Component
class NameValidator implements Validator {
    public void validate(User user) {
        if (user.name == null || user.name.trim().isEmpty() || user.name.length() > 20) {
            throw new IllegalArgumentException("invalid name: " + user.name);
        }
    }
}
```

最后，通过一个`Validators`作为入口进行验证：

```java
@Component
class Validators {
    @Autowired
    List<Validator> validators;

    public void validate(User user) {
        for (var validator : this.validators) {
            validator.validate(user);
        }
    }
}
```

启动：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        Validators validators= (Validators)appcon.getBean("validators");
        User user = new User("123@qq.com", "123123", "45ddf");
        validators.validate(user);
    }
}
```

`Validators`被注入了一个`List<Validator>`，Spring会自动把所有类型为`Validator`的Bean装配为一个`List`注入进来，这样一来，每新增一个`Validator`类型，就自动被Spring装配到`Validators`中了，非常方便。

因为Spring是通过扫描classpath获取到所有的Bean，而`List`是有序的，要指定`List`中Bean的顺序，可以加上`@Order`注解：

```java
@Order(1)
@Component
class EmailValidator implements Validator {}
@Order(2)
@Component
class PasswordValidator implements Validator {}
@Order(3)
@Component
class NameValidator implements Validator {}
```

### 可选注入

默认情况下，当标记了一个`@Autowired`后，Spring如果没有找到对应类型的Bean，它会**抛出`NoSuchBeanDefinitionException`异常**。可以给`@Autowired`增加一个`required = false`的参数，表示如果找不到就忽略，不抛出异常。这种方式非常适合有定义就使用定义，没有就使用默认值的情况。实例：

```java
@Component
class A {
    @Autowired(required = false)
    private B b;
    
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

### 创建第三方Bean

如果想给`A`注入`HikariDataSource`，但是这个类位于`com.zaxxer.hikari`包中，并且`HikariDataSource`也不可能有`@Component`注解，如何告诉IoC容器创建并配置`HikariDataSource`？

当然是在`@Configuration`类中编写一个Java方法创建并返回它，并注意给方法标记一个`@Bean`注解，这个方法返回一个`HikariDataSource`实例：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.jdbc();
    }
    @Bean(name = "dataSource")
    public HikariDataSource getDataSource(){
        Properties props = new Properties();
        props.setProperty("jdbcUrl","jdbc:mysql://localhost:3306/studentdb?characterEncoding=utf-8&serverTimezone=GMT%2B8&useSSL=false");
        props.setProperty("username","root");
        props.setProperty("password","123456");
        HikariConfig config = new HikariConfig(props);
        config.addDataSourceProperty("cachePrepStmts", "true");
        return new HikariDataSource(config);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private HikariDataSource dataSource;
    public void jdbc(){
        try(Connection connection = dataSource.getConnection()) {
            ResultSet resultSet = connection.prepareStatement("select name from student").executeQuery();
            while (resultSet.next()){
                System.out.println(resultSet.getString("name"));
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

Spring对标记为`@Bean`的方法只调用一次，因此返回的Bean仍然是单例。

### 初始化和销毁

有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。通常会定义一个`init()`方法进行初始化，定义一个`shutdown()`方法进行清理，需要引入JSR-250定义的Annotation。

```xml
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
```

然后在Bean的初始化和清理方法上标记`@PostConstruct`和`@PreDestroy`：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
    @PostConstruct
    public void init() {
        System.out.println("Init");
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("Shutdown");
    }
}
```

Spring容器会对上述Bean做如下初始化流程：

- 调用构造方法创建`A`实例；
- 根据`@Autowired`进行注入；
- 调用标记有`@PostConstruct`的`init()`方法进行初始化。

而销毁时，容器会首先调用标记有`@PreDestroy`的`shutdown()`方法。

Spring只根据Annotation查找**无参数**方法，对方法名不作要求。

如果`shutdown()` 没有调用，则需要手动调用`applicationContext.close()`，而不是等待进程结束。

在Spring框架中，Bean的生命周期经历了多个阶段，包括实例化、属性赋值、初始化、使用和销毁等过程。以下是典型的Bean生命周期：

1. **实例化（Instantiation）**：在这个阶段，Spring容器根据Bean的定义创建Bean的实例。

2. **属性赋值（Populate Properties）**：在实例化之后，Spring容器会根据配置文件或注解对Bean的属性进行赋值，包括基本类型的注入、引用类型的注入等。

3. **初始化（Initialization）**：在属性赋值完成之后，Spring容器会调用Bean的初始化方法（如果有定义的话），可以通过`@PostConstruct`注解或实现`InitializingBean`接口来定义初始化方法。

4. **使用（In Use）**：在初始化完成之后，Bean就可以被应用程序使用了，它会被注入到其他Bean中，或者被直接使用。

5. **销毁（Destruction）**：在Bean不再需要的时候，Spring容器会调用Bean的销毁方法（如果有定义的话），可以通过`@PreDestroy`注解或实现`DisposableBean`接口来定义销毁方法。



### 使用别名

默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个`DataSource`实例。

如果在`@Configuration`类中创建了多个同类型的Bean，在Spring 5.0之前的版本中，Spring会报`NoUniqueBeanDefinitionException`异常，意思是出现了重复的Bean定义。从Spring 5.0开始，默认情况下，Spring允许存在多个同类型的Bean定义，并且不会抛出异常。相反，它会将这些Bean注册为一个集合类型的Bean。

要避免这个异常，可以指定不同的名称：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
    @Bean("b1")
    public B b(){
        return new B();
    }
    @Bean("b2")
    public B b2(){
        return new B();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Qualifier("b1")
    @Autowired
    private B b;
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

可以用`@Bean("name")`指定别名，也可以用`@Bean`+`@Qualifier("name")`指定别名。

其实Bean的`name`默认就是方法名称。

### 注入选择问题

存在多个同类型的Bean时，注入时又会报错，即不知道注入哪个，因此要通过`@Qualifier("b1")`指定注入的Bean名称。

```java
@Component
class A {
    @Qualifier("b1")
    @Autowired
    private B b;
    public void hello(){
        b.hello();
    }
}
```

这里也可以把两个注解换成 `@Resource(name = "b1")`。

还可以把待注入的**变量名称**改为Bean名称，这样也可以指定注入的Bean名称：

```java
@Component
class A {
    @Autowired
    private B b1;
    public void hello(){
        b1.hello();
    }
}
```

也可以通过使用`@Primary`指定某个Bean，在注入时，如果没有指出Bean的名字，Spring会注入标记有`@Primary`的Bean。

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
    @Primary
    @Bean("b1")
    public B b(){
        return new B();
    }
    @Bean("b2")
    public B b2(){
        return new B();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private B b;//默认注入b1
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

若使用Spring boot，还能根据配置属性的值来决定是否应用这个配置。即注解：

```java
@Configuration
@ConditionalOnProperty(prefix = "class", name = "select", havingValue = "B")
class B｛｝
```

- `@Configuration`：注解表示这是一个配置类，它会被Spring容器扫描并加载。
- `@ConditionalOnProperty`：注解用于根据配置属性的值来决定是否应用这个配置。它有几个参数：
  - `prefix`：配置属性的前缀。在这个例子中，配置属性的前缀是`class`。
  - `name`：配置属性的名称。在这个例子中，配置属性的名称是`select`。
  - `havingValue`：期望的配置属性值。在这个例子中，期望的配置属性值是`B`。

如果满足了以上条件，即配置属性`class.select`的值为`B`，那么这个配置类中的配置将会生效。否则，这个配置类中的配置将会被忽略。

### 使用FactoryBean

用工厂模式创建Bean需要实现`FactoryBean`接口：

```java
@Component
class BFactoryBean implements FactoryBean<B>{

    @Override
    public B getObject() throws Exception {
        return new B();
    }

    @Override
    public Class<?> getObjectType() {
        return B.class;
    }
}
```

当一个Bean实现了`FactoryBean`接口后，Spring会先实例化这个工厂，然后调用`getObject()`创建真正的Bean。`getObjectType()`可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。

因此，如果定义了一个`FactoryBean`，要注意Spring创建的Bean实际上是这个`FactoryBean`的`getObject()`方法返回的Bean。为了和普通Bean区分，通常都以`XxxFactoryBean`命名。

由于可以用`@Bean`方法创建第三方Bean，本质上`@Bean`方法就是工厂方法，所以，`FactoryBean`已经用得越来越少了。

### 使用Resource

在Java程序中，经常会读取配置文件、资源文件等。使用Spring容器时，也可以把“文件”注入进来，方便程序读取。

例如，AppService需要读取`logo.txt`这个文件，通常情况下，需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。

Spring提供了一个`org.springframework.core.io.Resource`（注意不是`jarkata.annotation.Resource`或`javax.annotation.Resource`），它可以像`String`、`int`一样使用`@Value`注入：

```java
@Component
class A {
    @Value("classpath:/application.xml")
    private Resource resource;
    public void printResource(){
        try (var reader = new BufferedReader(
                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) {
            System.out.println(reader.lines().collect(Collectors.joining("\n")));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

注入`Resource`最常用的方式是通过classpath，即类似`classpath:/application.xml`表示在classpath中搜索`application.xml`文件，然后，直接调用`Resource.getInputStream()`就可以获取到输入流，避免了自己搜索文件的代码。

也可以直接指定文件的路径，例如：

```java
@Value("file:D:/application.xml")
```

### 注入配置

在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以`key=value`的形式写在`.properties`文件中。

例如，`MailService`根据配置的`app.zone=Asia/Shanghai`来决定使用哪个时区。要读取配置文件，可以使用上一节的`Resource`来读取位于classpath下的一个`app.properties`文件。但是，这样仍然比较繁琐。

Spring容器还提供了一个更简单的`@PropertySource`来自动读取配置文件。只需要在`@Configuration`配置类上再添加一个注解：

```java
@Configuration
@ComponentScan
@PropertySource("classpath:app.properties")
public class Test {
    @Value("${app.zone:Z}")
    String zoneId;
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        appcon.getBean(ZoneId.class);
        appcon.getBean(A.class).print();

    }
    @Bean
    ZoneId createZoneId(){
        System.out.println(zoneId);
        return ZoneId.of(zoneId);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Value("${app.zone:Z}")
    String zoneId;
    void print(){
        System.out.println(zoneId);
    }
}
```

`app.properties`：

```properties
app.zone=Asia/Shanghai
```

Spring容器看到`@PropertySource("app.properties")`注解后，自动读取这个配置文件，然后，使用`@Value`正常注入。

注入的字符串语法，它的格式如下：

- `"${app.zone}"`表示读取key为`app.zone`的value，如果key不存在，启动将报错；
- `"${app.zone:Z}"`表示读取key为`app.zone`的value，但如果key不存在，就使用默认值`Z`。

这样一来，就可以根据`app.zone`的配置来创建`ZoneId`。

还可以把注入的注解写到方法参数中：

```java
@Bean
ZoneId createZoneId(@Value("${app.zone:Z}") String zoneId){
    System.out.println(zoneId);
    return ZoneId.of(zoneId);
}
```

使用`@PropertySource`读取配置文件，然后通过`@Value`以`${key:defaultValue}`的形式注入，可以极大地简化读取配置的麻烦。

另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个`SmtpConfig`：

```java
@Component
class AppConfig {
    @Value("${app.zone:Z}")
    private String zoneId;

    public String getZoneId() {
        return zoneId;
    }
}
```

然后，在需要读取的地方，使用`#{appConfig.zoneId}`注入：

```java
@Bean
ZoneId createZoneId(@Value("#{appConfig.zoneId}") String zoneId){
    System.out.println(zoneId);
    return ZoneId.of(zoneId);
}
```

`#{}`这种注入语法，和`${key}`不同的是，`#{}`表示从JavaBean读取属性。`"#{appConfig.zoneId}"`的意思是，从名称为`appConfig`的Bean读取`zoneId`属性，即调用`getZoneId()`方法。

使用一个独立的JavaBean持有所有属性，然后在其他Bean中以`#{bean.property}`注入的好处是，多个Bean都可以引用同一个Bean的某个属性。如果`appConfig`决定从数据库中读取相关配置项，那么`createZoneId`注入的`@Value("#{appConfig.zoneId}")`仍然可以不修改正常运行。

### 使用条件装配

开发应用程序时，会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。

Spring为应用程序准备了Profile这一概念，用来表示不同的环境。分别定义开发、测试和生产这3个环境：

- native
- test
- production

创建某个Bean时，Spring容器可以根据注解`@Profile`来决定是否创建。例如，以下配置：

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Bean
    @Profile("!test")
    ZoneId createZoneId() {
        return ZoneId.systemDefault();
    }

    @Bean
    @Profile("test")
    ZoneId createZoneIdForTest() {
        return ZoneId.of("America/New_York");
    }
}
```

如果当前的Profile设置为`test`，则Spring容器会调用`createZoneIdForTest()`创建`ZoneId`，否则，调用`createZoneId()`创建`ZoneId`。注意到`@Profile("!test")`表示非test环境。

在运行程序时，加上JVM参数`-Dspring.profiles.active=test`就可以指定以`test`环境启动。

实际上，Spring允许指定多个Profile，例如：

```cmd
-Dspring.profiles.active=test,master
```

可以表示`test`环境，并使用`master`分支代码。要满足多个Profile条件，可以这样写：

```java
@Bean
@Profile({ "test", "master" }) // 满足test或master
ZoneId createZoneId() {
    ...
}
```

**使用Conditional**

除了根据`@Profile`条件来决定是否创建某个Bean外，Spring还可以根据`@Conditional`决定是否创建某个Bean。添加如下注解：

```java
@Bean("a1")
@Conditional(MainCondition.class)
A getA(){
    return new A();
}
```

它的意思是，如果满足`MainCondition`的条件，才会创建`a1`这个Bean。

```java
class MainCondition implements Condition{
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    	return false;
    }
}
```

这里直接返回`false`，因此Bean`a1`始终不会创建。

Spring只提供了`@Conditional`注解，具体判断逻辑还需要我们自己实现。

Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在`app.smtp=true`，则创建`a1`：

```java
@Bean("a1")
@ConditionalOnProperty(name="app.smtp", havingValue="true")
A getA(){
    return new A();
}
```

`@ConditionalOnProperty`是Spring Boot框架中的一个条件注解，用于根据属性的存在与否以及属性值来决定是否应该创建一个Bean。该注解有以下参数：

1. `name`：要检查的属性名。指定要检查的应用程序属性的名称。如果未指定`prefix`，则将直接检查指定名称的属性。如果指定了`prefix`，则会在`prefix`后面加上`.`再加上`name`来构成完整的属性名。

2. `havingValue`：属性必须具有的值。指定属性必须具有的值才能满足条件。默认值为空字符串。

3. `matchIfMissing`：如果属性不存在时是否应该匹配。指定当属性不存在时是否应该认为条件匹配。默认值为`false`，即属性不存在时条件不匹配。

4. `prefix`：属性名的前缀。指定属性名的前缀，用于构成完整的属性名。

5. `value`：属性的值。与`havingValue`参数相同，用于指定属性必须具有的值。

通过使用这些参数，可以根据应用程序的配置属性来动态地确定是否创建某个Bean。根据属性名、属性值、属性是否存在以及是否匹配等条件，可以灵活地控制Bean的创建过程。

如果当前classpath中存在类`javax.mail.Transport`，则创建`a1`：

```java
@Bean("a1")
@ConditionalOnClass(name = "javax.mail.Transport")
A getA(){
    return new A();
}
```

使用条件注解，能更灵活地装配Bean。



## AOP

AOP ( Aspect-Oriented Programming ）即面向切面编程，它与OOP (Object-Oriented Programming ， 面向对象编程）相辅相成，提供了与OOP 不同的抽象软件结构的视角。在OOP 中，以类作为程序的基本单元，而AOP 中的基本单元是Aspect（切面）。

在业务处理代码中通常有日志记录、性能统计、安全控制、事务处理、异常处理等操作。尽管使用OOP 可以通过封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中。

因此， 采用OOP 处理日志记录等操作不仅**增加**了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题， AOP 思想应运而生。

AOP 采取横向抽取机制，即将分散在各个方法中的重复代码**提取**出来，然后在程序**编译或运行阶段**将这些抽取出来的代码**应用到**需要执行的地方。这种横向抽取机制采用传统的OOP 是无法办到的，因为OOP 实现的是父子关系的纵向重用。但是**AOP 不是OOP 的替代品，而是OOP 的补充**，它们相辅相成。

------

**AOP的术语**

在SpringAOP框架中涉及以下常用术语。

切面（Aspect）：是指封装横切到**系统功能**（例如事务处理）的类。(通知方法的类)

连接点（Ooinpoint）：是指程序运行中的一些**时间点**，例如方法的调用或异常的抛出。(方法调用,或异常)，即定义在应用程序流程的何处插入切面的执行；

切入点（CPointcut）：是指**需要处理的连接点**。在SpringAOP中，**所有的方法执行**都是连接点，而切入点是一个描述信息，它修饰的是连接点，通过切入点**确定**哪些连接点需要被**处理**。(被处理的类的方法)

通知（Advice）：是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要**执行**的**程序代码**，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。(增强处理的代码)

引入（Introduction）：允许在现有的**实现类**中**添加**自定义的方法和属性。(增强类的方法与属性)

目标对象（TargetObject）：是指所有被通知的对象，即应用切面的原始对象或原始类。如果AOP框架使用运行时代理的方式（动态的AOP）来实现切面，那么通知对象总是一个**代理对象**。(要代理的对象Bean)

代理（Proxy）：是通知应用到目标对象**之后**被**动态创建的对象**。(被代理后动态生成的对象Bean)

织入（Weaving）：是**将切面代码插入到目标对象**上，**从而生成代理对象的过程**。根据不同的实现技术，AOP织入有3种方式：
- 编译期织入，需要有特殊的Java编译器；
- 类装载期织入，需要有特殊的类装载器；
- 动态代理织入，在运行期为目标类添加通知生成子类的方式。

SpringAOP框架默认采用**动态代理**织入，而AspectJ（基于Java语言的AOP框架）采用编译期织入和类装载期织入。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过[CGLIB](https://github.com/cglib/cglib)或者[Javassist](https://www.javassist.org/)这些第三方库实现。(代理对象生成的过程)



AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。

需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。

使用代理模式的简单示例：

```java
class Test2{
    public static void main(String[] args) {
        A a=new AProxy();
        a.func1();
    }
}
class A{
    void func1(){
        System.out.println("func1");
    }
    void func2(){
        System.out.println("func2");
    }
    void func3(){
        System.out.println("func3");
    }
}
class AProxy extends A{
    @Override
    void func1() {
        System.out.println("执行一些代码");
        super.func1();
        System.out.println("执行一些代码");
    }

    @Override
    void func2() {
        System.out.println("执行一些代码");
        super.func2();
        System.out.println("执行一些代码");
    }

    @Override
    void func3() {
        System.out.println("执行一些代码");
        super.func3();
        System.out.println("执行一些代码");
    }
}
```

通过创建一个名为`AProxy`的子类来实现对`A`类的方法进行增强，这可以被认为是一种简单的AOP实现方式。在`AProxy`中，重写了`A`类的各个方法，并在方法的前后插入了额外的逻辑。

虽然这种方式实现了对`A`类方法的增强，但它并不是典型的AOP实现方式。在典型的AOP框架中，切面逻辑是通过配置或注解来定义的，而不是通过创建子类来重写方法。AOP框架通常会使用动态代理或字节码生成等技术来实现切面逻辑的动态织入，而不是在代码中显式地创建代理类。

------

### 对类进行增强

#### 基于XML实现

首先添加依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.7</version>
</dependency>
```

或：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

要通过XML配置AOP，需要使用以下几个标签：

`<aop:config>`：这个标签用于配置AOP的相关信息，包括切面、通知等。

`<aop:aspect>`：这个标签用于定义一个切面（Aspect），其中`ref`属性指定了切面的实例引用，即切面对象的名称或引用。

在Spring AOP中，切面（Aspect）是一个普通的Java类，它通常包含通知（Advice）和切点（Pointcut）的定义。切面类并不需要实现特定的接口或继承特定的类，只需要符合Spring AOP的约定即可。通常情况下，一个切面类会包含以下内容：

- 通知（Advice）：定义了在连接点执行的具体操作，比如前置通知、后置通知、环绕通知等。
- 切点（Pointcut）：定义了在目标对象的哪些方法上执行通知。
- 引入（Introduction）：引入新的接口或方法到目标对象中。

`<aop:declare-parents>`：这个标签用于声明引入（Introduction）的相关信息，即在目标对象中引入新的接口或实现类。具有如下属性：

| **属性**             | **解释**                                  |
| -------------------- | ----------------------------------------- |
| `types-matching`     | AspectJ类型表达式，所限制的类可加"+*.."号 |
| `implement-interfac` | 将引入的接口的标准名称                    |
| `default-impl`       | 将引入接口的实现类的完全限定名称          |
| `delegate-ref`       | 将引入接口的实现类的Bean名称(实例化的)    |

**目标**是`types-matching`的类，spring让它实现`implement-interface`所指向的**接口**，而具体实现则通过`default-impl`或`delegate-ref`属性来赋予。让 `types-matching` 的类添加了**接口**并且指定了**实现**。

对类进行增强实例：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext ac=new ClassPathXmlApplicationContext("application.xml");
        A a= ac.getBean(A.class);
        a.print();
        System.out.println(a.getClass().getName());
        I i=(I)a;
        i.test();
    }
}
class A{
    public void print(){
        System.out.println("飞行");
    }
}
interface I{
    void test();
}
class B implements I{
    @Override
    public void test() {
        System.out.println(getClass().getName());
    }
}
class Aspect{}
```

XML：

```xml
<bean id="a" class="com.aotmd.test.A"/><!--目标类-->
<bean id="b" class="com.aotmd.test.B"/><!--增强类-->
<bean id="aspect" class="com.aotmd.test.Aspect"/><!--切面类-->
<aop:config>
    <aop:aspect ref="aspect"><!--指向切面类，这里Aspect是空的-->
        <aop:declare-parents types-matching="com.aotmd.test.A" implement-interface="com.aotmd.test.I" default-impl="com.aotmd.test.B"/>
        <!--两种方法，选一个即可：-->
        <aop:declare-parents types-matching="com.aotmd.test.A" implement-interface="com.aotmd.test.I" delegate-ref="b"/>
    </aop:aspect>
</aop:config>
```

控制台：

```text
飞行
com.aotmd.test.A$$EnhancerBySpringCGLIB$$712bcb1a
com.aotmd.test.B
```

在这个示例中，定义了三个bean：`a`、`b`和`aspect`。

- `a`是目标类（Target Class），它是`com.aotmd.test.A`类的实例。
- `b`是增强类（Advice Class），它是`com.aotmd.test.B`类的实例。
- `aspect`是切面类（Aspect Class），它是`com.aotmd.test.Aspect`类的实例。

然后，通过`<aop:config>`配置元素来定义AOP配置。在`<aop:aspect>`元素中，通过`ref="aspect"`将`aspect`切面类引入为切面的实例。

在`<aop:aspect>`元素中，使用了`<aop:declare-parents>`元素来声明引入（Introduction）操作。通过`types-matching`属性指定了`com.aotmd.test.A`类型的类，表示要对`A`类进行引入操作。使用`implement-interface`属性指定了要引入的接口`com.aotmd.test.I`，并使用`default-impl`属性指定了接口的默认实现类`com.aotmd.test.B`。

这样，通过AOP的引入操作，`A`类将会实现`I`接口，并使用`B`类作为接口的默认实现。这样，`A`类就拥有了`I`接口的方法，并且默认实现是`B`类的方法。

这样配置之后，**所有的`A`对象**都会**具有`I`接口的功能**，并默认使用`B`类来实现这个功能。

然后在`Test`类的`main`方法中，通过`ApplicationContext`从XML配置文件中加载了Spring容器，并从容器中获取了`A`类的实例`a`。然后调用了`a`的`print`方法，并打印了`a`的类名。接着，将`a`强制类型转换为`I`接口类型，并调用了`test`方法。

根据AOP配置，`a`的实例`A`被引入了`I`接口，并且默认实现为`B`类。因此，将`a`强制类型转换为`I`接口并调用`test`方法时，实际上会调用`B`类的`test`方法。

从spring容器中拿出来的`a`对象可以被强转换成`I`类型的对象。如果调用`I`的方法必须要强转，因为这些都是spring背后做了很多事情。

------

#### 基于注解

对类进行增强实例：

```java
/*@EnableAspectJAutoProxy:支持处理标有 AspectJ @Aspect 注解的组件，
类似于 Spring 的 XML 元素中的 <aop:aspectj-autoproxy> 功能。
用于 @Configuration 类*/
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class Test {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test.class);
        A a= ac.getBean(A.class);
        a.print();
        System.out.println(a.getClass().getName());
        I i=(I)a;
        i.test();
    }
}
@Component
class A{
    public void print(){
        System.out.println("飞行");
    }
}
interface I{
    void test();
}
@Component
class B implements I{
    @Override
    public void test() {
        System.out.println(getClass().getName());
        System.out.println(this);
    }
}
/*这里重名了，因此要完全名*/
@org.aspectj.lang.annotation.Aspect
@Component
class Aspect{
    @DeclareParents(value ="com.aotmd.test.A",defaultImpl = B.class)
    public I i;
}
```

控制台：

```text
飞行
com.aotmd.test.A$$EnhancerBySpringCGLIB$$5fdfd7a5
com.aotmd.test.B
com.aotmd.test.B@2fd953a6
```

这里使用了`@EnableAspectJAutoProxy`注解来启用对标记有AspectJ `@Aspect`注解的组件的支持，类似于在Spring XML配置中使用`<aop:aspectj-autoproxy>`元素的功能。这个注解通常用于`@Configuration`类中。通过这个注解，Spring将会自动代理被`@Aspect`注解标记的类，使得切面逻辑能够被织入到目标类中。

`@Aspect`: 这个注解用于标记一个类为切面（Aspect），其中定义了切面的通知（advice）和切点（pointcut）。在上面的代码中，`Aspect`类被标记为切面，用于定义引入操作。

`@DeclareParents`: 这个注解用于在切面中声明引入操作，将新的接口引入到目标类中。在上面的代码中，`Aspect`类使用`@DeclareParents`注解来向`A`类引入`I`接口，并指定`B`类作为默认实现类。

`@DeclareParents`的属性说明:

| **属性**         | **解释**                                    |
| ---------------- | ------------------------------------------- |
| `value`          | AspectJ类型表达式，所限制的类可加`+*..`这几个符号   |
| `default-impl`   | 将引入接口的实现类的完全限定名称的class实例 |

`@DeclareParents`用在切面类(`@Aspect`)中的需要引入的接口实例上。

注意:切面类(`@Aspect`)需要`@Component`成一个Bean,才能在内部使用`@DeclareParents`。

### 动态代理类型

在Java中有多种动态代理技术，例如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术是JDK和CGLIB。目前，在SpringAOP中常用JDK和CGLIB两种动态代理技术。

#### JDK动态代理

JDK动态代理是`java.lang.reflect.*`包提供的方式，它**必须借助**一个**接口**才能产生代理对象。因此，对于使用业务接口的类，Spring默认使用JDK动态代理实现AOP。

JDK中所要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中具有一定的局限性，而且使用反射的效率也并不是很高。

要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成，所以首先要编写用于生成代理对象的类。

java在JDK1.5之后提供了一个`java.lang.reflect.Proxy`类，通过`Proxy`类提供的一个`newProxyInstance`方法用来创建一个对象的代理对象，只需传入目标接口的类加载器、目标接口以及`InvocationHandler`回调接口，便可为**目标接口**生成代理类及代理对象，而且生成的代理类是其接口的实现类。

```java
Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);
```

通过`Proxy.newProxyInstance()`创建`interface`实例，需要3个参数：  

1. 使用的`ClassLoader`，通常就是接口的`ClassLoader`；
2. 需要实现的接口数组，**至少需要传入一个接口进去**；
3. 用来处理接口方法调用的`InvocationHandler`实例。 

返回值为接口实现类的实例。

`InvocationHandler`回调接口有一个方法，对于代理的逻辑方法，**所有动态代理类的方法调用都会交给该回调接口方法处理**，因此不要使用`method.invoke(proxy,args);`代码，这会导致无限递归：

```java
public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable;
```

参数解释：

* `proxy`：把代理对象自己传递进来。
* `method`：把代理对象当前调用的方法传递进来可以使用这个参数来获取方法的信息，比如方法名、参数类型等。
* `args`：方法的参数数组。这个参数包含了方法调用时传入的参数值。
* `返回值`：返回函数执行的结果，取决于你想返回什么。

通过一般类实现：

```java
public class Test2 {
    public static void main(String[] args) {
        JDKProxy<T> proxy = new JDKProxy<>();//创建生成代理对象的工厂类，同时它也负责InvocationHandler的执行逻辑。
        T t=new TDemo();//创建目标对象
        /*获取增强后的目标对象*/
        T t2= proxy.createProxy(t);
        t2.delete();//任何调用都会传入invoke()回调方法,具体执行逻辑由invoke()决定。
        System.out.println(t.getClass().getName());
        System.out.println(t2.getClass().getName());
    }
}
interface T{
    void save();
    void modify();
    void delete();
}

/**
 * 目标对象
 */
class TDemo implements T{
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
    public void delete2() {System.out.println("删除逻辑2执行");}
}
/**
 * 切面类，可以定义多个通知，即增强处理的方法
 */
class AspectDemo{
    public void check(){System.out.println("模拟权限控制");}
    public void except(){System.out.println("模拟异常处理");}
    public void log(){System.out.println("模拟日志记录");}
    public void monitor(){System.out.println("性能监测");}
}

class JDKProxy<T> implements InvocationHandler {
    /**目标类实例*/
    private T t;
    AspectDemo asp = new AspectDemo();//创建一个切面
    public T createProxy(T t){
        this.t=t;
        ClassLoader cld=t.getClass().getClassLoader();
        Class<?>[] interfaces=t.getClass().getInterfaces();
        return (T) Proxy.newProxyInstance(cld,interfaces,this);
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        asp.check();//前增强
        asp.except();
        System.out.println("转发至代理对象方法:"+method.getName());
        Object obj=method.invoke(t,args);//在目标类实例t上调用方法并传入参数
        asp.log();//后增强
        asp.monitor();
        return obj;
    }
}
```

控制台：

```text
模拟权限控制
模拟异常处理
转发至代理对象方法:delete
删除逻辑执行
模拟日志记录
性能监测
com.aotmd.test.TDemo
com.aotmd.test.$Proxy0
```

使用匿名类，则`JDKProxy`类只负责创建代理实例功能：

```java
class JDKProxy<T> {
    @SuppressWarnings("unchecked")
    public T createProxy(T target){
        ClassLoader cld= target.getClass().getClassLoader();
        Class<?>[] interfaces= target.getClass().getInterfaces();
        return (T) Proxy.newProxyInstance(cld, interfaces, new InvocationHandler() {
            /**切面类，用来增强*/
            final AspectDemo asp = new AspectDemo();
            /**目标类实例*/
            private final T t=target;
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                asp.check();//前增强
                asp.except();
                System.out.println("转发至代理对象方法:"+method.getName());
                //在目标类实例t上调用方法并传入参数
                Object obj=method.invoke(t,args);
                asp.log();//后增强
                asp.monitor();
                return obj;
            }
        });
    }
}
```

#### CGLIB 动态代理

JDK 动态代理必须提供接口才能使用，对于没有提供接口的类，只能采用CGLIB 动态代理。CGLIB (Code Generation Library ） 是一个高性能开源的代码生成包，采用非常底层的字节码技术，**对指定的目标类生成一个子类，并对子类进行增强**。在Spring Core 包中己经集成了CGLIB 所需要的JAR 包，因此不需要另外导入JAR 包。

CGLIB代理的类，**无需**强制实现接口，其生成的代理类是被代理类的子类，并且重写的被代理类的方法。

要使用CGLIB创建代理实例，需要用到`org.springframework.cglib.proxy.Enhancer`类，首先实例化`Enhancer`类，然后通过`setSuperclass`设置需要增强的对象的class实例，最后通过`setCallback`设置`MethodInterceptor`回调接口，再通过`create`创建代理对象。

`MethodInterceptor`回调接口有一个方法`intercept`，对于代理的逻辑方法，**所有动态代理类的方法调用都会交给该回调接口方法处理**，因此还是不要使用`method.invoke(o,objects);`代码，这会导致无限递归：

```java
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {}
```

参数解释：

* `o`：是CGLIB 根据指定父类生成的代理对象的实例。
* `method`：把代理对象当前要调用的方法传递进来，可以使用这个参数来获取方法的信息，比如方法名、参数类型等。
* `objects`：把方法参数通过数组传递进来。
* `methodProxy`：MethodProxy对象，可以用于调用**原始方法**（即目标的方法）。在intercept方法中，如果你需要调用原始方法，可以使用这个proxy对象。
* `返回值`：返回函数执行的结果，取决于你想返回什么。

`MethodProxy`是CGLIB库中的一个类，用于代理方法的调用。`MethodProxy`类提供了一些常用的方法，例如：

- `invokeSuper(Object obj, Object[] args)`: 调用被代理方法的实现
- `getSignature()`: 获取被代理方法的签名
- `getSuperIndex()`: 获取被代理方法在父类中的索引
- `getSuperName()`: 获取被代理方法的名称
- `getSuperDescriptor()`: 获取被代理方法的描述符
- `getSuperMethod()`: 获取被代理方法的`java.lang.reflect.Method`对象

通过一般类实现：

```java
public class Test2 {
    public static void main(String[] args) {
        CGLIBProxy proxy = new CGLIBProxy();//创建生成代理对象的工厂类，同时它也负责MethodInterceptor的执行逻辑。
        TDemo t=new TDemo();//创建目标对象
        /*获取增强后的目标对象*/
        TDemo t2= (TDemo) proxy.createProxy(t);
        t2.delete();//任何调用都会传入intercept()回调方法,具体执行逻辑由intercept()决定。
        System.out.println(t.getClass().getName());
        System.out.println(t2.getClass().getName());
    }
}
/**
 * 目标对象
 */
class TDemo{
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
    public void delete2() {System.out.println("删除逻辑2执行");}
}
/**
 * 切面类，可以定义多个通知，即增强处理的方法
 */
class AspectDemo{
    public void check(){System.out.println("模拟权限控制");}
    public void except(){System.out.println("模拟异常处理");}
    public void log(){System.out.println("模拟日志记录");}
    public void monitor(){System.out.println("性能监测");}
}

class CGLIBProxy implements MethodInterceptor{
    AspectDemo asp = new AspectDemo();//创建一个切面
    public Object createProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());//确定需要增强的类
        enhancer.setCallback(this);//确定回调对象
        return enhancer.create();//创建代理对象
    }
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        asp.check();//前增强
        asp.except();
        System.out.println("转发至代理对象方法:"+method.getName());
        Object result = methodProxy.invokeSuper(o, objects);//转发调用目标类对应方法
        asp.log();//后增强
        asp.monitor();
        return result;
    }
}
```

控制台：

```text
模拟权限控制
模拟异常处理
转发至代理对象方法:delete
删除逻辑执行
模拟日志记录
性能监测
com.aotmd.test.TDemo
com.aotmd.test.TDemo$$EnhancerByCGLIB$$a9a7303e
```

使用匿名类，则`CGLIBProxy`类只负责创建代理实例功能：：

```java
class CGLIBProxy{
    public Object createProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());//确定需要增强的类
        enhancer.setCallback(new MethodInterceptor() {
            final AspectDemo asp = new AspectDemo();//创建一个切面
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                asp.check();//前增强
                asp.except();
                System.out.println("转发至代理对象方法:"+method.getName());
                Object result = methodProxy.invokeSuper(o, objects);//转发调用目标类对应方法
                asp.log();//后增强
                asp.monitor();
                return result;
            }
        });//确定回调对象
        return enhancer.create();//创建代理对象
    }
}
```

### 使用动态代理

在Spring中**默认**使用JDK动态代理实现AOP编程。使用`org.spring.framework.aop.framework.ProxyFactoryBean`创建代理是SpringAOP实现的最基本方式。

根据Spring中通知在目标类方法中的**连接点**位置，通知可以分为6种类型。

环绕通知（`org.aopalliance.intercept.Methodlnterceptor`）是在目标方法**执行前**和**执行后**实施增强，可应用于日志记录、事务处理等功能。它的方法签名为：

```java
Object invoke(MethodInvocation invocation) throws Throwable;
```

其中`MethodInvocation`接口具有以下常用方法：

1. `Object[] getArguments()`: 获取方法调用的参数数组。
2. `Method getMethod()`: 获取被调用的方法对象。
3. `Object getThis()`: 获取目标对象，即被代理的对象。
4. `AccessibleObject getStaticPart()`: 获取静态部分，即被调用的方法或构造函数。
5. **`Object proceed() throws Throwable`: 执行下一个拦截器或目标方法，返回方法的返回值。**
6. `Object getReturnValue()`: 获取方法调用的返回值。
7. `Throwable getThrowable()`: 获取方法调用过程中抛出的异常。
8. `void setArguments(Object[] arguments)`: 设置方法调用的参数数组。
9. `void setReturnValue(Object returnValue)`: 设置方法调用的返回值。
10. `void setThrowable(Throwable throwable)`: 设置方法调用过程中抛出的异常。

前置通知（`org.springframework.aop.MethodBeforeAdvice`）是在目标方法**执行前**实施增强，可应用于权限管理等功能。

```java
public void before(Method method, Object[] args, Object target) throws Throwable {}
```

后置返回通知（`org.spring:framework.aop.AfterReturningAdvice`）是在目标方法**成功执行后**实施增强，可应用于关闭流、删除临时文件等功能，多了个`returnValue`，表示返回值。

```java
public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {}
```

后置(最终)通知（`org.springframework.aop.AfterAdvice`）是在目标方法**执行后**实施增强，与后置返回通知不同的是，**不管是否发生异常**都要执行该类通知，该类通知可应用于释放资源。

异常通知（`org.springframework.aop.ThrowsAdvice`）是在方法**抛出异常后**实施增强，可应用于处理异常、记录日志等功能。

引入通知（`org.springframework.aop.IntroductionInterceptor`）是在目标类中**添加一些新的方法和属性**，可应用于修改目标类（增强类）。

#### ProxyFactoryBean

ProxyFactory Bean是`org.springframework.beans.factory.FactoryBean` 接口的实现类，FactoryBean负责实例化一个Bean实例， ProxyFactoryBean 负责为其他Bean实例创建代理实例。ProxyFactoryBean 类的常用**属性**如下：

| **属性**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| target           | 代理的目标对象                                               |
| proxyInterfaces  | 代理需要实现的**接口列表**。如果是多个接口,可以使用以下格式赋值: `<list><value>/value><list>`  ，JDK代理使用这个参数。 |
| interceptorNames | 需要织入目标的Advice                                         |
| proxyTargetClass | 是否对类代理而不是接口,默认为false,使用JDK动态代理;当为true时,使用 CGLIB动态代理 |
| singleton        | 返回的代理实例是否为单例,默认为true                          |
| optimize         | 当设置为true时强制CGLIB使用动态代理                          |

示例：

```java
public class Test{
    public static void main(String[] args) {
        AbstractApplicationContext aac=new ClassPathXmlApplicationContext("application.xml");
        A cGLIBProxy = (A) aac.getBean("cGLIBProxy");
        cGLIBProxy.delete();
        System.out.println(cGLIBProxy.getClass().getName());
        IBase jDKProxy=(IBase)aac.getBean("jDKProxy");
        jDKProxy.save();
        System.out.println(jDKProxy.getClass().getName());
    }
}
class Aspect1 implements
        MethodInterceptor, MethodBeforeAdvice, AfterReturningAdvice
{
    public Object invoke(MethodInvocation i) throws Throwable {
        System.out.println("当前拦截对象:"+i.getMethod().getName());
        System.out.print("环绕通知前->");
        Object o = i.proceed();//转发,继续执行链中的下一个拦截。
        System.out.println("环绕通知后");
        return o;
    }
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("前置通知");
    }
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.print("后置通知->");
    }
}
/*下面使用CGLIB代理*/
class A {
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
}
/*下面使用JDK代理*/
interface IBase {
    void save();
    void modify();
    void delete();
}
class B implements IBase {
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
}
```

XML：

```xml
<bean id="aspect1" class="com.aotmd.test.Aspect1"/>
<!--下面使用CGLIB代理-->
<bean id="a" class="com.aotmd.test.A"/>
<bean id="cGLIBProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target" ref="a"/><!--指定要代理的目标对象-->
    <property name="interceptorNames" value="aspect1"/><!--指定切面-->
    <property name="proxyTargetClass" value="true"/><!--代理方式,默认falseJDK代理,true,CGLIB代理-->
</bean>
<!--下面使用JDK代理，共用aspect1，并使用p命名空间简化set注入-->
<bean id="b" class="com.aotmd.test.B"/>
<!--proxyInterfaces参数指定接口-->
<bean id="jDKProxy" class="org.springframework.aop.framework.ProxyFactoryBean"
      p:proxyInterfaces="com.aotmd.test.IBase" p:target-ref="b"
      p:interceptorNames="aspect1" p:proxyTargetClass="false"/>
```

控制台：

```text
当前拦截对象:delete
环绕通知前->前置通知
删除逻辑执行
后置通知->环绕通知后
com.aotmd.test.A$$EnhancerBySpringCGLIB$$4b7ac9ec
当前拦截对象:save
环绕通知前->前置通知
保存逻辑执行
后置通知->环绕通知后
com.aotmd.test.$Proxy5
```

### Aspectj

#### 切入点语法定义

在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义切入点(pointcut)。Pointcut可以通过`&&` 、`||`和`!`的方式进行组合。

**execution()**

**注意, `execution()`扫描的仅为依赖注入(控制反转)下的Bean**。

`execution()`是最常用的切点函数，其语法如下所示：修饰符 注解与异常是可选的。

```java
execution(<注解><修饰符> <返回类型> <[包名.][类名.]方法名>(<参数>) <异常>)
```

| 通配符 | **含义**                                                     |
| ------ | ------------------------------------------------------------ |
| `*`    | 所有语法中匹配任意字符,可与具体名称混写。                    |
| `+`    | 匹配接口及其所有实现类的方法。以及`Object+`用法,匹配`Object`类型或该类的子类,接口同理。 |
| `..`   | `void springAOP..*(..)) `，`..`匹配所有子包， `*`表任意方法名, `<参数>`中的`..`匹配任意数量类型的参数。 |

------

**对于：`<[包名.][类名.]方法名>`:**

`execution(void springAOP..*(..))` ：可用,匹配所有返回值为`void`,并在springAOP包及其所有子包下的所有方法。

`execution(void springAOP..(..))：`省略`*`号报错,可见`..`**只能匹配到包到类名**,没有匹配方法名称。

`execution(void *(..))`可用,匹配所有返回值为`void`的方法

`execution(void *.*(..))`可用,匹配所有返回值为`void`的方法

`execution(void *c(..))`可用,匹配以`c`结尾返回值为`void`的所有包与类中的方法

`execution(void a*(..))`可用,匹配以`a`开头返回值为`void`的所有包与类中的方法

`execution(void *.a*(..))`同上

`execution(void *.add.a*(..))`可用,没有匹配到`springIOC.pp.add`类下的`add`方法,推测`*`号被限制**只能匹配一层包或类**了

`execution(void springIoC.*.add.a*(..))`可用,正常匹配

`execution(void *.pp.add.a*(..))`可用,正常匹配

`execution(void ..a*(..))`报错，`..`通配符只能用于包名，而不能用于类名或方法名。

`execution(void ...*(..))`可用,匹配项未知

`execution(void spring*..*(..))`可用,匹配包名头为`spring`的任意包及其子包类中的`void`返回值的任意方法

`execution(void springAOP.aaa.T+.sc(..))`，`T`是一个接口因此只能用`+`的形式, 匹配`T`接口的实现类或其子接口的实现类的`sc`方法。

------

**对于`(<参数>)`**：

切点表达式中方法入参部分比较复杂，可以使用`*`和`..`通配符。

其中`*`表示**任意类型**的参数，而`..`表示**任意类型参数且参数个数不限**。

如果方法中的入参类型是`java.lang`包下的类，可以直接使用类名，否则**必须使用全限定类名**，如`joke(java.util.List,int)`。

`execution(* *(String,..))`匹配第一个参数为`String`的所有方法,**包括只有一个`String`参数**

`execution(void *(String,*))`匹配第一个参数为`String`,第二个为任意的所有方法,**限定参数个数为2**。

`execution(void *(..,String,..))`匹配参数带`String`类型的所有方法

`execution(void *(Object+))`匹配`Object`类型或该类的子类,限定参数为1

`execution(void *(Object))`**只**匹配`Object`类型,限定参数为1

`execution(void *(springAOP.aaa.T+))`匹配`T`接口或接口的实现类,以及继承`T`接口的其他接口与实现类。

------

**对于`<异常>`：**

`execution(void *(..)throws java.lang.IllegalArgumentException)`匹配**带**这个异常的方法

`execution(void *(..)throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException`匹配**带**这两个异常的方法

`execution(void *(..)throws Exception+)`同理,匹配该异常,**以及该异常下的所有子异常**

`execution(void *(..)throws Exception,java.lang.IllegalArgumentException)`**多个异常无位置关系**

------

**对于`<注解>`：**

`execution(@java.lang.Override * *(..))`没有实验过

------

**对于`<修饰符>`：**

`execution(private * *(..))`无效,因为无法**直接**在外部调用该方法

`execution(protected * *(..))`没有问题,**直接**访问该方法可以匹配,通过该方法所在类的其他方法**间接访问无法起作用**

`execution(protected+ * *(..))`**无法使用**`+`,报错,情理之中。

------

**对于`<返回类型>`：**

`execution(Object+ *(..))`同样,具有匹配`Object`类型或该类的子类,返回值`String`会被匹配。

------

**`args()`**

该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：`args(com.baobaotao.Waiter)`。

它表示运行时入参是`Waiter`类型的方法，它和`execution(* *(com.baobaotao.Waiter))`区别在于后者是针对类方法的签名而言的，而前者则针对**运行时**的入参类型而言。

如 `args(com.baobaotao.Waiter)`既匹配于`addWaiter(Waiter waiter)`也匹配于`addNaiveWaiter(NaiveWaiter naiveWaiter)`

而`execution(* *(com.baobaotao.Waiter))`只匹配`addWaiter(Waiter waiter)`方法；

实际上，`args(com.baobaotao.Waiter)`等价于`execution(* *(com.baobaotao.Waiter+))`，当然也等价于`args(com.baobaotao.Waiter+)`。

**`@args()`**

该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。如`@args(com.baobaotao.Monitorable)`表示任何这样的一个目标方法：它有一个入参且入参对象的类标注`@Monitorable`注解。

**`args()`和`@args()`**

`args()`函数的入参是**类名**，`@args()`函数的入参必须是**注解类的类名**。虽然`args()`允许在类名后使用`+`通配符后缀，但该通配符在此处没有意义：**添加和不添加效果都一样**。



**其他：**

| 类别             | 函数          | 入参       | 说明                                                     |
| ---------------- | ------------- | -------------- | ------------------------------------------------------------ |
| 方法切点函数     | `execution()` | **方法**匹配模式串 | 表示满足某一匹配模式的所有目标类方法连接点。如`execution(* greetTo(..))`表示所有目标类中的`greetTo()`方法。 |
| 同上   | `@annotation()` | 方法**注解类名** | 表示标注了特定注解的目标方法连接点。如`@annotation(com.baobaotao.anno.NeedTest)`表示任何标注了`@NeedTest`注解的目标类方法。 |
| 方法**入参**切点函数 | `args()`      | **类名**       | 通过判别目标类方法运行时入参对象的类型定义指定连接点。如`args(com.baobaotao.Waiter)`表示所有有且仅有一个按类型匹配于Waiter的入参的方法。 |
| 同上 | `@args()`     | 类型**注解类名** | 通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如`@args(com.baobaotao.Monitorable)`表示任何这样的一个目标方法：它有一个入参且入参对象的类标注`@Monitorable`注解。 |
| 目标类切点函数   | `within()`    | **类名**匹配串 | 表示特定域下的所有连接点。如`within(com.baobaotao.service.*)`表示`com.baobaotao.service`包中的所有连接点，也即包中所有类的所有方法，而`within(com.baobaotao.service.*Service)`表示在`com.baobaotao.service`包中，所有以Service结尾的类的所有连接点。 |
| 同上 | `target()`    | **类名**       | 假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过`target(com.baobaotao.Waiter)`定义的切点，`Waiter`、以及`Waiter`实现类`NaiveWaiter`中所有连接点都匹配该切点。 |
| 同上 | `@within()`   | 类型**注解类名** | 假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点。如`@within(com.baobaotao.Monitorable)`定义的切点，假如`Waiter`类标注了`@Monitorable`注解，则`Waiter`以及`Waiter`实现类`NaiveWaiter`类的所有连接点都匹配。 |
| 同上 | `@target()`   | 类型**注解类名** | 目标类标注了特定注解，则目标类所有连接点匹配该切点。如`@target(com.baobaotao.Monitorable)`，假如`NaiveWaiter`标注了`@Monitorable`，则`NaiveWaiter`所有连接点匹配切点。 |
| **代理类**切点函数 | `this()`      | **类名**       | 代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。如果有一个接口`MyInterface`，并且有一个代理类`MyProxy`实现了这个接口，那么使用`this(MyInterface)`将匹配所有`MyProxy`代理类中实现`MyInterface`接口的连接点。 |



#### 基于XML实现

AspectJ是一个基于Java语言的AOP框架。从Spring2.0以后引入了AspectJ的支持。对于目前的Spring框架，**建议**开发者使用AspectJ实现SpringAOP。

使用AspectJ实现Spring AOP的方式有两种，一是基于XML配置开发AspectJ，二是基于注解开发AspectJ。

基于XML配置开发AspectJ是指通过XML配置文件定义切面、切入点及通知，所有这些定义都必须在`<aop:config>`元素内。

| **元素名称**            | **用途**                                                     |
| ----------------------- | ------------------------------------------------------------ |
| `<aop:config>`          | 开发AspectJ的顶层配置元素，在配置文件的`<beans>`下可以包含多个该元素 |
| `<aop:aspect>`          | 配置（定义）一个切面，`<aop:config>`子元素，属性`ref`指定切面的定义 |
| `<aop:pointcut>`        | 配置切入点，`<aop:aspect>`子元素，属性`expression`指定通知增强哪些方法 |
| `<aop:before>`          | 配置前置通知,`<aop:aspect>`子元素, 目标方法执行前实施增强属性`method`指定前置通知方法,属性`pointcut-ref`指定关联的切入点 |
| `<aop:after-returning>` | 配置后置返回通知, `<aop:aspect>`子元素, 目标方法成功执行后实施增强属性`method`指定后置返回通知方法,属性`pointcut-ref`指定关联的切入点 |
| `<aop:around>`          | 配置环绕通知, `<aop:aspect>`子元素, 目标方法执行前和执行后实施增强属性`method`指定环绕通知方法,属性`pointcut-ref`指定关联的切入点 |
| `<aoppafter-throwing>`  | 配置异常通知, `<aop:aspect>`子元素, 抛出异常后实施增强属性`method`指定异常通知方法,属性`pointcut-ref`指定关联的切入点, |
| `<aop:after>`           | 配置后置(最终)通知, `<aop:aspect>`子元素, 标方法*执行后*实施增强属性`method`指定后置(最终)通知方法,属性`pointcut-ref`指定关联的切入点 |
| `<aop:declare-parents>` | 给通知引入新的额外接口，增强功能。                           |

实例：

```xml
<bean id="td6" class="com.aotmd.test.TDemo6"/><!--目标Bean-->
<bean id="aspectJProxy" class="com.aotmd.test.AspectJProxy"/><!--拦截器实现方法-->
<aop:config><!--配置AOP-->
    <aop:aspect ref="aspectJProxy"><!--拦截器配置-->
        <!--配置切入点,即给指定的方法增强,当前expression表达式为返回值为void在TDemo6类下的任意形参的方法-->
        <aop:pointcut id="myPointCut" expression="execution(void com.aotmd.test.TDemo6.*(..))"/>
        <aop:before method="before" pointcut-ref="myPointCut"/><!--关联指定拦截器(切面)的某方法为前置通知,并匹配切点-->
        <aop:after-returning method="afterReturning" pointcut-ref="myPointCut"/><!--同上,后置返回通知-->
        <aop:around method="around" pointcut-ref="myPointCut"/><!--同上,环绕通知-->
        <aop:after-throwing method="except" pointcut-ref="myPointCut" throwing="e"/><!--同上,异常通知,throwing异常方法形参-->
        <aop:after method="after" pointcut-ref="myPointCut"/><!--同上,关联后置(最终通知)-->
    </aop:aspect>
</aop:config>
```

类文件：

```java
package com.aotmd.test;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Test2 {
    public static void main(String[] args) {
        AbstractApplicationContext aac=new ClassPathXmlApplicationContext("application.xml");
        TDemo6 td6 = (TDemo6) aac.getBean("td6");
        td6.save();
        td6.delete();//不是void返回值,因此没有被代理
    }
}

class AspectJProxy{
    /**前置通知 @param jp 作为参数获得目标对象信息*/
    public void before(JoinPoint jp){
        System.out.print("前置通知：模拟权限控制");
        System.out.println("，目标类对象："+jp.getTarget()+"，被增强处理的方法："+jp.getSignature().getName());
    }
    public void afterReturning(JoinPoint jp){
        System.out.print("后置返回通知：模拟删除临时文件");
        System.out.println("，目标类对象："+jp.getTarget()+"，被增强处理的方法："+jp.getSignature().getName());
    }
    /**环绕通知,必须一个参数是ProceedingJoinPoint 类型
     * @param pjp ProceedingJoinPoint 是JoinPoint 的子接口， 代表可以执行的目标方法
     * @return 返回值的类型必须是Object
     * @throws Throwable */
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.print("环绕开始：执行目标方法前，模拟开启事务");
        System.out.println("，目标类对象："+pjp.getTarget()+ "，被增强处理的方法："+pjp.getSignature().getName());
        Object obj=pjp.proceed();//转发,继续下一拦截方法
        System.out.println("环绕结束：执行目标方法前，模拟关闭事务");
        return obj;
    }
    public void except(Throwable e){System.out.println("异常通知：程序执行异常"+e.getMessage());}
    public void after(){System.out.println("后置(最终)通知：模拟释放资源");}
}
class TDemo6 {
    public void save() {System.out.println("保存");}
    public void modify() {System.out.println("修改");}
    public boolean delete() {System.out.println("删除");return true;}
}
```

输出结果:

```text
前置通知：模拟权限控制，目标类对象：com.aotmd.test.TDemo6@9cd25ff，被增强处理的方法：save
环绕开始：执行目标方法前，模拟开启事务，目标类对象：com.aotmd.test.TDemo6@9cd25ff，被增强处理的方法：save
保存
后置(最终)通知：模拟释放资源
环绕结束：执行目标方法前，模拟关闭事务
后置返回通知：模拟删除临时文件，目标类对象：com.aotmd.test.TDemo6@9cd25ff，被增强处理的方法：save
删除
```

执行顺序：

![切点执行顺序](/images/posts/Java/切点执行顺序.png)

#### 基于注解实现

基于注解开发AspectJ 要比基于XML 配置开发AspectJ 便捷许多，所以在实际开发中推荐使用注解方式。

| **注解名称**    | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| `@Aspect`         | 用于定义一个切面,注解在切面类上。                            |
| `@Pointcut`       | 用于定义**切入点表达式**。在使用时需要定义一个**切入点方法**,该方法是一个**返回值void且方法体为空的普通方法。** |
| `@Before`         | 用于定义**前置通知**。在使用时通常为其指定`value`属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。 |
| `@AfterReturning` | 用于定义**后置返回通知**。在使用时通常为其指定`value`属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。 |
| `@Around`         | 用于定义**环绕通知**。在使用时通常为其指定`value`属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。 |
| `@AfterThrowing`  | 用于定义**异常通知**。在使用时通常为其指定`value`属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。另外,还有一个`throwing`属性用于访问目标方法抛出的异常,**该属性值与异常通知方法中同名的形参一致**。 |
| `@After`          | 用于定义**后置(最终)通知**。在使用时通常为其指定`value`属性值,该值可以是已有的切入点,也可以直接定义切入点表达式。 |

实例：

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class Test2 {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test2.class);
        TDemo7 tDemo7 = ac.getBean(TDemo7.class);
        tDemo7.save();
        tDemo7.delete();//不是void返回值,因此没有被代理
    }
}

@Aspect /*<aop:aspect ref="annotationAspectJProxy"><!--拦截器配置-->*/
@Component/*<bean id="annotationAspectJProxy" class="springAOP.AspectJProxy"/>*/
class AnnotationAspectJProxy {
    @Pointcut("execution(void com.aotmd.test.TDemo7.*(..))")/*配置切入点,即给指定的方法增强,
        <aop:pointcut id="cut" expression="execution(void com.aotmd.test.TDemo7.*(..))"/>*/
    private void cut(){}
    /**前置通知 @param jp 作为参数获得目标对象信息*/
    @Before("cut()")/*<aop:before method="before" pointcut-ref="cut"/>前置通知*/
    public void before(JoinPoint jp){
        System.out.print("前置通知：模拟权限控制");
        System.out.println("，目标类对象："+jp.getTarget()+"，被增强处理的方法："+jp.getSignature().getName());
    }
    @AfterReturning("cut()")/*<aop:before method="afterReturning" pointcut-ref="cut"/>后置返回通知*/
    public void afterReturning(JoinPoint jp){
        System.out.print("后置返回通知：模拟删除临时文件");
        System.out.println("，目标类对象："+jp.getTarget()+"，被增强处理的方法："+jp.getSignature().getName());
    }
    /**环绕通知,必须一个参数是ProceedingJoinPoint 类型
     * @param pjp ProceedingJoinPoint 是JoinPoint 的子接口， 代表可以执行的目标方法
     * @return 返回值的类型必须是Object
     * @throws Throwable*/
    @Around("cut()")/*<aop:before method="around" pointcut-ref="cut"/>环绕通知*/
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.print("环绕开始：执行目标方法前，模拟开启事务");
        System.out.println("，目标类对象："+pjp.getTarget()+ "，被增强处理的方法："+pjp.getSignature().getName());
        Object obj=pjp.proceed();//转发,继续下一拦截方法
        System.out.println("环绕结束：执行目标方法前，模拟关闭事务");
        return obj;
    }
    @AfterThrowing(value = "cut()",throwing = "e")
    /*<aop:after-throwing method="except" pointcut-ref="cut" throwing="e"/>
    <!--同上,异常通知,throwing异常方法形参-->*/
    public void except(Throwable e){System.out.println("异常通知：程序执行异常"+e.getMessage());}
    @After("cut()")
    /*<aop:after method="after" pointcut-ref="cut"/><!--关联后置(最终通知)-->*/
    public void after(){System.out.println("后置(最终)通知：模拟释放资源");}
}
@Component/*这里生成的Bean名称为TDemo7*/
class TDemo7 {
    public void save() {System.out.println("保存");}
    public void modify() {System.out.println("修改");}
    public boolean delete() {System.out.println("删除");return true;}
}
```

控制台：

```text
环绕开始：执行目标方法前，模拟开启事务，目标类对象：com.aotmd.test.TDemo7@5f0e9815，被增强处理的方法：save
前置通知：模拟权限控制，目标类对象：com.aotmd.test.TDemo7@5f0e9815，被增强处理的方法：save
保存
环绕结束：执行目标方法前，模拟关闭事务
后置(最终)通知：模拟释放资源
后置返回通知：模拟删除临时文件，目标类对象：com.aotmd.test.TDemo7@5f0e9815，被增强处理的方法：save
删除
```

这里使用了`@EnableAspectJAutoProxy`注解来启用对标记有AspectJ `@Aspect`注解的组件的支持，类似于在Spring XML配置中使用`<aop:aspectj-autoproxy>`元素的功能。这个注解通常用于`@Configuration`类中。通过这个注解，Spring将会自动代理被`@Aspect`注解标记的类，使得切面逻辑能够被织入到目标类中。

Spring的IoC容器看到这个注解，就会自动查找带有`@Aspect`的Bean，然后根据每个方法的`@Before`、`@Around`等注解把AOP注入到特定的Bean中。

`JoinPoint`接口是AspectJ框架中的一个核心接口，用于表示切点的信息。它提供了一些方法来获取与切点相关的信息。下面是`JoinPoint`接口中常用的方法：

- `getArgs()`：获取方法参数的数组。
- `getThis()`：获取代理对象的引用。
- **`getTarget()`：获取目标对象的引用，类型为`Signature`接口。**
- **`getSignature()`：获取方法签名的对象。**
- `getStaticPart()`：获取静态部分的对象。
- `getKind()`：获取切点的类型，如method-execution、method-call等。
- `getSourceLocation()`：获取切点所在位置的源代码位置。
- `getStaticPart()`：获取静态部分的对象。
- `toShortString()`：获取切点的简短字符串表示。
- `toLongString()`：获取切点的详细字符串表示。

`JoinPoint`接口还包含了两个内部接口`StaticPart`和`EnclosingStaticPart`。这两个接口提供了关于切点静态部分的信息。

`StaticPart`接口：表示切点的静态部分，即切点所在的位置信息。它包含了以下方法：

- `getKind()`：获取切点的类型，如`method-execution`、`method-call`等。
- `getSignature()`：获取方法签名的对象，类型为`Signature`接口。
- `getSourceLocation()`：获取切点所在位置的源代码位置。
- `toShortString()`：获取切点的简短字符串表示。
- `toLongString()`：获取切点的详细字符串表示。

`EnclosingStaticPart`接口：表示包围当前切点的静态部分，即当前切点所在的方法或构造函数的信息。它包含了与`StaticPart`接口相同的方法，用于获取包围切点的静态部分的信息。

而环绕通知的`ProceedingJoinPoint`接口继承于`JoinPoint`接口，并多了：

- `proceed()`：执行原始的连接点，即继续执行切点所在的方法。在环绕通知中，可以调用这个方法来执行原始的连接点，或者在合适的时机决定是否继续执行。
- `proceed(Object[] args)`：执行原始的连接点，并传入指定的参数。

传入参数的实例：

```java
@Around("cut()")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.print("环绕开始：执行目标方法前，模拟开启事务");
    System.out.println("，目标类对象："+pjp.getTarget()+ "，被增强处理的方法："+pjp.getSignature().getName());
    // 获取目标方法的参数
    Object[] args = pjp.getArgs();
    // 修改参数或者根据参数执行一些逻辑
    // ...
    // 调用proceed()方法并传入修改后的参数
    Object obj = pjp.proceed(args); // 传入修改后的参数
    System.out.println("环绕结束：执行目标方法前，模拟关闭事务");
    return obj;
}

```

在环绕通知中，如果目标方法有参数，可以直接调用`pjp.proceed()`方法而不传递任何参数。这是因为`proceed()`方法会自动使用目标方法的原始参数进行执行。

如果要**修改传入的参数**，可以使用`proceed(Object[] args)`：

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class Test2 {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test2.class);
        TDemo7 tDemo7 = ac.getBean(TDemo7.class);
        tDemo7.save();
        tDemo7.delete();
        tDemo7.modify("123");
    }
}

@Aspect
@Component
class AnnotationAspectJProxy {
    @Pointcut("execution(void com.aotmd.test.TDemo7.*(..))")
    private void cut(){}
    @Around("cut()")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("环绕："+pjp.getSignature().getName());
        Object obj;
        if (pjp.getArgs().length==1){
            obj=pjp.proceed(new Object[]{"修改"});
        }else {
            obj=pjp.proceed();
        }
        return obj;
    }
}
@Component
class TDemo7 {
    public void save() {System.out.println("保存");}
    public void modify(String s) {System.out.println("修改"+s);}
    public boolean delete() {System.out.println("删除");return true;}
}
```

控制台：

```java
环绕：save
保存
删除
环绕：modify
修改修改
```

这里为了正常调用无参数的`save`方法，做了一个判断，不管传入什么字符串给`modify`，都会被hook为`修改`字符串。

当然，也可以区分切点，就不需要判断了：

```java
@Around("execution(void com.aotmd.test.TDemo7.modify(..))")
public Object around(ProceedingJoinPoint pjp) throws Throwable {
    System.out.println("环绕："+pjp.getSignature().getName());
    Object obj=pjp.proceed(new Object[]{"修改"});
    return obj;
}
```

 **Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。**

Spring AOP实现AOP的方式是动态代理，而AspectJ实现的方式是静态代理。Spring虽然支持AspectJ，但仅仅是支持AspectJ的切点解析和匹配，比如`@Before`注解和`execution()`语句，代理的底层实现还是JDK动态代理和CGLIB动态代理。

Spring AOP（动态代理）：
- Spring AOP基于代理模式，使用JDK动态代理或CGLIB动态代理来创建代理对象。
- 当目标对象实现了接口时，Spring AOP使用JDK动态代理来创建代理对象。
- 当目标对象没有实现接口时，Spring AOP使用CGLIB动态代理来创建代理对象。
- Spring AOP通过在运行时动态地创建代理对象，并将切面逻辑织入到代理对象的方法中来实现AOP。

AspectJ（静态代理）：
- AspectJ是一个独立的AOP框架，它使用静态代理来实现AOP。
- AspectJ通过编译时织入（CTW）或类加载时织入（LTW）的方式，在编译或加载阶段将切面逻辑织入到目标类中。

------

**使用`@annotation()`切入点**

使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。

Spring提供的`@Transactional`就是一个非常好的例子。如果自己写的Bean希望在一个数据库事务中被调用，就在方法上标注上`@Transactional`，或者直接在class级别注解，表示所有public方法都被安排了。通过`@Transactional`，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。

以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，定义一个性能监控的注解：

```java
@Target(METHOD)
@Retention(RUNTIME)
@interface MetricTime {
    String value() default "";
}
```

然后在需要被监控的关键方法上标注该注解：

```java
@Component/*这里生成的Bean名称为TDemo7*/
class TDemo7 {
    public void save() {System.out.println("保存");}
    @MetricTime
    public void modify(String s) {System.out.println("修改"+s);}
    public boolean delete() {System.out.println("删除");return true;}
}
```

然后，使用`@annotation()`切入点，并定义具体逻辑：

```java
@Aspect
@Component
class AnnotationAspectJProxy {
    @Around("@annotation(com.aotmd.test.MetricTime) && @annotation(m)")
    public Object around(ProceedingJoinPoint pjp,MetricTime m) throws Throwable {
        long start = System.currentTimeMillis();
        try {
            return pjp.proceed();
        } finally {
            long t = System.currentTimeMillis() - start;
            // 写入日志或发送至JMX:
            System.err.println("[Metrics] " + pjp.getTarget().getClass()+"->" +pjp.getSignature().getName() + ": " + t + "ms");
        }
    }
}
```

`around()`方法标注了`@annotation(com.aotmd.test.MetricTime) && @annotation(m)`，`@annotation(com.aotmd.test.MetricTime)`意思为目标方法是带有`@MetricTime`注解的方法。

如果还要读取`MetricTime`注解实例的内容，就需要把**注解实例**注入到**通知方法**中，则需要追加`&& @annotation(m)`部分，通知方法应有一个名称为`m`的形式参数，类型为`MetricTime`，Spring会给`m`传入注解实例本身。因为形参带有类型，因此可以直接写成：`@Around("@annotation(m)")`。

如果不需要注解的内容，则直接写：`@Around("@annotation(com.aotmd.test.MetricTime)")`。

执行：

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class Test2 {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test2.class);
        TDemo7 tDemo7 = ac.getBean(TDemo7.class);
        tDemo7.save();
        tDemo7.delete();
        tDemo7.modify("123");
    }
}
```

控制台：

```text
保存
删除
修改123
[Metrics] class com.aotmd.test.TDemo7->modify: 4ms
```



### AOP原理

无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态**织入**了其他逻辑，因此，AOP本质上就是一个**代理模式**。

因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。

假设定义了一个`TDemo7`的Bean：

```java
@Component/*这里生成的Bean名称为TDemo7*/
class TDemo7 {
    public String s="123";
    public void save() {System.out.println("保存");}
    public void modify(String s) {System.out.println("修改："+s);}
    public boolean delete() {System.out.println("删除");return true;}
}
```

这里多个一个字段`s`，切面类：

```java
@Aspect
@Component
class AnnotationAspectJProxy {
    @Around("execution(void com.aotmd.test.TDemo7.*(..))")
    public Object around(ProceedingJoinPoint pjp) throws Throwable {
        System.out.println("-↓-环绕前-↓-");
        Object o = pjp.proceed();
        System.out.println("-↑-环绕后-↑-");
        return o;
    }
}
```

调用：

```java
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class Test2 {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test2.class);
        TDemo7 tDemo7 = ac.getBean(TDemo7.class);
        tDemo7.save();
        tDemo7.delete();
        tDemo7.modify("123");
        /*直接访问对象字段*/
        System.out.println(tDemo7.s);
        System.out.println(tDemo7.getClass());
    }
}
```

控制台：

```text
-↓-环绕前-↓-
保存
-↑-环绕后-↑-
删除
-↓-环绕前-↓-
修改：123
-↑-环绕后-↑-
null
class com.aotmd.test.TDemo7$$EnhancerBySpringCGLIB$$8c624483
```

其中对象字段`s`没有正常初始化赋值为`"123"`。为什么AOP代理后`s`就没有正常初始化呢？代理后会生成了一个子类替代原来的bean，生成子类这个过程中并没有初始化`s`。

Spring创建的AOP代理，代理类的名总是类似`class com.aotmd.test.TDemo7$$EnhancerBySpringCGLIB$$8c624483`，Java的类名实际上允许`$`字符。

为了让调用方无感，它必须继承自`TDemo7`，然后就可以使用向上提升的特性，让代码`TDemo7 tDemo7 = ac.getBean(TDemo7.class);`正常赋值。

该代理类会覆写所有`public`和`protected`方法，并在内部将**调用委托给原始的`TDemo7`实例**。

------

最终问题转换为：代理实例的成员变量`s`的值为什么是`null`。

实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：

```java
class TDemo7 {
    public String s="123";
}
```

这是编译器实际编译的代码：

```java
public class TDemo7 {
    public final String s;
    public TDemo7() {
        super(); // 构造方法的第一行代码总是调用super()
        s="123"; // 继续初始化成员变量
    }
}
```

然而，对于Spring通过CGLIB动态创建的`class com.aotmd.test.TDemo7$$EnhancerBySpringCGLIB$$8c624483`代理类，它的构造方法中，**并未调用`super()`**，因此，从父类继承的成员变量，包括`final`类型的成员变量，统统都没有初始化。

Java语言规定，任何类的构造方法，第一行必须调用`super()`，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？

这是因为自动加`super()`的功能是**Java编译器**实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用`super()`。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：

 Spring通过CGLIB创建的代理类，**不会初始化代理类自身继承的任何成员变量**，包括`final`类型的成员变量。

------

Spring在创建代理对象时，会先创建目标对象，再把目标对象注入到代理对象中，虽然代理对象继承了目标对象，但他们之间的关系本质还是组合。

为什么Spring不初始化代理对象父类？就是因为代理对象可以访问到两个`s`变量，但只需要为其中一个进行赋值，而Spring选择给target赋值，也就不需要对代理类的父类进行初始化了。

那么，为什么不直接通过super调用父类方法（即原始类方法），而是通过持有的原始target调用方法？因为有一个工厂模式创建Bean，在实例化完成后，还可以调用其他方法改变字段状态：

```java
@Bean
Map<String,String> createMap() {
    Map<String,String> map=new HashMap<>();
    map.put("key","value");
    return map;
}
```

而这个状态，很难重新被代理子类复制并替换，而且这个过程也会消耗性能，且也违背了代理模式，因此持有一个原始对象进行访问是最好的。

而且本来Bean就可以通过set方法注入其他参数或Bean，通过继承可不会重复这些额外的操作。举个简单的例子：

```java
public class Test2 {
    public static void main(String[] args) {
        A1 a1 = new A1();
        a1.setS("hello!");
        A1 a2 = new A1Proxy();
        System.out.println(a1);
        System.out.println(a2);
    }
}

class A1{
    String s;

    public void setS(String s) {
        this.s = s;
    }

    @Override
    public String toString() {return "A1{s='" + s + '\'' + '}'; }
}
class A1Proxy extends A1{
}
```

要复制`A1`的状态，对于简单的`String`，复制值就行了，比如：`a2.setS(a1.getS())`，那么如果是复杂对象，比如`Map`，自定义的对象，那复制起来就麻烦了。还不如持有一个原始对象呢。

------

那么启用了AOP后，如何修复？修复很简单，只需要把直接访问字段的代码，改为通过方法访问，这样就会在代理实例内部将**调用委托给原始的`TDemo7`实例**。即添加`getS()`：

```java
@Component/*这里生成的Bean名称为TDemo7*/
class TDemo7 {
    public String s="123";

    public String getS() {
        return s;
    }

    public void save() {System.out.println("保存");}
    public void modify(String s) {System.out.println("修改："+s);}
    public boolean delete() {System.out.println("删除");return true;}
}
```

如果要修改`s`，那也要通过方法，而不是直接访问字段修改。

------

如果`getS()`添加了`final`，因为代理类无法覆写`final`方法（这一点绕不过JVM的ClassLoader检查），因为无法覆写，所以直接调用了父类的`getS()`，因此该方法返回的是代理类的`s`，即`null`。

通过打断点步入，也可以很清晰的看到调用非`final`修饰的方法，和`final`修饰方法的不同。

实际上，如果加上日志：

```xml
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.30</version>
</dependency>
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
```

Spring在启动时会打印一个警告：

```text
22:01:34.283 [main] INFO  o.s.aop.framework.CglibAopProxy - Final method [public final java.lang.String com.aotmd.test.TDemo7.getS()] cannot get proxied via CGLIB: Calls to this method will NOT be routed to the target instance and might lead to NPEs against uninitialized fields in the proxy instance.
```

最终方法`getS()`无法通过 CGLIB 获得代理：对此方法的调用不会路由到目标实例，并且可能会导致针对代理实例中未初始化的字段的 NPE。

因此，使用Bean时，**总是调用方法**，而非直接访问字段；编写Bean时，如果可能会被代理，就不要编写`public final`方法。这样才能保证有没有AOP，代码都能正常工作。

------

**要查看动态生成的类文件，可以使用**：

```java
System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "C:\\class");
```

这两行代码是用于设置Java动态代理生成的类文件保存路径的：

`System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");`

这行代码设置了一个系统属性，告诉Java虚拟机（JVM）在生成动态代理类时保存生成的类文件。动态代理是一种在运行时创建代理对象的机制，通常用于AOP（面向切面编程）等场景。通过设置这个属性为`true`，JVM会将生成的动态代理类文件保存在默认的临时目录中。

`System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "C:\\class");`

这行代码设置了另一个系统属性，指定了动态代理生成的类文件保存的路径。在这里，`DebuggingClassWriter.DEBUG_LOCATION_PROPERTY`是一个常量，表示动态代理类文件保存路径的属性名，通常用于调试目的。通过将这个属性设置为`C:\\class`，表示将生成的动态代理类文件保存在`C:\class`目录下。

综合起来，这两行代码的作用是告诉JVM在生成动态代理类时保存生成的类文件，并指定保存路径为`C:\class`。这对于调试动态代理生成的类文件或者了解动态代理的工作原理可能会有帮助。

## 访问数据库

Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：

- 创建全局`DataSource`实例，表示数据库连接池；
- 在需要读写数据库的方法内部，按如下步骤访问数据库：
  - 从全局`DataSource`实例获取`Connection`实例；
  - 通过`Connection`实例创建`PreparedStatement`实例；
  - 执行SQL语句，如果是查询，则通过`ResultSet`读取结果集，如果是修改，则获得`int`结果。

正确编写JDBC代码的关键是使用`try ... finally`释放资源，涉及到事务的代码需要正确提交或回滚事务。

### 在Spring使用JDBC

在Spring使用JDBC，首先通过IoC容器创建并管理一个`DataSource`实例，Spring提供了一个`JdbcTemplate`，可以方便地操作JDBC，因此，通常情况下，会实例化一个`JdbcTemplate`。顾名思义，这个类主要使用了Template模式。

编写**示例代码或者测试代码**时，强烈推荐使用[HSQLDB](http://hsqldb.org/)这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。

HSQLDB是一种嵌入式数据库，一般不会持久化，仅用作简单即时性测试数据，程序执行完，数据销毁，有3种模式：`mem`、`file`、`server`。
使用`file`模式时，如果需要持久化数据，可以修改链接为：

```properties
jdbc.url=jdbc:hsqldb:file:testdb;hsqldb.write_delay=false;shutdown=true
```

`file`为单例模式，如果已连接数据库，将不能对数据库进行操作。

依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.4.0</version>
</dependency>
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>4.0.3</version>
</dependency>
```

对于**java8** , hsql 版本可以选择 2.4.0。

新建配置文件：

```properties
# 数据库文件名为testdb:
jdbc.url=jdbc:hsqldb:file:testdb

# Hsqldb默认的用户名是sa，口令是空字符串:
jdbc.username=sa
jdbc.password=
```

初始化数据库连接，并初始化`JdbcTemplate`。

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

在上述配置中：

1. 通过`@PropertySource("jdbc.properties")`读取数据库配置文件；
2. 通过`@Value("${jdbc.url}")`注入配置文件的相关配置；
3. 创建一个`DataSource`实例，它的实际类型是`HikariDataSource`，创建时需要用到注入的配置；
4. 创建一个`JdbcTemplate`实例，它需要注入`DataSource`，这是通过方法参数完成注入的。

实体类：

```java
class User{
    long id;
    String email,password,name;

    public User(long id, String email, String password, String name) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.name = name;
    }
    @Override
    public String toString() {return "User{id=" + id + ", email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + '}'; }
}
```

使用与初始化表：

```java
@Component
class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        //在Spring容器启动时自动创建一个users表
        jdbcTemplate.update("DROP TABLE IF EXISTS users");
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "UNIQUE (email))");
    }

    public User getUserById(long id) {
        // 注意传入的是ConnectionCallback:
        return jdbcTemplate.execute((ConnectionCallback<User>) (conn) -> {
            // 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:
            // 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:
            try (var ps = conn.prepareStatement("SELECT * FROM users WHERE id = ?")) {
                ps.setObject(1, id);
                try (var rs = ps.executeQuery()) {
                    if (rs.next()) {
                        return new User(
                                rs.getLong("id"), 
                                rs.getString("email"), 
                                rs.getString("password"), 
                                rs.getString("name")); 
                    }
                    throw new RuntimeException("未通过 ID 找到用户。");
                }
            }
        });
    }
    public long register(String email, String password, String name) {
        // 创建一个KeyHolder:
        KeyHolder holder = new GeneratedKeyHolder();
        if (1 != jdbcTemplate.update(
                // 参数1:PreparedStatementCreator
                (conn) -> {
                    // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:
                    var ps = conn.prepareStatement("INSERT INTO users(email, password, name) VALUES(?, ?, ?)",
                            Statement.RETURN_GENERATED_KEYS);
                    ps.setObject(1, email);
                    ps.setObject(2, password);
                    ps.setObject(3, name);
                    return ps;
                },
                // 参数2:KeyHolder
                holder)
        ) {
            throw new RuntimeException("插入失败。");
        }
        // 从KeyHolder中获取返回的自增值:
        return holder.getKey().longValue();
    }
}
```

启动：

```java
@Configuration
@ComponentScan
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test4.class);
        UserService userService = ac.getBean(UserService.class);
        long id = userService.register("1@qq.com", "123456", "小米");
        System.out.println(id);
        System.out.println(userService.getUserById(id));
    }
}
```

控制台：

```text
0
User{id=0, email='1@qq.com', password='123456', name='小米'}
```

------

Spring提供的`JdbcTemplate`采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的`try...catch`语句。

`T execute(ConnectionCallback<T> action)`方法，它提供了Jdbc的`Connection`供我们使用。

`T execute(String sql, PreparedStatementCallback<T> action)`同理：

```java
public User getUserById(long id) {
    // 注意传入的是ConnectionCallback:
    return jdbcTemplate.execute("SELECT * FROM users WHERE id = ?",(PreparedStatementCallback<? extends User>) (ps) -> {
        ps.setObject(1, id);
        try (ResultSet rs = ps.executeQuery()) {
            if (rs.next()) {
                return new User(
                        rs.getLong("id"),
                        rs.getString("email"),
                        rs.getString("password"),
                        rs.getString("name"));
            }
            throw new RuntimeException("未通过 ID 找到用户。");
        }
    });
}
```

------

在Spring的`JdbcTemplate`中，`queryForObject`方法用于执行SQL查询并将结果映射为单个对象。对于`queryForObject`方法，**它期望查询结果只有一行**，如果结果集为空或者超过一行，将会抛出异常。

```java
public User getUserByEmail(String email) {
    // 传入SQL，参数和RowMapper实例:
    return jdbcTemplate.queryForObject("SELECT * FROM users WHERE email = ?",
            (ResultSet rs, int rowNum) -> {
                // 将ResultSet的当前行映射为一个JavaBean:
                return new User( // new User object:
                        rs.getLong("id"), // id
                        rs.getString("email"), // email
                        rs.getString("password"), // password
                        rs.getString("name")); // name
            },
            email);
}
```

方法签名：

```java
public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args){}
```

参数解释如下：

- `sql`：要执行的 SQL 查询语句。
- `rowMapper`：一个 RowMapper 对象，用于将查询结果集中的行映射为对象。通常情况下，需要提供一个自定义的 RowMapper 实现，用于将查询结果映射为特定类型的对象。
- `args`：可变参数，用于指定 SQL 查询语句中的参数值。这些参数将替换 SQL 查询语句中的占位符（如果有的话）。

`RowMapper<T>`接口有一个方法：`T mapRow(ResultSet rs, int rowNum) throws SQLException;`。

实现必须实现此方法才能映射 `ResultSet` 中的每一行数据。此方法不应调用 `next()` `ResultSet`;它只应映射当前行的值。

参数解释：

- `rs` – 要映射的 `ResultSet`（针对当前行预先初始化）
- `rowNum` – 当前行的编号

------

如果需要处理多行结果集，应该使用`query`方法，并提供一个合适的`ResultSetExtractor`来处理整个结果集。`query`方法允许在`ResultSetExtractor`的实现中处理每一行数据，并且可以**自由地调用**`rs.next()`来移动到结果集的下一行。

```java
public List<User> getUsers(int pageIndex) {
    int limit = 100;
    int offset = limit * (pageIndex - 1);
    return jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?",
            new BeanPropertyRowMapper<>(User.class),
            limit, offset);
}
```

方法签名：

```java
public <T> List<T> query(String sql, RowMapper<T> rowMapper, @Nullable Object... args){}
```

这里参数同`queryForObject`，这里我们直接使用Spring提供的`BeanPropertyRowMapper`。如果数据库表的结构恰好和JavaBean的属性名称一致，那么`BeanPropertyRowMapper`就可以直接把一行记录按列名转换为JavaBean，注意要符合JavaBean规范。

------

如果执行的不是查询，而是插入、更新和删除操作，那么需要使用`update()`方法：

```java
public void updateUser(User user) {
    // 传入SQL，SQL参数，返回更新的行数:
    if (1 != jdbcTemplate.update("UPDATE users SET name = ? WHERE id = ?", user.getName(), user.getId())) {
        throw new RuntimeException("User not found by id");
    }
}
```

方法签名：

```java
public int update(String sql, @Nullable Object... args){}
```

参数解释如下：

- `sql`：要执行的 SQL 查询语句。
- `args`：可变参数，用于指定 SQL 查询语句中的参数值。这些参数将替换 SQL 查询语句中的占位符（如果有的话）。

只有一种`INSERT`操作比较特殊，那就是如果某一列是自增列（例如自增主键），**通常需要获取插入后的自增值**。`JdbcTemplate`提供了一个`KeyHolder`来简化这一操作：

```java
public long register(String email, String password, String name) {
    // 创建一个KeyHolder:
    KeyHolder holder = new GeneratedKeyHolder();
    if (1 != jdbcTemplate.update(
            // 参数1:PreparedStatementCreator
            (conn) -> {
                // 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:
                var ps = conn.prepareStatement("INSERT INTO users(email, password, name) VALUES(?, ?, ?)",
                        Statement.RETURN_GENERATED_KEYS);
                ps.setObject(1, email);
                ps.setObject(2, password);
                ps.setObject(3, name);
                return ps;
            },
            // 参数2:KeyHolder
            holder)
    ) {
        throw new RuntimeException("插入失败。");
    }
    // 从KeyHolder中获取返回的自增值:
    return holder.getKey().longValue();
}
```

`KeyHolder` 接口定义了用于检索主键的方法，通常用于处理由 JDBC 插入语句返回的自动生成的主键。以下是 `KeyHolder` 接口中的方法解释：

`Number getKey()`:

- 从第一个 Map 中检索第一个项目，假设**只有一个项目**和一个 Map，并且该项目是一个数字。这是典型情况下用于获取单个数字生成的主键值。
- 如果在 Map 或 List 中遇到多个条目，表示返回了多个主键，则会抛出 `InvalidDataAccessApiUsageException` 异常。

`Map<String, Object> getKeys()`:

- 检索包含主键的第一个 Map。如果列表中有多个条目（表示**多行**返回了主键），则会抛出 `InvalidDataAccessApiUsageException` 异常。
`List<Map<String, Object>> getKeyList()`:

- 返回包含主键的 List 的引用。可以用于提取**多行**的主键（不常见的情况），也可以用于添加新的主键 Map。

`KeyHolder` 接口的实现通常由 Spring 的 `JdbcTemplate` 在执行插入操作后自动填充并返回，以便可以方便地获取生成的主键值。

------

`JdbcTemplate`只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写`try(resource) {...}`的代码，对于查询，主要通过`RowMapper`实现了JDBC结果集到Java对象的转换。

总结一下`JdbcTemplate`的用法，那就是：

- 针对简单查询，优选`query()`和`queryForObject()`，因为只需提供SQL语句、参数和`RowMapper`；
- 针对更新操作，优选`update()`，因为只需提供SQL语句和参数；
- 任何复杂的操作，最终也可以通过`execute(ConnectionCallback)`实现，因为拿到`Connection`就可以做任何JDBC操作。

实际上使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用`BeanPropertyRowMapper`就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。

例如，表的列名是`office_address`，而JavaBean属性是`workAddress`，就需要指定别名，改写查询如下：

```sql
SELECT id, email, office_address AS workAddress, name FROM users WHERE email = ?
```

### 事务

事务必须服从ACID原则。ACID指的是：原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。通俗理解，事务其实就是一系列指令的集合。

| 名词   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 原子性 | 操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。 |
| 一致性 | 事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。 |
| 隔离性 | 在该事务执行的过程中，无论发生的任何数据的改变都应该只存在于该事务之中，对外界不存在任何影响。只有在事务确定正确提交之后，才会显示该事务对数据的改变。其他事务才能获取到这些改变后的数据。 |
| 持久性 | 当事务正确完成后，它对于数据的改变是永久性的。               |



#### 编程式事务管理

在代码中显式调用 `beginTransaction`、`commit`、`rollback`等与事务处理相关的方法，这就是编程式事务管理。只有少数事务操作时，编程式事务管理才比较合适。

**基于底层API的编程式事务管理**

基于底层API 的编程式事务管理就是根据`PlatformTransactionManager` 、`TransactionDefinition` 和`TransactionStatus` 几个核心接口，通过编程的方式来进行事务处理。

Spring提供了一个`PlatformTransactionManager`来表示事务管理器，所有的事务都由它负责管理。而事务由`TransactionStatus`表示。如果手写事务代码，使用`try...catch`如下：

```java
TransactionStatus tx = null;
try {
    /*开启ts事务*/
    tx = txManager.getTransaction(new DefaultTransactionDefinition());
    // 相关JDBC操作:
    jdbcTemplate.update("...");
    jdbcTemplate.update("...");
    /*提交事务,并关闭*/
    txManager.commit(tx);
} catch (RuntimeException e) {
    /*出现异常,中断ts事务并事务回滚,若不执行则ts事务将开启至程序结束*/
    txManager.rollback(tx);
    throw e;
}
```

Spring为啥要抽象出`PlatformTransactionManager`和`TransactionStatus`？原因是JavaEE除了提供JDBC事务外，它还支持分布式事务JTA（Java Transaction API）。分布式事务是指多个数据源（比如多个数据库，多个消息系统）要在分布式环境下实现事务的时候，应该怎么实现。分布式事务实现起来非常复杂，简单地说就是通过一个分布式事务管理器实现两阶段提交，但本身数据库事务就不快，基于数据库事务实现的分布式事务就慢得难以忍受，所以使用率不高。

Spring为了同时支持JDBC和JTA两种事务模型，就抽象出`PlatformTransactionManager`。因为我们的代码只需要JDBC事务，因此，在`AppConfig`中，需要再定义一个`PlatformTransactionManager`对应的Bean，它的实际类型是`DataSourceTransactionManager`：

```java
@Configuration
@ComponentScan
@PropertySource("jdbc.properties")
public class AppConfig {
    ...
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

完整示例：

初始化与dao：

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

class User{
    long id;
    String email,password,name;
    public User() {}
    public long getId() {return id;}public void setId(long id) {this.id = id;}public String getEmail() {return email;}public void setEmail(String email) {this.email = email;}public String getPassword() {return password;}public void setPassword(String password) {this.password = password;}public String getName() {return name;}public void setName(String name) {this.name = name;}

    public User(long id, String email, String password, String name) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.name = name;
    }
    @Override
    public String toString() {return "User{id=" + id + ", email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + '}'; }
}

@Component
class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        jdbcTemplate.update("DROP TABLE IF EXISTS users");
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "UNIQUE (email))");
    }

    public List<User> getUsers(int pageIndex) {
        int limit = 100;
        int offset = limit * (pageIndex - 1);
        return jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?",
                new BeanPropertyRowMapper<>(User.class),
                limit, offset);
    }
    public void insertUser(User user) {
        // 传入SQL，SQL参数，返回更新的行数:
        if (1 != jdbcTemplate.update("INSERT INTO users(id,email, password, name) VALUES(?,?,?,?)"
                , user.getId(),user.getEmail(),user.getPassword(), user.getName())) {
            throw new RuntimeException("更新出错");
        }
    }
}
```

`jdbc.properties`:

```properties
# 数据库文件名为testdb:
jdbc.url=jdbc:hsqldb:file:testdb

# Hsqldb默认的用户名是sa，口令是空字符串:
jdbc.username=sa
jdbc.password=
```

启动类：

```java
@Configuration
@ComponentScan
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService userService = ac.getBean(UserService.class);
        TransactionStatus tx = null;
        PlatformTransactionManager txManager=ac.getBean(PlatformTransactionManager.class);
        try {
            /*开启ts事务*/
            tx = txManager.getTransaction(new DefaultTransactionDefinition());
            // 相关JDBC操作:
            userService.insertUser(new User(1,"1@qq.com", "123456", "小米"));
            userService.insertUser(new User(1,"2@qq.com", "123456", "三星"));
            /*提交事务,并关闭*/
            txManager.commit(tx);
        } catch (Exception e) {
            /*出现异常,中断ts事务并事务回滚,若不执行则ts事务将开启至程序结束*/
            txManager.rollback(tx);
            throw e;
        }finally {
            System.out.println(userService.getUsers(1));
        }
    }
}
```

控制台：`[]`，加上相同主键异常。因为回滚了事务，所以没有插入任何一条数据。

去掉事务：

```java
ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
UserService userService = ac.getBean(UserService.class);
try {
    userService.insertUser(new User(1,"1@qq.com", "123456", "小米"));
    userService.insertUser(new User(1,"2@qq.com", "123456", "三星"));
}finally {
    System.out.println(userService.getUsers(1));
}
```

控制台：

```text
[User{id=1, email='1@qq.com', password='小米', name='1'}]
```

第一条插入成功了。

使用事务时，要特别注意使用提交或回滚结束事务，如果不及时提交或者回滚，当另一个事务需要对本事务中影响的行进行**更新**的时候是会被阻塞的。一直等到事务超时释放。所以一个事物要么尽快提交，要么尽快回滚。

#### 基于`TransactionTemplate`的编程式事务管理

事务处理的代码散落在业务逻辑代码中，破坏了原有代码的条理性， 并且每一个业务方法都包含了类似的启动事务、提交以及回滚事务的样板代码。

`TransactionTemplate` 的`execute` 方法有一个`TransactionCallback` 接口类型的参数，该接口中定义了一个`doInTransaction`方法。在这里可以使用默认的事务提交和回滚规则，在业务代码中不需要显式调用任何事务处理的API。

`dolnTransaction`方法有一个`TransactionStatus` 类型的参数，可以在方法的任何位置调用该参数的`setRollbackOnly`方法将事务**标识**为回滚，以执行事务回滚。

根据默认规则，如果在执行回调方法的过程中抛出了**未检查异常（也即运行时异常）**，或者显式调用了`setRollbackOnly`方法，则回滚事务；如果事务执行完成或者抛出了`checked` 类型的异常，则提交事务。

示例，在上个例子添加代码：

`Config`:

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    ...
    @Bean
    TransactionTemplate createTransactionTemplate(@Autowired PlatformTransactionManager ptm){
        return new TransactionTemplate(ptm);
    }
}
```

`UserService`:

```java
@Component
class UserService {
	...
    public void insertUsers(List<User> list){
        tt.execute(new TransactionCallback<Object>() {
            @Override
            public Object doInTransaction(TransactionStatus status) {
                try {
                    for (User user : list) {
                        insertUser(user);
                    }
                }catch (Exception e){
                    status.setRollbackOnly();/*显示调用回滚*/
                    e.printStackTrace();
                }
                return null;
            }
        });
    }
}
```

启动：

```java
@Configuration
@ComponentScan
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService userService = ac.getBean(UserService.class);
        try {
            List<User> list=new ArrayList<>();
            list.add(new User(1,"1@qq.com", "123456", "小米"));
            list.add(new User(1,"2@qq.com", "123456", "三星"));
            userService.insertUsers(list);
        }finally {
            System.out.println(userService.getUsers(1));
        }
    }
}
```

控制台：`[]`，加上相同主键异常。因为回滚了事务，所以没有插入任何一条数据。

#### 声明式事务

使用编程的方式使用Spring事务仍然比较繁琐，更好的方式是通过声明式事务来实现。

声明式事务管理最大的优点是不需要通过编程的方式管理事务，因而不需要在业务逻辑代码中掺杂事务处理的代码，只需相关的事务规则声明便可以将事务规则应用到业务逻辑中。通常情况下，在开发中使用声明式事务处理不仅因为其简单，更主要的是因为这样使得纯业务代码不被污染，极大地方便了后期的代码维护。

与编程式事务管理相比，声明式事务管理唯一不足的地方是最细粒度只能作用到方法级别，无法做到像编程式事务管理那样可以作用到代码块级别。但即便有这样的需求，也可以通过变通的方法进行解决，例如可以将需要进行事务处理的代码块独立为方法等。

Spring 的声明式事务管理可以通过两种方式来实现，一是基于XML 的方式， 二是基于`@Transactional` 注解的方式。

##### 基于XML 

基于XML方式的声明式事务管理是通过在配置文件中配置事务规则的相关声明来实现的。Spring框架提供了`tx`命名空间来配置事务，提供了`<tx:advice>`元素来配置事务的通知。

`<tx:advice>` 标签：

- `id` 属性：用于给事务通知指定一个唯一的标识符。
- `transaction-manager` 属性：指定要使用的事务管理器的名称。

`<tx:attributes>` 标签：

- 该标签用于定义事务的属性，即事务的行为和配置。
- `<tx:method>` 标签用于指定要应用事务的方法。
- `name` 属性：用于指定方法的名称。
- 其他属性（如 `propagation`、`isolation`、`timeout`、`readOnly` 等）可以用于进一步配置事务的行为。

下面是一个示例，展示了如何使用 `<tx:advice>` 标签及其子标签：

```xml
<tx:advice id="myAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="insert*" propagation="REQUIRED" isolation="DEFAULT" timeout="10" readOnly="false"/>
        <tx:method name="update*" propagation="REQUIRED" isolation="DEFAULT" timeout="10" readOnly="false"/>
        <tx:method name="delete*" propagation="REQUIRED" isolation="DEFAULT" timeout="10" readOnly="false"/>
        <tx:method name="get*" propagation="SUPPORTS" isolation="DEFAULT" timeout="10" readOnly="true"/>
    </tx:attributes>
</tx:advice>
```

在上述示例中，事务通知（`<tx:advice>`）被命名为 `myAdvice`，并使用名为 `transactionManager` 的事务管理器。`<tx:attributes>` 标签下定义了多个 `<tx:method>` 标签，每个标签指定了一个方法的事务属性。例如，`name="insert*"` 表示匹配以 "insert" 开头的方法，并将其配置为使用 `REQUIRED` 传播行为、`DEFAULT` 隔离级别、`10` 秒的超时时间和非只读模式。

在`<tx:advice>`元素自己置了事务的增强处理后就可以通过编写AOP配置让Spring自动对目标对象生成代理。

`<aop:advisor>` 是 Spring AOP 配置中的一个标签，用于定义切面（aspect）和切入点（pointcut）之间的关联关系。它允许将一个切面应用于一个或多个切入点，以便在匹配的方法执行时执行相应的通知（advice）。

`<aop:advisor>` 标签具有以下属性：

- `advice-ref`：指定要应用的通知的引用。通常是一个事务通知、日志记录通知或其他自定义通知。
- `pointcut-ref`：指定要应用通知的切入点的引用。切入点定义了哪些方法将被通知所影响。
- `order`：指定切面的执行顺序。如果有多个切面应用于同一个切入点，可以使用 `order` 属性来控制它们的执行顺序。

以下是一个示例，展示了如何使用 `<aop:advisor>` 标签：

```xml
<aop:config>
    <aop:pointcut id="cut" expression="execution(void com.example.service.UserService.saveUser(..))" />
    <aop:advisor advice-ref="myAdvice" pointcut-ref="cut" order="1" />
</aop:config>
```

在上述示例中，`<aop:config>` 标签用于配置 AOP。`<aop:pointcut>` 标签定义了一个切入点，它匹配了 `com.example.service.UserService` 类的 `saveUser` 方法。`<aop:advisor>` 标签将切面（`myAdvice`）和切入点（`cut`）关联起来，并指定了执行顺序为 1。

当出现unchecked异常时会发生回滚。

在编程式事务管理实例上修改为基于XML形式：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">
    <bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="location" value="classpath:jdbc.properties" />
    </bean>
    <bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
        <property name="jdbcUrl" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
        <property name="dataSourceProperties">
            <props>
                <prop key="autoCommit">true</prop>
                <prop key="connectionTimeout">5000</prop>
                <prop key="idleTimeout">60000</prop>
            </props>
        </property>
    </bean>
    <bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
        <constructor-arg ref="hikariConfig"/>
    </bean>
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <constructor-arg ref="dataSource" />
    </bean>
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!--扫描自动装配，其他的Bean懒得手动写了-->
    <context:component-scan base-package="com.aotmd.test"/>

    <!--编写通知声明事务-->
    <tx:advice id="myAdvice" transaction-manager="transactionManager">
        <tx:attributes><tx:method name="*"/><!--*表示任意方法--></tx:attributes>
    </tx:advice>
    <aop:config><!--编写AOP,让spring自动对目标对象生成代理,需要使用AspectJ的表达式-->
        <aop:pointcut id="cut" expression="execution(void com.aotmd.test.UserService.insertUsers(..))"/>
        <aop:advisor advice-ref="myAdvice" pointcut-ref="cut"/><!--切面,将切入点与通知关联-->
    </aop:config>
</beans>
```

上述XML配置是使用Spring的AOP（面向切面编程）来配置事务管理的示例。

1. `<tx:advice>` 元素定义了一个事务通知（advice），它的id属性设置为`myAdvice`，并指定了事务管理器为`transactionManager`。
2. `<tx:attributes>` 元素用于定义事务的属性，这里使用了`<tx:method>` 元素，并设置`name`属性为`*`，表示适用于所有方法，`<tx:method>` 标签是在 `<aop:pointcut>` 标签匹配的基础上再进行一次匹配过滤。
3. `<aop:config>` 元素用于配置AOP，它包含了切入点和通知的定义。
4. `<aop:pointcut>` 元素定义了一个切入点（pointcut），它的`id`属性设置为`cut`，并使用了AspectJ表达式来匹配目标对象的方法。在这个示例中，切入点表达式为`execution(void com.aotmd.test.UserService.insertUsers(..))`，表示匹配`com.aotmd.test.UserService` 类中的`insertUsers` 方法。
5. `<aop:advisor>` 元素用于将切入点和通知关联起来，它的`advice-ref`属性指定了要使用的通知`myAdvice`，`pointcut-ref`属性指定了要使用的切入点`cut`。

通过上述配置，Spring会自动为匹配切入点的方法生成代理，并在方法执行前后应用事务通知。事务通知会根据事务属性（在`<tx:attributes>`中定义）来管理事务的开始、提交或回滚。

`com.aotmd.test.Test4`：

```java
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac=new ClassPathXmlApplicationContext("application.xml");
        UserService userService = ac.getBean(UserService.class);
        try {
            List<User> list=new ArrayList<>();
            list.add(new User(1,"1@qq.com", "123456", "小米"));
            list.add(new User(1,"2@qq.com", "123456", "三星"));
            userService.insertUsers(list);
        }finally {
            System.out.println(userService.getUsers(1));
        }
    }
}

class User{
    long id;
    String email,password,name;
    public User() {}
    public long getId() {return id;}public void setId(long id) {this.id = id;}public String getEmail() {return email;}public void setEmail(String email) {this.email = email;}public String getPassword() {return password;}public void setPassword(String password) {this.password = password;}public String getName() {return name;}public void setName(String name) {this.name = name;}

    public User(long id, String email, String password, String name) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.name = name;
    }
    @Override
    public String toString() {return "User{id=" + id + ", email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + '}'; }
}

@Component
class UserService {
    @Autowired
    private JdbcTemplate jdbcTemplate;
    @PostConstruct
    public void init() {
        jdbcTemplate.update("DROP TABLE IF EXISTS users");
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "UNIQUE (email))");
    }

    public List<User> getUsers(int pageIndex) {
        int limit = 100;
        int offset = limit * (pageIndex - 1);
        return jdbcTemplate.query("SELECT * FROM users LIMIT ? OFFSET ?",
                new BeanPropertyRowMapper<>(User.class),
                limit, offset);
    }
    public void insertUser(User user) {
        // 传入SQL，SQL参数，返回更新的行数:
        if (1 != jdbcTemplate.update("INSERT INTO users(id,email, password, name) VALUES(?,?,?,?)"
                , user.getId(),user.getEmail(),user.getName(), user.getId())) {
            throw new RuntimeException("更新出错");
        }
    }
    public void insertUsers(List<User> list){
        for (User user : list) {
            insertUser(user);
        }
    }
}
```

控制台：`[]`，加上相同主键异常。因为回滚了事务，所以没有插入任何一条数据。



##### 基于`@Transactional` 注解实例

Spring对一个声明式事务的方法，是如何开启的事务支持？原理仍然是AOP代理，即通过自动创建Bean的Proxy实现：

```java
public class UserService$$EnhancerBySpringCGLIB extends UserService {
    UserService target = ...
    PlatformTransactionManager txManager = ...

    public User register(String email, String password, String name) {
        TransactionStatus tx = null;
        try {
            tx = txManager.getTransaction(new DefaultTransactionDefinition());
            target.register(email, password, name);
            txManager.commit(tx);
        } catch (RuntimeException e) {
            txManager.rollback(tx);
            throw e;
        }
    }
    ...
}
```

`@ Transactional` 注解可以作用于**接口、接口方法、类以及类的方法**上。当作用于类上时，该类的所有`public` 方法都将具有该类型的事务属性。当Spring检测到带有`@Transactional`注解的方法时，它会使用配置的事务管理器来管理这些方法的事务。

同时也可以在方法级别使用该注解来**覆盖**类级别的定义。虽然`@Transactional` 注解可以作用于接口、接口方法、类以及类的方法上，但是Spring小组建议不要在接口或者接口方法上使用该注解，因为它只有在使用基于接口的代理时才会生效。

另外， `@Transactional` 注解应该只被应用到 `public` 方法上，这是由 Spring AOP 的本质决定的。如果你在 `protected`、`private` 或者默认可见性的方法上使用 `@Transactional` 注解，这将被忽略，也不会抛出任何异常。

当出现unchecked异常时会发生回滚。

如果不想对某个异常进行事务处理， 可以使用如下代码：

```java
@Transactional(rollbackFor=RuntimeException.class) //不对RuntimeException回滚生效
@Transactional(rollbackFor=Exception.class) //不对Exception回滚生效
```

另外，**需要确保在Spring的配置类中启用了事务管理**，可以通过在**配置类**上添加`@EnableTransactionManagement`注解来启用事务管理。

**注意：声明了`@EnableTransactionManagement`后，不必额外添加`@EnableAspectJAutoProxy`。**

不过`@EnableTransactionManagement`只会处理事务的注解，AOP的注解还是需要`@EnableAspectJAutoProxy`来处理。

在编程式事务管理实例上修改添加：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{

    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        Controller controller = ac.getBean(Controller.class);
        UserService userService = ac.getBean(UserService.class);
        try {
            controller.test1();
        }finally {
            System.out.println(userService.getUsers(1));
        }
    }
}
@Component
class Controller{
    @Autowired
    UserService userService;
    @Transactional
    public void test1(){
        userService.insertUser(new User(1,"1@qq.com", "123456", "小米"));
        userService.insertUser(new User(1,"2@qq.com", "123456", "三星"));
    }
}
```

控制台：`[]`，加上相同主键异常。

去掉`@Transactional`后：`[User{id=1, email='1@qq.com', password='小米', name='1'}]`，加上相同主键异常。

基于`TransactionDefinition` 、`PlatformTransactionManager`、`TransactionStatus` 的编程式事务管理是Spring 提供的最原始的方式，通常在实际工程中不推荐使用，但了解这种方式对理解Spring 事务处理的本质有很大帮助。

基于`TransactionTemplate` 的编程式事务管理是对上一种方式的封装，使得编码更简单、清晰。基于`@Transactional` 的方式将事务管理简化到了极致，极大地提高了编程开发效率。

#### 事务回滚

默认情况下，如果发生了`RuntimeException`，Spring的声明式事务将自动回滚。在一个事务方法中，如果程序判断需要回滚事务，只需抛出`RuntimeException`。

如果要针对Checked Exception回滚事务，需要在`@Transactional`注解中写出来：

```java
@Transactional(rollbackFor = {RuntimeException.class, IOException.class})
```

上述代码表示在抛出`RuntimeException`或`IOException`时，事务将回滚。

`@Transactional` 注解中定义了以下方法：

- `value()`：用于设置事务管理器的别名，是 `transactionManager()` 方法的别名。
- `transactionManager()`：用于设置事务管理器的限定符值，可以用来确定目标事务管理器，匹配特定的 `PlatformTransactionManager` bean 定义。
- `propagation()`：用于设置事务传播类型，默认为 `Propagation.REQUIRED`。
- `isolation()`：用于设置事务隔离级别，默认为 `Isolation.DEFAULT`。
- `timeout()`：用于设置事务超时时间，单位秒，默认为底层事务系统的默认超时时间。
- `readOnly()`：用于设置事务是否为只读，默认为 `false`。
- **`rollbackFor()`：定义了必须导致事务回滚的异常类，可以是 `Throwable` 的子类。**
- `rollbackForClassName()`：定义了必须导致事务回滚的异常类名，可以是 `Throwable` 的子类的类名。
- `noRollbackFor()`：定义了不应导致事务回滚的异常类，可以是 `Throwable` 的子类。
- `noRollbackForClassName()`：定义了不应导致事务回滚的异常类名，可以是 `Throwable` 的子类的类名。

这些方法用于配置 `@Transactional` 注解的属性，以便在应用程序中定义事务行为。

#### 事务边界

在使用事务的时候，明确事务边界非常重要。对于声明式事务，例如，下面的`register()`方法：

```java
@Component
public class UserService {
    @Transactional
    public User register(String email, String password, String name) { // 事务开始
       ...
    } // 事务结束
}
```

它的事务边界就是`register()`方法开始和结束。

类似的，一个负责给用户增加积分的`addBonus()`方法：

```java
@Component
public class BonusService {
    @Transactional
    public void addBonus(long userId, int bonus) { // 事务开始
       ...
    } // 事务结束
}
```

它的事务边界就是`addBonus()`方法开始和结束。

用户注册后，能自动获得100积分，因此，实际代码如下：

```java
@Component
public class UserService {
    @Autowired
    BonusService bonusService;

    @Transactional
    public User register(String email, String password, String name) {
        // 插入用户记录:
        User user = jdbcTemplate.insert("...");
        // 增加100积分:
        bonusService.addBonus(user.id, 100);
    }
}
```

调用方（比如`RegisterController`）调用`UserService.register()`这个事务方法，该方法在内部又调用了`BonusService.addBonus()`这个事务方法，一共有几个事务？如果`addBonus()`抛出了异常需要回滚事务，`register()`方法的事务是否也要回滚？

#### 事务传播

要解决上面的问题，首先要定义事务的传播模型。

假设用户注册的入口是`RegisterController`，它本身没有事务，仅仅是调用`UserService.register()`这个事务方法：

```java
@Controller
public class RegisterController {
    @Autowired
    UserService userService;

    @PostMapping("/register")
    public ModelAndView doRegister(HttpServletRequest req) {
        String email = req.getParameter("email");
        String password = req.getParameter("password");
        String name = req.getParameter("name");
        User user = userService.register(email, password, name);
        return ...
    }
}
```

因此，`UserService.register()`这个事务方法的起始和结束，就是事务的范围。

需要关心的问题是，在`UserService.register()`这个事务方法内，调用`BonusService.addBonus()`，应该期待的事务行为是什么：

```java
@Transactional
public User register(String email, String password, String name) {
    // 事务已开启:
    User user = jdbcTemplate.insert("...");
    // ???:
    bonusService.addBonus(user.id, 100);
} // 事务结束
```

对于大多数业务来说，`UserService.register()`已经开启了一个事务，那么在内部调用`BonusService.addBonus()`时，`BonusService.addBonus()`方法就没必要再开启一个新事务，直接加入到`BonusService.register()`的事务里就好了。

其实就相当于：

1. `UserService.register()`先执行了一条INSERT语句：`INSERT INTO users ...`
2. `BonusService.addBonus()`再执行一条INSERT语句：`INSERT INTO bonus ...`

------

Spring的声明式事务为事务传播定义了几个级别，默认传播级别就是`REQUIRED`，它的意思是，如果当前**没有**事务，**就创建**一个新事务，如果当前**有**事务，**就加入**到当前事务中执行。

`UserService.register()`方法，它在`RegisterController`中执行，因为`RegisterController`没有事务，因此，`UserService.register()`方法会自动创建一个新事务。

在`UserService.register()`方法内部，调用`BonusService.addBonus()`方法时，因为`BonusService.addBonus()`检测到当前已经有事务了，因此，它会加入到当前事务中执行。

因此，整个业务流程的事务边界就清晰了：它只有一个事务，并且范围就是`UserService.register()`方法。

把`BonusService.addBonus()`方法的`@Transactional`去掉，变成一个普通方法，那不就规避了复杂的传播模型吗？

去掉`BonusService.addBonus()`方法的`@Transactional`，会引来另一个问题，即其他地方如果调用`BonusService.addBonus()`方法，那就没法保证事务了。

------

默认的事务传播级别是`REQUIRED`，它满足绝大部分的需求。还有一些其他的传播级别：

`SUPPORTS`：表示如果**有**事务，**就加入**到当前事务，如果**没有**，那**也不开启**事务执行。这种传播级别可用于查询方法，因为`SELECT`语句既可以在事务内执行，也可以不需要事务；

`MANDATORY`：表示**必须要存在**当前事务**并加入**执行，**否则**将抛出**异常**。这种传播级别可用于核心更新逻辑，比如用户余额变更，它总是被其他事务方法调用，不能直接由非事务方法调用；

`REQUIRES_NEW`：表示**不管**当前**有没有**事务，都**必须开启**一个**新的**事务执行。如果当前已经有事务，那么当前事务会挂起，等新事务完成后，再恢复执行；

`NOT_SUPPORTED`：表示**不支持**事务，如果当前有事务，那么当前事务会挂起，等这个方法执行完成后，再恢复执行；

`NEVER`：和`NOT_SUPPORTED`相比，它不但**不支持**事务，而且在**监测到**当前有事务时，会抛出**异常**拒绝执行；

`NESTED`：表示**如果当前有**事务，则**开启一个嵌套**级别事务，如果当前**没有**事务，则开启一个**新**事务。

上面这么多种事务的传播级别，其实默认的`REQUIRED`已经满足绝大部分需求，`SUPPORTS`和`REQUIRES_NEW`在少数情况下会用到，其他基本不会用到，因为把事务搞得越复杂，不仅逻辑跟着复杂，而且速度也会越慢。

定义事务的传播级别也是写在`@Transactional`注解里的：

```java
@Transactional(propagation = Propagation.REQUIRES_NEW)
```

------

Spring是如何传播事务的？在JDBC中使用事务的时候，是这么个写法：

```java
Connection conn = openConnection();
try {
    // 关闭自动提交:
    conn.setAutoCommit(false);
    // 执行多条SQL语句:
    insert(); update(); delete();
    // 提交事务:
    conn.commit();
} catch (SQLException e) {
    // 回滚事务:
    conn.rollback();
} finally {
    conn.setAutoCommit(true);
    conn.close();
}
```

Spring使用声明式事务，最终也是通过执行JDBC事务来实现功能的，那么，一个事务方法，如何获知当前是否存在事务？

答案是使用`ThreadLocal`。Spring总是把JDBC相关的`Connection`和`TransactionStatus`实例绑定到`ThreadLocal`。如果一个事务方法从`ThreadLocal`未取到事务，那么它会打开一个新的JDBC连接，同时开启一个新的事务，否则，它就直接使用从`ThreadLocal`获取的JDBC连接以及`TransactionStatus`。因此，事务能正确传播的前提是，**方法调用是在一个线程内才行**。如果像下面这样写：

```java
@Transactional
public User register(String email, String password, String name) { // BEGIN TX-A
    User user = jdbcTemplate.insert("...");
    new Thread(() -> {
        // BEGIN TX-B:
        bonusService.addBonus(user.id, 100);
        // END TX-B
    }).start();
} // END TX-A
```

在另一个线程中调用`BonusService.addBonus()`，它根本获取不到当前事务，因此，`UserService.register()`和`BonusService.addBonus()`两个方法，将分别开启两个完全独立的事务。换句话说，**事务只能在当前线程传播，无法跨线程传播。**

如果想实现跨线程传播事务，就要想办法把当前线程绑定到`ThreadLocal`的`Connection`和`TransactionStatus`实例传递给新线程，但实现起来非常复杂，根据异常回滚更加复杂，不推荐自己去实现。

#### 事务隔离级别

隔离级别是指若干个并发的事务之间的隔离程度。`TransactionDefinition` 接口中定义了五个表示隔离级别的常量：

`TransactionDefinition.ISOLATION_DEFAULT`：这是**默认值**，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是`TransactionDefinition.ISOLATION_READ_COMMITTED`。

`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别**不能防止脏读和不可重复读**，因此很少使用该隔离级别。

`TransactionDefinition.ISOLATION_READ_COMMITTED`：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别**可以防止脏读**，这也是大多数情况下的推荐值。

`TransactionDefinition.ISOLATION_REPEATABLE_READ`：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别**可以防止脏读和不可重复读**。

`TransactionDefinition.ISOLATION_SERIALIZABLE`：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别**可以防止脏读、不可重复读以及幻读**。但是这将**严重影响程序的性能**。通常情况下也不会用到该级别。

[具体参见](/2021/09/03/其他/#事务)

### 使用泛型编写通用模板方法

通用模板：

```java
abstract class Base<T>{
    private String table;
    private Class<T> entityClass;
    private RowMapper<T> rowMapper;
    /*在继承该抽象类的具体实现类中生效*/
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public JdbcTemplate getJdbcTemplate() {
        return jdbcTemplate;
    }

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    private Class<T> getParameterizedType() {
        Class<?> cls = getClass();
        while (cls.getSuperclass() != Base.class) {
            cls = cls.getSuperclass();
        }
        Type type = cls.getGenericSuperclass();
        if (type instanceof ParameterizedType) {//判断是否为ParameterizedType，如果是，则表示泛型父类有实际类型参数。
            ParameterizedType pt = (ParameterizedType) type;
            Type[] types = pt.getActualTypeArguments(); // 获取泛型的实际类型参数的数组。
            Type firstType = types[0]; // 获取第一个泛型的实际类型参数
            return (Class<T>) firstType;
        }
        throw new RuntimeException("找不到泛型");
    }
    public Base() {
        // 获取当前的泛型类型:
        this.entityClass = getParameterizedType();
        this.table = this.entityClass.getSimpleName().toLowerCase() + "s";
        this.rowMapper = new BeanPropertyRowMapper<>(entityClass);
    }

    public T getById(long id) {
        return getJdbcTemplate().queryForObject("SELECT * FROM " + table + " WHERE id = ?", this.rowMapper, id);
    }

    public List<T> getAll(int pageIndex) {
        int limit = 100;
        int offset = limit * (pageIndex - 1);
        return getJdbcTemplate().query("SELECT * FROM " + table + " LIMIT ? OFFSET ?",
                new Object[] { limit, offset },
                this.rowMapper);
    }

    public void deleteById(long id) {
        getJdbcTemplate().update("DELETE FROM " + table + " WHERE id = ?", id);
    }
}
```

然后继承即可：

```java
@Component
class UserService extends Base<User> {
    @PostConstruct
    public void init() {
        getJdbcTemplate().update("DROP TABLE IF EXISTS users");
        getJdbcTemplate().update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "UNIQUE (email))");
    }
    public void insertUser(User user){
        // 传入SQL，SQL参数，返回更新的行数:
        if (1 != getJdbcTemplate().update("INSERT INTO users(id,email, password, name) VALUES(?,?,?,?)"
                , user.getId(),user.getEmail(),user.getPassword(), user.getName())) {
            throw new RuntimeException("更新出错");
        }
    }
}
```

其他没有变化的类：

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
    @Bean
    PlatformTransactionManager createTxManager(@Autowired DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

class User{
    long id;
    String email,password,name;
    public User() {}
    public long getId() {return id;}public void setId(long id) {this.id = id;}public String getEmail() {return email;}public void setEmail(String email) {this.email = email;}public String getPassword() {return password;}public void setPassword(String password) {this.password = password;}public String getName() {return name;}public void setName(String name) {this.name = name;}

    public User(long id, String email, String password, String name) {
        this.id = id;
        this.email = email;
        this.password = password;
        this.name = name;
    }
    @Override
    public String toString() {return "User{id=" + id + ", email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + '}'; }
}
```

启动类：

```java
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{

    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService userService = ac.getBean(UserService.class);
        userService.insertUser(new User(1,"1@qq.com", "123456", "小米"));
        userService.insertUser(new User(2,"2@qq.com", "123456", "三星"));
        System.out.println(userService.getAll(1));
        System.out.println(userService.getById(1));
        userService.deleteById(1);
        System.out.println(userService.getAll(1));
    }
}
```

控制台：

```text
[User{id=1, email='1@qq.com', password='123456', name='小米'}, User{id=2, email='2@qq.com', password='123456', name='三星'}]
User{id=1, email='1@qq.com', password='123456', name='小米'}
[User{id=2, email='2@qq.com', password='123456', name='三星'}]
```

### 集成Hibernate

使用`JdbcTemplate`的时候，用得最多的方法就是`List<T> query(String, RowMapper, Object...)`。这个`RowMapper`的作用就是把`ResultSet`的一行记录映射为Java Bean。

这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。

使用`JdbcTemplate`配合`RowMapper`可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如[Hibernate](https://hibernate.org/)。

Hibernate作为ORM框架，可以替代`JdbcTemplate`，但Hibernate仍然需要JDBC驱动，需要引入JDBC驱动、连接池，以及Hibernate本身。在Maven中，需要加入以下依赖项：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/javax.persistence/javax.persistence-api -->
<dependency>
    <groupId>javax.persistence</groupId>
    <artifactId>javax.persistence-api</artifactId>
    <version>2.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core -->
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>5.6.15.Final</version>
</dependency>
<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.4.0</version>
</dependency>
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>4.0.3</version>
</dependency>
```

`jdbc.properties`:

```properties
# 数据库文件名为testdb:
jdbc.url=jdbc:hsqldb:mem:testdb

# Hsqldb默认的用户名是sa，口令是空字符串:
jdbc.username=sa
jdbc.password=
```

在`AppConfig`中，仍然需要引入JDBC配置文件创建`DataSource`，为了启用Hibernate，还要创建一个`LocalSessionFactoryBean`，之后还需要创建`HibernateTransactionManager`作为事务管理器：

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) {
        var props = new Properties();
        props.setProperty("hibernate.hbm2ddl.auto", "update"); // 生产环境不要使用
        props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
        props.setProperty("hibernate.show_sql", "true");
        var sessionFactoryBean = new LocalSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        // 扫描指定的package获取所有entity class:
        sessionFactoryBean.setPackagesToScan("com.aotmd.test");
        sessionFactoryBean.setHibernateProperties(props);
        return sessionFactoryBean;
    }
    @Bean
    PlatformTransactionManager createTxManager(@Autowired SessionFactory sessionFactory) {
        return new HibernateTransactionManager(sessionFactory);
    }
}
```

在Hibernate中，`Session`是封装了一个JDBC `Connection`的实例，而`SessionFactory`是封装了JDBC `DataSource`的实例，即`SessionFactory`持有连接池。

每次需要操作数据库的时候，`SessionFactory`创建一个新的`Session`，相当于从连接池获取到一个新的`Connection`。`SessionFactory`就是Hibernate提供的最核心的一个对象，`LocalSessionFactoryBean`是Spring提供的为了让我们方便创建`SessionFactory`的类。

创建`LocalSessionFactoryBean`的代码，首先用`Properties`持有Hibernate初始化`SessionFactory`时用到的所有设置，常用的设置请参考[Hibernate文档](https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations)，这里只定义了3个设置：

- `hibernate.hbm2ddl.auto=update`：表示在应用启动时自动创建或更新数据库表结构。这在开发和测试环境中非常有用，但在生产环境中应谨慎使用，以避免数据丢失或结构不一致的问题。
- `hibernate.dialect=org.hibernate.dialect.HSQLDialect`：指示Hibernate使用的数据库是HSQLDB。Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL；
- `hibernate.show_sql=true`：让Hibernate打印执行的SQL，这对于调试非常有用，可以方便地看到Hibernate生成的SQL语句是否符合我们的预期。

此外，`setPackagesToScan("com.aotmd.test")` 指示 Hibernate 扫描指定的包，以找到所有映射为数据库表的实体类。

而`HibernateTransactionManager` 是 Spring 提供的一个事务管理器，用于管理 Hibernate 的事务。

#### 将数据库表结构映射为Java对象

```sql
CREATE TABLE user
    id BIGINT NOT NULL AUTO_INCREMENT,
    email VARCHAR(100) NOT NULL,
    password VARCHAR(100) NOT NULL,
    name VARCHAR(100) NOT NULL,
    createdAt BIGINT NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `email` (`email`)
);
```

其中，`id`是自增主键，`email`、`password`、`name`是`VARCHAR`类型，`email`带唯一索引以确保唯一性，`createdAt`存储整型类型的时间戳。用JavaBean表示如下：

```java
public class User {
    private Long id;
    private String email;
    private String password;
    private String name;
    private Long createdAt;

    // getters and setters
    ...
}
```

还需要添加一些注解来告诉Hibernate如何把`User`类映射到表记录：

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }

    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() { ... }

    @Column(nullable = false, length = 100)
    public String getPassword() { ... }

    @Column(nullable = false, length = 100)
    public String getName() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
}
```

如果一个JavaBean被用于映射，就标记一个`@Entity`。默认情况下，映射的表名是`user`，如果实际的表名不同，例如实际表名是`users`，可以追加一个`@Table(name="users")`表示。

每个属性到数据库列的映射用`@Column()`标识，`nullable`指示列是否允许为`NULL`，`updatable`指示该列是否允许被用在`UPDATE`语句，`length`指示`String`类型的列的长度（如果没有指定，默认是`255`）。

主键需要用`@Id`标识，`@GeneratedValue(strategy = GenerationType.IDENTITY)`表示指定主键生成策略为 `IDENTITY`。这种策略依赖于数据库自动生成主键值（通常用于自增列）。

主键`id`定义的类型不是`long`，而是`Long`。是因为Hibernate如果检测到主键为`null`，就**不会**在`INSERT`语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在`INSERT`语句中直接列出。`long`型字段**总是具有默认值`0`**，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。

`createdAt`虽然是整型，但没有使用`long`，而是`Long`，这是因为使用基本类型会导致findByExample查询会添加意外的条件，**作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。**

再定义一个`Book`类：

```java
@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { ... }

    @Column(nullable = false, length = 100)
    public String getTitle() { ... }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { ... }
}
```

它们定义的`id`、`createdAt`属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常会统一使用一种主键生成机制，并添加`createdAt`表示创建时间，`updatedAt`表示修改时间等通用字段。

不必在`User`和`Book`中重复定义这些通用字段，可以把它们提到一个抽象类中：

```java
@MappedSuperclass
abstract class AbstractEntity {
    private Long id;
    private Long createdAt;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { return id; }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { return createdAt; }

    @Transient
    public ZonedDateTime getCreatedDateTime() {
        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setCreatedAt(Long createdAt) {
        this.createdAt = createdAt;
    }

    @PrePersist
    public void preInsert() {
        setCreatedAt(System.currentTimeMillis());
    }
}
```

对于`AbstractEntity`来说，要标注一个`@MappedSuperclass`表示它用于继承。表示这个类是一个 JPA 映射的超类（mapped superclass），不会直接映射到数据库表，但其属性会被继承到子类，并映射到子类所对应的数据库表中。

`@Transient`表示该属性**不需要持久化到数据库**中，即在数据库表中不会有相应的列。返回一个“虚拟”的属性。因为`getCreatedDateTime()`是计算得出的属性，而不是从数据库表读出的值，因此必须要标注`@Transient`，否则Hibernate会尝试从数据库读取名为`createdDateTime`这个不存在的字段从而出错。

`@PrePersist` 的方法，表示将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法，这样就可以自动设置好`createdAt`属性。注意，@PrePersist 是 JPA 规范中提供的，老版本 Hibernate SessionFactory （5.1.0.Final）并不能使用。但是新版本的 HIbernate（大于等于 5.2.17） 是可以使用的。

有了`AbstractEntity`，就可以大幅简化`User`和`Book`：

```java
@Entity
class User extends AbstractEntity{
    private String email;
    private String password;
    private String name;
    public User() {}
    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() {
        return email;
    }
    @Column(nullable = false, length = 100)
    public String getPassword() {
        return password;
    }
    @Column(nullable = false, length = 100)
    public String getName() {
        return name;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

 使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置。类似`User`、`Book`这样的用于ORM的Java Bean，通常称之为Entity Bean。

上面作用于`getter `方法的注解也可以放在字段上，而不仅仅是放在 `getter` 方法上。JPA 允许你在字段级别或属性级别（`getter` 方法）使用注解。选择在字段或 `getter` 方法上放置注解主要取决于你的设计习惯和代码风格。

------

`@Column` 注解用于指定持久化属性或字段在数据库中的映射列。下面是对 `@Column` 注解属性的详细解释：

**`name`**：指定列的名称。默认情况下，列名与属性名相同。

**`unique`**：指定列是否是唯一键。此属性是表级 `UniqueConstraint` 注解的快捷方式，当唯一键约束只对应单列时使用。

**`nullable`**：指定列是否允许 `NULL` 值。示例：`@Column(nullable = false) private String name;`，这将使 `name` 列不允许 `NULL` 值。

**`insertable`**：指定列是否包含在生成的 SQL INSERT 语句中。示例：

```java
@Column(insertable = false) private String readOnlyField;
```

这将使 `readOnlyField` 列在 INSERT 语句中被**忽略**。

**`updatable`**：指定列是否包含在生成的 SQL UPDATE 语句中。

```java
@Column(updatable = false) private String createdAt;
```

这将使 `createdAt` 列在 UPDATE 语句中被**忽略**。

**`columnDefinition`**：指定生成 DDL 时使用的 SQL 片段。默认为推断类型生成的 SQL。示例：

```java
@Column(columnDefinition = "CLOB NOT NULL")
private String description;
```

这将使 `description` 列在生成 DDL 时使用指定的 SQL 片段。`description` 列被定义为 CLOB 类型，并且不允许为空。

**`table`**：指定包含该列的表名。如果未指定，则默认该列在主表中。

**`length`**：指定列的长度。仅适用于字符串类型的列，默认为255。

**`precision`**：指定精确数值（如小数）列的精度。仅适用于精确数值列。示例：

```java
@Column(precision = 12, scale = 2)
private BigDecimal cost;
```

这将使 `cost` 列的精度为 12，小数位数为 2。

**`scale`**：指定精确数值列的小数位数。仅适用于精确数值列。示例：

```java
@Column(precision = 12, scale = 2)
private BigDecimal cost;
```

这将使 `cost` 列的精度为 12，小数位数为 2。

`@Column` 注解提供了详细的配置选项，允许你精确控制持久化属性与数据库列的映射方式。这些配置选项包括列名、唯一性、可空性、是否参与插入和更新、列的 SQL 定义、所在表名、字符串列的长度、数值列的精度和小数位数等。通过合理使用这些属性，你可以确保实体类与数据库表之间的映射符合业务需求。

#### CRUD

如果对`user`表进行增删改查。因为使用了Hibernate，因此，实际上是对`User`这个JavaBean进行“增删改查”。编写一个`UserService`，注入`SessionFactory`：

```java
@Component
@Transactional
public class UserService {
    @Autowired
    SessionFactory sessionFactory;
}
```

Hibernate 中大多数的数据修改操作（如插入、更新、删除）都需要在事务中执行。这是因为事务能够确保数据的一致性、隔离性、持久性和原子性，保证了数据库操作的可靠性和完整性。

在 Hibernate 中，如果没有启用事务，对于一些修改操作（如更新数据库记录），虽然可以正常执行，但实际上并不会立即将操作同步到数据库中。相反，它们将缓存在 Hibernate 的会话（Session）中，直到会话被关闭或事务被提交时才会同步到数据库中。如果没有事务管理，这可能导致数据不一致或丢失。

因此，当使用 Hibernate 时，强烈建议在数据修改操作中使用事务来确保数据的完整性和一致性。在 Spring 中，可以使用 `@Transactional` 注解轻松地管理事务，确保在方法执行期间自动开启、提交或回滚事务。

要启用事务，注意：配置事务管理器、启用事务注解`@EnableTransactionManagement`、使用`@Transactional`。

**Insert操作**

要持久化一个`User`实例，只需调用`persist()`方法。以`register()`方法为例，代码如下：

```java
public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);
    // 不要设置id，因为使用了自增主键
    // 保存到数据库:
    sessionFactory.getCurrentSession().persist(user);
    // 现在已经自动获得了id:
    System.out.println(user.getId());
    return user;
}
```

**Delete操作**

删除一个`User`相当于从表中删除对应的记录。注意Hibernate总是用`id`来删除记录，因此，要正确设置`User`的`id`属性才能正常删除记录：

```java
public boolean deleteUser(Long id) {
    User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
    if (user != null) {
        sessionFactory.getCurrentSession().remove(user);
        return true;
    }
    return false;
}
```

通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。注意到当记录不存在时，`load()`返回`null`。

**Update操作**

更新记录相当于先更新`User`的指定属性，然后调用`merge()`方法：

```java
public void updateUser(Long id, String name) {
    User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
    user.setName(name);
    sessionFactory.getCurrentSession().merge(user);
}
```

在定义`User`时，对有的属性标注了`@Column(updatable=false)`。Hibernate在更新记录时，它只会把`@Column(updatable=true)`的属性加入到`UPDATE`语句中，这样可以提供一层额外的安全性，即如果不小心修改了`User`的`email`、`createdAt`等属性，执行`update()`时并不会更新对应的数据库列。

**Select操作**

编写的大部分方法都是各种各样的查询。根据`id`查询可以直接调用`load()`，如果要使用条件查询，例如，假设想执行以下查询：

```sql
SELECT * FROM user WHERE email = ? AND password = ?
```

一种常用的查询是直接编写Hibernate内置的HQL查询：

```java
public List<User> selectByEmailAndByPassword(String email, String password){
    List<User> list = sessionFactory.getCurrentSession()
            .createQuery("from User u where u.email = ?1 and u.password = ?2", User.class)
            .setParameter(1, email).setParameter(2, password)
            .list();
    return list;
}
```

和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考[Hibernate文档](https://docs.jboss.org/hibernate/orm/6.1/userguide/html_single/Hibernate_User_Guide.html#query-language)。

除了可以直接传入HQL字符串外，Hibernate还可以使用一种`NamedQuery`，它给查询起个名字，然后保存在注解中。使用`NamedQuery`时，要先在`User`类标注，`NamedQueries` 注释可以应用于实体或映射的超类：

```java
@NamedQueries(
    @NamedQuery(
        // 查询名称:
        name = "login",
        // 查询语句:
        query = "SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd"
    )
)
@Entity
public class User extends AbstractEntity {
    ...
}
```

它和直接传入HQL有点不同的是，占位符使用`:e`和`:pwd`。使用`NamedQuery`只需要引入查询名和参数：

```java
public User login(String email, String password) {
    List<User> list = sessionFactory.getCurrentSession()
        .createNamedQuery("login", User.class) // 创建NamedQuery
        .setParameter("e", email) // 绑定e参数
        .setParameter("pwd", password) // 绑定pwd参数
        .list();
    return list.isEmpty() ? null : list.get(0);
}
```

直接写HQL和使用`NamedQuery`各有优劣。前者可以在代码中直观地看到查询语句，后者可以在`User`类统一管理所有相关查询。

要写多个`@NamedQuery`，可以用`{}`包起来，如：

```java
@NamedQueries({
        @NamedQuery(
            // 查询名称:
            name = "login",
            // 查询语句:
            query = "SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd"
        ),
        @NamedQuery(
            // 查询名称:
            name = "selectByID",
            // 查询语句:
            query = "SELECT u FROM User u WHERE u.id = :id"
        ),
    }
)
```

------

编程式事务，原：

```java
@Transactional
public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);
    // 不要设置id，因为使用了自增主键
    // 保存到数据库:
    sessionFactory.getCurrentSession().persist(user);
    // 现在已经自动获得了id:
    System.out.println(user.getId());
    return user;
}
```

修改后：

```java
public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);

    Transaction transaction = null;
    try (Session session = sessionFactory.openSession()) {
        transaction = session.beginTransaction();
        // 保存到数据库:
        session.persist(user);
        transaction.commit();
        // 现在已经自动获得了id:
        System.out.println(user.getId());
    } catch (Exception e) {
        if (transaction != null) {
            transaction.rollback();
        }
        e.printStackTrace();
    }
    return user;
}
```

查询可以不用事务：

```java
public List<User> selectByEmailAndByPassword(String email, String password){
    List<User> list = sessionFactory.openSession()
        .createQuery("from User u where u.email = ?1 and u.password = ?2", User.class)
        .setParameter(1, email).setParameter(2, password)
        .list();
    return list;
}
```

完整实例：

```java
package com.aotmd.test;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;
import org.springframework.orm.hibernate5.HibernateTransactionManager;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.Transactional;

import javax.persistence.*;
import javax.sql.DataSource;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Properties;


@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService service = ac.getBean(UserService.class);
        service.register("1@qq.com","123456","小米");
        service.register("2@qq.com","123456","小明");
        List<User> list = service.selectByEmailAndByPassword("1@qq.com", "123456");
        System.out.println(list);
        List<User> list2 = service.selectByEmailAndByPassword2("2@qq.com", "123456");
        System.out.println(list2);
        service.deleteUser(1L);
        List<User> list3 = service.selectByEmailAndByPassword("1@qq.com", "123456");
        System.out.println(list3);
        service.updateUser(2L,"小华");
        List<User> list4 = service.selectByEmailAndByPassword("2@qq.com", "123456");
        System.out.println(list4);
    }
}
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    LocalSessionFactoryBean createSessionFactory(@Autowired DataSource dataSource) {
        var props = new Properties();
        props.setProperty("hibernate.hbm2ddl.auto", "update"); // 生产环境不要使用
        props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
        props.setProperty("hibernate.show_sql", "true");
        var sessionFactoryBean = new LocalSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource);
        // 扫描指定的package获取所有entity class:
        sessionFactoryBean.setPackagesToScan("com.aotmd.test");
        sessionFactoryBean.setHibernateProperties(props);
        return sessionFactoryBean;
    }
    @Bean
    PlatformTransactionManager createTxManager(@Autowired SessionFactory sessionFactory) {
        return new HibernateTransactionManager(sessionFactory);
    }
}



@MappedSuperclass
abstract class AbstractEntity {
    private Long id;
    private Long createdAt;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { return id; }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { return createdAt; }

    @Transient
    public ZonedDateTime getCreatedDateTime() {
        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setCreatedAt(Long createdAt) {
        this.createdAt = createdAt;
    }

    @PrePersist
    public void preInsert() {
        setCreatedAt(System.currentTimeMillis());
    }
}

@NamedQueries({
        @NamedQuery(
                // 查询名称:
                name = "login",
                // 查询语句:
                query = "SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd"
        ),
        @NamedQuery(
                // 查询名称:
                name = "selectByID",
                // 查询语句:
                query = "SELECT u FROM User u WHERE u.id = :id"
        ),
    }
)
@Entity
class User extends AbstractEntity{
    private String email;
    private String password;
    private String name;
    public User() {}
    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() {
        return email;
    }
    @Column(nullable = false, length = 100)
    public String getPassword() {
        return password;
    }
    @Column(nullable = false, length = 100)
    public String getName() {
        return name;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {return "User{email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + '}'; }
}

@Component
class UserService {
    @Autowired
    SessionFactory sessionFactory;

    public User register(String email, String password, String name) {
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);

        Transaction transaction = null;
        try (Session session = sessionFactory.openSession()) {
            transaction = session.beginTransaction();
            // 保存到数据库:
            session.persist(user);
            transaction.commit();
            // 现在已经自动获得了id:
            System.out.println(user.getId());
        } catch (Exception e) {
            if (transaction != null) {
                transaction.rollback();
            }
            e.printStackTrace();
        }
        return user;
    }
    @Transactional
    public boolean deleteUser(Long id) {
        User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
        if (user != null) {
            sessionFactory.getCurrentSession().remove(user);
            return true;
        }
        return false;
    }
    @Transactional
    public void updateUser(Long id, String name) {
        User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
        user.setName(name);
        sessionFactory.getCurrentSession().merge(user);
    }

    public List<User> selectByEmailAndByPassword(String email, String password){
        List<User> list = sessionFactory.openSession()
                .createQuery("from User u where u.email = ?1 and u.password = ?2", User.class)
                .setParameter(1, email).setParameter(2, password)
                .list();
        return list;
    }
    @Transactional
    public List<User> selectByEmailAndByPassword2(String email, String password){
        List<User> list = sessionFactory.getCurrentSession()
                .createNamedQuery("login", User.class) // 创建NamedQuery
                .setParameter("e", email) // 绑定e参数
                .setParameter("pwd", password) // 绑定pwd参数
                .list();
        return list;
    }
}
```

------

#### 参数详细解释

`sessionFactory.getCurrentSession()` 是 Hibernate 中的一个方法，用于获取当前线程关联的 `Session` 对象。在 Hibernate 中，`Session` 对象代表了与数据库的一次会话，它提供了对持久化对象的管理和数据库操作的支持。

通常情况下，通过 `sessionFactory.openSession()` 方法来获取一个新的 `Session` 对象。这种方式每次调用都会创建一个新的 `Session` 对象。然而，在某些情况下，尤其是在使用基于线程的事务管理器（如 `ThreadLocalSessionContext`）时，可能希望获取当前线程关联的 `Session` 对象，以确保所有的数据库操作都在同一个会话中执行。这时就可以使用 `sessionFactory.getCurrentSession()` 方法。

使用 `getCurrentSession()` 方法时，Hibernate 会检查当前线程是否已经存在与之关联的 `Session` 对象。如果存在，则返回该 `Session` 对象；如果不存在，则根据配置创建一个新的 `Session` 对象，并将其与当前线程关联起来。通过这种方式，确保在同一个线程内的所有数据库操作都使用同一个 `Session` 对象，从而避免线程安全问题和多个 `Session` 实例之间的数据不一致性。

需要注意的是，使用 `getCurrentSession()` 方法时，需要在 Hibernate 的配置文件（如 `hibernate.cfg.xml`）中配置 `hibernate.current_session_context_class` 参数，指定使用的线程上下文（如 `thread`、`jta` 等），以告诉 Hibernate 如何管理当前会话。

以下是 `SessionFactory` 接口中一些常用的方法：

**`openSession()`**：打开一个新的会话（`Session`），每次调用都会创建一个新的 `Session` 实例。

**`getCurrentSession()`**：获取当前线程关联的会话（`Session`），如果没有与当前线程关联的会话，则根据配置创建一个新的会话。需要注意，使用该方法时需要在 Hibernate 的配置文件中配置 `hibernate.current_session_context_class` 参数。

**`openStatelessSession()`**：打开一个新的无状态会话（`StatelessSession`），无状态会话不会缓存任何持久化对象的状态信息。

**`close()`**：关闭 `SessionFactory`，释放资源。

------

**Session**

`Session` 是 Hibernate 中用于与数据库进行交互的核心接口，它提供了许多方法来执行数据库操作、管理持久化对象和控制事务等。以下是 `Session` 接口中一些常用的方法：

**`save(Object entity)`**：保存或更新给定的实体对象到数据库中。如果对象是新创建的，则插入数据；如果对象已经存在于数据库中，则更新数据。

**`persist(Object entity)`**：将给定的实体对象持久化到数据库中。与 `save()` 方法类似，但 `persist()` 方法不返回持久化对象的标识符，也不会立即执行 INSERT 操作。

**`update(Object entity)`**：更新给定的实体对象到数据库中，不返回任何值。

**`merge(Object entity)`** ：是 Hibernate 中用于将游离状态（detached）的实体对象合并到持久化状态（persistent）的方法之一。它的作用是将传入的实体对象的状态与数据库中的对应实体对象的状态进行合并，并返回持久化状态的实体对象。如果数据库中**不存在**对应的实体对象，则会**创建一个新的实体对象**，并将传入的实体对象的状态复制到新创建的实体对象上，对该副本的**任何更改将在数据库中反映出来**。

**`delete(Object entity)`**：从数据库中删除给定的实体对象。

**`get(Class clazz, Serializable id)`**：根据实体类和主键获取对象。如果对象不存在，则返回 null。

**`byId(Class<T> entityClass)`** ：该方法返回一个 `IdentifierLoadAccess<T>` 实例，用于通过主键检索指定的实体类型，`entityClass`：要检索的实体类型的 `Class` 对象，配合`T load(Serializable id)`得到类似下面的`load(Class clazz, Serializable id)`的效果。

**`load(Class clazz, Serializable id)`**：根据实体类和主键获取对象。如果对象不存在，则抛出异常。

**`createQuery(String hql)`**：创建一个查询对象，用于执行 HQL（Hibernate Query Language）查询。

```java
Query query = session.createQuery(hql);
```

**`createSQLQuery(String sql)`**：创建一个原生 SQL 查询对象，用于执行 SQL 查询。

```java
SQLQuery sqlQuery = session.createSQLQuery(sql);
```

**`beginTransaction()`**：开启一个新的事务。

**`close()`**：关闭当前会话，释放资源。

这些是 `Session` 接口中的一些常用方法，可以根据具体需求选择使用。在实际开发中，通常会使用这些方法来执行数据库操作、管理持久化对象和控制事务等。

------

**Transaction**

在 Hibernate 中，事务管理通常是通过 `Transaction` 接口来完成的。`Transaction` 接口提供了开始、提交、回滚等操作，用于管理数据库事务。以下是 `Transaction` 接口中一些常用的方法：

**`begin()`**：开启一个新的事务。

```java
Transaction tx = session.beginTransaction();
```

**`commit()`**：提交当前事务，将事务中的修改保存到数据库。

**`rollback()`**：回滚当前事务，撤销事务中的修改。

**`isActive()`**：检查事务是否处于活动状态（即已经开始但尚未提交或回滚）。

**`setTimeout(int seconds)`**：设置事务的超时时间，单位为秒。

**`getStatus()`**：获取事务的状态，返回一个枚举值表示事务的状态（如活动、已提交、已回滚等）。

```java
TransactionStatus status = tx.getStatus();
```

这些方法可以在代码中方便地管理事务的生命周期，确保数据库操作的一致性和可靠性。通常情况下，会通过调用 `beginTransaction()` 开启一个新的事务，然后执行数据库操作，最后通过调用 `commit()` 提交事务或 `rollback()` 回滚事务。

------

**Query**

`org.hibernate.query.Query` 接口继承了 `TypedQuery<R>`, `org.hibernate.Query<R>`, 和 `CommonQueryContract` 接口，并提供了一系列用于执行查询操作的方法。以下是一些常用方法：

- **`setParameter(String name, Object value)`**:为查询设置命名参数和对应的值。
- **`setParameter(int position, Object value)`**:为查询设置位置参数和对应的值。
- **`setParameter(String name, Object value, TemporalType temporalType)`**:为查询设置命名参数和对应的值，并指定参数类型为日期时间。
- **`setParameter(int position, Object value, TemporalType temporalType)`**:为查询设置位置参数和对应的值，并指定参数类型为日期时间。
- **`setFirstResult(int startPosition)`**:设置结果集的起始位置。
- **`setMaxResults(int maxResult)`**:设置返回结果的最大数量。
- **`getResultList()`**:执行查询并返回查询结果列表。
- **`getSingleResult()`**:执行查询并返回单个结果。如果结果不唯一或查询结果为空，则抛出异常。
- **`list()`**:与 `getResultList()` 方法功能相同，也是执行查询并返回结果列表。
- **`uniqueResult()`**:与 `getSingleResult()` 方法功能相同，也是执行查询并返回单个结果。
- **`setParameterList(String name, Collection values)`**:为查询设置命名参数和对应的值列表。
- **`setParameterList(String name, Object[] values)`**:为查询设置命名参数和对应的值数组。
- **`setParameterList(int position, Collection values)`**:为查询设置位置参数和对应的值列表。
- **`setParameterList(int position, Object[] values)`**:为查询设置位置参数和对应的值数组。
- **`setFlushMode(FlushModeType flushMode)`**:设置查询的刷新模式。
- **`setReadOnly(boolean readOnly)`**:设置查询是否为只读。
- **`unwrap(Class<T> type)`**:将查询对象转换为指定类型的对象。

这些方法覆盖了常用的查询操作，可以根据具体的需求选择使用。

------

**扩展：**

如果需要将多个实体类映射到数据库，而这多个实体类继承自同一个抽象类或者接口，而查询或者别的操作又需要使用这种多态性，可以参考[这篇文章](https://thorben-janssen.com/complete-guide-inheritance-strategies-jpa-hibernate/)。

如果实体类中有一个字段是一个集合，可以参考[这篇文章](https://thorben-janssen.com/ultimate-guide-association-mappings-jpa-hibernate/)。里面讨论了一对一、一对多、多对多、多对一等各种情况。

使用Hibernate时，有时候希望在一个实体中嵌入另一个对象，比如在一个人员实体中嵌入地址对象。这时，可以使用`@Embeddable`和`@Embedded`注解来实现。

首先，定义一个嵌入式组件，比如地址对象：

```java
import javax.persistence.Embeddable;

@Embeddable
public class Address {
    private String street;
    private String city;
    private String country;

    // 构造函数、getter和setter方法
}
```

这里，`Address`被标记为`@Embeddable`，表示它是一个值对象，可以被嵌入到其他实体中。

接下来，定义`Person`实体：

```java
import javax.persistence.*;

@Entity
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @Embedded
    private Address address;

    // 构造函数、getter和setter方法
}
```

这个类对应的表结构为：

```sql
CREATE TABLE Person (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    address_street VARCHAR(255),
    address_city VARCHAR(255),
    address_country VARCHAR(255)
);
```

在这里，在`address`字段上使用了`@Embedded`注解，表示它是一个嵌入式组件。

现在，当你持久化一个`Person`实体时，Hibernate会自动持久化嵌入的`Address`对象。以下是一个示例用法：

```java
// 创建一个新的Person，并设置地址信息
Person person = new Person();
person.setName("张三");

Address address = new Address();
address.setStreet("长江路123号");
address.setCity("上海");
address.setCountry("中国");

person.setAddress(address);

entityManager.persist(person);
```

这将同时持久化`Person`和其嵌入的`Address`对象到数据库中。

注意，`Address`对象中的每个属性都被映射到了`Person`表中的相应字段，且字段名遵循了默认的命名规则：`address_` + `属性名`。这是因为嵌入式组件在数据库中被表示为`Person`表的一部分，而不是单独的表。

如果要重新命名，可以这样写：

```java
import javax.persistence.Column;
import javax.persistence.Embeddable;

@Embeddable
public class Address {
    @Column(name = "street")
    private String street;
    
    @Column(name = "city")
    private String city;
    
    @Column(name = "country")
    private String country;

    // 构造函数、getter和setter方法
}

```

这样，`Person`类对应的表结构如下所示：

```sql
CREATE TABLE Person (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255),
    street VARCHAR(255),
    city VARCHAR(255),
    country VARCHAR(255)
);
```

在这个表结构中：

- `id`、`name`字段与`Person`类中的属性对应，无变化。
- `street`、`city`、`country`字段对应于`Address`对象中的属性，通过`@Column`注解指定了列名。这些字段直接位于`Person`表中，而不是`Address`表，因为`Address`对象是嵌入式的，不是单独的实体。

[详细参考](https://memorynotfound.com/hibernate-embeddable-embedded-annotation-example/)。



#### JPA

JPA：Java Persistence API，JPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，那么引用的就是`javax.persistence`这个“标准”包，而不是`org.hibernate`这样的第三方包。因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理。

使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如[EclipseLink](https://www.eclipse.org/eclipselink/)。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。若要以Hibernate作为JPA实现，则和使用Hibernate一样，只需要引入同样的依赖。Hibernate既提供了它自己的接口，也提供了JPA接口，用JPA接口就相当于通过JPA操作Hibernate。

使用Hibernate时，需要创建一个`LocalSessionFactoryBean`，并让它再自动创建一个`SessionFactory`。使用JPA也是类似的，也创建一个`LocalContainerEntityManagerFactoryBean`，并让它再自动创建一个`EntityManagerFactory`。

```java
@Bean
public LocalContainerEntityManagerFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) {
    var emFactory = new LocalContainerEntityManagerFactoryBean();
    // 注入DataSource:
    emFactory.setDataSource(dataSource);
    // 扫描指定的package获取所有entity class:
    emFactory.setPackagesToScan(AbstractEntity.class.getPackageName());
    // 使用Hibernate作为JPA实现:
    emFactory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
    // 其他配置项:
    var props = new Properties();
    props.setProperty("hibernate.hbm2ddl.auto", "update"); // 生产环境不要使用
    props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
    props.setProperty("hibernate.show_sql", "true");
    emFactory.setJpaProperties(props);
    return emFactory;
}
```

除了需要注入`DataSource`和设定自动扫描的`package`外，还需要指定JPA的提供商，这里使用Spring提供的一个`HibernateJpaVendorAdapter`，最后，针对Hibernate自己需要的配置，以`Properties`的形式注入。

还需要实例化一个`JpaTransactionManager`，以实现声明式事务：

```java
@Bean
PlatformTransactionManager createTxManager(@Autowired EntityManagerFactory entityManagerFactory) {
    return new JpaTransactionManager(entityManagerFactory);
}
```

这样，就完成了JPA的全部初始化工作。使用Spring+Hibernate作为JPA实现，无需任何配置文件。

所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。现在只需关心具体的业务类如何通过JPA接口操作数据库。

还是以`UserService`为例，需要注入一个`EntityManager`，但是不要使用`@Autowired`，而是`@PersistenceContext`：

```java
@Component
class UserService {
    @PersistenceContext
    EntityManager em;
    ...
}
```

JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：

| JDBC       | Hibernate      | JPA                  |
| :--------- | :------------- | :------------------- |
| DataSource | SessionFactory | EntityManagerFactory |
| Connection | Session        | EntityManager        |

`SessionFactory`和`EntityManagerFactory`相当于`DataSource`，`Session`和`EntityManager`相当于`Connection`。每次需要访问数据库的时候，需要获取新的`Session`和`EntityManager`，用完后再关闭。

`UserService`注入的不是`EntityManagerFactory`，而是`EntityManager`，并且标注了`@PersistenceContext`。难道使用JPA可以允许多线程操作同一个`EntityManager`？

实际上这里注入的并不是真正的`EntityManager`，而是一个`EntityManager`的代理类，相当于：

```java
public class EntityManagerProxy implements EntityManager {
    private EntityManagerFactory emf;
}
```

Spring遇到标注了`@PersistenceContext`的`EntityManager`会自动注入代理，该代理会在必要的时候自动打开`EntityManager`。换句话说，多线程引用的`EntityManager`虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的`EntityManager`实例。

因此，标注了`@PersistenceContext`的`EntityManager`可以被多线程安全地共享。

因此，在`UserService`的每个业务方法里，直接使用`EntityManager`就很方便。以主键查询为例：

```java
User user = this.em.find(User.class, id);
```

对比Hibernate：

```java
User user = sessionFactory.getCurrentSession().byId(User.class).load(id);
```

与HQL查询类似，JPA使用JPQL查询，它的语法和HQL基本差不多：

```java
public List<User> selectByEmailAndByPassword(String email, String password){
    List<User> list = em
            .createQuery("SELECT u from User u where u.email = :e and u.password = :p", User.class)
            .setParameter("e", email).setParameter("p", password)
            .getResultList();
    return list;
}
```

对比Hibernate，不同点在于：不需要`getCurrentSession()`，占位符名称不同，`list()`变为`getResultList()`。

同样的，JPA也支持`NamedQuery`，即先给查询起个名字，再按名字创建查询：

```java
@Transactional
public List<User> selectByEmailAndByPassword2(String email, String password){
    List<User> list = em
            .createNamedQuery("login", User.class) // 创建NamedQuery
            .setParameter("e", email) // 绑定e参数
            .setParameter("pwd", password) // 绑定pwd参数
            .getResultList();
    return list;
}
```

`NamedQuery`通过注解标注在`User`类上，它的定义和上一节的`User`类一样：

```java
@NamedQueries(
    @NamedQuery(
        // 查询名称:
        name = "login",
        // 查询语句:
        query = "SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd"
    )
)
@Entity
public class User extends AbstractEntity {
    ...
}
```

对比Hibernate，不同点在于：不需要`getCurrentSession()`，`list()`变为`getResultList()`。

对数据库进行增删改的操作，可以分别使用`persist()`、`remove()`和`merge()`方法，参数均为Entity Bean本身，使用非常简单，基本上都是去掉`getCurrentSession()`就行。

实际上，`EntityManager`接口和Hibernate的`Session`接口在方法上有很多重叠之处，因为`EntityManager`接口是JPA的一部分，而Hibernate**实现**了JPA规范。即：

```java
public interface Session extends SharedSessionContract, EntityManager, HibernateEntityManager, AutoCloseable, Closeable {}
```

一些常见的方法，无论是在`EntityManager`接口还是Hibernate的`Session`接口中都可以找到，包括`persist()`、`merge()`、`refresh()`、`find()`、`remove()`等。这些方法在JPA规范中定义，并且Hibernate作为JPA的实现，也提供了相应的实现。

对于之前提到的编程式事务：

```java
public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);

    Transaction transaction = null;
    try (Session session = sessionFactory.openSession()) {
        transaction = session.beginTransaction();
        // 保存到数据库:
        session.persist(user);
        transaction.commit();
        // 现在已经自动获得了id:
        System.out.println(user.getId());
    } catch (Exception e) {
        if (transaction != null) {
            transaction.rollback();
        }
        e.printStackTrace();
    }
    return user;
}
```

改写一下：

```java
public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);

    EntityTransaction transaction = null;
    try  {
        transaction = em.getTransaction();
        // 保存到数据库:
        em.persist(user);
        transaction.commit();
        // 现在已经自动获得了id:
        System.out.println(user.getId());
    } catch (Exception e) {
        if (transaction != null) {
            transaction.rollback();
        }
        e.printStackTrace();
    }
    return user;
}
```

运行后会报错：不允许在共享 `EntityManager` 上创建事务 - 改用 Spring 事务或 EJB CMT。

改为Spring事务：

```java
@Autowired
private  PlatformTransactionManager transactionManager;

public User register(String email, String password, String name) {
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user.setName(name);

    TransactionDefinition def = new DefaultTransactionDefinition();
    TransactionStatus status = transactionManager.getTransaction(def);
    try  {
        // 保存到数据库:
        em.persist(user);
        transactionManager.commit(status);
        // 现在已经自动获得了id:
        System.out.println(user.getId());
    } catch (Exception e) {
        transactionManager.rollback(status);
        e.printStackTrace();
    }
    return user;
}
```

正常。

完整实例：

```java
package com.aotmd.test;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.DefaultTransactionDefinition;

import javax.persistence.*;
import javax.sql.DataSource;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.List;
import java.util.Properties;

@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService service = ac.getBean(UserService.class);
        service.register("1@qq.com","123456","小米");
        service.register("2@qq.com","123456","小明");
        List<User> list = service.selectByEmailAndByPassword("1@qq.com", "123456");
        System.out.println(list);
        List<User> list2 = service.selectByEmailAndByPassword2("2@qq.com", "123456");
        System.out.println(list2);
        service.deleteUser(1L);
        List<User> list3 = service.selectByEmailAndByPassword("1@qq.com", "123456");
        System.out.println(list3);
        service.updateUser(2L,"小华");
        List<User> list4 = service.selectByEmailAndByPassword("2@qq.com", "123456");
        System.out.println(list4);
    }
}
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    public LocalContainerEntityManagerFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) {
        var emFactory = new LocalContainerEntityManagerFactoryBean();
        // 注入DataSource:
        emFactory.setDataSource(dataSource);
        // 扫描指定的package获取所有entity class:
        emFactory.setPackagesToScan(AbstractEntity.class.getPackageName());
        // 使用Hibernate作为JPA实现:
        emFactory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        // 其他配置项:
        var props = new Properties();
        props.setProperty("hibernate.hbm2ddl.auto", "update"); // 生产环境不要使用
        props.setProperty("hibernate.dialect", "org.hibernate.dialect.HSQLDialect");
        props.setProperty("hibernate.show_sql", "true");
        emFactory.setJpaProperties(props);
        return emFactory;
    }
    @Bean
    PlatformTransactionManager createTxManager(@Autowired EntityManagerFactory entityManagerFactory) {
        return new JpaTransactionManager(entityManagerFactory);
    }
}

@MappedSuperclass
abstract class AbstractEntity {
    private Long id;
    private Long createdAt;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(nullable = false, updatable = false)
    public Long getId() { return id; }

    @Column(nullable = false, updatable = false)
    public Long getCreatedAt() { return createdAt; }

    @Transient
    public ZonedDateTime getCreatedDateTime() {
        return Instant.ofEpochMilli(this.createdAt).atZone(ZoneId.systemDefault());
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setCreatedAt(Long createdAt) {
        this.createdAt = createdAt;
    }

    @PrePersist
    public void preInsert() {
        setCreatedAt(System.currentTimeMillis());
    }
}

@NamedQueries({
        @NamedQuery(
                // 查询名称:
                name = "login",
                // 查询语句:
                query = "SELECT u FROM User u WHERE u.email = :e AND u.password = :pwd"
        ),
        @NamedQuery(
                // 查询名称:
                name = "selectByID",
                // 查询语句:
                query = "SELECT u FROM User u WHERE u.id = :id"
        ),
    }
)
@Entity
class User extends AbstractEntity{
    private String email;
    private String password;
    private String name;
    public User() {}
    @Column(nullable = false, unique = true, length = 100)
    public String getEmail() {
        return email;
    }
    @Column(nullable = false, length = 100)
    public String getPassword() {
        return password;
    }
    @Column(nullable = false, length = 100)
    public String getName() {
        return name;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {return "User{email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + '}'; }
}

@Component
class UserService {
    @PersistenceContext
    EntityManager em;
    @Autowired
    private  PlatformTransactionManager transactionManager;

    public User register(String email, String password, String name) {
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);

        TransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = transactionManager.getTransaction(def);
        try  {
            // 保存到数据库:
            em.persist(user);
            transactionManager.commit(status);
            // 现在已经自动获得了id:
            System.out.println(user.getId());
        } catch (Exception e) {
            transactionManager.rollback(status);
            e.printStackTrace();
        }
        return user;
    }
    @Transactional
    public boolean deleteUser(Long id) {
        User user = em.find(User.class,id);
        if (user != null) {
            em.remove(user);
            return true;
        }
        return false;
    }
    @Transactional
    public void updateUser(Long id, String name) {
        User user = em.find(User.class,id);
        user.setName(name);
        em.merge(user);
    }

    public List<User> selectByEmailAndByPassword(String email, String password){
        List<User> list = em
                .createQuery("SELECT u from User u where u.email = :e and u.password = :p", User.class)
                .setParameter("e", email).setParameter("p", password)
                .getResultList();
        return list;
    }
    @Transactional
    public List<User> selectByEmailAndByPassword2(String email, String password){
        List<User> list = em
                .createNamedQuery("login", User.class) // 创建NamedQuery
                .setParameter("e", email) // 绑定e参数
                .setParameter("pwd", password) // 绑定pwd参数
                .getResultList();
        return list;
    }
}
```

### 集成MyBatis

使用Hibernate或JPA操作数据库时，这类ORM主要工作就是把`ResultSet`的每一行变成Java Bean，或者把Java Bean自动转换到`INSERT`或`UPDATE`语句的参数中，从而实现ORM。ORM框架之所以知道如何把行数据映射到Java Bean，是因为在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。

ORM框架使用代理模式跟踪Java Bean的修改，以便在`update()`操作中更新必要的属性。从ORM框架读取的`User`实例实际上并不是`User`类，而是代理类，代理类继承自`User`类，但针对每个`setter`方法做了覆写，例如：

```java
public class UserProxy extends User {
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }
}
```

这样，代理类可以跟踪到每个属性的变化。

针对一对多或多对一关系时，代理类可以直接通过`getter`方法查询数据库：

```java
public class UserProxy extends User {
    Session _session;
    boolean _isNameChanged;

    public void setName(String name) {
        super.setName(name);
        _isNameChanged = true;
    }

    /**
     * 获取User对象关联的Address对象:
     */
    public Address getAddress() {
        Query q = _session.createQuery("from Address where userId = :userId");
        q.setParameter("userId", this.getId());
        List<Address> list = query.list();
        return list.isEmpty() ? null : list(0);
    }
}
```

为了实现这样的查询，`UserProxy`必须保存Hibernate的当前`Session`。但是，当事务提交后，`Session`自动关闭，此时再获取`getAddress()`将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached/Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的`PersistentObjectException`异常。这种隐式状态使得普通Java Bean的生命周期变得复杂。

此外，Hibernate和JPA为了实现兼容多种数据库，使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦。

最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：

```java
User user1 = session.load(User.class, 123);
User user2 = session.load(User.class, 123);
```

二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：

```java
// 线程1读取:
User user1 = session1.load(User.class, 123);
...
// 一段时间后，线程2读取:
User user2 = session2.load(User.class, 123);
```

当二级缓存生效的时候，两个线程读取的`User`实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：

```sql
-- 给老用户增加100积分:
UPDATE users SET bonus = bonus + 100 WHERE createdAt <= ?
```

ORM无法判断`id=123`的用户是否受该`UPDATE`语句影响。考虑到数据库通常会支持多个应用程序，此`UPDATE`语句可能由其他进程执行，ORM框架就更不知道了。

这种ORM框架称之为全自动ORM框架。

对比Spring提供的`JdbcTemplate`，它和ORM框架相比，主要有几点差别：

- 查询后需要手动提供`Mapper`实例以便把`ResultSet`的每一行变为Java对象；
- 增删改操作所需的参数列表，需要手动传入，即把`User`实例变为`[user.id, user.name, user.email]`这样的列表，比较麻烦。

但是`JdbcTemplate`的优势在于它的确定性：即每次读取操作**一定是数据库操作而不是缓存**，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造`INSERT INTO users VALUES (?,?,?)`更是复杂。

所以，介于全自动ORM如Hibernate和手写全部如`JdbcTemplate`之间，还有一种半自动的ORM，它只负责把`ResultSet`自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。[MyBatis](https://mybatis.org/)就是这样一种半自动化ORM框架。

#### 引入Mybatis

首先，要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，需要再引入MyBatis官方自己开发的一个与Spring集成的库：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
<dependency>
    <groupId>org.hsqldb</groupId>
    <artifactId>hsqldb</artifactId>
    <version>2.4.0</version>
</dependency>
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>4.0.3</version>
</dependency>
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.3.0</version>
</dependency>
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>3.0.0</version>
</dependency>
```

和前面一样，先创建`DataSource`是必不可少的：

```java
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }
}
```

Hibernate和JPA的`SessionFactory`与`EntityManagerFactory`，MyBatis与之对应的是`SqlSessionFactory`和`SqlSession`：

| JDBC       | Hibernate      | JPA                  | MyBatis           |
| :--------- | :------------- | :------------------- | :---------------- |
| DataSource | SessionFactory | EntityManagerFactory | SqlSessionFactory |
| Connection | Session        | EntityManager        | SqlSession        |

ORM的设计套路都是类似的。使用MyBatis的核心就是创建`SqlSessionFactory`，这里需要创建的是`SqlSessionFactoryBean`：

```java
@Bean
public SqlSessionFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) {
    var sqlSessionFactoryBean = new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    return sqlSessionFactoryBean;
}
```

因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：

```java
@Bean
PlatformTransactionManager  createTxManager(@Autowired DataSource  dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
```

#### CRUD

和Hibernate不同的是，MyBatis使用Mapper来实现映射，而且Mapper必须是接口。以`User`类为例，在`User`类和`users`表之间映射的`UserMapper`编写如下：

```java
public interface UserMapper {
	@Select("SELECT * FROM users WHERE id = #{id}")
	User getById(@Param("id") long id);
}
```

这里的Mapper不是`JdbcTemplate`的`RowMapper`的概念，它是定义访问`users`表的接口方法。比如我们定义了一个`User getById(long)`的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解`@Select`标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数`id`的名字通过注解`@Param()`标记为`id`，则SQL语句里将来替换的占位符就是`#{id}`。

如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：

```java
@Select("SELECT * FROM users LIMIT #{offset}, #{maxResults}")
List<User> getAll(@Param("offset") int offset, @Param("maxResults") int maxResults);
```

MyBatis执行查询后，将根据方法的返回类型自动把`ResultSet`的每一行转换为`User`实例，转换规则当然是按列名和属性名对应。如果**列名和属性名不同**，最简单的方式是编写`SELECT`语句的别名：

```sql
-- 列名是created_time，属性名是createdAt:
SELECT id, name, email, created_time AS createdAt FROM users
```

执行INSERT语句就稍微麻烦点，因为我们希望传入`User`实例，因此，定义的方法接口与`@Insert`注解如下：

```java
@Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
int insert(@Param("user") User user);
```

上述方法传入的参数名称是`user`，参数类型是`User`类，在SQL中引用的时候，以`#{obj.property}`的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。

如果`users`表的`id`是自增主键，那么，在SQL中不传入`id`，但希望获取插入后的主键，需要再加一个`@Options`注解：

```java
@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
@Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
int insert2(@Param("user") User user);
```

`keyProperty`和`keyColumn`分别指出JavaBean的属性和数据库的主键列名。

执行`UPDATE`和`DELETE`语句相对比较简单，定义方法如下：

```java
@Update("UPDATE users SET name = #{user.name}, createdAt = #{user.createdAt} WHERE id = #{user.id}")
int update(@Param("user") User user);

@Delete("DELETE FROM users WHERE id = #{id}")
int deleteById(@Param("id") long id);
```

有了`UserMapper`接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但除了编写`UserMapper`接口外，还有`BookMapper`、`BonusMapper`……一个一个写太麻烦，因此，MyBatis提供了一个`MapperFactoryBean`来自动创建所有Mapper的实现类。可以用一个简单的注解`@MapperScan`来启用它：

```java
@MapperScan("com.aotmd.test")
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
    }
}
```

`@MapperScan`是MyBatis框架中的一个注解，用于扫描指定包路径下的Mapper接口，并将其注册为Spring的Bean，使得这些Mapper接口可以被注入到其他Bean中使用。

`@MapperScan("com.aotmd.test")`指示Spring在`com.aotmd.test`包及其子包下扫描所有的Mapper接口，并注册为Spring的Bean，使得这些Mapper接口可以被自动注入到其他组件中使用。

MyBatis在启动时会自动给每个Mapper接口创建如下Bean：

```java
@Component
public class UserMapperImpl implements UserMapper {
    @Autowired
    SqlSessionFactory sessionFactory;

    public List<User> getAllUsers() {
        String sql = getSqlFromAnnotation(...);
        try (SqlSession session = sessionFactory.createSession()) {
            ...
        }
    }
}
```

Spring允许动态创建Bean并添加到applicationContext中

------

从**mybatis3.4.0**开始加入了`@Mapper`注解，目的就是为了**不再写**mapper映射文件。在使用MyBatis时，除了通过`@MapperScan`注解扫描Mapper接口外，还可以直接在Mapper接口上使用`@Mapper`注解，这是因为MyBatis提供了`org.apache.ibatis.annotations.Mapper`注解来标识Mapper接口。

具体来说，使用`@Mapper`注解标注的接口会被MyBatis扫描并注册为Mapper接口，这样就不需要显式地在配置类中使用`@MapperScan`进行扫描。如：

```java
@Mapper
public interface UserMapper {
	@Select("SELECT * FROM users WHERE id = #{id}")
	User getById(@Param("id") long id);
}
```

------

在业务逻辑中，可以直接注入：

```java
@Component
class UserService {
    // 注入UserMapper:
    @Autowired
    UserMapper userMapper;

    public User getById(long id) {
        // 调用Mapper方法:
        return userMapper.getById(id);
    }
    public List<User> getAll(int offset,int maxResults){
        List<User> all = userMapper.getAll(offset, maxResults);
        return all;
    }
    public User register(String email, String password, String name){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);
        user.setCreatedAt(System.currentTimeMillis());
        // 不要设置id，因为使用了自增主键
        // 保存到数据库:
        userMapper.insert2(user);
        // 现在已经自动获得了id:
        System.out.println(user.getId());
        return user;
    }

    public int updateEmail(String name, long id){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setName(name);
        user.setId(id);
        int i = userMapper.updateName(user);
        System.out.println(i);
        return i;
    }
    public int delete(long id){
        int i = userMapper.deleteById(id);
        return i;
    }
}
```

初始化一下表：

```java
@Component
class init{
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        //在Spring容器启动时自动创建一个users表
        jdbcTemplate.update("DROP TABLE IF EXISTS users");
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "createdAt BIGINT NOT NULL, "
                + "UNIQUE (email))");
    }
}
```

启动测试：

```java
@MapperScan("com.aotmd.test")
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService service = ac.getBean(UserService.class);
        long userID1 = service.register("1@qq.com", "123456", "user1").getId();
        long userID2 = service.register("2@qq.com", "123456", "user2").getId();
        List<User> list = service.getAll(0,10);
        System.out.println(list);
        User user = service.getById(userID1);
        System.out.println(user);
        service.delete(userID1);
        User user2 = service.getById(userID1);

        System.out.println(user2);
        service.updateEmail("小华", userID2);
        User user3 = service.getById(userID2);
        System.out.println(user3);
    }
}
```

控制台：

```text
0
1
[User{id=0, email='1@qq.com', password='123456', name='user1', createdAt=1718607558794}, User{id=1, email='2@qq.com', password='123456', name='user2', createdAt=1718607558823}]
User{id=0, email='1@qq.com', password='123456', name='user1', createdAt=1718607558794}
null
1
User{id=1, email='2@qq.com', password='123456', name='小华', createdAt=1718607558823}
```

完整实例：

```java
package com.aotmd.test;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.apache.ibatis.annotations.*;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.*;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Component;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.Transactional;

import javax.annotation.PostConstruct;
import javax.sql.DataSource;
import java.util.List;

@MapperScan("com.aotmd.test")
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) {
        ApplicationContext ac = new AnnotationConfigApplicationContext(Test4.class);
        UserService service = ac.getBean(UserService.class);
        long userID1 = service.register("1@qq.com", "123456", "user1").getId();
        long userID2 = service.register("2@qq.com", "123456", "user2").getId();
        List<User> list = service.getAll(0,10);
        System.out.println(list);
        User user = service.getById(userID1);
        System.out.println(user);
        service.delete(userID1);
        User user2 = service.getById(userID1);

        System.out.println(user2);
        service.updateEmail("小华", userID2);
        User user3 = service.getById(userID2);
        System.out.println(user3);
    }
}
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    public SqlSessionFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) {
        var sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
/*        // 创建 MyBatis 的 Configuration 对象
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();

        // 开启 MyBatis 的 SQL 调试模式
        configuration.setLogImpl(org.apache.ibatis.logging.stdout.StdOutImpl.class);
        //configuration.setLogPrefix("mybatis.debug.");
        configuration.setLogPrefix("mybatis.debug.sql.");

        // 将 Configuration 对象设置到 SqlSessionFactoryBean 中
        sqlSessionFactoryBean.setConfiguration(configuration);*/

        return sqlSessionFactoryBean;
    }
    @Bean
    PlatformTransactionManager  createTxManager(@Autowired DataSource  dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}

class User{
    private long id;
    private String email;
    private String password;
    private String name;
    private Long createdAt;
    public User() {}
    public String getEmail() {
        return email;
    }
    public String getPassword() {
        return password;
    }
    public String getName() {
        return name;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public void setName(String name) {
        this.name = name;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Long getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Long createdAt) {
        this.createdAt = createdAt;
    }

    @Override public String toString() {return "User{id=" + id + ", email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + ", createdAt=" + createdAt + '}'; }
}

interface UserMapper {
    @Select("SELECT * FROM users WHERE id = #{id}")
    User getById(@Param("id") long id);
    @Select("SELECT * FROM users LIMIT #{offset}, #{maxResults}")
    List<User> getAll(@Param("offset") int offset, @Param("maxResults") int maxResults);
    @Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
    int insert(@Param("user") User user);
    @Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id")
    @Insert("INSERT INTO users (email, password, name, createdAt) VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})")
    int insert2(@Param("user") User user);
    @Update("UPDATE users SET name = #{user.name} WHERE id = #{user.id}")
    int updateName(@Param("user") User user);

    @Delete("DELETE FROM users WHERE id = #{id}")
    int deleteById(@Param("id") long id);
}

@Component
class init{
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        //在Spring容器启动时自动创建一个users表
        jdbcTemplate.update("DROP TABLE IF EXISTS users");
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "createdAt BIGINT NOT NULL, "
                + "UNIQUE (email))");
    }
}

@Component
class UserService {
    // 注入UserMapper:
    @Autowired
    UserMapper userMapper;

    public User getById(long id) {
        // 调用Mapper方法:
        return userMapper.getById(id);
    }
    public List<User> getAll(int offset,int maxResults){
        List<User> all = userMapper.getAll(offset, maxResults);
        return all;
    }
    public User register(String email, String password, String name){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);
        user.setCreatedAt(System.currentTimeMillis());
        // 不要设置id，因为使用了自增主键
        // 保存到数据库:
        userMapper.insert2(user);
        // 现在已经自动获得了id:
        System.out.println(user.getId());
        return user;
    }

    public int updateEmail(String name, long id){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setName(name);
        user.setId(id);
        int i = userMapper.updateName(user);
        System.out.println(i);
        return i;
    }
    public int delete(long id){
        int i = userMapper.deleteById(id);
        return i;
    }
}
```

#### 使用XML的编写SQL

只需要修改一下配置，指定映射文件位置为`"classpath:mapper/*.xml"`：

```java
    @Bean
    public SqlSessionFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) throws IOException {
        var sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"));
        return sqlSessionFactoryBean;
    }
```

这样就不用注解了：

```java
interface UserMapper {
    User getById(@Param("id") long id);
    List<User> getAll(@Param("offset") int offset, @Param("maxResults") int maxResults);
    int insert(@Param("user") User user);
    int insert2(@Param("user") User user);
    int updateName(@Param("user") User user);

    int deleteById(@Param("id") long id);
}
```

对应的sql写在xml文件中：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.aotmd.test.UserMapper"><!--命名空间为接口名称-->
    <!--id需与接口方法完全一致,parameterType形参,resultType返回值类型-->
    <select id="getById" parameterType="Long" resultType="com.aotmd.test.User">
        SELECT *
        FROM users
        WHERE id = #{id}
    </select>
    <select id="getAll" resultType="com.aotmd.test.User">
        SELECT *
        FROM users LIMIT #{offset}, #{maxResults}
    </select>
    <insert id="insert" parameterType="com.aotmd.test.User">
        INSERT INTO users (email, password, name, createdAt)
        VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})
    </insert>
    <insert id="insert2" parameterType="com.aotmd.test.User" useGeneratedKeys="true" keyProperty="id" keyColumn="id">
        INSERT INTO users (email, password, name, createdAt)
        VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})
    </insert>

    <update id="updateName" parameterType="com.aotmd.test.User">
        UPDATE users
        SET name = #{user.name}
        WHERE id = #{user.id}
    </update>

    <delete id="deleteById" parameterType="long">
        DELETE
        FROM users
        WHERE id = #{id}
    </delete>
</mapper>
```

------

更新`User`时根据属性值构造动态SQL：

```xml
<update id="updateUser">
  UPDATE users SET
  <set>
    <if test="user.name != null"> name = #{user.name} </if>
    <if test="user.hobby != null"> hobby = #{user.hobby} </if>
    <if test="user.summary != null"> summary = #{user.summary} </if>
  </set>
  WHERE id = #{user.id}
</update>
```

编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中，[官方文档](https://mybatis.org/mybatis-3/zh/configuration.html)。

使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。

#### 设置调试日志

引入log4j依赖：

```xml
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
```

初始化时配置log4j：

```java
@Bean
public SqlSessionFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) throws IOException {
    var sqlSessionFactoryBean = new SqlSessionFactoryBean();
    sqlSessionFactoryBean.setDataSource(dataSource);
    sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"));
    // 创建 MyBatis 的 Configuration 对象
    org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();

    // 设置日志实现为Log4j
    configuration.setLogImpl(org.apache.ibatis.logging.log4j.Log4jImpl.class);
    // 将 Configuration 对象设置到 SqlSessionFactoryBean 中
    sqlSessionFactoryBean.setConfiguration(configuration);

    return sqlSessionFactoryBean;
}
```

在`classpath`根目录新建`log4j.properties`:

```properties
# Global logging configuration
log4j.rootLogger=ERROR, stdout
# MyBatis logging configuration...
log4j.logger.com.aotmd.test=DEBUG
#log4j.logger.org.springframework=DEBUG
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %5p [%t] - %m%n
mybatis.configuration.call-setters-on-nulls=true
log4j.appender.Console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %5p [%t] (%F:%L) - %m%n
```

注意第4行的`log4j.logger.com.aotmd.test=DEBUG`，表示对`com.aotmd.test`包下的接口方法进行日志DEBUG级别输出。

# Spring MVC

Spring提供的是一个IoC容器，所有的Bean，包括Controller，都在Spring IoC容器中被初始化，而Servlet容器由JavaEE服务器提供（如Tomcat）。

要使用Spring MVC，需要以下依赖：

```xml
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-core</artifactId>
    <version>9.0.26</version>
    <scope>compile</scope>
</dependency>
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
    <version>9.0.26</version>
    <scope>compile</scope>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
<dependency>
    <groupId>io.pebbletemplates</groupId>
    <artifactId>pebble-spring5</artifactId>
    <version>3.2.2</version>
</dependency>
```

文件目录结构：

```ascii
spring-web-mvc
├── pom.xml
└── src
    └── main
        ├── java
        │   └── com
        │       └── aotmd
        │           └── test
        │               └── Test4.java
        ├── resources
        │   ├── jdbc.properties
        │   └── log4j.properties
        └── webapp
            ├── WEB-INF
            │   ├── templates
            │   │   └── test.html
            │   └── web.xml
            └── static
                ├── css
                └── js
```

其中，`src/main/webapp`是标准web目录，`WEB-INF`存放`web.xml`，编译的class，第三方jar，以及不允许浏览器直接访问的View模版，`static`目录存放所有静态文件。

`src/main/resources`目录中存放的是Java程序读取的classpath资源文件。`src/main/java`就是编写的Java代码。

------

和普通Spring配置一样，只需加上`@EnableWebMvc`注解，就“激活”了Spring MVC。

除了创建`DataSource`、`JdbcTemplate`、`PlatformTransactionManager`外，`AppConfig`需要额外创建几个用于Spring MVC的Bean：

```java
@Bean
WebMvcConfigurer createWebMvcConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addResourceHandlers(ResourceHandlerRegistry registry) {
            registry.addResourceHandler("/static/**").addResourceLocations("/static/");
        }
    };
}
```

`WebMvcConfigurer`并不是必须的，在这里创建了一个默认的`WebMvcConfigurer`，只覆写`addResourceHandlers()`，目的是让Spring MVC自动处理静态文件，并且映射路径为`/static/**`。

另一个必须要创建的Bean是`ViewResolver`，因为Spring MVC允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的`ViewResolver`：

```java
@Bean
ViewResolver createViewResolver(@Autowired ServletContext servletContext) {
    var engine = new PebbleEngine.Builder().autoEscaping(true)
            // cache:
            .cacheActive(false)
            // loader:
            .loader(new ServletLoader(servletContext))
            .build();
    var viewResolver = new PebbleViewResolver(engine);
    viewResolver.setPrefix("/WEB-INF/templates/");
    viewResolver.setSuffix("");
    return viewResolver;
}
```

`ViewResolver`通过指定`prefix`和`suffix`来确定如何查找View。上述配置使用Pebble引擎，指定模板文件存放在`/WEB-INF/templates/`目录下。

剩下的Bean都是普通的`@Component`，但Controller必须标记为`@Controller`，例如：

```java
// Controller使用@Controller标记而不是@Component:
@Controller
class UserController {
    // 正常使用@Autowired注入:
    @Autowired
    UserService userService;

    // 处理一个URL映射:
    @GetMapping("/test")
    public ModelAndView index() {
        HashMap<String, Object> map = new HashMap<>();
        map.put("name","测试");
        return new ModelAndView("test.html",map);
    }
}
```

如果是普通的Java应用程序，可以通过`main()`方法可以很简单地创建一个Spring容器的实例：

```java
public static void main(String[] args) {
    var context = new AnnotationConfigApplicationContext(AppConfig.class);
}
```

在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，介绍一种最简单的启动Spring容器的方式。在`web.xml`中配置Spring MVC提供的`DispatcherServlet`：

```xml
<?xml version="1.0"?>
<web-app>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
        </init-param>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.aotmd.test.Test4</param-value>
        </init-param>
        <load-on-startup>0</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>
```

初始化参数`contextClass`指定使用注解配置的`AnnotationConfigWebApplicationContext`，配置文件的位置参数`contextConfigLocation`指向`AppConfig`的完整类名，最后，把这个Servlet映射到`/*`，即处理所有URL。

上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的`DispatcherServlet`，在`DispatcherServlet`启动时，它根据配置`AppConfig`创建了一个类型是`WebApplicationContext`的IoC容器，完成所有Bean的初始化，并将容器绑到`ServletContext`上。

因为`DispatcherServlet`持有IoC容器，能从IoC容器中获取所有`@Controller`的Bean，因此，`DispatcherServlet`接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的`ModelAndView`决定如何渲染页面。

最后，在`AppConfig`中通过`main()`方法启动嵌入式Tomcat：

```java
@EnableWebMvc
@MapperScan
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 设置Tomcat的端口号，默认为8080
        tomcat.setPort(Integer.getInteger("port", 8080));
        // 获取Tomcat的连接器
        tomcat.getConnector();

        // 将webapp添加到Tomcat，路径为src/main/webapp
        Context ctx = tomcat.addWebapp(
                "",
                new File("src/main/webapp").getAbsolutePath()
        );
        //设置热部署
        ctx.setReloadable(true);
        // 创建Web资源根目录
        WebResourceRoot resources = new StandardRoot(ctx);
        // 添加预设资源，包括类路径和WEB-INF目录
        resources.addPreResources(
                new DirResourceSet(
                        resources,
                        "/WEB-INF/classes",
                        new File("target/classes").getAbsolutePath(),
                        "/"
                )
        );
        // 设置Web应用的资源
        ctx.setResources(resources);
        // 启动Tomcat
        tomcat.start();
        // 等待Tomcat服务器结束
        tomcat.getServer().await();
    }
}
```

`src/main/webapp/WEB-INF/templates/test.html`：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>测试</title>
</head>
<body>
<h1>{{name}}</h1>
</body>
</html>
```

上述Web应用程序就是使用Spring MVC时的一个最小启动功能集。

------

有了Web应用程序的最基本的结构，重点就可以放在如何编写Controller上。Spring MVC对Controller没有固定的要求，也不需要实现特定的接口。以`UserController`为例，编写Controller只需要遵循以下要点：

总是标记`@Controller`而不是`@Component`：

```java
@Controller
public class UserController {
    ...
}
```

一个方法对应一个HTTP请求路径，用`@GetMapping`或`@PostMapping`表示GET或POST请求：

```java
@PostMapping("/signin")
public ModelAndView doSignin(
        @RequestParam("email") String email,
        @RequestParam("password") String password,
        HttpSession session) {
    ...
}
```

需要接收的HTTP参数以`@RequestParam()`标注，可以设置默认值。如果方法参数需要传入`HttpServletRequest`、`HttpServletResponse`或者`HttpSession`，直接添加这个类型的参数即可，Spring MVC会自动按类型传入。

返回的ModelAndView通常包含View的路径和一个Map作为Model，但也可以没有Model，例如：

```java
return new ModelAndView("signin.html"); // 仅View，没有Model
```

返回重定向时既可以写`new ModelAndView("redirect:/signin")`，也可以直接返回String：

```java
public String index() {
    if (...) {
        return "redirect:/signin";
    } else {
        return "redirect:/profile";
    }
}
```

如果在方法内部直接操作`HttpServletResponse`发送响应，返回`null`表示无需进一步处理：

```java
public ModelAndView download(HttpServletResponse response) {
    byte[] data = ...
    response.setContentType("application/octet-stream");
    OutputStream output = response.getOutputStream();
    output.write(data);
    output.flush();
    return null;
}
```

对URL进行分组，每组对应一个Controller是一种很好的组织形式，并可以在Controller的class定义出添加URL前缀，例如：

```java
@Controller
@RequestMapping("/user")
public class UserController {
    // 注意实际URL映射是/user/profile
    @GetMapping("/profile")
    public ModelAndView profile() {
        ...
    }

    // 注意实际URL映射是/user/changePassword
    @GetMapping("/changePassword")
    public ModelAndView changePassword() {
        ...
    }
}
```

实际方法的URL映射总是前缀+路径，这种形式还可以有效避免不小心导致的重复的URL映射。

使用Spring MVC时，整个Web应用程序按如下顺序启动：

1. 启动Tomcat服务器；
2. Tomcat读取`web.xml`并初始化`DispatcherServlet`；
3. `DispatcherServlet`创建IoC容器并自动注册到`ServletContext`中。

启动后，浏览器发出的HTTP请求全部由`DispatcherServlet`接收，并根据配置转发到指定Controller的指定方法处理。

## REST

使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。

直接在Controller中处理JSON是可以的，因为Spring MVC的`@GetMapping`和`@PostMapping`都支持指定输入和输出的格式。如果想接收JSON，输出JSON，那么可以这样写：

```java
@PostMapping(value = "/rest",
             consumes = "application/json;charset=UTF-8",
             produces = "application/json;charset=UTF-8")
@ResponseBody
public String rest(@RequestBody User user) {
    return "{\"restSupport\":true}";
}
```

需要加入Jackson这个依赖：

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.17.0</version>
</dependency>
```

测试：post-body-raw-JSON：`{"email":"bob@example.com"}`，访问`http://localhost:8080/rest`，显示正常:`{"restSupport": true}`。

`@PostMapping`使用`consumes`声明能接收的类型，使用`produces`声明输出的类型，并且额外加了`@ResponseBody`表示返回的`String`无需额外处理，直接作为输出内容写入`HttpServletResponse`。输入的JSON则根据注解`@RequestBody`直接被Spring反序列化为`User`这个JavaBean。

直接用Spring的Controller配合一大堆注解写REST太麻烦了，因此，Spring还额外提供了一个`@RestController`注解，使用`@RestController`替代`@Controller`后，每个方法自动变成API接口方法。还是以实际代码举例，编写`ApiController`如下：

```java
@RestController
@RequestMapping("/api")
class ApiController {
    @Autowired
    UserService userService;

    @GetMapping("/users")
    public List<User> users() {
        return userService.getAll(1,5);
    }

    @GetMapping("/users/{id}")
    public User user(@PathVariable("id") long id) {
        return userService.getById(id);
    }

    @PostMapping("/signin")
    public Map<String, Object> signin(@RequestBody SignInRequest signinRequest) {
        try {
            User user = userService.register(signinRequest.email, signinRequest.password,signinRequest.name);
            return Map.of("user", user);
        } catch (Exception e) {
            return Map.of("error", "SIGNIN_FAILED", "message", e.getMessage());
        }
    }

    public static class SignInRequest {
        public String email;
        public String password;
        public String name;
    }
}
```

编写REST接口只需要定义`@RestController`，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。

测试：post-body-raw-JSON：`{"email":"bob@example.com","password":"bob123","name":"test"}`，访问`http://localhost:8080/api/signin`，显示正常:

```json
{
    "user": {
        "id": 0,
        "email": "bob@example.com",
        "password": "bob123",
        "name": "test",
        "createdAt": 1719308650728
    }
}
```

`User`能被正确地序列化为JSON，但暴露了`password`属性，这是我们不期望的。要避免输出`password`属性，可以把`User`复制到另一个`UserBean`对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在`User`的`password`属性定义处加上`@JsonIgnore`表示完全忽略该属性：

```java
public class User {
    ...
    @JsonIgnore
    public String getPassword() {
        return password;
    }
    ...
}
```

但是这样一来，如果写一个`register(User user)`方法，那么该方法的User对象也拿不到注册时用户传入的密码了。如果要允许输入`password`，但不允许输出`password`，即在JSON序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：

```java
public class User {
    ...
    @JsonProperty(access = Access.WRITE_ONLY)
    public String getPassword() {
        return password;
    }
    ...
}
```

同样的，可以使用`@JsonProperty(access = Access.READ_ONLY)`允许输出，不允许输入。

## 集成Filter

在Spring MVC中，`DispatcherServlet`只需要固定配置到`web.xml`中，剩下的工作主要是专注于编写Controller。

在Servlet规范中，还可以使用`Filter`。如果要在Spring MVC中使用`Filter`，应该怎么做？

在上一节的Web应用中注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，可以简单地使用一个EncodingFilter，在全局范围类给`HttpServletRequest`和`HttpServletResponse`强制设置为UTF-8编码。

可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个`CharacterEncodingFilter`。配置Filter时，只需在`web.xml`中声明即可：

```xml
<filter>
    <filter-name>encodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>

<filter-mapping>
    <filter-name>encodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

因为这种Filter和业务关系不大，`CharacterEncodingFilter`其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。

如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头`Authorization: Basic email:password`，这个需求如何实现？

编写一个`AuthFilter`是最简单的实现方式：

```java
@Component
class AuthFilter implements Filter {
    @Autowired
    UserService userService;

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        // 获取Authorization头:
        String authHeader = req.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Basic ")) {
            String str=authHeader.split(" ")[1];
            str=new String(Base64.getDecoder().decode(str));
            // 从Header中提取email和password:
            String email = str.split(":")[0];
            String password = str.split(":")[1];
            // 登录:
            User user = userService.login(email, password);
            System.out.println(user);
            // 放入Session:
            req.getSession().setAttribute("KEY_USER", user);
        }
        // 继续处理请求:
        chain.doFilter(request, response);
    }
}
```

但是，在Spring中创建的这个`AuthFilter`是一个普通Bean，Servlet容器并不知道，所以它不会起作用。

如果直接在`web.xml`中声明这个`AuthFilter`，则`AuthFilter`的实例将由Servlet容器而不是Spring容器初始化，因此，`@Autowire`根本不生效，用于登录的`UserService`成员变量永远是`null`。

所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的`AuthFilter`。Spring MVC提供了一个`DelegatingFilterProxy`，专门来干这个事情：

```xml
<filter>
    <filter-name>authFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>

<filter-mapping>
    <filter-name>authFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

Servlet容器从`web.xml`中读取配置，实例化`DelegatingFilterProxy`，注意命名是`authFilter`；

Spring容器通过扫描`@Component`实例化`AuthFilter`。

当`DelegatingFilterProxy`生效后，它会自动查找注册在`ServletContext`上的Spring容器，再试图从容器中查找**名为`authFilter`的Bean**，也就是我们用`@Component`声明的`AuthFilter`。

`DelegatingFilterProxy`将请求代理给`AuthFilter`，核心代码如下：

```java
public class DelegatingFilterProxy implements Filter {
    private Filter delegate;
    public void doFilter(...) throws ... {
        if (delegate == null) {
            delegate = findBeanFromSpringContainer();
        }
        delegate.doFilter(req, resp, chain);
    }
}
```

这就是一个代理模式的简单应用。画图表示它们之间的引用关系如下：

```ascii
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
  ┌─────────────────────┐        ┌───────────┐   │
│ │DelegatingFilterProxy│─│─│─ ─>│AuthFilter │
  └─────────────────────┘        └───────────┘   │
│ ┌─────────────────────┐ │ │    ┌───────────┐
  │  DispatcherServlet  │─ ─ ─ ─>│Controllers│   │
│ └─────────────────────┘ │ │    └───────────┘
                                                 │
│    Servlet Container    │ │  Spring Container
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

如果在`web.xml`中配置的Filter名字和Spring容器的**Bean的名字不一致**，那么需要指定Bean的名字：

```xml
<filter>
    <filter-name>basicAuthFilter</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    <!-- 指定Bean的名字 -->
    <init-param>
        <param-name>targetBeanName</param-name>
        <param-value>authFilter</param-value>
    </init-param>
</filter>
```

实际应用时，尽量保持名字一致，以减少不必要的配置。

要使用Basic模式的用户认证，可以使用postman测试。例如，用户登录名是`tom@example.com`，口令是`tomcat`，那么先构造一个使用URL编码的`用户名:口令`的字符串：`tom@example.com:tomcat`,然后通过`btoa("tom@example.com:tomcat")`编码为：`dG9tQGV4YW1wbGUuY29tOnRvbWNhdA==`，并在前头添加`Basic  ` 和空格，组成：`Basic dG9tQGV4YW1wbGUuY29tOnRvbWNhdA==`。

首先设置url：`http://localhost:8080/api/signin`,post方式body-raw-json：`{"email":"tom@example.com","password":"tomcat","name":"test"}`,插入一条数据。

然后构建一下登录：

`UserMapper`添加：

```java
User getByEmailAndByPassword(@Param("user") User user);
```

`UserMapper.xml`添加：

```xml
<select id="getByEmailAndByPassword" resultType="com.aotmd.test.User">
    SELECT *
    FROM users
    WHERE email = #{user.email} and
    password=#{user.password}
</select>
```

`UserService`添加：

```java
public User login(String email, String password){
    // 创建一个User对象:
    User user = new User();
    // 设置好各个属性:
    user.setEmail(email);
    user.setPassword(password);
    user=userMapper.getByEmailAndByPassword(user);
    return user;
}
```

get：`http://localhost:8080/api/users`，并附带header：Authorization：`Basic dG9tQGV4YW1wbGUuY29tOnRvbWNhdA==`

控制台打印：`User{id=0, email='tom@example.com', password='tomcat', name='test', createdAt=1719387371455}`，返回的Cookie带有:`JSESSIONID=5DEFF8E659A261619EDE0CA1D646038D`正常使用。

完整实例：

```java
package com.aotmd.test;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import io.pebbletemplates.pebble.PebbleEngine;
import io.pebbletemplates.pebble.loader.ServletLoader;
import io.pebbletemplates.spring.servlet.PebbleViewResolver;
import org.apache.catalina.Context;
import org.apache.catalina.LifecycleException;
import org.apache.catalina.WebResourceRoot;
import org.apache.catalina.startup.Tomcat;
import org.apache.catalina.webresources.DirResourceSet;
import org.apache.catalina.webresources.StandardRoot;
import org.apache.ibatis.annotations.Param;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import javax.annotation.PostConstruct;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.sql.DataSource;
import java.io.File;
import java.io.IOException;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


/**
 * @author aotmd
 * @version 1.0
 * @date 2024/6/1 22:16
 */
@EnableWebMvc
@MapperScan
@Configuration
@ComponentScan
@EnableTransactionManagement
public class Test4{
    public static void main(String[] args) throws LifecycleException {
        Tomcat tomcat = new Tomcat();
        // 设置Tomcat的端口号，默认为8080
        tomcat.setPort(Integer.getInteger("port", 8080));
        // 获取Tomcat的连接器
        tomcat.getConnector();

        // 将webapp添加到Tomcat，路径为src/main/webapp
        Context ctx = tomcat.addWebapp(
                "",
                new File("src/main/webapp").getAbsolutePath()
        );
        //设置热部署
        ctx.setReloadable(true);
        // 创建Web资源根目录
        WebResourceRoot resources = new StandardRoot(ctx);
        // 添加预设资源，包括类路径和WEB-INF目录
        resources.addPreResources(
                new DirResourceSet(
                        resources,
                        "/WEB-INF/classes",
                        new File("target/classes").getAbsolutePath(),
                        "/"
                )
        );
        // 设置Web应用的资源
        ctx.setResources(resources);
        // 启动Tomcat
        tomcat.start();
        // 等待Tomcat服务器结束
        tomcat.getServer().await();
    }
}
@Configuration
@PropertySource("classpath:jdbc.properties")
class Config {
    @Value("${jdbc.url}")
    String jdbcUrl;

    @Value("${jdbc.username}")
    String jdbcUsername;

    @Value("${jdbc.password}")
    String jdbcPassword;

    @Bean
    DataSource createDataSource() {
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(jdbcUrl);
        config.setUsername(jdbcUsername);
        config.setPassword(jdbcPassword);
        config.addDataSourceProperty("autoCommit", "true");
        config.addDataSourceProperty("connectionTimeout", "5");
        config.addDataSourceProperty("idleTimeout", "60");
        return new HikariDataSource(config);
    }

    @Bean
    public SqlSessionFactoryBean createEntityManagerFactory(@Autowired DataSource dataSource) throws IOException {
        var sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml"));
        // 创建 MyBatis 的 Configuration 对象
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();

        // 设置日志实现为Log4j
        configuration.setLogImpl(org.apache.ibatis.logging.log4j.Log4jImpl.class);
        //configuration.setLogPrefix("mybatis.debug.");
/*        configuration.setLogPrefix("mybatis.debug.sql.");*/

        // 将 Configuration 对象设置到 SqlSessionFactoryBean 中
        sqlSessionFactoryBean.setConfiguration(configuration);

        return sqlSessionFactoryBean;
    }
    @Bean
    PlatformTransactionManager  createTxManager(@Autowired DataSource  dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
    @Bean
    JdbcTemplate createJdbcTemplate(@Autowired DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
    @Bean
    WebMvcConfigurer createWebMvcConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addResourceHandlers(ResourceHandlerRegistry registry) {
                registry.addResourceHandler("/static/**").addResourceLocations("/static/");
            }
            @Override
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController("/").setViewName("/index.html");
            }
        };
    }
    @Bean
    ViewResolver createViewResolver(@Autowired ServletContext servletContext) {
        var engine = new PebbleEngine.Builder().autoEscaping(true)
                // cache:
                .cacheActive(false)
                // loader:
                .loader(new ServletLoader(servletContext))
                .build();
        var viewResolver = new PebbleViewResolver(engine);
        viewResolver.setPrefix("/WEB-INF/templates/");
        viewResolver.setSuffix("");
        return viewResolver;
    }
}

class User{
    private long id;
    private String email;
    private String password;
    private String name;
    private Long createdAt;
    public User() {}
    public String getEmail() {
        return email;
    }
    public String getPassword() {
        return password;
    }
    public String getName() {
        return name;
    }
    public void setEmail(String email) {
        this.email = email;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public void setName(String name) {
        this.name = name;
    }

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public Long getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Long createdAt) {
        this.createdAt = createdAt;
    }

    @Override public String toString() {return "User{id=" + id + ", email='" + email + '\'' + ", password='" + password + '\'' + ", name='" + name + '\'' + ", createdAt=" + createdAt + '}'; }
}

interface UserMapper {
    User getById(@Param("id") long id);
    List<User> getAll(@Param("offset") int offset, @Param("maxResults") int maxResults);
    int insert(@Param("user") User user);
    int insert2(@Param("user") User user);
    int updateName(@Param("user") User user);
    int deleteById(@Param("id") long id);
    //新增的部分
    User getByEmailAndByPassword(@Param("user") User user);
}

@Component
class init{
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void init() {
        //在Spring容器启动时自动创建一个users表
        jdbcTemplate.update("DROP TABLE IF EXISTS users");
        jdbcTemplate.update("CREATE TABLE IF NOT EXISTS users ("
                + "id BIGINT IDENTITY NOT NULL PRIMARY KEY, "
                + "email VARCHAR(100) NOT NULL, "
                + "password VARCHAR(100) NOT NULL, "
                + "name VARCHAR(100) NOT NULL, "
                + "createdAt BIGINT NOT NULL, "
                + "UNIQUE (email))");
    }

}

@Component
class UserService {
    // 注入UserMapper:
    @Autowired
    UserMapper userMapper;

    public User getById(long id) {
        // 调用Mapper方法:
        return userMapper.getById(id);
    }
    public List<User> getAll(int offset,int maxResults){
        List<User> all = userMapper.getAll(offset, maxResults);
        return all;
    }
    public User register(String email, String password, String name){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setEmail(email);
        user.setPassword(password);
        user.setName(name);
        user.setCreatedAt(System.currentTimeMillis());
        // 不要设置id，因为使用了自增主键
        // 保存到数据库:
        userMapper.insert2(user);
        // 现在已经自动获得了id:
        System.out.println(user.getId());
        return user;
    }

    public int updateEmail(String name, long id){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setName(name);
        user.setId(id);
        int i = userMapper.updateName(user);
        System.out.println(i);
        return i;
    }
    public int delete(long id){
        int i = userMapper.deleteById(id);
        return i;
    }
	//新增的部分
    public User login(String email, String password){
        // 创建一个User对象:
        User user = new User();
        // 设置好各个属性:
        user.setEmail(email);
        user.setPassword(password);
        user=userMapper.getByEmailAndByPassword(user);
        return user;
    }
}

// Controller使用@Controller标记而不是@Component:
@Controller
class UserController {
    // 正常使用@Autowired注入:
    @Autowired
    UserService userService;

    // 处理一个URL映射:
    @GetMapping("/test")
    public ModelAndView index() {
        HashMap<String, Object> map = new HashMap<>();
        map.put("name","测试");
        return new ModelAndView("test.html",map);
    }
    @PostMapping(value = "/rest",
            consumes = "application/json;charset=UTF-8",
            produces = "application/json;charset=UTF-8")
    @ResponseBody
    public String rest(@RequestBody User user) {
        return "{\"restSupport\":true}";
    }
}
@RestController
@RequestMapping("/api")
class ApiController {
    @Autowired
    UserService userService;

    @GetMapping("/users")
    public List<User> users() {
        return userService.getAll(1,5);
    }

    @GetMapping("/users/{id}")
    public User user(@PathVariable("id") long id) {
        return userService.getById(id);
    }

    @PostMapping("/signin")
    public Map<String, Object> signin(@RequestBody SignInRequest signinRequest) {
        try {
            User user = userService.register(signinRequest.email, signinRequest.password,signinRequest.name);
            return Map.of("user", user);
        } catch (Exception e) {
            return Map.of("error", "SIGNIN_FAILED", "message", e.getMessage());
        }
    }

    public static class SignInRequest {
        public String email;
        public String password;
        public String name;
    }
}
//新增的部分
@Component
class AuthFilter implements Filter {
    @Autowired
    UserService userService;

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        // 获取Authorization头:
        String authHeader = req.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Basic ")) {
            String str=authHeader.split(" ")[1];
            str=new String(Base64.getDecoder().decode(str));
            // 从Header中提取email和password:
            String email = str.split(":")[0];
            String password = str.split(":")[1];
            // 登录:
            User user = userService.login(email, password);
            System.out.println(user);
            // 放入Session:
            req.getSession().setAttribute("KEY_USER", user);
        }
        // 继续处理请求:
        chain.doFilter(request, response);
    }
}
```

`web.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
        </init-param>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.aotmd.test.Test4</param-value>
        </init-param>
        <load-on-startup>0</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
	<!--新增的部分-->
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
	
    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
	<!--新增的部分-->
    <filter>
        <filter-name>authFilter</filter-name>
        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
    </filter>

    <filter-mapping>
        <filter-name>authFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>
```

`UserMapper.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.aotmd.test.UserMapper"><!--命名空间为接口名称-->
    <!--id需与接口方法完全一致,parameterType形参,resultType返回值类型-->
    <select id="getById" parameterType="Long" resultType="com.aotmd.test.User">
        SELECT *
        FROM users
        WHERE id = #{id}
    </select>
    <select id="getAll" resultType="com.aotmd.test.User">
        SELECT *
        FROM users LIMIT #{offset}, #{maxResults}
    </select>
    <!--新增的部分-->
    <select id="getByEmailAndByPassword" resultType="com.aotmd.test.User">
        SELECT *
        FROM users
        WHERE email = #{user.email} and
        password=#{user.password}
    </select>
    <insert id="insert" parameterType="com.aotmd.test.User">
        INSERT INTO users (email, password, name, createdAt)
        VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})
    </insert>
    <insert id="insert2" parameterType="com.aotmd.test.User" useGeneratedKeys="true" keyProperty="id" keyColumn="id">
        INSERT INTO users (email, password, name, createdAt)
        VALUES (#{user.email}, #{user.password}, #{user.name}, #{user.createdAt})
    </insert>

    <update id="updateName" parameterType="com.aotmd.test.User">
        UPDATE users
        SET name = #{user.name}
        WHERE id = #{user.id}
    </update>

    <delete id="deleteById" parameterType="long">
        DELETE
        FROM users
        WHERE id = #{id}
    </delete>
</mapper>
```



## 使用Interceptor

在Web程序中，使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：

```ascii
         │   ▲
         ▼   │
       ┌───────┐
       │Filter1│
       └───────┘
         │   ▲
         ▼   │
       ┌───────┐
┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐
       └───────┘
│        │   ▲                  │
         ▼   │
│ ┌─────────────────┐           │
  │DispatcherServlet│<───┐
│ └─────────────────┘    │      │
   │              ┌────────────┐
│  │              │ModelAndView││
   │              └────────────┘
│  │                     ▲      │
   │    ┌───────────┐    │
│  ├───>│Controller1│────┤      │
   │    └───────────┘    │
│  │                     │      │
   │    ┌───────────┐    │
│  └───>│Controller2│────┘      │
        └───────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的`DispatcherServlet`还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。

如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：

```ascii
       │   ▲
       ▼   │
     ┌───────┐
     │Filter1│
     └───────┘
       │   ▲
       ▼   │
     ┌───────┐
     │Filter2│
     └───────┘
       │   ▲
       ▼   │
┌─────────────────┐
│DispatcherServlet│<───┐
└─────────────────┘    │
 │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ┐
 │                     │
 │ │            ┌────────────┐ │
 │              │   Render   │
 │ │            └────────────┘ │
 │                     ▲
 │ │                   │       │
 │              ┌────────────┐
 │ │            │ModelAndView│ │
 │              └────────────┘
 │ │                   ▲       │
 │    ┌───────────┐    │
 ├─┼─>│Controller1│────┤       │
 │    └───────────┘    │
 │ │                   │       │
 │    ┌───────────┐    │
 └─┼─>│Controller2│────┘       │
      └───────────┘
   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
```

上图虚线框就是Interceptor的拦截范围，Controller的处理方法一般都类似这样：

```java
@Controller
public class Controller1 {
    @GetMapping("/path/to/hello")
    ModelAndView hello() {
        ...
    }
}
```

所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回`ModelAndView`并渲染后，后续处理就脱离了Interceptor的拦截范围。

使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的`@Order`指定顺序。先写一个`LoggerInterceptor`：

```java
@Order(1)
@Component
public class LoggerInterceptor implements HandlerInterceptor {

    final Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        logger.info("preHandle {}...", request.getRequestURI());
        if (request.getParameter("debug") != null) {
            PrintWriter pw = response.getWriter();
            pw.write("<p>DEBUG MODE</p>");
            pw.flush();
            return false;
        }
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        logger.info("postHandle {}.", request.getRequestURI());
        if (modelAndView != null) {
            modelAndView.addObject("__time__", LocalDateTime.now());
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        logger.info("afterCompletion {}: exception = {}", request.getRequestURI(), ex);
    }
}
```

一个Interceptor必须实现`HandlerInterceptor`接口，可以选择实现`preHandle()`、`postHandle()`和`afterCompletion()`方法。`preHandle()`是Controller方法调用前执行，`postHandle()`是Controller方法正常返回后执行，而`afterCompletion()`无论Controller方法是否抛异常都会执行，参数`ex`就是Controller方法抛出的异常（未抛出异常是`null`）。

在`preHandle()`中，也可以直接处理响应，返回`false`表示无需调用Controller方法继续处理，通常在认证或者安全检查失败时直接返回错误响应。在`postHandle()`中，因为捕获了Controller方法返回的`ModelAndView`，所以可以继续往`ModelAndView`里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。

最后，要让拦截器生效，我们在`WebMvcConfigurer`中注册所有的Interceptor：

```java
@Bean
WebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) {
    return new WebMvcConfigurer() {
        public void addInterceptors(InterceptorRegistry registry) {
            for (var interceptor : interceptors) {
                registry.addInterceptor(interceptor);
            }
        }
        ...
    };
}
```

 如果拦截器没有生效，请检查是否忘了在WebMvcConfigurer中注册。

如果是通过xml配置，则`LoggerInterceptor`照旧，但可以去掉`@Component`，如果不需要指定执行顺序，也可以去掉`@Order(1)`。xml文件配置如下：

```xml
<mvc:interceptors>
    <mvc:interceptor>
        <!--mapping:哪些路径需要经过拦截器 /**: 表示n层路径 /*:表示一层路径 -->
        <mvc:mapping path="/**"/>
        <!--exclude-mapping:设置不经过该拦截的路径-->
        <mvc:exclude-mapping path="/img/*"/>
        <mvc:exclude-mapping path="/css/**"/>
        <mvc:exclude-mapping path="/js/**"/>
        <!--bean表示你自定义的拦截器类路径-->
        <bean class="com.aotmd.test.LoggerInterceptor"/>
    </mvc:interceptor>
</mvc:interceptors>
```

对应的代码是：

```java
@Bean
WebMvcConfigurer createWebMvcConfigurer(@Autowired HandlerInterceptor[] interceptors) {
    return new WebMvcConfigurer() {
		...
        public void addInterceptors(InterceptorRegistry registry) {
            for (var interceptor : interceptors) {
                registry.addInterceptor(interceptor)
                        .addPathPatterns("/**")
                        .excludePathPatterns("/img/*", "/css/**", "/js/**");
            }
        }
    };
}
```



## 处理异常

在Controller中，Spring MVC还允许定义基于`@ExceptionHandler`注解的异常处理方法：

```java
@Controller
public class UserController {
    @ExceptionHandler(RuntimeException.class)
    public ModelAndView handleUnknowException(Exception ex) {
        return new ModelAndView("500.html", Map.of("error", ex.getClass().getSimpleName(), "message", ex.getMessage()));
    }
    ...
}
```

异常处理方法没有固定的方法签名，可以传入`Exception`、`HttpServletRequest`等，返回值可以是`void`，也可以是`ModelAndView`，上述代码通过`@ExceptionHandler(RuntimeException.class)`表示当发生`RuntimeException`的时候，就自动调用此方法处理。

这里返回了一个新的`ModelAndView`，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。

也可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理`LoginException`使得页面可以自动跳转到登录页。

使用`ExceptionHandler`时，要注意它**仅作用于当前的Controller**，即ControllerA中定义的一个`ExceptionHandler`方法对ControllerB不起作用。

要在所有Controller生效可以使用`@ControllerAdvice`注解。

`@ControllerAdvice`用于定义全局控制器增强（Global Controller Advice）类。它允许在多个控制器中共享相同的异常处理逻辑、数据绑定和其他通用的控制器功能。

使用`@ControllerAdvice`注解的类可以包含以下类型的方法：

1. 异常处理方法：使用`@ExceptionHandler`注解的方法可以处理控制器中抛出的特定异常。这些方法可以根据异常类型来定义处理逻辑，并返回适当的响应。

2. 模型属性方法：使用`@ModelAttribute`注解的方法可以在每个请求处理方法之前添加模型属性。这些属性可以在多个控制器中共享，并在视图中使用。

3. 绑定参数预处理方法：使用`@InitBinder`注解的方法可以在请求处理方法之前对请求参数进行预处理。这可以包括数据绑定、格式化和验证等操作。

`@ControllerAdvice`类可以应用于整个应用程序，或者可以通过指定特定的包或控制器来限定其作用范围。

以下是一个使用`@ControllerAdvice`注解的示例：

```java
@ControllerAdvice
public class GlobalControllerAdvice {

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleException(Exception ex) {
        // 处理异常逻辑
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Internal Server Error");
    }

    @ModelAttribute
    public void addCommonAttributes(Model model) {
        // 添加共享的模型属性
        model.addAttribute("appName", "MyApp");
    }

    @InitBinder
    public void initBinder(WebDataBinder binder) {
        // 预处理请求参数
        binder.registerCustomEditor(LocalDate.class, new CustomLocalDateEditor());
    }
}
```

在上面的示例中，`GlobalControllerAdvice`类使用`@ControllerAdvice`注解进行标注。它包含了一个异常处理方法`handleException`，一个模型属性方法`addCommonAttributes`，以及一个参数预处理方法`initBinder`。这些方法可以在整个应用程序中的多个控制器中共享，并提供统一的处理逻辑和功能。

通过使用`@ControllerAdvice`注解，可以将这些通用的控制器增强逻辑集中到一个类中，以提高代码的可维护性和重用性。







