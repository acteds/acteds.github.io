---
layout: post
title: Spring
categories: Java
description: Java笔记
keywords: Java
---

# 引言

Spring框架笔记。



# Spring

Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。

Spring Framework主要包括几个模块：

- 支持IoC和AOP的容器；
- 支持JDBC和ORM的数据访问模块；
- 支持声明式事务的模块；
- 支持基于Servlet的MVC开发；
- 支持基于Reactive的Web开发；
- 以及集成JMS、JavaMail、JMX、缓存等其他模块。

## IoC

容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。

通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。

Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

IoC全称Inversion of Control，直译为控制反转。

假定一个在线书店，通过`BookService`获取书籍：

```java
public class BookService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public Book getBook(long bookId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return book;
        }
    }
}
```

为了从数据库查询书籍，`BookService`持有一个`DataSource`。为了实例化一个`HikariDataSource`，又不得不实例化一个`HikariConfig`。

现在，继续编写`UserService`获取用户：

```java
public class UserService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public User getUser(long userId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return user;
        }
    }
}
```

因为`UserService`也需要访问数据库，因此，不得不也实例化一个`HikariDataSource`。

上述每个组件都采用了一种简单的通过`new`创建实例并持有的方式。会有以下缺点：

1. 实例化一个组件其实很难，例如，`BookService`和`UserService`要创建`HikariDataSource`，实际上需要读取配置，才能先实例化`HikariConfig`，再实例化`HikariDataSource`。
2. 没有必要让`BookService`和`UserService`分别创建`DataSource`实例，完全可以共享同一个`DataSource`，但谁负责创建`DataSource`，谁负责获取其他组件已经创建的`DataSource`，不好处理。
3. 很多组件需要销毁以便释放资源，例如`DataSource`，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？
4. 测试某个组件，例如`BookService`，是复杂的，因为必须要在真实的数据库环境下执行。

如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

因此，核心问题是：谁负责创建组件？谁负责根据依赖关系组装组件？销毁时，如何按依赖顺序正确销毁？解决这一问题的核心方案就是IoC。

传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：

`CartServlet`创建了`BookService`，在创建`BookService`的过程中，又创建了`DataSource`组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。

在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，`BookService`自己并不会创建`DataSource`，而是等待外部通过`setDataSource()`方法来注入一个`DataSource`：

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

不直接`new`一个`DataSource`，而是注入一个`DataSource`，这个小小的改动虽然简单，却带来了一系列好处：

1. `BookService`不再关心如何创建`DataSource`，因此，不必编写读取数据库配置之类的代码；
2. `DataSource`实例被注入到`BookService`，同样也可以注入到`UserService`，因此，共享一个组件非常简单；
3. 测试`BookService`更容易，因为注入的是`DataSource`，可以使用内存数据库，而不是真实的MySQL配置。

IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。

因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为`dataSource`的组件通过属性`dataSource`（即调用`setDataSource()`方法）注入到另外两个组件中。

依赖注入可以通过`set()`方法实现，也可以通过构造方法实现。

把`BookService`改造为通过构造方法注入，那么实现代码如下：

```java
public class BookService {
    private DataSource dataSource;

    public BookService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。

在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：

1. 应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；
2. 测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。

### IoC装配

首先引入依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

测试代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

编写一个特定的`application.xml`配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="b" class="com.aotmd.test.B" />
    <bean id="a" class="com.aotmd.test.A" >
        <constructor-arg index="0" ref="b"/>
    </bean>
</beans>
```

------

### Bean的配置

在 Spring中，XML配置文件的根元素是`< beans>`，其下包含了`<bean>`子元素，每个`<bean>`子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中。

`<bean>`元素中包含了多个*属性*。其常用属性如下：

| **属性** | **解释**                           |
| -------- | ---------------------------------- |
| id       | 实例化对象名称                     |
| name     | 可以为bean指定多个名称，用逗号分隔 |
| class    | 类文件的全局名称                   |
| scope    | 实例的生存空间或有效范围           |

`<bean>`元素中同样包含了多个*子*元素，其子元素如下

`constructor-arg`、`property`、`ref`、`value`、`list`、`set`、`map`、`entry`

### Bean的实例化

**构造方法实例化，使用类的无参数构造创建**

```java
<bean id="testdemo" class="dao.TestDemo"></bean>
```

**使用静态工厂实例化**

```java
<bean id="b2" class="SpringBean.Factory" factory-method="newBean"/>
```

参数：id 实例化对象名称，class 静态工厂绝对名称，factory-method 工厂的静态方法名称

```java
public class Factory {
    public static Bean newBean() {return new Bean();}
    public static void main(String[] args) {
        ApplicationContext ap=new ClassPathXmlApplicationContext("Factory.xml");
        ap.getBean("b2");
    }
}
class Bean{}
```

**实例工厂实例化**

```java
<bean id="factory" class="SpringBean.Factory" />
<bean id="b3" factory-bean="factory" factory-method="newBean2"/>
```

参数：id 实例化对象名称，factory-bean 实例化的工厂名称，factory-method 工厂的方法名称

```java
public class Factory {
    public Bean newBean2() {return new Bean();}
    public static void main(String[] args) {
        ApplicationContext ap=new ClassPathXmlApplicationContext("Factory.xml");
        ap.getBean("b3");
    }
}
class Bean{}
```

### 注入方式

对于构造方法注入，通过设置`constructor-arg`标签完成：

`constructor-arg`参数:`type` 形参类型，`name` 形参变量名，`value` 属性值，`ref` 引用实例对象，`index` 索引值。

```xml
<bean id="b" class="com.aotmd.test.B" />
<bean id="a" class="com.aotmd.test.A" >
    <constructor-arg index="0" ref="b"/>
</bean>
```

- 每个`<bean ...>`都有一个`id`标识，相当于Bean的唯一ID；
- 在`a`Bean中，通过`<constructor-arg index="0" ref="b"/>`以**构造方法注入**了另一个`b`Bean；
- Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。

把上述XML配置文件用Java代码写出来，就像这样：

```java
B b=new B();
A a=new A(b);
```

只不过Spring容器是通过读取XML文件后使用反射完成的。

其实这里不写`constructor-arg`，也可以，在 Spring XML 配置文件中，如果类 `A` 只有**一个构造函数**，并且这个构造函数需要一个 `B` 类型的参数，Spring 会自动匹配并注入所需的依赖。因此，如果只有一个构造函数并且只有一个参数类型可以匹配，则**可以省略** `<constructor-arg>` 标签。



还可以使用c命名空间简化注入,对应`constructor-arg`。

`beans`标签添加属性: `xmlns:c="http://www.springframework.org/schema/c"`。

使用c命名空间，直接在bean添加参数：

```java
<bean id="a1" class="com.aotmd.test.A" c:_0-ref="b"/>
<bean id="a2" class="com.aotmd.test.A" c:b-ref="b"/>
```

`c:_索引值` 对应 `index="索引值"`， 加`-ref`表示引用实例对象

`c:形参变量名` 对应 `name="形参变量名"`,加`-ref`表示引用实例对象，不加则是设置普通数据类型，上面的式子如果不加，则`"b"`视为字符串。

需要注意的是`c:b-ref`这种方式只对以debug方式编译的class有效，因为对于非debug方式编译的class文件Spring将无法获取到对应构造方法的`参数名`，因为被优化掉了。之前在JavaWeb有说，可以设置编译器参数：`-parameters`，保留形参变量名。

------

对于set方法注入，通过设置`property`标签完成：

如果要改成**通过`set`方法注入**，则xml修改为：

```xml
<bean id="a" class="com.aotmd.test.A" >
    <property name="b" ref="b"/>
</bean>
```

`property`参数： `name` 变量名，`value` 属性值，`ref` 引用实例对象。



同样的，可以使用p命名空间简化注入,对应`property`。

`beans`标签添加属性: `xmlns:p="http://www.springframework.org/schema/p"`。

使用p命名空间，直接在bean添加参数：

```xml
<bean id="a" class="com.aotmd.test.A" p:b-ref="b"/>
```

`p:变量名` 对应 `name="变量名"`，加`-ref`表示引用实例对象。

注意：`property`对应的是set方法，而**不是**对应的属性。如`name="world"`实际对应`setWorld()`方法，这个时候**不管**是否真的存在名为`world`的属性.

------

### 自动装配

Spring的`<bean>`元素中包含个 `autowire`属性，可通过设置 `autowire`的属性来自动装配Bean。自动装配，就是将一个Bean注入到其他Bean的Property中。autowire属性值及说明如下:

| 属性值      | 说明                                                        |
| ----------- | ----------------------------------------------------------- |
| default     | 默认值。                                                    |
| byName      | 根据 Property的Name自动装配。                               |
| byType      | 根据 Property的数据类型（TYPE）自动装配                     |
| constructor | 根据构造函数参数的数据类型。                                |
| autodetect  | 如果发现默认的构造函数，用constructor模式，否则用byType模式 |
| no          | 不适用自动装配，Bean依赖必须通过ref元素定义。               |

默认情况下，`autowire`属性的默认值为`default`。默认情况下Spring会根据`byName`的方式进行自动装配。如果Spring在容器中找到与属性名相同的Bean，则会将该Bean注入到相应的属性中。如果找不到与属性名相同的Bean，Spring会抛出`NoSuchBeanDefinitionException`异常。



### 注入的类型

如果注入的不是Bean，而是`boolean`、`int`、`String`这样的数据类型，则通过设置`value`注入（构造方法注入同理），例如，创建一个`HikariDataSource`：

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="maximumPoolSize" value="10" />
    <property name="autoCommit" value="true" />
</bean>
```

如果是Map类型，则通过嵌套`map`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="map">
        <map>
            <entry key="1" value="唱"/>
            <entry key="2" value="跳"/>
            <entry key="3" value="RAP" value-type="java.lang.String"/>
        </map>
    </property>
</bean>
```

如果是List类型，则通过嵌套`list`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg ref="b" index="0"/>
    <property name="list">
        <list><value>唱</value><value>跳</value><value>RAR</value></list>
    </property>
</bean>
```

如果是Set类型，则通过嵌套`set`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="set">
        <set><value >唱</value><value>跳</value><value>RAR</value></set>
    </property>
</bean>
```

前面有说name属性对应的是set方法，这里是`"set"`,所以对应`setList`方法，也可以改成其他的名字。

如果是数组，则通过嵌套`array`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="list">
        <array><value>唱</value><value>跳</value><value>RAR</value></array>
    </property>
</bean>
```

实例：

```java
public class Test{
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
class A {
    private B call;

    public A(Map<String,Object> map) {
        this.call = (B) map.get("key1");
        System.out.println(map);
    }

    public void setArray(String[] map) {
        System.out.println(Arrays.toString(map));
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A">
        <constructor-arg index="0">
            <map>
                <entry key="1" value="唱"/>
                <entry key="2" value="跳"/>
                <entry key="3" value="RAP" value-type="java.lang.String"/>
                <entry key="4" value="1" value-type="java.lang.Integer"/>
                <entry key="key1" value-ref="b"/>
            </map>
        </constructor-arg>
        <property name="array">
            <array><value>唱</value><value>跳</value><value>RAR</value></array>
        </property>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

控制台：

```text
{1=唱, 2=跳, 3=RAP, 4=1, key1=com.aotmd.test.B@53de625d}
[唱, 跳, RAR]
hello
```



### ApplicationContext

Spring容器就是`ApplicationContext`，它是一个接口，有很多实现类，这里选择`ClassPathXmlApplicationContext`，表示它会自动从classpath中查找指定的XML配置文件。

获得了`ApplicationContext`的实例，就获得了IoC容器的引用。从`ApplicationContext`中可以根据Bean的ID获取Bean，也可以根据Bean的类型获取Bean的引用：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
A a= appcon.getBean(A.class);
a.hello();
```

Spring还提供另一种IoC容器叫`BeanFactory`，使用方式和`ApplicationContext`类似：

```java
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("application.xml"));
A a = factory.getBean(A.class);
```

`BeanFactory`和`ApplicationContext`的区别在于，`BeanFactory`的实现是**按需创建**，即第一次获取Bean时才创建这个Bean，而`ApplicationContext`会一次性创建所有的Bean。实际上，`ApplicationContext`接口是从`BeanFactory`接口继承而来的，并且，`ApplicationContext`提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，总是使用`ApplicationContext`，很少会考虑使用`BeanFactory`。

------

创建 `ApplicationContext`接口实例通常有三种方法：

**通过`ClassPathXmlApplicationContext`创建**
`ClassPathXmlApplicationContext`将从类路径classPath目录寻找指定的XML配置文件：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
```

**通过`FileSystemXmlApplicationContext`创建**

`FileSystemXmlApplicationContext`将从指定文件的**绝对路径**中寻找XML配置文件，找到并装载完成`ApplicationContext`的实例化工作。采用绝对路径的加载方式将导致程序的灵活性变差， 一般**不推荐使用**。

```java
ApplicationContext appcon=new FileSystemXmlApplicationContext("C:\\XXX\\application.xml");
```

**通过Web服务器实例化`ApplicationContext`容器**

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
```

如果有多个Spring配置文件，则在`param-value`里，以逗号分隔，如果没有定义则默认加载`/WEB-INF/applicationContext.xml`文件，`contextConfigLocation`是参数值，固定不变。

Web服务器实例化`ApplicationContext`容器时，一般使用基于`org.springframework.web.context.ContextLoaderListener`的实现方法只需要在`web.xml`中添加代码:

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
```

需要web依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

使用，首先**获取`ServletContext`**，这里列出几种方法：

```java
ServletContext sc = request.getServletContext();
sc=((HttpServletRequest)request).getSession().getServletContext();
sc=this.getServletContext();
```

普通类获取方法（普通类若不经过服务器调用(如servlet调用)则会报`NullPointerException`）

```java
ServletContext sc = ContextLoader.getCurrentWebApplicationContext().getServletContext();
```

然后**通过`ServletContext`获取`ApplicationContext`：**

```java
ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc);// 这种方法 获取失败时返回null
@SuppressWarnings("unused")
WebApplicationContext ctx=WebApplicationContextUtils.getRequiredWebApplicationContext(sc);// 这种方法 获取失败时抛出异常
ac = WebApplicationContextUtils.getRequiredWebApplicationContext(sc);
```

------

**销毁**

对于手动加载的Spring，`ApplicationContext`怎么销毁:

在非Web应用中，手工加载Spring IoC容器，不能用`ApplicationContext`，要用`AbstractApplicationContext`。用完以后要记得调用`ctx.close()`关闭容器。如果不记得关闭容器，最典型的问题就是数据库连接不能释放。

```java
((AbstractApplicationContext)appcon).close();
```

### 完整实例

```java
@WebServlet("/test")
public class Test extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        // 这种方法 获取失败时返回null
        ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        A a= ac.getBean(A.class);
        a.hello();
    }
}
class A {
    private B call;

    public void setCall(B call) {
        this.call = call;
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A" >
        <property name="call" ref="b"/>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

web.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:application.xml</param-value>
    </context-param>
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
</web-app>
```

### Bean的生命周期

在Spring框架中，Bean的生命周期包括创建（实例化与初始化）、使用以及销毁等阶段。Spring提供了多个接口和配置方式，允许开发者在这三个过程的前后进行操作。在Spring中，实例化是为Bean对象分配内存空间，初始化则是对Bean的属性进行设置。

对于singleton作用域的Bean，Spring容器可以精确地管理其生命周期，包括创建、初始化和销毁。而对于prototype作用域的Bean，Spring只负责创建实例，之后Bean的生命周期由客户端代码管理，Spring容器不再跟踪其状态。

Spring中Bean的生命周期可以参考Servlet的生命周期模型：实例化→初始化→请求处理→销毁。在singleton作用域下，Bean的生命周期包括以下阶段：

1. 根据Bean的配置实例化Bean。
2. 对实例化的Bean进行依赖注入，即对属性进行初始化。
3. 如果Bean实现了`BeanNameAware`接口，将调用其`setBeanName(String beanName)`方法，传递的是Bean在Spring配置文件中的id。
4. 如果Bean实现了`BeanFactoryAware`接口，将调用其`setBeanFactory`方法，传递的是当前Spring工厂实例的引用。
5. 如果Bean实现了`BeanFactoryPostProcessor`接口，将调用其`postProcessBeanFactory()`方法，允许在Bean工厂实例化Bean之前对Bean定义进行修改。实现该接口可以在容器实例化Bean之前对Bean定义进行一些自定义的处理。
6. 如果Bean实现了`ApplicationContextAware`接口，将调用其`setApplicationContext(ApplicationContext)`方法，传递的是Spring上下文实例的引用。
7. 如果Bean实现了`BeanPostProcessor`接口，将调用其`postProcessBeforeInitialization(Object obj, String beanName)`方法，在Bean初始化前对Bean进行操作。
8. 如果Bean实现了`InitializingBean`接口，将调用其`afterPropertiesSet`方法，Bean在属性设置完成后会调用该方法进行初始化操作。
9. 如果Bean在配置文件中配置了`init-method`属性，将自动调用配置的初始化方法。
10. 如果Bean实现了`BeanPostProcessor`接口，将调用其`postProcessBeforeInitialization()`和`postProcessAfterInitialization(Object obj, String beanName)`方法，允许在Bean初始化前后进行一些自定义处理操作。实现该接口可以在Bean初始化前后对Bean进行一些额外的处理。

注意：完成上述工作后，Bean可以被使用。由于是singleton作用域，因此调用的是同一个Bean实例。

10. 当Bean不再需要时，进入销毁阶段。如果Bean实现了`DisposableBean`接口，将调用其`destroy`方法来销毁Bean。
11. 如果在配置文件中通过`destroy-method`属性指定了Bean的销毁方法，将调用配置的销毁方法进行Bean的销毁操作。

在Spring中，通过实现特定接口或配置`<bean>`元素的属性，开发者可以影响Bean的生命周期过程。建议谨慎使用Bean实现接口，以避免过度耦合代码与Spring框架。

## 使用注解

使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，就可以直接从容器中获取Bean使用它们。

使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。

还可以使用Annotation配置，让Spring自动扫描Bean并组装它们。

原代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

xml：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg index="0" ref="b"/>
</bean>
<bean id="b" class="com.aotmd.test.B" />
```

使用注解后：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

`@Component`注解就相当于定义了一个Bean，默认名称为小写开头的类名，可以指定`value`显示设置Bean名称。这里是使用构造方法装配，也可以使用`@Autowired`把指定类型的Bean注入到指定的字段中，它可以写在set方法上，也可以写在字段上，还可以写在构造方法形参上。如：

```java
@Component
class A {
    private B b;

    public A(@Autowired B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
```

一般把`@Autowired`写在字段上：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
}
```

对于xml配置部分，通过标注`@Configuration`，表示`Test`是一个配置类，并且标注`@ComponentScan`告诉容器，自动搜索**当前配置类所在的包以及子包**的注解并装配。因此要特别注意包的层次结构。通常来说，启动配置类要位于自定义的顶层包。当然也可以指定要扫描的包`@ComponentScan("com.aotmd.test")`，这样就不用特定配置类的位置了。

如果不想使用配置类，也可以使用xml扫描注解：

```xml
<context:component-scan base-package="com.aotmd.test"/>
```

常用的装配注解：

| 注解        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| @Component  | 描述Spring中的Bean，但是它时一个泛化的概念，仅仅表示一个组件（Bean）并且可以作用在任何层次； |
| @Repository | 用于将数据访问层（DAO）层的类标识为Spring中的Bean            |
| @Service    | 作用在业务层（service层），用于将业务层的类标识为Spring中的Bean |
| @Controller | 作用在控制层（如Spring MVC 的 controller层），用于将控制层的类标识为Spring中的Bean |
| @Autowired  | 该注解可以对类成员变量、方法及构造方法进行标注，完成自动装配的工作。  通过@Autowired的使用来消除setter 和getter方法。默认按照Bean的**类型进行装配**。 |
| @Resource   | 该注解与@Autowired功能一样。区别在于，该注解默认是按照**名称**来装配注入的，只有当找不到与名称匹配的Bean才会按照类型来装配注入； @Resource注解有两个属性；name和type。name属性指定Bean实例名称，即按照名称来装配注入；type属性指定Bean类型，即按照Bean的类型进行装配 |
| @Qualifier  | 该注解与@Autowired注解配合使用。当@Autowired注解需要按照**名称**来装配注入，则需要结合该注解一起使用，Bean的实例名称由@Qualifier注解的参数指定。 |

注意: @Component @Repository @Service @Controller 注解默认无参数生成的Bean是**首字母小写**的类名,但若**类名第一第二都是大写**则将**类名**做为生成的Bean,若类名首字母是小写则一样以类名作为标识符。

上面几个注解中，虽然@Repository、@Service和@Controller等注解的功能与@Component相同，但为了使标注类的用途更加清晰（层次化），在实际开发中推荐使用@Repository标注数据访问层（DA0层）、使用@Service标注业务逻辑层（Service层）以及使用@Controller标注控制器层（控制层）。

### Configuration

`@Configuration`注解用于标识一个类是Spring的配置类，它通常与`@Bean`注解一起使用，用于定义Bean的创建和配置。主要作用包括：

1. **定义Bean**：在配置类中使用`@Bean`注解定义Bean的创建方法，Spring容器会根据这些方法创建相应的Bean实例。
2. **替代XML配置**：`@Configuration`注解可以替代传统的XML配置文件，通过Java类的方式来配置应用程序的Bean。
3. **组件扫描**：`@Configuration`注解通常与`@ComponentScan`注解一起使用，用于启用组件扫描，自动发现和注册Spring的Bean。
4. **条件化配置**：可以结合条件注解如`@ConditionalOnProperty`等，根据条件来决定是否应用某个配置。
5. **AOP支持**：`@Configuration`类中的方法可以使用`@Bean`注解来声明切面等AOP相关的Bean。
6. **配置属性绑定**：可以使用`@Value`注解将配置文件中的属性值注入到`@Configuration`类中的Bean中。

如果没有该注解，也可以正常使用，但它的缺陷是被调用的@Bean方法产生的实例在容器中不是唯一的：

```java
@ComponentScan
public class Test {

    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        appcon.getBean("a1");
        
    }
    @Bean("a1")
    A getA(){
        System.out.println(getB() == getB()); //结果是false，说明每调用一次getB()都会产生新的实例。加上@Configuration之后结果就是true了。
        return new A();
    }

    @Bean
    B getB(){
        return new B();
    }
    static class A{}
    static class B{}
}
```

### Prototype

对于Spring容器来说，把一个Bean标记为`@Component`后，它就会自动创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，调用`getBean(Class)`获取到的Bean总是同一个实例。

还有一种Bean，每次调用`getBean(Class)`，容器都返回一个**新的实例**，这种Bean称为Prototype（原型），它的生命周期和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的`@Scope`注解：

```java
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//"prototype"
```

即：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a1= (A)appcon.getBean("a");//test为配置文件中的id
        A a2= (A)appcon.getBean("a");//test为配置文件中的id
        System.out.println(a1==a2);//false
    }
}
/*默认bean名称为首字母小写*/
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)//"prototype"
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

具体来说有如下几个作用域：

| **作用域名称**  | **描述**                                                     |
| --------------- | ------------------------------------------------------------ |
| **singleton**   | 默认的作用域，使用singleton定义的Bean在Spring容器中只有一个Bean实例。 |
| **prototype**   | Spring容器每次获取prototype定义的Bean，容器都将创建一个新的Bean实例。 |
| **request**     | 在一次HTTP请求中容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **session**     | 在一个HTTP Session中，容器将返回同一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **application** | 为每个ServletContext对象创建一个实例，即同一个应用共享一个Bean实例。仅在Web Spring应用程序上下文中使用。 |
| **websocket**   | 为每个WebSocket对象创建一个Bean实例。仅在Web Spring应用程序上下文中使用。 |

### 注入List

有些时候，会有一系列接口相同，不同实现类的Bean。例如，注册用户时，要对`email`、`password`和`name`这3个变量进行验证。为了便于扩展，先定义验证接口：

```java
interface Validator {
    void validate(User user);
}
```

然后，分别使用3个`Validator`对用户参数进行验证：

```java
@Component
class EmailValidator implements Validator {
    public void validate(User user) {
        if (!user.email.matches("^[a-z0-9]+@[a-z0-9]+\\.[a-z]{2,10}$")) {
            throw new IllegalArgumentException("invalid email: " + user.email);
        }
    }
}

@Component
class PasswordValidator implements Validator {
    public void validate(User user) {
        if (!user.password.matches("^.{6,20}$")) {
            throw new IllegalArgumentException("invalid password");
        }
    }
}

@Component
class NameValidator implements Validator {
    public void validate(User user) {
        if (user.name == null || user.name.trim().isEmpty() || user.name.length() > 20) {
            throw new IllegalArgumentException("invalid name: " + user.name);
        }
    }
}
```

最后，通过一个`Validators`作为入口进行验证：

```java
@Component
class Validators {
    @Autowired
    List<Validator> validators;

    public void validate(User user) {
        for (var validator : this.validators) {
            validator.validate(user);
        }
    }
}
```

启动：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        Validators validators= (Validators)appcon.getBean("validators");
        User user = new User("123@qq.com", "123123", "45ddf");
        validators.validate(user);
    }
}
```

`Validators`被注入了一个`List<Validator>`，Spring会自动把所有类型为`Validator`的Bean装配为一个`List`注入进来，这样一来，每新增一个`Validator`类型，就自动被Spring装配到`Validators`中了，非常方便。

因为Spring是通过扫描classpath获取到所有的Bean，而`List`是有序的，要指定`List`中Bean的顺序，可以加上`@Order`注解：

```java
@Order(1)
@Component
class EmailValidator implements Validator {}
@Order(2)
@Component
class PasswordValidator implements Validator {}
@Order(3)
@Component
class NameValidator implements Validator {}
```

### 可选注入

默认情况下，当标记了一个`@Autowired`后，Spring如果没有找到对应类型的Bean，它会**抛出`NoSuchBeanDefinitionException`异常**。可以给`@Autowired`增加一个`required = false`的参数，表示如果找不到就忽略，不抛出异常。这种方式非常适合有定义就使用定义，没有就使用默认值的情况。实例：

```java
@Component
class A {
    @Autowired(required = false)
    private B b;
    
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

### 创建第三方Bean

如果想给`A`注入`HikariDataSource`，但是这个类位于`com.zaxxer.hikari`包中，并且`HikariDataSource`也不可能有`@Component`注解，如何告诉IoC容器创建并配置`HikariDataSource`？

当然是在`@Configuration`类中编写一个Java方法创建并返回它，并注意给方法标记一个`@Bean`注解，这个方法返回一个`HikariDataSource`实例：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.jdbc();
    }
    @Bean(name = "dataSource")
    public HikariDataSource getDataSource(){
        Properties props = new Properties();
        props.setProperty("jdbcUrl","jdbc:mysql://localhost:3306/studentdb?characterEncoding=utf-8&serverTimezone=GMT%2B8&useSSL=false");
        props.setProperty("username","root");
        props.setProperty("password","123456");
        HikariConfig config = new HikariConfig(props);
        config.addDataSourceProperty("cachePrepStmts", "true");
        return new HikariDataSource(config);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private HikariDataSource dataSource;
    public void jdbc(){
        try(Connection connection = dataSource.getConnection()) {
            ResultSet resultSet = connection.prepareStatement("select name from student").executeQuery();
            while (resultSet.next()){
                System.out.println(resultSet.getString("name"));
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```

Spring对标记为`@Bean`的方法只调用一次，因此返回的Bean仍然是单例。

### 初始化和销毁

有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。通常会定义一个`init()`方法进行初始化，定义一个`shutdown()`方法进行清理，需要引入JSR-250定义的Annotation。

```xml
<dependency>
    <groupId>javax.annotation</groupId>
    <artifactId>javax.annotation-api</artifactId>
    <version>1.2</version>
</dependency>
```

然后在Bean的初始化和清理方法上标记`@PostConstruct`和`@PreDestroy`：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
    @PostConstruct
    public void init() {
        System.out.println("Init");
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("Shutdown");
    }
}
```

Spring容器会对上述Bean做如下初始化流程：

- 调用构造方法创建`A`实例；
- 根据`@Autowired`进行注入；
- 调用标记有`@PostConstruct`的`init()`方法进行初始化。

而销毁时，容器会首先调用标记有`@PreDestroy`的`shutdown()`方法。

Spring只根据Annotation查找**无参数**方法，对方法名不作要求。

如果shutdown() 没有调用，则需要手动调用`applicationContext.close()`，而不是等待进程结束。

在Spring框架中，Bean的生命周期经历了多个阶段，包括实例化、属性赋值、初始化、使用和销毁等过程。以下是典型的Bean生命周期：

1. **实例化（Instantiation）**：在这个阶段，Spring容器根据Bean的定义创建Bean的实例。

2. **属性赋值（Populate Properties）**：在实例化之后，Spring容器会根据配置文件或注解对Bean的属性进行赋值，包括基本类型的注入、引用类型的注入等。

3. **初始化（Initialization）**：在属性赋值完成之后，Spring容器会调用Bean的初始化方法（如果有定义的话），可以通过`@PostConstruct`注解或实现`InitializingBean`接口来定义初始化方法。

4. **使用（In Use）**：在初始化完成之后，Bean就可以被应用程序使用了，它会被注入到其他Bean中，或者被直接使用。

5. **销毁（Destruction）**：在Bean不再需要的时候，Spring容器会调用Bean的销毁方法（如果有定义的话），可以通过`@PreDestroy`注解或实现`DisposableBean`接口来定义销毁方法。



### 使用别名

默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个`DataSource`实例。

如果在`@Configuration`类中创建了多个同类型的Bean，在Spring 5.0之前的版本中，Spring会报`NoUniqueBeanDefinitionException`异常，意思是出现了重复的Bean定义。从Spring 5.0开始，默认情况下，Spring允许存在多个同类型的Bean定义，并且不会抛出异常。相反，它会将这些Bean注册为一个集合类型的Bean。

要避免这个异常，可以指定不同的名称：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
    @Bean("b1")
    public B b(){
        return new B();
    }
    @Bean("b2")
    public B b2(){
        return new B();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Qualifier("b1")
    @Autowired
    private B b;
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

可以用`@Bean("name")`指定别名，也可以用`@Bean`+`@Qualifier("name")`指定别名。

其实Bean的`name`默认就是方法名称。

### 注入选择问题

存在多个同类型的Bean时，注入时又会报错，即不知道注入哪个，因此要通过`@Qualifier("b1")`指定注入的Bean名称。

```java
@Component
class A {
    @Qualifier("b1")
    @Autowired
    private B b;
    public void hello(){
        b.hello();
    }
}
```

这里也可以把两个注解换成 `@Resource(name = "b1")`。

还可以把待注入的**变量名称**改为Bean名称，这样也可以指定注入的Bean名称：

```java
@Component
class A {
    @Autowired
    private B b1;
    public void hello(){
        b1.hello();
    }
}
```

也可以通过使用`@Primary`指定某个Bean，在注入时，如果没有指出Bean的名字，Spring会注入标记有`@Primary`的Bean。

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
    @Primary
    @Bean("b1")
    public B b(){
        return new B();
    }
    @Bean("b2")
    public B b2(){
        return new B();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private B b;//默认注入b1
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

若使用Spring boot，还能根据配置属性的值来决定是否应用这个配置。即注解：

```java
@Configuration
@ConditionalOnProperty(prefix = "class", name = "select", havingValue = "B")
class B｛｝
```

- `@Configuration`：注解表示这是一个配置类，它会被Spring容器扫描并加载。
- `@ConditionalOnProperty`：注解用于根据配置属性的值来决定是否应用这个配置。它有几个参数：
  - `prefix`：配置属性的前缀。在这个例子中，配置属性的前缀是`class`。
  - `name`：配置属性的名称。在这个例子中，配置属性的名称是`select`。
  - `havingValue`：期望的配置属性值。在这个例子中，期望的配置属性值是`B`。

如果满足了以上条件，即配置属性`class.select`的值为`B`，那么这个配置类中的配置将会生效。否则，这个配置类中的配置将会被忽略。

### 使用FactoryBean

用工厂模式创建Bean需要实现`FactoryBean`接口：

```java
@Component
class BFactoryBean implements FactoryBean<B>{

    @Override
    public B getObject() throws Exception {
        return new B();
    }

    @Override
    public Class<?> getObjectType() {
        return B.class;
    }
}
```

当一个Bean实现了`FactoryBean`接口后，Spring会先实例化这个工厂，然后调用`getObject()`创建真正的Bean。`getObjectType()`可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。

因此，如果定义了一个`FactoryBean`，要注意Spring创建的Bean实际上是这个`FactoryBean`的`getObject()`方法返回的Bean。为了和普通Bean区分，通常都以`XxxFactoryBean`命名。

由于可以用`@Bean`方法创建第三方Bean，本质上`@Bean`方法就是工厂方法，所以，`FactoryBean`已经用得越来越少了。











### 使用Resource

在Java程序中，经常会读取配置文件、资源文件等。使用Spring容器时，也可以把“文件”注入进来，方便程序读取。

例如，AppService需要读取`logo.txt`这个文件，通常情况下，需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。

Spring提供了一个`org.springframework.core.io.Resource`（注意不是`jarkata.annotation.Resource`或`javax.annotation.Resource`），它可以像`String`、`int`一样使用`@Value`注入：

```java
@Component
class A {
    @Value("classpath:/application.xml")
    private Resource resource;
    public void printResource(){
        try (var reader = new BufferedReader(
                new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) {
            System.out.println(reader.lines().collect(Collectors.joining("\n")));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

注入`Resource`最常用的方式是通过classpath，即类似`classpath:/application.xml`表示在classpath中搜索`application.xml`文件，然后，直接调用`Resource.getInputStream()`就可以获取到输入流，避免了自己搜索文件的代码。

也可以直接指定文件的路径，例如：

```java
@Value("file:D:/application.xml")
```

### 注入配置

在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以`key=value`的形式写在`.properties`文件中。

例如，`MailService`根据配置的`app.zone=Asia/Shanghai`来决定使用哪个时区。要读取配置文件，可以使用上一节的`Resource`来读取位于classpath下的一个`app.properties`文件。但是，这样仍然比较繁琐。

Spring容器还提供了一个更简单的`@PropertySource`来自动读取配置文件。只需要在`@Configuration`配置类上再添加一个注解：

```java
@Configuration
@ComponentScan
@PropertySource("classpath:app.properties")
public class Test {
    @Value("${app.zone:Z}")
    String zoneId;
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        appcon.getBean(ZoneId.class);
        appcon.getBean(A.class).print();

    }
    @Bean
    ZoneId createZoneId(){
        System.out.println(zoneId);
        return ZoneId.of(zoneId);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Value("${app.zone:Z}")
    String zoneId;
    void print(){
        System.out.println(zoneId);
    }
}
```

app.properties：

```properties
app.zone=Asia/Shanghai
```

Spring容器看到`@PropertySource("app.properties")`注解后，自动读取这个配置文件，然后，使用`@Value`正常注入。

注入的字符串语法，它的格式如下：

- `"${app.zone}"`表示读取key为`app.zone`的value，如果key不存在，启动将报错；
- `"${app.zone:Z}"`表示读取key为`app.zone`的value，但如果key不存在，就使用默认值`Z`。

这样一来，就可以根据`app.zone`的配置来创建`ZoneId`。

还可以把注入的注解写到方法参数中：

```java
@Bean
ZoneId createZoneId(@Value("${app.zone:Z}") String zoneId){
    System.out.println(zoneId);
    return ZoneId.of(zoneId);
}
```

使用`@PropertySource`读取配置文件，然后通过`@Value`以`${key:defaultValue}`的形式注入，可以极大地简化读取配置的麻烦。

另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个`SmtpConfig`：

```java
@Component
class AppConfig {
    @Value("${app.zone:Z}")
    private String zoneId;

    public String getZoneId() {
        return zoneId;
    }
}
```

然后，在需要读取的地方，使用`#{appConfig.zoneId}`注入：

```java
@Bean
ZoneId createZoneId(@Value("#{appConfig.zoneId}") String zoneId){
    System.out.println(zoneId);
    return ZoneId.of(zoneId);
}
```

`#{}`这种注入语法，和`${key}`不同的是，`#{}`表示从JavaBean读取属性。`"#{appConfig.zoneId}"`的意思是，从名称为`appConfig`的Bean读取`zoneId`属性，即调用`getZoneId()`方法。

使用一个独立的JavaBean持有所有属性，然后在其他Bean中以`#{bean.property}`注入的好处是，多个Bean都可以引用同一个Bean的某个属性。如果`appConfig`决定从数据库中读取相关配置项，那么`createZoneId`注入的`@Value("#{appConfig.zoneId}")`仍然可以不修改正常运行。

### 使用条件装配

开发应用程序时，会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。

Spring为应用程序准备了Profile这一概念，用来表示不同的环境。分别定义开发、测试和生产这3个环境：

- native
- test
- production

创建某个Bean时，Spring容器可以根据注解`@Profile`来决定是否创建。例如，以下配置：

```java
@Configuration
@ComponentScan
public class AppConfig {
    @Bean
    @Profile("!test")
    ZoneId createZoneId() {
        return ZoneId.systemDefault();
    }

    @Bean
    @Profile("test")
    ZoneId createZoneIdForTest() {
        return ZoneId.of("America/New_York");
    }
}
```

如果当前的Profile设置为`test`，则Spring容器会调用`createZoneIdForTest()`创建`ZoneId`，否则，调用`createZoneId()`创建`ZoneId`。注意到`@Profile("!test")`表示非test环境。

在运行程序时，加上JVM参数`-Dspring.profiles.active=test`就可以指定以`test`环境启动。

实际上，Spring允许指定多个Profile，例如：

```cmd
-Dspring.profiles.active=test,master
```

可以表示`test`环境，并使用`master`分支代码。要满足多个Profile条件，可以这样写：

```java
@Bean
@Profile({ "test", "master" }) // 满足test或master
ZoneId createZoneId() {
    ...
}
```

**使用Conditional**

除了根据`@Profile`条件来决定是否创建某个Bean外，Spring还可以根据`@Conditional`决定是否创建某个Bean。添加如下注解：

```java
@Bean("a1")
@Conditional(MainCondition.class)
A getA(){
    return new A();
}
```

它的意思是，如果满足`MainCondition`的条件，才会创建`a1`这个Bean。

```java
class MainCondition implements Condition{
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    	return false;
    }
}
```

这里直接返回`false`，因此Bean`a1`始终不会创建。

Spring只提供了`@Conditional`注解，具体判断逻辑还需要我们自己实现。

Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在`app.smtp=true`，则创建`a1`：

```java
@Bean("a1")
@ConditionalOnProperty(name="app.smtp", havingValue="true")
A getA(){
    return new A();
}
```

`@ConditionalOnProperty`是Spring Boot框架中的一个条件注解，用于根据属性的存在与否以及属性值来决定是否应该创建一个Bean。该注解有以下参数：

1. `name`：要检查的属性名。指定要检查的应用程序属性的名称。如果未指定`prefix`，则将直接检查指定名称的属性。如果指定了`prefix`，则会在`prefix`后面加上`.`再加上`name`来构成完整的属性名。

2. `havingValue`：属性必须具有的值。指定属性必须具有的值才能满足条件。默认值为空字符串。

3. `matchIfMissing`：如果属性不存在时是否应该匹配。指定当属性不存在时是否应该认为条件匹配。默认值为`false`，即属性不存在时条件不匹配。

4. `prefix`：属性名的前缀。指定属性名的前缀，用于构成完整的属性名。

5. `value`：属性的值。与`havingValue`参数相同，用于指定属性必须具有的值。

通过使用这些参数，可以根据应用程序的配置属性来动态地确定是否创建某个Bean。根据属性名、属性值、属性是否存在以及是否匹配等条件，可以灵活地控制Bean的创建过程。

如果当前classpath中存在类`javax.mail.Transport`，则创建`a1`：

```java
@Bean("a1")
@ConditionalOnClass(name = "javax.mail.Transport")
A getA(){
    return new A();
}
```

使用条件注解，能更灵活地装配Bean。



## AOP

AOP ( Aspect-Oriented Programming ）即面向切面编程，它与OOP (Object-Oriented Programming ， 面向对象编程）相辅相成，提供了与OOP 不同的抽象软件结构的视角。在OOP 中，以类作为程序的基本单元，而AOP 中的基本单元是Aspect（切面）。

在业务处理代码中通常有日志记录、性能统计、安全控制、事务处理、异常处理等操作。尽管使用OOP 可以通过封装或继承的方式达到代码的重用，但仍然有同样的代码分散在各个方法中。

因此， 采用OOP 处理日志记录等操作不仅**增加**了开发者的工作量，而且提高了升级维护的困难。为了解决此类问题， AOP 思想应运而生。

AOP 采取横向抽取机制，即将分散在各个方法中的重复代码**提取**出来，然后在程序**编译或运行阶段**将这些抽取出来的代码**应用到**需要执行的地方。这种横向抽取机制采用传统的OOP 是无法办到的，因为OOP 实现的是父子关系的纵向重用。但是**AOP 不是OOP 的替代品，而是OOP 的补充**，它们相辅相成。

------

**AOP的术语**

在SpringAOP框架中涉及以下常用术语。

切面（Aspect）：是指封装横切到**系统功能**（例如事务处理）的类。(通知方法的类)

连接点（Ooinpoint）：是指程序运行中的一些**时间点**，例如方法的调用或异常的抛出。(方法调用,或异常)，即定义在应用程序流程的何处插入切面的执行；

切入点（CPointcut）：是指**需要处理的连接点**。在SpringAOP中，**所有的方法执行**都是连接点，而切入点是一个描述信息，它修饰的是连接点，通过切入点**确定**哪些连接点需要被**处理**。(被处理的类的方法)

通知（Advice）：是由切面添加到特定的连接点（满足切入点规则）的一段代码，即在定义好的切入点处所要**执行**的**程序代码**，可以将其理解为切面开启后切面的方法，因此通知是切面的具体实现。(增强处理的代码)

引入（Introduction）：允许在现有的**实现类**中**添加**自定义的方法和属性。(增强类的方法与属性)

目标对象（TargetObject）：是指所有被通知的对象，即应用切面的原始对象或原始类。如果AOP框架使用运行时代理的方式（动态的AOP）来实现切面，那么通知对象总是一个**代理对象**。(要代理的对象Bean)

代理（Proxy）：是通知应用到目标对象**之后**被**动态创建的对象**。(被代理后动态生成的对象Bean)

织入（Weaving）：是**将切面代码插入到目标对象**上，**从而生成代理对象的过程**。根据不同的实现技术，AOP织入有3种方式：
- 编译期织入，需要有特殊的Java编译器；
- 类装载期织入，需要有特殊的类装载器；
- 动态代理织入，在运行期为目标类添加通知生成子类的方式。

SpringAOP框架默认采用**动态代理**织入，而AspectJ（基于Java语言的AOP框架）采用编译期织入和类装载期织入。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过[CGLIB](https://github.com/cglib/cglib)或者[Javassist](https://www.javassist.org/)这些第三方库实现。(代理对象生成的过程)



AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。

需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。

使用代理模式的简单示例：

```java
class Test2{
    public static void main(String[] args) {
        A a=new AProxy();
        a.func1();
    }
}
class A{
    void func1(){
        System.out.println("func1");
    }
    void func2(){
        System.out.println("func2");
    }
    void func3(){
        System.out.println("func3");
    }
}
class AProxy extends A{
    @Override
    void func1() {
        System.out.println("执行一些代码");
        super.func1();
        System.out.println("执行一些代码");
    }

    @Override
    void func2() {
        System.out.println("执行一些代码");
        super.func2();
        System.out.println("执行一些代码");
    }

    @Override
    void func3() {
        System.out.println("执行一些代码");
        super.func3();
        System.out.println("执行一些代码");
    }
}
```

通过创建一个名为`AProxy`的子类来实现对`A`类的方法进行增强，这可以被认为是一种简单的AOP实现方式。在`AProxy`中，重写了`A`类的各个方法，并在方法的前后插入了额外的逻辑。

虽然这种方式实现了对`A`类方法的增强，但它并不是典型的AOP实现方式。在典型的AOP框架中，切面逻辑是通过配置或注解来定义的，而不是通过创建子类来重写方法。AOP框架通常会使用动态代理或字节码生成等技术来实现切面逻辑的动态织入，而不是在代码中显式地创建代理类。

------

### 对类进行增强

#### 基于XML实现

首先添加依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.7</version>
</dependency>
```

或：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

要通过XML配置AOP，需要使用以下几个标签：

`<aop:config>`：这个标签用于配置AOP的相关信息，包括切面、通知等。

`<aop:aspect>`：这个标签用于定义一个切面（Aspect），其中`ref`属性指定了切面的实例引用，即切面对象的名称或引用。

在Spring AOP中，切面（Aspect）是一个普通的Java类，它通常包含通知（Advice）和切点（Pointcut）的定义。切面类并不需要实现特定的接口或继承特定的类，只需要符合Spring AOP的约定即可。通常情况下，一个切面类会包含以下内容：

- 通知（Advice）：定义了在连接点执行的具体操作，比如前置通知、后置通知、环绕通知等。
- 切点（Pointcut）：定义了在目标对象的哪些方法上执行通知。
- 引入（Introduction）：引入新的接口或方法到目标对象中。

`<aop:declare-parents>`：这个标签用于声明引入（Introduction）的相关信息，即在目标对象中引入新的接口或实现类。具有如下属性：

| **属性**             | **解释**                                  |
| -------------------- | ----------------------------------------- |
| `types-matching`     | AspectJ类型表达式，所限制的类可加"+*.."号 |
| `implement-interfac` | 将引入的接口的标准名称                    |
| `default-impl`       | 将引入接口的实现类的完全限定名称          |
| `delegate-ref`       | 将引入接口的实现类的Bean名称(实例化的)    |

**目标**是`types-matching`的类，spring让它实现`implement-interface`所指向的**接口**，而具体实现则通过`default-impl`或`delegate-ref`属性来赋予。让 `types-matching` 的类添加了**接口**并且指定了**实现**。

对类进行增强实例：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext ac=new ClassPathXmlApplicationContext("application.xml");
        A a= ac.getBean(A.class);
        a.print();
        System.out.println(a.getClass().getName());
        I i=(I)a;
        i.test();
    }
}
class A{
    public void print(){
        System.out.println("飞行");
    }
}
interface I{
    void test();
}
class B implements I{
    @Override
    public void test() {
        System.out.println(getClass().getName());
    }
}
class Aspect{}
```

XML：

```xml
<bean id="a" class="com.aotmd.test.A"/><!--目标类-->
<bean id="b" class="com.aotmd.test.B"/><!--增强类-->
<bean id="aspect" class="com.aotmd.test.Aspect"/><!--切面类-->
<aop:config>
    <aop:aspect ref="aspect"><!--指向切面类，这里Aspect是空的-->
        <aop:declare-parents types-matching="com.aotmd.test.A" implement-interface="com.aotmd.test.I" default-impl="com.aotmd.test.B"/>
        <!--两种方法，选一个即可：-->
        <aop:declare-parents types-matching="com.aotmd.test.A" implement-interface="com.aotmd.test.I" delegate-ref="b"/>
    </aop:aspect>
</aop:config>
```

控制台：

```text
飞行
com.aotmd.test.A$$EnhancerBySpringCGLIB$$712bcb1a
com.aotmd.test.B
```

在这个示例中，定义了三个bean：`a`、`b`和`aspect`。

- `a`是目标类（Target Class），它是`com.aotmd.test.A`类的实例。
- `b`是增强类（Advice Class），它是`com.aotmd.test.B`类的实例。
- `aspect`是切面类（Aspect Class），它是`com.aotmd.test.Aspect`类的实例。

然后，通过`<aop:config>`配置元素来定义AOP配置。在`<aop:aspect>`元素中，通过`ref="aspect"`将`aspect`切面类引入为切面的实例。

在`<aop:aspect>`元素中，使用了`<aop:declare-parents>`元素来声明引入（Introduction）操作。通过`types-matching`属性指定了`com.aotmd.test.A`类型的类，表示要对`A`类进行引入操作。使用`implement-interface`属性指定了要引入的接口`com.aotmd.test.I`，并使用`default-impl`属性指定了接口的默认实现类`com.aotmd.test.B`。

这样，通过AOP的引入操作，`A`类将会实现`I`接口，并使用`B`类作为接口的默认实现。这样，`A`类就拥有了`I`接口的方法，并且默认实现是`B`类的方法。

这样配置之后，**所有的`A`对象**都会**具有`I`接口的功能**，并默认使用`B`类来实现这个功能。

然后在`Test`类的`main`方法中，通过`ApplicationContext`从XML配置文件中加载了Spring容器，并从容器中获取了`A`类的实例`a`。然后调用了`a`的`print`方法，并打印了`a`的类名。接着，将`a`强制类型转换为`I`接口类型，并调用了`test`方法。

根据AOP配置，`a`的实例`A`被引入了`I`接口，并且默认实现为`B`类。因此，将`a`强制类型转换为`I`接口并调用`test`方法时，实际上会调用`B`类的`test`方法。

从spring容器中拿出来的`a`对象可以被强转换成`I`类型的对象。如果调用`I`的方法必须要强转，因为这些都是spring背后做了很多事情。

------

#### 基于注解

对类进行增强实例：

```java
/*@EnableAspectJAutoProxy:支持处理标有 AspectJ @Aspect 注解的组件，
类似于 Spring 的 XML 元素中的 <aop:aspectj-autoproxy> 功能。
用于 @Configuration 类*/
@Configuration
@ComponentScan
@EnableAspectJAutoProxy
public class Test {
    public static void main(String[] args) {
        ApplicationContext ac=new AnnotationConfigApplicationContext(Test.class);
        A a= ac.getBean(A.class);
        a.print();
        System.out.println(a.getClass().getName());
        I i=(I)a;
        i.test();
    }
}
@Component
class A{
    public void print(){
        System.out.println("飞行");
    }
}
interface I{
    void test();
}
@Component
class B implements I{
    @Override
    public void test() {
        System.out.println(getClass().getName());
        System.out.println(this);
    }
}
/*这里重名了，因此要完全名*/
@org.aspectj.lang.annotation.Aspect
@Component
class Aspect{
    @DeclareParents(value ="com.aotmd.test.A",defaultImpl = B.class)
    public I i;
}
```

控制台：

```text
飞行
com.aotmd.test.A$$EnhancerBySpringCGLIB$$5fdfd7a5
com.aotmd.test.B
com.aotmd.test.B@2fd953a6
```

这里使用了`@EnableAspectJAutoProxy`注解来启用对标记有AspectJ `@Aspect`注解的组件的支持，类似于在Spring XML配置中使用`<aop:aspectj-autoproxy>`元素的功能。这个注解通常用于`@Configuration`类中。通过这个注解，Spring将会自动代理被`@Aspect`注解标记的类，使得切面逻辑能够被织入到目标类中。

`@Aspect`: 这个注解用于标记一个类为切面（Aspect），其中定义了切面的通知（advice）和切点（pointcut）。在上面的代码中，`Aspect`类被标记为切面，用于定义引入操作。

`@DeclareParents`: 这个注解用于在切面中声明引入操作，将新的接口引入到目标类中。在上面的代码中，`Aspect`类使用`@DeclareParents`注解来向`A`类引入`I`接口，并指定`B`类作为默认实现类。

`@DeclareParents`的属性说明:

| **属性**         | **解释**                                    |
| ---------------- | ------------------------------------------- |
| **value**        | AspectJ类型表达式，所限制的类可加"+*.."号   |
| **default-impl** | 将引入接口的实现类的完全限定名称的class实例 |

`@DeclareParents`用在切面类(`@Aspect`)中的需要引入的接口实例上。

注意:切面类(`@Aspect`)需要`@Component`成一个Bean,才能在内部使用`@DeclareParents`。

### 动态代理类型

在Java中有多种动态代理技术，例如JDK、CGLIB、Javassist、ASM，其中最常用的动态代理技术是JDK和CGLIB。目前，在SpringAOP中常用JDK和CGLIB两种动态代理技术。

#### JDK动态代理

JDK动态代理是`java.lang.reflect.*`包提供的方式，它**必须借助**一个**接口**才能产生代理对象。因此，对于使用业务接口的类，Spring默认使用JDK动态代理实现AOP。

JDK中所要进行动态代理的类必须要实现一个接口，也就是说只能对该类所实现接口中定义的方法进行代理，这在实际编程中具有一定的局限性，而且使用反射的效率也并不是很高。

要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成，所以首先要编写用于生成代理对象的类。

java在JDK1.5之后提供了一个`java.lang.reflect.Proxy`类，通过`Proxy`类提供的一个`newProxyInstance`方法用来创建一个对象的代理对象，只需传入目标接口的类加载器、目标接口以及`InvocationHandler`回调接口，便可为**目标接口**生成代理类及代理对象，而且生成的代理类是其接口的实现类。

```java
Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);
```

通过`Proxy.newProxyInstance()`创建`interface`实例，需要3个参数：  

1. 使用的`ClassLoader`，通常就是接口的`ClassLoader`；
2. 需要实现的接口数组，**至少需要传入一个接口进去**；
3. 用来处理接口方法调用的`InvocationHandler`实例。 

返回值为接口实现类的实例。

`InvocationHandler`回调接口有一个方法，对于代理的逻辑方法，**所有动态代理类的方法调用都会交给该回调接口方法处理**，因此不要使用`method.invoke(proxy,args);`代码，这会导致无限递归：

```java
public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable;
```

参数解释：
 * `proxy`：把代理对象自己传递进来。
 * `method`：把代理对象当前调用的方法传递进来可以使用这个参数来获取方法的信息，比如方法名、参数类型等。
 * `args`：方法的参数数组。这个参数包含了方法调用时传入的参数值。
 * `返回值`：返回函数执行的结果，取决于你想返回什么。

通过一般类实现：

```java
public class Test2 {
    public static void main(String[] args) {
        JDKProxy<T> proxy = new JDKProxy<>();//创建生成代理对象的工厂类，同时它也负责InvocationHandler的执行逻辑。
        T t=new TDemo();//创建目标对象
        /*获取增强后的目标对象*/
        T t2= proxy.createProxy(t);
        t2.delete();//任何调用都会传入invoke()回调方法,具体执行逻辑由invoke()决定。
        System.out.println(t.getClass().getName());
        System.out.println(t2.getClass().getName());
    }
}
interface T{
    void save();
    void modify();
    void delete();
}

/**
 * 目标对象
 */
class TDemo implements T{
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
    public void delete2() {System.out.println("删除逻辑2执行");}
}
/**
 * 切面类，可以定义多个通知，即增强处理的方法
 */
class AspectDemo{
    public void check(){System.out.println("模拟权限控制");}
    public void except(){System.out.println("模拟异常处理");}
    public void log(){System.out.println("模拟日志记录");}
    public void monitor(){System.out.println("性能监测");}
}

class JDKProxy<T> implements InvocationHandler {
    /**目标类实例*/
    private T t;
    AspectDemo asp = new AspectDemo();//创建一个切面
    public T createProxy(T t){
        this.t=t;
        ClassLoader cld=t.getClass().getClassLoader();
        Class<?>[] interfaces=t.getClass().getInterfaces();
        return (T) Proxy.newProxyInstance(cld,interfaces,this);
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        asp.check();//前增强
        asp.except();
        System.out.println("转发至代理对象方法:"+method.getName());
        Object obj=method.invoke(t,args);//在目标类实例t上调用方法并传入参数
        asp.log();//后增强
        asp.monitor();
        return obj;
    }
}
```

控制台：

```text
模拟权限控制
模拟异常处理
转发至代理对象方法:delete
删除逻辑执行
模拟日志记录
性能监测
com.aotmd.test.TDemo
com.aotmd.test.$Proxy0
```

使用匿名类，则`JDKProxy`类只负责创建代理实例功能：

```java
class JDKProxy<T> {
    @SuppressWarnings("unchecked")
    public T createProxy(T target){
        ClassLoader cld= target.getClass().getClassLoader();
        Class<?>[] interfaces= target.getClass().getInterfaces();
        return (T) Proxy.newProxyInstance(cld, interfaces, new InvocationHandler() {
            /**切面类，用来增强*/
            final AspectDemo asp = new AspectDemo();
            /**目标类实例*/
            private final T t=target;
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                asp.check();//前增强
                asp.except();
                System.out.println("转发至代理对象方法:"+method.getName());
                //在目标类实例t上调用方法并传入参数
                Object obj=method.invoke(t,args);
                asp.log();//后增强
                asp.monitor();
                return obj;
            }
        });
    }
}
```

#### CGLIB 动态代理

JDK 动态代理必须提供接口才能使用，对于没有提供接口的类，只能采用CGLIB 动态代理。CGLIB (Code Generation Library ） 是一个高性能开源的代码生成包，采用非常底层的字节码技术，**对指定的目标类生成一个子类，并对子类进行增强**。在Spring Core 包中己经集成了CGLIB 所需要的JAR 包，因此不需要另外导入JAR 包。

CGLIB代理的类，**无需**强制实现接口，其生成的代理类是被代理类的子类，并且重写的被代理类的方法。

要使用CGLIB创建代理实例，需要用到`org.springframework.cglib.proxy.Enhancer`类，首先实例化`Enhancer`类，然后通过`setSuperclass`设置需要增强的对象的class实例，最后通过`setCallback`设置`MethodInterceptor`回调接口，再通过`create`创建代理对象。

`MethodInterceptor`回调接口有一个方法`intercept`，对于代理的逻辑方法，**所有动态代理类的方法调用都会交给该回调接口方法处理**，因此还是不要使用`method.invoke(o,objects);`代码，这会导致无限递归：

```java
public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {}
```

参数解释：

 * `o`：是CGLIB 根据指定父类生成的代理对象的实例。
 * `method`：把代理对象当前要调用的方法传递进来，可以使用这个参数来获取方法的信息，比如方法名、参数类型等。
 * `objects`：把方法参数通过数组传递进来。
 * `methodProxy`：MethodProxy对象，可以用于调用**原始方法**（即目标的方法）。在intercept方法中，如果你需要调用原始方法，可以使用这个proxy对象。
 * `返回值`：返回函数执行的结果，取决于你想返回什么。

`MethodProxy`是CGLIB库中的一个类，用于代理方法的调用。`MethodProxy`类提供了一些常用的方法，例如：

- `invokeSuper(Object obj, Object[] args)`: 调用被代理方法的实现
- `getSignature()`: 获取被代理方法的签名
- `getSuperIndex()`: 获取被代理方法在父类中的索引
- `getSuperName()`: 获取被代理方法的名称
- `getSuperDescriptor()`: 获取被代理方法的描述符
- `getSuperMethod()`: 获取被代理方法的`java.lang.reflect.Method`对象

通过一般类实现：

```java
public class Test2 {
    public static void main(String[] args) {
        CGLIBProxy proxy = new CGLIBProxy();//创建生成代理对象的工厂类，同时它也负责MethodInterceptor的执行逻辑。
        TDemo t=new TDemo();//创建目标对象
        /*获取增强后的目标对象*/
        TDemo t2= (TDemo) proxy.createProxy(t);
        t2.delete();//任何调用都会传入intercept()回调方法,具体执行逻辑由intercept()决定。
        System.out.println(t.getClass().getName());
        System.out.println(t2.getClass().getName());
    }
}
/**
 * 目标对象
 */
class TDemo{
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
    public void delete2() {System.out.println("删除逻辑2执行");}
}
/**
 * 切面类，可以定义多个通知，即增强处理的方法
 */
class AspectDemo{
    public void check(){System.out.println("模拟权限控制");}
    public void except(){System.out.println("模拟异常处理");}
    public void log(){System.out.println("模拟日志记录");}
    public void monitor(){System.out.println("性能监测");}
}

class CGLIBProxy implements MethodInterceptor{
    AspectDemo asp = new AspectDemo();//创建一个切面
    public Object createProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());//确定需要增强的类
        enhancer.setCallback(this);//确定回调对象
        return enhancer.create();//创建代理对象
    }
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        asp.check();//前增强
        asp.except();
        System.out.println("转发至代理对象方法:"+method.getName());
        Object result = methodProxy.invokeSuper(o, objects);//转发调用目标类对应方法
        asp.log();//后增强
        asp.monitor();
        return result;
    }
}
```

控制台：

```text
模拟权限控制
模拟异常处理
转发至代理对象方法:delete
删除逻辑执行
模拟日志记录
性能监测
com.aotmd.test.TDemo
com.aotmd.test.TDemo$$EnhancerByCGLIB$$a9a7303e
```

使用匿名类，则`CGLIBProxy`类只负责创建代理实例功能：：

```java
class CGLIBProxy{
    public Object createProxy(Object target) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());//确定需要增强的类
        enhancer.setCallback(new MethodInterceptor() {
            final AspectDemo asp = new AspectDemo();//创建一个切面
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                asp.check();//前增强
                asp.except();
                System.out.println("转发至代理对象方法:"+method.getName());
                Object result = methodProxy.invokeSuper(o, objects);//转发调用目标类对应方法
                asp.log();//后增强
                asp.monitor();
                return result;
            }
        });//确定回调对象
        return enhancer.create();//创建代理对象
    }
}
```

### 使用动态代理

在Spring中**默认**使用JDK动态代理实现AOP编程。使用`org.spring.framework.aop.framework.ProxyFactoryBean`创建代理是SpringAOP实现的最基本方式。

根据Spring中通知在目标类方法中的**连接点**位置，通知可以分为6种类型。

环绕通知（`org.aopalliance.intercept.Methodlnterceptor`）是在目标方法**执行前**和**执行后**实施增强，可应用于日志记录、事务处理等功能。它的方法签名为：

```java
Object invoke(MethodInvocation invocation) throws Throwable;
```

其中`MethodInvocation`接口具有以下常用方法：

1. `Object[] getArguments()`: 获取方法调用的参数数组。
2. `Method getMethod()`: 获取被调用的方法对象。
3. `Object getThis()`: 获取目标对象，即被代理的对象。
4. `AccessibleObject getStaticPart()`: 获取静态部分，即被调用的方法或构造函数。
5. **`Object proceed() throws Throwable`: 执行下一个拦截器或目标方法，返回方法的返回值。**
6. `Object getReturnValue()`: 获取方法调用的返回值。
7. `Throwable getThrowable()`: 获取方法调用过程中抛出的异常。
8. `void setArguments(Object[] arguments)`: 设置方法调用的参数数组。
9. `void setReturnValue(Object returnValue)`: 设置方法调用的返回值。
10. `void setThrowable(Throwable throwable)`: 设置方法调用过程中抛出的异常。

前置通知（`org.springframework.aop.MethodBeforeAdvice`）是在目标方法**执行前**实施增强，可应用于权限管理等功能。

```java
public void before(Method method, Object[] args, Object target) throws Throwable {}
```

后置返回通知（`org.spring:framework.aop.AfterReturningAdvice`）是在目标方法**成功执行后**实施增强，可应用于关闭流、删除临时文件等功能，多了个`returnValue`，表示返回值。

```java
public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {}
```

后置(最终)通知（`org.springframework.aop.AfterAdvice`）是在目标方法**执行后**实施增强，与后置返回通知不同的是，**不管是否发生异常**都要执行该类通知，该类通知可应用于释放资源。

异常通知（`org.springframework.aop.ThrowsAdvice`）是在方法**抛出异常后**实施增强，可应用于处理异常、记录日志等功能。

引入通知（`org.springframework.aop.IntroductionInterceptor`）是在目标类中**添加一些新的方法和属性**，可应用于修改目标类（增强类）。

#### ProxyFactoryBean

ProxyFactory Bean是`org.springframework.beans.factory.FactoryBean` 接口的实现类，FactoryBean负责实例化一个Bean实例， ProxyFactoryBean 负责为其他Bean实例创建代理实例。ProxyFactoryBean 类的常用**属性**如下：

| **属性**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| target           | 代理的目标对象                                               |
| proxyInterfaces  | 代理需要实现的**接口列表**。如果是多个接口,可以使用以下格式赋值: `<list><value>/value><list>`  ，JDK代理使用这个参数。 |
| interceptorNames | 需要织入目标的Advice                                         |
| proxyTargetClass | 是否对类代理而不是接口,默认为false,使用JDK动态代理;当为true时,使用 CGLIB动态代理 |
| singleton        | 返回的代理实例是否为单例,默认为true                          |
| optimize         | 当设置为true时强制CGLIB使用动态代理                          |

示例：

```java
public class Test{
    public static void main(String[] args) {
        AbstractApplicationContext aac=new ClassPathXmlApplicationContext("application.xml");
        A cGLIBProxy = (A) aac.getBean("cGLIBProxy");
        cGLIBProxy.delete();
        System.out.println(cGLIBProxy.getClass().getName());
        IBase jDKProxy=(IBase)aac.getBean("jDKProxy");
        jDKProxy.save();
        System.out.println(jDKProxy.getClass().getName());
    }
}
class Aspect1 implements
        MethodInterceptor, MethodBeforeAdvice, AfterReturningAdvice
{
    public Object invoke(MethodInvocation i) throws Throwable {
        System.out.println("当前拦截对象:"+i.getMethod().getName());
        System.out.print("环绕通知前->");
        Object o = i.proceed();//转发,继续执行链中的下一个拦截。
        System.out.println("环绕通知后");
        return o;
    }
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println("前置通知");
    }
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.print("后置通知->");
    }
}
/*下面使用CGLIB代理*/
class A {
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
}
/*下面使用JDK代理*/
interface IBase {
    void save();
    void modify();
    void delete();
}
class B implements IBase {
    public void save() {System.out.println("保存逻辑执行");}
    public void modify() {System.out.println("修改逻辑执行");}
    public void delete() {System.out.println("删除逻辑执行");}
}
```

XML：

```xml
<bean id="aspect1" class="com.aotmd.test.Aspect1"/>
<!--下面使用CGLIB代理-->
<bean id="a" class="com.aotmd.test.A"/>
<bean id="cGLIBProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target" ref="a"/><!--指定要代理的目标对象-->
    <property name="interceptorNames" value="aspect1"/><!--指定切面-->
    <property name="proxyTargetClass" value="true"/><!--代理方式,默认falseJDK代理,true,CGLIB代理-->
</bean>
<!--下面使用JDK代理，共用aspect1，并使用p命名空间简化set注入-->
<bean id="b" class="com.aotmd.test.B"/>
<!--proxyInterfaces参数指定接口-->
<bean id="jDKProxy" class="org.springframework.aop.framework.ProxyFactoryBean"
      p:proxyInterfaces="com.aotmd.test.IBase" p:target-ref="b"
      p:interceptorNames="aspect1" p:proxyTargetClass="false"/>
```

控制台：

```text
当前拦截对象:delete
环绕通知前->前置通知
删除逻辑执行
后置通知->环绕通知后
com.aotmd.test.A$$EnhancerBySpringCGLIB$$4b7ac9ec
当前拦截对象:save
环绕通知前->前置通知
保存逻辑执行
后置通知->环绕通知后
com.aotmd.test.$Proxy5
```

### Aspectj切入点语法定义

在使用spring框架配置AOP的时候，不管是通过XML配置文件还是注解的方式都需要定义切入点(pointcut)。Pointcut可以通过`&&` 、`||`和`!`的方式进行组合。

#### execution()

**注意, `execution()`扫描的仅为依赖注入(控制反转)下的Bean**。

`execution()`是最常用的切点函数，其语法如下所示：修饰符 注解与异常是可选的。

```java
execution(<注解><修饰符> <返回类型> <[包名.][类名.]方法名>(<参数>) <异常>)
```

| 通配符 | **含义**                                                     |
| ------ | ------------------------------------------------------------ |
| `*`    | 所有语法中匹配任意字符,可与具体名称混写。                    |
| `+`    | 匹配接口及其所有实现类的方法。以及`Object+`用法,匹配`Object`类型或该类的子类,接口同理。 |
| `..`   | `void springAOP..*(..)) `，`..`匹配所有子包， `*`表任意方法名, `<参数>`中的`..`匹配任意数量类型的参数。 |

------

**对于：`<[包名.][类名.]方法名>`:**

`execution(void springAOP..*(..))` ：可用,匹配所有返回值为`void`,并在springAOP包及其所有子包下的所有方法。

`execution(void springAOP..(..))：`省略`*`号报错,可见`..`**只能匹配到包到类名**,没有匹配方法名称。

`execution(void *(..))`可用,匹配所有返回值为`void`的方法

`execution(void *.*(..))`可用,匹配所有返回值为`void`的方法

`execution(void *c(..))`可用,匹配以`c`结尾返回值为`void`的所有包与类中的方法

`execution(void a*(..))`可用,匹配以`a`开头返回值为`void`的所有包与类中的方法

`execution(void *.a*(..))`同上

`execution(void *.add.a*(..))`可用,没有匹配到`springIOC.pp.add`类下的`add`方法,推测`*`号被限制**只能匹配一层包或类**了

`execution(void springIoC.*.add.a*(..))`可用,正常匹配

`execution(void *.pp.add.a*(..))`可用,正常匹配

`execution(void ..a*(..))`报错，`..`通配符只能用于包名，而不能用于类名或方法名。

`execution(void ...*(..))`可用,匹配项未知

`execution(void spring*..*(..))`可用,匹配包名头为`spring`的任意包及其子包类中的`void`返回值的任意方法

`execution(void springAOP.aaa.T+.sc(..))`，`T`是一个接口因此只能用`+`的形式, 匹配`T`接口的实现类或其子接口的实现类的`sc`方法。

------

**对于`(<参数>)`**：

切点表达式中方法入参部分比较复杂，可以使用`*`和`..`通配符。

其中`*`表示**任意类型**的参数，而`..`表示**任意类型参数且参数个数不限**。

如果方法中的入参类型是`java.lang`包下的类，可以直接使用类名，否则**必须使用全限定类名**，如`joke(java.util.List,int)`。

`execution(* *(String,..))`匹配第一个参数为`String`的所有方法,**包括只有一个`String`参数**

`execution(void *(String,*))`匹配第一个参数为`String`,第二个为任意的所有方法,**限定参数个数为2**。

`execution(void *(..,String,..))`匹配参数带`String`类型的所有方法

`execution(void *(Object+))`匹配`Object`类型或该类的子类,限定参数为1

`execution(void *(Object))`**只**匹配`Object`类型,限定参数为1

`execution(void *(springAOP.aaa.T+))`匹配`T`接口或接口的实现类,以及继承`T`接口的其他接口与实现类。

------

**对于`<异常>`：**

`execution(void *(..)throws java.lang.IllegalArgumentException)`匹配**带**这个异常的方法

`execution(void *(..)throws java.lang.IllegalArgumentException,java.lang.ArrayIndexOutOfBoundsException`匹配**带**这两个异常的方法

`execution(void *(..)throws Exception+)`同理,匹配该异常,**以及该异常下的所有子异常**

`execution(void *(..)throws Exception,java.lang.IllegalArgumentException)`**多个异常无位置关系**

------

**对于`<注解>`：**

`execution(@java.lang.Override * *(..))`没有实验过

------

**对于`<修饰符>`：**

`execution(private * *(..))`无效,因为无法**直接**在外部调用该方法

`execution(protected * *(..))`没有问题,**直接**访问该方法可以匹配,通过该方法所在类的其他方法**间接访问无法起作用**

`execution(protected+ * *(..))`**无法使用**`+`,报错,情理之中。

------

**对于`<返回类型>`：**

`execution(Object+ *(..))`同样,具有匹配`Object`类型或该类的子类,返回值`String`会被匹配。































