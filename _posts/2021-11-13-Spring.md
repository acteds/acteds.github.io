---
layout: post
title: Spring
categories: Java
description: Java笔记
keywords: Java
---

# 引言

Spring框架笔记。



# Spring

Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。

Spring Framework主要包括几个模块：

- 支持IoC和AOP的容器；
- 支持JDBC和ORM的数据访问模块；
- 支持声明式事务的模块；
- 支持基于Servlet的MVC开发；
- 支持基于Reactive的Web开发；
- 以及集成JMS、JavaMail、JMX、缓存等其他模块。

## IoC

容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。

通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。

Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。

IoC全称Inversion of Control，直译为控制反转。

假定一个在线书店，通过`BookService`获取书籍：

```java
public class BookService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public Book getBook(long bookId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return book;
        }
    }
}
```

为了从数据库查询书籍，`BookService`持有一个`DataSource`。为了实例化一个`HikariDataSource`，又不得不实例化一个`HikariConfig`。

现在，继续编写`UserService`获取用户：

```java
public class UserService {
    private HikariConfig config = new HikariConfig();
    private DataSource dataSource = new HikariDataSource(config);

    public User getUser(long userId) {
        try (Connection conn = dataSource.getConnection()) {
            ...
            return user;
        }
    }
}
```

因为`UserService`也需要访问数据库，因此，不得不也实例化一个`HikariDataSource`。

上述每个组件都采用了一种简单的通过`new`创建实例并持有的方式。会有以下缺点：

1. 实例化一个组件其实很难，例如，`BookService`和`UserService`要创建`HikariDataSource`，实际上需要读取配置，才能先实例化`HikariConfig`，再实例化`HikariDataSource`。
2. 没有必要让`BookService`和`UserService`分别创建`DataSource`实例，完全可以共享同一个`DataSource`，但谁负责创建`DataSource`，谁负责获取其他组件已经创建的`DataSource`，不好处理。
3. 很多组件需要销毁以便释放资源，例如`DataSource`，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？
4. 测试某个组件，例如`BookService`，是复杂的，因为必须要在真实的数据库环境下执行。

如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。

因此，核心问题是：谁负责创建组件？谁负责根据依赖关系组装组件？销毁时，如何按依赖顺序正确销毁？解决这一问题的核心方案就是IoC。

传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：

`CartServlet`创建了`BookService`，在创建`BookService`的过程中，又创建了`DataSource`组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。

在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，`BookService`自己并不会创建`DataSource`，而是等待外部通过`setDataSource()`方法来注入一个`DataSource`：

```java
public class BookService {
    private DataSource dataSource;

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

不直接`new`一个`DataSource`，而是注入一个`DataSource`，这个小小的改动虽然简单，却带来了一系列好处：

1. `BookService`不再关心如何创建`DataSource`，因此，不必编写读取数据库配置之类的代码；
2. `DataSource`实例被注入到`BookService`，同样也可以注入到`UserService`，因此，共享一个组件非常简单；
3. 测试`BookService`更容易，因为注入的是`DataSource`，可以使用内存数据库，而不是真实的MySQL配置。

IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。

因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：

```xml
<beans>
    <bean id="dataSource" class="HikariDataSource" />
    <bean id="bookService" class="BookService">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <bean id="userService" class="UserService">
        <property name="dataSource" ref="dataSource" />
    </bean>
</beans>
```

上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为`dataSource`的组件通过属性`dataSource`（即调用`setDataSource()`方法）注入到另外两个组件中。

依赖注入可以通过`set()`方法实现，也可以通过构造方法实现。

把`BookService`改造为通过构造方法注入，那么实现代码如下：

```xml
public class BookService {
    private DataSource dataSource;

    public BookService(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}
```

Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。

在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：

1. 应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；
2. 测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。

### IoC装配

首先引入依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

测试代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

编写一个特定的`application.xml`配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="b" class="com.aotmd.test.B" />
    <bean id="a" class="com.aotmd.test.A" >
        <constructor-arg index="0" ref="b"/>
    </bean>
</beans>
```

------

### 注入方式

对于构造方法注入，通过设置`constructor-arg`标签完成：

`constructor-arg`参数:`type` 形参类型，`name` 形参变量名，`value` 属性值，`ref` 引用实例对象，`index` 索引值。

```xml
<bean id="b" class="com.aotmd.test.B" />
<bean id="a" class="com.aotmd.test.A" >
    <constructor-arg index="0" ref="b"/>
</bean>
```

- 每个`<bean ...>`都有一个`id`标识，相当于Bean的唯一ID；
- 在`a`Bean中，通过`<constructor-arg index="0" ref="b"/>`以**构造方法注入**了另一个`b`Bean；
- Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。

把上述XML配置文件用Java代码写出来，就像这样：

```java
B b=new B();
A a=new A(b);
```

只不过Spring容器是通过读取XML文件后使用反射完成的。

其实这里不写`constructor-arg`，也可以，在 Spring XML 配置文件中，如果类 `A` 只有**一个构造函数**，并且这个构造函数需要一个 `B` 类型的参数，Spring 会自动匹配并注入所需的依赖。因此，如果只有一个构造函数并且只有一个参数类型可以匹配，则**可以省略** `<constructor-arg>` 标签。



还可以使用c命名空间简化注入,对应`constructor-arg`。

`beans`标签添加属性: `xmlns:c="http://www.springframework.org/schema/c"`。

使用c命名空间，直接在bean添加参数：

```java
<bean id="a1" class="com.aotmd.test.A" c:_0-ref="b"/>
<bean id="a2" class="com.aotmd.test.A" c:b-ref="b"/>
```

`c:_索引值` 对应 `index="索引值"`， 加`-ref`表示引用实例对象

`c:形参变量名` 对应 `name="形参变量名"`,加`-ref`表示引用实例对象，不加则是设置普通数据类型，上面的式子如果不加，则`"b"`视为字符串。

需要注意的是`c:b-ref`这种方式只对以debug方式编译的class有效，因为对于非debug方式编译的class文件Spring将无法获取到对应构造方法的`参数名`，因为被优化掉了。之前在JavaWeb有说，可以设置编译器参数：`-parameters`，保留形参变量名。

------

对于set方法注入，通过设置`property`标签完成：

如果要改成**通过`set`方法注入**，则xml修改为：

```xml
<bean id="a" class="com.aotmd.test.A" >
    <property name="b" ref="b"/>
</bean>
```

`property`参数： `name` 变量名，`value` 属性值，`ref` 引用实例对象。



同样的，可以使用p命名空间简化注入,对应`property`。

`beans`标签添加属性: `xmlns:p="http://www.springframework.org/schema/p"`。

使用p命名空间，直接在bean添加参数：

```xml
<bean id="a" class="com.aotmd.test.A" p:b-ref="b"/>
```

`p:变量名` 对应 `name="变量名"`，加`-ref`表示引用实例对象。

注意：`property`对应的是set方法，而**不是**对应的属性。如`name="world"`实际对应`setWorld()`方法，这个时候**不管**是否真的存在名为`world`的属性.

------

### 注入的类型

如果注入的不是Bean，而是`boolean`、`int`、`String`这样的数据类型，则通过设置`value`注入（构造方法注入同理），例如，创建一个`HikariDataSource`：

```xml
<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource">
    <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/test" />
    <property name="username" value="root" />
    <property name="password" value="password" />
    <property name="maximumPoolSize" value="10" />
    <property name="autoCommit" value="true" />
</bean>
```

如果是Map类型，则通过嵌套`map`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="map">
        <map>
            <entry key="1" value="唱"/>
            <entry key="2" value="跳"/>
            <entry key="3" value="RAP" value-type="java.lang.String"/>
        </map>
    </property>
</bean>
```

如果是List类型，则通过嵌套`list`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg ref="b" index="0"/>
    <property name="list">
        <list><value>唱</value><value>跳</value><value>RAR</value></list>
    </property>
</bean>
```

如果是Set类型，则通过嵌套`set`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="set">
        <set><value >唱</value><value>跳</value><value>RAR</value></set>
    </property>
</bean>
```

前面有说name属性对应的是set方法，这里是`"set"`,所以对应`setList`方法，也可以改成其他的名字。

如果是数组，则通过嵌套`array`标签进行设置：

```xml
<bean id="a" class="com.aotmd.test.A">
    <property name="list">
        <array><value>唱</value><value>跳</value><value>RAR</value></array>
    </property>
</bean>
```

实例：

```java
public class Test{
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
class A {
    private B call;

    public A(Map<String,Object> map) {
        this.call = (B) map.get("key1");
        System.out.println(map);
    }

    public void setArray(String[] map) {
        System.out.println(Arrays.toString(map));
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A">
        <constructor-arg index="0">
            <map>
                <entry key="1" value="唱"/>
                <entry key="2" value="跳"/>
                <entry key="3" value="RAP" value-type="java.lang.String"/>
                <entry key="4" value="1" value-type="java.lang.Integer"/>
                <entry key="key1" value-ref="b"/>
            </map>
        </constructor-arg>
        <property name="array">
            <array><value>唱</value><value>跳</value><value>RAR</value></array>
        </property>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

控制台：

```text
{1=唱, 2=跳, 3=RAP, 4=1, key1=com.aotmd.test.B@53de625d}
[唱, 跳, RAR]
hello
```



### ApplicationContext

Spring容器就是`ApplicationContext`，它是一个接口，有很多实现类，这里选择`ClassPathXmlApplicationContext`，表示它会自动从classpath中查找指定的XML配置文件。

获得了`ApplicationContext`的实例，就获得了IoC容器的引用。从`ApplicationContext`中可以根据Bean的ID获取Bean，也可以根据Bean的类型获取Bean的引用：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
A a= appcon.getBean(A.class);
a.hello();
```

Spring还提供另一种IoC容器叫`BeanFactory`，使用方式和`ApplicationContext`类似：

```java
BeanFactory factory = new XmlBeanFactory(new ClassPathResource("application.xml"));
A a = factory.getBean(A.class);
```

`BeanFactory`和`ApplicationContext`的区别在于，`BeanFactory`的实现是**按需创建**，即第一次获取Bean时才创建这个Bean，而`ApplicationContext`会一次性创建所有的Bean。实际上，`ApplicationContext`接口是从`BeanFactory`接口继承而来的，并且，`ApplicationContext`提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，总是使用`ApplicationContext`，很少会考虑使用`BeanFactory`。

------

创建 `ApplicationContext`接口实例通常有三种方法：

**通过`ClassPathXmlApplicationContext`创建**
`ClassPathXmlApplicationContext`将从类路径classPath目录寻找指定的XML配置文件：

```java
ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
```

**通过`FileSystemXmlApplicationContext`创建**

`FileSystemXmlApplicationContext`将从指定文件的**绝对路径**中寻找XML配置文件，找到并装载完成`ApplicationContext`的实例化工作。采用绝对路径的加载方式将导致程序的灵活性变差， 一般**不推荐使用**。

```java
ApplicationContext appcon=new FileSystemXmlApplicationContext("C:\\XXX\\application.xml");
```

**通过Web服务器实例化`ApplicationContext`容器**

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
```

如果有多个Spring配置文件，则在`param-value`里，以逗号分隔，如果没有定义则默认加载`/WEB-INF/applicationContext.xml`文件，`contextConfigLocation`是参数值，固定不变。

Web服务器实例化`ApplicationContext`容器时，一般使用基于`org.springframework.web.context.ContextLoaderListener`的实现方法只需要在`web.xml`中添加代码:

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:application.xml</param-value>
</context-param>
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
```

需要web依赖：

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-web</artifactId>
    <version>5.0.2.RELEASE</version>
</dependency>
```

使用，首先**获取`ServletContext`**，这里列出几种方法：

```java
ServletContext sc = request.getServletContext();
sc=((HttpServletRequest)request).getSession().getServletContext();
sc=this.getServletContext();
```

普通类获取方法（普通类若不经过服务器调用(如servlet调用)则会报`NullPointerException`）

```java
ServletContext sc = ContextLoader.getCurrentWebApplicationContext().getServletContext();
```

然后**通过`ServletContext`获取`ApplicationContext`：**

```java
ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(sc);// 这种方法 获取失败时返回null
@SuppressWarnings("unused")
WebApplicationContext ctx=WebApplicationContextUtils.getRequiredWebApplicationContext(sc);// 这种方法 获取失败时抛出异常
ac = WebApplicationContextUtils.getRequiredWebApplicationContext(sc);
```

------

**销毁**

对于手动加载的Spring，`ApplicationContext`怎么销毁:

在非Web应用中，手工加载Spring IoC容器，不能用`ApplicationContext`，要用`AbstractApplicationContext`。用完以后要记得调用`ctx.close()`关闭容器。如果不记得关闭容器，最典型的问题就是数据库连接不能释放。

```java
((AbstractApplicationContext)appcon).close();
```

### 完整实例

```java
@WebServlet("/test")
public class Test extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext servletContext = this.getServletContext();
        // 这种方法 获取失败时返回null
        ApplicationContext ac = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        A a= ac.getBean(A.class);
        a.hello();
    }
}
class A {
    private B call;

    public void setCall(B call) {
        this.call = call;
    }

    public void hello(){
        call.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

application.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="a" class="com.aotmd.test.A" >
        <property name="call" ref="b"/>
    </bean>
    <bean id="b" class="com.aotmd.test.B" />
</beans>
```

web.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:application.xml</param-value>
    </context-param>
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
</web-app>
```

## 使用注解

使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，就可以直接从容器中获取Bean使用它们。

使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。

还可以使用Annotation配置，让Spring自动扫描Bean并组装它们。

原代码：

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new ClassPathXmlApplicationContext("application.xml");
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();

    }
}
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

xml：

```xml
<bean id="a" class="com.aotmd.test.A">
    <constructor-arg index="0" ref="b"/>
</bean>
<bean id="b" class="com.aotmd.test.B" />
```

使用注解后：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.hello();
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
@Component
class B{
    public void hello(){
        System.out.println("hello");
    }
}
```

`@Component`注解就相当于定义了一个Bean，默认名称为小写开头的类名，可以指定`value`显示设置Bean名称。这里是使用构造方法装配，也可以使用`@Autowired`把指定类型的Bean注入到指定的字段中，它可以写在set方法上，也可以写在字段上，还可以写在构造方法形参上。如：

```java
@Component
class A {
    private B b;

    public A(@Autowired B b) {
        this.b = b;
    }
    public void hello(){
        b.hello();
    }
}
```

一般把`@Autowired`写在字段上：

```java
@Component
class A {
    @Autowired
    private B b;

    public void hello(){
        b.hello();
    }
}
```

对于xml配置部分，通过标注`@Configuration`，表示`Test`是一个配置类，并且标注`@ComponentScan`告诉容器，自动搜索**当前配置类所在的包以及子包**的注解并装配。因此要特别注意包的层次结构。通常来说，启动配置类要位于自定义的顶层包。当然也可以指定要扫描的包`@ComponentScan("com.aotmd.test")`，这样就不用特定配置类的位置了。

如果不想使用配置类，也可以使用xml扫描注解：

```xml
<context:component-scan base-package="com.aotmd.test"/>
```







如果想给`A`注入`HikariDataSource`，但是这个类位于`com.zaxxer.hikari`包中，并且`HikariDataSource`也不可能有`@Component`注解，如何告诉IoC容器创建并配置`HikariDataSource`？可以在方法上标注`@Bean`注解，然后返回一个`HikariDataSource`：

```java
@Configuration
@ComponentScan
public class Test {
    public static void main(String[] args) {
        ApplicationContext appcon=new AnnotationConfigApplicationContext(Test.class);
        A a= (A)appcon.getBean("a");//test为配置文件中的id
        a.jdbc();
    }
    @Bean(name = "dataSource")
    public HikariDataSource getDataSource(){
        Properties props = new Properties();
        props.setProperty("jdbcUrl","jdbc:mysql://localhost:3306/studentdb?characterEncoding=utf-8&serverTimezone=GMT%2B8&useSSL=false");
        props.setProperty("username","root");
        props.setProperty("password","123456");
        HikariConfig config = new HikariConfig(props);
        config.addDataSourceProperty("cachePrepStmts", "true");
        return new HikariDataSource(config);
    }
}
/*默认bean名称为首字母小写*/
@Component
class A {
    @Autowired
    private HikariDataSource dataSource;
    public void jdbc(){
        try(Connection connection = dataSource.getConnection()) {
            ResultSet resultSet = connection.prepareStatement("select name from student").executeQuery();
            while (resultSet.next()){
                System.out.println(resultSet.getString("name"));
            }
        }catch (Exception e){
            e.printStackTrace();
        }
    }
}
```



































