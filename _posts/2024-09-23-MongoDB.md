---
layout: post
title: MongoDB
categories: Java
description: Java笔记
keywords: Java
---

# 引言

MongoDB是一个非关系型数据库。



# MongoDB

## 快速启动

在spring boot中使用，需要引入依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

`application.yml`：

```yaml
spring:
  data:
    mongodb:
      uri: ${MONGODB_URI:mongodb://账号:密码@10.80.21.115:29018,10.80.21.116:29018/db_schema?authSource=admin}

  jackson:
    serialization:
      FAIL_ON_EMPTY_BEANS: false
      write-dates-as-timestamps: false #使用时间戳，使用数值timestamp表示日期
      indent_output: true #格式化输出
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
```

Spring Boot 默认会自动配置 `MongoTemplate` 和 `MongoClient`，但如果需要自定义配置（例如不同的 `MongoClientOptions`），可以手动定义 `MongoClient` 和 `MongoTemplate` 的 Bean。

```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.mongodb.core.MongoTemplate;

@Configuration
public class MongoConfig {

    @Bean
    public MongoClient mongoClient() {
        return MongoClients.create("mongodb://admin:admin123@localhost:27017/mydatabase");
    }

    @Bean
    public MongoTemplate mongoTemplate() {
        return new MongoTemplate(mongoClient(), "mydatabase");
    }
}
```

**创建 MongoDB 数据模型和 Repository**

在 Spring Data MongoDB 中，每个 MongoDB 集合都对应一个 Java 类，通常使用 `@Document` 注解来标注。

```java
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

@Document(collection = "users") // 对应 MongoDB 中的 users 集合
public class User {
    @Id
    private String id;
    private String name;
    private int age;
    // Getters and Setters
}
```

可以注入 `MongoTemplate` 来执行自定义查询：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private MongoTemplate mongoTemplate;

    public User findUserById(String id) {
        return mongoTemplate.findById(id, User.class);
    }
}
```

也可以使用 `MongoRepository` 来直接进行数据库操作：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User getUserByName(String name) {
        return userRepository.findByName(name);
    }

    public void saveUser(User user) {
        userRepository.save(user);
    }
}
```

## `MongoTemplate`

`MongoTemplate` 是 Spring Data MongoDB 中用于执行 MongoDB 操作的核心类，它提供了丰富的 CRUD（创建、读取、更新、删除）和其他 MongoDB 操作的 API。以下是一些常用的 `MongoTemplate` 方法分类及其用途：

**插入操作 (Insert)**

`<T> T insert(T objectToSave)`：插入单个对象到默认集合。

`<T> T insert(T objectToSave, String collectionName)`：插入单个对象到指定的集合。

`<T> Collection<T> insertAll(Collection<? extends Object> batchToSave)`：插入多个对象到它们各自的集合。

**作用**：用于将一个或多个对象插入到 MongoDB 中的集合里。

**返回值**：返回插入的对象，带有 MongoDB 分配的 `_id`。

```java
// 创建一个新的 Product 对象并插入到默认的集合
Product product = new Product("Laptop", 1200);
Product savedProduct = mongoTemplate.insert(product);

// 创建一个新的 Product 对象并插入到指定集合 "electronics"
Product savedProductInElectronics = mongoTemplate.insert(product, "electronics");

// 插入多个 Product 对象
List<Product> products = Arrays.asList(
    new Product("Mouse", 50),
    new Product("Keyboard", 100)
);
Collection<Product> savedProducts = mongoTemplate.insertAll(products);
```

**`savedProduct`** 和 **`savedProducts`** 包含了插入后自动生成的 MongoDB `_id` 字段，可以用这个 `_id` 作为后续的查询条件。

`insertAll`会根据插入对象的类型，自动将数据插入到相应的集合。



**查询操作 (Find)**

`<T> List<T> find(Query query, Class<T> entityClass)`：根据查询条件查找符合条件的所有记录。

`<T> List<T> find(Query query, Class<T> entityClass, String collectionName)`：根据查询条件从指定集合中查找符合条件的所有记录。

`<T> T findOne(Query query, Class<T> entityClass)`：根据查询条件查找符合条件的单条记录。

`<T> T findById(Object id, Class<T> entityClass)`：根据 ID 查找对象。

`<T> T findById(Object id, Class<T> entityClass, String collectionName)`：根据 ID 从指定集合中查找对象。

`<T> List<T> findAll(Class<T> entityClass)`：查询所有记录。

`<T> List<T> findAll(Class<T> entityClass, String collectionName)`：从指定集合中查询所有记录。

`<T> List<T> findDistinct(Query query, String field, Class<T> entityClass, Class<D> resultClass)`：获取某个字段的去重值。

**作用**：用于从 MongoDB 中查询数据，可以根据不同的条件来查询多个或单个记录。

**返回值**：返回符合查询条件的对象或对象列表。`findOne` 和 `findById` 返回单个对象，`find` 返回多个对象。

```java
// 查找所有 Product 对象
List<Product> products = mongoTemplate.findAll(Product.class);

// 根据查询条件查找 price 大于 100 的所有记录
Query query = new Query(Criteria.where("price").gt(100));
List<Product> expensiveProducts = mongoTemplate.find(query, Product.class);

// 根据 ID 查找某个 Product 对象
Product product = mongoTemplate.findById("12345", Product.class);

// 获取 category 字段的去重值（所有不同的商品分类）
List<String> distinctCategories = mongoTemplate.findDistinct(new Query(), "category", Product.class, String.class);
```

**`find`**：返回匹配的多个记录。`List<Product>` 是包含符合条件的所有产品。

**`findOne`**：只返回第一个符合条件的记录。

**`findDistinct`**：可以用于获取某个字段的唯一值，例如不同的商品分类。



**计数操作 (Count)**

- `long count(Query query, Class<T> entityClass)`：根据查询条件统计记录数。
- `long count(Query query, String collectionName)`：根据查询条件统计指定集合中的记录数。

**作用**：计算 MongoDB 集合中符合查询条件的记录数。

**返回值**：返回符合条件的记录总数。

```java
// 计算价格低于 1000 的商品数量
long count = mongoTemplate.count(new Query(Criteria.where("price").lt(1000)), Product.class);
```

**`count`** 用于统计符合条件的记录数量，在查询数据量或进行分页时非常有用。



**更新操作 (Update)**

- `UpdateResult updateFirst(Query query, Update update, Class<T> entityClass)`：根据查询条件更新符合条件的第一条记录。
- `UpdateResult updateFirst(Query query, Update update, String collectionName)`：根据查询条件更新指定集合中符合条件的第一条记录。
- `UpdateResult updateMulti(Query query, Update update, Class<T> entityClass)`：根据查询条件更新符合条件的多条记录。
- `UpdateResult updateMulti(Query query, Update update, String collectionName)`：根据查询条件更新指定集合中符合条件的多条记录。
- `<T> T findAndModify(Query query, Update update, Class<T> entityClass)`：查找并更新符合条件的单条记录，并返回更新前的记录。

**作用**：更新 MongoDB 集合中的数据，可以更新单个记录或多个记录。

**返回值**：`UpdateResult` 包含了更新操作的结果，包括受影响的记录数。`findAndModify` 返回更新前的记录或更新后的记录，具体取决于配置。

```java
// 更新符合条件的第一条记录，将价格设置为 1100
Query query = new Query(Criteria.where("name").is("Laptop"));
Update update = new Update().set("price", 1100);
UpdateResult result = mongoTemplate.updateFirst(query, update, Product.class);

// 更新所有价格为 100 以下的商品，将价格增加 10
Update multiUpdate = new Update().inc("price", 10);
UpdateResult multiResult = mongoTemplate.updateMulti(new Query(Criteria.where("price").lt(100)), multiUpdate, Product.class);

// 查找并更新符合条件的记录，返回更新前的记录
Product oldProduct = mongoTemplate.findAndModify(query, update, Product.class);
```

**`updateFirst`**：只更新符合条件的第一条记录。

**`updateMulti`**：更新所有符合条件的记录。

**`findAndModify`**：可以用于实现原子性操作，比如修改某个字段并返回更新前的对象或更新后的对象。



**删除操作 (Delete)**

- `DeleteResult remove(Query query, Class<T> entityClass)`：根据查询条件删除符合条件的记录。
- `DeleteResult remove(Query query, Class<T> entityClass, String collectionName)`：根据查询条件删除指定集合中符合条件的记录。
- `<T> T findAndRemove(Query query, Class<T> entityClass)`：查找并删除符合条件的单条记录。

**作用**：删除 MongoDB 集合中的记录，可以删除单条或多条记录。

**返回值**：`DeleteResult` 表示删除操作的结果，包含删除的记录数。`findAndRemove` 返回被删除的对象。

```java
// 删除所有 name 为 "Laptop" 的记录
Query query = new Query(Criteria.where("name").is("Laptop"));
DeleteResult deleteResult = mongoTemplate.remove(query, Product.class);

// 查找并删除符合条件的第一条记录
Product deletedProduct = mongoTemplate.findAndRemove(query, Product.class);
```

**`remove`**：删除操作后，`DeleteResult` 包含受影响的记录数。

**`findAndRemove`**：查找并删除符合条件的第一条记录，并返回删除的对象。



**保存操作 (Save)**

- `<T> T save(Object objectToSave)`：保存对象到默认集合，如果存在 `_id` 则更新，否则插入。
- `<T> T save(Object objectToSave, String collectionName)`：保存对象到指定集合。

**作用**：保存对象到 MongoDB 中，如果对象已经存在（根据 `_id` 字段判断），则更新对象；否则，插入新对象。

**返回值**：返回保存后的对象。

```java
// 保存新的 Product 对象
Product product = new Product("Monitor", 300);
Product savedProduct = mongoTemplate.save(product);

// 如果 _id 已存在则更新，否则插入
mongoTemplate.save(product, "electronics");
```

**`save`**：用于插入或更新记录，适用于不确定对象是否已经存在的场景。



**聚合操作 (Aggregation)**

- `<T> AggregationResults<T> aggregate(Aggregation aggregation, String collectionName, Class<T> outputType)`：执行聚合操作，并将结果映射为指定的类。
- `<T> AggregationResults<T> aggregate(Aggregation aggregation, Class<T> inputType, Class<O> outputType)`：对指定类型的集合进行聚合操作。

**作用**：用于执行 MongoDB 的聚合操作，比如分组、求和、计算平均值等，类似于 SQL 中的 `GROUP BY`、`SUM()`、`AVG()` 等功能。

**返回值**：`AggregationResults<T>`，其中包含聚合查询的结果列表。

```java
// 计算每个类别的平均价格
Aggregation aggregation = Aggregation.newAggregation(
    Aggregation.group("category").avg("price").as("avgPrice")
);

AggregationResults<CategoryAveragePrice> result = mongoTemplate.aggregate(aggregation, "products", CategoryAveragePrice.class);
for (CategoryAveragePrice cap : result.getMappedResults()) {
    System.out.println(cap.getCategory() + ": " + cap.getAvgPrice());
}
```

**`Aggregation`**：适合用于复杂的数据处理任务，如计算统计值、分组数据等。返回值会根据映射类型转换为 `CategoryAveragePrice` 类。



**索引操作 (Index)**

- `void ensureIndex(String collectionName, IndexDefinition indexDefinition)`：为指定集合创建索引。
- `IndexOperations indexOps(String collectionName)`：返回索引操作类，用于进一步的索引操作。

**作用**：用于管理 MongoDB 集合中的索引，类似于 SQL 中的 `CREATE INDEX`。

**返回值**：`IndexOperations` 对象用于进一步操作索引。

```java
// 为 Product 集合的 price 字段创建索引
IndexDefinition priceIndex = new Index().on("price", Sort.Direction.ASC);
mongoTemplate.indexOps("products").ensureIndex(priceIndex);
```

**`ensureIndex`**：为指定字段创建索引，可以加快查询速度，特别是当集合中数据量很大时。

**`indexOps`**：用于获取集合的索引操作，提供更多对索引的操作接口。



**集合操作 (Collection Operations)**

- `MongoCollection<Document> createCollection(String collectionName)`：创建集合。
- `MongoCollection<Document> createCollection(String collectionName, CollectionOptions collectionOptions)`：根据选项创建集合。
- `void dropCollection(String collectionName)`：删除指定集合。
- `boolean collectionExists(String collectionName)`：检查集合是否存在。

**作用**：用于创建、删除集合和检查集合是否存在。

**返回值**：`createCollection` 和 `dropCollection` 没有返回值，`collectionExists` 返回布尔值表示集合是否存在。

```java
// 创建一个新的集合并设置其容量为 100 个文档
CollectionOptions options = CollectionOptions.empty().capped().size(100);
mongoTemplate.createCollection("logs", options);

// 检查集合 "products" 是否存在
boolean exists = mongoTemplate.collectionExists("products");
if (exists) {
    System.out.println("Collection exists!");
}

// 删除集合
mongoTemplate.dropCollection("oldData");
```

- **`createCollection`**：可以根据需要创建新的集合，并设定集合的选项，如大小限制等。
- **`collectionExists`**：用于检查集合是否存在，避免重复创建或删除。



**Map-Reduce 操作**

- `<T> MapReduceResults<T> mapReduce(Query query, String inputCollectionName, String mapFunction, String reduceFunction, Class<T> entityClass)`：

**作用**：执行 MongoDB 的 Map-Reduce 操作，适用于复杂的数据处理任务，类似于 Hadoop 中的 Map-Reduce 操作。

**返回值**：`MapReduceResults<T>`，包含 Map-Reduce 计算的结果列表。

```java
// 定义 map 函数和 reduce 函数，计算每个类别下商品的总数量
String mapFunction = "function() { emit(this.category, 1); }";
String reduceFunction = "function(key, values) { return Array.sum(values); }";

MapReduceResults<CategoryCount> results = mongoTemplate.mapReduce(
    new Query(), "products", mapFunction, reduceFunction, CategoryCount.class);

for (CategoryCount result : results) {
    System.out.println(result.getCategory() + ": " + result.getCount());
}
```

**`mapReduce`**：适合用于大规模数据的分布式计算，如聚合、统计等。



**投影操作 (Projection)**

- `<T> Query project(String fieldName, String alias)`：对指定字段进行投影并使用别名。

**作用**：用于查询时只返回指定的字段，类似于 SQL 中的 `SELECT column1, column2`。

**返回值**：返回投影后的对象列表，只有被包含的字段会返回。

```java
// 只返回 name 和 price 字段
Query query = new Query(Criteria.where("price").gt(100));
query.fields().include("name").include("price");
List<Product> products = mongoTemplate.find(query, Product.class);
```

**`project`**：用于查询时减少返回的字段，提高查询效率。



**分页操作 (Pagination)**

- `<T> List<T> with(Pageable pageable)`：基于分页器执行查询。

**作用**：实现分页查询。

**返回值**：返回当前页的数据。

```java
// 查询第 1 页，每页 10 条记录
PageRequest pageable = PageRequest.of(0, 10);
Query query = new Query().with(pageable);
List<Product> products = mongoTemplate.find(query, Product.class);
```

**with**：在大数据集的查询中，分页操作可以提升性能并减少内存占用。



**Bulk 操作 (批量操作)**

- `BulkOperations bulkOps(BulkOperations.BulkMode bulkMode, String collectionName)`：用于执行批量操作。

**作用**：用于批量插入、更新或删除多个文档。MongoDB 的批量操作可以极大地提高性能，特别是在处理大量数据时。

**返回值**：返回 `BulkOperations` 对象，用于构建和执行批量操作。

```java
// 批量插入或更新商品数据
BulkOperations bulkOps = mongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED, "products");

bulkOps.insert(new Product("Laptop", 1200));
bulkOps.updateOne(
    new Query(Criteria.where("name").is("Mouse")),
    new Update().set("price", 25)
);
bulkOps.remove(new Query(Criteria.where("name").is("Old Mouse")));

// 执行批量操作
bulkOps.execute();
```

**`bulkOps`**：批量操作分为两种模式，`ORDERED`（有序执行）和 `UNORDERED`（无序执行）。`UNORDERED` 会跳过失败的操作继续执行其他操作，`ORDERED` 则会在失败时终止后续操作。



## `Query`

`Query` 是 Spring Data MongoDB 提供的一个类，用于定义查询条件。它封装了 MongoDB 的查询语法，可以通过它构建复杂的查询条件，传递给 `MongoTemplate` 执行数据库查询操作。

`Query` 通常与 `Criteria` 结合使用，来定义字段的筛选条件。`Criteria` 类封装了 MongoDB 查询语句中的各种条件运算符，例如等于、包含、范围等。

以下是 `Query` 类的一些常用方法：

**基本方法**

`addCriteria(Criteria criteria)`：添加一个查询条件。

**投影（字段过滤）**

`fields()`：指定返回结果中的字段。可以包括或排除某些字段。示例：

```java
Query query = new Query();
query.fields().include("name").exclude("age"); // 只返回 name 字段，不包括 age，这是错误的，一般情况下include和exclude不能同时使用
```

在 MongoDB 中，查询返回时**默认会包含所有字段**，除非你通过 `include` 或 `exclude` 来精确控制返回的字段集合。 

- **`include("name")`**：表示只返回 `name` 字段（默认总是返回的 `_id` 字段）。
- **`exclude("age")`**：表示排除 `age` 字段，使得返回的结果中不包含 `age` 字段。

在一条查询中不能同时对同一个查询字段既 `include` 又 `exclude`，即你不能同时包括和排除字段。

只使用 `include()`
```java
query.fields().include("name").include("address");
```
这条语句表示只返回 `_id`（默认返回）以及 `name` 和 `address` 字段，其他字段会被排除。最终返回结果类似：
```json
{
    "_id": "123",
    "name": "John",
    "address": "123 Street"
}
```

只使用 `exclude()`
```java
query.fields().exclude("age").exclude("salary");
```
这条语句表示排除 `age` 和 `salary` 字段，返回除它们以外的所有字段。例如，MongoDB 文档中包含 `_id`、`name`、`age` 和 `salary` 字段，最终结果可能如下：
```json
{
    "_id": "123",
    "name": "John"
}
```

`include` 和 `exclude` 同时使用
```java
query.fields().include("name").exclude("age");
```
**这种写法是无效的**，MongoDB 不允许在同一个查询中既有 `include` 又有 `exclude`。

MongoDB 规则

- 可以使用多个 `include` 来明确指定要返回的字段，除了 `_id` 字段（它默认会被返回，除非你显式排除）。
- 可以使用多个 `exclude` 来排除不需要的字段，其他字段都会被返回。
- 如果想排除 `_id`，需要显式调用 `exclude("_id")`。
  

例如：

返回指定字段，不返回 `_id`
```java
query.fields().include("name").include("address").exclude("_id");
```
这条语句返回 `name` 和 `address` 字段，并且不包含 `_id`。返回结果可能如下：
```json
{
    "name": "John",
    "address": "123 Street"
}
```

排除某些字段，保留 `_id`
```java
query.fields().exclude("age").exclude("salary");
```
这条语句会排除 `age` 和 `salary` 字段，返回 `_id` 和除 `age` 和 `salary` 外的所有字段。

重点总结
- **`include()`**：只返回指定的字段，其他字段会被排除。
- **`exclude()`**：排除指定的字段，其他字段会被返回。
- **不能**在同一个查询中混用 `include` 和 `exclude`，除了特殊情况下 `_id` 可以单独被 `exclude`。



**分页操作**

- `skip(long skip)`：跳过查询结果中的前 N 条记录，常用于分页。
- `limit(int limit)`：限制查询结果的记录数量。

示例：
```java
Query query = new Query();
query.skip(10); // 跳过前 10 条
query.limit(5); // 限制只返回 5 条
```

**排序操作**
- `with(Sort sort)`：对查询结果进行排序。可以对一个或多个字段进行升序或降序排列。示例：

```java
import org.springframework.data.domain.Sort;

Query query = new Query();
query.with(Sort.by(Sort.Direction.ASC, "age")); // 按照 age 升序排列
```

**分页与排序配合**

可以通过 `Pageable` 来实现分页和排序。示例：

```java
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

Pageable pageable = PageRequest.of(1, 10); // 第2页，每页10条
Query query = new Query().with(pageable);
```

**使用 `MongoTemplate` 执行查询：**

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    @Autowired
    private MongoTemplate mongoTemplate;

    public List<User> findUsersByAge(int age) {
        Query query = new Query();
        query.addCriteria(Criteria.where("age").gt(age));
        return mongoTemplate.find(query, User.class);
    }
}
```

## `Criteria`

**基本操作：**

**`where(String key)`**：指定要查询的字段名称。链式调用其他方法来设置查询条件。例：

```java
Criteria criteria = Criteria.where("age").is(30); // 查询 age 字段等于 30 的记录
```

**`is(Object value)`**：`=`，等于某个值。

**`lt(Object value)`**：`<`，小于某个值。

**`lte(Object value)`**：`<=`，小于等于某个值。

**`gt(Object value)`**：`>`，大于某个值。

**`gte(Object value)`**：`>=`，大于等于某个值。

**`ne(Object value)`**：`!=`，不等于某个值。

**`in(Collection<?> values)`**：`in`，字段值在给定的集合中，例：

```java
Criteria criteria = Criteria.where("age").in(Arrays.asList(25, 30, 35)); // 查询 age 为 25, 30 或 35 的记录。
```

**`nin(Collection<?> values)`**：`not in`，字段值不在给定的集合中。

```java
Criteria criteria = Criteria.where("age").nin(Arrays.asList(25, 30, 35)); // 查询 age 不为 25, 30 或 35 的记录、
```

**`regex(String regex)`**：正则表达式匹配。

```java
Criteria criteria = Criteria.where("name").regex("^A.*"); // 查询 name 字段以 "A" 开头的记录
```

**`exists(boolean exists)`**：检查字段是否存在。

```java
Criteria criteria = Criteria.where("address").exists(true); // 查询 address 字段存在的记录
```

**嵌套操作**：

**`elemMatch(Criteria criteria)`**：用于数组或嵌套对象中的匹配。

```java
Criteria criteria = Criteria.where("items").elemMatch(Criteria.where("price").gt(100)); // 查询数组中包含 price 大于 100 的元素
```

**`orOperator(Criteria... criteria)`**：用于 OR 条件组合查询，相当于 SQL 中的 `OR`。

```java
Criteria criteria = new Criteria().orOperator(
    Criteria.where("age").lt(20),
    Criteria.where("name").is("John")
); // 查询 age 小于 20 或 name 为 "John" 的记录
```

**`andOperator(Criteria... criteria)`**：用于 AND 条件组合查询，相当于 SQL 中的 `AND`。

```java
Criteria criteria = new Criteria().andOperator(
    Criteria.where("age").gt(20),
    Criteria.where("age").lt(30)
); // 查询 age 大于 20 且小于 30 的记录
```

**其他：**

**`size(int size)`**：用于查询数组长度为指定值的记录。

```java
Criteria criteria = Criteria.where("tags").size(3); // 查询 tags 数组长度为 3 的记录
```

**`not()`**：用于取反条件，相当于 SQL 中的 `NOT`。

```java
Criteria criteria = Criteria.where("name").not().is("Alice"); // 查询 name 不为 "Alice" 的记录
```

**`mod(Number divisor, Number remainder)`**：用于取模操作，查询字段的值是否满足模运算的结果。

```java
Criteria criteria = Criteria.where("age").mod(5, 0); // 查询 age 能被 5 整除的记录
```

**`type(int type)`**：用于查询字段的 BSON 类型。

```java
Criteria criteria = Criteria.where("age").type(2); // 查询 age 为 BSON 类型 "double" 的记录
```

**`all(Collection<?> values)`**：用于数组字段的查询，匹配数组字段中包含指定值的记录。

```java
Criteria criteria = Criteria.where("tags").all(Arrays.asList("tag1", "tag2")); // 查询 tags 字段同时包含 "tag1" 和 "tag2" 的记录
```

**`isNull()`**：用于查询字段是否为 `null`。

```java
Criteria criteria = Criteria.where("address").isNull(); // 查询 address 字段为 null 的记录
```

**结合 `Criteria` 和 `Query` 使用**

通常情况下，`Criteria` 会与 `Query` 结合使用，通过 `Query` 类将 `Criteria` 传递给 `MongoTemplate` 执行查询。

```java
Query query = new Query();
query.addCriteria(Criteria.where("age").gt(25).lt(40)); // 查询 age 在 25 到 40 之间的记录

List<User> users = mongoTemplate.find(query, User.class);
```

**嵌套查询实例：**

关于 `elemMatch`、`orOperator` 和 `andOperator` 等嵌套操作的具体使用场景，通常是在查询 MongoDB 中复杂的嵌套文档或数组结构时用到的。为了更清晰地解释这些操作，下面会结合实际的 MongoDB 文档结构，逐个举例说明。

示例 1：`elemMatch`（用于数组或嵌套对象匹配）

假设有一个 MongoDB 集合 `products`，其文档结构如下：

```json
{
  "_id": ObjectId("123"),
  "name": "Laptop",
  "items": [
    { "color": "black", "price": 1200 },
    { "color": "silver", "price": 1300 }
  ]
}
```

**需求**：查询 `items` 数组中包含 `price` 大于 1200 的文档。

```java
// 使用 elemMatch 来匹配数组中的元素
Criteria criteria = Criteria.where("items").elemMatch(Criteria.where("price").gt(1200));

Query query = new Query(criteria);
List<Map> result = mongoTemplate.find(query, Map.class, "products");
```

**解释**：`elemMatch` 用于查询数组字段 `items`，并查找其包含 `price` 大于 1200 的元素。



示例 2：`orOperator`（用于 `OR` 条件查询）

假设有一个 MongoDB 集合 `users`，其文档结构如下：

```json
{
  "_id": ObjectId("123"),
  "name": "Alice",
  "age": 25,
  "location": "New York"
},
{
  "_id": ObjectId("124"),
  "name": "Bob",
  "age": 30,
  "location": "San Francisco"
},
{
  "_id": ObjectId("125"),
  "name": "Charlie",
  "age": 18,
  "location": "Los Angeles"
}
```

**需求**：查询年龄小于 20 岁或名字为 `Alice` 的用户。

```java
// 使用 orOperator 来进行 OR 组合条件查询
Criteria criteria = new Criteria().orOperator(
    Criteria.where("age").lt(20),
    Criteria.where("name").is("Alice")
);

Query query = new Query(criteria);
List<Map> result = mongoTemplate.find(query, Map.class, "users");
```

**解释**：这里使用了 `orOperator` 来表示 `age` 小于 20 岁或者 `name` 是 `Alice` 的用户。这个操作相当于 SQL 中的 `OR`。



示例 3：`andOperator`（用于 `AND` 条件查询）

假设还是使用 `users` 集合：

```json
{
  "_id": ObjectId("123"),
  "name": "Alice",
  "age": 25,
  "location": "New York"
},
{
  "_id": ObjectId("124"),
  "name": "Bob",
  "age": 30,
  "location": "San Francisco"
},
{
  "_id": ObjectId("125"),
  "name": "Charlie",
  "age": 18,
  "location": "Los Angeles"
}
```

**需求**：查询年龄大于 20 且小于 30 岁的用户。

```java
// 使用 andOperator 来进行 AND 组合条件查询
Criteria criteria = new Criteria().andOperator(
    Criteria.where("age").gt(20),
    Criteria.where("age").lt(30)
);

Query query = new Query(criteria);
List<Map> result = mongoTemplate.find(query, Map.class, "users");
```

**解释**：这里使用了 `andOperator`，表示 `age` 大于 20 且小于 30 的用户。这相当于 SQL 中的 `AND` 逻辑。



示例 4：`elemMatch` + `andOperator`（嵌套查询）

假设有一个集合 `orders`，其文档结构如下：

```json
{
  "_id": ObjectId("101"),
  "customer": "John Doe",
  "items": [
    { "product": "Laptop", "quantity": 1, "price": 1200 },
    { "product": "Mouse", "quantity": 2, "price": 50 }
  ]
},
{
  "_id": ObjectId("102"),
  "customer": "Jane Smith",
  "items": [
    { "product": "Laptop", "quantity": 1, "price": 1500 },
    { "product": "Keyboard", "quantity": 1, "price": 100 }
  ]
}
```

**需求**：查询订单中包含 `Laptop` 且价格大于 1300 的订单。

```java
// 使用 elemMatch 和 andOperator 进行复杂嵌套条件查询
Criteria criteria = Criteria.where("items").elemMatch(
    new Criteria().andOperator(
        Criteria.where("product").is("Laptop"),
        Criteria.where("price").gt(1300)
    )
);

Query query = new Query(criteria);
List<Map> result = mongoTemplate.find(query, Map.class, "orders");
```

**解释**：这里的 `elemMatch` 用于匹配 `items` 数组中的某个元素，它必须同时满足 `product` 为 `Laptop` 且 `price` 大于 1300 的条件。



示例 5：`orOperator` + `elemMatch`（组合查询）

假设使用相同的 `orders` 集合：

**需求**：查询订单中包含 `Laptop` 且价格大于 1300 或 `Mouse` 的订单。

```java
// 使用 orOperator 和 elemMatch 进行组合查询
Criteria criteria = new Criteria().orOperator(
    Criteria.where("items").elemMatch(
        new Criteria().andOperator(
            Criteria.where("product").is("Laptop"),
            Criteria.where("price").gt(1300)
        )
    ),
    Criteria.where("items").elemMatch(Criteria.where("product").is("Mouse"))
);

Query query = new Query(criteria);
List<Map> result = mongoTemplate.find(query, Map.class, "orders");
```

**解释**：在这里，使用了 `orOperator` 来表示两种情况之一：要么 `items` 中包含 `Laptop` 且价格大于 1300，要么 `items` 中包含 `Mouse`。这相当于 SQL 中的 `OR` 逻辑。



**特别注意**

下面的 MongoDB 查询：

```json
{
  "$or" : [{ "deleteStatus" : false }, { "deleteStatus" : { "$exists" : false } }],
  "tenant_id" : "16889087066967307206",
  "$or" : [{ "speciality" : "生物学" }, { "number" : { "$gt" : 54 } }]
}
```

等效于以下 SQL 语句：

```sql
SELECT * 
FROM co_common_test1 
WHERE 
  (deleteStatus = false OR deleteStatus IS NULL)
  AND tenant_id = '16889087066967307206'
  AND (speciality = '生物学' OR number > 54);
```

但是，在 MongoDB 中，一个文档内不能同时包含两个顶层的 `"$or"`，因为**每个键必须是唯一的**。如果你尝试这样做，后面的 `"$or"` 会覆盖前面的 `"$or"`，导致无法正确执行查询。

要解决这个问题并保持你想要的逻辑，可以使用一个顶层的 `"$and"` 来组合这两个 `"$or"` 逻辑。这是 MongoDB 语法的限制，必须使用 `$and` 来组合多个 `"$or"`。

可以将查询重构为：

```json
{
  "$and": [
    { "$or": [{ "deleteStatus": false }, { "deleteStatus": { "$exists": false } }] },
    { "tenant_id": "16889087066967307206" },
    { "$or": [{ "speciality": "生物学" }, { "number": { "$gt": 54 } }] }
  ]
}
```

这对应的 SQL 查询仍然是你期望的：

```sql
SELECT * 
FROM co_common_test1 
WHERE 
  (deleteStatus = false OR deleteStatus IS NULL)
  AND tenant_id = '16889087066967307206'
  AND (speciality = '生物学' OR number > 54);
```

**总结：** 尽管 SQL 中不需要显式使用 `AND` 来组合多个条件，但在 MongoDB 中，必须使用 `"$and"` 来组合多个 `"$or"`，否则会遇到查询覆盖的问题。



## 更新操作

**`Update`**：

`org.springframework.data.mongodb.core.query.Update` 是 Spring Data MongoDB 中用于执行数据库更新操作的核心类。它可以用于对 MongoDB 文档进行字段更新、增量修改、数组操作等。以下是一些 `Update` 类的常用方法，以及每个方法的用途和实例。

**`set(String key, Object value)`** - 设置字段值

用于将指定字段的值更新为新值。如果字段不存在，会创建该字段。

```java
Update update = new Update();
update.set("age", 30);  // 设置字段 "age" 的值为 30
```

**`unset(String key)`** - 移除字段

用于移除指定的字段。

```java
Update update = new Update();
update.unset("address");  // 删除字段 "address"
```

**`inc(String key, Number value)`** - 增加或减少字段值

对数值字段进行增量操作（加法）。如果字段不存在，它将创建该字段。

```java
Update update = new Update();
update.inc("age", 2);  // 将 "age" 字段的值增加 2
```

**`push(String key, Object value)`** - 向数组字段追加元素

将一个元素添加到数组字段中。

```java
Update update = new Update();
update.push("skills", "Java");  // 在 "skills" 数组中添加 "Java"
```

**`addToSet(String key, Object value)`** - 向数组添加唯一元素

如果数组字段中不存在该值，则添加该值（避免重复）。

```java
Update update = new Update();
update.addToSet("skills", "Java");  // 如果 "skills" 数组中不存在 "Java"，则添加
```

**`pull(String key, Object value)`** - 从数组中移除指定值

移除数组字段中等于指定值的元素。

```java
Update update = new Update();
update.pull("skills", "Java");  // 从 "skills" 数组中移除 "Java"
```

**`pullAll(String key, Object... values)`** - 从数组中移除多个值

从数组字段中移除多个指定值。

**实例**：
```java
Update update = new Update();
update.pullAll("skills", new String[]{"Java", "Python"});  // 从 "skills" 数组中移除 "Java" 和 "Python"
```

**`pop(String key, Update.Position position)`** - 从数组的开头或结尾移除元素

用于从数组的开头或结尾移除一个元素。

- `Update.Position.FIRST`：移除第一个元素
- `Update.Position.LAST`：移除最后一个元素

```java
Update update = new Update();
update.pop("skills", Update.Position.LAST);  // 移除 "skills" 数组中的最后一个元素
```

**`rename(String oldName, String newName)`** - 重命名字段

将指定字段重命名为新名称。

```java
Update update = new Update();
update.rename("oldFieldName", "newFieldName");  // 将字段 "oldFieldName" 重命名为 "newFieldName"
```

**`mul(String key, Number factor)`** - 数值乘法更新

将指定字段的值乘以某个因子。

```java
Update update = new Update();
update.mul("price", 1.1);  // 将 "price" 字段的值乘以 1.1
```

**`min(String key, Object value)`** - 仅当新值小于当前值时进行更新

如果传入的新值比现有字段的值小，则更新该字段为新值。

```java
Update update = new Update();
update.min("price", 100);  // 仅当 "price" 小于 100 时，更新它为 100
```

**`max(String key, Object value)`** - 仅当新值大于当前值时进行更新

如果传入的新值比现有字段的值大，则更新该字段为新值。

```java
Update update = new Update();
update.max("price", 1000);  // 仅当 "price" 大于 1000 时，更新它为 1000
```

**`currentDate(String key)`** - 设置字段为当前日期

将指定字段的值设置为当前日期时间。

**实例**：
```java
Update update = new Update();
update.currentDate("lastModified");  // 设置 "lastModified" 字段为当前时间
```

**`combine(Update... updates)`** - 组合多个 `Update` 对象

将多个 `Update` 对象组合成一个 `Update` 对象。

```java
Update update1 = new Update().set("name", "John");
Update update2 = new Update().inc("age", 1);
Update combinedUpdate = Update.combine(update1, update2);  // 将多个更新组合在一起
```

------

**`UpdateResult`**：

`updateFirst` 等更新方法的返回值类型为 `com.mongodb.client.result.UpdateResult`。`UpdateResult` 类用于表示更新操作的结果，并提供了一些方法来获取有关更新操作的详细信息。它包括以下一些常用方法：

`UpdateResult` 常用方法

**`getMatchedCount()`**:  返回匹配到的文档数。

   ```java
   UpdateResult result = mongoTemplate.updateFirst(query, update, MyClass.class);
   long matchedCount = result.getMatchedCount();  // 返回匹配到的文档数量
   ```

**`getModifiedCount()`**:  返回实际被修改的文档数。

   ```java
   long modifiedCount = result.getModifiedCount();  // 返回修改的文档数量
   ```

**`wasAcknowledged()`**:  检查更新操作是否被 MongoDB 确认。返回 `true` 表示操作已确认。

   ```java
   boolean isAcknowledged = result.wasAcknowledged();  // 检查操作是否被确认
   ```

**`getUpsertedId()`**:  返回因为 `upsert` 操作插入的文档的 `_id`，如果操作不是 `upsert`，则返回 `null`。

   ```java
   BsonValue upsertedId = result.getUpsertedId();  // 获取通过 upsert 插入的文档 ID
   if (upsertedId != null) {
       System.out.println("Upserted ID: " + upsertedId);
   }
   ```

结合 `updateFirst` 使用的完整示例

```java
Query query = new Query(Criteria.where("name").is("John"));
Update update = new Update().set("age", 30);

// 执行更新操作
UpdateResult result = mongoTemplate.updateFirst(query, update, MyClass.class);

// 获取更新结果信息
if (result.wasAcknowledged()) {
    System.out.println("Matched count: " + result.getMatchedCount());
    System.out.println("Modified count: " + result.getModifiedCount());
    if (result.getUpsertedId() != null) {
        System.out.println("Upserted ID: " + result.getUpsertedId());
    }
} else {
    System.out.println("Update was not acknowledged by MongoDB");
}
```


- `getMatchedCount()`：匹配的文档数量。
- `getModifiedCount()`：修改的文档数量。
- `wasAcknowledged()`：检查操作是否被 MongoDB 确认。
- `getUpsertedId()`：如果进行了 `upsert` 操作并插入新文档，则返回该文档的 `_id`。



## 删除操作

`com.mongodb.client.result.DeleteResult` 是 MongoDB 中删除操作的结果对象，它提供了方法来检查删除操作的执行情况和结果。它和 `UpdateResult` 类似，主要用于查看删除操作的结果和影响。

`DeleteResult` 常用方法

**`getDeletedCount()`**:  返回被删除的文档数。该方法用于了解删除操作影响了多少个文档。

 ```java
 long deletedCount = deleteResult.getDeletedCount();  // 获取被删除的文档数量
 ```

**`wasAcknowledged()`**:  检查删除操作是否被 MongoDB 确认。返回 `true` 表示删除操作已确认，`false` 表示操作未被确认。这对于确认操作是否成功完成是非常有用的。

 ```java
 boolean isAcknowledged = deleteResult.wasAcknowledged();  // 检查操作是否被确认
 ```

使用 `DeleteResult` 的完整示例

假设你想从 MongoDB 中删除某个集合中的记录，可以通过 `MongoTemplate` 执行删除操作，并使用 `DeleteResult` 来获取结果。

```java
// 定义查询条件
Query query = new Query(Criteria.where("name").is("John"));

// 执行删除操作
DeleteResult deleteResult = mongoTemplate.remove(query, MyClass.class);

// 检查删除操作是否被 MongoDB 确认
if (deleteResult.wasAcknowledged()) {
    // 获取被删除的文档数量
    long deletedCount = deleteResult.getDeletedCount();
    System.out.println("Deleted count: " + deletedCount);
} else {
    System.out.println("Delete operation was not acknowledged by MongoDB");
}
```



## 批量操作

`BulkOperations` 是 Spring Data MongoDB 提供的用于批量执行 MongoDB 操作的接口。它允许你在一次操作中对多个文档执行插入、更新、删除等操作。使用批量操作不仅可以提高效率，还可以减少网络开销和数据库负载。

常用的 `BulkOperations` 方法及其作用

**`insert(List<?> documents)`**：插入多个文档到集合中。  
```java
List<MyDocument> documents = Arrays.asList(new MyDocument("doc1"), new MyDocument("doc2"));
bulkOps.insert(documents);
```

**`updateOne(Query query, Update update)`**：根据查询条件更新单个文档。相当于 MongoDB 中的 `updateOne` 操作。  

```java
bulkOps.updateOne(new Query(Criteria.where("name").is("John")), Update.update("age", 30));
```

**`updateMulti(Query query, Update update)`**: 根据查询条件更新多个文档。相当于 MongoDB 中的 `updateMany` 操作。  
```java
bulkOps.updateMulti(new Query(Criteria.where("status").is("active")), Update.update("status", "inactive"));
```

**`remove(Query query)`**：根据查询条件删除文档。相当于 MongoDB 中的 `deleteMany` 操作。  
```java
bulkOps.remove(new Query(Criteria.where("age").lt(18)));
```

**`replaceOne(Query query, Object replacement)`**: 查找并替换符合条件的单个文档。类似于 MongoDB 中的 `replaceOne` 操作。  
```java
MyDocument replacement = new MyDocument("newDocument");
bulkOps.replaceOne(new Query(Criteria.where("name").is("OldDocument")), replacement);
```

**`upsert(Query query, Update update)`**：如果符合条件的文档存在，则更新；如果不存在，则插入新文档。相当于 MongoDB 中的 `upsert` 操作。  
```java
bulkOps.upsert(new Query(Criteria.where("name").is("John")), Update.update("age", 25));
```

**`execute()`**：执行批量操作。执行所有在批量操作中添加的插入、更新、删除等操作。  
```java
BulkWriteResult result = bulkOps.execute();
```

**`find(Query query)`**：根据查询条件查找文档，通常用于后续的 `update` 或 `remove` 操作。  
```java
bulkOps.find(new Query(Criteria.where("age").gt(30)));
```

`BulkOperations` 示例

```java
// 创建 BulkOperations 实例
BulkOperations bulkOps = mongoTemplate.bulkOps(BulkOperations.BulkMode.ORDERED, MyDocument.class);

// 插入多个文档
List<MyDocument> documents = Arrays.asList(new MyDocument("doc1"), new MyDocument("doc2"));
bulkOps.insert(documents);

// 更新单个文档
bulkOps.updateOne(new Query(Criteria.where("name").is("John")), Update.update("age", 30));

// 删除符合条件的文档
bulkOps.remove(new Query(Criteria.where("status").is("inactive")));

// 执行所有操作
BulkWriteResult result = bulkOps.execute();
```

执行模式
- **ORDERED**: 批量操作按顺序执行。如果某个操作失败，后续操作将不执行。
- **UNORDERED**: 批量操作可以并行执行，即使某个操作失败，其他操作仍会继续执行。

常用场景
- **批量插入**: 大量文档插入时，使用 `bulkOps.insert()` 提高性能。
- **批量更新**: 需要对多个文档进行同一条件更新时，使用 `bulkOps.updateMulti()`。
- **批量删除**: 批量删除符合条件的文档时，使用 `bulkOps.remove()`。
- **高效处理**: 当需要执行多个操作时（如更新和删除），可以通过批量操作一次性提交。

通过 `BulkOperations`，可以将多种操作打包成一次请求，大幅减少与数据库的交互次数，提升操作效率。

------

`BulkWriteResult` 是 MongoDB 批量操作（`BulkOperations`）执行后的结果对象。它用于获取批量写操作的执行结果，提供了插入、更新、删除等操作的统计信息。

`BulkWriteResult` 常用方法及其作用

**`getInsertedCount()`**：返回批量操作中成功插入文档的数量。

```java
int insertedCount = bulkWriteResult.getInsertedCount();
System.out.println("插入的文档数量: " + insertedCount);
```

**`getMatchedCount()`**：返回批量更新操作中匹配的文档数量，即符合查询条件的文档数量，不论是否有实际更新发生。

```java
int matchedCount = bulkWriteResult.getMatchedCount();
System.out.println("匹配的文档数量: " + matchedCount);
```

**`getModifiedCount()`**：返回批量更新操作中实际被更新的文档数量。注意，只有当文档内容发生改变时，这个值才会增加。

```java
int modifiedCount = bulkWriteResult.getModifiedCount();
System.out.println("实际更新的文档数量: " + modifiedCount);
```

**`getDeletedCount()`**：返回批量操作中成功删除的文档数量。

```java
int deletedCount = bulkWriteResult.getDeletedCount();
System.out.println("删除的文档数量: " + deletedCount);
```

**`getUpserts()`**：返回批量操作中发生 `upsert`（更新插入）的文档信息列表。`upsert` 是指如果查询没有匹配到文档，则插入新文档。

```java
List<BulkWriteUpsert> upserts = bulkWriteResult.getUpserts();
for (BulkWriteUpsert upsert : upserts) {
   System.out.println("Upserted Document _id: " + upsert.getId());
}
```

**`getInsertedIds()`**：返回批量操作中成功插入的文档 `_id` 列表。

```java
List<BsonValue> insertedIds = bulkWriteResult.getInsertedIds();
for (BsonValue id : insertedIds) {
   System.out.println("插入的文档 _id: " + id);
}
```

**`wasAcknowledged()`**：返回该批量操作是否被 MongoDB 成功确认。通常在 `UNACKNOWLEDGED` 模式下，它会返回 `false`。
```java
boolean acknowledged = bulkWriteResult.wasAcknowledged();
if (acknowledged) {
   System.out.println("批量操作已被确认");
} else {
   System.out.println("批量操作未被确认");
}
```

**示例**

```java
// 创建 BulkOperations 实例
BulkOperations bulkOps = mongoTemplate.bulkOps(BulkOperations.BulkMode.ORDERED, MyDocument.class);

// 添加批量操作
bulkOps.insert(new MyDocument("doc1"));
bulkOps.updateOne(new Query(Criteria.where("name").is("John")), Update.update("age", 30));
bulkOps.remove(new Query(Criteria.where("status").is("inactive")));

// 执行批量操作并获取结果
BulkWriteResult result = bulkOps.execute();

// 获取插入的文档数量
int insertedCount = result.getInsertedCount();
System.out.println("插入的文档数量: " + insertedCount);

// 获取更新匹配的文档数量
int matchedCount = result.getMatchedCount();
System.out.println("匹配的文档数量: " + matchedCount);

// 获取实际更新的文档数量
int modifiedCount = result.getModifiedCount();
System.out.println("实际更新的文档数量: " + modifiedCount);

// 获取删除的文档数量
int deletedCount = result.getDeletedCount();
System.out.println("删除的文档数量: " + deletedCount);

// 检查批量操作是否被确认
if (result.wasAcknowledged()) {
    System.out.println("批量操作已成功确认");
} else {
    System.out.println("批量操作未被确认");
}
```

**常用场景**

- **批量插入后统计**: 在执行大批量数据插入后，使用 `getInsertedCount()` 获取插入的总数。
- **批量更新后检查**: 在进行批量更新时，通过 `getMatchedCount()` 和 `getModifiedCount()` 确认有多少文档被匹配和实际修改。
- **批量删除后确认**: 使用 `getDeletedCount()` 确认成功删除的文档数量。
- **检查 `upsert` 操作**: 使用 `getUpserts()` 获取执行了 `upsert` 的文档信息。

## 排序

`org.springframework.data.domain.Sort` 是 Spring Data 中用于排序查询结果的类，它封装了排序逻辑并用于指定查询时的排序规则。可以使用 `Sort` 来按照指定字段升序或降序排列数据，通常与分页（`Pageable`）和查询（`Query`）配合使用。

`Sort` 的作用是定义数据库查询的排序方式，指定某个字段按升序或降序排列。你可以基于多个字段进行排序，甚至在不同字段上指定不同的排序方向（升序或降序）。

常用方法

**`Sort.by(String... properties)`**：根据属性名生成排序对象，默认是升序排序。

```java
Sort sort = Sort.by("name", "age");  // 按 name 和 age 字段升序排序
```

**`Sort.by(Sort.Order... orders)`**：根据多个 `Sort.Order` 对象创建排序对象，每个字段可以自定义升序或降序。

```java
Sort sort = Sort.by(
   Sort.Order.asc("name"),      // 按 name 升序
   Sort.Order.desc("age")       // 按 age 降序
);
```

**`Sort.by(List<Sort.Order> orders)`**：使用 `List<Sort.Order>` 对象创建排序规则。

```java
List<Sort.Order> orders = Arrays.asList(
   new Sort.Order(Sort.Direction.ASC, "name"),
   new Sort.Order(Sort.Direction.DESC, "age")
);
Sort sort = Sort.by(orders);
```

**`Sort.Order.asc(String property)`**：创建按指定字段升序排序的 `Order` 对象。

```java
Sort.Order order = Sort.Order.asc("name");  // 按 name 升序排序
```

**`Sort.Order.desc(String property)`**：创建按指定字段降序排序的 `Order` 对象。

```java
Sort.Order order = Sort.Order.desc("age");  // 按 age 降序排序
```

**`Sort.with(Sort.Direction direction, String... properties)`**：指定排序方向和多个字段。

```java
Sort sort = Sort.by(Sort.Direction.ASC, "name", "age");  // 按 name 和 age 升序排序
```

**`and(Sort sort)`**：将两个 `Sort` 对象组合，等同于 SQL 中多个字段排序。

```java
Sort sort1 = Sort.by("name");
Sort sort2 = Sort.by("age");
Sort combinedSort = sort1.and(sort2);  // 先按 name 升序，然后按 age 升序排序
```

**`getOrderFor(String property)`**：获取指定属性的排序规则。

```java
Sort sort = Sort.by(Sort.Order.asc("name"));
Sort.Order order = sort.getOrderFor("name");
System.out.println(order.getDirection());  // 输出: ASC
```

**`descending()`**：转换当前排序对象为降序排序。

```java
Sort sort = Sort.by("name").descending();  // 按 name 降序排序
```

**`ascending()`**：转换当前排序对象为升序排序。

```java
Sort sort = Sort.by("name").ascending();  // 按 name 升序排序
```

**常用字段**

**`Sort.Direction`**: 枚举类，表示排序方向，有两个可能的值：
 - `ASC`（升序）
 - `DESC`（降序）

```java
Sort sort = Sort.by(Sort.Direction.ASC, "name");  // 按 name 字段升序排序
```

**`Sort.Order`**: 封装了排序规则的对象，可以指定排序方向、字段和忽略大小写等参数。常用字段:
 - `property`：要排序的字段名。
 - `direction`：排序方向，`ASC` 或 `DESC`。
 - `ignoreCase`：是否忽略大小写。

```java
Sort.Order order = new Sort.Order(Sort.Direction.ASC, "name");
```

**示例**

单字段排序：按 `name` 升序排序:

```java
Sort sort = Sort.by(Sort.Direction.ASC, "name");
```

多字段排序：按 `name` 升序、`age` 降序排序:

```java
Sort sort = Sort.by(
    Sort.Order.asc("name"),
    Sort.Order.desc("age")
);
```

与分页结合
```java
Pageable pageable = PageRequest.of(0, 10, Sort.by("name"));
Page<User> users = userRepository.findAll(pageable);
```

## 分页

在 Spring Data 中，分页查询是非常常见的功能。`PageRequest` 和 `Pageable` 是用于定义分页和排序的核心类，通常与 `Page` 和 `Slice` 类一起使用来获取分页后的数据结果。

**`PageRequest`**
`PageRequest` 是 `Pageable` 的实现类，用于创建分页请求对象，包含分页和排序的信息。

常用方法

**`PageRequest.of(int page, int size)`**：创建一个分页请求对象，指定页码和每页大小。**参数**:

- `page`: 页码（从 0 开始）。
- `size`: 每页的记录数。

```java
Pageable pageable = PageRequest.of(0, 10); // 第 1 页，每页 10 条记录
```

**`PageRequest.of(int page, int size, Sort sort)`**：创建带排序功能的分页请求。**参数**:
- `page`: 页码。
- `size`: 每页大小。
- `sort`: 排序规则。

```java
Pageable pageable = PageRequest.of(0, 10, Sort.by("name").ascending()); // 第 1 页，按 name 升序，每页 10 条记录
```

**`PageRequest.previous()`**：返回上一页的 `PageRequest` 对象，如果是第一页则返回第一页。

```java
Pageable previousPage = pageable.previous(); // 获取上一页的分页信息
```

**`PageRequest.next()`**：返回下一页的 `PageRequest` 对象。

```java
Pageable nextPage = pageable.next(); // 获取下一页的分页信息
```

常用字段
`PageRequest` 主要实现自 `Pageable`，常用的字段来自 `Pageable` 接口：
- `page`: 页码（从 0 开始）。
- `size`: 每页的大小。
- `sort`: 排序规则（`Sort` 对象）。



---

**`Pageable`**
`Pageable` 是分页信息的接口，用于定义分页和排序规则。

常用方法

**`getPageNumber()`**：返回当前页码（从 0 开始）。

```java
int pageNumber = pageable.getPageNumber(); // 获取当前页码
```

**`getPageSize()`**：返回每页的大小。

```java
int pageSize = pageable.getPageSize(); // 获取每页记录数
```

**`getOffset()`**：返回从哪条记录开始查询（偏移量）。

```java
long offset = pageable.getOffset(); // 获取查询的起始记录索引
```

**`getSort()`**：返回当前的排序规则。

```java
Sort sort = pageable.getSort(); // 获取排序规则
```

**`isPaged()`**：检查是否分页。

```java
boolean paged = pageable.isPaged(); // 判断是否分页
```



---

**`Page`**
`Page` 是一个接口，用于封装分页结果集，通常包含分页的元信息（如总页数、总记录数、当前页）以及数据列表。

常用方法

**`getContent()`**：返回当前页的数据内容。

```java
List<User> users = page.getContent(); // 获取当前页的用户列表
```

**`getTotalElements()`**：返回总记录数。

```java
long total = page.getTotalElements(); // 获取总记录数
```

**`getTotalPages()`**：返回总页数。

```java
int totalPages = page.getTotalPages(); // 获取总页数
```

**`getNumber()`**：返回当前页码（从 0 开始）。

```java
int pageNumber = page.getNumber(); // 获取当前页码
```

**`getSize()`**：返回每页大小。

```java
int size = page.getSize(); // 获取每页记录数
```

**`hasNext()`**：判断是否有下一页。

```java
boolean hasNext = page.hasNext(); // 判断是否有下一页
```

**`hasPrevious()`**：判断是否有上一页。

```java
boolean hasPrevious = page.hasPrevious(); // 判断是否有上一页
```

**`isFirst()`**：判断是否为第一页。

```java
boolean isFirst = page.isFirst(); // 判断是否是第一页
```

**`isLast()`**：判断是否为最后一页。

```java
boolean isLast = page.isLast(); // 判断是否是最后一页
```



---

**`Slice`**
`Slice` 是分页的一种轻量级版本，它不包含总页数和总记录数的信息，只提供当前页的数据和是否存在下一页的标志。

常用方法

**`getContent()`**：返回当前页的数据内容。

```java
List<User> users = slice.getContent(); // 获取当前页的用户列表
```

**`hasNext()`**：判断是否有下一页。

```java
boolean hasNext = slice.hasNext(); // 判断是否有下一页
```

**`getNumber()`**：返回当前页码。

```java
int pageNumber = slice.getNumber(); // 获取当前页码
```

**`getSize()`**：返回每页大小。

```java
int size = slice.getSize(); // 获取每页记录数
```



---

实例代码

```java
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
   this.userRepository = userRepository;
    }

    // 分页查询
    public Page<User> getUsersByPage(int page, int size) {
   Pageable pageable = PageRequest.of(page, size, Sort.by("name").ascending());
   return userRepository.findAll(pageable);
    }

    // 获取分页结果
    public void printPagedUsers() {
   Page<User> page = getUsersByPage(0, 10);

   System.out.println("Total Elements: " + page.getTotalElements()); // 总记录数
   System.out.println("Total Pages: " + page.getTotalPages());  // 总页数
   for (User user : page.getContent()) {
  System.out.println(user.getName());
   }
    }
}
```

总结

- `Pageable` 用于定义分页和排序的逻辑。
- `PageRequest` 是 `Pageable` 的具体实现类，帮助我们创建分页和排序请求。
- `Page` 接口封装了分页后的数据和分页信息（总记录数、总页数等）。
- `Slice` 类提供类似分页的功能，但不包含总页数等信息，适用于更轻量级的分页场景。

这些类一起使用，可以很方便地在 Spring Data 中实现分页查询功能。

## 聚合

`Aggregation` 是 Spring Data MongoDB 中用于执行复杂数据处理操作的一个工具，类似于 MongoDB 的 `aggregate` 操作。它允许对文档执行聚合查询，例如分组、过滤、排序、投影、联表查询等。下面是聚合操作中常用的类、方法、字段的详细解释与实例。

---

**`Aggregation` 类常用方法：**

**`Aggregation.newAggregation(AggregationOperation... operations)`**：用于创建聚合管道，接受一系列的 `AggregationOperation` 作为参数。

```java
Aggregation aggregation = Aggregation.newAggregation(
    Aggregation.match(Criteria.where("age").gt(25)),  // 匹配 age 大于 25 的文档
    Aggregation.group("department").count().as("totalEmployees"),  // 按 department 分组并统计每组员工数
    Aggregation.sort(Sort.by(Sort.Direction.DESC, "totalEmployees"))  // 按 totalEmployees 降序排序
);
```

**`Aggregation.match(Criteria criteria)`**：用于定义筛选条件，相当于 SQL 中的 `WHERE` 语句。

```java
AggregationOperation matchOperation = Aggregation.match(Criteria.where("age").gte(30));  // 筛选 age 大于等于 30 的记录
```

**`Aggregation.group(String... fields)`**：按字段分组，类似 SQL 的 `GROUP BY`，并且可以在分组后进行数据计算。

```java
AggregationOperation groupOperation = Aggregation.group("department")  // 按 department 字段分组
    .sum("salary").as("totalSalary")  // 计算每个部门的薪资总和
    .avg("age").as("averageAge");  // 计算每个部门的平均年龄
```

`fields`可以为空，也可以是多个字段。常见的聚合方法有：`count`、`sum`、`avg`、`min`、`max`。

对于多字段分组，返回的结果通常是一个包含分组键和聚合结果的文档列表。每个文档代表一个分组，包含所分组的字段及其对应的聚合结果。以下是一个示例来说明这种结构：

**示例场景**
假设有一个集合存储用户信息，其中有 `gender`（性别）、`department`（部门）和 `age`（年龄）等字段。你希望按 `gender` 和 `department` 分组，并计算每组的平均年龄。

**MongoDB 聚合查询**

```java
Aggregation aggregation = Aggregation.newAggregation(
    Aggregation.group("gender", "department")
        .avg("age").as("averageAge")
);
```

假设你的集合中有以下数据：

```json
[
    { "gender": "male", "department": "IT", "age": 30 },
    { "gender": "male", "department": "IT", "age": 35 },
    { "gender": "female", "department": "HR", "age": 28 },
    { "gender": "female", "department": "HR", "age": 32 }
]
```

经过聚合后，返回的结果可能如下所示：
```json
[
    { "gender": "male", "department": "IT", "averageAge": 32.5},
    { "gender": "female", "department": "HR", "averageAge": 30.0}
]
```

- 每个文档中的 `_id` 字段包含了分组字段（如 `gender` 和 `department`）。
- `averageAge` 字段是对该分组的 `age` 字段进行计算的聚合结果。

对于分组字段，有以下规则：

**没有设置分组依据**：

- MongoDB 会将所有文档视为一个整体进行全局聚合。
- 返回的数据会包含一个 `_id` 字段，其值为 `null`。

**有一个字段分组**（如 `Aggregation.group("gender")`）：

- 返回的数据会多一个 `_id` 字段，其值为 `gender` 列的分组结果。
- 这确实有点扭曲，因为它似乎是将分组的字段变成了一个额外的标识符。

**有多个字段分组**：

- 如果设置了多个分组依据，返回的数据将根据每个分组依据的值组织，而不再有额外的 `_id` 字段。
- 每个分组依据将作为返回结果中的一列。

如果只分组不聚合，MongoDB 会返回每个组的文档，效果同上。



**`Aggregation.project(String... fields)`**：用于选择输出的字段，相当于 SQL 中的 `SELECT`。

```java
AggregationOperation projectOperation = Aggregation.project("name", "department", "totalSalary")  // 选择输出字段
    .andExpression("totalSalary / 1000").as("salaryInThousands");  // 添加计算字段
```

如果用类似：

```java
Aggregation.project().and("data.email").as("amount"); //别名
```

的方式设置别名，那么原来的列`data.email`将不存在，原来的列会被替换为别名`amount`。

你可能会觉得：

```java
Aggregation.project("data.email").and("data.email").as("amount"); //别名
```

会保留原列，但实际上不会，它会将 `data.email` 替换为 `amount`。

**要保留原字段，则需要这样写：**

```java
Aggregation.project()
    .and("data.email").as("amount"); //别名
	.and("data.email").as("data.email") // 原字段
```



**`Aggregation.sort(Sort sort)`**：对聚合结果进行排序，类似于 SQL 中的 `ORDER BY`。

```java
AggregationOperation sortOperation = Aggregation.sort(Sort.by(Sort.Direction.DESC, "totalSalary"));  // 按 totalSalary 降序排序
```

**`Aggregation.limit(long maxSize)`**：限制聚合结果的条数，相当于 SQL 中的 `LIMIT`。

```java
AggregationOperation limitOperation = Aggregation.limit(5);  // 限制结果返回前 5 条
```

**`Aggregation.skip(long elementsToSkip)`**：跳过指定数量的文档，类似于 SQL 中的 `OFFSET`。

```java
AggregationOperation skipOperation = Aggregation.skip(10);  // 跳过前 10 条记录
```

---

**常用类与方法：**

**`AggregationOperation`**：表示聚合操作的接口，每一个具体的聚合步骤都是它的实现类。

- `Aggregation.match(Criteria criteria)`：用于筛选数据，等同于 MongoDB 的 `$match` 操作。
- `Aggregation.group(String... fields)`：用于分组数据，等同于 MongoDB 的 `$group` 操作。
- `Aggregation.project(String... fields)`：用于选择和转换数据，等同于 MongoDB 的 `$project` 操作。
- `Aggregation.sort(Sort sort)`：用于排序数据，等同于 MongoDB 的 `$sort` 操作。
- `Aggregation.limit(long maxSize)`：用于限制结果集的大小，等同于 MongoDB 的 `$limit` 操作。
- `Aggregation.skip(long elementsToSkip)`：用于跳过指定数量的文档，等同于 MongoDB 的 `$skip` 操作。

---

**`AggregationResults<T>`**：表示聚合操作的结果集，封装了返回的数据。

**常用方法：**

**`getMappedResults()`**：返回经过映射后的聚合结果列表。

```java
AggregationResults<EmployeeStats> result = mongoTemplate.aggregate(aggregation, "employees", EmployeeStats.class);
List<EmployeeStats> statsList = result.getMappedResults();  // 获取聚合结果
```

---

**实例代码：**

假设有一个员工集合 `employees`，结构如下：

```json
{
  "name": "Alice",
  "age": 30,
  "department": "HR",
  "salary": 5000
}
```

下面是一个完整的聚合操作实例，查询年龄大于 25 岁的员工，按部门分组统计每个部门的总薪资，并按总薪资降序排序，只返回前 3 个部门。

```java
// 创建匹配操作，筛选出 age > 25 的文档
AggregationOperation match = Aggregation.match(Criteria.where("age").gt(25));

// 创建分组操作，按 department 字段分组并计算总薪资
AggregationOperation group = Aggregation.group("department")
    .sum("salary").as("totalSalary");

// 创建排序操作，按 totalSalary 降序排序
AggregationOperation sort = Aggregation.sort(Sort.by(Sort.Direction.DESC, "totalSalary"));

// 创建限制操作，只返回前 3 条结果
AggregationOperation limit = Aggregation.limit(3);

// 创建聚合对象，将所有操作串联
Aggregation aggregation = Aggregation.newAggregation(match, group, sort, limit);

// 执行聚合查询
AggregationResults<DepartmentStats> results = mongoTemplate.aggregate(aggregation, "employees", DepartmentStats.class);

// 获取并输出聚合结果
List<DepartmentStats> departmentStats = results.getMappedResults();
departmentStats.forEach(stat -> System.out.println(stat.getDepartment() + ": " + stat.getTotalSalary()));
```

在这个例子中，`DepartmentStats` 是一个映射聚合结果的类，它包含 `department` 和 `totalSalary` 两个字段，用来接收分组后的结果。

## 投影

投影是在 MongoDB 中用于控制查询结果中返回哪些字段的操作，类似于 SQL 中的 `SELECT` 子句。通过投影，您可以只选择您关心的字段，从而减少传输的数据量，提高查询效率。

在 Spring Data MongoDB 中，投影操作主要通过 `Aggregation.project()` 方法来实现，此外，在简单查询中也可以通过 `Query.fields()` 方法实现。

---

**投影操作相关类与方法：**

**`Aggregation.project(String... fields)`**：用于选择并格式化输出的字段。

```java
AggregationOperation projectOperation = Aggregation.project("name", "salary")  // 选择输出 name 和 salary 字段
    .and("department").as("dept");  // 重命名 department 字段为 dept
```

**`Query.fields()`**：在简单查询中指定需要返回的字段，不能重命名字段。

```java
Query query = new Query(Criteria.where("age").gt(25));  // 筛选条件
query.fields().include("name").include("salary");  // 仅返回 name 和 salary 字段
```

---

**投影的作用与优势：**

- **减少数据量**：只选择需要的字段，减少了网络传输和存储的开销。
- **提高性能**：减少了 MongoDB 返回的数据量，从而提高了查询性能。
- **自定义输出**：可以通过 `Aggregation.project()` 进行字段重命名或计算新字段，提供更灵活的输出。

---

**实例代码：**

假设我们有一个员工集合 `employees`，结构如下：

```json
{
  "name": "Alice",
  "age": 30,
  "department": "HR",
  "salary": 5000
}
```

下面是一个使用聚合投影的示例，查询所有员工的姓名和薪资，同时重命名 `department` 字段为 `dept`：

```java
// 创建聚合投影操作
AggregationOperation project = Aggregation.project("name", "salary")
    .and("department").as("dept");  // 重命名 department 字段为 dept

// 创建聚合对象
Aggregation aggregation = Aggregation.newAggregation(project);

// 执行聚合查询
AggregationResults<EmployeeProjection> results = mongoTemplate.aggregate(aggregation, "employees", EmployeeProjection.class);

// 获取并输出投影结果
List<EmployeeProjection> projections = results.getMappedResults();
projections.forEach(proj -> System.out.println("Name: " + proj.getName() + ", Salary: " + proj.getSalary() + ", Department: " + proj.getDept()));
```

在这个例子中，`EmployeeProjection` 是一个用于映射投影结果的类，包含 `name`、`salary` 和 `dept` 三个字段，用来接收查询结果。

## 日志

```yaml
logging:
  level:
    root: ${LOG_LEVE:info}
    org.springframework.data.mongodb.core: DEBUG
    org.mongodb.driver.protocol: WARN
```

## 数据转换

`ConvertOperators` 是 Spring Data MongoDB 中用于字段类型转换的类。它提供了多个方法来将字段转换为不同的数据类型，常见的用法包括：

1. **`ConvertOperators.Convert.convertValueOf(String field)`**：用于指定需要转换的字段。
2. **`.to(String type)`**：指定目标数据类型，`double`、`string`、`objectId`、`bool`、`date`、`int`、`long`、`decimal`。

使用示例：

```java
ConvertOperators.Convert.convertValueOf("fieldName").to("decimal");
```

这种转换在聚合操作中非常有用，可以在数据处理时确保字段的类型符合预期，从而避免类型错误。

示例：

```java
// 创建投影操作进行字段转换
ProjectionOperation projectStage = Aggregation.project("data.email")
        .and(ConvertOperators.Convert.convertValueOf("data.email").to("decimal").onErrorReturn(0).onNullReturn(0)).as("amount"); //别名

// 创建聚合操作
Aggregation aggregation = Aggregation.newAggregation(
        Aggregation.match(Criteria.where("data.email").exists(true)),
        projectStage,
        Aggregation.group()
                .sum("amount").as("totalAmount")
);
Map result = mongoTemplate.aggregate(aggregation, "co_common_test1", Map.class).getMappedResults().get(0);
Decimal128 totalAmount = (Decimal128) result.get("totalAmount");
System.out.println(totalAmount);
```

这段代码的目的是在 MongoDB 中进行聚合操作，将 `data.email` 字段转换为十进制格式，并计算总和。具体步骤如下：

1. **投影操作 (`ProjectionOperation`)**：
   - 使用 `Aggregation.project("data.email")` 创建一个投影阶段，保留 `data.email` 字段。
   - 通过 `ConvertOperators.Convert.convertValueOf("data.email").to("decimal").as("amount")` 将 `data.email` 转换为十进制格式，并给它起一个别名 `amount`。

2. **聚合操作 (`Aggregation`)**：
   - 创建一个新的聚合管道，首先通过 `Aggregation.match(Criteria.where("data.email").exists(true))` 过滤出存在 `data.email` 字段的文档。
   - 然后应用之前定义的投影阶段。
   - 最后，使用 `Aggregation.group().sum("amount").as("totalAmount")` 聚合阶段，对转换后的 `amount` 字段进行求和，并将结果命名为 `totalAmount`。

3. **执行聚合**：
   - 使用 `mongoTemplate.aggregate()` 方法执行聚合操作，查询 `co_common_test1` 集合，并将结果映射为 `Map` 对象。
   - 从结果中获取 `totalAmount`，并打印出来。

这段代码主要实现了对 `data.email` 字段的类型转换和求和操作，目的是在处理数据时确保数值类型的正确性。



要对多个字段进行转换，可以在投影操作中连续添加多个转换。例如，假设你有 `data.email` 和 `data.amount` 两个字段要转换为十进制，可以如下操作：

```java
// 创建投影操作进行多个字段转换
ProjectionOperation projectStage = Aggregation.project()
        .and(ConvertOperators.Convert.convertValueOf("data.email").to("decimal")).as("emailAmount")
        .and(ConvertOperators.Convert.convertValueOf("data.amount").to("decimal")).as("amountAmount"); // 别名

// 创建聚合操作
Aggregation aggregation = Aggregation.newAggregation(
        Aggregation.match(Criteria.where("data.email").exists(true).and("data.amount").exists(true)),
        projectStage,
        Aggregation.group()
                .sum("emailAmount").as("totalEmailAmount")
                .sum("amountAmount").as("totalAmountAmount")
);
Map result = mongoTemplate.aggregate(aggregation, "co_common_test1", Map.class).getMappedResults().get(0);
Decimal128 totalEmailAmount = (Decimal128) result.get("totalEmailAmount");
Decimal128 totalAmountAmount = (Decimal128) result.get("totalAmountAmount");
System.out.println(totalEmailAmount);
System.out.println(totalAmountAmount);
```

在这个示例中：

1. **投影操作 (`ProjectionOperation`)**：
   - 使用 `Aggregation.project()`，通过 `and()` 方法添加多个字段的转换。
   - 每个字段的转换都使用 `ConvertOperators.Convert.convertValueOf()` 方法，并给它们起不同的别名。

2. **聚合操作**：
   - 通过 `Aggregation.match()` 过滤出存在这两个字段的文档。
   - 在聚合阶段，分别对转换后的 `emailAmount` 和 `amountAmount` 字段进行求和。

这样可以轻松处理多个字段的转换和聚合。



这样打印的值是科学计数法，如果需要打印普通值，则需要使用：`totalAmount.bigDecimalValue().toPlainString()`。
