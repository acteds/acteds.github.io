---
layout: post
title: 多线程
categories: Java
description: Java笔记
keywords: Java
---

# 多线程

代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。

**进程**

在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。

某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。

```ascii
                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
```

操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：

多进程模式（每个进程只有一个线程）：

```ascii
┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
```

多线程模式（一个进程有多个线程）：

```ascii
┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
```

多进程＋多线程模式（复杂度最高）：

```ascii
┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
```

进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。具体采用哪种方式，要考虑到进程和线程的特点。

和多线程相比，多进程的缺点在于：

- 创建进程比创建线程开销大，尤其是在Windows系统上；
- 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：

多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

**多线程**

Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。

因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。

和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。

Java多线程编程的特点又在于：

- 多线程模型是Java程序最基本的并发模型；
- 后续读写网络、数据库、Web开发等都依赖Java多线程模型。



## 创建新线程

Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行`main()`方法。在`main()`方法中，我们又可以启动其他线程。

要创建一个新线程非常容易，我们需要实例化一个`Thread`实例，然后调用它的`start()`方法。

但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：

方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：

```java
Thread t2 = new Thread(){
    @Override
    public void run() {
        super.run();
        System.out.println("匿名子类");
    }
};
t2.start(); // 启动新线程
```

`start()`方法会在内部自动调用实例的`run()`方法。

方法二：创建`Thread`实例时，传入一个`Runnable`实例，这种方法内部类会取不到当前Thread匿名类对象，可以通过`Thread.currentThread()`得到当前线程对象。

```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Runnable接口匿名类");
    }
});
t.start(); // 启动新线程
```

若外部`Thread`不是匿名的，则也可以在匿名内部类内通过`外部类名.this`来引用外部类的实例。

```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(t);
    }
});
t.start(); // 启动新线程
```

注意不能使用`t`，因为`t`现在还没有初始化（其实内部类代码运行的时候已经实例化了），但对编译器来说无法确定在这个时候`t`是否已经被正确初始化。因此，即使在实际运行时`t`已经被实例化了，编译器也会在编译时会认为`t`是一个未被初始化的变量，从而导致编译错误。

可以使用lambda简化：

```java
Thread t = new Thread(() -> System.out.println("Runnable接口匿名类"));
t.start(); // 启动新线程
```

创建线程后的代码执行顺序：

```java
System.out.println("main方法开始");
Thread t = new Thread(() -> {
    System.out.println("线程开始");
    System.out.println("线程结束");
});
t.start(); // 启动新线程
System.out.println("main方法结束");
```

只能肯定`main`线程先打印`main方法开始`，然后创建并启动了新线程，然后再打印。而新线程会在启动后与`main`线程并发运行，因此对于新线程启用后的打印语句顺序是**不可预知**的，调度由操作系统控制，**程序本身无法确定线程的调度顺序**。

要模拟并发执行的效果，可以在线程中调用`Thread.sleep()`，强迫**当前线程**暂停一段时间：

```java
public static void main(String[] args){
    System.out.println("main方法开始");
    Thread t = new Thread(() -> {
        System.out.println("线程开始");
        sleep(10);
        System.out.println("线程结束");
    });
    t.start(); // 启动新线程
    sleep(20);
    System.out.println("main方法结束");
}
public static void sleep(long millis){
    try {
        Thread.sleep(millis);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
```

要特别注意：直接调用`Thread`实例的`run()`方法是无效的。直接调用`run()`方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。

**必须**调用`Thread`实例的`start()`方法才能**启动新线程**，如果查看`Thread`类的源代码，会看到`start()`方法内部调用了一个`private native void start0()`方法，`native`修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。

可以通过`setPriority(int n)`对线程设定优先级，n的值范围是1~10, 默认值为5。

JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但决**不能**通过设置优先级来**确保**高优先级的线程**一定会先执行**。

## 线程的状态

在Java程序中，一个线程对象只能调用一次`start()`方法启动新线程，并在新线程中执行`run()`方法。一旦`run()`方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：

- New：新创建的线程，尚未执行；
- Runnable：运行中的线程，正在**执行**`run()`方法的Java代码；
- Blocked：运行中的线程，因为某些操作被**阻塞**而挂起；
- Waiting：运行中的线程，因为某些操作在**等待**中；
- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时**等待**；
- Terminated：线程已**终止**，因为`run()`方法执行完毕。

用一个状态转移图表示如下：

```ascii
         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
```

当线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。

线程终止的原因有：

- 线程正常终止：`run()`方法执行到`return`语句返回；
- 线程意外终止：`run()`方法因为未捕获的异常导致线程终止；
- 对某个线程的`Thread`实例调用`stop()`方法强制终止（强烈不推荐使用）。

一个线程还可以等待另一个线程直到其运行结束。

例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：

```java
System.out.println("main方法开始");
Thread t = new Thread(() -> {
    System.out.println("线程开始");
    System.out.println("线程结束");
});
t.start(); // 启动新线程
t.join();//等待t线程结束
System.out.println("main方法结束");
```

```text
main方法开始
线程开始
线程结束
main方法结束
```

如果`t`线程已经结束，对实例`t`调用`join()`会立刻返回。此外，`join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。

在 Java 中，多线程中的阻塞状态和等待状态是两种不同的状态，它们之间有一些区别：

1. 阻塞状态（Blocked）：
- 当线程在获取锁时被其他线程所占用，导致无法继续执行时，线程会进入阻塞状态。
- 线程进入阻塞状态是因为正在等待某个条件的发生，一旦条件满足，线程将会被唤醒并切换到就绪状态。
- 在阻塞状态下的线程**仍然持有锁**，只是无法继续执行而已。

2. 等待状态（Waiting）：
- 当线程调用 `Object.wait()`、`Thread.join()` 或 `LockSupport.park()` 等方法进入等待状态时，线程会进入等待状态。
- 等待状态下的线程会**释放持有的锁**，等待其他线程调用 `notify()`、`notifyAll()` 或被中断时才能被唤醒。
- 等待状态通常用于线程间的协调和通信，等待特定条件满足后再继续执行。

总的来说，阻塞状态是因为线程被其他原因无法继续执行所产生的状态，而等待状态则是线程主动等待某些条件满足才能继续执行的状态。在编写多线程程序时，理解和正确处理线程的阻塞和等待状态是非常重要的。

**注意：`Thread.sleep()`不会释放持有的锁。**

Timed Waiting（计时等待）和Waiting（等待）是两种不同的线程状态。

- Timed Waiting（计时等待）是指线程在等待一段时间后自动恢复，例如通过调用`Thread.sleep()`或者等待一个锁的过程中调用了`Object.wait(long timeout)`方法。在这种状态下，线程是**持有锁**的。
- Waiting（等待）是指线程在等待某个条件满足后被唤醒，例如通过调用`Object.wait()`方法或者等待一个锁的过程中调用了`Object.wait()`方法。在这种状态下，线程是**释放了持有的锁**的。

这两种状态的区别在于是否指定了等待的时间。Timed Waiting是有一个固定的等待时间，而Waiting是等待某个条件的发生，时间不确定。



## 中断线程

如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是**其他线程**给该线程发一个信号，该线程收到信号后结束执行`run()`方法，使得自身线程能**立刻结束运行**。

假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。

中断一个线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法，目标线程**需要反复检测自身状态**是否是interrupted状态，如果是，就立刻结束运行。

```java
Thread t = new Thread(){
    @Override
    public void run() {
        int n=0;
        while (!isInterrupted()){
            try {
                sleep(10);
                n++;
            } catch (InterruptedException e) {
                System.out.println("线程被中断，结束执行");
            }
        }
        System.out.println("中断了，n="+n);
    }
};
System.out.println("开始");
t.start(); // 启动新线程
try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}
t.interrupt();
t.join();
System.out.println("结束");
```

这段代码大概率会一直运行，且`!isInterrupted()`并不会起到中断作用，虽然调用`t.interrupt();`时，会改变`interrupted`的状态，使得`!isInterrupted()`为假。

但主线程请求`t`线程中断时，`t`线程**大概率**是在运行`sleep(10)`，此时线程处在休眠状态，而`sleep(10)`在休眠过程中会检测线程是否出现中断请求，如果检测到了了，则会抛出`InterruptedException`异常，并**清除线程的中断状态**，因此`while`循环不会结束。

也有极小概率会正常终止，当主线程请求`t`线程中断时，如果`t`线程正运行在`n++;`则会在下次循环通过`!isInterrupted()`为假后结束运行。

要让之前的代码正常退出，只需要在`catch`块中添加`break;`。结果如下：

```text
开始
线程被中断，结束执行
中断了，n=9
结束
```

------

在Java中，调用`interrupt()`方法**只是向目标线程发出中断请求**，目标线程可以**选择**是否**响应**这个请求。目标线程可以通过**检查中断状态**并**采取**适当的**措施**来响应中断请求，也可以选择**忽略**中断请求继续执行。

在处理`InterruptedException`时，也可以选择继续等待，或处理中断请求提前结束线程的执行，具体取决于应用程序的需求。

`InterruptedException`通常在以下情况下抛出：

1. 当一个线程处于睡眠状态（通过调用`Thread.sleep()`进入睡眠状态）时，另一个线程调用了该线程的`interrupt()`方法，这会导致处于睡眠状态的线程抛出`InterruptedException`，并且**清除该线程的中断状态**。

2. 如果一个线程在调用`Object.wait()`、`Thread.join()`、`Thread.sleep()`时被中断，则会抛出`InterruptedException`，并且**清除该线程的中断状态**。这样线程在等待某些条件时，如果被中断就会提早终止。

也就是说：当线程处于等待、睡眠状态或以其他方式被占用时，或者线程在活动之前或期间出现中断时会抛出`InterruptedException`。

还可以通过`Thread.currentThread.interrupt()`方法来**重新设置当前线程的中断状态**。这种方式可以在捕获`InterruptedException`异常后，手动设置线程的中断状态为`true`，以便在后续的循环条件中能够正确地退出循环。



**实际上`interrupt()`是这么说的**：

`interrupt()` 方法用于中断线程。除非当前线程是在中断自己，这种情况总是被允许的，否则会调用此线程的 `checkAccess` 方法，可能会导致抛出 `SecurityException`。

如果线程被阻塞在 `Object` 类的 `wait()`、`wait(long)`、`wait(long, int)` 方法，或者 `Thread` 类的 `join()`、`join(long)`、`join(long, int)`、`sleep(long)`、`sleep(long, int)` 方法中，那么它的**中断状态将被清除**，并且会收到一个 `InterruptedException`。

如果线程被阻塞在一个 `InterruptibleChannel` 的 I/O 操作上，那么该通道将被关闭，线程的**中断状态将被设置**，并且线程将收到一个 `java.nio.channels.ClosedByInterruptException`。

如果线程被阻塞在一个 `Selector` 上，那么线程的**中断状态将被设置**，并且它将立即从选择操作中返回，可能返回一个非零值，就像调用了选择器的 `wakeup` 方法一样。

如果以上情况**都不适用**，那么线程的**中断状态将被设置**。

对一个非存活的线程进行中断操作可能没有任何效果。

此外，文档还指出，在 JDK 参考实现中，对于一个非存活的线程进行中断操作仍然**会记录中断请求**，并通过 `interrupted()` 和 `isInterrupted()` 方法报告它。



------

```java
package com.aotmd;

public class Main {
    public static void main(String[] args) throws Exception  {
        Thread t1 = new Thread(()->{
            Thread t2 = new Thread(() -> {
                int n = 0;
                //判断中断状态
                while (!Thread.currentThread().isInterrupted()) {
                    n++;
                    System.out.println(n + " hello!");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        System.out.println("t2：休眠时检测到中断请求");
                        try {Thread.sleep(10);//收拾东西
                            System.out.println("t2：走了！");
                        }catch (InterruptedException _) {
                            System.out.println("t2：别催了，马上走！");
                        }
                        return;
                    }
                }
                System.out.println("t2：运行时检测到中断请求");
                System.out.println("t2：走了！");
            });
            t2.start();// 启动新线程t2
            try {
                t2.join(); // 等待t2线程结束
            } catch (InterruptedException e) {
                System.out.println("t1：Main通知关门了!");
                System.out.println("t1：t2，关门了，快走！");
                t2.interrupt();// 通知t2，中断请求
                try {
                    t2.join();// 等待t2线程结束
                } catch (InterruptedException e2) {
                    System.out.println("t1：又被Main通知关门了!t2怎么还不走？");
                    //t2.join();
                    System.out.println("t1：算了我不等了，我先走了");
                }
            }
        });
        t1.start(); // 启动新线程t1
        Thread.sleep(1000);
        System.out.println("Main：t1，关门了，快走！");
        t1.interrupt();// 通知t1，中断请求
        t1.join(1);// 等1ms
        System.out.println("Main：t1，快点！");
        t1.interrupt();// 再次通知t1，中断请求
        t1.join();// 等待t1，中断完成
        System.out.println("Main：已确认t1走了");
    }
}

```

控制台：

```text
1 hello!
2 hello!
3 hello!
4 hello!
5 hello!
6 hello!
7 hello!
8 hello!
9 hello!
10 hello!
Main：t1，关门了，快走！
t1：Main通知关门了!
t1：t2，关门了，快走！
t2：休眠时检测到中断请求
Main：t1，快点！
t1：又被Main通知关门了!t2怎么还不走？
t1：算了我不等了，我先走了
Main：已确认t1走了
t2：走了！
```

假设代码执行没有消耗时间，`XXXXms`表示程序运行后的时间。

0~1000ms：`t2`持续输出。

1000ms：`main`线程通过调用`t1.interrupt()`从而通知`t1`线程中断，并等待`t1`。

1000ms：而此时`t1`线程正在等待`t2`线程，收到中断请求后抛出异常，捕获异常后`t1`也对`t2`发出中断请求，并等待`t2`。

1000ms：`t2`大概率在休眠时收到中断请求，然后抛出异常，磨蹭10ms后才真正走人。

1000ms：而`main`线程在第一次请求`t1`中断后，间隔1ms，再次催促`t1`中断请求。

1001ms：而此时`t1`线程还在等待`t2`线程，收到中断请求后，不再等待`t2`，也没有继续通知`t2`,直接结束了运行。

1001ms：`main`线程已经得到`t1`线程执行完毕，结束了执行。

1010ms：`t2`磨蹭10ms后才真正走人。



另一个常用的中断线程的方法是设置标志位。我们通常会用一个`running`标志位来标识线程是否应该继续运行，在外部线程中，通过把`HelloThread.running`置为`false`，就可以让线程结束。其实和`interrupt()`方法是一样的，只是`interrupted`字段也会被其他方法检测到状态，比如`join()`、`sleep()`。如果使用自定义的标志位表示中断线程，则其他方法不会响应。

错误写法：

```java
Thread t1 = new Thread(){
    public volatile boolean running=true;
    @Override
    public void run() {
        int n = 0;
        while (running) {
            n ++;
            System.out.println(n + " hello!");
        }
        System.out.println("end!");
    }
};
t1.start(); // 启动新线程t1
Thread.sleep(1);
t1.running=false;// 通知t1，中断请求
t1.join();// 等
```

因为向上转型的原因，`Thread`不存在`running`这个字段，好的，我转回去可以吗，也不行，因为是匿名类。把`Thread`改成`var`倒是可以，`var t1 = new Thread(){...}`，不过不建议。

同样的，如果是实现`Runnable`接口传入`Thread`构造方法，`Thread`当然不知道你定义了`running`这个字段，因为`Runnable`接口只规定了你有`run()`方法。因此只能写正常继承的类了：

```java
package com.aotmd;

public class Main {
    public static void main(String[] args) throws Exception  {
        T1 t1 = new T1();
        t1.start(); // 启动新线程t1
        Thread.sleep(1);
        t1.running=false;// 通知t1，中断请求
        t1.join();// 等
    }
    static class T1 extends Thread{
        public volatile boolean running=true;
        @Override
        public void run() {
            int n = 0;
            while (running) {
                n ++;
                System.out.println(n + " hello!");
            }
            System.out.println("end!");
        }
    }
}
```

控制台：

```text
1 hello!
end!
```

## volatile

注意到`T1`的标志位`boolean running`是一个线程间共享的变量。线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。

为什么要对线程间共享的变量用关键字`volatile`声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，**当线程访问变量时**，它会先获取一个副本，并保存在自己的工作内存中。如果**线程修改了变量的值**，虚拟机会在**某个时刻**把修改后的值回写到主内存，但是，这个时间是**不确定**的！

```ascii
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
```

这会导致如果一个线程更新了某个变量，另一个线程读取的值**可能**还是**更新前**的。例如，主内存的变量`a = true`，线程1对主线程的`a`执行`a = false`时，它在此刻仅仅是把变量`a`的副本变成了`false`，主内存的变量`a`还是`true`，在JVM把修改后的`a`回写到主内存之前，其他线程读取到的`a`的值仍然是`true`，这就造成了多线程之间共享的变量不一致。

因此，`volatile`关键字的目的是告诉虚拟机：

- 每次访问变量时，总是获取主内存的**最新值**；
- 每次修改变量后，**立刻回写**到主内存。

`volatile`关键字解决的是可见性问题：当一个**线程**修改了某个**共享变量**的值，其他线程能够**立刻看到**修改后的值。

如果我们去掉`volatile`关键字，运行上述程序，发现效果和带`volatile`差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。

**ABA问题**

`volatile`关键字可能会导致ABA问题，但不使用`volatile`关键字更容易导致ABA问题。

ABA问题是指在多线程环境下，一个值从A变成了B，然后又变回A，在这个过程中可能会引发一些意料之外的问题。

使用`volatile`关键字修饰的变量可以确保多个线程能够正确地读取和修改该变量，但是它并不能解决ABA问题。例如，线程1读取一个`volatile`变量的值为A，然后线程2将其修改为B，最后线程2又将其修改回A，这个过程中线程1可能并不知道变量的值曾经变成过B，因为`volatile`只保证了可见性，并没有解决ABA问题。

要解决ABA问题，可以使用`AtomicStampedReference`类或`AtomicMarkableReference`类，它们可以在引用的同时记录一个标记（stamp或mark），当引用发生变化时，标记也会相应地发生变化，从而避免了ABA问题。

## 守护线程

Java程序入口就是由JVM启动`main`线程，`main`线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。

如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：

```java
Thread t=new Thread(()->{
    while (true) {
        System.out.println(LocalTime.now());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            break;
        }
    }
});
t.start();
```

如果这个线程不结束，JVM进程就无法结束。**这类线程**经常没有负责人来负责结束它们。但是，当**其他线程**结束时，JVM进程又必须要结束。而使用使用守护线程（Daemon Thread）是一个好办法。守护线程是指为其他线程服务的线程。在JVM中，所有**非守护线程**都执行完毕后，无论有没有守护线程，虚拟机**都会**自动退出。在调用`start()`方法前，调用`setDaemon(true)`就能把该线程标记为守护线程，然后JVM就会无视它了。

在守护线程中，编写代码要注意：守护线程**不能持有**任何需要关闭的资源，例如打开文件等，因为**虚拟机退出**时，可不管你守护线程在干什么，就像在任务管理器结束进程，可不需要进程同意结束进程，守护线程**没有任何机会来关闭文件**，这会导致数据丢失。

所有非守护线程都结束时，JVM会立即杀死所有守护线程并退出。这是因为守护线程被认为是为其他线程提供服务的线程，当所有的非守护线程结束时，守护线程也就没有存在的必要了，因此JVM会终止这些守护线程，然后退出。

父子线程只是谁创建了谁的关系，并没有先后或从属之分，只要创建并运行后，这个所谓的子线程其实和父线程是相互独立的。 

如果想要实现父线程结束时，子线程也结束的效果，可以在子线程中判断父线程是否存活。 `while (fatherThread.isAlive())`，示例代码：

```java
Thread fatherThread = Thread.currentThread(); // 获取当前线程，即对于t的父线程
Thread t = new Thread(()->{
    int n = 0;
    while (fatherThread.isAlive()) {
        System.out.println("Main还活着" + n++);
    }
    System.out.println("Main已关闭了");
});
t.setDaemon(true);//设置守护线程，JVM无视其运行状态
t.start();
Thread.sleep(10);
System.out.println("已关闭");
```

守护进程会在父线程结束后结束。

可以通过`System.exit(0);`显示的控制JVM关闭。如果在最后一行调用`System.exit(0);`，`t`线程就算不是守护线程JVM也会立即终止。

## 线程同步

当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在**任何指令处被操作系统暂停**，然后在某个时间段后继续执行。

这个时候，有个单线程模型下不存在的问题就来了：如果**多个线程同时读写共享变量**，会出现**数据不一致**的问题。

```java
public class Main {
    public static volatile int count = 0;
    public static void main(String[] args) throws Exception {
        Thread add = new Thread(()->{
            for (int i=0; i<10000; i++) { Main.count += 1; }
        });
        Thread dec = new Thread(()->{
            for (int i=0; i<10000; i++) { Main.count -= 1; }
        });
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Main.count);
    }
}
```

上面的代码很简单，两个线程同时对一个`int`变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。

这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。

对于语句：

```java
n = n + 1;
```

看上去是一行语句，实际上对应了3条指令：

```java
ILOAD
IADD
ISTORE
```

假设`n`的值是`100`，如果两个线程同时执行`n = n + 1`，得到的结果很可能不是`102`，而是`101`，原因在于：

```ascii
┌───────┐    ┌───────┐
│Thread1│    │Thread2│
└───┬───┘    └───┬───┘
    │            │
    │ILOAD (100) │
    │            │ILOAD (100)
    │            │IADD
    │            │ISTORE (101)
    │IADD        │
    │ISTORE (101)│
    ▼            ▼
```

如果线程1在执行`ILOAD`后被操作系统中断，此刻如果线程2被调度执行，它执行`ILOAD`后获取的值仍然是`100`，最终结果被两个线程的`ISTORE`写入后变成了`101`，而不是期待的`102`。

这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证**一组指令**以**原子**方式执行：即某一个线程执行时，其他线程必须等待：

```ascii
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
```

通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为**临界区**（Critical Section），任何时候临界区最多只有一个线程能执行。

### synchronized

保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用`synchronized`关键字对一个对象进行加锁，`synchronized`保证了**代码块**在任意时刻最多只有一个线程能执行。

```java
synchronized(lock) {
    n = n + 1;
}
```

修改后：

```java
public class Main {
    public static final Object lock = new Object();
    public static volatile int count = 0;
    public static void main(String[] args) throws Exception {
        Thread add = new Thread(()->{
            for (int i=0; i<10000; i++) {
                synchronized (Main.lock) {
                    Main.count += 1;
                }
            }
        });
        Thread dec = new Thread(()->{
            for (int i=0; i<10000; i++) {
                synchronized (Main.lock) {
                    Main.count -= 1;
                }
            }
        });
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Main.count);
    }
}
```

注意到代码：

```java
synchronized(Main.lock) { // 获取锁
    ...
} // 释放锁
```

它表示用`Main.lock`实例作为锁，两个线程在执行各自的`synchronized(Main.lock) { ... }`代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在`synchronized`语句块结束会自动释放锁。这样一来，对`Main.count`变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。

------

使用`synchronized`解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了**性能下降**。因为`synchronized`代码块无法并发执行，且加锁和解锁需要消耗一定的时间，所以，`synchronized`会降低程序的执行效率。

如何使用`synchronized`：

1. 找出**修改共享变量的线程代码块**；
2. 选择一个**共享实例**作为锁；
3. 使用`synchronized(lockObject) { ... }`。

在使用`synchronized`的时候，不必担心抛出异常。因为无论是否有异常，都会在`synchronized`结束处正确释放锁。

------

**不需要锁的原子操作，JVM规范定义了几种原子操作**：

- 基本类型（`long`和`double`**除外**）**赋值**，例如：`int n = m`；
- 引用类型**赋值**，例如：`List<String> list = anotherList`。

`long`和`double`是64位数据，JVM**没有明确规定**64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把`long`和`double`的赋值作为原子操作实现的。

单条原子操作不需要锁，如果是多条原子操作，则需要锁。多线程连续读写多个变量时，同步的目的是为了**保证程序逻辑正确**。

不但写需要同步，读也需要同步：

```java
class Point {
    int x;
    int y;
    public void set(int x, int y) {
        synchronized(this) {
            this.x = x;
            this.y = y;
        }
    }
    public int[] get() {
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```

假定当前坐标是`(100, 200)`，那么当设置新坐标为`(110, 220)`时，上述未同步的多线程`get()`**读到**的值可能有：

- (100, 200)：x，y更新前；
- (110, 200)：x更新后，y更新前；
- (110, 220)：x，y更新后。

如果读取到`(110, 200)`，即读到了更新后的x，更新前的y，那么可能会造成程序的逻辑错误，无法保证读取的多个变量状态保持一致。

有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：

```java
class Point {
    int[] ps;
    public void set(int x, int y) {
        int[] ps = new int[] { x, y };
        this.ps = ps;
    }
}
```

`this.ps = ps;`是原子操作。而`int[] ps = new int[] { x, y };`不是，不过没有关系，因为`x`与`y`不是共享变量，它们的值只在当前线程中可见，所以在这种情况下，不需要担心原子性问题。重要的是`ps`，原子操作保证了`ps`**要么是赋值前的值，要么是赋值后的值**。

不过`get()`读取还是有可能存在`x`更新后，`y`更新前的情况，这个问题并没有解决。

------

### 测试同步问题

```java
package com.aotmd;

import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Point point = new Point();
        Map<String,Integer> map=new HashMap<>();
        Thread thread = new Thread(()->{
            // 超出出后停止
            for (int x=0,y=1;y<100000000;x++,y++){
                point.set(x,y);
            }
        });
        Thread thread2 = new Thread(()->{
            // 线程thread执行完后关闭
            while (thread.isAlive()){
                int[] ints;
                ints = point.get();
                if (ints[0]-ints[1]!=-1){
                    String s="x="+ints[0]+",y="+ints[1];
                    if (!map.containsKey(s)) {
                        map.put(s,1);
                    }else {
                        map.put(s,map.get(s)+1);
                    }
                }
            }
        });
        thread.start();
        thread2.start();
        thread.join();
        thread2.join();
        int count=0;
        for (Map.Entry<String, Integer> stringIntegerEntry : map.entrySet()) {
            String key = stringIntegerEntry.getKey();
            Integer value = stringIntegerEntry.getValue();
            count+=value;
            System.out.println(key+",count:"+value);
        }
        System.out.println("一共"+count+"条同步问题");
    }
}
class Point {
    int x;
    int y;
    public void set(int x, int y) {
            this.x = x;
            this.y = y;
    }
    public int[] get(){
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```

控制台提示有同步问题，**1000条左右的量级**。

那么把`set`，**加锁**：

```java
public void set(int x, int y) {
    synchronized (this) {
        this.x = x;
        this.y = y;
    }
}
```

控制台提示有同步问题，**100w条左右的量级**，为什么同步问题更多了呢？因为加锁后性能变低了。

那么把`get`也**加相同锁**：

```java
public int[] get(){
    synchronized (this) {
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```

肯定没问题，因为`get`要等全部`set`完才执行，这时就不存在共享变量了。

那么把get改成**不同锁**：

```java
public int[] get(){
    synchronized (new Object()) {
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```

那`get`的`synchronized`就锁了个寂寞，控制台提示有同步问题，**100w条左右的量级**

那么把`Point`的`set`改写成线程安全的形式：

```java
class Point {
    int[] ps;
    public void set(int x, int y) {
        int[] ps = new int[] { x, y };
        this.ps = ps;
    }
    public int[] get(){
        int[] copy = new int[2];
        copy[0] = ps[0];
        copy[1] = ps[1];
        return copy;
    }
}
```

`get`还有线程安全问题，控制台提示有同步问题，**大概100条左右的量级**。

那么把`get`改写成：

```java
public int[] get(){
    int[] copy = new int[]{ps[0],ps[1]};
    return copy;
}
```

当然有问题，不是原子性的语句，控制台提示有同步问题，**大概100条左右的量级**。

那么最终改成：

```java
public void set(int x, int y) {
    this.ps = new int[] { x, y };
}
public int[] get(){
    return new int[]{ps[0],ps[1]};
}
```

还是一样的问题，控制台提示有同步问题，**大概100条作用的量级**。

那么把`get`改成：

```java
public int[] get(){
    return ps.clone();
}
```

**问题解决**，一共0条同步问题。

------

胡乱分析：

```java
public void set(int x, int y) {
    this.ps = new int[] { x, y };
}
```

对于 `this.ps = new int[] { x, y };`来说，它实际上解决的是同时将`x`，`y`赋值到`ps`的问题，因为对于引用类型变量来说赋值是原子的，所以问题解决了。但是获取`x`，`y`的值可不是原子的，为什么这里没有问题呢？因为`x`与`y`都是局部变量，不会有变量共享问题。

```java
public int[] get(){
    return new int[]{ps[0],ps[1]};
}
```

而对于`get`来说，`ps[0]`,`ps[1]`有变量共享问题，因为`ps`是共享变量。

总的来说，在这段测试代码中，只要`set`和`get`方法有一个有同步问题就会导致测试代码出问题。

------

**不可变对象无需同步**

如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：

```java
class Data {
    List<String> names;
    void set(String[] names) {
        this.names = List.of(names);
    }
    List<String> get() {
        return this.names;
    }
}
```

`set()`方法内部创建了一个不可变`List`，这个`List`包含的对象也是不可变对象`String`，因此，整个`List<String>`对象都是不可变的，因此读写均无需同步。

------

分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。对于下面这个例子：

```java
class Status {
    List<String> names;
    int x;
    int y;
    void set(String[] names, int n) {
        List<String> ns = List.of(names);
        this.names = ns;
        int step = n * 10;
        this.x += step;
        this.y += step;
    }
    StatusRecord get() {
        return new StatusRecord(this.names, this.x, this.y);
    }
}
```

如果有A、B两个线程，同时执行是指：

- 可能同时执行set()；
- 可能同时执行get()；
- 可能A执行set()，同时B执行get()。

对象的成员变量`names`、`x`、`y`显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量`step`也仅在`set()`方法内部使用，因此每个线程同时执行`set`时都有一份独立的`step`存储在线程的栈上，互不影响，但是局部变量`ns`虽然每个线程也各有一份，但**后续赋值后**对其他线程就变成可见了。对`set()`方法同步时，如果要最小化`synchronized`代码块，可以改写如下：

```java
void set(String[] names, int n) {
    // 局部变量其他线程不可见:
    List<String> ns = List.of(names);
    int step = n * 10;
    synchronized(this) {
        this.names = ns;
        this.x += step;
        this.y += step;
    }
}
```

因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。

------

例子：

```java
package com.aotmd;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Point point = new Point();
        point.set(100, 200);
        Thread t1 = new Thread(() -> {
            point.set(110, 220);
        });
        System.out.println(point);
        t1.start();
        t1.join(1);
        System.out.println(point);
    }
}
class Point {
    int x,y;
    @Override
    public String toString() {
        String s;
        synchronized (this) {
            s = STR."Point{x=\{x}, y=\{y}\{'}'}";
        }
        return s;
    }

    public void set(int x, int y) {
        synchronized (this) {
            this.x = x;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            this.y = y;
        }
    }
}
```

最后一条`System.out.println(point);`会等待`point.set(110, 220);`释放锁后执行。

如果去掉`toString()`的锁，则最后一条`System.out.println(point);`打印的内容是不可确定的，可能是`Point{x=100, y=200}`也可能是`Point{x=110, y=200}`，如果1ms内`set()`没执行完`this.x = x;`那就是`Point{x=110, y=200}`。

------

### `volatile`与`synchronized`

可能导致线程安全的问题有：原子性问题、有序性问题、可见性问题

JAVA构建内存模型JMM来应对，其中`volatile`解决可见性+有序性问题，原子性问题解决思路本质是**互斥**，只能使用锁来解决，比如`synchronized`或者`CAS`

`volatile`只保证每个线程读到的数据是最新值，但不能保证多个线程对同一个变量的操作的原子性。

`synchronized`保证**同步代码块内**的代码同一时刻**只能有一个线程访问**，也确保了可见性、有序性和原子性。

也就是说`synchronized`除了加锁外，还具有内存屏障功能，并且强制读取所有共享变量的主内存最新值，退出`synchronized`时再强制回写主内存（如果有修改）。

### 同步方法

使用`synchronized`的时候，锁住的是哪个对象非常重要。让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把`synchronized`逻辑封装起来。比如：

```java
public class Counter {
    private int count = 0;

    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
    public void dec(int n) {
        synchronized(this) {
            count -= n;
        }
    }
    public int get() {
        return count;
    }
}
```

这样一来，线程调用`add()`、`dec()`方法时，它不必关心同步逻辑，因为`synchronized`代码块在`add()`、`dec()`方法内部。并且`synchronized`锁住的对象是`this`，即**当前实例**，这又使得创建**多个**`Counter`实例的时候，它们之间**互不影响**，可以并发执行。

------

如果一个类被设计为允许多线程正确访问，这个类就是“线程安全”的（thread-safe），上面的`Counter`类就是线程安全的。Java标准库的`java.lang.StringBuffer`也是线程安全的。

还有一些不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访问时只能读不能写，这些不变类也是线程安全的。

最后，类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的。

除了上述几种少数情况，大部分类，例如`ArrayList`，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么`ArrayList`是可以安全地在线程间共享的。 **没有特殊说明时，一个类默认是非线程安全的**。

------

当我们锁住的是`this`实例时，实际上可以用`synchronized`关键字修饰这个**方法**。它表示整个方法都用`this`实例加锁。

而对于`static`方法，是没有`this`实例的，因为`static`方法是针对类而不是实例。但是任何一个类都有一个由JVM自动创建的`Class`实例，因此，对`static`方法添加`synchronized`，锁住的是该类的`Class`实例。即类似：

```java
public class Counter {
    public static void test(int n) {
        synchronized(Counter.class) {
            ...
        }
    }
}
```

如果在**方法**上使用`synchronized`关键字，则表示整个方法都会被加锁，只有获取到锁的线程才能执行该方法。其他线程在获取到锁之前会被阻塞，直到锁被释放。这样可以确保在多线程环境下对该方法的调用是安全的，不会出现竞态条件等问题。确保了在同一时间只有一个线程可以进入该方法的代码块执行。

如果对两个方法**同时**使用`synchronized`关键字，那么这两个方法将会使用**同一把锁**，即`this`。这种情况下，如果一个线程已经获取了锁并在执行其中一个方法，那其他线程就不能同时执行这两个方法中的任意一个，直到获取到锁。

如果希望两个方法**不使用同一把锁**，则不能在方法上使用`synchronized`关键字，在方法体内使用`synchronized(lockObject) { ... }`指定锁即可，或者一个用方法锁，一个用代码锁。

对于单条赋值语句：

```java
public class Counter {
    private int count;
    public int get() {
        return count;
    }
    ...
}
```

不需要同步，因为读取一个 `int` 变量是原子操作，不会出现线程安全问题。

但是如果是两条赋值语句：

```java
public class Counter {
    private int first;
    private int last;

    public Pair get() {
        Pair p = new Pair();
        p.first = first;
        p.last = last;
        return p;
    }
    ...
}
```

`get`方法返回一个包含两个`int`值的对象`Pair`。如果在调用`get`方法的过程中，另一个线程修改了`first`或`last`的值，就可能导致返回的`Pair`对象中的`first`和`last`不是**原子性地对应的**。

为了确保返回的`Pair`对象中的`first`和`last`是**原子性地对应的**，需要在`get`方法内部使用`synchronized`关键字，同时也应该在修改`first`和`last`值的`set`方法上加上`synchronized`关键字，这样既确保在同一时刻只有一个线程能够获取到`first`和`last`的值，保证获取`first`和`last`的过程是原子的。

如果只在`get`方法上加锁，虽然能保证在同一时刻只有一个线程**能够通过`get`方法**获取到`first`和`last`的值，但不能保证获取`first`和`last`的过程是原子的。

原子性指的是一个操作是不可分割的整体，要么全部执行成功，要么全部不执行，不会出现中间状态。在这里，原子性是指保证在读取`first`和`last`时，它们的值是一致的，不存在读到`first`更新后、`last`更新前的情况。使用`synchronized`确保了这种一致性，但并没有保证**同时获取**这两个值，因此把其他的对`first`和`last`写入操作的也锁了才能保证一致性。

如果不需要保证`first`和`last`的**一致性**，即`first`和`last`没有什么关系，那么不需要对这两个变量进行同步操作。同步的目的是为了**保证程序逻辑正确**。

## 死锁























