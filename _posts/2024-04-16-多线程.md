---
layout: post
title: 多线程
categories: Java
description: Java笔记
keywords: Java
---

# 多线程

代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。

**进程**

在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。

某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。

```ascii
                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
```

操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。

因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：

多进程模式（每个进程只有一个线程）：

```ascii
┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
```

多线程模式（一个进程有多个线程）：

```ascii
┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
```

多进程＋多线程模式（复杂度最高）：

```ascii
┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
```

进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。具体采用哪种方式，要考虑到进程和线程的特点。

和多线程相比，多进程的缺点在于：

- 创建进程比创建线程开销大，尤其是在Windows系统上；
- 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：

多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。

**多线程**

Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。

因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。

和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。

Java多线程编程的特点又在于：

- 多线程模型是Java程序最基本的并发模型；
- 后续读写网络、数据库、Web开发等都依赖Java多线程模型。



## 创建新线程

Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行`main()`方法。在`main()`方法中，我们又可以启动其他线程。

要创建一个新线程非常容易，我们需要实例化一个`Thread`实例，然后调用它的`start()`方法。

但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：

方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：

```java
Thread t2 = new Thread(){
    @Override
    public void run() {
        super.run();
        System.out.println("匿名子类");
    }
};
t2.start(); // 启动新线程
```

`start()`方法会在内部自动调用实例的`run()`方法。

方法二：创建`Thread`实例时，传入一个`Runnable`实例，这种方法内部类会取不到当前Thread匿名类对象，可以通过`Thread.currentThread()`得到当前线程对象。

```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Runnable接口匿名类");
    }
});
t.start(); // 启动新线程
```

若外部`Thread`不是匿名的，则也可以在匿名内部类内通过`外部类名.this`来引用外部类的实例。

```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(t);
    }
});
t.start(); // 启动新线程
```

注意不能使用`t`，因为`t`现在还没有初始化（其实内部类代码运行的时候已经实例化了），但对编译器来说无法确定在这个时候`t`是否已经被正确初始化。因此，即使在实际运行时`t`已经被实例化了，编译器也会在编译时会认为`t`是一个未被初始化的变量，从而导致编译错误。

可以使用lambda简化：

```java
Thread t = new Thread(() -> System.out.println("Runnable接口匿名类"));
t.start(); // 启动新线程
```

创建线程后的代码执行顺序：

```java
System.out.println("main方法开始");
Thread t = new Thread(() -> {
    System.out.println("线程开始");
    System.out.println("线程结束");
});
t.start(); // 启动新线程
System.out.println("main方法结束");
```

只能肯定`main`线程先打印`main方法开始`，然后创建并启动了新线程，然后再打印。而新线程会在启动后与`main`线程并发运行，因此对于新线程启用后的打印语句顺序是**不可预知**的，调度由操作系统控制，**程序本身无法确定线程的调度顺序**。

要模拟并发执行的效果，可以在线程中调用`Thread.sleep()`，强迫**当前线程**暂停一段时间：

```java
    System.out.println("main方法开始");
    Thread t = new Thread(() -> {
        System.out.println("线程开始");
        sleep(10);
        System.out.println("线程结束");
    });
    t.start(); // 启动新线程
    sleep(20);
    System.out.println("main方法结束");
}
public static void sleep(long millis){
    try {
        Thread.sleep(millis);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
```

要特别注意：直接调用`Thread`实例的`run()`方法是无效的。直接调用`run()`方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。

**必须**调用`Thread`实例的`start()`方法才能**启动新线程**，如果查看`Thread`类的源代码，会看到`start()`方法内部调用了一个`private native void start0()`方法，`native`修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。

可以通过`setPriority(int n)`对线程设定优先级，n的值范围是1~10, 默认值为5。

JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但决**不能**通过设置优先级来**确保**高优先级的线程**一定会先执行**。

## 线程的状态

在Java程序中，一个线程对象只能调用一次`start()`方法启动新线程，并在新线程中执行`run()`方法。一旦`run()`方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：

- New：新创建的线程，尚未执行；
- Runnable：运行中的线程，正在**执行**`run()`方法的Java代码；
- Blocked：运行中的线程，因为某些操作被**阻塞**而挂起；
- Waiting：运行中的线程，因为某些操作在**等待**中；
- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时**等待**；
- Terminated：线程已**终止**，因为`run()`方法执行完毕。

用一个状态转移图表示如下：

```ascii
         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
```

当线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。

线程终止的原因有：

- 线程正常终止：`run()`方法执行到`return`语句返回；
- 线程意外终止：`run()`方法因为未捕获的异常导致线程终止；
- 对某个线程的`Thread`实例调用`stop()`方法强制终止（强烈不推荐使用）。

一个线程还可以等待另一个线程直到其运行结束。

例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：

```java
System.out.println("main方法开始");
Thread t = new Thread(() -> {
    System.out.println("线程开始");
    System.out.println("线程结束");
});
t.start(); // 启动新线程
t.join();//等待t线程结束
System.out.println("main方法结束");
```

```text
main方法开始
线程开始
线程结束
main方法结束
```

如果`t`线程已经结束，对实例`t`调用`join()`会立刻返回。此外，`join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。

在 Java 中，多线程中的阻塞状态和等待状态是两种不同的状态，它们之间有一些区别：

1. 阻塞状态（Blocked）：
- 当线程在获取锁时被其他线程所占用，导致无法继续执行时，线程会进入阻塞状态。
- 线程进入阻塞状态是因为正在等待某个条件的发生，一旦条件满足，线程将会被唤醒并切换到就绪状态。
- 在阻塞状态下的线程**仍然持有锁**，只是无法继续执行而已。

2. 等待状态（Waiting）：
- 当线程调用 `Object.wait()`、`Thread.join()` 或 `LockSupport.park()` 等方法进入等待状态时，线程会进入等待状态。
- 等待状态下的线程会**释放持有的锁**，等待其他线程调用 `notify()`、`notifyAll()` 或被中断时才能被唤醒。
- 等待状态通常用于线程间的协调和通信，等待特定条件满足后再继续执行。

总的来说，阻塞状态是因为线程被其他原因无法继续执行所产生的状态，而等待状态则是线程主动等待某些条件满足才能继续执行的状态。在编写多线程程序时，理解和正确处理线程的阻塞和等待状态是非常重要的。

## 中断线程

如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是**其他线程**给该线程发一个信号，该线程收到信号后结束执行`run()`方法，使得自身线程能**立刻结束运行**。

假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。

中断一个线程非常简单，只需要在其他线程中对目标线程调用`interrupt()`方法，目标线程**需要反复检测自身状态**是否是interrupted状态，如果是，就立刻结束运行。

```java
Thread t = new Thread(){
    @Override
    public void run() {
        int n=0;
        while (!isInterrupted()){
            try {
                sleep(10);
                n++;
            } catch (InterruptedException e) {
                System.out.println("线程被中断，结束执行");
            }
        }
        System.out.println("中断了，n="+n);
    }
};
System.out.println("开始");
t.start(); // 启动新线程
try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}
t.interrupt();
t.join();
System.out.println("结束");
```

这段代码大概率会一直运行，且`!isInterrupted()`并不会起到中断作用，虽然调用`t.interrupt();`时，会改变`interrupted`的状态，使得`!isInterrupted()`为假。

但主线程请求`t`线程中断时，`t`线程**大概率**是在运行`sleep(10)`，此时线程处在休眠状态，而`sleep(10)`在休眠过程中会检测线程是否出现中断请求，如果检测到了了，则会抛出`InterruptedException`异常，并**清除线程的中断状态**，因此`while`循环不会结束。

也有极小概率会正常终止，当主线程请求`t`线程中断时，如果`t`线程正运行在`n++;`则会在下次循环通过`!isInterrupted()`为假后结束运行。

要让之前的代码正常退出，只需要在`catch`块中添加`break;`。结果如下：

```text
开始
线程被中断，结束执行
中断了，n=9
结束
```

------

在Java中，调用`interrupt()`方法**只是向目标线程发出中断请求**，目标线程可以**选择**是否**响应**这个请求。目标线程可以通过**检查中断状态**并**采取**适当的**措施**来响应中断请求，也可以选择**忽略**中断请求继续执行。

在处理`InterruptedException`时，也可以选择继续等待，或处理中断请求提前结束线程的执行，具体取决于应用程序的需求。

`InterruptedException`通常在以下情况下抛出：

1. 当一个线程处于睡眠状态（通过调用`Thread.sleep()`进入睡眠状态）时，另一个线程调用了该线程的`interrupt()`方法，这会导致处于睡眠状态的线程抛出`InterruptedException`，并且**清除该线程的中断状态**。

2. 如果一个线程在调用`Object.wait()`、`Thread.join()`、`Thread.sleep()`时被中断，则会抛出`InterruptedException`，并且**清除该线程的中断状态**。这样线程在等待某些条件时，如果被中断就会提早终止。

也就是说：当线程处于等待、睡眠状态或以其他方式被占用时，或者线程在活动之前或期间出现中断时会抛出`InterruptedException`。

还可以通过`Thread.currentThread.interrupt()`方法来**重新设置当前线程的中断状态**。这种方式可以在捕获`InterruptedException`异常后，手动设置线程的中断状态为`true`，以便在后续的循环条件中能够正确地退出循环。



**实际上`interrupt()`是这么说的**：

`interrupt()` 方法用于中断线程。除非当前线程是在中断自己，这种情况总是被允许的，否则会调用此线程的 `checkAccess` 方法，可能会导致抛出 `SecurityException`。

如果线程被阻塞在 `Object` 类的 `wait()`、`wait(long)`、`wait(long, int)` 方法，或者 `Thread` 类的 `join()`、`join(long)`、`join(long, int)`、`sleep(long)`、`sleep(long, int)` 方法中，那么它的**中断状态将被清除**，并且会收到一个 `InterruptedException`。

如果线程被阻塞在一个 `InterruptibleChannel` 的 I/O 操作上，那么该通道将被关闭，线程的**中断状态将被设置**，并且线程将收到一个 `java.nio.channels.ClosedByInterruptException`。

如果线程被阻塞在一个 `Selector` 上，那么线程的**中断状态将被设置**，并且它将立即从选择操作中返回，可能返回一个非零值，就像调用了选择器的 `wakeup` 方法一样。

如果以上情况**都不适用**，那么线程的**中断状态将被设置**。

对一个非存活的线程进行中断操作可能没有任何效果。

此外，文档还指出，在 JDK 参考实现中，对于一个非存活的线程进行中断操作仍然**会记录中断请求**，并通过 `interrupted()` 和 `isInterrupted()` 方法报告它。



------

```java
package com.aotmd;

public class Main {
    public static void main(String[] args) throws Exception  {
        Thread t1 = new Thread(()->{
            Thread t2 = new Thread(() -> {
                int n = 0;
                //判断中断状态
                while (!Thread.currentThread().isInterrupted()) {
                    n++;
                    System.out.println(n + " hello!");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        System.out.println("t2：休眠时检测到中断请求");
                        try {Thread.sleep(10);//收拾东西
                            System.out.println("t2：走了！");
                        }catch (InterruptedException _) {
                            System.out.println("t2：别催了，马上走！");
                        }
                        return;
                    }
                }
                System.out.println("t2：运行时检测到中断请求");
                System.out.println("t2：走了！");
            });
            t2.start();// 启动新线程t2
            try {
                t2.join(); // 等待t2线程结束
            } catch (InterruptedException e) {
                System.out.println("t1：Main通知关门了!");
                System.out.println("t1：t2，关门了，快走！");
                t2.interrupt();// 通知t2，中断请求
                try {
                    t2.join();// 等待t2线程结束
                } catch (InterruptedException e2) {
                    System.out.println("t1：又被Main通知关门了!t2怎么还不走？");
                    //t2.join();
                    System.out.println("t1：算了我不等了，我先走了");
                }
            }
        });
        t1.start(); // 启动新线程t1
        Thread.sleep(1000);
        System.out.println("Main：t1，关门了，快走！");
        t1.interrupt();// 通知t1，中断请求
        t1.join(1);// 等1ms
        System.out.println("Main：t1，快点！");
        t1.interrupt();// 再次通知t1，中断请求
        t1.join();// 等待t1，中断完成
        System.out.println("Main：已确认t1走了");
    }
}

```

控制台：

```text
1 hello!
2 hello!
3 hello!
4 hello!
5 hello!
6 hello!
7 hello!
8 hello!
9 hello!
10 hello!
Main：t1，关门了，快走！
t1：Main通知关门了!
t1：t2，关门了，快走！
t2：休眠时检测到中断请求
Main：t1，快点！
t1：又被Main通知关门了!t2怎么还不走？
t1：算了我不等了，我先走了
Main：已确认t1走了
t2：走了！
```

假设代码执行没有消耗时间，`XXXXms`表示程序运行后的时间。

0~1000ms：`t2`持续输出。

1000ms：`main`线程通过调用`t1.interrupt()`从而通知`t1`线程中断，并等待`t1`。

1000ms：而此时`t1`线程正在等待`t2`线程，收到中断请求后抛出异常，捕获异常后`t1`也对`t2`发出中断请求，并等待`t2`。

1000ms：`t2`大概率在休眠时收到中断请求，然后抛出异常，磨蹭10ms后才真正走人。

1000ms：而`main`线程在第一次请求`t1`中断后，间隔1ms，再次催促`t1`中断请求。

1001ms：而此时`t1`线程还在等待`t2`线程，收到中断请求后，不再等待`t2`，也没有继续通知`t2`,直接结束了运行。

1001ms：`main`线程已经得到`t1`线程执行完毕，结束了执行。

1010ms：`t2`磨蹭10ms后才真正走人。



另一个常用的中断线程的方法是设置标志位。我们通常会用一个`running`标志位来标识线程是否应该继续运行，在外部线程中，通过把`HelloThread.running`置为`false`，就可以让线程结束。其实和`interrupt()`方法是一样的，只是`interrupted`字段也会被其他方法检测到状态，比如`join()`、`sleep()`。如果使用自定义的标志位表示中断线程，则其他方法不会响应。

错误写法：

```java
Thread t1 = new Thread(){
    public volatile boolean running=true;
    @Override
    public void run() {
        int n = 0;
        while (running) {
            n ++;
            System.out.println(n + " hello!");
        }
        System.out.println("end!");
    }
};
t1.start(); // 启动新线程t1
Thread.sleep(1);
t1.running=false;// 通知t1，中断请求
t1.join();// 等
```

因为向上转型的原因，`Thread`不存在`running`这个字段，好的，我转回去可以吗，也不行，因为是匿名类。把`Thread`改成`var`倒是可以，`var t1 = new Thread(){...}`，不过不建议。

同样的，如果是实现`Runnable`接口传入`Thread`构造方法，`Thread`当然不知道你定义了`running`这个字段，因为`Runnable`接口只规定了你有`run()`方法。因此只能写正常继承的类了：

```java
package com.aotmd;

public class Main {
    public static void main(String[] args) throws Exception  {
        T1 t1 = new T1();
        t1.start(); // 启动新线程t1
        Thread.sleep(1);
        t1.running=false;// 通知t1，中断请求
        t1.join();// 等
    }
    static class T1 extends Thread{
        public volatile boolean running=true;
        @Override
        public void run() {
            int n = 0;
            while (running) {
                n ++;
                System.out.println(n + " hello!");
            }
            System.out.println("end!");
        }
    }
}
```

控制台：

```text
1 hello!
end!
```

## volatile

注意到`T1`的标志位`boolean running`是一个线程间共享的变量。线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。

为什么要对线程间共享的变量用关键字`volatile`声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，**当线程访问变量时**，它会先获取一个副本，并保存在自己的工作内存中。如果**线程修改了变量的值**，虚拟机会在**某个时刻**把修改后的值回写到主内存，但是，这个时间是**不确定**的！

```ascii
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
```

这会导致如果一个线程更新了某个变量，另一个线程读取的值**可能**还是**更新前**的。例如，主内存的变量`a = true`，线程1对主线程的`a`执行`a = false`时，它在此刻仅仅是把变量`a`的副本变成了`false`，主内存的变量`a`还是`true`，在JVM把修改后的`a`回写到主内存之前，其他线程读取到的`a`的值仍然是`true`，这就造成了多线程之间共享的变量不一致。

因此，`volatile`关键字的目的是告诉虚拟机：

- 每次访问变量时，总是获取主内存的**最新值**；
- 每次修改变量后，**立刻回写**到主内存。

`volatile`关键字解决的是可见性问题：当一个**线程**修改了某个**共享变量**的值，其他线程能够**立刻看到**修改后的值。

如果我们去掉`volatile`关键字，运行上述程序，发现效果和带`volatile`差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。

**ABA问题**

`volatile`关键字可能会导致ABA问题，但不使用`volatile`关键字更容易导致ABA问题。

ABA问题是指在多线程环境下，一个值从A变成了B，然后又变回A，在这个过程中可能会引发一些意料之外的问题。

使用`volatile`关键字修饰的变量可以确保多个线程能够正确地读取和修改该变量，但是它并不能解决ABA问题。例如，线程1读取一个`volatile`变量的值为A，然后线程2将其修改为B，最后线程2又将其修改回A，这个过程中线程1可能并不知道变量的值曾经变成过B，因为`volatile`只保证了可见性，并没有解决ABA问题。

要解决ABA问题，可以使用`AtomicStampedReference`类或`AtomicMarkableReference`类，它们可以在引用的同时记录一个标记（stamp或mark），当引用发生变化时，标记也会相应地发生变化，从而避免了ABA问题。

## 守护线程







