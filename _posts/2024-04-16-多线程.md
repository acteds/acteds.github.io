---
layout: post
title: 多线程
categories: Java
description: Java笔记
keywords: Java
---
# 引言
多线程笔记，包括线程、中断、同步、死锁、等待、唤醒、ReentrantLock、ReadWriteLock、 StampedLock、Semaphore、线程池、 CompletableFuture异步执行、ForkJoin、ThreadLocal、虚拟线程。


# 多线程
操作系统（Windows，macOS，Linux）都可以执行多任务,多任务就是同时运行多个任务。  

**进程**  

在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。  

某些进程内部还需要同时执行多个子任务。例如，在使用Word时，可以一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。  

进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。  

```ascii
                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
```
操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，**如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。**  

因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：  

多进程模式（每个进程只有一个线程）：  

```ascii
┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
```
多线程模式（一个进程有多个线程）：  
```ascii
┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
```
多进程＋多线程模式（复杂度最高）：  
```ascii
┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
```
进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。具体采用哪种方式，要考虑到进程和线程的特点。  

和多线程相比，多进程的缺点在于：  

- 创建进程比创建线程开销大，尤其是在Windows系统上；
- 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。

而多进程的优点在于：  

多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。  

**多线程**  

Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行`main()`方法，在`main()`方法内部，又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。  

因此，对于大多数Java程序来说，说多任务，实际上是说如何使用多线程实现多任务。  

和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。  

Java多线程编程的特点又在于：  

- 多线程模型是Java程序最基本的并发模型；
- 后续读写网络、数据库、Web开发等都依赖Java多线程模型。

------

**线程类`Thread`常用的方法**：  

- `start()`：启动线程，使其处于可运行状态。
- `run()`：线程的执行体，包含了线程要执行的代码。
- `Thread.setDaemon(boolean on)`：设置线程为守护线程或用户线程。守护线程不会阻止程序的终止，当所有的用户线程结束时，守护线程会自动结束。
- `Thread.isDaemon()`：判断线程是否为守护线程。
- `sleep(long millis)`：使当前线程休眠指定的时间，以毫秒为单位。在休眠期间，线程状态不会改变，不会释放已经持有的锁。
- `join()`：等待线程终止。调用此方法的线程将会被阻塞，直到目标线程执行完成。
- `interrupt()`：中断线程。通知目标线程应该中断，但实际中断操作由目标线程自行处理。
- `isInterrupted()`：判断线程是否已经被中断。
- `interrupted()`：判断当前线程是否已经被中断，并清除中断状态。
- `yield()`：让出当前线程的执行权，使得其他具有相同优先级的线程有机会执行。
- `setName(String name)`：设置线程的名称。
- `getName()`：获取线程的名称。
- `isAlive()`：判断线程是否处于活动状态（已启动但尚未终止）。
- `setPriority(int priority)`：设置线程的优先级。优先级范围为1（最低）到10（最高）。
- `getPriority()`：获取线程的优先级。

这些方法可以帮助我们管理和控制线程的执行，使得多线程编程更加灵活和高效。  

------

锁的方法通常与`synchronized`关键字和`java.util.concurrent.locks`包中的锁对象相关联。以下是一些常用的**锁方法**：  

- `synchronized`关键字：用于同步方法或同步块，可以实现对代码块的互斥访问。
- `wait()`：在锁对象上等待，直到其他线程调用该对象的`notify()`或`notifyAll()`方法唤醒该线程。
- `void wait(long timeout)`：同`wait()`，但如果在指定时间内未收到通知，则当前线程会自动唤醒。
- `void wait(long timeout, int nanos)`：类似于`wait(long timeout)`方法，但还可以指定纳秒级别的超时时间。
- `notify()`：唤醒在锁对象上等待的单个线程。
- `notifyAll()`：唤醒在锁对象上等待的所有线程。
- `ReentrantLock`类：可重入锁，提供了更灵活的锁定机制，可以替代`synchronized`关键字。常用方法包括`lock()`、`unlock()`、`tryLock()`等。
- `Condition`接口：配合`ReentrantLock`使用，提供了类似`wait()`和`notify()`的功能，但更加灵活。
- `ReadWriteLock`接口：读写锁，提供了读锁和写锁，可以提高读操作的并发性能。
- `StampedLock`类：提供了一种乐观读锁的机制，适用于读多写少的场景。

这些方法和类可以帮助我们在多线程环境中实现对共享资源的安全访问和控制。  

------

以下是一些`Thread`类中的常用**静态方法**：  

- `Thread.currentThread()`：返回当前正在执行的线程对象。
- `Thread.sleep(long millis)`：使当前线程休眠指定的毫秒数。
- `Thread.yield()`：提示调度器当前线程愿意放弃当前对处理器的使用。
- `Thread.interrupted()`：测试当前线程是否已经中断，并清除该线程的中断状态。
- `Thread.interrupt()`：中断当前线程。

这些静态方法在多线程编程中经常被使用，用于控制线程的行为和状态。  
## 创建新线程

Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行`main()`方法。在`main()`方法中，又可以启动其他线程。  

要创建一个新线程非常容易，实例化一个`Thread`实例，然后调用它的`start()`方法。  

但是这个线程启动后实际上什么也不做就立刻结束了。如果希望新线程能执行指定的代码，有以下几种方法：  

方法一：从`Thread`派生一个自定义类，然后覆写`run()`方法：  

```java
Thread t2 = new Thread(){
    @Override
    public void run() {
        super.run();
        System.out.println("匿名子类");
    }
};
t2.start(); // 启动新线程
```
`start()`方法会在内部自动调用实例的`run()`方法。  

方法二：创建`Thread`实例时，传入一个`Runnable`实例，这种内部类会取不到当前`Thread`匿名子类对象，可以通过`Thread.currentThread()`得到当前线程对象。  

```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Runnable接口匿名类");
    }
});
t.start(); // 启动新线程
```
若外部`Thread`不是匿名的，则也可以在匿名内部类内通过`外部类名.this`来引用外部类的实例。  
```java
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(t);
    }
});
t.start(); // 启动新线程
```
注意不能使用`t`，因为`t`现在还没有初始化（其实内部类代码运行的时候已经实例化了），但对编译器来说无法确定在这个时候`t`是否已经被正确初始化。因此，即使在实际运行时`t`已经被实例化了，编译器也会在编译时会认为`t`是一个未被初始化的变量，从而导致编译错误。  

可以使用lambda简化：  

```java
Thread t = new Thread(() -> System.out.println("Runnable接口匿名类"));
t.start(); // 启动新线程
```
创建线程后的代码执行顺序：  
```java
System.out.println("main方法开始");
Thread t = new Thread(() -> {
    System.out.println("线程开始");
    System.out.println("线程结束");
});
t.start(); // 启动新线程
System.out.println("main方法结束");
```
只能肯定`main`线程先打印`main方法开始`，然后创建并启动了新线程，然后再打印。而新线程会在启动后与`main`线程并发运行，因此对于新线程启用后的打印语句顺序是**不可预知**的，调度由操作系统控制，**程序本身无法确定线程的调度顺序**。  

要特别注意：直接调用`Thread`实例的`run()`方法是**无效**的。直接调用`run()`方法，相当于调用了一个**普通**的Java方法，当前线程并没有任何改变，也不会启动新线程。  

**必须**调用`Thread`实例的`start()`方法才能**启动新线程**，如果查看`Thread`类的源代码，会看到`start()`方法内部调用了一个`private native void start0()`方法，`native`修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。  

可以通过`setPriority(int n)`对线程设定优先级，n的值范围是1~10, 默认值为5。  

JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但**决不能**通过设置优先级来**确保**高优先级的线程**一定会先执行**。  

## 线程的状态
在Java程序中，**一个线程对象只能调用一次`start()`方法启动新线程**，并在新线程中执行`run()`方法。一旦`run()`方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：  
- New：新创建的线程，尚未执行；
- Runnable：运行中的线程，正在**执行**`run()`方法的Java代码；
- Blocked：运行中的线程，因为某些操作被**阻塞**而挂起；
- Waiting：运行中的线程，因为某些操作在**等待**中；
- Timed Waiting：运行中的线程，因为执行`sleep()`方法正在计时**等待**；
- Terminated：线程已**终止**，因为`run()`方法执行完毕。

用一个状态转移图表示如下：  
```ascii
         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
```
当线程启动后，它可以在`Runnable`、`Blocked`、`Waiting`和`Timed Waiting`这几个状态之间切换，直到最后变成`Terminated`状态，线程终止。  
线程终止的原因有：  

- 线程正常终止：`run()`方法执行到`return`语句返回；
- 线程意外终止：`run()`方法因为未捕获的异常导致线程终止；
- 对某个线程的`Thread`实例调用`stop()`方法强制终止（强烈不推荐使用）。

------

**等待其他线程执行完毕**

一个线程还可以**等待**另一个线程直到其运行结束。  

例如，`main`线程在启动`t`线程后，可以通过`t.join()`等待`t`线程结束后再继续运行：  

```java
System.out.println("main方法开始");
Thread t = new Thread(() -> {
    System.out.println("线程开始");
    System.out.println("线程结束");
});
t.start(); // 启动新线程
t.join();//等待t线程结束
System.out.println("main方法结束");
```
```text
main方法开始
线程开始
线程结束
main方法结束
```
如果`t`线程已经结束，对实例`t`调用`join()`会立刻返回。此外，`join(long)`的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。  

------

在 Java 中，**多线程中的阻塞状态和等待状态是两种不同的状态**，它们之间有一些区别：  

1. **阻塞状态（Blocked）**：
- 当一个线程在获取锁时，如果该锁已经被其他线程持有，那么这个线程会进入阻塞状态，直到该锁被释放并且它能够获取到锁为止。
- 当一个线程已经持有锁时，线程进入阻塞状态是因为正在等待某个条件的发生，一旦条件满足，线程将会被唤醒并切换到就绪状态。
- 阻塞状态的线程**仍然持有已经获得的锁**，不会释放锁。

2. **等待状态（Waiting）**：
- 当线程调用 `Object.wait()`、`Thread.join()` 或 `LockSupport.park()` 等方法进入等待状态时，线程会进入等待状态。
- 等待状态下的线程会**释放持有的锁**，等待其他线程调用 `notify()`、`notifyAll()` 或被中断时才能被唤醒，并尝试重新获得之前持有的锁，如果获取成功，则可以继续执行。
- 等待状态通常用于线程间的协调和通信，等待特定条件满足后再继续执行。

总的来说，阻塞状态是因为线程被其他原因无法继续执行所产生的状态，而等待状态则是线程主动等待某些条件满足才能继续执行的状态。在编写多线程程序时，理解和正确处理线程的阻塞和等待状态是非常重要的。  

------

**注意：`Thread.sleep()`不会释放持有的锁。**  

Timed Waiting（计时等待）和Waiting（等待）是两种不同的线程状态。  

- Timed Waiting（计时等待）是指线程在等待一段时间后自动恢复，例如通过调用`Thread.sleep()`或调用了**`Object.wait(long timeout)`**方法。在这种状态下，线程是**持有锁**的。
- Waiting（等待）是指线程在等待某个条件满足后被唤醒，例如通过调用**`Object.wait()`**方法。在这种状态下，线程是**释放了持有的锁**的。

这两种状态的区别在于**是否指定了等待的时间**。Timed Waiting是有一个**固定的等待时间**，而Waiting是等待某个条件的发生，**时间不确定**。  
## 中断线程
如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是**其他线程**给该线程发一个信号，该线程收到信号后应结束执行`run()`方法，使得自身线程能**立刻结束运行**。  

假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。  

中断一个线程非常简单，只需要在**其他线程**中**对目标线程**调用`interrupt()`方法，**目标线程需要反复检测自身状态**是否是interrupted状态，如果是，就立刻结束运行。  

```java
Thread t = new Thread(){
    @Override
    public void run() {
        int n=0;
        while (!isInterrupted()){
            try {
                sleep(10);
                n++;
            } catch (InterruptedException e) {
                System.out.println("线程被中断，结束执行");
            }
        }
        System.out.println("中断了，n="+n);
    }
};
System.out.println("开始");
t.start(); // 启动新线程
try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    throw new RuntimeException(e);
}
t.interrupt();
t.join();
System.out.println("结束");
```
这段代码大概率会一直运行，虽然调用`t.interrupt();`时，会改变`interrupted`的状态，使得`!isInterrupted()`为假。  

但主线程请求`t`线程中断时，`t`线程**大概率**是在运行`sleep(10)`，而**`sleep()`方法会检测线程是否出现中断请求**，如果检测到了，则会抛出`InterruptedException`异常，并**清除线程的中断状态**，而异常又被捕获了，因此`while`循环不会结束。  

也有极小概率会正常终止，当主线程请求`t`线程中断时，如果`t`线程已经运行完`sleep()`,在运行之后的`n++;`则会在下次循环通过`!isInterrupted()`为假后结束循环。  

要让之前的代码正常退出，只需要在`catch`块中添加`break;`。结果如下：  

```text
开始
线程被中断，结束执行
中断了，n=9
结束
```

------

调用`interrupt()`方法**只是向目标线程发出中断请求**，目标线程**可以选择**是否**响应**这个请求。目标线程可以通过**检查中断状态**并**采取**适当的**措施**来响应中断请求，也可以选择**忽略**中断请求继续执行。  

在处理`InterruptedException`时，也可以选择继续等待，或处理中断请求提前结束线程的执行，具体取决于应用程序的需求。  

**`InterruptedException`通常在以下情况下抛出**：  

1. 当一个线程处于计时等待状态（如调用`Thread.sleep()`）时，另一个线程调用了该线程的`interrupt()`方法，这会导致该线程抛出`InterruptedException`，并且**清除该线程的中断状态**。或者在调用`Thread.sleep()`**之前**，另一个线程调用了该线程的`interrupt()`方法，则在执行`Thread.sleep()`**时**会**检测**到中断请求，并抛出异常，清除中断状态。
2. 如果一个线程在调用`Object.wait()`、`Thread.join()`、`Thread.sleep()`时被中断，则会抛出`InterruptedException`，并且**清除该线程的中断状态**。这样线程在等待某些条件时，如果被中断就会提早终止。如果**调用前**被中断请求，则**调用时**也会检测到中断请求，并抛出异常，清除中断状态。

也就是说：当线程处于等待、计时等待状态或以其他方式被占用时，线程在活动之前或期间出现中断时会抛出`InterruptedException`。  

还可以通过`Thread.currentThread().interrupt()`方法来**重新设置当前线程的中断状态**。这种方式可以在捕获`InterruptedException`异常后，手动设置线程的中断状态为`true`，以便在后续的循环条件中能够正确地退出循环。  

因此**正在跑的线程不会响应别的线程发出的中断**。**只有`sleep/wait`状态的线程会响应`interrupt`。**如果一个线程正在跑，别的线程给他发中断请求，如果没有显示的处理中断请求，它要继续跑到自己调用`sleep/wait`的时候，才响应中断请求，抛出异常。  

如果你写了一个计算密集型任务，跑一次要10分钟，为了能及时响应别的线程发的`interrupt`，可以每跑几秒钟就`sleep(1)`一下，确保能及时被`interrupt`。  

**实际上`interrupt()`是这么说的**：  

`interrupt()` 方法用于中断线程。除非当前线程是在中断自己，这种情况总是被允许的，否则会调用此线程的 `checkAccess` 方法，可能会导致抛出 `SecurityException`。  

如果线程被阻塞在 `Object` 类的 `wait()`、`wait(long)`、`wait(long, int)` 方法，或者 `Thread` 类的 `join()`、`join(long)`、`join(long, int)`、`sleep(long)`、`sleep(long, int)` 方法中，那么它的**中断状态将被清除**，并且会收到一个 `InterruptedException`。  

如果线程被阻塞在一个 `InterruptibleChannel` 的 I/O 操作上，那么该通道将被关闭，线程的**中断状态将被设置**，并且线程将收到一个 `java.nio.channels.ClosedByInterruptException`。  

如果线程被阻塞在一个 `Selector` 上，那么线程的**中断状态将被设置**，并且它将立即从选择操作中返回，可能返回一个非零值，就像调用了选择器的 `wakeup` 方法一样。  

如果以上情况**都不适用**，那么线程的**中断状态将被设置**。  

对一个非存活的线程进行中断操作可能没有任何效果。  

此外，文档还指出，在 JDK 参考实现中，对于一个非存活的线程进行中断操作仍然**会记录中断请求**，并通过 `interrupted()` 和 `isInterrupted()` 方法报告它。  

------

```java
package com.aotmd;
public class Main {
    public static void main(String[] args) throws Exception  {
        Thread t1 = new Thread(()->{
            Thread t2 = new Thread(() -> {
                int n = 0;
                //判断中断状态
                while (!Thread.currentThread().isInterrupted()) {
                    n++;
                    System.out.println(n + " hello!");
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        System.out.println("t2：休眠时检测到中断请求");
                        try {Thread.sleep(10);//收拾东西
                            System.out.println("t2：走了！");
                        }catch (InterruptedException _) {
                            System.out.println("t2：别催了，马上走！");
                        }
                        return;
                    }
                }
                System.out.println("t2：运行时检测到中断请求");
                System.out.println("t2：走了！");
            });
            t2.start();// 启动新线程t2
            try {
                t2.join(); // 等待t2线程结束
            } catch (InterruptedException e) {
                System.out.println("t1：Main通知关门了!");
                System.out.println("t1：t2，关门了，快走！");
                t2.interrupt();// 通知t2，中断请求
                try {
                    t2.join();// 等待t2线程结束
                } catch (InterruptedException e2) {
                    System.out.println("t1：又被Main通知关门了!t2怎么还不走？");
                    //t2.join();
                    System.out.println("t1：算了我不等了，我先走了");
                }
            }
        });
        t1.start(); // 启动新线程t1
        Thread.sleep(1000);
        System.out.println("Main：t1，关门了，快走！");
        t1.interrupt();// 通知t1，中断请求
        t1.join(1);// 等1ms
        System.out.println("Main：t1，快点！");
        t1.interrupt();// 再次通知t1，中断请求
        t1.join();// 等待t1，中断完成
        System.out.println("Main：已确认t1走了");
    }
}
```
控制台：  
```text
1 hello!
2 hello!
3 hello!
4 hello!
5 hello!
6 hello!
7 hello!
8 hello!
9 hello!
10 hello!
Main：t1，关门了，快走！
t1：Main通知关门了!
t1：t2，关门了，快走！
t2：休眠时检测到中断请求
Main：t1，快点！
t1：又被Main通知关门了!t2怎么还不走？
t1：算了我不等了，我先走了
Main：已确认t1走了
t2：走了！
```
假设一般代码执行没有消耗时间，`XXXXms`表示程序运行后的时间。  
0~1000ms：`t2`持续输出。  

1000ms：`main`线程通过调用`t1.interrupt()`从而通知`t1`线程中断，并等待`t1`。  

1000ms：而此时`t1`线程正在等待`t2`线程，收到中断请求后，抛出异常，捕获异常后`t1`也对`t2`发出中断请求，并等待`t2`。  

1000ms：`t2`大概率在休眠时收到中断请求，然后抛出异常，磨蹭10ms后才真正走人。  

1001ms：而`main`线程在第一次请求`t1`中断后，间隔1ms，再次催促`t1`中断请求。  

1001ms：而此时`t1`线程还在等待`t2`线程，收到中断请求后，不再等待`t2`，也没有继续通知`t2`,直接结束了运行。  

1001ms：`main`线程已经得到`t1`线程执行完毕，结束了执行。  

1010ms：`t2`磨蹭10ms后才真正走人。  

------

另一个常用的中断线程的方法是设置标志位。通常会用一个`running`标志位来标识线程是否应该继续运行，在外部线程中，通过把`HelloThread.running`置为`false`，就可以让线程结束。其实和`interrupt()`方法是一样的，只是`interrupted`字段也会被其他方法检测到状态，比如`join()`、`sleep()`。如果使用自定义的标志位表示中断线程，则其他方法不会响应。  

错误写法：  

```java
Thread t1 = new Thread(){
    public volatile boolean running=true;
    @Override
    public void run() {
        int n = 0;
        while (running) {
            n ++;
            System.out.println(n + " hello!");
        }
        System.out.println("end!");
    }
};
t1.start(); // 启动新线程t1
Thread.sleep(1);
t1.running=false;// 通知t1，中断请求
t1.join();// 等
```
因为向上转型的原因，`Thread`不存在`running`这个字段，好的，我强转回去可以吗，也不行，因为是匿名类。把`Thread`改成`var`倒是可以，`var t1 = new Thread(){...}`，不过不建议。  

同样的，如果是实现`Runnable`接口传入`Thread`构造方法，`Thread`当然不知道你定义了`running`这个字段，因为`Runnable`接口只规定了你有`run()`方法。因此只能写正常继承的类了：  

```java
package com.aotmd;
public class Main {
    public static void main(String[] args) throws Exception  {
        T1 t1 = new T1();
        t1.start(); // 启动新线程t1
        Thread.sleep(1);
        t1.running=false;// 通知t1，中断请求
        t1.join();// 等
    }
    static class T1 extends Thread{
        public volatile boolean running=true;
        @Override
        public void run() {
            int n = 0;
            while (running) {
                n ++;
                System.out.println(n + " hello!");
            }
            System.out.println("end!");
        }
    }
}
```
控制台：  
```text
1 hello!
end!
```
## volatile
注意到`T1`的标志位`boolean running`是一个线程间共享的变量。线程间共享变量需要使用`volatile`关键字标记，确保每个线程都能读取到更新后的变量值。  

为什么要对线程间共享的变量用关键字`volatile`声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，**当线程访问变量时**，它会先获取一个副本，并保存在自己的工作内存中。如果**线程修改了变量的值**，虚拟机会在**某个时刻**把修改后的值回写到主内存，但是，这个时间是**不确定**的！  

```ascii
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
```
这会导致如果一个线程更新了某个变量，另一个线程读取的值**可能**还是**更新前**的。例如，主内存的变量`a = true`，线程1对主线程的`a`执行`a = false`时，它在此刻仅仅是把变量`a`的副本变成了`false`，主内存的变量`a`还是`true`，在JVM把修改后的`a`回写到主内存之前，其他线程读取到的`a`的值仍然是`true`，这就造成了多线程之间共享的变量不一致。  

而`volatile`关键字的目的是告诉虚拟机：  

- 每次访问变量时，总是获取主内存的**最新值**；
- 每次修改变量后，**立刻回写**到主内存。

`volatile`关键字解决的是可见性问题：当一个**线程**修改了某个**共享变量**的值，其他线程能够**立刻看到**修改后的值。确保多个线程能够正确地读取和修改该变量。

如果去掉`volatile`关键字，运行上述程序，发现效果和带`volatile`差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。  

**ABA问题**  

`volatile`关键字不能解决ABA问题，但不使用`volatile`关键字更会导致ABA问题。  ABA问题是指在多线程环境下，一个值从A变成了B，然后又变回A。  

例如，线程1读取一个`volatile`变量的值为A，然后线程2将其修改为B，最后线程2又将其修改回A，这个过程中线程1可能并不知道变量的值曾经变成过B，因为`volatile`只保证了可见性，并没有解决ABA问题。  

要解决ABA问题，可以使用`AtomicStampedReference`类或`AtomicMarkableReference`类，它们可以在引用的同时记录一个标记（stamp或mark），当引用发生变化时，标记也会相应地发生变化，从而避免了ABA问题。  



## 守护线程
Java程序入口就是由JVM启动`main`线程，`main`线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。  只要有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。

但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：  

```java
Thread t=new Thread(()->{
    while (true) {
        System.out.println(LocalTime.now());
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            break;
        }
    }
});
t.start();
```
如果这个线程不结束，JVM进程就无法结束。**这类线程**经常没有负责人来负责结束它们。但是，当**其他线程**结束时，JVM进程又必须要结束。

使用守护线程（Daemon Thread）是一个好办法，守护线程是指**为其他线程提供服务的线程**。在调用`start()`方法前，调用`setDaemon(true)`就能把该线程标记为守护线程。  

在JVM中，所有**非守护线程**都执行完毕后，无论有没有守护线程，虚拟机**都会**自动退出。因为所有的非守护线程都结束了，守护线程也就没有存在的必要了。  

因此守护线程**不能持有**任何需要关闭的资源，例如打开文件等，因为**虚拟机退出**时，可不管守护线程在干什么，守护线程**没有任何机会来关闭文件**，这会导致数据丢失。  

------

父子线程只是谁创建了谁的关系，并没有先后或从属之分，只要创建并运行后，这个所谓的子线程其实和父线程是相互独立的，它的生命周期不受父线程的生命周期影响。   

如果想要实现父线程结束时，子线程也结束的效果，可以在子线程中判断父线程是否存活。 `while (fatherThread.isAlive())`，示例代码：  

```java
Thread fatherThread = Thread.currentThread(); // 获取当前线程，即对于t的父线程
Thread t = new Thread(()->{
    int n = 0;
    while (fatherThread.isAlive()) {
        System.out.println("Main还活着" + n++);
    }
    System.out.println("Main已关闭了");
});
t.setDaemon(true);//设置守护线程，JVM无视其运行状态
t.start();
Thread.sleep(10);
System.out.println("已关闭");
```
守护进程会在父线程结束后结束。  

可以通过`System.exit(0);`显示的控制JVM关闭。如果在最后一行调用`System.exit(0);`，`t`线程就算不是守护线程JVM也会立即终止。  

## 线程同步
**当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定**。因此，任何一个线程都有可能在**任何指令处被操作系统暂停**，然后在某个时间段后继续执行。  

这个时候，有个单线程模型下不存在的问题就来了：如果**多个线程同时读写共享变量**，会出现**数据不一致**的问题。  

```java
public class Main {
    public static volatile int count = 0;
    public static void main(String[] args) throws Exception {
        Thread add = new Thread(()->{
            for (int i=0; i<10000; i++) { Main.count += 1; }
        });
        Thread dec = new Thread(()->{
            for (int i=0; i<10000; i++) { Main.count -= 1; }
        });
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Main.count);
    }
}
```
上面的代码很简单，两个线程同时对一个`int`变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。  

这是因为对变量进行读取和写入时，如果想得到预期的结果，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。  

对于语句：  

```java
n = n + 1;
```
看上去是一行语句，实际上对应了3条指令：  
```java
ILOAD
IADD
ISTORE
```
假设`n`的值是`100`，如果两个线程同时执行`n = n + 1`，得到的结果很可能不是`102`，而是`101`，原因在于：
```ascii
┌───────┐    ┌───────┐
│Thread1│    │Thread2│
└───┬───┘    └───┬───┘
    │            │
    │ILOAD (100) │
    │            │ILOAD (100)
    │            │IADD
    │            │ISTORE (101)
    │IADD        │
    │ISTORE (101)│
    ▼            ▼
```
如果线程1在执行`ILOAD`后被操作系统中断，此刻如果线程2被调度执行，它执行`ILOAD`后获取的值仍然是`100`，最终结果被两个线程的`ISTORE`写入后变成了`101`，而不是期待的`102`。  

这说明多线程模型下，如果要**保证逻辑正确**，则对**共享变量**进行读写时，必须保证**一组指令**以**原子**方式执行：即某一个线程执行这组指令时，其他想执行这组指令的线程必须等待：  

```ascii
┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
```
通过加锁和解锁的操作，就能保证这3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。

即使在执行期线程**被操作系统中断**执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。

这种加锁和解锁之间的代码块称之为**临界区**（Critical Section），任何时候临界区最多只有一个线程能执行。  

### synchronized
保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用`synchronized`关键字对一个对象进行加锁，`synchronized`保证了**代码块**在任意时刻最多只有一个线程能执行。  
```java
synchronized(lock) {
    n = n + 1;
}
```
修改后：  
```java
public class Main {
    public static final Object lock = new Object();
    public static volatile int count = 0;
    public static void main(String[] args) throws Exception {
        Thread add = new Thread(()->{
            for (int i=0; i<10000; i++) {
                synchronized (Main.lock) {
                    Main.count += 1;
                }
            }
        });
        Thread dec = new Thread(()->{
            for (int i=0; i<10000; i++) {
                synchronized (Main.lock) {
                    Main.count -= 1;
                }
            }
        });
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Main.count);
    }
}
```
注意到代码：  
```java
synchronized(Main.lock) { // 获取锁
    ...
} // 释放锁
```
它表示用`Main.lock`实例作为锁，即`new Object();`这个实例，因为是静态的，所以两个线程通过获得`Main.lock`的是同一个实例。

两个线程在执行各自的`synchronized(Main.lock) { ... }`代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在`synchronized`语句块结束会自动释放锁。这样一来，对`Main.count`变量进行读写就不可能同时进行。

------

使用`synchronized`解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了**性能下降**。因为`synchronized`代码块无法并发执行，且加锁和解锁需要消耗一定的时间，所以，`synchronized`会降低程序的执行效率。  

如何使用`synchronized`：  

1. 找出修改**共享变量**的线程代码块；
2. 选择一个**共享实例**作为锁；
3. 使用`synchronized(lockObject) { ... }`。

在使用`synchronized`的时候，不必担心抛出异常。因为无论是否有异常，都会在`synchronized`结束处正确释放锁。  

------

**不需要锁的原子操作，JVM规范定义了几种原子操作**：  
- 基本类型（`long`和`double`**除外**）**赋值**，例如：`int n = m`；
- 引用类型**赋值**，例如：`List<String> list = anotherList`。

`long`和`double`是64位数据，JVM**没有明确规定**64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把`long`和`double`的赋值作为原子操作实现的。  

单条原子操作不需要锁，如果是多条原子操作，则需要锁。多线程连续读写多个变量时，同步的目的是为了**保证程序逻辑正确**。  

不但写需要同步，读也需要同步：  

```java
class Point {
    int x;
    int y;
    public void set(int x, int y) {
        synchronized(this) {
            this.x = x;
            this.y = y;
        }
    }
    public int[] get() {
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```
假定当前坐标是`(100, 200)`，那么当设置新坐标为`(110, 220)`时，上述未同步的多线程`get()`**读到**的值可能有：  
- (100, 200)：x，y更新前；
- (110, 200)：x更新后，y更新前；
- (110, 220)：x，y更新后。

如果读取到`(110, 200)`，即读到了更新后的x，更新前的y，那么可能会造成程序的逻辑错误，无法保证读取的**多个变量状态保持一致**。  

有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：  

```java
class Point {
    int[] ps;
    public void set(int x, int y) {
        int[] ps = new int[] { x, y };
        this.ps = ps;
    }
}
```
`this.ps = ps;`是原子操作。而`int[] ps = new int[] { x, y };`不是，不过没有关系，因为`x`与`y`不是共享变量，它们的值只在当前线程中可见，所以在这种情况下，不需要担心原子性问题。重要的是`ps`，原子操作保证了`ps`**要么是赋值前的值，要么是赋值后的值**。  

不过`get()`读取还是有可能存在`x`更新后，`y`更新前的情况，这个问题并没有解决。  

------

### 测试同步问题
```java
package com.aotmd;
import java.util.HashMap;
import java.util.Map;
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Point point = new Point();
        Map<String,Integer> map=new HashMap<>();
        Thread thread = new Thread(()->{
            // 超出出后停止
            for (int x=0,y=1;y<100000000;x++,y++){
                point.set(x,y);
            }
        });
        Thread thread2 = new Thread(()->{
            // 线程thread执行完后关闭
            while (thread.isAlive()){
                int[] ints;
                ints = point.get();
                if (ints[0]-ints[1]!=-1){
                    String s="x="+ints[0]+",y="+ints[1];
                    if (!map.containsKey(s)) {
                        map.put(s,1);
                    }else {
                        map.put(s,map.get(s)+1);
                    }
                }
            }
        });
        thread.start();
        thread2.start();
        thread.join();
        thread2.join();
        int count=0;
        for (Map.Entry<String, Integer> stringIntegerEntry : map.entrySet()) {
            String key = stringIntegerEntry.getKey();
            Integer value = stringIntegerEntry.getValue();
            count+=value;
            System.out.println(key+",count:"+value);
        }
        System.out.println("一共"+count+"条同步问题");
    }
}
class Point {
    int x;
    int y;
    public void set(int x, int y) {
        this.x = x;
        this.y = y;
    }
    public int[] get(){
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```
控制台提示有同步问题，**1000条左右的量级**。  

那么把`set`，**加锁**：  

```java
public void set(int x, int y) {
    synchronized (this) {
        this.x = x;
        this.y = y;
    }
}
```
控制台提示有同步问题，**100w条左右的量级**，为什么同步问题更多了呢？因为加锁后性能变低了。  

那么把`get`也**加相同锁**：  

```java
public int[] get(){
    synchronized (this) {
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```
肯定没问题，一次只能有一个线程进入`synchronized (this) {}`,因此`set`和`get`互斥了，这时就不存在同时访问的问题了。  

那么把`get`改成**不同锁**：  

```java
public int[] get(){
    synchronized (new Object()) {
        int[] copy = new int[2];
        copy[0] = x;
        copy[1] = y;
        return copy;
    }
}
```
`new Object()`这样的写法让`synchronized`完全失去了作用，控制台提示有同步问题，**100w条左右的量级**  

那么把`Point`的`set`改写成线程安全的形式：  

```java
class Point {
    int[] ps;
    public void set(int x, int y) {
        int[] ps = new int[] { x, y };
        this.ps = ps;
    }
    public int[] get(){
        int[] copy = new int[2];
        copy[0] = ps[0];
        copy[1] = ps[1];
        return copy;
    }
}
```
但`get`还有线程安全问题，控制台提示有同步问题，**大概100条左右的量级**。  

那么把`get`改写成：  

```java
public int[] get(){
    int[] copy = new int[]{ps[0],ps[1]};
    return copy;
}
```
当然有问题，不是原子性的语句，控制台提示有同步问题，**大概100条左右的量级**。  

那么都简化为一条语句：  

```java
public void set(int x, int y) {
    this.ps = new int[] { x, y };
}
public int[] get(){
    return new int[]{ps[0],ps[1]};
}
```
还是一样的问题，控制台提示有同步问题，**大概100条作用的量级**。  

那么把`get`改成：  

```java
public int[] get(){
    return ps.clone();
}
```
**问题解决**，一共0条同步问题。  

------

胡乱分析：  
```java
public void set(int x, int y) {
    this.ps = new int[] { x, y };
}
```
对于 `this.ps = new int[] { x, y };`来说，它实际上解决的是同时将`x`，`y`赋值到`ps`的问题，因为对于引用类型变量来说赋值是原子的，所以问题解决了。但是获取`x`，`y`的值可不是原子的，为什么这里没有问题呢？因为`x`与`y`都是局部变量，不会有变量共享问题。  
```java
public int[] get(){
    return new int[]{ps[0],ps[1]};
}
```
而对于`get`来说，`ps[0]`,`ps[1]`有变量共享问题，因为`ps`是共享变量。  

总的来说，在这段测试代码中，只要`set`和`get`方法有一个有同步问题就会导致测试代码出问题。  

------

**不可变对象无需同步**  

如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：  

```java
class Data {
    List<String> names;
    void set(String[] names) {
        this.names = List.of(names);
    }
    List<String> get() {
        return this.names;
    }
}
```
`set()`方法内部创建了一个不可变`List`，这个`List`包含的对象也是不可变对象`String`，因此，整个`List<String>`对象都是不可变的，因此读写均无需同步。  

------

分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。
```java
class Status {
    List<String> names;
    int x;
    int y;
    void set(String[] names, int n) {
        List<String> ns = List.of(names);
        this.names = ns;
        int step = n * 10;
        this.x += step;
        this.y += step;
    }
    StatusRecord get() {
        return new StatusRecord(this.names, this.x, this.y);
    }
}
```
如果有A、B两个线程，同时执行是指：  
- 可能同时执行set()；
- 可能同时执行get()；
- 可能A执行set()，同时B执行get()。

对象的成员变量`names`、`x`、`y`显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量`step`也仅在`set()`方法内部使用，因此每个线程同时执行`set`时都有一份独立的`step`存储在线程的栈上，互不影响，但是局部变量`ns`虽然每个线程也各有一份，但**后续赋值后**对其他线程就变成可见了。对`set()`方法同步时，如果要最小化`synchronized`代码块，可以改写如下：  
```java
void set(String[] names, int n) {
    // 局部变量其他线程不可见:
    List<String> ns = List.of(names);
    int step = n * 10;
    synchronized(this) {
        this.names = ns;
        this.x += step;
        this.y += step;
    }
}
```
因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。  

------

例子：  
```java
package com.aotmd;
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Point point = new Point();
        point.set(100, 200);
        Thread t1 = new Thread(() -> {
            point.set(110, 220);
        });
        System.out.println(point);
        t1.start();
        t1.join(1);//停1毫秒
        System.out.println(point);
    }
}
class Point {
    int x,y;
    @Override
    public String toString() {
        String s;
        synchronized (this) {
            s = STR."Point{x=\{x}, y=\{y}\{'}'}";
        }
        return s;
    }
    public void set(int x, int y) {
        synchronized (this) {
            this.x = x;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            this.y = y;
        }
    }
}
```
最后一条`System.out.println(point);`会等待`point.set(110, 220);`执行完释放锁后打印`Point{x=110, y=220}`，当然，如果1ms过去了`t1`线程还没执行`point.set()`拿到锁，则会直接打印`Point{x=110, y=200}`。  

如果去掉`toString()`的锁，则最后一条`System.out.println(point);`打印的内容是不可确定的。

可能是`Point{x=100, y=200}`（`set`执行开始的时间大于1ms）。

可能是`Point{x=110, y=200}`（`set`执行开始的时间小于1ms，执行到一半，在计时等待）。

不太可能是`Point{x=110, y=220}`（`set`执行完了，`println`才执行，也就是说受到神秘力量干涉，`println`延迟了至少999ms才执行）。

  

------

### volatile与synchronized

程安全问题主要包括原子性问题、有序性问题、可见性问题。  为了应对这些问题，Java构建了内存模型JMM（Java Memory Model），并提供了一些解决方案：

1. `volatile`关键字解决可见性和有序性问题：`volatile`关键字用于修饰变量，保证了每个线程读到的数据是最新值，并且禁止了指令重排序。但是，`volatile`不能保证**多个线程对同一个变量的操作**的原子性。
2. `synchronized`关键字解决原子性、可见性和有序性问题：`synchronized`关键字用于创建同步代码块或同步方法，确保同步代码块内的代码在**同一时刻**只能有一个线程访问，从而保证了线程安全。此外，`synchronized`关键字还具有内存屏障的功能，解决可见性和有序性问题。
3. `CAS`（Compare and Swap）解决原子性问题：`CAS`是一种无锁算法，通过比较内存中的值和预期值来决定是否更新内存中的值。`CAS`操作是原子的，可以解决原子性问题。在Java中，`AtomicInteger`、`AtomicLong`等原子类使用了`CAS`操作来实现线程安全的原子操作。

原子性问题解决思路本质是**互斥**。

### 内存屏障

内存屏障（Memory Barrier），也称为内存栅栏或内存栅障，是一种硬件或软件的屏障，用于控制特定指令序列的执行顺序以及对内存访问的顺序和方式。内存屏障在多核处理器和多线程环境下发挥重要作用，确保线程间的内存可见性和有序性，从而保证并发程序的正确性。

内存屏障可以分为以下几种类型：

1. **读屏障（Read Barrier）**：读屏障用于确保在读取操作之前，所有之前的读取和写入操作都已经完成。它可以防止处理器乱序执行指令或缓存数据不一致的情况。

2. **写屏障（Write Barrier）**：写屏障用于确保在写入操作之后，所有之前的写入和读取操作都已经完成。它可以防止处理器将写入操作提前执行，保证写入的值对其他线程可见。

3. **全屏障（Full Barrier）**：全屏障用于同时提供读屏障和写屏障的功能，即在执行全屏障之前，所有之前的读取和写入操作都已经完成；在执行全屏障之后，所有之前的写入和读取操作都已经完成。

内存屏障在Java中的应用：

- 在`volatile`关键字的实现中，编译器会在读取和写入`volatile`变量时插入对应的读屏障和写屏障，保证了`volatile`变量的可见性和有序性。
- 在`synchronized`关键字的实现中，`synchronized`块的进入和退出分别对应了全屏障的插入，**保证了同步代码块内的指令按照预期顺序执行，同时也保证了线程间的内存可见性。**

内存屏障是确保多线程程序正确性的重要机制，它能够控制指令的执行顺序和内存访问的顺序，保证了线程间的通信和协调。

### 同步方法
使用`synchronized`的时候，锁住的是哪个对象非常重要。让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把`synchronized`逻辑封装起来。比如：
```java
public class Counter {
    private int count = 0;
    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
    public void dec(int n) {
        synchronized(this) {
            count -= n;
        }
    }
    public int get() {
        return count;
    }
}
```
这样一来，线程调用`add()`、`dec()`方法时，不必关心同步逻辑，因为`synchronized`代码块在`add()`、`dec()`方法内部。并且`synchronized`锁住的对象是`this`，即**当前实例**，这又使得创建**多个**`Counter`实例的时候，它们之间**互不影响**，可以并发执行。  

------

如果一个类被设计为允许多线程正确访问，这个类就是“线程安全”的（thread-safe），上面的`Counter`类就是线程安全的。Java标准库的`java.lang.StringBuffer`也是线程安全的。  

还有一些不变类，例如`String`，`Integer`，`LocalDate`，它们的所有成员变量都是`final`，多线程同时访问时只能读不能写，这些不变类也是线程安全的。  

最后，类似`Math`这些只提供静态方法，没有成员变量的类，也是线程安全的。  

除了上述几种少数情况，大部分类，例如`ArrayList`，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么`ArrayList`是可以安全地在线程间共享的。 

**没有特殊说明时，一个类默认是非线程安全的**。  

------

当锁住的是`this`实例时，实际上可以用`synchronized`关键字修饰这个**方法**。它表示整个方法都用`this`实例加锁。  

而对于`static`方法，是没有`this`实例的，因为`static`方法是针对类而不是实例。但是任何一个类都有一个由JVM自动创建的`Class`实例，因此，对`static`方法添加`synchronized`，锁住的是该类的`Class`实例。即类似：  

```java
public class Counter {
    public static void test(int n) {
        synchronized(Counter.class) {
            ...
        }
    }
}
```
如果在**方法**上使用`synchronized`关键字，则表示整个方法都会被加锁，只有获取到锁的线程才能执行该方法。其他线程在获取到锁之前会被阻塞，直到锁被释放后，开始竞争锁。这样确保了在同一时间只有一个线程可以进入该方法的代码块执行。  

如果对相同类的两个方法**同时**使用`synchronized`关键字，那么这两个方法将会使用**同一把锁**，即`this`。这种情况下，如果一个线程已经获取了锁在执行其中一个方法，那其他线程就不能同时执行这两个方法中的任意一个。  

如果希望两个方法**不使用同一把锁**，则**不能在方法上**使用`synchronized`关键字。

对于单条赋值语句：  

```java
public class Counter {
    private int count;
    public int get() {
        return count;
    }
    ...
}
```
不需要同步，因为读取一个 `int` 变量是原子操作，不会出现线程安全问题。  
但是如果是两条赋值语句：  
```java
public class Counter {
    private int first;
    private int last;
    public Pair get() {
        Pair p = new Pair();
        p.first = first;
        p.last = last;
        return p;
    }
    ...
}
```
`get`方法返回一个包含两个`int`值的对象`Pair`。如果在调用`get`方法的过程中，另一个线程修改了`first`或`last`的值，就可能导致返回的`Pair`对象中的`first`和`last`不是**原子性地对应的**。  

为了确保返回的`Pair`对象中的`first`和`last`是**原子性地对应的**，需要在`get`方法和修改`first`和`last`值的`set`方法内部使用`synchronized`关键字。

这样既确保在同一时刻只有一个线程能够修改或者获取`first`和`last`的值，保证了获取`first`和`last`的过程是原子的。  

如果只在`get`方法内加锁，只能保证在**同一时刻**只有一个线程能够**通过`get`方法**获取到`first`和`last`的值，我们不需要这个特性，这个特性反而是负面的。还不能保证获取`first`和`last`的过程是原子的。  

原子性指的是一个操作是不可分割的整体，要么全部执行成功，要么全部不执行，不会出现中间状态。在这里，原子性是指保证在读取`first`和`last`时，它们的值是一致的，不存在读到`first`更新后、`last`更新前的情况。

使用`synchronized`确保了这种一致性，但并没有保证是**同时获取了**这两个值，因此把其他的对`first`和`last`写入操作的也锁了才能保证一致性。  

如果不需要保证`first`和`last`的**一致性**，即`first`和`last`没有什么关系，那么不需要对这两个变量进行同步操作。同步的目的是为了**保证程序逻辑正确**。 

 

## 死锁

Java的线程锁是可重入的锁。

```java
public class Counter {
    private int count = 0;
    public synchronized void add(int n) {
        if (n < 0) {
            dec(-n);
        } else {
            count += n;
        }
    }
    public synchronized void dec(int n) {
        count += n;
    }
}
```
一旦线程执行到`add()`方法内部，说明它已经获取了当前实例的`this`锁。如果传入的`n < 0`，将在`add()`方法内部调用`dec()`方法。由于`dec()`方法也需要获取`this`锁，那么对同一个线程，能否在获取到锁以后继续获取同一个锁？  

答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。  

由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出`synchronized`块，记录-1，减到0的时候，才会真正释放锁。  

**死锁**

一个线程可以获取一个锁后，再继续获取另一个锁。例如：  

```java
public void add(int m) {
    synchronized(lockA) { // 获得lockA的锁
        this.value += m;
        synchronized(lockB) { // 获得lockB的锁
            this.another += m;
        } // 释放lockB的锁
    } // 释放lockA的锁
}
public void dec(int m) {
    synchronized(lockB) { // 获得lockB的锁
        this.another -= m;
        synchronized(lockA) { // 获得lockA的锁
            this.value -= m;
        } // 释放lockA的锁
    } // 释放lockB的锁
}
```
在获取多个锁的时候，不同线程获取多个不同对象的锁**可能**导致死锁。对于上述代码，线程1和线程2如果分别执行`add()`和`dec()`方法时：  
- 线程1：进入`add()`，获得`lockA`；
- 线程2：进入`dec()`，获得`lockB`。

随后：  
- 线程1：准备获得`lockB`，失败，等待锁释放中；
- 线程2：准备获得`lockA`，失败，等待锁释放中。

此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。  

死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。如何避免死锁呢？答案是：线程获取锁的顺序要一致。**所有**使用一组相同的锁的**线程**，获取锁的顺序要保持一致。

避免死锁的一个有效策略是保持线程获取锁的顺序一致。这样可以避免循环等待条件，从而减少死锁的发生。还有其他一些避免死锁的策略，比如尽量减少锁的持有时间、使用超时机制来获取锁、以及使用锁的层次结构等。

死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种僵局，若无外力作用，这些线程都将无法继续执行下去。死锁发生必须同时满足以下四个条件，称为死锁的必要条件：  

1. **互斥条件（Mutual Exclusion）**：一个资源每次只能被一个线程使用，即在一段时间内某资源只能被一个线程占用。如果此时有其他线程请求该资源，请求线程只能等待。
2. **请求与保持条件（Hold and Wait）**：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不可抢占条件（No Preemption）**：已获得的资源在未使用完之前，不能被强行剥夺，只能由持有资源的线程自行释放。
4. **循环等待条件（Circular Wait）**：若干线程之间形成一种头尾相接的循环等待资源关系。

当以上四个条件同时满足时，就会导致死锁的发生。为了避免死锁，可以采用破坏这些条件的方法，如破坏循环等待条件、引入超时机制等。  
## wait和notify
在Java程序中，`synchronized`解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用`synchronized`加锁：  
```java
class TaskQueue {
    Queue<String> queue = new LinkedList<>();
    public synchronized void addTask(String s) {
        this.queue.add(s);
    }
    public synchronized String getTask() {
        while (queue.isEmpty()) {
        }
        return queue.remove();
    }
}
```
但是`synchronized`并没有解决多线程协调的问题。  

`getTask()`的`while()`循环永远不会退出，因为锁没有释放，其他线程根本无法调用`addTask()`。实际上代码应该实现以下效果：  

- 线程1可以调用`addTask()`不断往队列中添加任务；
- 线程2可以调用`getTask()`从队列中获取任务。如果队列为空，则`getTask()`应该等待，直到队列中至少有一个任务时再返回。

多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。  

可以通过调用`wait()`方法让线程进入等待状态，调用`wait()`方法会一直等待到被其他线程唤醒后才会返回。必须在`synchronized`块中才能调用`wait()`方法，也只能在锁对象上调用`wait()`方法，因为`wait()`方法调用时，会**释放线程获得的锁**，`wait()`方法返回后，线程又会重新**试图获得之前放弃的锁**。  

如何让等待的线程被重新唤醒，然后从`wait()`方法返回？答案是在**相同**的锁对象上调用`notify()`方法。那么代码修改如下：  

```java
package com.aotmd;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
public class Main {
    public static void main(String[] args) throws InterruptedException {
        var q = new TaskQueue();
        //启动5个获取任务
        var ts = getThreads(q);
        //添加10个任务，每隔100ms
        var add = new Thread(() -> {
            for (int i=0; i<10; i++) {
                System.out.print("添加任务: " + i);
                q.addTask(String.valueOf(i));
                try { Thread.sleep(100); } catch(InterruptedException _) {}
            }
        });
        add.start();
        add.join();
        Thread.sleep(100);
        //中断
        for (var t : ts) {
            t.interrupt();
        }
    }
    private static ArrayList<Thread> getThreads(TaskQueue q) {
        var ts = new ArrayList<Thread>();
        for (int i=0; i<5; i++) {
            Thread t = new Thread(() -> {
                while (true) {
                    try {
                        String s = q.getTask();
                        System.out.println("，线程："+Thread.currentThread().getName()+"，执行任务: " + s);
                    } catch (InterruptedException e) {
                        return;
                    }
                }
            });
            t.start();
            ts.add(t);
        }
        return ts;
    }
}
class TaskQueue {
    Queue<String> queue = new LinkedList<>();
    public synchronized void addTask(String s) {
        this.queue.add(s);
        this.notifyAll();
    }
    public synchronized String getTask() throws InterruptedException {
        while (queue.isEmpty()) {
            this.wait();
        }
        return queue.remove();
    }
}
```
使用`notifyAll()`会唤醒**所有**等待该锁的线程，而`notify()`只会唤醒其中**一个**线程。在使用`notify()`时，如果唤醒的线程不是所期望的线程，那么其他线程可能会一直等待下去，造成资源的浪费和程序性能的下降。因此，通常情况下推荐使用`notifyAll()`来确保所有等待线程都有机会被唤醒。

`wait()`方法返回时需要重新获得`this`锁。假设有3个线程被唤醒，唤醒后，首先等待执行`addTask()`的线程结束此方法后，才能释放`this`锁，随后，这3个线程中只能有一个获取到`this`锁，**剩下两个将等待锁释放后继续竞争锁**，竞争成功后开始运行。  

如果在`getTask()`不是使用`while`而是使用`if`，则剩下的两个将依次得到锁后直接执行`queue.remove();`，而此时队列中已经没有东西了，则会抛出异常，终止此线程。  

是`while`的话,则剩下的两个依次得到锁后后会再次判断`queue.isEmpty()`，如果是则会继续等待。  

当然，如果改用`notify()`+`if`则不会出现问题,因为一次只唤醒一个线程:  

```java
class TaskQueue {
    Queue<String> queue = new LinkedList<>();
    public synchronized void addTask(String s) {
        this.queue.add(s);
        this.notify();
    }
    public synchronized String getTask() throws InterruptedException {
        if (queue.isEmpty()) {
            this.wait();
        }
        return queue.remove();
    }
}
```
**方法：**
1. `wait()`：在锁对象上等待，直到其他线程调用该对象的`notify()`或`notifyAll()`方法唤醒该线程。
2. `void wait(long timeout)`：同`wait()`，但如果在指定时间内未收到通知，则当前线程会自动唤醒。
3. `void wait(long timeout, int nanos)`：类似于`wait(long timeout)`方法，但还可以指定纳秒级别的超时时间。
4. `notify()`：唤醒在锁对象上等待的单个线程。
5. `notifyAll()`：唤醒在锁对象上等待的所有线程。

## ReentrantLock
从**Java 5**开始，引入了一个高级的处理并发的`java.util.concurrent`包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。 

Java提供了`synchronized`关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。  

`java.util.concurrent.locks`包提供的`ReentrantLock`用于替代`synchronized`加锁。对比：  

```java
public class Counter {
    private int count;
    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
}
```
如果用`ReentrantLock`替代，可以把代码改造为：  
```java
public class Counter {
    private final Lock lock = new ReentrantLock();
    private int count;
    public void add(int n) {
        lock.lock();
        try {
            count += n;
        } finally {
            lock.unlock();
        }
    }
}
```
`synchronized`是Java语言层面提供的语法，所以不需要考虑异常。而`ReentrantLock`是Java代码实现的锁，**就必须先获取锁，然后在`finally`中正确释放锁**。  

顾名思义，`ReentrantLock`是可重入锁，它和`synchronized`一样，一个线程可以多次获取同一个锁。  

和`synchronized`不同的是，`ReentrantLock`可以**尝试获取锁**：  

```java
if (lock.tryLock(1, TimeUnit.SECONDS)) {
    try {
        ...
    } finally {
        lock.unlock();
    }
}
```
上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，`tryLock()`返回`false`，程序就可以做一些额外处理，而不是无限等待下去。  

所以，使用`ReentrantLock`比直接使用`synchronized`更安全，线程在`tryLock()`失败的时候不会导致死锁。  

`tryLock()`:尝试获取锁，如果锁当前是空闲的，则获取锁并立即返回`true`；如果锁不可用，则立即返回`false`，而不会等待。下面是一个典型的使用示例：  

```java
Lock lock = ...;
if (lock.tryLock()) {
    try {
        // 操作受保护的状态
    } finally {
        lock.unlock();
    }
} else {
    // 执行备选操作
}
```
这种用法确保如果成功获取了锁，则在最后释放锁，如果没有获取到锁，则不会尝试释放锁。`tryLock()`方法的返回值为`true`表示成功获取锁，为`false`表示未能获取锁。  

`tryLock(long time, TimeUnit unit)`这个方法尝试在给定的等待时间内获取锁，如果锁当前是空闲的，则获取锁并立即返回`true`；如果锁不可用，则当前线程将被禁用以进行线程调度，并且处于计时等待状态，直到以下三种情况发生之一：  

1. 当前线程成功获取了锁；
2. 其他某个线程中断了当前线程，且支持锁获取时中断；
3. 指定的等待时间过去了。

如果成功获取了锁，则返回`true`。

如果在方法调用前当前线程的中断状态被设置，或者在获取锁的过程中被中断，且支持锁获取时中断，则会抛出`InterruptedException`异常，并且会清除当前线程的中断状态。

如果指定的等待时间过去了但没有获取到锁，则返回`false`。如果指定的等待时间小于或等于零，则方法不会等待。  

实现注意事项：  

1. 在某些情况下，锁的获取可能无法被中断，或者中断锁获取可能是一项昂贵的操作。这提醒开发者在使用锁时要注意这一点，避免过度依赖锁的中断操作。
2. 会优先响应中断，而不是正常方法返回，或者报告超时。
3. 锁的实现可能会检测到一些错误使用情况，比如可能导致死锁的调用，这种情况下锁可能会抛出异常。开发者需要了解这些情况并遵循实现的文档说明，以避免出现异常情况。

参数：  
- `time` - 等待获取锁的最长时间
- `unit` - `time` 参数的时间单位

返回值：  
- 如果获取了锁则返回`true`，如果等待时间过去了但没有获取到锁则返回`false`

抛出：  
- `InterruptedException` - 如果当前线程在获取锁时被中断（且支持锁获取时中断）

------

**方法：**  
- `lock()`: 获取锁。如果锁不可用，当前线程将被阻塞，直到获取到锁为止。
- `lockInterruptibly()`: 获取锁，但是可以响应中断。如果锁不可用，当前线程将被阻塞，直到获取到锁或者被中断为止。
- `tryLock()`: 尝试获取锁，如果锁可用立即返回`true`，否则返回`false`。
- `tryLock(long timeout, TimeUnit unit)`: 在指定的时间内尝试获取锁。如果在指定时间内获取到了锁，返回`true`，否则返回`false`。
- `unlock()`: 释放锁。
- `getHoldCount()`: 返回当前线程持有此锁的次数。
- `getQueueLength()`: 返回等待获取此锁的线程估计数。
- `hasQueuedThreads()`: 查询是否有线程正在等待获取此锁。
- `isFair()`: 查询是否是公平锁。
- `isHeldByCurrentThread()`: 查询当前线程是否持有此锁。
- `isLocked()`: 查询此锁是否被任意线程持有。
- `Condition newCondition()`：创建一个绑定到此锁实例的新`Condition`实例，用于线程间通信。

## Condition
使用`ReentrantLock`比直接使用`synchronized`更安全，可以替代`synchronized`进行线程同步。  

但是`synchronized`可以配合`wait`和`notify`实现线程在条件不满足时等待，条件满足时唤醒，用`ReentrantLock`怎么编写`wait`和`notify`的功能呢？  

答案是使用`Condition`对象来实现`wait`和`notify`的功能。  

仍然以`TaskQueue`为例，把前面用`synchronized`实现的功能通过`ReentrantLock`和`Condition`来实现：  

```java
class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();
    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            // 可以替换为LockSupport.unpark(Thread.currentThread());
            condition.signal();//唤醒一个
            condition.signalAll();//唤醒全部
        } finally {
            lock.unlock();
        }
    }
    public String getTask() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                // 可以替换为LockSupport.park()
                condition.await();//等待
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
```
使用`Condition`时，引用的`Condition`对象必须从`Lock`实例的`newCondition()`返回，这样才能获得一个绑定了`Lock`实例的`Condition`实例。  

`Condition`提供的`await()`、`signal()`、`signalAll()`原理和`synchronized`锁对象的`wait()`、`notify()`、`notifyAll()`是一致的，并且其行为也是一样的：  

- `await()`会释放当前锁，进入等待状态；
- `awaitUninterruptibly()`: 与`await()`类似，但不会响应中断。
- `long awaitNanos(long nanosTimeout)`：类似于`await()`，但最多等待指定的纳秒数。
- `boolean await(long time, TimeUnit unit)`：类似于`await()`，但最多等待指定的时间。
- `signal()`会唤醒某个等待线程；
- `signalAll()`会唤醒所有等待线程；
- 唤醒线程从`await()`返回一样需要重新获得之前放弃的锁。

和`tryLock()`类似，`await()`可以在等待指定时间后，如果还没有被其他线程通过`signal()`或`signalAll()`唤醒，可以自己醒来：  
```java
if (condition.await(1, TimeUnit.SECOND)) {
    // 被其他线程唤醒
} else {
    // 指定时间内没有被其他线程唤醒
}
```
可见，使用`Condition`配合`Lock`，可以实现更灵活的线程同步。  

**注意`lock.newCondition();`每次都返回一个新的`Condition`**，这样写就不在一个频道了，肯定无法唤醒：  

```java
class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private final Condition condition2 = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();
    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signal();//唤醒一个
            condition.signalAll();//唤醒全部
        } finally {
            lock.unlock();
        }
    }
    public String getTask() throws InterruptedException {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition2.await();//等待
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
```
`condition`和`condition2`是两个独立的条件对象，它们可以分别用于不同的线程等待和唤醒操作。这样可以**更精细地控制线程的等待和唤醒逻辑**，确保线程在正确的条件下被唤醒。通过使用不同的`Condition`对象，可以更好地组织和管理线程的等待和唤醒操作，提高多线程程序的效率和可维护性。  
## ReadWriteLock
`ReentrantLock`保证了只有一个线程可以执行临界区代码。  

但是有些时候，这种保护有点过头。任何时刻，只允许一个线程修改，但是读取也被限制为一个线程了。  

实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待。  

使用`ReadWriteLock`可以解决这个问题，它保证：  

- 只允许一个线程写入（其他线程既不能写入也不能读取）；
- 没有写入时，多个线程允许同时读（提高性能）。

`ReadWriteLock`并不是写优先于读，它只是提供了更灵活的读写锁机制，允许多个线程同时读取数据，但只允许一个线程写入数据。  

1. 多个线程可以同时获取读锁（共享锁），以便同时读取共享资源，这样可以提高并发性能。
2. 写锁是排它的，即只有一个线程可以获取写锁，当有线程持有写锁时，**其他线程无法获取读锁或写锁**。

------

当有多个读线程持有读锁时，写线程必须等待**所有的线程释放弃读锁**后才能获取写锁。这保证了在写操作进行时，不会有任何其他线程持有读锁，从而确保了写操作的**独占性**，避免了写操作和读操作的并发冲突，从而保证了数据的一致性和正确性。  

当**申请写锁**的时候，如果当前有若干取得读锁正在读的线程，那么就**不允许后续准备申请读锁的线程去拿读锁了**，这时会等到当前读锁全部释放后，拿到写锁。这么做是防止如果写锁没有高优先级，在大量线程不停读的情况下，写不进去。  

一般来说**写锁**的优先级要**高于读锁**，假定读很多几乎不会间断，如果突然来个写锁，那么只需等当前正在读的释放读锁后，写就立刻获得写锁，其它后续读都得等，不然你想，在一直都有读的情况下，永远写不了。  

通过读写锁的机制，写锁在请求时会阻塞后续的读锁请求，直到写锁被获取并完成写操作。这种机制确保了写操作的优先级，避免了写锁长时间等待的情况，从而防止了写锁被饿死的情况发生。  

------

用`ReadWriteLock`实现这个功能十分容易。需要创建一个`ReadWriteLock`实例，然后分别获取读锁和写锁：  
```java
class Counter {
    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
    private final Lock rlock = rwlock.readLock();
    private final Lock wlock = rwlock.writeLock();
    private int[] counts = new int[10];
    public void inc(int index) {
        wlock.lock(); // 加写锁
        try {
            counts[index] += 1;
        } finally {
            wlock.unlock(); // 释放写锁
        }
    }
    public int[] get() {
        rlock.lock(); // 加读锁
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            rlock.unlock(); // 释放读锁
        }
    }
}
```
把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。  

使用`ReadWriteLock`时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。  

例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用`ReadWriteLock`。  

测试一下：  

```java
package com.aotmd;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Point point = new Point();
        Map<String,Integer> map=new HashMap<>();
        long start = System.currentTimeMillis();
        Thread thread = new Thread(()->{
            // 超出出后停止
            for (int x=0,y=1;y<100000000;x++,y++){
                point.set(x,y);
            }
        });
        Thread thread2 = new Thread(()->{
            // 线程thread执行完后关闭
            while (thread.isAlive()){
                int[] ints;
                ints = point.get();
                if (ints[0]-ints[1]!=-1){
                    String s="x="+ints[0]+",y="+ints[1];
                    if (!map.containsKey(s)) {
                        map.put(s,1);
                    }else {
                        map.put(s,map.get(s)+1);
                    }
                }
            }
        });
        thread.start();
        thread2.start();
        thread.join();
        thread2.join();
        int count=0;
        for (Map.Entry<String, Integer> stringIntegerEntry : map.entrySet()) {
            String key = stringIntegerEntry.getKey();
            Integer value = stringIntegerEntry.getValue();
            count+=value;
            System.out.println(key+",count:"+value);
        }
        System.out.println("一共"+count+"条同步问题");
        System.out.println("耗时："+(System.currentTimeMillis()-start));
    }
}
class Point {
    private final ReadWriteLock reentrantLock=new ReentrantReadWriteLock();
    private final Lock w=reentrantLock.writeLock();
    private final Lock r=reentrantLock.readLock();
    int x;
    int y;
    public void set(int x, int y) {
        w.lock();
        try {
            this.x = x;
            this.y = y;
        } finally {
            w.unlock();
        }
    }
    public int[] get(){
        int[] copy = new int[2];
        r.lock();
        try {
            copy[0] = x;
            copy[1] = y;
        } finally {
            r.unlock();
        }
        return copy;
    }
}
```
耗时7000ms，不使用锁：  
```java
class Point {
    int[] ps;
    public void set(int x, int y) {
        int[] ps = new int[] { x, y };
        this.ps = ps;
    }
    public int[] get(){
        return ps.clone();
    }
}
```
耗时1600ms。  

------

**构造方法**：

1. `ReentrantReadWriteLock()`：创建一个新的`ReentrantReadWriteLock`实例。这个实例包含一个读锁和一个写锁。
2. `ReentrantReadWriteLock(boolean fair)`：创建一个新的`ReentrantReadWriteLock`实例，可以选择是否公平地管理获取锁的顺序。如果`fair`为`true`，则表示使用公平的策略；如果`fair`为`false`，则表示使用非公平的策略。

**`ReentrantReadWriteLock`是一个支持类似于`ReentrantLock`的语义的`ReadWriteLock`实现。它具有以下特性：**

- **获取顺序**：该类不强制要求读取器或写入器优先顺序。但是，它支持一个可选的公平性策略。
  - **非公平模式（默认）**：当以非公平模式（默认）构造时，对读锁和写锁的进入顺序是未指定的，但受到重入约束的限制。一个连续争用的非公平锁可能会无限期地延迟一个或多个读取器或写入器线程，但通常具有比公平锁更高的吞吐量。
  - **公平模式**：当以公平模式构造时，线程按照近似到达顺序的策略竞争进入。当当前持有锁被释放时，要么最长等待的单个写入器线程将被分配写入锁，要么如果有一组读取器线程等待时间比所有等待的写入器线程都长，则该组将被分配读取锁。
- **重入性**：此锁允许读取器和写入器以类似于`ReentrantLock`的方式重新获取读取或写入锁。直到写入线程持有的所有写入锁都被释放前，都不允许其他线程获取读锁。
- **锁降级**：通过获取写锁，然后获取读锁，然后释放写锁，可以将写锁降级为读锁。但是，不能从读锁升级为写锁。
- **锁获取中断**：读锁和写锁都支持在获取锁时中断。
- **条件支持**：写锁提供了一个`Condition`实现，行为与`ReentrantLock`提供的`Condition`实现对于`ReentrantLock`一样。当然，这个`Condition`**只能与写锁一起使用**。读锁不支持`Condition`，`readLock().newCondition()`会抛出`UnsupportedOperationException`异常。
- **仪表化**：这个类支持用于确定锁是否被持有或争用的方法。这些方法设计用于监视系统状态，而不是用于同步控制。

## StampedLock
`ReadWriteLock`可以解决多线程同时读，但只有一个线程能写的问题。  

`ReadWriteLock`有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种**悲观的读锁**。  

要进一步提升并发执行效率，**Java 8**引入了新的读写锁：`StampedLock`。  

`StampedLock`和`ReadWriteLock`相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种**乐观锁**。  

乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。  

**乐观锁不会上锁**，在获得乐观锁时会得到一个版本号，然后在读数据操作完毕后，再次检查版本号，如果不匹配，则表示数据已经被其他线程修改过，需要进行相应的处理（例如回滚或重新尝试更新）。乐观锁省去了加锁的步骤，减少了锁竞争，但需要额外的代码，处理数据冲突的情况。  

```java
class Point {
    private final StampedLock stampedLock = new StampedLock();
    int x;
    int y;
    public void set(int x, int y) {
        long l = stampedLock.writeLock();
        try {
            this.x = x;
            this.y = y;
        } finally {
            stampedLock.unlockWrite(l);
        }
    }
    public int[] get(){
        int[] copy = new int[2];
        // 获得一个乐观读锁
        long stamp = stampedLock.tryOptimisticRead(); 
        copy[0] = x;
        copy[1] = y;
        // 验证
        if (!stampedLock.validate(stamp)){
            long l = stampedLock.readLock();
            try {
                copy[0] = x;
                copy[1] = y;
            } finally {
                stampedLock.unlockRead(l);
            }
        }
        return copy;
    }
}
```
和`ReadWriteLock`相比，写入的加锁是完全一样的，不同的是读取。  

首先通过`tryOptimisticRead()`获取一个乐观读锁，并返回版本号。  

接着进行读取，读取完成后，通过`validate()`去验证版本号，如果在读取过程中**没有写入**，版本号不变，**验证成功**，就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，**验证失败**。在失败的时候，再通过获取悲观读锁再次读取。  

`StampedLock`每次读写会记录时间戳， 尝试乐观读`tryOptimisticRead`后，通过`validate`确认是否有更新的**写操作时间戳**，有则加普通读锁重读。而`ReadWriteLock` 相比`StampedLock`，少了一个尝试读的过程和记录、比较时间戳的操作。  

在`StampedLock`中，`unlock`方法用于释放读锁或写锁。如果持有的是读锁，应该使用`unlockRead`方法释放；如果持有的是写锁，应该使用`unlockWrite`方法释放。这两个方法都需要传入获取锁时返回的`stamp`作为参数。  

另外，如果尝试获取乐观读锁（`tryOptimisticRead`）成功，后续需要使用`validate`方法验证乐观读锁的`stamp`是否仍然有效，如果无效则需要重新尝试获取乐观读锁或者进行其他处理，但并**不需要显式释放**乐观读锁。  

------

`StampedLock`把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是`StampedLock`中的**写锁（write lock）是不可重入的**，这意味着如果一个线程已经持有写锁，再次尝试获取写锁会导致死锁。  

读锁（read lock）是**可重入**的，同一个线程可以多次获取读锁而不会导致死锁。这种设计在一定程度上降低了使用`StampedLock`时出现死锁的可能性。  

Java 对于 `ReadWriteLock` 的读锁的抢锁的策略做了限制，当阻塞队列中第一个线程是一个写线程的时候，那读锁就不会参与抢锁，而是直接阻塞，这在一定程度上解决了写锁饿死的问题，JDK8 中的 `StampedLock` 进一步解决了写锁被读锁阻塞的问题，在乐观锁的读锁状态下，写锁可以直接进行获取锁，不用进行抢锁，而且 `StampLock` 对于抢锁失败阻塞造成频繁的上下文切换也进行了优化，线程在抢锁时（底层使用 CAS 实现）如果失败不会直接阻塞，而是通过自旋不断尝试获取锁，直到尝试次数达到上限（单核CPU为0，多核为2^16）才会进行阻塞，等待被唤醒，唤醒后依旧进行自旋，如果依旧无法获得锁，那么再阻塞等待被唤醒。  

`StampedLock`还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。  

`StampedLock` 支持在三种模式之间有条件地提供转换的方法。  

例如，方法`tryConvertToWriteLock(long)`尝试“升级”模式，如果已在写入模式中或在读取模式中且没有其他读取者或在乐观模式中且锁可用，则返回有效的写标记。  

`StampedLocks` 是可序列化的，**但反序列化始终为初始解锁状态**，因此对于远程锁定而言并不实用。  

**`StampedLock`与`ReadWriteLock`不同的方法主要包括以下几种：**  

1. `tryOptimisticRead()`：尝试获取乐观读锁，如果当前没有写锁被持有，则返回一个非零的标记，否则返回零。
2. `validate(long)`：验证乐观读锁的标记是否仍然有效，即是否有写操作发生。如果在获取乐观读锁后没有写操作，则返回true，否则返回false。
3. `tryConvertToWriteLock(long)`：尝试将乐观读锁转换为写锁。如果当前没有其他线程持有写锁，并且没有其他读锁存在，则可以成功转换，返回一个有效的写锁标记，否则返回零。
4. `tryConvertToReadLock(long)`：尝试将写锁转换为读锁。如果当前没有其他线程持有写锁，并且没有其他读锁存在，则可以成功转换，返回一个有效的读锁标记，否则返回零。
5. `tryConvertToOptimisticRead(long)`：尝试将写锁或读锁转换为乐观读锁。如果当前没有其他线程持有写锁，则可以成功转换，返回一个有效的乐观读锁标记，否则返回零。

**测试：**  
```java
package com.aotmd;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.StampedLock;
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Point point = new Point();
        Map<String,Integer> map=new HashMap<>();
        long start = System.currentTimeMillis();
        Thread thread = new Thread(()->{
            // 超出出后停止
            for (int x=0,y=1;y<100000000;x++,y++){
                point.set(x,y);
            }
        });
        Thread thread2 = new Thread(()->{
            // 线程thread执行完后关闭
            while (thread.isAlive()){
                int[] ints;
                ints = point.get();
                if (ints[0]-ints[1]!=-1){
                    String s="x="+ints[0]+",y="+ints[1];
                    if (!map.containsKey(s)) {
                        map.put(s,1);
                    }else {
                        map.put(s,map.get(s)+1);
                    }
                }
            }
        });
        thread.start();
        thread2.start();
        thread.join();
        thread2.join();
        int count=0;
        for (Map.Entry<String, Integer> stringIntegerEntry : map.entrySet()) {
            String key = stringIntegerEntry.getKey();
            Integer value = stringIntegerEntry.getValue();
            count+=value;
            System.out.println(key+",count:"+value);
        }
        System.out.println("一共"+count+"条同步问题");
        System.out.println("耗时："+(System.currentTimeMillis()-start));
        System.out.printf("乐观：%d,悲观转换写：%d,悲观写：%d,乐观占比：%s%n", point.he, point.be1, point.be2, point.he / (point.be1 + point.be2 + point.he + 0.0));
    }
}
class Point {
    private final StampedLock stampedLock = new StampedLock();
    int he=0;
    int be1=0;
    int be2=0;
    int x;
    int y;
    public void set(int x, int y) {
        long l = stampedLock.writeLock();
        try {
            this.x = x;
            this.y = y;
        } finally {
            stampedLock.unlockWrite(l);
        }
    }
    public int[] get(){
        int[] copy = new int[2];
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        copy[0] = x;
        copy[1] = y;
        if (!stampedLock.validate(stamp)){
            // 如果不一致，则回写为旧数据，尝试转换为写锁
            long l = stampedLock.tryConvertToWriteLock(stamp);
            if (l!=0){
                be1++;
                this.x=copy[0];
                this.y=copy[1];
                stampedLock.unlockWrite(l);
            }else {
                //转换失败，获取写锁
                long l1 = stampedLock.writeLock();
                be2++;
                try {
                    copy[0] = x;
                    copy[1] = y;
                } finally {
                    stampedLock.unlockWrite(l1);
                }
            }
        }else {
            he++;
        }
        return copy;
    }
}
```
控制台：  
```text
一共0条同步问题
耗时：7238
乐观：594759493,悲观转换写：0,悲观写：8128226,乐观占比：0.986517844461184
```
挺有用的。  
## Semaphore
各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。  

还有一种受限资源，它需要保证同一时刻最多有N个线程能访问，比如同一时刻最多创建100个数据库连接，最多允许10个用户下载等。  

这种限制数量的锁，如果用Lock数组来实现，就太麻烦了。  

这种情况就可以使用`Semaphore`，例如，最多允许3个线程同时访问：  

```java
public class AccessLimitControl {
    // 任意时刻仅允许最多3个线程获取许可:
    final Semaphore semaphore = new Semaphore(3);
    public String access() throws Exception {
        // 如果超过了许可数量,其他线程将在此等待:
        semaphore.acquire();
        try {
            // TODO:
            return UUID.randomUUID().toString();
        } finally {
            semaphore.release();
        }
    }
}
```
使用`Semaphore`先调用`acquire()`获取，然后通过`try ... finally`保证在`finally`中使用`release()`释放。  

调用`acquire()`可能会进入等待，直到满足条件为止。也可以使用`tryAcquire()`指定等待时间：  

```java
if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) {
    // 指定等待时间3秒内获取到许可:
    try {
        // TODO:
    } finally {
        semaphore.release();
    }
}
```
`Semaphore`本质上就是一个信号计数器，用于限制同一时间的最大访问数量。  

------

`Semaphore`类提供了以下几个常用的方法：  

- `acquire()`: 获取一个许可，如果没有许可可用，则阻塞直到有许可可用为止。
- `release()`: 释放一个许可，将其返回给信号量。
- `tryAcquire()`: 尝试获取一个许可，如果成功则返回`true`，否则立即返回`false`，不会阻塞。
- `tryAcquire(long timeout, TimeUnit unit)`: 尝试获取一个许可，如果在指定的时间内成功获取许可则返回`true`，否则返回`false`，不会阻塞超过指定时间。
- `availablePermits()`: 返回当前可用的许可数。
- `drainPermits()`: 获取并返回立即可用的所有许可，并将可用许可数归零。
- `reducePermits(int reduction)`: 减少许可数，可能导致信号量内部状态的变化。

除了这些方法，`Semaphore`还提供了一些构造方法用于初始化许可数量，以及一些其他辅助方法用于查询状态等。`Semaphore`的用法通常是在需要控制并发访问数量的地方，使用`acquire()`方法获取许可，在任务完成后使用`release()`方法释放许可。  

`Semaphore`类提供了以下几种构造方法：  

1. `Semaphore(int permits)`: 创建一个具有给定许可数的`Semaphore`实例。这个许可数表示同时可以访问某一资源的线程数。
2. `Semaphore(int permits, boolean fair)`: 创建一个具有给定许可数和公平性设置的`Semaphore`实例。如果`fair`为`true`，则使用公平的许可获取顺序；否则，使用非公平的许可获取顺序。

公平的许可获取顺序指的是当有多个线程在等待获取许可时，`Semaphore`会按照它们等待获取许可的先后顺序来分配许可。也就是说，等待时间最长的线程会最先获得许可，而等待时间最短的线程会最后获得许可。这种方式可以确保所有线程都有公平的机会获取许可，避免了某些线程长期被阻塞的情况。  
## Concurrent集合
在前面已经通过`ReentrantLock`和`Condition`实现了一个`BlockingQueue`  
```java
public class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue<String> queue = new LinkedList<>();
    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }
    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
```
`BlockingQueue`的意思就是说，当一个线程调用这个`TaskQueue`的`getTask()`方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，`getTask()`方法才会返回。  
因为`BlockingQueue`非常有用，所以不必自己编写，可以直接使用Java标准库的`java.util.concurrent`包提供的线程安全的集合：`ArrayBlockingQueue`。  
除了`BlockingQueue`外，针对`List`、`Map`、`Set`、`Deque`等，`java.util.concurrent`包也提供了对应的并发集合类。我们归纳一下：  

| interface | non-thread-safe         | thread-safe                              |
| :-------- | :---------------------- | :--------------------------------------- |
| List      | ArrayList               | CopyOnWriteArrayList                     |
| Map       | HashMap                 | ConcurrentHashMap                        |
| Set       | HashSet / TreeSet       | CopyOnWriteArraySet                      |
| Queue     | ArrayDeque / LinkedList | ArrayBlockingQueue / LinkedBlockingQueue |
| Deque     | ArrayDeque / LinkedList | LinkedBlockingDeque                      |

使用这些并发集合与使用非线程安全的集合类完全相同。以`ConcurrentHashMap`为例：  
```java
Map<String, String> map = new ConcurrentHashMap<>();
// 在不同的线程读写:
map.put("A", "1");
map.put("B", "2");
map.get("A", "1");
```
因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：  
```java
Map<String, String> map = new HashMap<>();
```
改为：
```java
Map<String, String> map = new ConcurrentHashMap<>();
```
就可以了。  

`java.util.Collections`工具类还提供了一个旧的线程安全集合转换器，可以这么用：  

```java
Map unsafeMap = new HashMap();
Map threadSafeMap = Collections.synchronizedMap(unsafeMap);
```
但是它实际上是用一个包装类包装了非线程安全的`Map`，然后对所有读写方法都用`synchronized`加锁，这样获得的线程安全集合的性能比`java.util.concurrent`集合要低很多，所以不推荐使用。  
## Atomic
Java的`java.util.concurrent`包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于`java.util.concurrent.atomic`包。  

以`AtomicInteger`为例，它提供的主要操作有：  

- 增加值并返回新值：`int addAndGet(int delta)`
- 加1后返回新值：`int incrementAndGet()`
- 获取当前值：`int get()`
- 用CAS方式设置：`int compareAndSet(int expect, int update)`

Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。  

CAS原子操作属于处理器汇编指令集，值相同则写入，否则跳转，所以是lock-free不需要额外加锁。  
在CAS基础上的Atomic，先暂存原值并操作，后根据CAS比较的结果判断**操作的独立有效性，值相同则有效，反之无效。**  
如果我们自己通过CAS编写`incrementAndGet()`，它大概长这样：  

```java
public int incrementAndGet(AtomicInteger var) {
    int prev, next;
    do {
        prev = var.get();
        next = prev + 1;
    } while ( ! var.compareAndSet(prev, next));
    return next;
}
```
在这个操作中CAS是指`var.compareAndSet(prev, next)`，如果`var`的当前值是`prev`，那么就更新为`next`，返回`true`。如果`var`的当前值不是`prev`，就什么也不干，返回`false`。通过CAS操作并配合`do ... while`循环，即使其他线程修改了`AtomicInteger`的值，最终的结果也是正确的。  

CAS是原子操作，但多核CPU下多个线程同时执行CAS操作为什么依旧是线程安全的呢？因为计算机底层实现保证了V（即上面的变量Var）指向内存的互斥性和立即可见性，可以理解为**CAS操作是底层保证的线程安全。**  

利用`AtomicLong`可以编写一个多线程安全的全局唯一ID生成器：  

```java
class IdGenerator {
    AtomicLong var = new AtomicLong(0);
    public long getNextId() {
        return var.incrementAndGet();
    }
}
```
通常情况下，我们并不需要直接用`do ... while`循环调用`compareAndSet`实现复杂的并发操作，而是用`incrementAndGet()`这样的封装好的方法，因此，使用起来非常简单。  

在高度竞争的情况下，还可以使用**Java 8**提供的`LongAdder`和`LongAccumulator`。  

`LongAdder`和`LongAccumulator`都是用来累加长整型值的工具类，但它们的使用场景和实现略有不同。  

**LongAdder**：适用于高并发情况下的累加操作。它采用了分段锁（Cell数组）的方式来减小锁的竞争，从而提高了并发性能。使用`LongAdder`时，通常不需要担心多线程竞争导致的性能问题，适用于计数器等需要频繁增加的场景。  

示例代码：  

```java
LongAdder adder = new LongAdder();
adder.increment(); // 增加值
long sum = adder.sum(); // 获取总和
System.out.println(sum);// 1
```
**LongAccumulator**：适用于需要自定义累加规则的情况。它提供了一个函数和一个初始值，可以根据自定义的函数对输入的值进行累加。使用`LongAccumulator`时，可以定义一个累加函数，该函数接受两个参数（当前值和新值），并返回一个新值。  

示例代码：  

```java
LongBinaryOperator accumulatorFunction = (x, y) -> x * y; // 定义累加函数
long identity = 1; // 初始值
LongAccumulator accumulator = new LongAccumulator(accumulatorFunction, identity);
accumulator.accumulate(3); // 累加新值
long result = accumulator.get(); // 获取结果
System.out.println(result);//3
```
总的来说，`LongAdder`适用于高并发下的累加操作，而`LongAccumulator`适用于需要自定义累加规则的情况。  
## 线程池
Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。  

如果可以复用一组线程：  

```ascii
┌─────┐ execute  ┌──────────────────┐
│Task1│─────────>│ThreadPool        │
├─────┤          │┌───────┐┌───────┐│
│Task2│          ││Thread1││Thread2││
├─────┤          │└───────┘└───────┘│
│Task3│          │┌───────┐┌───────┐│
├─────┤          ││Thread3││Thread4││
│Task4│          │└───────┘└───────┘│
├─────┤          └──────────────────┘
│Task5│
├─────┤
│Task6│
└─────┘
  ...
```
那么就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。  

简单地说，线程池内部**维护了若干个线程**，没有任务的时候，这些线程都处于等待状态。如果有**新任务**，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。  

Java标准库提供了`ExecutorService`接口表示线程池，它的典型用法如下：  

```java
// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务:
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);
```
因为`ExecutorService`只是接口，Java标准库提供的几个常用实现类有：  
- `FixedThreadPool`：线程数固定的线程池；
- `CachedThreadPool`：线程数根据任务动态调整的线程池；
- `SingleThreadExecutor`：仅单线程执行的线程池。

### FixedThreadPool
创建这些线程池的方法都被封装到`Executors`这个类中。以`FixedThreadPool`为例：  
```java
// 创建一个固定大小的线程池:
ExecutorService es = Executors.newFixedThreadPool(4);
for (int i = 0; i < 6; i++) {
    int finalI = i;
    es.submit(new Runnable() {
        final String name= String.valueOf(finalI+1);
        @Override
        public void run() {
            System.out.printf("线程 %s 开始任务: %s%n", Thread.currentThread().getName(),name);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException _) {
            }
            System.out.printf("线程 %s 结束任务: %s%n", Thread.currentThread().getName(), name);
        }
    });
}
// 关闭线程池:
es.shutdown();
```
控制台：  
```text
线程 pool-1-thread-4 开始任务: 4
线程 pool-1-thread-2 开始任务: 2
线程 pool-1-thread-3 开始任务: 3
线程 pool-1-thread-1 开始任务: 1
线程 pool-1-thread-4 结束任务: 4
线程 pool-1-thread-4 开始任务: 5
线程 pool-1-thread-1 结束任务: 1
线程 pool-1-thread-1 开始任务: 6
线程 pool-1-thread-3 结束任务: 3
线程 pool-1-thread-2 结束任务: 2
线程 pool-1-thread-1 结束任务: 6
线程 pool-1-thread-4 结束任务: 5
```
一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。  

线程池在程序结束的时候要关闭。使用`shutdown()`方法关闭线程池的时候，会等待**正在执行**的任务先完成，然后再关闭。`shutdownNow()`则会立刻停止正在执行的任务，`awaitTermination()`则会等待指定的时间让线程池关闭。  

------

### CachedThreadPool
如果把线程池改为`CachedThreadPool`，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。  

如果想把线程池的大小限制在4～10个之间动态调整怎么办？我们查看`Executors.newCachedThreadPool()`方法的源码：  

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
}
```
因此，想创建指定动态范围的线程池，可以这么写：  
```java
int min = 4;
int max = 10;
ExecutorService es = new ThreadPoolExecutor(min, max,
        60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
```
### SingleThreadExecutor
```java
ExecutorService es = Executors.newSingleThreadExecutor();
Runnable callable=()->{
    System.out.println("123");
};
es.submit(callable);
// 关闭线程池:
es.shutdown();
```
### ThreadPoolExecutor
`ThreadPoolExecutor`类是Java中用于管理线程池的一个重要类，它实现了`ExecutorService`接口。以下是`ThreadPoolExecutor`类的一些常用方法：  
- `execute(Runnable command)`: 提交一个不需要返回值的任务给线程池执行。
- `submit(Callable<T> task)`: 提交一个有返回值的任务给线程池执行，并返回一个表示任务的未来结果的 `Future` 对象。
- `shutdown()`: 启动有序关闭，在该关闭中先前提交的任务将被执行，但不会接受新任务。如果已经关闭，则调用没有其他影响。
- `shutdownNow()`: 尝试停止所有正在执行的活动任务，暂停等待任务的处理，并返回等待执行的任务列表。此方法不保证能够停止正在处理的活动执行任务，但是会尽最大努力。
- `isShutdown()`: 如果此执行程序已关闭，则返回 `true`。
- `isTerminating()`: 如果此执行程序已经启动关闭过程，则返回 `true`。
- `isTerminated()`: 如果所有任务在关闭后都已完成，则返回 `true`。
- `awaitTermination(long timeout, TimeUnit unit)`: 请求关闭，并阻塞直到所有任务完成执行，或发生超时，或当前线程被中断，以先发生者为准。
- `setCorePoolSize(int corePoolSize)`: 设置核心线程数。
- `getCorePoolSize()`: 获取核心线程数。
- `setMaximumPoolSize(int maximumPoolSize)`: 设置最大线程数。
- `getMaximumPoolSize()`: 获取最大线程数。
- `getPoolSize()`: 获取当前线程池中的线程数量。
- `getActiveCount()`: 获取当前线程池中正在执行任务的线程数量。
- `getQueue()`: 获取用于保存等待执行任务的队列。
- `getRejectedExecutionHandler()`: 获取用于处理无法执行的任务的处理程序。
- `setRejectedExecutionHandler(RejectedExecutionHandler handler)`: 设置用于处理无法执行的任务的处理程序。
- `prestartCoreThread()`: 预启动一个核心线程，不等待任务。
- `prestartAllCoreThreads()`: 预启动所有核心线程，不等待任务。
- `allowsCoreThreadTimeOut()`: 判断核心线程在执行完当前任务后是否允许超时。如果允许超时，则核心线程在空闲一定时间后会被回收；如果不允许超时，则核心线程会一直保持存活状态，即使空闲也不会被回收。。
- `allowCoreThreadTimeOut(boolean value)`:设置核心线程是否在执行完当前任务后允许超时。如果设置为`true`，则核心线程在空闲一定时间后会被回收；如果设置为`false`，则核心线程会一直保持存活状态，即使空闲也不会被回收。
- `remove(Runnable task)`: 从工作队列中删除指定的任务。
- `purge()`: 从工作队列中删除所有已经取消的任务。

这些方法使得我们可以方便地管理线程池的行为，如调整线程数、查看线程池状态等。  
实际上前面的`FixedThreadPool`、`CachedThreadPool`、`SingleThreadExecutor`，实例化的都是`ThreadPoolExecutor`。  
```java
ExecutorService es0 = Executors.newFixedThreadPool(10);
ExecutorService es1 = Executors.newCachedThreadPool();
ExecutorService es2 = Executors.newSingleThreadExecutor();
```
相当于:  
```java
// 创建一个固定大小为10个线程的线程池
ThreadPoolExecutor es0 = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
// 创建一个根据需要创建新线程的线程池
ThreadPoolExecutor es1 = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
// 创建一个只有一个工作线程的线程池
ThreadPoolExecutor es2 = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>());
```
### ScheduledThreadPool
还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用`ScheduledThreadPool`。放入`ScheduledThreadPool`的任务可以定期反复执行。创建一个`ScheduledThreadPool`仍然是通过`Executors`类：  
```java
ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);
```
可以提交一次性任务，它会在指定延迟后只执行一次：  
```java
// 1秒后执行一次性任务:
ses.schedule(new Task("one-time"), 1, TimeUnit.SECONDS);
```
如果任务以固定的**每3秒**执行，我们可以这样写：  
```java
// 2秒后开始执行定时任务，每3秒执行:
ses.scheduleAtFixedRate(new Task("fixed-rate"), 2, 3, TimeUnit.SECONDS);
```
如果任务以固定的3秒为**间隔**执行，我们可以这样写：  
```java
// 2秒后开始执行定时任务，以3秒为间隔执行:
ses.scheduleWithFixedDelay(new Task("fixed-delay"), 2, 3, TimeUnit.SECONDS);
```
注意`FixedRate`和`FixedDelay`的区别。`FixedRate`是指任务总是以固定时间间隔触发，**不管任务执行多长时间**：  
```ascii
│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  
├───────┼───────┼───────┼───────┼────>
│<─────>│<─────>│<─────>│<─────>│
```
而`FixedDelay`是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：  
```ascii
│░░░│       │░░░░░│       │░░│       │░
└───┼───────┼─────┼───────┼──┼───────┼──>
    │<─────>│     │<─────>│  │<─────>│
```
因此，使用`ScheduledThreadPool`时，我们要根据需要选择执行一次、`FixedRate`执行还是`FixedDelay`执行。  

在`scheduleAtFixedRate`方法中，如果某次任务**执行时间超过**了指定的**周期**，如果任务的任何执行时间超过其周期，则后续执行会延迟启动，不会同时执行。后续任务会在上个任务执行完毕后立即执行以持续补时差，直到回归正常(时间->任务)一一对应的序列。  

```java
ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);
ses.scheduleAtFixedRate(()->{
    System.out.println("开始"+Thread.currentThread().getName());
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    System.out.println("结束");
}, 2, 100, TimeUnit.MILLISECONDS);
```
这个例子本来是间隔0.1s执行的，但任务至少需要1s才能执行完，因此每次任务都会贴着执行 即后续输出都是输出：`结束`后马上输出`开始...`。  

对于`scheduleAtFixedRate`和`scheduleWithFixedDelay`方法，如果任务**抛出异常**，后续任务**会停止执行**，且异常不会抛出到控制台，线程将被迫停止并由RUNNABLE状态进入 WAITING 状态。如果希望任务出现异常后仍然继续执行后续任务，可以在任务内部捕获异常，并处理异常后继续执行。  

使用 `shutdown()` 方法关闭线程池时，会等待已提交的任务（包括正在执行的任务和还未开始执行的任务）全部执行完成，然后关闭线程池。  

如果某个定时任务的第一次执行时间点尚未到达，而在此之前调用了 `shutdown()` 方法，那么这个定时任务**将不会被执行**。这是因为 `shutdown()` 方法会等待正在执行的任务完成，而尚未开始执行的任务会被取消。  

```java
ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);
ses.scheduleAtFixedRate(()->{
    System.out.println("开始"+Thread.currentThread().getName());
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    System.out.println("结束");
}, 1000, 1000, TimeUnit.MILLISECONDS);
Thread.sleep(999);
// 关闭线程池:
ses.shutdown();
```
如果 `shutdown()` 方法调用的时机在定时任务执行时，则定时任务会在执行完本次任务后关闭。  
```java
ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);
ses.scheduleAtFixedRate(()->{
    System.out.println("开始"+Thread.currentThread().getName());
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    System.out.println("结束");
}, 0, 1000, TimeUnit.MILLISECONDS);
Thread.sleep(499);
// 关闭线程池:
ses.shutdown();
```
如果 `shutdown()` 方法调用的时机在定时任务间隔时（非第一次运行前的延迟），则定时任务会在间隔结束后再执行一次后关闭。这是因为 `shutdown()` 方法不会取消已经计划的下一次任务。  
```java
ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);
ses.scheduleAtFixedRate(()->{
    System.out.println("开始"+Thread.currentThread().getName());
    try {
        Thread.sleep(500);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    System.out.println("结束");
}, 0, 1000, TimeUnit.MILLISECONDS);
Thread.sleep(1499);
// 关闭线程池:
ses.shutdown();
```
------

除了继承自`ThreadPoolExecutor`的方法外，`ScheduledThreadPoolExecutor`还添加了以下方法：  
1. `schedule(Callable<V> callable, long delay, TimeUnit unit)`：延迟执行`Callable`任务，并在任务完成后返回结果。返回一个`ScheduledFuture`表示该任务的未来结果。
2. `schedule(Runnable command, long delay, TimeUnit unit)`：延迟执行`Runnable`任务。返回一个`ScheduledFuture`表示该任务的未来结果。
3. `scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)`：在每次执行结束后等待固定的延迟时间后再执行任务，即任务开始后，等待`initialDelay`后开始执行第一次任务，之后每次任务执行结束后再等待`delay`后执行下一次任务。返回一个`ScheduledFuture`表示该任务的未来结果。
4. `scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)`：按固定的频率执行任务，即任务开始后，等待`initialDelay`后开始执行第一次任务，之后每隔`period`执行一次。如果任务的执行时间超过`period`，则后续任务会立即执行，不会等待。返回一个`ScheduledFuture`表示该任务的未来结果。

这些方法都是用于实现定时任务的调度。  
### Timer
Java标准库还提供了一个`java.util.Timer`类，这个类也可以定期执行任务，但是，一个`Timer`会对应一个`Thread`，所以，一个`Timer`只能定期执行一个任务，多个定时任务必须启动多个`Timer`，而一个`ScheduledThreadPool`就可以调度多个定时任务，所以，完全可以用`ScheduledThreadPool`取代旧的`Timer`。  

`java.util.Timer`类也可以用于定期执行任务，但与`ScheduledThreadPoolExecutor`相比，`Timer`存在一些局限性和缺点。  

**`Timer`的特点：**  

1. **单线程执行**：`Timer`内部维护了一个线程，用于执行所有任务。如果某个任务执行时间过长，会影响后续任务的执行。
2. **异常处理**：`Timer`在执行任务时，如果任务抛出未捕获的异常，会导致`Timer`线程终止，影响后续任务的执行。
3. **灵活性差**：`Timer`的调度方式比较简单，无法灵活控制任务的执行方式。
4. **不适合长期运行**：由于`Timer`是单线程执行任务，长期运行的任务可能会影响其他任务的执行。

示例代码：  
```java
Timer timer = new Timer();
// 1秒后执行一次性任务:
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println("一次性任务");
    }
}, 1000);
// 每隔3秒执行一次任务，任务开始后2秒再次执行：
timer.schedule(new TimerTask() {
    @Override
    public void run() {
        System.out.println("定时任务");
    }
}, 2000, 3000);
// 10秒后终止
Thread.sleep(10000);
timer.cancel();
```
**注意事项：**  
1. 使用`Timer`时要注意处理任务抛出的异常，避免影响`Timer`线程的执行。
2. 不适合需要高并发、长期运行的任务，建议使用`ScheduledThreadPoolExecutor`。

总的来说，如果需要更灵活、可靠的任务调度机制，推荐使用`ScheduledThreadPoolExecutor`，而不是`Timer`类。  
## Future
在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现`Runnable`接口，就可以让线程池去执行：  
```java
class Task implements Runnable {
    public String result;
    public void run() {
        this.result = longTimeCalculation(); 
    }
}
```
`Runnable`接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个`Callable`接口，和`Runnable`接口比，它多了一个返回值：  
```java
class Task implements Callable<String> {
    public String call() throws Exception {
        return longTimeCalculation(); 
    }
}
```
并且`Callable`接口是一个泛型接口，可以返回指定类型的结果。  

现在的问题是，如何获得异步执行的结果？  

如果仔细看`ExecutorService.submit()`方法，可以看到，它返回了一个`Future`类型，一个`Future`类型的实例代表一个**未来能获取结果**的对象：  

```java
ExecutorService executor = Executors.newFixedThreadPool(4); 
// 定义任务:
Callable<String> task = new Task();
// 提交任务并获得Future:
Future<String> future = executor.submit(task);
// 从Future获取异步执行返回的结果:
String result = future.get(); // 可能阻塞
```
当提交一个`Callable`任务后，会同时获得一个`Future`对象，然后，在主线程某个时刻调用`Future`对象的`get()`方法，就可以获得异步执行的结果。在调用`get()`时，如果异步任务已经完成，就直接获得结果。如果异步任务还没有完成，那么`get()`会**阻塞**，直到任务完成后才返回结果。  

示例：

```java
ExecutorService ses = Executors.newFixedThreadPool(4);
Callable<String> task =()->{
    Thread.sleep(1000);
    return "你好";
};
Future<String> result=ses.submit(task);
System.out.println(result.get());
// 关闭线程池:
ses.shutdown();
```
------

一个`Future<V>`接口表示一个未来可能会返回的结果，即表示一个异步计算的结果。它定义了以下方法：  
1. `boolean cancel(boolean mayInterruptIfRunning)`：尝试取消任务的执行。如果任务已经完成、已经被取消或者由于某些原因不能取消，则此尝试将失败，返回 `false`。如果取消成功，并且任务尚未开始执行，则任务不应该运行。如果任务已经开始执行，则应该中断任务的执行。
2. `boolean isCancelled()`：如果任务已经被取消，则返回 true。
3. `boolean isDone()`：如果任务已经完成（无论是正常完成、取消还是由于执行过程中出现异常），则返回 true。
4. `V get()`：等待计算完成，然后返回其结果。
5. `V get(long timeout, TimeUnit unit)`：等待计算完成，最多等待给定的时间。如果在超时时间内计算完成，则返回结果；如果超时，则抛出 `TimeoutException`。

------

**单独使用：**

步骤：  

1. 创建一个实现`Callable`的实现类
2. 实现`call`方法，将此线程需要执行的操作声明在call()中
3. 创建`Callable`接口实现类的对象
4. 将此`Callable`接口实现类的对象作为传递到`FutureTask`构造器中，创建`FutureTask`的对象
5. 将`FutureTask`的对象作为参数传递到`Thread`类的构造器中，创建`Thread`对象，并调用`start()`
6. 获取`Callable`中`call`方法的返回值

即：  
```java
Callable<String> task =()->{
    Thread.sleep(1000);
    return "你好";
};
FutureTask<String> futureTask = new FutureTask<>(task);
new Thread(futureTask).start();
System.out.println(futureTask.get());
```
## CompletableFuture
使用`Future`获得异步执行结果时，要么调用阻塞方法`get()`，要么轮询看`isDone()`是否为`true`，这两种方法都不是很好，因为主线程也会被迫等待。  

从**Java 8**开始引入了`CompletableFuture`，它针对`Future`做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。  

以获取股票价格为例：  

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 创建异步执行任务:
        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(Main::fetchPrice);
        // 如果执行成功:
        cf.thenAccept((result) -> {
            System.out.println("price: " + result);
        });
        // 如果执行异常:
        cf.exceptionally((e) -> {
            e.printStackTrace();
            return null;
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(200);
    }
    static Double fetchPrice() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
        if (Math.random() < 0.3) {
            throw new RuntimeException("fetch price failed!");
        }
        return 5 + Math.random() * 20;
    }
}
```
创建一个`CompletableFuture`是通过`CompletableFuture.supplyAsync()`实现的，它需要一个实现了`Supplier`接口的对象：  
```java
public interface Supplier<T> {
    T get();
}
```
这里用lambda语法简化了一下，直接传入`Main::fetchPrice`，因为`Main.fetchPrice()`静态方法的签名符合`Supplier`接口的定义（除了方法名外）。  

紧接着，`CompletableFuture`已经被提交给默认的线程池执行了，我们需要定义的是`CompletableFuture`完成时和异常时需要回调的实例。完成时，`CompletableFuture`会调用`Consumer`对象：  

```java
public interface Consumer<T> {
    void accept(T t);
}
```
异常时，`CompletableFuture`会调用`Function`对象：  
```java
public interface Function<T, R> {
    R apply(T t);
}
```
这里都用lambda语法简化了代码。  

可见`CompletableFuture`的优点是：  

- 异步任务结束时，会自动回调某个对象的方法；
- 异步任务出错时，会自动回调某个对象的方法；
- 主线程设置好回调后，不再关心异步任务的执行。

如果只是实现了异步回调机制，还看不出`CompletableFuture`相比`Future`的优势。`CompletableFuture`更强大的功能是，多个`CompletableFuture`可以串行执行，例如，定义两个`CompletableFuture`，第一个`CompletableFuture`根据证券名称查询证券代码，第二个`CompletableFuture`根据证券代码查询证券价格，这两个`CompletableFuture`实现串行操作如下：  
```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 第一个任务:
        CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync(() -> queryCode("中国石油"));
        // cfQuery成功后继续执行下一个任务:
        CompletableFuture<Double> cfFetch = cfQuery.thenApplyAsync((code) -> fetchPrice(code));
        // cfFetch成功后打印结果:
        cfFetch.thenAccept((result) -> {
            System.out.println("price: " + result);
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(2000);
    }
    static String queryCode(String name) {
        try {
            Thread.sleep(100);
        } catch (InterruptedException _) {
        }
        return "601857";
    }
    static Double fetchPrice(String code) {
        try {
            Thread.sleep(100);
        } catch (InterruptedException _) {
        }
        return 5 + Math.random() * 20;
    }
}
```
除了串行执行外，多个`CompletableFuture`还可以并行执行。例如，我们考虑这样的场景：  

同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：  

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 两个CompletableFuture执行异步查询:
        CompletableFuture<String> cfQueryFromSina = CompletableFuture.supplyAsync(() -> {
            return queryCode("中国石油", "https://finance.sina.com.cn/code/");
        });
        CompletableFuture<String> cfQueryFrom163 = CompletableFuture.supplyAsync(() -> {
            return queryCode("中国石油", "https://money.163.com/code/");
        });
        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture<Object> cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);
        // 两个CompletableFuture执行异步查询:
        CompletableFuture<Double> cfFetchFromSina = cfQuery.thenApplyAsync((code) -> {
            return fetchPrice((String) code, "https://finance.sina.com.cn/price/");
        });
        CompletableFuture<Double> cfFetchFrom163 = cfQuery.thenApplyAsync((code) -> {
            return fetchPrice((String) code, "https://money.163.com/price/");
        });
        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture<Object> cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);
        // 最终结果:
        cfFetch.thenAccept((result) -> {
            System.out.println("price: " + result);
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(200);
    }
    static String queryCode(String name, String url) {
        System.out.println("query code from " + url + "...");
        try {
            Thread.sleep((long) (Math.random() * 100));
        } catch (InterruptedException e) {
        }
        return "601857";
    }
    static Double fetchPrice(String code, String url) {
        System.out.println("query price from " + url + "...");
        try {
            Thread.sleep((long) (Math.random() * 100));
        } catch (InterruptedException e) {
        }
        return 5 + Math.random() * 20;
    }
}
```
除了`anyOf()`可以实现“任意个`CompletableFuture`只要一个成功”，`allOf()`可以实现“所有`CompletableFuture`都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。  

`CompletableFuture`类提供了许多方法来处理异步计算的结果或执行其他操作。以下是一些常用方法：  

### 异步执行指定的任务
- `static CompletableFuture<Void> runAsync(Runnable runnable)`：在默认的 `ForkJoinPool.commonPool()` 中**异步执行**指定的`Runnable`任务。
- `static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)`：在**指定**的`Executor`线程池上异步执行`Runnable`任务。
- `static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)`：异步执行指定的`Supplier`任务，`Supplier`任务需返回一个**结果**，该方法会**返回一个包含结果的`CompletableFuture`对象**，该对象在**计算完成时**将**返回**。
- `static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)`：在**指定**的`Executor`线程池上异步执行`Supplier`任务，`Supplier`任务需返回一个结果，该方法会返回一个包含结果的`CompletableFuture`对象，该对象在计算完成时将返回结果。

```java
CompletionStage<Integer> stage = CompletableFuture.supplyAsync(() -> 10);
```

------

### 执行完成
**上个任务执行完成时，再执行给定的方法**  
- `CompletableFuture<Void> thenRun(Runnable action)`：当此 `CompletableFuture` 完成时，执行给定的方法。如果有多个`thenRun()`,则一个一个执行。
- `CompletableFuture<Void> thenRunAsync(Runnable action)`：当此 `CompletableFuture` 完成时，**异步**地执行给定的方法。
- `CompletableFuture<Void> thenRunAsync(Runnable action, Executor executor)`：当此 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法。

示例：  
```java
public static void main(String[] args) throws Exception {
    CompletionStage<Integer> stage = CompletableFuture.supplyAsync(() -> {
        try {Thread.sleep(100);} catch (InterruptedException e) {throw new RuntimeException(e);}
        return 10;
    });
    stage.thenRun(() -> hi(Thread.currentThread().getName()));
    stage.thenRun(() -> hi(Thread.currentThread().getName()));
    stage.thenRunAsync(() -> hi(Thread.currentThread().getName()));
    stage.thenRunAsync(() -> hi(Thread.currentThread().getName()));
    ExecutorService e= Executors.newCachedThreadPool();
    stage.thenRunAsync(() -> hi(Thread.currentThread().getName()),e);
    Thread.sleep(10000);
}
static void hi(String i){
    try {Thread.sleep(1000);} catch (InterruptedException e) {throw new RuntimeException(e);}
    System.out.println("你好:"+i);
}
```
控制台：  
```text
你好:ForkJoinPool.commonPool-worker-1
你好:ForkJoinPool.commonPool-worker-2
你好:ForkJoinPool.commonPool-worker-3
你好:pool-1-thread-1
你好:ForkJoinPool.commonPool-worker-1
```
打印间隔为：1234行瞬间显示，行间隔1秒后5行显示。如果同时定义了同步和异步，则异步不管同步，而同步排队运行。`thenRun()`定义的匿名类实例方法始终在一个线程`ForkJoinPool.commonPool-worker-1`上执行。  

**回调执行时机**  

`thenRun`执行的时候，如果任务**没执行完**就注册回调，则**等待任务执行完**再执行回调，如果任务已经执行完了就**直接执行回调**，后续的所有等待`CompletableFuture` 完成时都是这个逻辑。  

```java
public static void main(String[] args) throws Exception {
    CompletionStage<Integer> stage = CompletableFuture.supplyAsync(() -> 10);
    Thread.sleep(100);
    stage.thenRun(() -> hi(Thread.currentThread().getName()));
    stage.thenRun(() -> hi(Thread.currentThread().getName()));
    System.out.println("我是主线程");
    Thread.sleep(100);
    stage.thenRunAsync(() -> hi(Thread.currentThread().getName()));
    stage.thenRunAsync(() -> hi(Thread.currentThread().getName()));
    System.out.println("我是主线程");
    Thread.sleep(10000);
}
static void hi(String i){
    try {Thread.sleep(1000);} catch (InterruptedException e) {throw new RuntimeException(e);}
    System.out.println("你好:"+i);
}
```
控制台：  
```java
你好:main
你好:main
我是主线程
我是主线程
你好:ForkJoinPool.commonPool-worker-1
你好:ForkJoinPool.commonPool-worker-2
```
打印间隔为1先显示，间隔1秒之后2、3、4行瞬间显示，隔1秒之后5、6行瞬间显示。  

因定义`thenRun()`时`supplyAsync()`已经执行完了，所以直接执行`thenRun()`内的方法了，**而且**执行的线程是主线程，并阻塞了主线程，在执行到`thenRunAsync()`后正常开线程异步执行。  

将其**结果**传入给定的方法执行：  

- `CompletableFuture<Void> thenAccept(Consumer<? super T> action)`：当此 `CompletableFuture` 完成时，将其结果传入到给定的方法执行。
- `CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action)`：当此 `CompletableFuture` 完成时，**异步**执行给定的方法，并将结果传入该方法。
- `CompletableFuture<Void> thenAcceptAsync(Consumer<? super T> action, Executor executor)`：当此 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将结果传入该方法。

```java
CompletionStage<Integer> stage = CompletableFuture.supplyAsync(() -> 10);
stage.thenAccept(x -> System.out.println(x));
```
还**返回结果**：  
- `CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)`：当此 `CompletableFuture` 完成时，将其结果传入到给定的方法执行，给定的方法还需返回一个值。
- `CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn)`：当此 `CompletableFuture` 完成时，**异步**执行给定的方法，并将结果传入该方法，给定的方法还需返回一个值。
- `CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)`：当此 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将结果传入该方法，给定的方法还需返回一个值。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = stage1.thenApply(x -> x * 2);
stage2.thenAccept(System.out::println);
```
还**返回新的`CompletableFuture`**：  
- `CompletableFuture<U> thenCompose(Function<? super T,? extends CompletionStage<U>> fn)`：当此 `CompletableFuture` 完成时，将其结果传入到给定的方法执行，给定的方法还需**返回一个新的 `CompletableFuture`**。
- `CompletableFuture<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> fn)`：当此 `CompletableFuture` 完成时，**异步**执行给定的方法，并将结果传入该方法，给定的方法还需返回一个新的 `CompletableFuture`。
- `CompletableFuture<U> thenComposeAsync(Function<? super T,? extends CompletionStage<U>> fn, Executor executor)`：当此 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将结果传入该方法，给定的方法还需返回一个新的 `CompletableFuture`。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = stage1.thenCompose(x -> CompletableFuture.supplyAsync(() -> x * 2));
stage2.thenAccept(System.out::println);
```

------

### 执行异常
**上个任务执行异常时，再执行给定的操作**  

对于异常，不存在类似`thenRun()`的不传参的方法，也不存在类似`thenAccept()`的无返回值的方法。这是因为在处理异常时，需要访问异常信息（Throwable）。  

将其**异常**传入给定的方法执行：  

还**返回结果**：  

- `CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)`：当 `CompletableFuture` 遇到**异常**时，将异常传入到给定的方法执行，给定的方法还需**返回一个值**。
- `CompletableFuture<T> exceptionallyAsync(Function<Throwable,? extends T> fn)`：当 `CompletableFuture` 遇到异常时，**异步**执行给定的方法，并将异常传入该方法，给定的方法还需返回一个值。
- `CompletableFuture<T> exceptionallyAsync(Function<Throwable,? extends T> fn, Executor executor)`：当 `CompletableFuture` 遇到异常时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将异常传入该方法，给定的方法还需返回一个值。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> {
    if (new Random().nextFloat()<0.99) {
        throw new RuntimeException("异常");
    }
    return 10;
});
CompletionStage<Integer> exc = stage1.exceptionally(throwable -> {
    throwable.printStackTrace();
    return 1;
});
exc.thenAccept(System.out::println);
```
还**返回新的`CompletableFuture`**：  
- `CompletableFuture<T> exceptionallyCompose(Function<Throwable,? extends CompletionStage<T>> fn)`：当 `CompletableFuture` 遇到异常时，将异常传入到给定的方法执行，给定的方法还需**返回一个新的 `CompletableFuture`**。
- `CompletableFuture<T> exceptionallyComposeAsync(Function<Throwable,? extends CompletionStage<T>> fn)`：当 `CompletableFuture` 遇到异常时，**异步**执行给定的方法，并将异常传入该方法，给定的方法还需返回一个新的 `CompletableFuture`。
- `CompletableFuture<T> exceptionallyComposeAsync(Function<Throwable,? extends CompletionStage<T>> fn,Executor executor)`：当 `CompletableFuture` 遇到异常时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将异常传入该方法，给定的方法还需返回一个新的 `CompletableFuture`。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> {
    if (new Random().nextFloat()<0.99) {
        throw new RuntimeException("异常");
    }
    return 10;
});
CompletionStage<Integer> exc = stage1.exceptionallyCompose(throwable -> {
    throwable.printStackTrace();
    return CompletableFuture.supplyAsync(()-> 2);
});
exc.thenAccept(System.out::println);
```

------

### 执行完成或异常
**上个任务执行完成或异常时，再执行给定的操作**  

同样的对于异常，不存在类似`thenRun()`的不传参的方法，但是存在类似`thenAccept()`的无返回值的方法，即`whenComplete()`。  

将其**异常**与**结果**传入给定的方法执行：  

- `CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)`：当此 `CompletableFuture` 完成时，将**结果和异常**传入到给定的方法执行。
- `CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)`：当此 `CompletableFuture` 完成时，**异步**执行给定的方法，并将结果和异常传入该方法。
- `CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)`：当此 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将结果和异常传入该方法。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> {
    if (new Random().nextFloat()<0.5) {
        throw new RuntimeException("异常");
    }
    return 10;
});
stage1.whenComplete((integer, throwable) -> {
    if (throwable==null){
        System.out.println("没有异常");
        System.out.println(integer);
    }else {
        throwable.printStackTrace();
    }
});
```
这里返回值不是`CompletableFuture<Void>`，是`CompletableFuture<T>`，其结果和 `stage1` 的结果相同，不是同一个对象。  
```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> {
    if (new Random().nextFloat()<0.5) {
        throw new RuntimeException("异常");
    }
    return 10;
});
System.out.println(stage1);
CompletionStage<Integer> integerCompletionStage = stage1.whenComplete((integer, throwable) -> {
    if (throwable == null) {
        System.out.println("没有异常");
        System.out.println(integer);
    } else {
        throwable.printStackTrace();
    }
});
System.out.println(integerCompletionStage);
integerCompletionStage.thenAccept(x -> {
    System.out.println(x);
});
integerCompletionStage.exceptionally(e->{
    e.printStackTrace();
    return 1;
});
```
控制台：  
```text
java.util.concurrent.CompletableFuture@7cd84586[Not completed]
没有异常  
10
java.util.concurrent.CompletableFuture@1e80bfe8[Completed normally]
10
```
还**返回结果**：  
- `CompletableFuture<U> handle(BiFunction<? super T,Throwable,? extends U> fn)`：当此 `CompletableFuture` 完成时，将**结果和异常**传入到给定的方法执行，给定的方法还需**返回一个值**。
- `CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> fn)`：当此 `CompletableFuture` 完成时，**异步**执行给定的方法，并将结果和异常传入该方法，给定的方法还需返回一个值。
- `CompletableFuture<U> handleAsync(BiFunction<? super T,Throwable,? extends U> fn, Executor executor)`：当此 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池，异步执行给定的方法，并将结果和异常传入该方法，给定的方法还需返回一个值。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> {
    if (new Random().nextFloat()<0.5) {
        throw new RuntimeException("异常");
    }
    return 10;
});
CompletionStage<Integer> handle = stage1.handle((integer, throwable) -> {
    if (throwable == null) {
        System.out.println("没有异常");
        System.out.println(integer);
        return 1;
    } else {
        throwable.printStackTrace();
        return 0;
    }
});
handle.thenAccept(System.out::println);
```
### 与操作
两个任务都执行完成时，再执行给定的方法。  
- `CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，执行给定的方法。
- `CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，异步地执行给定的方法。
- `CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action, Executor executor)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
stage1.runAfterBoth(stage2, () -> {
    System.out.println("执行");
});
```
还将其的**两个结果**传入到给定的方法执行：  
- `CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，将**两个结果**传入到给定的方法执行。
- `CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，**异步**地执行给定的方法，并将两个结果传入该方法。
- `CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action, Executor executor)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法，并将两个结果传入该方法。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
stage1.thenAcceptBoth(stage2, (a, b) -> {
    System.out.println(Integer.sum(a, b));
});
```
**还返回结果：**  
- `CompletableFuture<V> thenCombine(CompletionStage<? extends U> other, BiConsumer<? super T,? super U,? extends V> action)`：当此 `CompletableFuture` **和**另一个 `CompletableFuture` **都**完成时，将**两个结果**传入到给定的方法执行，给定的方法还需**返回一个值**。
- `CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiConsumer<? super T,? super U,? extends V> action)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，**异步**地执行给定的方法，并将两个结果传入该方法，给定的方法还需**返回一个值**。
- `CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U> other, BiConsumer<? super T,? super U,? extends V> action, Executor executor)`：当此 `CompletableFuture` 和另一个 `CompletableFuture` 都完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法，并将两个结果传入该方法，给定的方法还需**返回一个值**。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
CompletionStage<Integer> stage3 = stage1.thenCombine(stage2, Integer::sum);
stage3.thenAccept(System.out::println);
```
### 或操作
两个任务中有一个执行完成时，就执行给定的方法：  
- `CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，执行给定的方法。
- `CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，异步地执行给定的方法。
- `CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action, Executor executor)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
stage1.runAfterEither(stage2, () -> {
    System.out.println("执行");
});
```
也将**结果**传入方法：  
- `CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)`：当此 `CompletableFuture` **或**另一个 `CompletableFuture` 完成时，将结果传入到给定的方法执行。
- `CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，**异步**地执行给定的方法，并将结果传入到给定的方法。
- `CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends T> other, Consumer<? super T> action, Executor executor)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法，并将结果传入到给定的方法。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
stage1.acceptEither(stage2, (x) -> {
    System.out.println(x);
});
```
**还返回结果**：  
- `CompletableFuture<U> applyToEither(CompletionStage<? extends T> other, Function<? super T,U> fn)`：当此 `CompletableFuture` **或**另一个 `CompletableFuture` 完成时，将结果传入到给定的方法执行，给定的方法还需**返回一个值**。
- `CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，**异步**地执行给定的方法，并将结果传入到给定的方法，给定的方法还需返回一个值。
- `CompletableFuture<U> applyToEitherAsync(CompletionStage<? extends T> other, Function<? super T,U> fn, Executor executor)`：当此 `CompletableFuture` 或另一个 `CompletableFuture` 完成时，使用**指定**的 `Executor` 线程池异步地运行给定的方法，并将结果传入到给定的方法，给定的方法还需返回一个值。

```java
CompletionStage<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletionStage<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
stage1.applyToEither(stage2, (x) -> x);
stage1.thenAccept(System.out::println);
```
### 合并操作
- `static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)`：返回一个新的 `CompletableFuture`，当所有传入的 `CompletableFuture` 都完成时，它也会完成。

```java
CompletableFuture<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletableFuture<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
CompletableFuture<Void> all = CompletableFuture.allOf(stage1, stage2);
all.thenRun(()->{
    System.out.println("两个都执行完了");
});
// 相当于：
stage1.runAfterBoth(stage2,()->{
    System.out.println("两个都执行完了");
});
```
- `static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)`：返回一个新的 `CompletableFuture`，当**任意**一个传入的 `CompletableFuture` 完成时，它也会完成，并**返回**完成的 `CompletableFuture` 的**结果**。

```java
CompletableFuture<Integer> stage1 = CompletableFuture.supplyAsync(() -> 10);
CompletableFuture<Integer> stage2 = CompletableFuture.supplyAsync(() -> 20);
CompletableFuture<Object> all = CompletableFuture.anyOf(stage1, stage2);
all.thenAccept(System.out::println);
// 相当于：
stage1.acceptEither(stage2,System.out::println);
```
### 总结
`CompletableFuture`的方法命名规律如下：  
1. 方法名以`then`开头，表示该方法会在当前`CompletableFuture`**完成后**执行。
2. 方法名以`Run`开头，表示该方法会**执行**一个`Runnable`而**不返回**结果。
3. 方法名以`Accept`开头，表示该方法会**接受**`CompletableFuture`的**结果**，传入回调，但回调**不返回**结果。
4. 方法名以`Apply`开头，表示该方法会**接受**`CompletableFuture`的**结果**，传入回调，回调需返回一个**结果**，该方法会返回一个包含结果的`CompletableFuture`。
5. 方法名包含`Compose`，表示该方法会**接受**`CompletableFuture`的**结果**，传入回调，回调需返回一个`CompletableFuture`。
6. 方法名包含`Async`，表示该方法会**异步执行**。
7. 方法名以`exceptionally`开头，表示该方法会**接受**`CompletableFuture`的**异常**，并**返回**一个包含结果的`CompletableFuture`。
8. 方法名包含`Complete`，表示该方法会**接受**`CompletableFuture`的**异常和结果**，传入回调执行，但回调**不返回**结果。
9. 方法名以`handle`开头，表示该方法会**接受**`CompletableFuture`的**异常和结果**，传入回调执行，回调需返回一个结果，该方法会返回一个包含结果的`CompletableFuture`。
10. 方法名包含`Both`，表示该方法会等待两个`CompletableFuture`都完成才执行回调。
11. 方法名包含`Combine`，表示该方法会等待两个`CompletableFuture`都完成才执行回调，并接收它们两个的结果，传入回调，回调需返回一个结果，该方法会返回一个包含结果的`CompletableFuture`。
12. 方法名包含`Either`，表示该方法会等待两个`CompletableFuture`任意一个完成就执行回调。
13. 方法名以`applyToEither`开头，表示该方法会等待两个`CompletableFuture`任意一个完成就执行回调，并将那一个结果，传入回调，回调需返回一个结果，该方法会返回一个包含结果的`CompletableFuture`。
14. 方法名包含`Of`，表示该方法是一个静态工厂方法，用于创建`CompletableFuture`。

## ForkJoin
**Java 7**开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。  

如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：  

```ascii
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```
还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：  
```ascii
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
```
如果拆成两部分还是很大，还可以继续拆，用4个线程并行执行：  
```ascii
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
```
这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。  

使用Fork/Join对大数据进行并行求和：

```java
import java.util.Random;
import java.util.concurrent.*;
public class Main {
    public static void main(String[] args) throws Exception {
        // 创建2000个随机数组成的数组:
        long[] array = new long[2000];
        long expectedSum = 0;
        for (int i = 0; i < array.length; i++) {
            array[i] = random();
            expectedSum += array[i];
        }
        System.out.println("Expected sum: " + expectedSum);
        // fork/join:
        ForkJoinTask<Long> task = new SumTask(array, 0, array.length);
        long startTime = System.currentTimeMillis();
        Long result = ForkJoinPool.commonPool().invoke(task);
        long endTime = System.currentTimeMillis();
        System.out.println("Fork/join sum: " + result + " in " + (endTime - startTime) + " ms.");
    }
    static Random random = new Random(0);
    static long random() {
        return random.nextInt(10000);
    }
}
class SumTask extends RecursiveTask<Long> {
    static final int THRESHOLD = 500;
    long[] array;
    int start;
    int end;
    SumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // 如果任务足够小,直接计算:
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += this.array[i];
                // 故意放慢计算速度:
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                }
            }
            return sum;
        }
        // 任务太大,一分为二:
        int middle = (end + start) / 2;
        System.out.println(String.format("split %d~%d ==> %d~%d, %d~%d", start, end, start, middle, middle, end));
        SumTask subtask1 = new SumTask(this.array, start, middle);
        SumTask subtask2 = new SumTask(this.array, middle, end);
        invokeAll(subtask1, subtask2);
        Long subresult1 = subtask1.join();
        Long subresult2 = subtask2.join();
        Long result = subresult1 + subresult2;
        System.out.println("result = " + subresult1 + " + " + subresult2 + " ==> " + result);
        return result;
    }
}
```
控制台：  
```text
Expected sum: 9788366
split 0~2000 ==> 0~1000, 1000~2000
split 0~1000 ==> 0~500, 500~1000
split 1000~2000 ==> 1000~1500, 1500~2000
result = 2485485 + 2491717 ==> 4977202
result = 2391591 + 2419573 ==> 4811164
result = 4811164 + 4977202 ==> 9788366
Fork/join sum: 9788366 in 1035 ms.
```
一个大的计算任务0~2000首先分裂为两个小任务0~1000和1000~2000，这两个小任务仍然太大，继续分裂为更小的0~500，500~1000，1000~1500，1500~2000，最后，计算结果被依次合并，得到最终结果。  

核心代码`SumTask`继承自`RecursiveTask`，在`compute()`方法中，关键是如何“分裂”出子任务并且提交子任务：  

```java
class SumTask extends RecursiveTask<Long> {
    protected Long compute() {
        // “分裂”子任务:
        SumTask subtask1 = new SumTask(...);
        SumTask subtask2 = new SumTask(...);
        // invokeAll会并行运行两个子任务:
        invokeAll(subtask1, subtask2);
        // 获得子任务的结果:
        Long subresult1 = subtask1.join();
        Long subresult2 = subtask2.join();
        // 汇总结果:
        return subresult1 + subresult2;
    }
}
```
Fork/Join线程池在Java标准库中就有应用。Java标准库提供的`java.util.Arrays.parallelSort(array)`可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。  

Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。  

`ForkJoinPool`线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自`RecursiveTask`或`RecursiveAction`。使用Fork/Join模式可以进行并行计算以提高效率。  

`commonPool()`方法的线程数量，实际上是CPU的核数减1，如果自己创建就是自己指定的值；  

`ForkJoinPool`在单核机器上会挂起，通过设置属性可以临时解决：  

```bash
-Djava.util.concurrent.ForkJoinPool.common.parallelism=1
```
或者在`main()`的第一行开始写  
```java
if(Runtime.getRuntime().availableProcessors()<=1){
    System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","1");
}
```
------

**常用的方法：**  

- `ForkJoinPool.commonPool()`：返回一个共享的 `ForkJoinPool` 实例，用于执行并行任务。
- `ForkJoinPool.submit(ForkJoinTask<?> task)`：提交一个 `ForkJoinTask` 任务给线程池执行，并返回一个 `Future` 对象，用于获取任务的结果或取消任务。
- `ForkJoinPool.execute(ForkJoinTask<?> task)`：立即执行给定的 `ForkJoinTask`，不返回任何结果。
- `ForkJoinTask.join()`：阻塞当前线程直到任务完成，并返回任务的结果。
- `ForkJoinTask.fork()`：将任务放入工作队列，允许它在另一个线程上执行。
- `ForkJoinTask.invoke()`：同步执行任务，并返回任务的结果。
- `ForkJoinTask.invokeAll(Collection<? extends ForkJoinTask<T>> tasks)`：同步执行给定的任务集合，并返回包含所有任务结果的列表。
- `ForkJoinTask.isDone()`：检查任务是否已经完成。
- `ForkJoinTask.isCancelled()`：检查任务是否已经被取消。
- `ForkJoinTask.cancel(boolean mayInterruptIfRunning)`：尝试取消任务的执行。

**常用的构造方法：**  

1. `ForkJoinPool()`：创建一个新的 `ForkJoinPool`，使用默认的线程数和参数。
2. `ForkJoinPool(int parallelism)`：创建一个新的 `ForkJoinPool`，指定并行度（即线程数）。通常，线程数等于处理器的数量。
3. `ForkJoinPool(int parallelism, ForkJoinPool.ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode)`：创建一个新的 `ForkJoinPool`，允许指定线程数、线程工厂、异常处理器和是否使用异步模式。
4. `ForkJoinPool(int parallelism, ForkJoinPool.ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, ForkJoinPool.ForkJoinWorkerThreadFactory hook, boolean system, int mode)`：更加灵活的构造方法，允许指定线程数、线程工厂、异常处理器、异步模式、核心池大小、最大池大小、线程保持活跃时间、时间单位、钩子、是否为系统线程以及模式。

## ThreadLocal
`Thread`对象代表一个线程，可以在代码中调用`Thread.currentThread()`获取当前线程。  
对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：  

```java
public void process(User user) {
    checkPermission();
    doWork();
    saveStatus();
    sendResponse();
}
```
然后，通过线程池去执行这些任务。`process()`方法，内部需要调用若干其他方法，如何在一个线程内传递状态？  

`process()`方法需要传递的状态就是`User`实例。  

```java
public void process(User user) {
    checkPermission(user);
    doWork(user);
    saveStatus(user);
    sendResponse(user);
}
```
但是往往一个方法又会调用其他很多方法，这样会导致`User`传递到所有地方：  
```java
void doWork(User user) {
    queryStatus(user);
    checkStatus();
    setNewStatus(user);
    log();
}
```
这种在一个线程中，横跨若干方法调用，需要传递的对象，通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。  

给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，`User`对象就传不进去了。  

Java标准库提供了一个特殊的`ThreadLocal`，它可以在一个线程中传递同**一个**对象。  

`ThreadLocal`实例通常总是以静态字段初始化如下：  

```java
static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();
```
它的典型使用方式如下：  
```java
void processUser(user) {
    try {
        threadLocalUser.set(user);
        step1();
        step2();
    } finally {
        threadLocalUser.remove();
    }
}
```
通过设置一个`User`实例关联到`ThreadLocal`中，在移除之前，所有方法都可以随时获取到该`User`实例：  
```java
void step1() {
    User u = threadLocalUser.get();
    log();
    printUser();
}
void log() {
    User u = threadLocalUser.get();
    println(u.name);
}
void step2() {
    User u = threadLocalUser.get();
    checkUser(u.id);
}
```
普通的方法调用一定是同一个线程执行的，所以，`step1()`、`step2()`以及`log()`方法内，`threadLocalUser.get()`获取的`User`对象是同一个实例。  

实际上，可以把`ThreadLocal`看成一个全局`Map<Thread, Object>`：每个线程获取`ThreadLocal`变量时，总是使用`Thread`自身作为key：  

```java
Object threadLocalValue = threadLocalMap.get(Thread.currentThread());
```
因此，`ThreadLocal`相当于给每个线程都开辟了一个独立的存储空间，各个线程的`ThreadLocal`关联的实例互不干扰。  

最后，特别注意`ThreadLocal`一定要在`finally`中清除：  

```java
try {
    threadLocalUser.set(user);
    ...
} finally {
    threadLocalUser.remove();
}
```
这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果`ThreadLocal`没有被清除，该线程执行其他代码时，会把上一次的状态带进去。  

为了保证能释放`ThreadLocal`关联的实例，可以通过`AutoCloseable`接口配合`try (resource) {...}`结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的`ThreadLocal`可以封装为一个`UserContext`对象：  

```java
public class UserContext implements AutoCloseable {
    static final ThreadLocal<String> ctx = new ThreadLocal<>();
    public UserContext(String user) {
        ctx.set(user);
    }
    public static String currentUser() {
        return ctx.get();
    }
    @Override
    public void close() {
        ctx.remove();
    }
}
```
使用的时候，借助`try (resource) {...}`结构，可以这么写：  
```java
try (var ctx = new UserContext("Bob")) {
    // 可任意调用UserContext.currentUser():
    String currentUser = UserContext.currentUser();
} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象
```
这样就在`UserContext`中完全封装了`ThreadLocal`，外部代码在`try (resource) {...}`内部可以随时调用`UserContext.currentUser()`获取当前线程绑定的用户名。  

`ThreadLocal`表示线程的“局部变量”，它确保每个线程的`ThreadLocal`变量都是各自独立的；  

`ThreadLocal`适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；  

使用`ThreadLocal`要用`try ... finally`结构，并在`finally`中清除。  

实际上`ThreadLocal`本身不会存储任何数据，`ThreadLocal.set`方法是将值存储到`Thread`线程本身的`ThreadLocalMap`里面了。如果线程执行完毕就死亡了，实时上是不需要调用`ThreadLocal`的`remove`方法的。因为`ThreadLocalMap`是属于线程对象的，线程都死亡了，`ThreadLocalMap`里面存的值自然就不存在了。但是，真正的项目开发中基本上都是从线程池里面获取线程的，所以线程执行完**并不会死亡**，而是会被线程池复用。  

## 虚拟线程
虚拟线程（Virtual Thread）是**Java 19**引入的一种轻量级线程，它在很多其他语言中被称为协程、纤程、绿色线程、用户态线程等。  

在理解虚拟线程前，先回顾一下线程的特点：  

- 线程是由操作系统创建并调度的资源；
- 线程切换会耗费大量CPU时间；
- 一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。

因此，说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度的线程数量，所以通常使用线程池来尽量减少频繁创建和销毁线程的成本。  

对于需要处理大量IO请求的任务来说，使用线程是低效的，因为一旦读写IO，线程就必须进入等待状态，直到IO数据返回。常见的IO操作包括：  

- 读写文件；
- 读写网络，例如HTTP请求；
- 读写数据库，本质上是通过JDBC实现网络调用。

一个处理HTTP请求的线程，它在读写网络、文件的时候就会进入等待状态：  
```ascii
Begin
────────
Blocking ──▶ Read HTTP Request
Wait...
Wait...
Wait...
────────
Running
────────
Blocking ──▶ Read Config File
Wait...
────────
Running
────────
Blocking ──▶ Read Database
Wait...
Wait...
Wait...
────────
Running
────────
Blocking ──▶ Send HTTP Response
Wait...
Wait...
────────
End
```
真正由CPU执行的代码消耗的时间非常少，线程的大部分时间都在等待IO。我们把这类任务称为IO密集型任务。  

为了能高效执行IO密集型任务，Java从**19**开始引入了虚拟线程。虚拟线程的接口和普通线程是一样的，但是执行方式不一样。虚拟线程不是由操作系统调度，而是由普通线程调度，即成百上千个虚拟线程可以由一个普通线程调度。任何时刻，只能执行一个虚拟线程，但是，一旦该虚拟线程执行一个IO操作进入等待时，它会被立刻“挂起”，然后执行下一个虚拟线程。什么时候IO数据返回了，这个挂起的虚拟线程才会被再次调度。因此，若干个虚拟线程可以在一个普通线程中交替运行：  

```ascii
Begin
───────────
V1 Runing
V1 Blocking ──▶ Read HTTP Request
───────────
V2 Runing
V2 Blocking ──▶ Read HTTP Request
───────────
V3 Runing
V3 Blocking ──▶ Read HTTP Request
───────────
V1 Runing
V1 Blocking ──▶ Read Config File
───────────
V2 Runing
V2 Blocking ──▶ Read Database
───────────
V1 Runing
V1 Blocking ──▶ Read Database
───────────
V3 Runing
V3 Blocking ──▶ Read Database
───────────
V2 Runing
V2 Blocking ──▶ Send HTTP Response
───────────
V1 Runing
V1 Blocking ──▶ Send HTTP Response
───────────
V3 Runing
V3 Blocking ──▶ Send HTTP Response
───────────
End
```
如果单独看一个虚拟线程的代码，在一个方法中：  
```java
void register() {
    config = readConfigFile("./config.json"); // #1
    if (config.useFullName) {
        name = req.firstName + " " + req.lastName;
    }
    insertInto(db, name); // #2
    if (config.cache) {
        redis.set(key, name); // #3
    }
}
```
涉及到IO读写的#1、#2、#3处，执行到这些地方的时候（进入相关的JNI方法内部时）会自动挂起，并切换到其他虚拟线程执行。等到数据返回后，当前虚拟线程会再次调度并执行，因此，代码看起来是同步执行，但实际上是异步执行的。  

**使用虚拟线程**
虚拟线程的接口和普通线程一样，唯一区别在于创建虚拟线程只能通过特定方法。  

方法一：直接创建虚拟线程并运行：  

```java
// 传入Runnable实例并立刻运行:
Thread vt = Thread.startVirtualThread(() -> {
    System.out.println("Start virtual thread...");
    Thread.sleep(10);
    System.out.println("End virtual thread.");
});
```
方法二：创建虚拟线程但不自动运行，而是手动调用`start()`开始运行：  
```java
// 创建VirtualThread:
Thread.ofVirtual().unstarted(() -> {
    System.out.println("Start virtual thread...");
    Thread.sleep(1000);
    System.out.println("End virtual thread.");
});
// 运行:
vt.start();
```
方法三：通过虚拟线程的`ThreadFactory`创建虚拟线程，然后手动调用`start()`开始运行：  
```java
// 创建ThreadFactory:
ThreadFactory tf = Thread.ofVirtual().factory();
// 创建VirtualThread:
Thread vt = tf.newThread(() -> {
    System.out.println("Start virtual thread...");
    Thread.sleep(1000);
    System.out.println("End virtual thread.");
});
// 运行:
vt.start();
```
直接调用`start()`实际上是由`ForkJoinPool`的线程来调度的。也可以自己创建调度线程，然后运行虚拟线程：  
```java
// 创建调度器:
ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();
// 创建大量虚拟线程并调度:
ThreadFactory tf = Thread.ofVirtual().factory();
for (int i=0; i<100000; i++) {
    Thread vt = tf.newThread(() -> { ... });
    executor.submit(vt);
    // 也可以直接传入Runnable或Callable:
    executor.submit(() -> {
        System.out.println("Start virtual thread...");
        Thread.sleep(1000);
        System.out.println("End virtual thread.");
        return true;
    });
}
```
由于虚拟线程属于非常轻量级的资源，因此，用时创建，用完就扔，不要池化虚拟线程。  

最后注意，虚拟线程在**Java 21**正式发布，在**Java 19/20**是预览功能，默认关闭，需要添加参数`--enable-preview`启用：  

```bash
java --source 19 --enable-preview Main.java
```
**使用限制**

只有以虚拟线程方式运行的代码，才会在执行IO操作时自动被挂起并切换到其他虚拟线程。普通线程的IO操作仍然会等待，例如，我们在`main()`方法中读写文件，是不会有调度和自动挂起的。  

可以自动引发调度切换的操作包括：  

- 文件IO；
- 网络IO；
- 使用`Concurrent`库引发等待；
- `Thread.sleep()`操作。

这是因为JDK为了实现虚拟线程，已经对底层相关操作进行了修改，这样应用层的Java代码无需修改即可使用虚拟线程。无法自动切换的JavaScript语言需要用户手动调用`await`来实现异步操作：  
```javascript
async function doWork() {
    await readFile();
    await sendNetworkData();
}
```
在虚拟线程中，如果绕过JDK的IO接口，直接通过JNI读写文件或网络是无法实现调度的。此外，在`synchronized`块内部也无法调度。  

**Java 19**引入的虚拟线程是为了解决IO密集型任务的吞吐量，它可以高效通过少数线程去调度大量虚拟线程；  

虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化线程的执行效率；  

虚拟线程使用普通线程相同的接口，最大的好处是无需修改任何代码，就可以将现有的IO操作异步化获得更大的吞吐能力。  

计算密集型任务不应使用虚拟线程，只能通过增加CPU核心解决，或者利用分布式计算资源。  
