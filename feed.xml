<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-03-08T00:35:08+08:00</updated><id>/feed.xml</id><title type="html">个人博客</title><subtitle></subtitle><author><name>acteds</name></author><entry><title type="html">SecureRandom</title><link href="/2024/12/24/SecureRandom/" rel="alternate" type="text/html" title="SecureRandom" /><published>2024-12-24T00:00:00+08:00</published><updated>2024-12-24T00:00:00+08:00</updated><id>/2024/12/24/SecureRandom</id><content type="html" xml:base="/2024/12/24/SecureRandom/"><![CDATA[<h1 id="引言">引言</h1>

<p><code class="language-plaintext highlighter-rouge">SecureRandom</code>随机数的坑，java8版本与java17版本的该类底层原理不同。</p>

<h1 id="securerandom">SecureRandom</h1>

<h2 id="问题复现">问题复现</h2>

<p>场景：需要对存入数据库的敏感数据进行非对称加密，对于不涉及加密数据的查询，无所谓随机数是否固定，但对于涉及加密数据的查询，就需要固定随机数了。因此有如下方法用来加密：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * SM2加密
     *
     * @param data      待加密数据
     * @return 加密后的数据
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">sm2Encrypt</span><span class="o">(</span> <span class="nc">String</span> <span class="n">data</span><span class="o">){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="nc">StringUtil</span><span class="o">.</span><span class="na">isNotNull</span><span class="o">(</span><span class="n">data</span><span class="o">)){</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//使用固定随机数</span>
            <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
            <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
            <span class="nc">ECPublicKeyParameters</span> <span class="n">publicKeyParam</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ECPublicKeyParameters</span><span class="o">)</span> <span class="nc">PublicKeyFactory</span><span class="o">.</span><span class="na">createKey</span><span class="o">(</span><span class="n">getPublicKey</span><span class="o">().</span><span class="na">getEncoded</span><span class="o">());</span>
            <span class="nc">CipherParameters</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParametersWithRandom</span><span class="o">(</span><span class="n">publicKeyParam</span><span class="o">,</span> <span class="n">random</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypt</span> <span class="o">=</span> <span class="n">iniSmUtil</span><span class="o">().</span><span class="na">encrypt</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span><span class="n">parameters</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">base64String</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">encodeBase64String</span><span class="o">(</span><span class="n">encrypt</span><span class="o">);</span>
            <span class="c1">//转16进制后返回</span>
            <span class="k">return</span> <span class="nc">HexUtil</span><span class="o">.</span><span class="na">encodeHexStr</span><span class="o">(</span><span class="n">base64String</span><span class="o">,</span> <span class="nc">CharsetUtil</span><span class="o">.</span><span class="na">CHARSET_UTF_8</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"SM2数据加密异常:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>这里的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
<span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
</code></pre></div></div>

<p>就是固定随机数。测试在Java8中相同种子是否返回相同的随机数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用固定随机数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[-1765061395]</span>
</code></pre></div></div>

<p><strong>相同</strong>，在Java17中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span><span class="c1">//10000</span>
</code></pre></div></div>

<p><strong>不相同</strong>。实际上是<code class="language-plaintext highlighter-rouge">SecureRandom</code>的底层随机数算法发生了变化。</p>

<h2 id="基本用法">基本用法</h2>

<p><code class="language-plaintext highlighter-rouge">SecureRandom</code> 是一个提供加密强随机数生成器（RNG）的类，用于生成符合加密要求的随机数。</p>

<p><strong>加密强随机数</strong>：</p>
<ul>
  <li>加密强随机数是指符合统计随机数生成器测试要求的随机数，满足 FIPS 140-2 和 RFC 4086 的要求，必须生成不可预测的输出。</li>
  <li><code class="language-plaintext highlighter-rouge">SecureRandom</code> 必须生成非确定性输出，即每次生成的结果应该是随机且难以预测的。</li>
</ul>

<p><strong>伪随机数生成器（PRNG）与真随机数</strong>：</p>
<ul>
  <li>大多数 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 的实现是基于伪随机数生成器（PRNG），即使用确定性的算法从随机种子生成伪随机数序列。</li>
  <li>也有一些实现通过硬件或环境噪声等物理方式生成真随机数。</li>
  <li>还有一些实现会结合这两种技术。</li>
</ul>

<p><strong>获取 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例</strong>：</p>

<p>可以通过无参构造函数或 <code class="language-plaintext highlighter-rouge">getInstance</code> 方法获取 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例，并指定具体的随机数生成算法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span> <span class="c1">// 默认</span>
<span class="nc">SecureRandom</span> <span class="n">r2</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNG"</span><span class="o">);</span> <span class="c1">// 使用特定算法</span>
<span class="nc">SecureRandom</span> <span class="n">r3</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DRBG"</span><span class="o">,</span> <span class="nc">DrbgParameters</span><span class="o">.</span><span class="na">instantiation</span><span class="o">(</span><span class="mi">128</span><span class="o">,</span> <span class="no">RESEED_ONLY</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span> <span class="c1">// 使用 DRBG 算法</span>
</code></pre></div></div>

<p><strong>生成随机字节</strong>：</p>

<p>常用的方法是通过 <code class="language-plaintext highlighter-rouge">nextBytes(byte[] bytes)</code> 生成随机字节数组。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">20</span><span class="o">];</span>
<span class="n">random</span><span class="o">.</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>生成种子</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">generateSeed</code> 方法可以用来生成一定数量的种子字节，通常用于给其他随机数生成器提供种子。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>自我播种</strong>：</p>
<ul>
  <li>新创建的 PRNG <code class="language-plaintext highlighter-rouge">SecureRandom</code> 对象不会自动播种，除非是通过 <code class="language-plaintext highlighter-rouge">SecureRandom(byte[])</code> 构造函数创建的。</li>
  <li>如果没有显式调用 <code class="language-plaintext highlighter-rouge">setSeed</code>，第一次调用 <code class="language-plaintext highlighter-rouge">nextBytes</code> 时，它会自动从实现特定的熵源播种自己。</li>
</ul>

<p><strong>重播种</strong>：</p>
<ul>
  <li>可以通过 <code class="language-plaintext highlighter-rouge">reseed</code> 或 <code class="language-plaintext highlighter-rouge">setSeed</code> 方法对 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 进行重播种。<code class="language-plaintext highlighter-rouge">reseed</code> 方法会从熵源读取输入进行重播种，而 <code class="language-plaintext highlighter-rouge">setSeed</code> 方法则需要显式提供种子。</li>
  <li>需要注意的是，并非所有实现都支持 <code class="language-plaintext highlighter-rouge">reseed</code>。</li>
</ul>

<p><strong>支持的实现和线程安全性</strong>：</p>
<ul>
  <li>一些 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实现可能会接受 <code class="language-plaintext highlighter-rouge">SecureRandomParameters</code> 参数来进一步控制方法行为。</li>
  <li>根据实现的不同，<code class="language-plaintext highlighter-rouge">generateSeed</code>、<code class="language-plaintext highlighter-rouge">reseed</code> 和 <code class="language-plaintext highlighter-rouge">nextBytes</code> 方法可能会阻塞，尤其是当熵源是 <code class="language-plaintext highlighter-rouge">/dev/random</code>（在类 Unix 操作系统上）时。</li>
  <li><code class="language-plaintext highlighter-rouge">SecureRandom</code> 对象是线程安全的，可以在多个并发线程中使用。</li>
</ul>

<p><strong>线程安全</strong>：</p>
<ul>
  <li>如果 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 服务提供者支持线程安全，则会在服务提供者注册时设置“ThreadSafe”属性为“true”。</li>
  <li>如果没有声明线程安全，<code class="language-plaintext highlighter-rouge">SecureRandom</code> 会通过同步来确保以下方法的线程安全：</li>
  <li><code class="language-plaintext highlighter-rouge">engineSetSeed(byte[])</code></li>
  <li><code class="language-plaintext highlighter-rouge">engineNextBytes(byte[])</code></li>
  <li><code class="language-plaintext highlighter-rouge">engineGenerateSeed(int)</code></li>
  <li><code class="language-plaintext highlighter-rouge">engineReseed(SecureRandomParameters)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">SecureRandom</code> 是 Java 提供的一个加密强度的随机数生成器，它可以生成适用于加密、密码学和其他安全应用的随机数。该类支持多种随机数生成算法，包括伪随机数生成算法和真随机数生成算法。用户可以通过不同的方式获取 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例，并生成随机字节或种子。<code class="language-plaintext highlighter-rouge">SecureRandom</code> 对象是线程安全的，可以在多线程环境中使用。</p>

<h2 id="数字生成算法">数字生成算法</h2>

<p>SecureRandom 有如下数字生成算法：<a href="https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#securerandom-number-generation-algorithms">Java Security Standard Algorithm Names</a></p>

<table>
  <thead>
    <tr>
      <th>算法名称</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>NativePRNG</strong></td>
      <td>从底层操作系统获取随机数。没有对生成这些数字的阻塞性质做出任何声明。</td>
    </tr>
    <tr>
      <td><strong>NativePRNGBlocking</strong></td>
      <td>从底层操作系统获取随机数，必要时会阻塞。例如，类 UNIX 系统中的 <code class="language-plaintext highlighter-rouge">/dev/random</code>。</td>
    </tr>
    <tr>
      <td><strong>NativePRNGNonBlocking</strong></td>
      <td>从底层操作系统获取随机数，不会阻塞，避免应用程序过度停顿。例如，类 UNIX 系统中的 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>。</td>
    </tr>
    <tr>
      <td><strong>PKCS11</strong></td>
      <td>从底层已安装并配置的 PKCS #11 库获取随机数。</td>
    </tr>
    <tr>
      <td><strong>DRBG</strong></td>
      <td>使用 NIST SP 800-90Ar1 中定义的 DRBG 机制的算法。</td>
    </tr>
    <tr>
      <td><strong>SHA1PRNG</strong></td>
      <td>使用 SUN 提供的伪随机数生成（PRNG）算法。该算法使用 SHA-1 作为 PRNG 的基础。通过对一个真实随机种子值和一个 64 位计数器进行 SHA-1 哈希计算，每次操作时计数器递增 1。 从 160 位的 SHA-1 输出中，仅使用 64 位。</td>
    </tr>
    <tr>
      <td><strong>Windows-PRNG</strong></td>
      <td>从底层 Windows 操作系统获取随机数。</td>
    </tr>
  </tbody>
</table>

<p>这些算法各自具有不同的实现方式和用途，可以根据安全需求和平台特性选择合适的算法。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">new SecureRandom()</code> 创建的 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例使用的算法是 <strong>平台默认的伪随机数生成算法</strong>。该算法通常依赖于操作系统提供的随机数生成机制，但具体算法的选择会根据操作系统和 Java 实现的不同而有所变化。</p>

<p>常见的实现和算法：</p>
<ol>
  <li><strong>Unix-like 操作系统（Linux、macOS等）</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SecureRandom</code> 默认会使用基于 <code class="language-plaintext highlighter-rouge">/dev/urandom</code> 或 <code class="language-plaintext highlighter-rouge">/dev/random</code> 的随机数生成器。</li>
      <li><code class="language-plaintext highlighter-rouge">/dev/urandom</code>：非阻塞的伪随机数生成器，它会不断使用系统熵池中的数据生成随机数。</li>
      <li><code class="language-plaintext highlighter-rouge">/dev/random</code>：阻塞的伪随机数生成器，只有当系统熵池中的数据足够时才能生成随机数。</li>
    </ul>
  </li>
  <li>
    <p><strong>Windows 操作系统</strong>：<code class="language-plaintext highlighter-rouge">SecureRandom</code> 默认会使用 <strong>Windows-PRNG</strong>（基于 Windows 操作系统的随机数生成器）。</p>
  </li>
  <li><strong>其他平台</strong>：在一些平台上，<code class="language-plaintext highlighter-rouge">SecureRandom</code> 可能会使用类似 <strong>NativePRNG</strong> 的伪随机数生成算法。</li>
</ol>

<p>实现原理：</p>
<ul>
  <li><strong>NativePRNG</strong>：一种伪随机数生成算法，通常会依赖于操作系统提供的底层熵源。在 Unix-like 系统中，它通过 <code class="language-plaintext highlighter-rouge">dev/urandom</code> 提供一个快速的、非阻塞的随机数生成方式。</li>
  <li><strong>DRBG（Deterministic Random Bit Generator）</strong>：如果平台不提供足够的熵源，或者要求更强的加密性质，<code class="language-plaintext highlighter-rouge">SecureRandom</code> 会使用 DRBG 算法，它是一个基于确定性算法的伪随机数生成器。常用于满足更严格的安全需求。</li>
</ul>

<p>通过 <code class="language-plaintext highlighter-rouge">new SecureRandom()</code> 创建的 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例使用的是平台默认的算法，它通常依赖于操作系统提供的熵源。在类 Unix 操作系统中，它通常基于 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>，而在 Windows 操作系统中，它会使用 Windows 提供的 <code class="language-plaintext highlighter-rouge">Windows-PRNG</code> 算法。具体使用哪种算法，可以通过 <code class="language-plaintext highlighter-rouge">SecureRandom.getInstance()</code> 方法显式指定。</p>

<p>下面是几个示例代码，展示了如何选择不同的随机数生成算法并输出其生成的随机数。</p>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">NativePRNG</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 NativePRNG 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNG"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"NativePRNG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>输出的随机数将来自底层操作系统的随机数源，没有对阻塞性质做任何声明。不同操作系统的行为可能不同。</p>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">NativePRNGBlocking</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 NativePRNGBlocking 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNGBlocking"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"NativePRNGBlocking Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>该算法会从底层操作系统的 <code class="language-plaintext highlighter-rouge">blocking</code> 随机数源获取随机数。在 Linux 系统上，通常会从 <code class="language-plaintext highlighter-rouge">/dev/random</code> 获取，可能会在系统缺少足够的熵时导致阻塞。</p>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">NativePRNGNonBlocking</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 NativePRNGNonBlocking 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNGNonBlocking"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"NativePRNGNonBlocking Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>该算法将从非阻塞的随机数源获取随机数，例如 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>，即使系统缺乏熵，也不会阻塞，能保证更快的响应时间。</p>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">PKCS11</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 PKCS11 算法（需要配置并且支持 PKCS11 提供者）</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PKCS11"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PKCS11 Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>该算法将使用已安装的 PKCS#11 加密模块提供的随机数生成器。如果没有安装支持的硬件加密模块或配置正确的 PKCS#11 提供者，可能会抛出异常。</p>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">DRBG</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.bouncycastle.crypto.prng.DrbgParameters</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 DRBG 算法</span>
       <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DRBG"</span><span class="o">,</span> <span class="nc">DrbgParameters</span><span class="o">.</span><span class="na">instantiation</span><span class="o">(</span><span class="mi">128</span><span class="o">,</span> <span class="nc">DrbgParameters</span><span class="o">.</span><span class="na">Capability</span><span class="o">.</span><span class="na">RESEED_ONLY</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DRBG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>该算法使用 DRBG（Deterministic Random Bit Generator）机制，通常基于哈希函数或加密算法（例如 SHA-256）生成随机数。需要合适的参数进行初始化。此算法通常提供高安全性，并且能够生成高质量的随机数。</p>

<p><strong>“DRBG”</strong></p>

<p>这里指定了使用的算法为 <strong>DRBG</strong>（Deterministic Random Bit Generator）。它是基于特定标准（如 NIST SP 800-90A）定义的伪随机数生成算法。DRBG 主要通过一个确定性算法（通常是基于哈希函数或者加密算法）来生成伪随机数序列，并且可以通过一定的种子输入和系统熵来源进行初始化。</p>

<p><strong><code class="language-plaintext highlighter-rouge">DrbgParameters.instantiation(int securityStrength, DrbgParameters.Capability capability, byte[] personalizationString)</code></strong></p>

<p>(DRBG 参数实例化)这个方法用于指定 DRBG 的生成方式，通常包括以下三个重要参数：</p>

<p><strong><code class="language-plaintext highlighter-rouge">securityStrength</code></strong> (安全强度)</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">securityStrength</code> 是 DRBG 算法的安全强度，以位为单位。例如，<code class="language-plaintext highlighter-rouge">128</code> 表示 DRBG 的输出应该具有 128 位的安全强度，通常是为了保证随机数生成的强度和质量。这意味着生成的随机数在算法层面上应该至少提供 128 位的安全保障。</li>
  <li>一般来说，安全强度是基于预期的用途来选择的。如果你需要更高的安全性，可以选择更高的安全强度（比如 256 位）。例如：</li>
  <li>128：适用于一般的加密操作和安全应用。</li>
  <li>256：适用于高安全性的要求。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">capability</code></strong> (能力)</p>

<p><strong><code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code></strong>:</p>

<ul>
  <li>这个值表示所请求的 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例 <strong>同时支持预测抗性</strong> 和 <strong>重种子功能</strong>。</li>
  <li><strong>预测抗性（Prediction Resistance）</strong>：确保通过某些途径预测随机数生成器的输出变得极其困难，增加安全性。对于加密应用，通常需要预测抗性来防止攻击者通过某些方式推测后续生成的随机数。</li>
  <li><strong>重种子（Reseed）</strong>：DRBG 需要定期重新引入熵源（例如，新的随机输入），以保持生成的随机数的质量。重种子是为了避免长期使用同一种子产生的随机数序列趋向于可预测。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">RESEED_ONLY</code></strong>:</p>
<ul>
  <li>这个值表示所请求的 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例 <strong>仅支持重种子功能</strong>，而 <strong>不支持预测抗性</strong>。</li>
  <li>这种能力适用于需要定期刷新或更新种子的场景，但不要求具备强大的抗预测性。在一些不那么敏感的应用中，可能只需要重种子来保证随机数的质量，而不一定要求具有预测抗性。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">NONE</code></strong>:</p>
<ul>
  <li>这个值表示所请求的 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例 <strong>既不支持预测抗性，也不支持重种子功能</strong>。</li>
  <li>在某些情况下，可能仅需要生成一次性的随机数，而不需要进行任何后续的重种子或抗预测性保护。例如，一些简单的随机数生成应用可能不要求具有特别高的安全标准。</li>
</ul>

<p>不同的请求能力与可能的实际能力之间的关系：</p>
<ul>
  <li>请求 <strong>NONE</strong> 能力时，实际返回的能力可能是 <code class="language-plaintext highlighter-rouge">NONE</code>、<code class="language-plaintext highlighter-rouge">RESEED_ONLY</code> 或 <code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>。</li>
  <li>请求 <strong>RESEED_ONLY</strong> 时，实际返回的能力可能是 <code class="language-plaintext highlighter-rouge">RESEED_ONLY</code> 或 <code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>。</li>
  <li>请求 <strong>PR_AND_RESEED</strong> 时，实际返回的能力一定是 <code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>。</li>
</ul>

<p>总结：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>：支持重种子和预测抗性。</li>
  <li><code class="language-plaintext highlighter-rouge">RESEED_ONLY</code>：仅支持重种子，不支持预测抗性。</li>
  <li><code class="language-plaintext highlighter-rouge">NONE</code>：既不支持预测抗性，也不支持重种子。</li>
</ul>

<p>这种能力控制机制提供了灵活性，允许开发者根据实际安全需求选择最合适的 <code class="language-plaintext highlighter-rouge">DRBG</code> 配置。</p>

<p><strong><code class="language-plaintext highlighter-rouge">personalizationString</code></strong> (个性化字符串)</p>
<ul>
  <li>这个参数用于初始化 DRBG 时的个性化字符串，通常是额外的输入数据，用于增强生成随机数的多样性和不可预测性。传入 <code class="language-plaintext highlighter-rouge">null</code> 表示没有使用个性化字符串。</li>
  <li>个性化字符串有助于在特定上下文中初始化 DRBG，确保在不同场景中生成的随机数是不同的。</li>
  <li>如果你希望在初始化时根据特定的上下文或环境（如设备ID、时间戳等）来生成不同的随机数种子，可以使用个性化字符串。</li>
</ul>

<p><strong>整体效果</strong></p>

<p>综合来看，这行代码通过 <code class="language-plaintext highlighter-rouge">DrbgParameters.instantiation(128, DrbgParameters.Capability.RESEED_ONLY, null)</code> 来创建一个 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例，它有以下特点：</p>
<ul>
  <li><strong>128 位安全强度</strong>，生成的随机数序列具有较高的安全性。</li>
  <li><strong>RESEED_ONLY</strong> 能力，意味着该实例不直接生成随机数，而是在需要时执行重种子操作。</li>
  <li><strong>没有个性化字符串</strong>，即 DRBG 使用的是默认的熵源，而不是特定上下文的数据。</li>
</ul>

<p>这种配置通常适用于需要安全随机数生成、定期重种子的场景，尤其是在要求较高安全性的加密应用中。</p>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">SHA1PRNG</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 SHA1PRNG 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1PRNG"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"SHA1PRNG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>SHA1PRNG 是一个基于 SHA-1 哈希的伪随机数生成器。其生成的随机数会受到初始种子和计数器的影响，生成的随机数相对较为可预测，但对于大多数非安全应用场景是足够的。</p>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">Windows-PRNG</code> 算法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 Windows-PRNG 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"Windows-PRNG"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Windows-PRNG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>预期结果：</strong></p>

<p>该算法将从 Windows 操作系统的随机数源（例如通过 Windows Cryptographic API）生成随机数。</p>

<hr />

<p>总结</p>

<ol>
  <li><strong>NativePRNG</strong> 和 <strong>Windows-PRNG</strong> 会依赖操作系统的原生随机数生成机制，通常比较快，但可能不太适合高安全性需求。</li>
  <li><strong>NativePRNGBlocking</strong> 会阻塞直到足够的随机数可用，适合用于高安全性的环境，但可能会延迟。</li>
  <li><strong>NativePRNGNonBlocking</strong> 适用于不希望阻塞的环境，会优先使用 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>。</li>
  <li><strong>PKCS11</strong> 和 <strong>DRBG</strong> 提供硬件加速和更高的安全性，但依赖于相应的硬件和配置。</li>
  <li><strong>SHA1PRNG</strong> 是基于 SHA-1 的伪随机数生成器，适用于一般用途，但不适合高安全性的要求。</li>
</ol>

<p>根据具体需求选择合适的算法。</p>

<h2 id="解决">解决</h2>

<p>在Java8中相同种子是否返回相同的随机数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用固定随机数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[-1765061395]</span>
</code></pre></div></div>

<p>在Java17中，指定<code class="language-plaintext highlighter-rouge">SHA1PRNG</code>随机数生成器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用固定随机数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1PRNG"</span><span class="o">);</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[-1765061395]</span>
</code></pre></div></div>

<p>进一步测试：</p>

<p>java17：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1PRNG"</span><span class="o">);</span>
        <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[1171630791, -70273684, -1765061395, -786090109, 1560068868, 1762545591, 1861147253, -551574285, 1891309446, -1389656251]</span>
</code></pre></div></div>

<p>java8：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
        <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[1171630791, -70273684, -1765061395, -786090109, 1560068868, 1762545591, 1861147253, -551574285, 1891309446, -1389656251]</span>
</code></pre></div></div>

<p>可以看出结果一致，实际上只要保证指定种子返回固定的随机数序列即可。</p>

<p>然后将之前的数据重新指定算法加密即可。</p>]]></content><author><name>acteds</name></author><category term="Java" /><category term="IDEA" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Drools规则引擎</title><link href="/2024/12/21/Drools%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/" rel="alternate" type="text/html" title="Drools规则引擎" /><published>2024-12-21T00:00:00+08:00</published><updated>2024-12-21T00:00:00+08:00</updated><id>/2024/12/21/Drools%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E</id><content type="html" xml:base="/2024/12/21/Drools%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"><![CDATA[<h1 id="引言">引言</h1>

<p>Drools规则引擎，说明</p>

<h1 id="drools">Drools</h1>

<h2 id="基本使用">基本使用</h2>

<p>引入依赖：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.drools<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>drools-compiler<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>7.14.0.Final<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>服务层：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">io.swagger.annotations.ApiOperation</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.Data</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.NoArgsConstructor</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.lang.StringUtils</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.drools.core.definitions.InternalKnowledgePackage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.drools.core.impl.KnowledgeBaseImpl</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.api.KieBaseConfiguration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.api.KieServices</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.api.io.ResourceType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.api.runtime.KieSession</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.internal.builder.KnowledgeBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.internal.builder.KnowledgeBuilderFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.internal.io.ResourceFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.internal.utils.KieHelper</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>

<span class="nd">@Slf4j</span>
<span class="nd">@Component</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@ApiOperation</span><span class="o">(</span><span class="s">"规则引擎"</span><span class="o">)</span>
<span class="nd">@Data</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">KnowledgeContext</span> <span class="o">{</span>

    <span class="cm">/**
     * 规则上下文
     */</span>
    <span class="kd">private</span> <span class="nc">KnowledgeBaseImpl</span> <span class="n">knowledgeBase</span><span class="o">;</span>

    <span class="cm">/**
     * 规则内容
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">rule</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">KnowledgeContext</span><span class="o">(</span><span class="nc">String</span> <span class="n">rule</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span> <span class="o">=</span> <span class="n">buildImpl</span><span class="o">();</span>
        <span class="c1">//构建提交数据规则</span>
        <span class="k">if</span> <span class="o">(!</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="n">rule</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">KnowledgeBuilder</span> <span class="n">paramsKb</span> <span class="o">=</span> <span class="nc">KnowledgeBuilderFactory</span><span class="o">.</span><span class="na">newKnowledgeBuilder</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">paramsKb</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">ResourceFactory</span><span class="o">.</span><span class="na">newByteArrayResource</span><span class="o">(</span><span class="n">rule</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)),</span> <span class="nc">ResourceType</span><span class="o">.</span><span class="na">DRL</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">paramsKb</span><span class="o">.</span><span class="na">hasErrors</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"参数的规则文件:{}错误：{}"</span><span class="o">,</span> <span class="n">rule</span><span class="o">,</span> <span class="n">paramsKb</span><span class="o">.</span><span class="na">getErrors</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"规则文件错误："</span> <span class="o">+</span> <span class="n">paramsKb</span><span class="o">.</span><span class="na">getErrors</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"构建规则:{}时出现异常,异常为:{}"</span><span class="o">,</span> <span class="n">rule</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span><span class="o">.</span><span class="na">addPackages</span><span class="o">(</span><span class="n">paramsKb</span><span class="o">.</span><span class="na">getKnowledgePackages</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rule</span> <span class="o">=</span> <span class="n">rule</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="kd">private</span> <span class="nc">KnowledgeBaseImpl</span> <span class="nf">buildImpl</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">KieBaseConfiguration</span> <span class="n">kbConfig</span> <span class="o">=</span> <span class="nc">KieServices</span><span class="o">.</span><span class="na">Factory</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">newKieBaseConfiguration</span><span class="o">();</span>
        <span class="nc">KnowledgeBaseImpl</span> <span class="n">impl</span> <span class="o">=</span> <span class="o">(</span><span class="nc">KnowledgeBaseImpl</span><span class="o">)</span> <span class="k">new</span> <span class="nc">KieHelper</span><span class="o">().</span><span class="na">build</span><span class="o">(</span><span class="n">kbConfig</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">impl</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">KieSession</span> <span class="nf">getSession</span><span class="o">(</span><span class="nc">RuleTypeEnum</span> <span class="n">ruleTypeEnum</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span><span class="o">.</span><span class="na">newKieSession</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 更新规则,删除原有的所有规则,重新加载新规则
     *
     * @return
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">updateRule</span><span class="o">(</span><span class="nc">String</span> <span class="n">rule</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">KnowledgeBuilder</span> <span class="n">kb</span> <span class="o">=</span> <span class="nc">KnowledgeBuilderFactory</span><span class="o">.</span><span class="na">newKnowledgeBuilder</span><span class="o">();</span>
        <span class="n">kb</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">ResourceFactory</span><span class="o">.</span><span class="na">newByteArrayResource</span><span class="o">(</span><span class="n">rule</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)),</span> <span class="nc">ResourceType</span><span class="o">.</span><span class="na">DRL</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">kb</span><span class="o">.</span><span class="na">hasErrors</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"规则文件:{} 错误：{}"</span><span class="o">,</span> <span class="n">rule</span><span class="o">,</span> <span class="n">kb</span><span class="o">.</span><span class="na">getErrors</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"规则文件错误："</span> <span class="o">+</span> <span class="n">kb</span><span class="o">.</span><span class="na">getErrors</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>

        <span class="o">}</span>
        <span class="nc">KnowledgeBaseImpl</span> <span class="n">knowledgeBase</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getKnowledgeBase</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rule</span> <span class="o">=</span> <span class="n">rule</span><span class="o">;</span>
        <span class="c1">//清除原规则</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">InternalKnowledgePackage</span> <span class="n">internalKnowledgePackage</span> <span class="o">:</span> <span class="n">knowledgeBase</span><span class="o">.</span><span class="na">getPackages</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">knowledgeBase</span><span class="o">.</span><span class="na">removeKiePackage</span><span class="o">(</span><span class="n">internalKnowledgePackage</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="n">knowledgeBase</span><span class="o">.</span><span class="na">addPackages</span><span class="o">(</span><span class="n">kb</span><span class="o">.</span><span class="na">getKnowledgePackages</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">clean</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">InternalKnowledgePackage</span> <span class="n">aPackage</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span><span class="o">.</span><span class="na">getPackages</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span><span class="o">.</span><span class="na">removeKiePackage</span><span class="o">(</span><span class="n">aPackage</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">this</span><span class="o">.</span><span class="na">knowledgeBase</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rule</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>调用规则代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.ilw.formflowprovider</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.ilw.formflowprovider.center.kie.KnowledgeContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.ilw.formflowprovider.center.kie.RuleTypeEnum</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.kie.api.runtime.KieSession</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.ByteArrayOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>


<span class="cm">/**
 * @author aotmd
 * @version 1.0
 * @date 2024/12/21 9:32
 */</span>
<span class="c1">//@SpringBootTest(classes = FormflowproviderApplication.class)</span>
<span class="c1">//@RunWith(SpringRunner.class)</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DroolsTest</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">startTestDroolsRule</span><span class="o">(</span><span class="s">"drl/规则引擎代码赋值操作实例.drl"</span><span class="o">,</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;());</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 启动规则引擎规则代码
     * @param ruleFilePath 规则文件路径
     * @param param 入参
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">startTestDroolsRule</span><span class="o">(</span><span class="nc">String</span> <span class="n">ruleFilePath</span><span class="o">,</span><span class="nc">Object</span> <span class="n">param</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 读取规则文件内容</span>
        <span class="nc">String</span> <span class="n">ruleContent</span> <span class="o">=</span> <span class="n">readRuleFile</span><span class="o">(</span><span class="n">ruleFilePath</span><span class="o">);</span>

        <span class="c1">// 创建 KnowledgeContext 实例，并传入规则内容</span>
        <span class="nc">KnowledgeContext</span> <span class="n">knowledgeContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">KnowledgeContext</span><span class="o">(</span><span class="n">ruleContent</span><span class="o">);</span>

        <span class="c1">// 获取 KieSession</span>
        <span class="nc">KieSession</span> <span class="n">kieSession</span> <span class="o">=</span> <span class="n">knowledgeContext</span><span class="o">.</span><span class="na">getSession</span><span class="o">(</span><span class="nc">RuleTypeEnum</span><span class="o">.</span><span class="na">CUSTOM</span><span class="o">);</span>
        <span class="c1">// 入参</span>
        <span class="n">kieSession</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">param</span><span class="o">);</span>
        <span class="c1">// 执行 Drools 规则</span>
        <span class="n">kieSession</span><span class="o">.</span><span class="na">fireAllRules</span><span class="o">();</span>
        <span class="c1">// 清理会话</span>
        <span class="n">kieSession</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 读取规则文件内容
     * @param filePath 规则文件路径
     * @return 规则文件内容的字符串
     */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">readRuleFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">filePath</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 使用 ClassLoader 从类路径中加载文件</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="nc">DroolsTest</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">().</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">filePath</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">inputStream</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"无法找到文件: "</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// 传统方法：使用 ByteArrayOutputStream 读取 InputStream 的内容</span>
            <span class="nc">ByteArrayOutputStream</span> <span class="n">byteArrayOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">length</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">length</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">byteArrayOutputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span><span class="n">byteArrayOutputStream</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">(),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span> <span class="c1">// 返回规则文件的内容</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"无法读取规则文件："</span> <span class="o">+</span> <span class="n">filePath</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">drl/规则引擎代码赋值操作实例.drl</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.jiean.schemasystem</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span>

<span class="n">function</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
    <span class="k">return</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
<span class="o">}</span>

<span class="n">rule</span> <span class="s">"start-process"</span>
   <span class="n">when</span>
        <span class="n">$map</span><span class="o">:</span><span class="nc">HashMap</span><span class="o">()</span>
   <span class="n">then</span>
   		<span class="nc">Integer</span> <span class="n">a</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">100</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">100</span><span class="o">+</span><span class="n">i</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="n">end</span>
</code></pre></div></div>

<p>控制台：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10
100
200
</code></pre></div></div>

<h2 id="注意事项">注意事项</h2>

<p>在规则引擎代码中，不支持静态字段导入，即类似：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">constant</span><span class="o">.</span><span class="na">StatusEnum</span><span class="o">.</span><span class="na">FAILURE</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">constant</span><span class="o">.</span><span class="na">StatusEnum</span><span class="o">.</span><span class="na">SUCCESS</span><span class="o">;</span>
</code></pre></div></div>

<p>所以只能先导入类，然后通过类名访问静态字段。</p>

<p>支持静态方法导入：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">ilw</span><span class="o">.</span><span class="na">formflowprovider</span><span class="o">.</span><span class="na">center</span><span class="o">.</span><span class="na">utils</span><span class="o">.</span><span class="na">SpringBeanUtil</span><span class="o">.</span><span class="na">getBean</span><span class="o">;</span>
</code></pre></div></div>

<p>在赋值时，IDE会提示<code class="language-plaintext highlighter-rouge">作用域中已定义变量</code>，忽略即可，不会出错。</p>]]></content><author><name>acteds</name></author><category term="Java" /><category term="IDEA" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">IDEA的配置</title><link href="/2024/12/20/IDEA%E7%9A%84%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="IDEA的配置" /><published>2024-12-20T00:00:00+08:00</published><updated>2024-12-20T00:00:00+08:00</updated><id>/2024/12/20/IDEA%E7%9A%84%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="/2024/12/20/IDEA%E7%9A%84%E9%85%8D%E7%BD%AE/"><![CDATA[<h1 id="引言">引言</h1>

<p>IDEA的常用配置</p>

<h1 id="idea">IDEA</h1>

<h2 id="热更新">热更新</h2>

<p>鼠标移动到<code class="language-plaintext highlighter-rouge">运行</code>按钮所在<code class="language-plaintext highlighter-rouge">工具栏</code>-右键-<code class="language-plaintext highlighter-rouge">自定义工具栏..</code>-进入到<code class="language-plaintext highlighter-rouge">自定义导航栏工具栏</code>对话框。</p>

<p>选择<code class="language-plaintext highlighter-rouge">导航工具栏</code>-<code class="language-plaintext highlighter-rouge">工具栏运行操作</code>-<code class="language-plaintext highlighter-rouge">运行/调试</code>-点击<code class="language-plaintext highlighter-rouge">添加操作</code>按钮-进入到<code class="language-plaintext highlighter-rouge">添加操作</code>对话框。</p>

<p>查询 <code class="language-plaintext highlighter-rouge">编译并重新加载文件</code> ，然后选择，并确认添加该功能按钮。（若找不到，则手动定位：<code class="language-plaintext highlighter-rouge">调试器操作</code>-<code class="language-plaintext highlighter-rouge">编译并重新加载文件</code>）。</p>

<p>查询<code class="language-plaintext highlighter-rouge">更新正在运行的应用程序</code>，然后选择，并确认添加该功能按钮。（若找不到，则手动定位：<code class="language-plaintext highlighter-rouge">主菜单</code>-<code class="language-plaintext highlighter-rouge">运行</code>-<code class="language-plaintext highlighter-rouge">调试器操作</code>-<code class="language-plaintext highlighter-rouge">更新正在运行的应用程序</code>）。</p>

<p>查询<code class="language-plaintext highlighter-rouge">重新加载已更改的类</code>，然后选择，并确认添加该功能按钮。（若找不到，则手动定位：<code class="language-plaintext highlighter-rouge">主菜单</code>-<code class="language-plaintext highlighter-rouge">运行</code>-<code class="language-plaintext highlighter-rouge">调试器操作</code>-<code class="language-plaintext highlighter-rouge">重新加载已更改的类</code>）。</p>

<p>查询<code class="language-plaintext highlighter-rouge">重新加载已更改的类</code>，然后选择，并确认添加该功能按钮。（若找不到，则手动定位：<code class="language-plaintext highlighter-rouge">主菜单</code>-<code class="language-plaintext highlighter-rouge">运行</code>-<code class="language-plaintext highlighter-rouge">调试器操作</code>-<code class="language-plaintext highlighter-rouge">重新加载已更改的类</code>）。</p>

<h2 id="调试器">调试器</h2>

<p>调试器没有强制步入等操作。</p>

<p>打开调试器窗口，鼠标移动到调试器相关按钮所在<code class="language-plaintext highlighter-rouge">工具栏</code>-右键-<code class="language-plaintext highlighter-rouge">自定义工具栏..</code>-进入到<code class="language-plaintext highlighter-rouge">自定义 调试工具窗口顶部工具栏</code>对话框。</p>

<p>点击<code class="language-plaintext highlighter-rouge">添加操作</code>按钮-进入到<code class="language-plaintext highlighter-rouge">添加操作</code>对话框。</p>

<p>定位到<code class="language-plaintext highlighter-rouge">主菜单</code>-<code class="language-plaintext highlighter-rouge">运行</code>-<code class="language-plaintext highlighter-rouge">调试器操作</code>，可以看到相关功能按钮。</p>]]></content><author><name>acteds</name></author><category term="Java" /><category term="IDEA" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Elasticsearch</title><link href="/2024/12/05/elasticsearch/" rel="alternate" type="text/html" title="Elasticsearch" /><published>2024-12-05T00:00:00+08:00</published><updated>2024-12-05T00:00:00+08:00</updated><id>/2024/12/05/elasticsearch</id><content type="html" xml:base="/2024/12/05/elasticsearch/"><![CDATA[<h1 id="引言">引言</h1>

<p>elasticsearch的操作方法。</p>

<h1 id="elasticsearch">Elasticsearch</h1>

<h2 id="简介">简介</h2>

<p>Elasticsearch（简称 ES）是一个开源的分布式搜索引擎，基于 Apache Lucene 构建，能够存储、搜索、分析大量数据。它广泛应用于日志分析、全文搜索、实时数据分析等场景。和 MongoDB 类似，Elasticsearch 也是一个 NoSQL 数据库，但它主要用于高效的搜索和分析。</p>

<p>Elasticsearch 中的核心概念包括：</p>

<ul>
  <li><strong>Index（索引）</strong>：类似于关系数据库中的数据库。它是 Elasticsearch 中的数据存储单位。</li>
  <li><strong>Document（文档）</strong>：类似于关系数据库中的一行数据。一个文档包含一个或多个字段，每个字段有不同的数据类型。</li>
  <li><strong>Field（字段）</strong>：类似于关系数据库中的列。字段包含实际的数据，支持不同的数据类型，如文本、数字、日期等。</li>
  <li><strong>Shard（分片）</strong>：Elasticsearch 将索引数据分成多个分片，以便分布式存储。</li>
  <li><strong>Cluster（集群）</strong>：由多个节点组成，Elasticsearch 集群可以横向扩展以处理大规模的数据。</li>
</ul>

<p>与 MongoDB 对比</p>

<ul>
  <li><strong>数据模型</strong>：
    <ul>
      <li><strong>MongoDB</strong>：文档存储，灵活的 JSON 格式数据，适用于多变的数据结构。</li>
      <li><strong>Elasticsearch</strong>：也使用 JSON 格式，但主要用于高效的文本搜索和分析，支持全文索引、倒排索引等。</li>
    </ul>
  </li>
  <li><strong>查询</strong>：
    <ul>
      <li><strong>MongoDB</strong>：通过 MongoDB 的查询语言进行数据查询，支持多种条件和聚合操作。</li>
      <li><strong>Elasticsearch</strong>：通过 Elasticsearch 的查询 DSL（查询语言）进行复杂的全文搜索、聚合分析和过滤操作，尤其擅长高效的文本搜索。</li>
    </ul>
  </li>
  <li><strong>性能</strong>：
    <ul>
      <li><strong>MongoDB</strong>：适用于大规模的数据存储和处理，支持高并发读写操作。</li>
      <li><strong>Elasticsearch</strong>：专注于高效的搜索和分析，可以快速处理大量的文本数据并提供实时搜索功能。</li>
    </ul>
  </li>
</ul>

<p>Elasticsearch 非常适合需要高效搜索和分析的场景，通常与 MongoDB 配合使用，MongoDB 用于存储结构化数据，Elasticsearch 用于处理和分析日志、文本等非结构化数据。</p>

<hr />

<p>在 Elasticsearch（ES）、MongoDB 和 MySQL 之间，有一些重要的类比关系，它们都属于数据存储系统，但它们的结构和功能有所不同。以下是它们的主要组件和概念的对比：</p>

<p><strong>Elasticsearch 与 MongoDB/MySQL 对比</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>Elasticsearch</strong></th>
      <th><strong>MongoDB</strong></th>
      <th><strong>MySQL</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Index</strong></td>
      <td><strong>Collection</strong></td>
      <td><strong>Table</strong></td>
    </tr>
    <tr>
      <td><strong>Document</strong></td>
      <td><strong>Document</strong></td>
      <td><strong>Row</strong></td>
    </tr>
    <tr>
      <td><strong>Field</strong></td>
      <td><strong>Field</strong></td>
      <td><strong>Column</strong></td>
    </tr>
    <tr>
      <td><strong>Shard</strong></td>
      <td>No Direct Equivalent</td>
      <td>No Direct Equivalent</td>
    </tr>
    <tr>
      <td><strong>Cluster</strong></td>
      <td>No Direct Equivalent</td>
      <td>No Direct Equivalent</td>
    </tr>
  </tbody>
</table>

<p><strong>索引（Index）</strong></p>

<ul>
  <li><strong>Elasticsearch</strong>:
    <ul>
      <li>一个 <strong>索引（Index）</strong> 是 Elasticsearch 用来存储和组织文档的单位。每个索引包含多个文档，类似于数据库的表。索引通常用于对数据进行分区和存储。</li>
      <li><strong>作用</strong>：类似于数据库中的“表”，它定义了存储数据的结构、映射规则（数据类型等）和分片等。</li>
    </ul>
  </li>
  <li><strong>MongoDB</strong>:
    <ul>
      <li><strong>集合（Collection）</strong>：MongoDB 中的集合类似于 Elasticsearch 的索引。集合是 MongoDB 存储文档（数据）的容器。每个集合包含多个文档，文档类似于一行数据。</li>
    </ul>
  </li>
  <li><strong>MySQL</strong>:
    <ul>
      <li><strong>表（Table）</strong>：在 MySQL 中，表是数据的存储单位。每个表由多行数据组成，每一行包含多个列。表中的每一行是一个记录。</li>
    </ul>
  </li>
</ul>

<p><strong>文档（Document）</strong></p>

<ul>
  <li><strong>Elasticsearch</strong>:
    <ul>
      <li><strong>文档（Document）</strong> 是 Elasticsearch 存储的基本数据单位，类似于 MongoDB 中的文档或者 MySQL 中的行。每个文档都是一个 JSON 对象，表示一个完整的记录。一个文档包含多个字段（类似于列）。</li>
    </ul>
  </li>
  <li><strong>MongoDB</strong>:
    <ul>
      <li><strong>文档（Document）</strong>：MongoDB 中的文档是基本的数据单元，它们是以 BSON 格式（类似于 JSON）存储的。每个文档可以包含多个字段（类似于表的列），而且字段类型是动态的，可以根据需要存储不同的结构。</li>
    </ul>
  </li>
  <li><strong>MySQL</strong>:
    <ul>
      <li><strong>行（Row）</strong>：MySQL 中的每一行代表一个记录。行中的每一列对应表的字段。与 Elasticsearch 的文档类似，MySQL 的一行代表了一个完整的数据记录。</li>
    </ul>
  </li>
</ul>

<p><strong>字段（Field）</strong></p>

<ul>
  <li><strong>Elasticsearch</strong>:
    <ul>
      <li><strong>字段（Field）</strong> 是文档中的一部分，存储特定的值或属性。每个字段都有一个数据类型（如字符串、整数、日期等），并且支持不同的搜索、排序和聚合操作。</li>
    </ul>
  </li>
  <li><strong>MongoDB</strong>:
    <ul>
      <li><strong>字段（Field）</strong>：每个 MongoDB 文档由多个字段组成，字段是数据的基本单元。字段可以是简单的数值或复杂的嵌套结构。字段类似于数据库表中的列。</li>
    </ul>
  </li>
  <li><strong>MySQL</strong>:
    <ul>
      <li><strong>列（Column）</strong>：MySQL 中的列表示表的字段。每个列有固定的数据类型和约束（如 NOT NULL、UNIQUE 等）。</li>
    </ul>
  </li>
</ul>

<p><strong>分片（Shard）</strong></p>

<ul>
  <li><strong>Elasticsearch</strong>:
    <ul>
      <li><strong>分片（Shard）</strong> 是 Elasticsearch 中用于分布式存储和处理的单位。每个索引可以分为多个分片，分片可以存储在集群中的不同节点上，从而提高可扩展性和并发处理能力。</li>
    </ul>
  </li>
  <li><strong>MongoDB &amp; MySQL</strong>:
    <ul>
      <li>MongoDB 和 MySQL 都没有直接类似于分片的概念（尽管 MongoDB 支持分片）。但是，MongoDB 的集合和 MySQL 的表也可以在多个节点上分布和存储数据，尤其是在需要水平扩展的场景中。</li>
    </ul>
  </li>
</ul>

<p><strong>集群（Cluster）</strong></p>

<ul>
  <li><strong>Elasticsearch</strong>:
    <ul>
      <li><strong>集群（Cluster）</strong> 是 Elasticsearch 中由多个节点组成的一个集合。集群中的节点共享数据，并共同完成数据的分片和复制任务，确保系统的高可用性和扩展性。</li>
    </ul>
  </li>
  <li><strong>MongoDB &amp; MySQL</strong>:
    <ul>
      <li>MongoDB 和 MySQL 都有支持分布式架构的功能，MongoDB 使用 <strong>副本集（Replica Set）</strong> 和 <strong>分片（Sharding）</strong> 机制来实现数据的高可用性和横向扩展。而 MySQL 可以通过 <strong>主从复制（Master-Slave Replication）</strong> 或 <strong>分区表（Partitioning）</strong> 来实现类似的功能。</li>
    </ul>
  </li>
</ul>

<p><strong>总结</strong></p>

<ul>
  <li>Elasticsearch 更侧重于<strong>全文搜索</strong>和<strong>大数据分析</strong>，并且使用 <strong>索引（Index）</strong> 来管理文档（Document），它非常适合用于快速查询和分析大量的非结构化数据（如日志、文本等）。</li>
  <li>MongoDB 和 MySQL 则是传统的数据库，MongoDB 是一个文档型数据库，MySQL 是一个关系型数据库。MongoDB 使用<strong>集合（Collection）</strong>存储文档数据，MySQL 使用<strong>表（Table）</strong>存储数据。</li>
</ul>

<p>举个例子：</p>

<p>假设你有一个用户信息的表，存储在 MySQL 中，结构如下：</p>
<ul>
  <li><strong>表</strong>：<code class="language-plaintext highlighter-rouge">users</code>
    <ul>
      <li><strong>字段</strong>：<code class="language-plaintext highlighter-rouge">user_id</code>（主键），<code class="language-plaintext highlighter-rouge">name</code>，<code class="language-plaintext highlighter-rouge">email</code>，<code class="language-plaintext highlighter-rouge">created_at</code></li>
    </ul>
  </li>
</ul>

<p>在 Elasticsearch 中，你可以使用 <strong>索引（Index）</strong> 来存储类似的文档数据，结构如下：</p>
<ul>
  <li><strong>索引</strong>：<code class="language-plaintext highlighter-rouge">users</code>
    <ul>
      <li><strong>文档</strong>：每个文档代表一个用户，包含类似字段：<code class="language-plaintext highlighter-rouge">user_id</code>，<code class="language-plaintext highlighter-rouge">name</code>，<code class="language-plaintext highlighter-rouge">email</code>，<code class="language-plaintext highlighter-rouge">created_at</code>。</li>
    </ul>
  </li>
</ul>

<p>对于 MongoDB，你的 <strong>集合（Collection）</strong> 也可以存储这些数据，每个 <strong>文档（Document）</strong> 也包含这些字段。</p>

<h2 id="准备工作">准备工作</h2>

<p>引入依赖：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>co.elastic.clients<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>elasticsearch-java<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>8.10.4<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>com.fasterxml.jackson.core<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>jackson-databind<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>2.12.3<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>配置ES属性：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">custom</span><span class="pi">:</span>
  <span class="na">elasticsearch</span><span class="pi">:</span>
    <span class="c1"># ES 服务端的用户名，默认值是 "elastic"。这是连接到 Elasticsearch 的认证凭证。</span>
    <span class="na">UserName</span><span class="pi">:</span> <span class="s">${ES_USERNAME:elastic}</span>

    <span class="c1"># ES 服务端的密码，默认值是 "*"。这是连接到 Elasticsearch 的认证凭证。</span>
    <span class="na">Password</span><span class="pi">:</span> <span class="s">${ES_PASSWORD:*}</span>

    <span class="c1"># Elasticsearch 服务端地址，默认值是 "*:9200"。可以指定多个地址，以逗号分隔，如果是集群模式，配置多个节点地址以保证高可用。</span>
    <span class="na">address</span><span class="pi">:</span> <span class="s">${ES_ADDR:*:9200}</span>

    <span class="c1"># 网络链接协议，默认为 "http"。可以选择 "http" 或 "https"。</span>
    <span class="na">schema</span><span class="pi">:</span> <span class="s">${ES_SCHEMA:http}</span>

    <span class="c1"># 连接超时时间，单位是毫秒。此配置决定了客户端连接到 Elasticsearch 服务器时的最大等待时间。默认 6000 毫秒，即 6 秒。</span>
    <span class="na">connectTimeout</span><span class="pi">:</span> <span class="m">6000</span>

    <span class="c1"># Socket 连接超时时间，单位是毫秒。这个配置用于规定连接建立后，接收数据时的超时限制，默认 6000 毫秒。</span>
    <span class="na">socketTimeout</span><span class="pi">:</span> <span class="m">6000</span>

    <span class="c1"># 最大连接数，默认 100。设置连接池中所有连接的最大数量。如果连接数达到最大值，其他请求会等待，直到有连接可用。</span>
    <span class="na">maxConnectNum</span><span class="pi">:</span> <span class="m">100</span>

    <span class="c1"># 每个路由（每个 Elasticsearch 集群节点）允许的最大连接数，默认 100。这个配置用于控制与集群内单个节点的连接数。</span>
    <span class="na">maxConnectPerRoute</span><span class="pi">:</span> <span class="m">100</span>
</code></pre></div></div>

<p>配置连接时效：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.http.HttpResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.impl.client.DefaultConnectionKeepAliveStrategy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.protocol.HttpContext</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="c1">// 自定义 KeepAlive 时限策略</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomConnectionKeepAliveStrategy</span> <span class="kd">extends</span> <span class="nc">DefaultConnectionKeepAliveStrategy</span> <span class="o">{</span>

    <span class="c1">// 创建一个实例，确保整个应用中只有一个实例</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">CustomConnectionKeepAliveStrategy</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CustomConnectionKeepAliveStrategy</span><span class="o">();</span>

    <span class="c1">// 私有构造方法，确保类的实例只通过上述静态成员访问</span>
    <span class="kd">private</span> <span class="nf">CustomConnectionKeepAliveStrategy</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 最大 KeepAlive 的时间（分钟）
     * &lt;p&gt;
     * 这里默认为 10 分钟，可以根据实际情况设置。该值用于控制 HTTP 连接保持的最长时间。
     * 如果客户端机器的 TCP 连接数处于 TIME_WAIT 状态过多，适当增加此值可以避免频繁关闭连接。
     * &lt;/p&gt;
     */</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="no">MAX_KEEP_ALIVE_MINUTES</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

    <span class="cm">/**
     * 重写父类的 `getKeepAliveDuration` 方法
     * &lt;p&gt;
     * 该方法决定了 HTTP 连接保持的时长（毫秒）。如果父类返回负值（表示无限期保持连接），
     * 将其替换为自定义的最大保持时长（10 分钟）。
     * &lt;/p&gt;
     *
     * @param response HTTP 响应对象
     * @param context HTTP 上下文
     * @return 连接保持的时长（毫秒）
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getKeepAliveDuration</span><span class="o">(</span><span class="nc">HttpResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HttpContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 调用父类的实现，获取默认的 Keep-Alive 时长</span>
        <span class="kt">long</span> <span class="n">keepAliveDuration</span> <span class="o">=</span> <span class="kd">super</span><span class="o">.</span><span class="na">getKeepAliveDuration</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">context</span><span class="o">);</span>

        <span class="c1">// 如果父类返回的是负值（表示连接应该无限期保持）</span>
        <span class="c1">// 则将其替换为我们自定义的最大保持时长（10 分钟）</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">keepAliveDuration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MINUTES</span><span class="o">.</span><span class="na">toMillis</span><span class="o">(</span><span class="no">MAX_KEEP_ALIVE_MINUTES</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 返回父类获取的时长</span>
        <span class="k">return</span> <span class="n">keepAliveDuration</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>创建ES连接：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">co.elastic.clients.elasticsearch.ElasticsearchClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">co.elastic.clients.json.jackson.JacksonJsonpMapper</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">co.elastic.clients.transport.ElasticsearchTransport</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">co.elastic.clients.transport.rest_client.RestClientTransport</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.HttpHost</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.auth.AuthScope</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.auth.UsernamePasswordCredentials</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.client.CredentialsProvider</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.http.impl.client.BasicCredentialsProvider</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.elasticsearch.client.RestClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.elasticsearch.client.RestClientBuilder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="cm">/**
 * 配置类，用于初始化与 Elasticsearch 集群的连接配置。
 * &lt;p&gt;
 * 该类通过 Spring 配置机制，读取外部配置文件中的相关设置，创建并配置一个 {@link ElasticsearchClient} 实例。
 * 它自定义了连接超时、认证信息、最大连接数等，并配置了连接池管理与连接保活策略。
 * &lt;/p&gt;
 */</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ElasticSearchConfig</span> <span class="o">{</span>

    <span class="cm">/** 协议，例如 "http" 或 "https" */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.schema:http}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">schema</span><span class="o">;</span>

    <span class="cm">/** Elasticsearch 集群地址，多个地址用逗号分隔 */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.address}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">address</span><span class="o">;</span>

    <span class="cm">/** 连接超时时间，单位为毫秒 */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.connectTimeout}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">connectTimeout</span><span class="o">;</span>

    <span class="cm">/** Socket 连接超时时间，单位为毫秒 */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.socketTimeout}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">socketTimeout</span><span class="o">;</span>

    <span class="cm">/** 最大连接数 */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.maxConnectNum}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxConnectNum</span><span class="o">;</span>

    <span class="cm">/** 最大路由连接数，每个路由的最大连接数 */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.maxConnectPerRoute}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">maxConnectPerRoute</span><span class="o">;</span>

    <span class="cm">/** Elasticsearch 用户名，用于 Basic Authentication */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.UserName}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">userName</span><span class="o">;</span>

    <span class="cm">/** Elasticsearch 密码，用于 Basic Authentication */</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${custom.elasticsearch.Password}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

    <span class="cm">/**
     * 创建并配置一个 {@link ElasticsearchTransport} 实例。
     * &lt;p&gt;
     * 本方法通过 Spring 注解 {@link Bean} 来定义一个 Bean，供 Spring 管理。
     * 它配置了 Elasticsearch 集群的连接信息，包括协议、地址、认证信息、连接池和超时设置。
     * &lt;/p&gt;
     *
     * @return 配置好的 {@link ElasticsearchTransport} 实例
     */</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ElasticsearchTransport</span> <span class="nf">getElasticsearchTransport</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 将多个 Elasticsearch 集群地址拆分为 HttpHost 数组</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">hostList</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
        <span class="nc">HttpHost</span><span class="o">[]</span> <span class="n">httpHost</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">hostList</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="n">addr</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">host</span> <span class="o">=</span> <span class="n">addr</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>  <span class="c1">// 提取主机部分</span>
            <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span> <span class="n">addr</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>  <span class="c1">// 提取端口部分</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">HttpHost</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="n">schema</span><span class="o">);</span> <span class="c1">// 构建 HttpHost 对象</span>
        <span class="o">}).</span><span class="na">toArray</span><span class="o">(</span><span class="nc">HttpHost</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>

        <span class="c1">// 设置 Basic Authentication 认证</span>
        <span class="kd">final</span> <span class="nc">CredentialsProvider</span> <span class="n">credentialsProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BasicCredentialsProvider</span><span class="o">();</span>
        <span class="n">credentialsProvider</span><span class="o">.</span><span class="na">setCredentials</span><span class="o">(</span><span class="nc">AuthScope</span><span class="o">.</span><span class="na">ANY</span><span class="o">,</span> <span class="k">new</span> <span class="nc">UsernamePasswordCredentials</span><span class="o">(</span><span class="n">userName</span><span class="o">,</span> <span class="n">password</span><span class="o">));</span>

        <span class="c1">// 创建 RestClient 构建器，配置连接超时和 Socket 超时</span>
        <span class="nc">RestClientBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="nc">RestClient</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="n">httpHost</span><span class="o">).</span><span class="na">setRequestConfigCallback</span><span class="o">(</span><span class="n">requestConfigBuilder</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 配置连接和 Socket 超时</span>
            <span class="n">requestConfigBuilder</span><span class="o">.</span><span class="na">setConnectTimeout</span><span class="o">(</span><span class="n">connectTimeout</span><span class="o">);</span>
            <span class="n">requestConfigBuilder</span><span class="o">.</span><span class="na">setSocketTimeout</span><span class="o">(</span><span class="n">socketTimeout</span><span class="o">);</span>
            <span class="n">requestConfigBuilder</span><span class="o">.</span><span class="na">setConnectionRequestTimeout</span><span class="o">(</span><span class="n">socketTimeout</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">requestConfigBuilder</span><span class="o">;</span>
        <span class="o">}).</span><span class="na">setHttpClientConfigCallback</span><span class="o">(</span><span class="n">httpClientBuilder</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// 禁用认证缓存，设置最大连接数和连接保活策略</span>
            <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">disableAuthCaching</span><span class="o">();</span>  <span class="c1">// 禁用认证缓存</span>
            <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">setKeepAliveStrategy</span><span class="o">(</span><span class="nc">CustomConnectionKeepAliveStrategy</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>  <span class="c1">// 设置保活策略</span>
            <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">setMaxConnTotal</span><span class="o">(</span><span class="n">maxConnectNum</span><span class="o">);</span>  <span class="c1">// 设置最大连接数</span>
            <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">setMaxConnPerRoute</span><span class="o">(</span><span class="n">maxConnectPerRoute</span><span class="o">);</span>  <span class="c1">// 设置每个路由的最大连接数</span>
            <span class="c1">// 显式调用方法来添加拦截器</span>
            <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">addInterceptorFirst</span><span class="o">((</span><span class="nc">HttpRequestInterceptor</span><span class="o">)</span> <span class="k">new</span> <span class="nc">RequestLogger</span><span class="o">());</span>  <span class="c1">// 添加请求拦截器</span>
            <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">addInterceptorLast</span><span class="o">((</span><span class="nc">HttpResponseInterceptor</span><span class="o">)</span> <span class="k">new</span> <span class="nc">RequestLogger</span><span class="o">());</span> <span class="c1">// 添加响应拦截器</span>
            <span class="c1">// 设置认证信息</span>
            <span class="k">return</span> <span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">setDefaultCredentialsProvider</span><span class="o">(</span><span class="n">credentialsProvider</span><span class="o">);</span>
        <span class="o">});</span>

        <span class="c1">// 构建 RestClient 实例</span>
        <span class="nc">RestClient</span> <span class="n">restClient</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>

        <span class="c1">// 创建 ElasticsearchTransport</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">RestClientTransport</span><span class="o">(</span><span class="n">restClient</span><span class="o">,</span> <span class="k">new</span> <span class="nc">JacksonJsonpMapper</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 创建一个 {@link ElasticsearchClient} 实例。
     * @param transport 实现 Elasticsearch 特性的传输层
     * @return
     */</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ElasticsearchClient</span> <span class="nf">docqaElasticsearchClient</span><span class="o">(</span><span class="nc">ElasticsearchTransport</span> <span class="n">transport</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ElasticsearchClient</span><span class="o">(</span><span class="n">transport</span><span class="o">);</span>  <span class="c1">// 返回配置好的 ElasticsearchClient 实例</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 创建一个 {@link ElasticsearchAsyncClient} 实例。
     * @param transport 实现 Elasticsearch 特性的传输层
     * @return
     */</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ElasticsearchAsyncClient</span> <span class="nf">docqaElasticsearchAsyncClient</span><span class="o">(</span><span class="nc">ElasticsearchTransport</span> <span class="n">transport</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ElasticsearchAsyncClient</span><span class="o">(</span><span class="n">transport</span><span class="o">);</span>  <span class="c1">// 返回配置好的 ElasticsearchClient 实例</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">RestClient</code>这个类主要是用作于与服务端IP以及端口的配置，在其的<code class="language-plaintext highlighter-rouge">builder()</code>方法可以设置登陆权限的账号密码、连接时长等等。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">RestClientTransport</code></strong> 是<code class="language-plaintext highlighter-rouge">Jackson</code>映射器创建传输。建立客户端与服务端之间的连接传输数据。这是在创建<code class="language-plaintext highlighter-rouge">ElasticsearchClient</code>需要的参数，而创建<code class="language-plaintext highlighter-rouge">RestClientTransport</code>就需要上面创建的<code class="language-plaintext highlighter-rouge">RestClient</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ElasticsearchClient</code></strong> 是 Elasticsearch 高级客户端，基于 <code class="language-plaintext highlighter-rouge">RestClientTransport</code> 构建，它提供了更为便捷的 API，帮助开发者通过 Java 代码与 Elasticsearch 进行交互。提供更加抽象和封装的接口，允许执行各种 Elasticsearch 操作（如索引、搜索、删除等）。基于 <code class="language-plaintext highlighter-rouge">RestClientTransport</code>，它将底层的 HTTP 请求转换为更高层的 Elasticsearch 操作。支持同步和异步操作。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ElasticsearchAsyncClient</code></strong> 是 <code class="language-plaintext highlighter-rouge">ElasticsearchClient</code> 的异步版本，它用于执行异步的 Elasticsearch 操作，支持非阻塞 I/O 操作。</li>
  <li>提供与 <code class="language-plaintext highlighter-rouge">ElasticsearchClient</code> 类似的功能，但所有请求和响应操作都不阻塞线程。适用于需要高吞吐量或并发请求的场景，避免了线程的阻塞。异步操作通常会返回一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 对象，允许调用者在操作完成时获取结果。</li>
</ul>

<h2 id="打开日志">打开日志</h2>

<p>新建一个日志打印类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="kd">class</span> <span class="nc">RequestLogger</span> <span class="kd">implements</span> <span class="nc">HttpRequestInterceptor</span><span class="o">,</span> <span class="nc">HttpResponseInterceptor</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="nc">HttpRequest</span> <span class="n">request</span><span class="o">,</span> <span class="nc">HttpContext</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Log request details</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"请求 URI: "</span> <span class="o">+</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestLine</span><span class="o">().</span><span class="na">getUri</span><span class="o">());</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"请求方法： "</span> <span class="o">+</span> <span class="n">request</span><span class="o">.</span><span class="na">getRequestLine</span><span class="o">().</span><span class="na">getMethod</span><span class="o">());</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"请求标头："</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getAllHeaders</span><span class="o">()));</span>

        <span class="c1">// 获取请求体内容</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">request</span> <span class="k">instanceof</span> <span class="nc">HttpEntityEnclosingRequest</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">HttpEntity</span> <span class="n">entity</span> <span class="o">=</span> <span class="o">((</span><span class="nc">HttpEntityEnclosingRequest</span><span class="o">)</span> <span class="n">request</span><span class="o">).</span><span class="na">getEntity</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entity</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 缓存请求体内容</span>
                <span class="kt">byte</span><span class="o">[]</span> <span class="n">entityContent</span> <span class="o">=</span> <span class="n">entityToBytes</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">entityContent</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">entityContent</span><span class="o">);</span>
                    <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"请求体："</span> <span class="o">+</span> <span class="n">body</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="nc">HttpResponse</span> <span class="n">response</span><span class="o">,</span> <span class="nc">HttpContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// Log response details</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"响应状态： "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">getStatusLine</span><span class="o">());</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">"响应标头： "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getAllHeaders</span><span class="o">()));</span>
        <span class="c1">// 获取响应体内容</span>
        <span class="nc">HttpEntity</span> <span class="n">entity</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getEntity</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">entity</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 缓存响应体内容</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">entityContent</span> <span class="o">=</span> <span class="n">entityToBytes</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">entityContent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">entityContent</span><span class="o">);</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"响应体："</span> <span class="o">+</span> <span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 将 HttpEntity 内容转换为字节数组
     * @param entity HttpEntity
     * @return 字节数组
     */</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">entityToBytes</span><span class="o">(</span><span class="nc">HttpEntity</span> <span class="n">entity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">entity</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">content</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
             <span class="nc">ByteArrayOutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bytesRead</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">out</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 处理异常，返回null或者其他默认值</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>添加到<code class="language-plaintext highlighter-rouge">RestClientBuilder</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 显式调用方法来添加拦截器</span>
<span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">addInterceptorFirst</span><span class="o">((</span><span class="nc">HttpRequestInterceptor</span><span class="o">)</span> <span class="k">new</span> <span class="nc">RequestLogger</span><span class="o">());</span>  <span class="c1">// 添加请求拦截器</span>
<span class="n">httpClientBuilder</span><span class="o">.</span><span class="na">addInterceptorLast</span><span class="o">((</span><span class="nc">HttpResponseInterceptor</span><span class="o">)</span> <span class="k">new</span> <span class="nc">RequestLogger</span><span class="o">());</span> <span class="c1">// 添加响应拦截器</span>
</code></pre></div></div>

<p>打开调试日志：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">logging</span><span class="pi">:</span>
  <span class="na">level</span><span class="pi">:</span>
    <span class="na">org.elasticsearch.client</span><span class="pi">:</span> <span class="s">DEBUG</span>
    <span class="na">com.*.config.RequestLogger</span><span class="pi">:</span> <span class="s">DEBUG</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">com.*.config.RequestLogger</code>是日志打印类的类名。</p>

<h2 id="使用">使用</h2>

<h3 id="插入">插入</h3>

<p>通过 HTTP 请求插入数据：</p>

<p>要通过 HTTP 向 Elasticsearch 插入数据，通常使用 <code class="language-plaintext highlighter-rouge">PUT</code> 或 <code class="language-plaintext highlighter-rouge">POST</code> 请求。以下是通过 HTTP 请求插入数据的步骤和示例。</p>

<p><strong>插入数据的 HTTP 请求方式</strong></p>

<ul>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">POST</code> 请求</strong>：如果不指定文档 ID，Elasticsearch 会自动生成一个 ID。</li>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">PUT</code> 请求</strong>：如果指定文档 ID，Elasticsearch 会使用该 ID 插入数据。如果文档已存在，则会更新该文档。</li>
</ul>

<p><strong>HTTP 请求的基本格式</strong></p>

<ul>
  <li><strong>请求 URL</strong>：
    <ul>
      <li>格式：<code class="language-plaintext highlighter-rouge">http://&lt;hostname&gt;:&lt;port&gt;/&lt;index&gt;/_doc/&lt;document_id&gt;</code></li>
      <li>示例：<code class="language-plaintext highlighter-rouge">http://localhost:9200/products/_doc/1</code></li>
    </ul>
  </li>
  <li>
    <p><strong>请求头</strong>：<code class="language-plaintext highlighter-rouge">Content-Type: application/json</code>：指定请求体的格式为 JSON。</p>
  </li>
  <li><strong>请求体</strong>：以 JSON 格式提供文档的内容。</li>
</ul>

<p><strong>示例：通过 HTTP 插入数据</strong></p>

<p>假设你要向 <code class="language-plaintext highlighter-rouge">products</code> 索引插入一个文档，文档的内容包括 SKU、产品名称和价格。</p>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">POST</code> 插入数据（自动生成 ID）</strong></p>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST http://localhost:9200/products/_doc
Content-Type: application/json

{
  "sku": "bk-1",
  "name": "City bike",
  "price": 123.0
}
</span></code></pre></div></div>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">PUT</code> 插入数据（指定 ID）</strong></p>
<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PUT http://localhost:9200/products/_doc/bk-1
Content-Type: application/json

{
  "sku": "bk-1",
  "name": "City bike",
  "price": 123.0
}
</span></code></pre></div></div>

<p>在这两个示例中，<code class="language-plaintext highlighter-rouge">products</code> 是目标索引，<code class="language-plaintext highlighter-rouge">_doc</code> 是文档类型，<code class="language-plaintext highlighter-rouge">bk-1</code> 是文档的 ID（在第二个示例中指定），文档的内容是 JSON 格式。</p>

<hr />

<p>通过Java插入数据：</p>

<p>构建请求最直接的方法是使用 Fluent DSL：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">sku</span><span class="o">,</span> <span class="nc">String</span> <span class="n">cityBike</span><span class="o">,</span> <span class="kt">double</span> <span class="n">v</span><span class="o">)</span> <span class="o">{}</span>
<span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>

<span class="nc">IndexResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>           <span class="c1">// 设置索引名为 "products"</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>           <span class="c1">// 设置文档的 ID 为 `product.sku()`（即 "bk-1"），可选</span>
        <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)</span>           <span class="c1">// 设置文档内容为 `product` 对象</span>
<span class="o">);</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Indexed with version "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
</code></pre></div></div>

<p>还可以将使用 DSL 创建的对象分配给变量。Java API Client 类有一个静态方法，该方法使用 DSL 语法创建一个对象。<code class="language-plaintext highlighter-rouge">of()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
        <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)</span>
<span class="o">);</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</code></pre></div></div>

<p>使用经典构建器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">build</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;()</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"product"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
        <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">build</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">esClient.index(...)</code> 是用来执行文档索引操作的代码。</p>

<p><code class="language-plaintext highlighter-rouge">.index("products")</code>：指定将数据索引到名为 <code class="language-plaintext highlighter-rouge">"products"</code> 的索引中。索引是 Elasticsearch 中数据的存储单元，相当于数据库中的表。</p>

<p><code class="language-plaintext highlighter-rouge">.id(product.sku())</code>：指定该文档的 ID，通常用于唯一标识每个文档。这里使用 <code class="language-plaintext highlighter-rouge">product.sku()</code> 来设置 ID，这意味着文档的 ID 是商品的 SKU（如 <code class="language-plaintext highlighter-rouge">"bk-1"</code>）。</p>

<p><code class="language-plaintext highlighter-rouge">.document(product)</code>：指定将要存储的文档内容。<code class="language-plaintext highlighter-rouge">product</code> 对象被直接传递给 <code class="language-plaintext highlighter-rouge">document()</code> 方法，Elasticsearch 会自动将其转化为适当的 JSON 格式存储。</p>

<p><code class="language-plaintext highlighter-rouge">IndexResponse</code> 是 Elasticsearch 返回的响应对象，包含有关文档索引操作的详细信息。</p>

<p><code class="language-plaintext highlighter-rouge">response.version()</code>：获取索引操作的版本号。每当文档被创建或更新时，Elasticsearch 会为该文档分配一个版本号，用于追踪文档的变更。这里的 <code class="language-plaintext highlighter-rouge">version</code> 是索引的版本号，可以用于控制并发和版本管理。</p>

<p>使用异步客户端：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">IndexResponse</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">esAsyncClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">finalProduct2</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
        <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">finalProduct2</span><span class="o">)</span>
<span class="o">);</span>
<span class="n">future</span><span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">response1</span><span class="o">,</span> <span class="n">exception</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">exception</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"索引失败"</span><span class="o">,</span> <span class="n">exception</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"使用 version 编制索引 "</span> <span class="o">+</span> <span class="n">response1</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<p>完整代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">co.elastic.clients.elasticsearch.ElasticsearchAsyncClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">co.elastic.clients.elasticsearch.ElasticsearchClient</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">co.elastic.clients.elasticsearch.core.IndexRequest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">co.elastic.clients.elasticsearch.core.IndexResponse</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.annotation.Resource</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.runner.RunWith</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.test.context.SpringBootTest</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.test.context.junit4.SpringRunner</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.CompletableFuture</span><span class="o">;</span>

<span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">classes</span> <span class="o">=</span> <span class="o">*</span><span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Slf4j</span>
<span class="kd">class</span> <span class="err">*</span><span class="nc">ApplicationTests</span> <span class="o">{</span>
    <span class="nd">@Resource</span>
    <span class="kd">private</span> <span class="nc">ElasticsearchClient</span> <span class="n">esClient</span><span class="o">;</span>

    <span class="nd">@Resource</span>
    <span class="kd">private</span> <span class="nc">ElasticsearchAsyncClient</span> <span class="n">esAsyncClient</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">contextLoads</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="n">record</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">sku</span><span class="o">,</span> <span class="nc">String</span> <span class="n">cityBike</span><span class="o">,</span> <span class="kt">double</span> <span class="n">v</span><span class="o">)</span> <span class="o">{}</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>
        <span class="c1">// * 使用 Fluent DSL</span>
        <span class="nc">Product</span> <span class="n">finalProduct1</span> <span class="o">=</span> <span class="n">product</span><span class="o">;</span>
        <span class="nc">IndexResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>           <span class="c1">// 设置索引名为 "products"</span>
                <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">finalProduct1</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>           <span class="c1">// 设置文档的 ID 为 `product.sku()`（即 "bk-1"）</span>
                <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">finalProduct1</span><span class="o">)</span>           <span class="c1">// 设置文档内容为 `product` 对象</span>
        <span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"使用 version 编制索引 "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

        <span class="c1">// * 使用 DSL 创建的对象分配给变量</span>
        <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-2"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="mf">124.0</span><span class="o">);</span>
        <span class="nc">Product</span> <span class="n">finalProduct</span> <span class="o">=</span> <span class="n">product</span><span class="o">;</span>
        <span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">finalProduct</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
                <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">finalProduct</span><span class="o">)</span>
        <span class="o">);</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"使用 version 编制索引 "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

        <span class="c1">// * 使用经典构建器</span>
        <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-3"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="mf">125.0</span><span class="o">);</span>
        <span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">build</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;()</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
                <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>

        <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">build</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"使用 version 编制索引 "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>

        <span class="c1">// * 使用异步客户端</span>
        <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-4"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="mf">126.0</span><span class="o">);</span>
        <span class="nc">Product</span> <span class="n">finalProduct2</span> <span class="o">=</span> <span class="n">product</span><span class="o">;</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">IndexResponse</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">esAsyncClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">finalProduct2</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
                <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">finalProduct2</span><span class="o">)</span>
        <span class="o">);</span>
        <span class="n">future</span><span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">response1</span><span class="o">,</span> <span class="n">exception</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">exception</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"索引失败"</span><span class="o">,</span> <span class="n">exception</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"使用 version 编制索引 "</span> <span class="o">+</span> <span class="n">response1</span><span class="o">.</span><span class="na">version</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">withJson</code></strong></p>

<p>在使用 Elasticsearch 进行应用程序开发过程中，一个常见的工作流程是使用 Kibana 开发人员控制台以交互方式准备和测试查询、聚合、索引映射和其他复杂的 API 调用。这将生成您可能希望在应用程序中使用的有效 JSON 代码段。</p>

<p>由于将这些 JSON 代码片段转换为 Java 代码可能非常耗时且容易出错，因此 Java API 客户端中的大多数数据类都可以从 JSON 文本加载：对象生成器具有从原始 JSON 填充生成器的方法。这还允许您将动态加载的 JSON 与对象的编程构造相结合。``</p>

<p>在后台，这些方法调用对象的反序列化器。因此，JSON 文本的结构和值类型必须正确适用于目标数据结构。使用可保持 Java API Client 的强类型保证。</p>

<p><strong>从资源文件加载索引定义</strong></p>

<p>考虑一个包含索引定义的资源文件：<code class="language-plaintext highlighter-rouge">some-index.json</code></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"mappings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"field1"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"text"</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>可以根据该定义创建索引，如下所示：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span>
    <span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"some-index.json"</span><span class="o">);</span> 

<span class="nc">CreateIndexRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="nc">CreateIndexRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"some-index"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">withJson</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> 
<span class="o">);</span>

<span class="kt">boolean</span> <span class="n">created</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">indices</span><span class="o">().</span><span class="na">create</span><span class="o">(</span><span class="n">req</span><span class="o">).</span><span class="na">acknowledged</span><span class="o">();</span>
</code></pre></div></div>

<p>打开 JSON 资源文件的输入流。使用资源文件内容填充索引创建请求。</p>

<p><strong>从 JSON 文件摄取文档</strong></p>

<p>同样，可以从数据文件中读取要存储在 Elasticsearch 中的文档：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">FileReader</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="n">dataDir</span><span class="o">,</span> <span class="s">"document-1.json"</span><span class="o">));</span>

<span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">JsonData</span><span class="o">&gt;</span> <span class="n">req</span><span class="o">;</span> 

<span class="n">req</span> <span class="o">=</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"some-index"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">withJson</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
<span class="o">);</span>

<span class="n">client</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>
</code></pre></div></div>

<p>当你在 <code class="language-plaintext highlighter-rouge">IndexRequest</code> 中使用泛型（比如 <code class="language-plaintext highlighter-rouge">JsonData</code>），<code class="language-plaintext highlighter-rouge">withJson()</code> 方法会使用这个类型来处理数据，确保文件内容符合这个数据类型的格式，并最终被索引到 Elasticsearch 中。</p>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">withPipeline</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">withPipeline(String pipeline)</code> 是 <code class="language-plaintext highlighter-rouge">IndexRequest</code> 类中的一个方法，它用于指定在将文档索引到 Elasticsearch 之前应用的 <strong>管道（Pipeline）</strong>。</p>

<p>Elasticsearch 的 <strong>管道</strong> 是一个处理数据的功能，它可以在数据被索引前对文档进行转换、处理或者清洗等操作。通过管道，用户可以对文档进行更复杂的操作，例如：</p>

<ul>
  <li><strong>数据格式转换</strong>：对文档的字段进行重命名或改变格式。</li>
  <li><strong>数据增强</strong>：根据外部数据来源来修改文档内容。</li>
  <li><strong>验证和清洗</strong>：确保文档数据符合某些标准或者格式。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">withPipeline</code> 方法的作用</strong></p>

<p>该方法将指定的管道名称（管道ID）<strong>与当前的索引请求关联</strong>。这个管道将在文档被索引之前被调用，对文档进行处理。</p>

<p><strong>使用示例</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">&lt;&gt;();</span>
<span class="n">request</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>  <span class="c1">// 设置索引</span>
       <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"product-123"</span><span class="o">)</span>    <span class="c1">// 设置文档 ID</span>
       <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City Bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">))</span>  <span class="c1">// 设置文档内容</span>
       <span class="o">.</span><span class="na">withPipeline</span><span class="o">(</span><span class="s">"my-pipeline"</span><span class="o">);</span>  <span class="c1">// 设置管道，使用 "my-pipeline"</span>
</code></pre></div></div>

<p>在Elasticsearch 8.x 版本中，<code class="language-plaintext highlighter-rouge">withPipeline</code> 改为了 <code class="language-plaintext highlighter-rouge">pipeline</code> 方法。</p>

<hr />

<p><strong>插入详解</strong></p>

<p>操作：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">i</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>           <span class="c1">// 设置索引名为 "products"</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">finalProduct1</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>           <span class="c1">// 设置文档的 ID 为 product.sku()（即 "bk-1"）</span>
        <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">finalProduct1</span><span class="o">)</span>           <span class="c1">// 设置文档内容为 product 对象</span>
<span class="o">);</span>
</code></pre></div></div>

<p>涉及到以下类：</p>

<p><strong>IndexRequest</strong>（<code class="language-plaintext highlighter-rouge">i -&gt; i.index(...)</code>）</p>

<p><code class="language-plaintext highlighter-rouge">IndexRequest</code>是一个封装 Elasticsearch 索引请求的类，包含了目标索引名、文档 ID 和文档内容等信息。它是 <code class="language-plaintext highlighter-rouge">index()</code> 方法的参数。</p>

<p><strong>IndexResponse</strong>（<code class="language-plaintext highlighter-rouge">response</code>）</p>

<p><code class="language-plaintext highlighter-rouge">IndexResponse</code> 是 Elasticsearch 索引操作的响应类。它包含有关索引操作的信息，例如文档的版本号、成功与否、是否进行了刷新等。</p>

<h4 id="indexrequest"><code class="language-plaintext highlighter-rouge">IndexRequest</code></h4>

<p><code class="language-plaintext highlighter-rouge">IndexRequest&lt;TDocument&gt;</code> 是 Elasticsearch 客户端库中的一个类，它用于向指定的 Elasticsearch 索引中 <strong>创建</strong> 或 <strong>更新</strong> 文档。这个类是 Elasticsearch 中的索引操作请求（<code class="language-plaintext highlighter-rouge">index</code> API）的核心部分，用于表示向 Elasticsearch 索引中插入或更新文档的请求。</p>

<p><strong>主要功能</strong></p>

<ul>
  <li><strong>创建文档</strong>：如果指定的文档 ID 在索引中不存在，Elasticsearch 会创建一个新的文档。</li>
  <li><strong>更新文档</strong>：如果指定的文档 ID 已经存在，Elasticsearch 会更新该文档的数据。默认情况下，如果文档已经存在，<code class="language-plaintext highlighter-rouge">index</code> 请求会覆盖原有文档，但你也可以使用一些选项来控制更新方式。</li>
  <li><strong>选择索引</strong>：可以选择目标索引（<code class="language-plaintext highlighter-rouge">index</code>），指定文档的 ID（<code class="language-plaintext highlighter-rouge">id</code>），以及文档的内容（<code class="language-plaintext highlighter-rouge">document</code>）。</li>
  <li><strong>支持 JSON 序列化和反序列化</strong>：文档的内容通常是一个 POJO 对象，Elasticsearch 会自动将 POJO 对象序列化为 JSON 格式，并发送到服务器端。</li>
</ul>

<p>以下是 <code class="language-plaintext highlighter-rouge">IndexRequest&lt;TDocument&gt;</code> 类的常用方法：</p>

<p><strong><code class="language-plaintext highlighter-rouge">index(String index)</code></strong>: 设置文档的目标索引（指定文档存储的索引名）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">&lt;&gt;();</span>
<span class="n">request</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">);</span>  <span class="c1">// 将文档插入到 "products" 索引中</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">id(String id)</code></strong>: 设置文档的 ID。Elasticsearch 使用文档的 ID 来唯一标识文档。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"product-1"</span><span class="o">);</span>  <span class="c1">// 设置文档 ID 为 "product-1"</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">document(TDocument document)</code></strong>: 设置文档的内容。这个内容通常是一个 POJO 对象（比如 <code class="language-plaintext highlighter-rouge">Product</code>），该对象将被自动转换为 JSON 格式。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>
<span class="n">request</span><span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>  <span class="c1">// 将 Product 对象作为文档内容</span>
</code></pre></div></div>

<p><strong>参数</strong>: <code class="language-plaintext highlighter-rouge">TDocument document</code> — 文档内容，可以是任何 POJO 类型或 JSON 数据（需要通过 <code class="language-plaintext highlighter-rouge">JsonpSerializable</code> 序列化）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">opType(IndexRequest.OpType opType)</code></strong>: 设置操作类型。操作类型决定了文档插入的方式：</p>

<p><code class="language-plaintext highlighter-rouge">OpType.CREATE</code>: 如果文档已存在，则会抛出异常。</p>

<p><code class="language-plaintext highlighter-rouge">OpType.INDEX</code>: 默认值，文档存在时会被覆盖。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">opType</span><span class="o">(</span><span class="nc">OpType</span><span class="o">.</span><span class="na">CREATE</span><span class="o">);</span>  <span class="c1">// 如果文档存在，会抛出异常</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">routing(String routing)</code></strong></p>

<p>为文档指定一个路由值。路由用于优化文档在 Elasticsearch 集群中的分布。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">routing</span><span class="o">(</span><span class="s">"user-123"</span><span class="o">);</span>  <span class="c1">// 为文档指定一个路由值 "user-123"</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">version(Long version)</code></strong>: 设置文档的版本号。版本控制用于乐观并发控制，可以确保文档不会在其他进程更新时发生冲突。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="mi">1L</span><span class="o">);</span>  <span class="c1">// 设置版本号为 1</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">versionType(String versionType)</code></strong>：设置版本类型。常见的版本类型包括 <code class="language-plaintext highlighter-rouge">internal</code> 和 <code class="language-plaintext highlighter-rouge">external</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">versionType</span><span class="o">(</span><span class="s">"external"</span><span class="o">);</span>  <span class="c1">// 设置版本类型为 "external"</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">VersionType.Internal</code>（默认）: Elasticsearch 内部的版本控制,文档的版本号由 Elasticsearch 自动生成。</li>
  <li><code class="language-plaintext highlighter-rouge">VersionType.External </code>: 使用外部版本控制系统。在索引文档时，文档的版本由用户提供，而不是由 Elasticsearch 自动管理。</li>
  <li><code class="language-plaintext highlighter-rouge">VersionType.ExternalGte</code>: 该版本类型表示仅在外部版本号大于或等于当前文档的版本时，才允许执行更新操作。它允许更新操作在确保不会覆盖更高版本的数据的情况下执行。</li>
  <li><code class="language-plaintext highlighter-rouge">VersionType.Force</code>：该类型会强制执行操作，忽略版本控制。即使文档版本不匹配，它也会执行索引或更新操作。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">refresh(Refresh refresh)</code></strong>: 设置是否刷新索引，以便可以立即搜索该文档。常用的选项有 <code class="language-plaintext highlighter-rouge">Refresh.TRUE</code>, <code class="language-plaintext highlighter-rouge">Refresh.FALSE</code>, <code class="language-plaintext highlighter-rouge">Refresh.WaitFor</code>。</p>

<p><code class="language-plaintext highlighter-rouge">Refresh.True</code> :在执行完写操作后立即刷新索引，使得文档立即可用于搜索。</p>

<p><code class="language-plaintext highlighter-rouge">Refresh.False</code>(默认值):不进行刷新，文档不会立即对查询可见。索引将不会立即刷新，而是等待默认的刷新周期。</p>

<p><code class="language-plaintext highlighter-rouge">Refresh.WaitFor</code>:执行写操作后，等待一定条件下的刷新，直到索引被刷新（通常是通过异步刷新机制）。这意味着请求将等待直到文档可搜索（但不会立即刷新）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">TRUE</span><span class="o">);</span>  <span class="c1">// 索引操作后立即刷新索引</span>
</code></pre></div></div>

<p>Elasticsearch 默认每 1 秒自动刷新一次索引。当索引中的文档被写入后，这些文档会暂时保存在内存中，直到 Elasticsearch 自动刷新索引。这一默认行为有助于减少过度刷新导致的性能开销。</p>

<p><strong><code class="language-plaintext highlighter-rouge">withJson(JsonData json)</code></strong>：通过 JSON 数据将文档内容传递给索引请求。适用于不使用 POJO 类型的情况。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">JsonData</span> <span class="n">jsonData</span> <span class="o">=</span> <span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"{\"sku\": \"bk-1\", \"cityBike\": \"City bike\", \"v\": 123.0}"</span><span class="o">);</span>
<span class="n">request</span><span class="o">.</span><span class="na">withJson</span><span class="o">(</span><span class="n">jsonData</span><span class="o">);</span>  <span class="c1">// 将 JSON 数据作为文档传递</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">withPipeline(String pipeline)</code></strong>: 设置一个管道，管道用于在文档被索引之前对文档进行处理（例如对数据进行转换）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">request</span><span class="o">.</span><span class="na">withPipeline</span><span class="o">(</span><span class="s">"my-pipeline"</span><span class="o">);</span>  <span class="c1">// 使用管道 "my-pipeline"</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">IndexRequest&lt;TDocument&gt;</code> 是用于向 Elasticsearch 索引中创建或更新文档的核心请求类。它包含了文档的目标索引、文档 ID、文档内容以及其他索引请求的相关参数。常用方法包括设置索引名、文档 ID、文档内容、操作类型（创建或更新）等。</p>

<h4 id="indexresponse"><code class="language-plaintext highlighter-rouge">IndexResponse</code></h4>

<p>在 Elasticsearch Java 客户端中，<code class="language-plaintext highlighter-rouge">IndexResponse</code> 是用于表示文档索引操作响应的对象。它提供了许多方法和字段，用于获取关于索引操作的详细信息。以下是 <code class="language-plaintext highlighter-rouge">IndexResponse</code> 的常用方法和字段的详细说明：</p>

<p><strong>常用字段</strong></p>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">index</code></strong>：表示索引文档所在的索引名。示例值：<code class="language-plaintext highlighter-rouge">"products"</code></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">id</code></strong>：表示文档的唯一标识符（ID）。示例值：<code class="language-plaintext highlighter-rouge">"bk-1"</code></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">version</code></strong>：文档的版本号（一个递增值，表示文档的修改次数）。示例值：<code class="language-plaintext highlighter-rouge">1</code></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">seqNo</code></strong>：表示文档的序列号，用于内部版本控制。示例值：<code class="language-plaintext highlighter-rouge">0</code></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">primaryTerm</code></strong>：表示文档的主分片的主要版本号。示例值：<code class="language-plaintext highlighter-rouge">1</code></p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">result</code></strong>操作结果，表示文档的操作状态，常见的值包括：</p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">"created"</code>: 文档被成功创建。</li>
      <li><code class="language-plaintext highlighter-rouge">"updated"</code>: 文档被成功更新。</li>
      <li><code class="language-plaintext highlighter-rouge">"deleted"</code>: 文档被成功删除</li>
      <li><code class="language-plaintext highlighter-rouge">"not_found"</code>: 在执行操作时，文档不存在。</li>
      <li><code class="language-plaintext highlighter-rouge">"noop"</code>: 没有操作（例如在某些条件下没有对文档进行更改）。</li>
    </ul>
  </li>
</ol>

<p>要获取这些值，可以通过同名方法获取。</p>

<hr />

<h4 id="index"><code class="language-plaintext highlighter-rouge">index()</code></h4>

<p><code class="language-plaintext highlighter-rouge">esClient.index()</code> 方法是 Elasticsearch 客户端中用于执行文档索引操作的核心方法之一。它允许你将文档索引到指定的 Elasticsearch 索引中。</p>

<p><strong>基本的 <code class="language-plaintext highlighter-rouge">index()</code> 方法</strong></p>

<p><strong>参数：</strong></p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">IndexRequest indexRequest</code></strong>：包含索引操作所需的信息，例如索引名、文档 ID、文档数据等。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">RequestOptions</code></strong>：请求的选项，如超时、认证、头信息等（通常为 <code class="language-plaintext highlighter-rouge">RequestOptions.DEFAULT</code>）。</li>
</ul>

<p><strong>返回：</strong> <strong><code class="language-plaintext highlighter-rouge">IndexResponse</code></strong>：返回的响应对象，包含关于索引操作的状态信息，如文档 ID、版本号等。</p>

<p><strong>示例：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span> <span class="n">indexRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"sku"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="s">"price"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>

<span class="nc">IndexResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexRequest</span><span class="o">,</span> <span class="nc">RequestOptions</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document indexed with id: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p><strong>异步 <code class="language-plaintext highlighter-rouge">index()</code> 方法（带 <code class="language-plaintext highlighter-rouge">ActionListener</code>）</strong></p>

<p>Elasticsearch 客户端也支持异步执行索引操作，使用 <code class="language-plaintext highlighter-rouge">ActionListener</code> 来处理异步响应。</p>

<p><strong>参数：</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">IndexRequest indexRequest</code></strong>：请求对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">RequestOptions</code></strong>：请求的配置选项（可选）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ActionListener&lt;IndexResponse&gt;</code></strong>：回调，用于处理异步响应。</li>
</ul>

<p><strong>返回：</strong> 异步操作，不直接返回 <code class="language-plaintext highlighter-rouge">IndexResponse</code>，而是通过回调进行通知。</p>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span> <span class="n">indexRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"sku"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="s">"price"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>

<span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexRequest</span><span class="o">,</span> <span class="nc">RequestOptions</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ActionListener</span><span class="o">&lt;</span><span class="nc">IndexResponse</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onResponse</span><span class="o">(</span><span class="nc">IndexResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document indexed with id: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">index()</code> 方法（ElasticsearchClient 8.x）</strong></p>

<p>在 Elasticsearch 8.x 中，<code class="language-plaintext highlighter-rouge">index()</code> 方法的接口进行了优化，通常采用泛型和 <code class="language-plaintext highlighter-rouge">IndexRequest</code> 构建请求，并返回相应的响应类型。</p>

<p><strong>参数：</strong></p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">IndexRequest indexRequest</code></strong>：请求对象，包含索引名称、文档 ID 和文档内容。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code></strong>：指定要索引的文档类型（通常是自定义的 Java 类）。</li>
</ul>

<p><strong>返回：</strong></p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">IndexResponse</code></strong>：返回的响应对象，包含索引操作的结果。</li>
</ul>

<p><strong>示例：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span> <span class="n">indexRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"sku"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"City bike"</span><span class="o">,</span> <span class="s">"price"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>

<span class="nc">IndexResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexRequest</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document indexed with id: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p><strong>总结：</strong></p>

<p><code class="language-plaintext highlighter-rouge">esClient.index()</code> 方法提供了多种使用方式，主要变体和常用参数如下：</p>
<ul>
  <li><strong>同步 <code class="language-plaintext highlighter-rouge">index()</code> 方法</strong>：通过 <code class="language-plaintext highlighter-rouge">IndexRequest</code> 提交索引请求，返回 <code class="language-plaintext highlighter-rouge">IndexResponse</code>。</li>
  <li><strong>异步 <code class="language-plaintext highlighter-rouge">index()</code> 方法</strong>：通过 <code class="language-plaintext highlighter-rouge">ActionListener</code> 处理异步索引操作。</li>
</ul>

<h3 id="获取">获取</h3>

<p>通过 HTTP 请求执行 Elasticsearch 的 <code class="language-plaintext highlighter-rouge">GET</code> 操作，可以直接向 Elasticsearch 的 REST API 发起请求。</p>

<p><strong>HTTP GET 请求 URL：</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET http://&lt;Elasticsearch-host&gt;:&lt;port&gt;/&lt;index&gt;/_doc/&lt;id&gt;
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Elasticsearch-host&gt;</code>: Elasticsearch 的主机名或 IP 地址（例如 <code class="language-plaintext highlighter-rouge">localhost</code> 或 <code class="language-plaintext highlighter-rouge">10.80.21.121</code>）。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;port&gt;</code>: Elasticsearch 的端口号，默认是 <code class="language-plaintext highlighter-rouge">9200</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;index&gt;</code>: 目标索引的名称。</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;id&gt;</code>: 文档的唯一标识符（ID）。</li>
</ul>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET http://localhost:9200/products/_doc/bk-1
</span></code></pre></div></div>

<p><strong>响应示例（JSON）：</strong></p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bk-1"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"products"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_primary_term"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_seq_no"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_source"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"cityBike"</span><span class="p">:</span><span class="w"> </span><span class="s2">" City bike "</span><span class="p">,</span><span class="w">
    </span><span class="nl">"sku"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bk-1"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"v"</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"found"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">found: true</code></strong> 表示找到了文档。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">_source</code></strong> 包含文档的实际数据。</li>
</ul>

<p>如果指定的文档 ID 不存在，返回如下 JSON：</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"products"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"_doc"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bk-999"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"found"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<hr />

<p>使用Java代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">getRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span> <span class="c1">// 指定索引名称</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>        <span class="c1">// 指定文档 ID</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">GetResponse</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">getResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getRequest</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">getResponse</span><span class="o">.</span><span class="na">found</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">getResponse</span><span class="o">.</span><span class="na">source</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document found: "</span> <span class="o">+</span> <span class="n">product</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document not found."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Elasticsearch 的 <code class="language-plaintext highlighter-rouge">get</code> 方法是用来<strong>获取单条数据</strong>的，并且需要指定 <strong>索引</strong> 和 <strong>文档 ID</strong>。</p>

<hr />

<p><strong>获取详解</strong></p>

<p>在 Java 中，使用 Elasticsearch 获取单条数据（<code class="language-plaintext highlighter-rouge">get</code>）时，主要涉及：</p>

<p><code class="language-plaintext highlighter-rouge">GetRequest</code> 是构建获取单条数据请求的类。它封装了获取文档所需的所有参数，如索引名称、文档 ID 以及可能的路由值。</p>

<p><code class="language-plaintext highlighter-rouge">GetResponse</code> 是 Elasticsearch 响应类，包含了从 Elasticsearch 获取的单条文档的结果，包括文档的 <code class="language-plaintext highlighter-rouge">_source</code> 数据、索引名称、文档 ID 等。</p>

<h4 id="getrequest"><code class="language-plaintext highlighter-rouge">GetRequest</code></h4>

<p><code class="language-plaintext highlighter-rouge">GetRequest</code> 是 Elasticsearch 客户端中用于获取单个文档的请求类。</p>

<p><strong>字段</strong></p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>文档所属的索引名称，必须设置。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>要检索的文档 ID，必须设置。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">routing</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>路由值，用于指向特定分片（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preference</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>检索首选项，用于控制节点间查询的路由逻辑（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">realtime</code></td>
      <td><code class="language-plaintext highlighter-rouge">Boolean</code></td>
      <td>是否实时检索（默认为 <code class="language-plaintext highlighter-rouge">true</code>，非实时可能查询到旧版本文档）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">refresh</code></td>
      <td><code class="language-plaintext highlighter-rouge">Boolean</code></td>
      <td>在检索前是否强制刷新索引（默认为 <code class="language-plaintext highlighter-rouge">false</code>）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">storedFields</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code></td>
      <td>返回指定的存储字段，而不是返回整个文档（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSource</code></td>
      <td><code class="language-plaintext highlighter-rouge">Boolean</code></td>
      <td>是否检索 <code class="language-plaintext highlighter-rouge">_source</code> 字段的数据（默认为 <code class="language-plaintext highlighter-rouge">true</code>）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSourceIncludes</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code></td>
      <td>设置需要包含在 <code class="language-plaintext highlighter-rouge">_source</code> 中的字段（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSourceExcludes</code></td>
      <td><code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code></td>
      <td>设置需要从 <code class="language-plaintext highlighter-rouge">_source</code> 中排除的字段（可选）。</td>
    </tr>
  </tbody>
</table>

<p><strong>方法</strong></p>

<p><strong>字段设置方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index(String index)</code></td>
      <td>设置目标索引名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id(String id)</code></td>
      <td>设置要检索的文档 ID。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">routing(String routing)</code></td>
      <td>设置路由值，影响分片定位。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">preference(String pref)</code></td>
      <td>设置检索的首选项（如 <code class="language-plaintext highlighter-rouge">_primary</code>、<code class="language-plaintext highlighter-rouge">_primary_first</code> 等）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">realtime(boolean rt)</code></td>
      <td>设置是否实时检索（默认为 <code class="language-plaintext highlighter-rouge">true</code>）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">refresh(boolean refresh)</code></td>
      <td>设置在检索前是否刷新索引（<code class="language-plaintext highlighter-rouge">true</code> 为刷新）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">storedFields(List&lt;String&gt; fields)</code></td>
      <td>设置需要返回的存储字段（不返回 <code class="language-plaintext highlighter-rouge">_source</code>，只返回存储字段内容）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSource(boolean fetch)</code></td>
      <td>是否检索 <code class="language-plaintext highlighter-rouge">_source</code> 字段。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSourceIncludes(List&lt;String&gt; includes)</code></td>
      <td>设置 <code class="language-plaintext highlighter-rouge">_source</code> 中要包含的字段（支持通配符）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSourceExcludes(List&lt;String&gt; excludes)</code></td>
      <td>设置 <code class="language-plaintext highlighter-rouge">_source</code> 中要排除的字段（支持通配符）。</td>
    </tr>
  </tbody>
</table>

<p><strong>构造与辅助方法</strong>
| 方法         | 描述                                                   |
| ———— | —————————————————— |
| <code class="language-plaintext highlighter-rouge">build()</code>    | 构建 <code class="language-plaintext highlighter-rouge">GetRequest</code> 对象，将设置的所有参数封装到请求中。 |
| <code class="language-plaintext highlighter-rouge">toString()</code> | 返回对象的字符串表示，主要用于调试和日志记录。         |</p>

<hr />

<p><strong>示例代码</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>          <span class="c1">// 指定索引</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>                 <span class="c1">// 指定文档 ID</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>设置更多参数：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">routing</span><span class="o">(</span><span class="s">"customRouting"</span><span class="o">)</span>         <span class="c1">// 指定路由值</span>
    <span class="o">.</span><span class="na">preference</span><span class="o">(</span><span class="s">"_primary_first"</span><span class="o">)</span>     <span class="c1">// 优先使用主分片</span>
    <span class="o">.</span><span class="na">realtime</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span>                  <span class="c1">// 设置非实时模式</span>
    <span class="o">.</span><span class="na">fetchSourceIncludes</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"price"</span><span class="o">))</span> <span class="c1">// 仅检索指定字段</span>
    <span class="o">.</span><span class="na">fetchSourceExcludes</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"internalField"</span><span class="o">))</span> <span class="c1">// 排除某些字段</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><strong>用途与说明</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">index</code> 和 <code class="language-plaintext highlighter-rouge">id</code> 是必填字段</strong>，用于定位目标文档。</li>
  <li>提供了灵活的选项来精确控制返回的数据（如过滤字段、使用存储字段等）。</li>
  <li>通常与 <code class="language-plaintext highlighter-rouge">GetResponse</code> 一起使用，用于解析和处理返回的文档数据。</li>
</ul>

<h4 id="getresponse"><code class="language-plaintext highlighter-rouge">GetResponse</code></h4>

<p><code class="language-plaintext highlighter-rouge">GetResponse</code> 是 Elasticsearch 客户端中，用于封装单条文档检索结果的响应类。</p>

<p><strong>字段</strong></p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>文档所在的索引名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>检索到的文档 ID。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">version</code></td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>文档的版本号（仅在版本控制启用时有效）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">source</code></td>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code> 或 <code class="language-plaintext highlighter-rouge">Object</code></td>
      <td>返回的文档 <code class="language-plaintext highlighter-rouge">_source</code> 数据，通常是原始文档内容。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">found</code></td>
      <td><code class="language-plaintext highlighter-rouge">Boolean</code></td>
      <td>是否成功找到文档。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">primaryTerm</code></td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>主分片的术语号（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">seqNo</code></td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>文档的序列号（可选）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">routing</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>文档的路由值（可选）。</td>
    </tr>
  </tbody>
</table>

<p><strong>方法</strong></p>

<p><strong>基本字段获取方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>返回值类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index()</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>获取文档的索引名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id()</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>获取文档的 ID。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">version()</code></td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>获取文档的版本号。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">source()</code></td>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code> 或 <code class="language-plaintext highlighter-rouge">Object</code></td>
      <td>获取文档的 <code class="language-plaintext highlighter-rouge">_source</code> 数据，通常是原始 JSON 文档。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">found()</code></td>
      <td><code class="language-plaintext highlighter-rouge">Boolean</code></td>
      <td>检查是否成功找到文档。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">primaryTerm()</code></td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>获取主分片的术语号（仅当返回时有效）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">seqNo()</code></td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
      <td>获取文档的序列号（仅当返回时有效）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">routing()</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>获取文档的路由值（如果有的话）。</td>
    </tr>
  </tbody>
</table>

<p><strong>辅助方法</strong>
| 方法                 | 返回值类型 | 描述                                       |
| ——————– | ———- | —————————————— |
| <code class="language-plaintext highlighter-rouge">toString()</code>         | <code class="language-plaintext highlighter-rouge">String</code>   | 返回对象的字符串表示，方便调试或日志记录。 |
| <code class="language-plaintext highlighter-rouge">equals(Object obj)</code> | <code class="language-plaintext highlighter-rouge">boolean</code>  | 比较两个响应对象是否相同。                 |
| <code class="language-plaintext highlighter-rouge">hashCode()</code>         | <code class="language-plaintext highlighter-rouge">int</code>      | 返回对象的哈希值，用于集合操作等场景。     |</p>

<hr />

<p><strong>示例代码</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetResponse</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">g</span> <span class="o">-&gt;</span> <span class="n">g</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">),</span> 
    <span class="nc">Product</span><span class="o">.</span><span class="na">class</span>
<span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">found</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document found:"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Index: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">index</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">id</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Source: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">source</span><span class="o">());</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document not found!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>获取主分片信息：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">found</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Primary Term: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">primaryTerm</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sequence Number: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">seqNo</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>通过 <code class="language-plaintext highlighter-rouge">_source</code> 转为对象：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">source</span><span class="o">();</span>  <span class="c1">// 如果使用泛型，直接返回反序列化的对象。</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Product: "</span> <span class="o">+</span> <span class="n">product</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p><strong>注意事项</strong></p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">found</code> 字段：</strong>如果文档不存在，则 <code class="language-plaintext highlighter-rouge">found</code> 为 <code class="language-plaintext highlighter-rouge">false</code>，且 <code class="language-plaintext highlighter-rouge">source</code> 等字段返回 <code class="language-plaintext highlighter-rouge">null</code>。</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">source</code> 的泛型支持：</strong>如果在请求中使用了泛型类（如 <code class="language-plaintext highlighter-rouge">Product.class</code>），<code class="language-plaintext highlighter-rouge">source()</code> 方法会返回反序列化后的对象。</p>
  </li>
  <li>
    <p><strong>路由和版本控制：</strong>如果文档启用了自定义路由或版本控制，可通过 <code class="language-plaintext highlighter-rouge">routing()</code> 和 <code class="language-plaintext highlighter-rouge">version()</code> 获取这些信息。</p>
  </li>
  <li>
    <p><strong>与 <code class="language-plaintext highlighter-rouge">GetRequest</code> 配合使用：</strong><code class="language-plaintext highlighter-rouge">GetResponse</code> 通常与 <code class="language-plaintext highlighter-rouge">GetRequest</code> 一起使用，用于解析返回的单条文档数据。</p>
  </li>
</ul>

<h4 id="get"><code class="language-plaintext highlighter-rouge">get()</code></h4>

<p><code class="language-plaintext highlighter-rouge">esClient.get()</code> 是 Elasticsearch 客户端中用于获取单条文档数据的方法。在不同版本的 Elasticsearch 客户端中，<code class="language-plaintext highlighter-rouge">get()</code> 方法的参数可能有所不同。以下是 <code class="language-plaintext highlighter-rouge">esClient.get()</code> 方法的常用变体和参数，基于 Elasticsearch 7.x 和 8.x 客户端。</p>

<p><strong>基本的 <code class="language-plaintext highlighter-rouge">get()</code> 方法</strong></p>

<p><strong>参数：</strong><code class="language-plaintext highlighter-rouge">GetRequest getRequest</code>：这是一个 <code class="language-plaintext highlighter-rouge">GetRequest</code> 对象，包含了需要的索引、文档 ID 和其他可选参数（如路由值）。</p>

<p><strong>返回：</strong><code class="language-plaintext highlighter-rouge">GetResponse</code>：包含了文档的 <code class="language-plaintext highlighter-rouge">_source</code> 数据、文档 ID、索引名等。</p>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">getRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">);</span>
<span class="nc">GetResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getRequest</span><span class="o">,</span> <span class="nc">RequestOptions</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">found</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">source</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Product: "</span> <span class="o">+</span> <span class="n">product</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">get()</code> 方法的异步变体</strong></p>

<p>Elasticsearch 客户端也支持异步获取文档数据的方法，可以通过 <code class="language-plaintext highlighter-rouge">ActionListener</code> 来处理异步响应。</p>

<p><strong>参数：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">GetRequest getRequest</code>：请求对象。</li>
  <li><code class="language-plaintext highlighter-rouge">ActionListener&lt;GetResponse&gt;</code>：用于处理异步响应的回调。</li>
</ul>

<p><strong>返回：</strong> 异步操作，不会直接返回 <code class="language-plaintext highlighter-rouge">GetResponse</code>，而是通过回调通知响应。</p>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">getRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">);</span>
<span class="n">esClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getRequest</span><span class="o">,</span> <span class="nc">RequestOptions</span><span class="o">.</span><span class="na">DEFAULT</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ActionListener</span><span class="o">&lt;</span><span class="nc">GetResponse</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onResponse</span><span class="o">(</span><span class="nc">GetResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">found</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">source</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Product: "</span> <span class="o">+</span> <span class="n">product</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">get()</code> 方法（ElasticsearchClient 8.x）</strong></p>

<p>在 Elasticsearch 8.x 中，<code class="language-plaintext highlighter-rouge">get()</code> 方法的接口发生了一些变化，<code class="language-plaintext highlighter-rouge">ElasticsearchClient</code> 引入了新的 API 来进行数据的获取。相比于 7.x 客户端，8.x 客户端的 <code class="language-plaintext highlighter-rouge">get()</code> 方法不再直接使用 <code class="language-plaintext highlighter-rouge">RequestOptions</code>，而是使用 <code class="language-plaintext highlighter-rouge">GetRequest</code> 对象和泛型来指定返回类型。</p>

<p><strong>参数：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">GetRequest getRequest</code>：请求对象，包含索引、文档 ID 和可选的路由。</li>
  <li><code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>：指定返回类型，通常是从 Elasticsearch 获取的数据模型类（如 <code class="language-plaintext highlighter-rouge">Product.class</code>）。</li>
</ul>

<p><strong>返回：</strong><code class="language-plaintext highlighter-rouge">GetResponse&lt;T&gt;</code>：返回指定类型的数据。</p>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">getRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">);</span>
<span class="nc">GetResponse</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">getRequest</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">found</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">source</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Product: "</span> <span class="o">+</span> <span class="n">product</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">get()</code> 方法的其他变体</strong></p>

<p><strong>常用参数：</strong></p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">index(String index)</code></strong>：指定要查询的索引。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">id(String id)</code></strong>：指定要查询文档的 ID。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">routing(String routing)</code></strong>：指定文档的路由值（可选）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">preference(String preference)</code></strong>：指定查询的优先级（可选）。</li>
</ul>

<p>这些参数通常通过 <code class="language-plaintext highlighter-rouge">GetRequest</code> 对象来传递。</p>

<p><strong>示例：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">GetRequest</span> <span class="n">getRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GetRequest</span><span class="o">(</span><span class="s">"products"</span><span class="o">,</span> <span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">routing</span><span class="o">(</span><span class="s">"user1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">preference</span><span class="o">(</span><span class="s">"replica"</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>总结</strong></p>

<p><code class="language-plaintext highlighter-rouge">esClient.get()</code> 方法的常用变体和参数：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">GetRequest getRequest</code></strong>：这是必须提供的，包含索引名称、文档 ID 以及其他可选参数（如路由和优先级）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">RequestOptions</code></strong>：在 7.x 版本中，可通过 <code class="language-plaintext highlighter-rouge">RequestOptions</code> 设置请求的配置（如超时、认证等）。在 8.x 中已不再显式使用。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ActionListener&lt;GetResponse&gt;</code></strong>：用于异步操作，提供回调机制来处理响应或失败。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Product.class</code> 或其他自定义类</strong>：指定返回数据的类型，Elasticsearch 会将 <code class="language-plaintext highlighter-rouge">_source</code> 数据反序列化为该类型。</li>
</ul>

<h3 id="更新">更新</h3>

<p>通过 HTTP 更新 Elasticsearch 中的数据，通常使用 <code class="language-plaintext highlighter-rouge">PUT</code> 或 <code class="language-plaintext highlighter-rouge">POST</code> 请求。更新操作会依赖于你是否指定文档的 ID。以下是通过 HTTP 请求更新数据的步骤和示例。</p>

<p><strong>更新数据的 HTTP 请求方式</strong></p>

<ul>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">PUT</code> 请求</strong>：如果文档已存在，它会被更新。如果文档不存在，则会创建新文档。</li>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">POST</code> 请求</strong>：适用于部分更新（文档部分字段更新），即使用 Elasticsearch 的更新 API。</li>
</ul>

<p><strong>HTTP 请求的基本格式</strong></p>

<ul>
  <li><strong>请求 URL</strong>：
    <ul>
      <li>格式：<code class="language-plaintext highlighter-rouge">http://&lt;hostname&gt;:&lt;port&gt;/&lt;index&gt;/_doc/&lt;document_id&gt;</code></li>
      <li>示例：<code class="language-plaintext highlighter-rouge">http://localhost:9200/products/_doc/1</code></li>
    </ul>
  </li>
  <li>
    <p><strong>请求头</strong>：<code class="language-plaintext highlighter-rouge">Content-Type: application/json</code>：指定请求体的格式为 JSON。</p>
  </li>
  <li><strong>请求体</strong>：
    <ul>
      <li>在 <code class="language-plaintext highlighter-rouge">PUT</code> 请求中，可以提供完整的文档内容，更新文档。</li>
      <li>在 <code class="language-plaintext highlighter-rouge">POST</code> 请求中，通常只提供需要更新的字段，Elasticsearch 会对文档进行部分更新。</li>
    </ul>
  </li>
</ul>

<p><strong>示例：通过 HTTP 更新数据</strong></p>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">PUT</code> 更新数据（完整替换文档）</strong></p>

<p><code class="language-plaintext highlighter-rouge">PUT</code> 请求将完全替换指定 ID 的文档。如果文档不存在，则会创建新文档。</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PUT http://localhost:9200/products/_doc/bk-1
Content-Type: application/json

{
  "sku": "bk-1",
  "name": "Mountain bike",
  "price": 150.0
}
</span></code></pre></div></div>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">POST</code> 更新数据（部分更新）</strong></p>

<p><code class="language-plaintext highlighter-rouge">POST</code> 请求适用于部分更新，只有提供的字段会被更新，其他字段保持不变。</p>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">POST http://localhost:9200/products/_doc/bk-1/_update
Content-Type: application/json

{
  "doc": {
    "price": 150.0
  }
}
</span></code></pre></div></div>

<p>在这个例子中，<code class="language-plaintext highlighter-rouge">_update</code> 路径指示部分更新操作，<code class="language-plaintext highlighter-rouge">doc</code> 字段包含要更新的内容。</p>

<p><strong>更新数据的响应</strong></p>

<p>无论是 <code class="language-plaintext highlighter-rouge">PUT</code> 还是 <code class="language-plaintext highlighter-rouge">POST</code> 请求，Elasticsearch 都会返回一个 JSON 响应，表示更新操作的结果。以下是响应的一个示例：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"products"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"_doc"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bk-1"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_version"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
  </span><span class="nl">"result"</span><span class="p">:</span><span class="w"> </span><span class="s2">"updated"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_shards"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"total"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
    </span><span class="nl">"successful"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
    </span><span class="nl">"failed"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"_seq_no"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
  </span><span class="nl">"_primary_term"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">_index</code></strong>：文档所在的索引。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">_id</code></strong>：文档的 ID。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">_version</code></strong>：文档的版本，更新时会增加版本号。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">result</code></strong>：操作结果，<code class="language-plaintext highlighter-rouge">updated</code> 表示文档已更新。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">_shards</code></strong>：有关分片的信息，表示操作执行成功的分片数等。</li>
</ul>

<p><strong>错误处理</strong></p>

<p>如果更新操作出现错误，Elasticsearch 会返回错误信息，例如：</p>
<ul>
  <li><strong>400 Bad Request</strong>：请求格式错误，通常是因为 JSON 格式不正确。</li>
  <li><strong>404 Not Found</strong>：目标索引或文档 ID 不存在。</li>
  <li><strong>409 Conflict</strong>：尝试更新不存在的文档。</li>
</ul>

<hr />

<p><strong>总结</strong></p>

<p>通过 HTTP 更新数据的基本步骤是：</p>
<ol>
  <li>使用 <code class="language-plaintext highlighter-rouge">PUT</code> 或 <code class="language-plaintext highlighter-rouge">POST</code> 请求，<code class="language-plaintext highlighter-rouge">PUT</code> 用于完整替换文档，<code class="language-plaintext highlighter-rouge">POST</code> 用于部分更新文档。</li>
  <li>设置正确的 URL 和请求头。</li>
  <li>提供要更新的文档内容（完整或部分字段）。</li>
  <li>发送请求并处理响应。</li>
</ol>

<hr />

<p>通过Java更新数据：</p>

<p><strong>部分更新文档（使用 <code class="language-plaintext highlighter-rouge">update</code>）</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">updateRequest</span> <span class="o">=</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">index</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
        <span class="o">.</span><span class="na">doc</span><span class="o">(</span><span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">jsonString</span><span class="o">))</span>
<span class="o">);</span>
<span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">updateResponse</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">updateRequest</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">updateResponse</span><span class="o">.</span><span class="na">result</span><span class="o">());</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">UpdateRequest.of()</code></strong>：使用 <code class="language-plaintext highlighter-rouge">of()</code> 方法构建更新请求。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">JsonData.of()</code></strong>：将 JSON 字符串转换为 <code class="language-plaintext highlighter-rouge">JsonData</code> 类型，这是 <code class="language-plaintext highlighter-rouge">co.elastic.clients</code> 中用于传输 JSON 数据的类型。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">updateResponse.result()</code></strong>：返回操作结果，指示更新是否成功。</li>
</ul>

<p><strong>完整替换文档（使用 <code class="language-plaintext highlighter-rouge">index</code>）</strong>，详解插入。</p>

<p>更新操作可能会失败，因此需要进行异常处理。常见的异常有：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">VersionConflictEngineException</code></strong>：版本冲突异常，通常发生在多线程环境中。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ElasticsearchException</code></strong>：其他与 Elasticsearch 相关的异常。</li>
</ul>

<hr />

<p><strong>更新详解</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">co.elastic.clients.elasticsearch.core.UpdateRequest&lt;TDocument, TPartial&gt;</code></strong></p>

<ul>
  <li>用于构建更新请求。</li>
  <li>支持更新整个文档或部分字段。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">co.elastic.clients.elasticsearch.core.UpdateResponse&lt;TDocument&gt;</code></strong></p>

<ul>
  <li>用于处理更新操作的响应。</li>
  <li>包含结果状态和文档元数据。</li>
</ul>

<p>同 <code class="language-plaintext highlighter-rouge">index</code>，<code class="language-plaintext highlighter-rouge">UpdateRequest</code>也有同样的几种构建方式：</p>

<p>方式2：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"cityBike"</span><span class="o">,</span><span class="s">"测试修改"</span><span class="o">);</span>
<span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">updateRequest</span> <span class="o">=</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">doc</span><span class="o">(</span><span class="n">map</span><span class="o">)</span>
<span class="o">);</span>
<span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">updateResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">updateRequest</span><span class="o">,</span><span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<p>方式3：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">updateResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">doc</span><span class="o">(</span><span class="n">map</span><span class="o">),</span><span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="updaterequest"><strong><code class="language-plaintext highlighter-rouge">UpdateRequest</code></strong></h4>

<p><code class="language-plaintext highlighter-rouge">UpdateRequest</code> 是用于构建 Elasticsearch 更新请求的核心类。通过它，可以指定索引、文档 ID、更新内容（部分更新或脚本更新）等参数。</p>

<p><strong>字段</strong></p>

<p>以下是 <code class="language-plaintext highlighter-rouge">UpdateRequest</code> 的常用字段：</p>

<table>
  <thead>
    <tr>
      <th>字段名称</th>
      <th>类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>要更新的索引名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>要更新的文档 ID。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">routing</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
      <td>可选的路由值，用于分片分发。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ifSeqNo</code></td>
      <td><code class="language-plaintext highlighter-rouge">Long</code></td>
      <td>序列号，确保只在特定版本时更新（乐观锁）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ifPrimaryTerm</code></td>
      <td><code class="language-plaintext highlighter-rouge">Long</code></td>
      <td>主分片版本号，与 <code class="language-plaintext highlighter-rouge">ifSeqNo</code> 结合使用。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">doc</code></td>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code> 或 <code class="language-plaintext highlighter-rouge">JsonData</code>，或<code class="language-plaintext highlighter-rouge">T</code></td>
      <td>要更新的部分文档内容。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">upsert</code></td>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code> 或 <code class="language-plaintext highlighter-rouge">JsonData</code>，或<code class="language-plaintext highlighter-rouge">T</code></td>
      <td>如果文档不存在时插入的内容。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">script</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">Script</code></td>
      <td>用于动态更新文档的脚本。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">docAsUpsert</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">boolean</code></td>
      <td>是否将部分文档作为插入内容（如果文档不存在）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">fetchSource</code></td>
      <td><code class="language-plaintext highlighter-rouge">FetchSourceContext</code></td>
      <td>是否返回更新后的文档以及哪些字段需要返回。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">retryOnConflict</code></td>
      <td><code class="language-plaintext highlighter-rouge">Integer</code></td>
      <td>更新冲突重试的次数。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">refresh</code></td>
      <td><code class="language-plaintext highlighter-rouge">RefreshPolicy</code></td>
      <td>更新操作后是否刷新索引。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">timeout</code></td>
      <td><code class="language-plaintext highlighter-rouge">TimeValue</code></td>
      <td>等待主分片响应的超时时间。</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>方法</strong></p>

<p><strong>基础设置方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>返回类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index(String index)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置目标索引名称。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id(String id)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置文档 ID。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">routing(String routing)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置路由信息。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ifSeqNo(long seqNo)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置序列号（用于乐观并发控制）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">ifPrimaryTerm(long term)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置主分片版本号。</td>
    </tr>
  </tbody>
</table>

<p><strong>内容设置方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>返回类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">doc(Object doc)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置部分更新的内容，可以是 Map 或 POJO。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">upsert(Object upsert)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置插入文档（如果文档不存在时）。</td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">script(Script script)</code></strong></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置更新脚本。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">docAsUpsert(boolean docAsUpsert)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>是否将部分文档作为插入内容（如果文档不存在）。</td>
    </tr>
  </tbody>
</table>

<p><strong>控制参数方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>返回类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">retryOnConflict(int retries)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置更新冲突的重试次数（默认 0）。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">refresh(RefreshPolicy policy)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置刷新策略。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">timeout(TimeValue timeout)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置等待主分片响应的超时时间。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">scriptedUpsert(Boolean value)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置为 true 以执行脚本，无论文档是否存在</td>
    </tr>
  </tbody>
</table>

<p><strong>Fetch Source 方法</strong></p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>返回类型</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">source(SourceConfig fetch)</code></td>
      <td><code class="language-plaintext highlighter-rouge">UpdateRequest</code></td>
      <td>设置返回的字段范围（具体字段或排除字段）</td>
    </tr>
  </tbody>
</table>

<p><strong>部分字段更新</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;();</span>
<span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="s">"stock"</span><span class="o">,</span> <span class="mi">50</span><span class="o">))</span> <span class="c1">// 更新部分字段</span>
    <span class="o">.</span><span class="na">docAsUpsert</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>                      <span class="c1">// 如果文档不存在，插入新文档</span>
    <span class="o">.</span><span class="na">retryOnConflict</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>                     <span class="c1">// 更新冲突重试次数</span>
    <span class="o">.</span><span class="na">fetchSource</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>                      <span class="c1">// 返回更新后的源文档</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>脚本更新</strong></p>

<p>通过脚本动态更新字段的值：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Script</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"ctx._source.price += params.increment"</span><span class="o">)</span> <span class="c1">// 使用 Painless 脚本</span>
    <span class="o">.</span><span class="na">params</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"increment"</span><span class="o">,</span> <span class="mi">20</span><span class="o">))</span>                <span class="c1">// 设置参数</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;();</span>
<span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">script</span><span class="o">)</span>
    <span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">time</span><span class="o">(</span><span class="s">"2s"</span><span class="o">))</span> <span class="c1">// 设置超时时间</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>设置 <code class="language-plaintext highlighter-rouge">upsert</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">upsert</code> 的功能在 Fluent DSL 中也支持：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;();</span>
<span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">200</span><span class="o">))</span>               <span class="c1">// 如果文档存在，更新 "price" 字段的值为 200</span>
    <span class="o">.</span><span class="na">upsert</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">200</span><span class="o">,</span> <span class="s">"stock"</span><span class="o">,</span> <span class="mi">100</span><span class="o">))</span> <span class="c1">// 如果文档不存在，创建一个包含 "price" 和 "stock" 的新文档</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>控制刷新策略</strong></p>

<p>设置刷新策略，以确保更新后立即对查询可见：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;();</span>
<span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"status"</span><span class="o">,</span> <span class="s">"updated"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">True</span><span class="o">)</span> <span class="c1">// 设置刷新策略为立即刷新</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<h4 id="updateresponse"><code class="language-plaintext highlighter-rouge">UpdateResponse</code></h4>

<p><code class="language-plaintext highlighter-rouge">UpdateResponse</code> 是一个重要的类，用于表示 <code class="language-plaintext highlighter-rouge">UpdateRequest</code> 的响应。它包含了关于更新操作的详细信息，例如更新状态、文档元数据等。</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
      <th>返回类型</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">id()</code></td>
      <td>获取文档的 <code class="language-plaintext highlighter-rouge">_id</code></td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">index()</code></td>
      <td>获取文档的索引名称</td>
      <td><code class="language-plaintext highlighter-rouge">String</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">version()</code></td>
      <td>获取文档版本号</td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">result()</code></td>
      <td>获取更新操作的结果</td>
      <td><code class="language-plaintext highlighter-rouge">Result</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">shards()</code></td>
      <td>获取分片统计信息</td>
      <td><code class="language-plaintext highlighter-rouge">ShardStatistics</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">seqNo()</code></td>
      <td>获取操作的序列号</td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">primaryTerm()</code></td>
      <td>获取操作的主分片任期号</td>
      <td><code class="language-plaintext highlighter-rouge">long</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">get()</code></td>
      <td>获取文档的当前状态（需启用 <code class="language-plaintext highlighter-rouge">source</code>）</td>
      <td><code class="language-plaintext highlighter-rouge">@Nullable GetResult</code></td>
    </tr>
  </tbody>
</table>

<p><strong><code class="language-plaintext highlighter-rouge">result</code> (Result)</strong>：表示更新操作的结果状态，枚举类型 <code class="language-plaintext highlighter-rouge">Result</code>，可能的值有：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Created</code>：文档是新创建的（通过 <code class="language-plaintext highlighter-rouge">upsert</code>）。</li>
  <li><code class="language-plaintext highlighter-rouge">Updated</code>：文档已被成功更新。</li>
  <li><code class="language-plaintext highlighter-rouge">Deleted</code>：文档被删除。</li>
  <li><code class="language-plaintext highlighter-rouge">NoOp</code>：未执行任何操作。</li>
  <li><code class="language-plaintext highlighter-rouge">NotFound</code>：未找到文档。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">get</code> (<code class="language-plaintext highlighter-rouge">GetResult</code>)</strong>：如果更新操作包含 <code class="language-plaintext highlighter-rouge">fetchSource(true)</code>，会返回 <code class="language-plaintext highlighter-rouge">GetResult</code> 对象，提供关于文档当前状态的详细信息。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">source</span><span class="o">();</span>
   <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Updated source: "</span> <span class="o">+</span> <span class="n">source</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="update"><code class="language-plaintext highlighter-rouge">update()</code></h4>

<p><code class="language-plaintext highlighter-rouge">update</code> API 允许你对已存在的文档进行部分更新，而无需替换整个文档。</p>

<p>在 <strong>Elasticsearch 8.x Java Client</strong> 中，<code class="language-plaintext highlighter-rouge">update()</code> 方法有多个变体，可以通过不同的构造方式来执行文档更新操作。</p>

<p><strong><code class="language-plaintext highlighter-rouge">update()</code> 方法的基本变体</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">,</span> <span class="nc">TPartialDocument</span><span class="o">&gt;</span> <span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">&gt;</span> <span class="nf">update</span><span class="o">(</span>
        <span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">,</span> <span class="nc">TPartialDocument</span><span class="o">&gt;</span> <span class="n">request</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">&gt;</span> <span class="n">tDocumentClass</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ElasticsearchException</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>功能</strong>：此方法接受一个 <strong><code class="language-plaintext highlighter-rouge">UpdateRequest</code></strong> 对象和目标文档的 <strong><code class="language-plaintext highlighter-rouge">Class</code></strong> 类型（用于指定返回的文档类型），然后执行更新操作。</p>

<p><strong>参数</strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">UpdateRequest&lt;TDocument, TPartialDocument&gt; request</code>：包含更新操作详细信息的请求对象。</li>
  <li><code class="language-plaintext highlighter-rouge">Class&lt;TDocument&gt; tDocumentClass</code>：返回结果文档的类型，通常是你的实体类。</li>
</ul>

<p>此方法直接通过 <code class="language-plaintext highlighter-rouge">transport.performRequest()</code> 执行请求，执行一个同步的文档更新操作。</p>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">update()</code> 方法的构建器变体</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">,</span> <span class="nc">TPartialDocument</span><span class="o">&gt;</span> <span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">&gt;</span> <span class="nf">update</span><span class="o">(</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">,</span> <span class="nc">TPartialDocument</span><span class="o">&gt;,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">UpdateRequest</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">,</span> <span class="nc">TPartialDocument</span><span class="o">&gt;&gt;&gt;</span> <span class="n">fn</span><span class="o">,</span>
        <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">&gt;</span> <span class="n">tDocumentClass</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ElasticsearchException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">update</span><span class="o">(</span><span class="n">fn</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">new</span> <span class="nc">UpdateRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">TDocument</span><span class="o">,</span> <span class="nc">TPartialDocument</span><span class="o">&gt;()).</span><span class="na">build</span><span class="o">(),</span> <span class="n">tDocumentClass</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>功能</strong>：此变体使用了构建器模式。通过一个函数 <code class="language-plaintext highlighter-rouge">fn</code>，你可以配置一个 <code class="language-plaintext highlighter-rouge">UpdateRequest</code> 对象，然后调用 <code class="language-plaintext highlighter-rouge">update()</code> 执行请求。</p>

<p><strong>参数</strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">fn</code>：一个接受 <code class="language-plaintext highlighter-rouge">UpdateRequest.Builder</code> 的函数，构造一个 <code class="language-plaintext highlighter-rouge">UpdateRequest</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">Class&lt;TDocument&gt; tDocumentClass</code>：返回结果文档的类型。</li>
</ul>

<p>此方法的优势是可以通过 Lambda 表达式快速构建请求对象，避免显式地创建请求对象。</p>

<p><strong>示例</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">update</span><span class="o">(</span>
    <span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">).</span><span class="na">script</span><span class="o">(</span><span class="n">script</span><span class="o">).</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">True</span><span class="o">),</span> 
    <span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">updateByQuery()</code> 方法变体</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">UpdateByQueryResponse</span> <span class="nf">updateByQuery</span><span class="o">(</span><span class="nc">UpdateByQueryRequest</span> <span class="n">request</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ElasticsearchException</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><strong>功能</strong>
执行一个更新查询操作，更新符合条件的所有文档，而不直接改变源文档的内容（如应用映射更改）。通常用于批量更新。
<strong>参数</strong>：<code class="language-plaintext highlighter-rouge">UpdateByQueryRequest request</code>：包含更新查询操作的请求对象。</li>
</ul>

<p>该方法执行一个同步的更新操作，更新索引中的多个文档。</p>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">updateByQuery()</code> 方法的构建器变体</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="nc">UpdateByQueryResponse</span> <span class="nf">updateByQuery</span><span class="o">(</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">UpdateByQueryRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">UpdateByQueryRequest</span><span class="o">&gt;&gt;</span> <span class="n">fn</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ElasticsearchException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">updateByQuery</span><span class="o">(</span><span class="n">fn</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">new</span> <span class="nc">UpdateByQueryRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">()).</span><span class="na">build</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>功能</strong>：该变体允许使用构建器模式配置一个 <code class="language-plaintext highlighter-rouge">UpdateByQueryRequest</code> 对象，然后执行更新查询操作。
<strong>参数</strong>：<code class="language-plaintext highlighter-rouge">fn</code>：一个接受 <code class="language-plaintext highlighter-rouge">UpdateByQueryRequest.Builder</code> 的函数，构造 <code class="language-plaintext highlighter-rouge">UpdateByQueryRequest</code> 对象。</p>

<p>通过这个方法，你可以更灵活地构建请求参数，适用于复杂的查询和批量更新操作。</p>

<p><strong>示例</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateByQueryResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">updateByQuery</span><span class="o">(</span>
    <span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">matchAll</span><span class="o">()).</span><span class="na">script</span><span class="o">(</span><span class="n">script</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">updateByQueryRethrottle()</code> 方法</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">UpdateByQueryRethrottleResponse</span> <span class="nf">updateByQueryRethrottle</span><span class="o">(</span><span class="nc">UpdateByQueryRethrottleRequest</span> <span class="n">request</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ElasticsearchException</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>功能</strong>：用于更改 <code class="language-plaintext highlighter-rouge">UpdateByQuery</code> 操作的请求频率（每秒请求数）。如果你想控制查询操作的速率，可以使用此方法。
<strong>参数</strong>：<code class="language-plaintext highlighter-rouge">UpdateByQueryRethrottleRequest request</code>：请求对象，指定需要更改速率的 <code class="language-plaintext highlighter-rouge">UpdateByQuery</code> 操作。</p>

<p><strong><code class="language-plaintext highlighter-rouge">updateByQueryRethrottle()</code> 方法的构建器变体</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="nc">UpdateByQueryRethrottleResponse</span> <span class="nf">updateByQueryRethrottle</span><span class="o">(</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">UpdateByQueryRethrottleRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">UpdateByQueryRethrottleRequest</span><span class="o">&gt;&gt;</span> <span class="n">fn</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ElasticsearchException</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">updateByQueryRethrottle</span><span class="o">(</span><span class="n">fn</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="k">new</span> <span class="nc">UpdateByQueryRethrottleRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">()).</span><span class="na">build</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>功能</strong>：该变体使用构建器模式构造一个 <code class="language-plaintext highlighter-rouge">UpdateByQueryRethrottleRequest</code> 对象，然后执行重新调整请求频率的操作。</p>

<p>总结</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">update()</code></strong>：用于单个文档的更新操作，支持 <code class="language-plaintext highlighter-rouge">script</code>、<code class="language-plaintext highlighter-rouge">doc</code> 等字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">updateByQuery()</code></strong>：用于根据查询条件批量更新多个文档。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">updateByQueryRethrottle()</code></strong>：用于控制 <code class="language-plaintext highlighter-rouge">update_by_query</code> 操作的速率。</li>
</ul>

<p>所有这些方法的变体都可以通过构建器模式或函数式编程来配置请求，提供了灵活的 API 使得你可以根据需求构造更新操作。</p>

<h4 id="sourceconfig"><code class="language-plaintext highlighter-rouge">SourceConfig</code></h4>

<p><code class="language-plaintext highlighter-rouge">SourceConfig</code> 是一个用于定义如何获取文档 <code class="language-plaintext highlighter-rouge">_source</code> 数据的类。它有两种主要的配置方式：<code class="language-plaintext highlighter-rouge">Filter</code> 和 <code class="language-plaintext highlighter-rouge">Fetch</code>，这两种方式可以决定是完全检索 <code class="language-plaintext highlighter-rouge">_source</code>，还是根据过滤条件来获取 <code class="language-plaintext highlighter-rouge">_source</code>。</p>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">filter</code> 类型的 <code class="language-plaintext highlighter-rouge">SourceConfig</code></strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SourceConfig</span> <span class="n">sourceConfig</span> <span class="o">=</span> <span class="nc">SourceConfig</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
  <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="s">"name"</span><span class="o">).</span><span class="na">excludes</span><span class="o">(</span><span class="s">"age"</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">fetch</code> 类型的 <code class="language-plaintext highlighter-rouge">SourceConfig</code></strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SourceConfig</span> <span class="n">sourceConfig</span> <span class="o">=</span> <span class="nc">SourceConfig</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
    <span class="o">.</span><span class="na">fetch</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p><strong>总结</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SourceConfig</code> 用于控制如何检索文档的 <code class="language-plaintext highlighter-rouge">_source</code> 数据。</li>
  <li>它支持两种类型：<code class="language-plaintext highlighter-rouge">Filter</code>（通过过滤字段来检索）和 <code class="language-plaintext highlighter-rouge">Fetch</code>（完全检索 <code class="language-plaintext highlighter-rouge">_source</code> 数据）。</li>
  <li>通过 <code class="language-plaintext highlighter-rouge">Builder</code> 模式，您可以方便地构建 <code class="language-plaintext highlighter-rouge">SourceConfig</code> 实例，并在查询中使用它。</li>
</ul>

<h4 id="sourcefilter"><code class="language-plaintext highlighter-rouge">SourceFilter</code></h4>

<p><code class="language-plaintext highlighter-rouge">SourceFilter.Builder</code> 是用于构建 <code class="language-plaintext highlighter-rouge">SourceFilter</code> 实例的类。它允许您动态地设置哪些字段应该被包含或排除在 <code class="language-plaintext highlighter-rouge">_source</code> 字段中，并且提供了多种方法来添加包含或排除的字段。</p>

<p><strong>关键字段：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">includes</code>: 这个字段保存了需要包含在 <code class="language-plaintext highlighter-rouge">_source</code> 中的字段名列表。</li>
  <li><code class="language-plaintext highlighter-rouge">excludes</code>: 这个字段保存了需要排除在 <code class="language-plaintext highlighter-rouge">_source</code> 中的字段名列表。</li>
</ul>

<p><strong>关键方法：</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">excludes(List&lt;String&gt; list)</code></strong></p>
<ul>
  <li>这个方法允许您将一个字段列表添加到排除列表 <code class="language-plaintext highlighter-rouge">excludes</code> 中。</li>
  <li><strong>参数</strong>：一个包含字段名的 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">Builder</code> 对象，允许链式调用。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">builder</span><span class="o">.</span><span class="na">excludes</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"field1"</span><span class="o">,</span> <span class="s">"field2"</span><span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">excludes(String value, String... values)</code></strong></p>
<ul>
  <li>这个方法允许您将一个或多个字段名添加到排除列表 <code class="language-plaintext highlighter-rouge">excludes</code> 中。</li>
  <li><strong>参数</strong>：一个字段名或多个字段名作为参数。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">Builder</code> 对象，允许链式调用。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">excludes</span><span class="o">(</span><span class="s">"field1"</span><span class="o">,</span> <span class="s">"field2"</span><span class="o">,</span> <span class="s">"field3"</span><span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">includes(List&lt;String&gt; list)</code></strong></p>
<ul>
  <li>这个方法允许您将一个字段列表添加到包含列表 <code class="language-plaintext highlighter-rouge">includes</code> 中。</li>
  <li><strong>参数</strong>：一个包含字段名的 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">Builder</code> 对象，允许链式调用。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"field1"</span><span class="o">,</span> <span class="s">"field2"</span><span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">includes(String value, String... values)</code></strong></p>
<ul>
  <li>这个方法允许您将一个或多个字段名添加到包含列表 <code class="language-plaintext highlighter-rouge">includes</code> 中。</li>
  <li><strong>参数</strong>：一个字段名或多个字段名作为参数。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">Builder</code> 对象，允许链式调用。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="s">"field1"</span><span class="o">,</span> <span class="s">"field2"</span><span class="o">,</span> <span class="s">"field3"</span><span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">self()</code></strong>：这个方法是继承自 <code class="language-plaintext highlighter-rouge">WithJsonObjectBuilderBase</code> 的一个辅助方法，它返回当前的 <code class="language-plaintext highlighter-rouge">Builder</code> 实例。用于支持链式调用。</p>

<p><strong><code class="language-plaintext highlighter-rouge">build()</code></strong>：构建并返回一个 <code class="language-plaintext highlighter-rouge">SourceFilter</code> 对象。如果一些必要字段为 <code class="language-plaintext highlighter-rouge">null</code>，则会抛出 <code class="language-plaintext highlighter-rouge">NullPointerException</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SourceFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>以下是如何使用 <code class="language-plaintext highlighter-rouge">SourceFilter.Builder</code> 来创建一个 <code class="language-plaintext highlighter-rouge">SourceFilter</code> 实例的示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SourceFilter</span> <span class="n">filter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SourceFilter</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="s">"field1"</span><span class="o">,</span> <span class="s">"field2"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">excludes</span><span class="o">(</span><span class="s">"field3"</span><span class="o">,</span> <span class="s">"field4"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<p>更简洁的方式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SourceConfig</span> <span class="n">sourceConfig</span> <span class="o">=</span> <span class="nc">SourceConfig</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="s">"name"</span><span class="o">).</span><span class="na">excludes</span><span class="o">(</span><span class="s">"age"</span><span class="o">)));</span>
</code></pre></div></div>

<h4 id="script"><code class="language-plaintext highlighter-rouge">Script</code></h4>

<p><code class="language-plaintext highlighter-rouge">Script</code> 类用于表示 Elasticsearch 中的脚本，支持两种主要的脚本类型：<code class="language-plaintext highlighter-rouge">Inline</code> 和 <code class="language-plaintext highlighter-rouge">Stored</code>。它是一个标签联合类（<code class="language-plaintext highlighter-rouge">TaggedUnion</code>），意味着它可以在不同类型的变体之间切换。</p>

<p><strong>字段</strong>:</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">_kind</code></strong>：表示当前脚本的类型，可能的值为 <code class="language-plaintext highlighter-rouge">Inline</code> 或 <code class="language-plaintext highlighter-rouge">Stored</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">_value</code></strong>：存储当前脚本的实际内容。具体内容根据 <code class="language-plaintext highlighter-rouge">_kind</code> 的值而定。如果 <code class="language-plaintext highlighter-rouge">_kind</code> 是 <code class="language-plaintext highlighter-rouge">Inline</code>，则 <code class="language-plaintext highlighter-rouge">value</code> 是 <code class="language-plaintext highlighter-rouge">InlineScript</code> 类型；如果 <code class="language-plaintext highlighter-rouge">_kind</code> 是 <code class="language-plaintext highlighter-rouge">Stored</code>，则 <code class="language-plaintext highlighter-rouge">value</code> 是 <code class="language-plaintext highlighter-rouge">StoredScriptId</code> 类型。</li>
</ul>

<p><strong>方法</strong>:</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">_kind()</code></strong>: 返回脚本的类型（<code class="language-plaintext highlighter-rouge">Inline</code> 或 <code class="language-plaintext highlighter-rouge">Stored</code>）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">_get()</code></strong>: 获取脚本的实际内容（<code class="language-plaintext highlighter-rouge">InlineScript</code> 或 <code class="language-plaintext highlighter-rouge">StoredScriptId</code>）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">isInline()</code></strong>: 判断当前脚本是否为 <code class="language-plaintext highlighter-rouge">Inline</code> 类型。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">inline()</code></strong>: 获取 <code class="language-plaintext highlighter-rouge">Inline</code> 类型的脚本内容。若当前脚本不是 <code class="language-plaintext highlighter-rouge">Inline</code> 类型，将抛出异常。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">isStored()</code></strong>: 判断当前脚本是否为 <code class="language-plaintext highlighter-rouge">Stored</code> 类型。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">stored()</code></strong>: 获取 <code class="language-plaintext highlighter-rouge">Stored</code> 类型的脚本内容。若当前脚本不是 <code class="language-plaintext highlighter-rouge">Stored</code> 类型，将抛出异常。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">serialize()</code></strong>: 将脚本对象序列化为 JSON 格式。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">toString()</code></strong>: 返回脚本的字符串表示，通常为 JSON 格式。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">Builder</code> 类</strong>:</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">inline(InlineScript v)</code></strong>: 设置脚本为 <code class="language-plaintext highlighter-rouge">Inline</code> 类型，并传入 <code class="language-plaintext highlighter-rouge">InlineScript</code> 对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">inline(Function&lt;InlineScript.Builder, ObjectBuilder&lt;InlineScript&gt;&gt; fn)</code></strong>: 使用构建器模式创建 <code class="language-plaintext highlighter-rouge">InlineScript</code> 对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">stored(StoredScriptId v)</code></strong>: 设置脚本为 <code class="language-plaintext highlighter-rouge">Stored</code> 类型，并传入 <code class="language-plaintext highlighter-rouge">StoredScriptId</code> 对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">stored(Function&lt;StoredScriptId.Builder, ObjectBuilder&lt;StoredScriptId&gt;&gt; fn)</code></strong>: 使用构建器模式创建 <code class="language-plaintext highlighter-rouge">StoredScriptId</code> 对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">build()</code></strong>: 构建 <code class="language-plaintext highlighter-rouge">Script</code> 对象。</li>
</ul>

<p><strong>增量更新示例</strong>:
假设你需要增量更新一个 Elasticsearch 文档时使用脚本。以下是如何构建一个 <code class="language-plaintext highlighter-rouge">Script</code> 对象，执行增量更新的示例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设有一个字段 "v"，我们要将它的值增加 1。</span>
<span class="nc">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="nc">Script</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
        <span class="o">.</span><span class="na">inline</span><span class="o">(</span><span class="n">inlineScriptBuilder</span> <span class="o">-&gt;</span> <span class="n">inlineScriptBuilder</span>
                <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"ctx._source.v += params.increment"</span><span class="o">)</span> <span class="c1">// inline 脚本</span>
                <span class="o">.</span><span class="na">params</span><span class="o">(</span><span class="s">"increment"</span><span class="o">,</span>  <span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="c1">// 传递参数</span>
        <span class="o">)</span>
<span class="o">);</span>
<span class="nc">UpdateResponse</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">updateResponse2</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">script</span><span class="o">)</span>
                <span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">True</span><span class="o">)</span>
        <span class="o">,</span><span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">updateResponse2</span><span class="o">.</span><span class="na">result</span><span class="o">());</span>
</code></pre></div></div>
<p>在此示例中，使用了 <code class="language-plaintext highlighter-rouge">Inline</code> 脚本来增量更新 <code class="language-plaintext highlighter-rouge">counter</code> 字段，脚本内容是 <code class="language-plaintext highlighter-rouge">ctx._source.v += params.increment</code>，它表示将 <code class="language-plaintext highlighter-rouge">counter</code> 字段的值增加 <code class="language-plaintext highlighter-rouge">increment</code> 参数的值。</p>

<p><strong><code class="language-plaintext highlighter-rouge">params</code></strong>: 增量更新需要传递参数。在脚本中通过 <code class="language-plaintext highlighter-rouge">params.increment</code> 引用了这个参数，并在构建脚本时传递了实际值 <code class="language-plaintext highlighter-rouge">1</code>。</p>

<p><strong><code class="language-plaintext highlighter-rouge">UpdateRequest</code></strong>: 构建了一个 <code class="language-plaintext highlighter-rouge">UpdateRequest</code> 对象，使用 <code class="language-plaintext highlighter-rouge">Script</code> 执行增量更新。</p>

<p><code class="language-plaintext highlighter-rouge">Script</code> 类用于封装 Elasticsearch 的脚本操作，支持 <code class="language-plaintext highlighter-rouge">Inline</code> 和 <code class="language-plaintext highlighter-rouge">Stored</code> 两种类型的脚本。通过构建器模式，可以动态地设置脚本内容并执行操作。在增量更新场景中，使用 <code class="language-plaintext highlighter-rouge">InlineScript</code> 类型的脚本结合传递参数的方式实现字段值的增量更新。</p>

<p>在 Java 中，<code class="language-plaintext highlighter-rouge">Script</code> 类用于与 Elasticsearch 中的脚本交互，允许你在查询、聚合、更新等操作中使用自定义的脚本。<code class="language-plaintext highlighter-rouge">Script</code> 类支持多种脚本语言，其中 <code class="language-plaintext highlighter-rouge">Painless</code> 是默认和推荐的脚本语言。下面简要介绍常用的脚本语法及其特殊变量，如 <code class="language-plaintext highlighter-rouge">params</code>、<code class="language-plaintext highlighter-rouge">ctx._source</code> 等。</p>

<p><strong>脚本类型（ScriptType）</strong></p>

<p><code class="language-plaintext highlighter-rouge">Script</code> 类支持两种类型的脚本：</p>
<ul>
  <li><strong>INLINE</strong>：直接在查询或操作中内联定义脚本代码。</li>
  <li><strong>STORED</strong>：从已存储的脚本中加载脚本（通常是预先定义并存储在 Elasticsearch 中的脚本）。</li>
</ul>

<p><strong>特殊变量</strong></p>

<p>在 Painless 脚本中，有几个关键的特殊变量用于访问文档数据、查询参数等内容。常见的特殊变量有 <code class="language-plaintext highlighter-rouge">doc</code>、<code class="language-plaintext highlighter-rouge">params</code> 和 <code class="language-plaintext highlighter-rouge">ctx</code>。</p>

<p><strong><code class="language-plaintext highlighter-rouge">doc</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">doc</code> 是一个用于访问文档字段的特殊变量。它允许在脚本中访问文档中的字段值，通常用于获取数值、日期或文本字段的内容。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">doc['field_name'].value</code>：获取字段的值。</li>
  <li><code class="language-plaintext highlighter-rouge">doc['field_name'].size()</code>：获取字段的数组大小。</li>
</ul>

<p><strong>示例：</strong></p>
<pre><code class="language-painless">return doc['price'].value * 1.2;
</code></pre>
<p>这个脚本返回字段 <code class="language-plaintext highlighter-rouge">price</code> 的值乘以 1.2。</p>

<p><strong><code class="language-plaintext highlighter-rouge">params</code></strong>
<code class="language-plaintext highlighter-rouge">params</code> 是一个用于传递脚本参数的特殊变量。它允许将外部参数传递给脚本，从而使脚本更加灵活和动态。<code class="language-plaintext highlighter-rouge">params</code> 是一个 <code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>，其中可以存储多个键值对。</p>

<ul>
  <li>通过 <code class="language-plaintext highlighter-rouge">params['param_name']</code> 访问传入的参数。</li>
</ul>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设有一个字段 "v"，我们要将它的值增加 1。</span>
<span class="nc">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="nc">Script</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
        <span class="o">.</span><span class="na">inline</span><span class="o">(</span><span class="n">inlineScriptBuilder</span> <span class="o">-&gt;</span> <span class="n">inlineScriptBuilder</span>
                <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"ctx._source.v += params.increment"</span><span class="o">)</span> <span class="c1">// inline 脚本</span>
                <span class="o">.</span><span class="na">params</span><span class="o">(</span><span class="s">"increment"</span><span class="o">,</span>  <span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="c1">// 传递参数</span>
        <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>
<p>这里将参数 <code class="language-plaintext highlighter-rouge">1</code> 传递给脚本，在脚本中通过 <code class="language-plaintext highlighter-rouge">params.increment</code> 使用该值。</p>

<p><strong><code class="language-plaintext highlighter-rouge">ctx._source</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">ctx._source</code> 是用于在更新脚本中访问和修改文档源的特殊变量。它代表当前文档的完整源内容（即 <code class="language-plaintext highlighter-rouge">_source</code> 字段），并允许脚本在更新时修改文档的数据。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ctx._source['field_name']</code>：获取或修改文档字段的值。</li>
  <li><code class="language-plaintext highlighter-rouge">ctx._source.remove('field_name')</code>：从文档中删除字段。</li>
</ul>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设有一个字段 "v"，我们要将它的值增加 1。</span>
<span class="nc">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="nc">Script</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
        <span class="o">.</span><span class="na">inline</span><span class="o">(</span><span class="n">inlineScriptBuilder</span> <span class="o">-&gt;</span> <span class="n">inlineScriptBuilder</span>
                <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"ctx._source.v += params.increment"</span><span class="o">)</span> <span class="c1">// inline 脚本</span>
                <span class="o">.</span><span class="na">params</span><span class="o">(</span><span class="s">"increment"</span><span class="o">,</span>  <span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="c1">// 传递参数</span>
        <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>
<p>这个脚本将文档字段 <code class="language-plaintext highlighter-rouge">v</code> 的值增加 <code class="language-plaintext highlighter-rouge">1</code>。</p>

<p><strong><code class="language-plaintext highlighter-rouge">_score</code></strong>
<code class="language-plaintext highlighter-rouge">_score</code> 是一个在查询过程中用于获取当前文档的评分的特殊变量。它可以在自定义评分脚本中使用。</p>

<p><strong>示例：</strong></p>
<pre><code class="language-painless">return _score * 2;  // 将文档评分加倍
</code></pre>

<p><strong><code class="language-plaintext highlighter-rouge">_id</code></strong>
<code class="language-plaintext highlighter-rouge">_id</code> 用于访问文档的唯一标识符。</p>

<p><strong>示例：</strong></p>

<pre><code class="language-painless">return _id;  // 返回文档的ID
</code></pre>

<p><strong>常见脚本语法</strong></p>

<p><strong>数学运算</strong></p>

<p>支持常见的数学运算，如加法、减法、乘法、除法、取余等。</p>

<p><strong>示例：</strong></p>

<pre><code class="language-painless">return doc['price'].value * params.factor + params.offset;
</code></pre>

<p><strong>条件语句</strong></p>

<p>可以使用 <code class="language-plaintext highlighter-rouge">if</code>、<code class="language-plaintext highlighter-rouge">else</code> 进行条件判断。</p>

<p><strong>示例：</strong></p>

<pre><code class="language-painless">if (doc['age'].value &gt; 30) {
    return 'Adult';
} else {
    return 'Youth';
}
</code></pre>

<p><strong>字符串操作</strong>
支持字符串拼接、截取、替换等操作。</p>

<p><strong>示例：</strong></p>

<pre><code class="language-painless">return doc['name'].value + ' - ' + doc['category'].value;
</code></pre>

<p><strong>数组操作</strong></p>

<p>支持操作数组或列表，如获取特定索引的值。</p>

<p><strong>示例：</strong></p>

<pre><code class="language-painless">return params.myList[0];  // 获取列表的第一个元素
</code></pre>

<p><strong>更新脚本</strong>
在文档更新操作中，<code class="language-plaintext highlighter-rouge">Script</code> 类通常与 <code class="language-plaintext highlighter-rouge">ctx._source</code> 一起使用，以便在文档更新时修改其字段值。</p>

<p><strong>示例：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设有一个字段 "v"，我们要将它的值增加 1。</span>
<span class="nc">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="nc">Script</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
        <span class="o">.</span><span class="na">inline</span><span class="o">(</span><span class="n">inlineScriptBuilder</span> <span class="o">-&gt;</span> <span class="n">inlineScriptBuilder</span>
                <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"ctx._source.v += params.increment"</span><span class="o">)</span> <span class="c1">// inline 脚本</span>
                <span class="o">.</span><span class="na">params</span><span class="o">(</span><span class="s">"increment"</span><span class="o">,</span>  <span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="c1">// 传递参数</span>
        <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>
<p>该脚本将文档字段 <code class="language-plaintext highlighter-rouge">v</code> 的值增加 <code class="language-plaintext highlighter-rouge">1</code>。</p>

<p><strong>脚本评分</strong>
在查询中使用脚本进行评分时，<code class="language-plaintext highlighter-rouge">_score</code> 和其他文档字段可以一起参与评分计算。</p>

<p><strong>示例：</strong></p>

<pre><code class="language-painless">Math.log(doc['views'].value + 1) + _score
</code></pre>
<p>这个脚本计算评分时结合了 <code class="language-plaintext highlighter-rouge">views</code> 字段的对数值和原始评分。</p>

<p>总结
在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">Script</code> 类通过 Painless 脚本语言允许在查询、聚合、更新等场景中执行自定义逻辑。常用的特殊变量包括：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">doc</code>：访问文档字段。</li>
  <li><code class="language-plaintext highlighter-rouge">params</code>：传递外部参数给脚本。</li>
  <li><code class="language-plaintext highlighter-rouge">ctx._source</code>：访问并修改文档的源内容（用于更新操作）。</li>
  <li><code class="language-plaintext highlighter-rouge">_score</code>：访问当前文档的评分。</li>
  <li><code class="language-plaintext highlighter-rouge">_id</code>：访问文档的 ID。</li>
</ul>

<p>通过灵活使用这些变量和 Painless 脚本语法，可以实现复杂的数据处理和查询逻辑。</p>

<h3 id="条件更新">条件更新</h3>

<h4 id="updatebyquery"><code class="language-plaintext highlighter-rouge">updateByQuery</code></h4>

<p>在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">updateByQuery</code> 是一种通过查询更新多个文档的方法。与传统的单个文档更新 (<code class="language-plaintext highlighter-rouge">update</code>) 不同，<code class="language-plaintext highlighter-rouge">updateByQuery</code> 允许你对符合查询条件的所有文档应用一个更新脚本。</p>

<p>示例代码解析</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateByQueryResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">updateByQuery</span><span class="o">(</span>
    <span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
          <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">matchAll</span><span class="o">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">m</span><span class="o">))</span>
          <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">script</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p>这段代码的意思是：</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">index("products")</code></strong>: 指定操作的索引为 <code class="language-plaintext highlighter-rouge">"products"</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">query(q -&gt; q.matchAll(m-&gt;m))</code></strong>: 查询条件使用 <code class="language-plaintext highlighter-rouge">matchAll</code>，即匹配所有文档。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">script(script)</code></strong>: 执行脚本来更新匹配的文档，<code class="language-plaintext highlighter-rouge">script</code> 是一个更新脚本，它将应用于所有匹配的文档。</li>
</ol>

<p>代码功能</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">updateByQuery</code></strong>: 这个方法执行一个基于查询的批量更新操作，允许你使用一个查询条件（比如 <code class="language-plaintext highlighter-rouge">matchAll</code> 或其他复杂查询）来选择文档，然后通过脚本对这些文档进行更新。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">script</code></strong>: 更新操作通过脚本完成，脚本可以访问文档的字段并对其进行修改。例如，你可以使用 <code class="language-plaintext highlighter-rouge">painless</code> 脚本来增加、修改或删除字段。</li>
</ul>

<p>典型的 <code class="language-plaintext highlighter-rouge">script</code> 更新示例</p>

<p>假设你希望更新所有 <code class="language-plaintext highlighter-rouge">v</code> 字段等于 123 的产品，将它们的 <code class="language-plaintext highlighter-rouge">v</code> 字段更新为 50。你可以使用以下脚本：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateByQueryResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">updateByQuery</span><span class="o">(</span>
        <span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">matchAll</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">))</span>  <span class="c1">// 使用 matchAll 构建查询条件  // 查询所有文档</span>
                <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span><span class="o">.</span><span class="na">inline</span><span class="o">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">i</span><span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"if (ctx._source.v == 123) { ctx._source.v = 50 }"</span><span class="o">)))</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
</code></pre></div></div>

<p>参数说明</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">index("products")</code></strong>: 指定了目标索引 <code class="language-plaintext highlighter-rouge">"products"</code>，更新操作将在这个索引的文档上执行。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">query(q -&gt; q.matchAll(m-&gt;m))</code></strong>: <code class="language-plaintext highlighter-rouge">matchAll</code> 查询匹配所有文档，你也可以使用其他更复杂的查询，如 <code class="language-plaintext highlighter-rouge">match</code>、<code class="language-plaintext highlighter-rouge">term</code> 等。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">script(script)</code></strong>: 这是更新的核心，通过一个脚本对文档进行修改。在这里，<code class="language-plaintext highlighter-rouge">painless</code> 脚本会检查每个文档的 <code class="language-plaintext highlighter-rouge">v</code> 字段，如果其值等于 123，则将 <code class="language-plaintext highlighter-rouge">v</code> 字段设置为 50。</li>
</ol>

<p>更复杂的查询与脚本</p>

<p>可以根据需要构造更复杂的查询和脚本。例如，查询所有 <code class="language-plaintext highlighter-rouge">status</code> 为 <code class="language-plaintext highlighter-rouge">inactive</code> 且 <code class="language-plaintext highlighter-rouge">last_updated</code> 超过 30 天的文档，并将它们的 <code class="language-plaintext highlighter-rouge">active</code> 字段设置为 <code class="language-plaintext highlighter-rouge">false</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">UpdateByQueryResponse</span> <span class="n">response2</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">updateByQuery</span><span class="o">(</span>
    <span class="n">u</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
                <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">term</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"status"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"inactive"</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"last_updated"</span><span class="o">).</span><span class="na">lt</span><span class="o">(</span><span class="nc">JsonData</span><span class="o">.</span><span class="na">fromJson</span><span class="o">(</span><span class="s">"now-30d/d"</span><span class="o">))))))</span>
        <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span><span class="o">.</span><span class="na">inline</span><span class="o">(</span>
                <span class="n">i</span><span class="o">-&gt;</span><span class="n">i</span><span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"if (ctx._source.status == 'inactive' &amp;&amp; (new Date().getTime() - ctx._source.last_updated) &gt; 2592000000L) { ctx._source.active = false }"</span><span class="o">)))</span>
<span class="o">);</span>
</code></pre></div></div>

<p>主要方法说明</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">index</code></strong>: 指定操作的索引。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">query</code></strong>: 设置更新操作的查询条件。指定哪些文档需要更新，可以是 <code class="language-plaintext highlighter-rouge">matchAll</code>、<code class="language-plaintext highlighter-rouge">term</code> 或其他查询类型。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">script</code></strong>: 设置执行的脚本，脚本可以通过 <code class="language-plaintext highlighter-rouge">ctx._source</code> 来访问文档字段并进行更新。</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">refresh</code></strong>（可选）: 是否在更新后刷新索引，通常用于确保文档立即可见。</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">updateByQuery</code></strong>：允许你通过查询条件批量更新文档。适用于需要批量修改文档的场景。</li>
</ul>

<p>这种方法非常适合用于需要条件更新的批量操作，能够高效地更新大量文档。</p>

<h3 id="删除">删除</h3>

<p>在 Java 中，使用 Elasticsearch 进行数据删除（<code class="language-plaintext highlighter-rouge">delete</code>）主要涉及以下几个类和接口：</p>

<p><strong><code class="language-plaintext highlighter-rouge">DeleteRequest</code> 类</strong>：是删除操作的核心类，表示删除文档的请求。你可以使用它来设置删除操作的目标索引和文档 ID。</p>

<p><strong><code class="language-plaintext highlighter-rouge">DeleteResponse</code> 类</strong>：是 <code class="language-plaintext highlighter-rouge">delete</code> 请求返回的响应类。它包含删除操作的结果，比如是否成功、删除的文档信息等。</p>

<p><strong><code class="language-plaintext highlighter-rouge">DeleteByQueryRequest</code> 类</strong>：如果你想基于查询条件删除多个文档，而不仅仅是单个文档，可以使用 <code class="language-plaintext highlighter-rouge">DeleteByQueryRequest</code> 类。这个类支持通过查询条件删除符合条件的多个文档。</p>

<p><strong><code class="language-plaintext highlighter-rouge">DeleteByQueryResponse</code> 类</strong>：与 <code class="language-plaintext highlighter-rouge">DeleteByQueryRequest</code> 配套的响应类，用于返回 <code class="language-plaintext highlighter-rouge">delete_by_query</code> 操作的结果。它包含删除的文档数量等信息。</p>

<h4 id="deleterequest"><code class="language-plaintext highlighter-rouge">DeleteRequest</code></h4>

<p><code class="language-plaintext highlighter-rouge">DeleteRequest</code> 是 Elasticsearch 中用于执行文档删除操作的请求类，它主要用于指定要删除的文档的索引、文档 ID 以及一些其他的参数。</p>

<p><strong>字段：</strong>
<code class="language-plaintext highlighter-rouge">DeleteRequest</code> 的字段主要用于指定要删除的文档所在的索引和文档 ID。常用的字段如下：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">index</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 要删除文档的索引名称。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">id</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 要删除文档的 ID。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">version</code></strong> (<code class="language-plaintext highlighter-rouge">long</code>): 文档的版本号，用于乐观并发控制（可选）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">versionType</code></strong> (<code class="language-plaintext highlighter-rouge">VersionType</code>): 版本类型，默认是 <code class="language-plaintext highlighter-rouge">VersionType.INTERNAL</code>，可以指定其他类型（如 <code class="language-plaintext highlighter-rouge">VersionType.EXTERNAL</code>）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">routing</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 指定路由值，默认情况下会根据文档 ID 进行路由。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">parent</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 设置父文档的 ID（对于父子文档关系有用）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">timeout</code></strong> (<code class="language-plaintext highlighter-rouge">TimeValue</code>): 设置请求的超时时间。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">refresh</code></strong> (<code class="language-plaintext highlighter-rouge">Boolean</code>): 是否刷新索引以便立即可见（例如：<code class="language-plaintext highlighter-rouge">true</code> 或 <code class="language-plaintext highlighter-rouge">false</code>）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">waitForActiveShards</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 指定在删除请求返回前等待多少个活动分片（例如：<code class="language-plaintext highlighter-rouge">1</code>）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">routing</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 用于路由的值。</li>
</ul>

<hr />

<p><strong>常用方法：</strong></p>

<p><strong>设置索引和文档 ID：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest index(String index)</code>  ：设置删除操作的索引名称。</li>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest id(String id)</code>  ：设置要删除文档的 ID。</li>
</ul>

<p><strong>设置版本控制：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest version(long version)</code> ：设置文档的版本号，适用于乐观锁控制。</li>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest versionType(VersionType versionType)</code> ：设置版本类型（如 <code class="language-plaintext highlighter-rouge">VersionType.INTERNAL</code> 或 <code class="language-plaintext highlighter-rouge">VersionType.EXTERNAL</code>）。</li>
</ul>

<p><strong>设置路由：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest routing(String routing)</code>  ：设置路由值，指定文档的路由策略。</li>
</ul>

<p><strong>设置父文档：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest parent(String parent)</code>  ：设置父文档的 ID（用于父子文档关系）。</li>
</ul>

<p><strong>设置超时：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest timeout(TimeValue timeout)</code> ：设置请求的超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest timeout(String timeout)</code>  ：设置请求的超时时间，字符串形式（如 <code class="language-plaintext highlighter-rouge">"30s"</code>）。</li>
</ul>

<p><strong>设置刷新选项：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy)</code> ：设置刷新策略（例如 <code class="language-plaintext highlighter-rouge">WriteRequest.RefreshPolicy.IMMEDIATE</code>）。</li>
</ul>

<p><strong>设置等待活动分片：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest waitForActiveShards(String waitForActiveShards)</code>：设置在返回之前等待多少个活动分片。</li>
</ul>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DeleteResponse</span> <span class="n">deleteResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">));</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">deleteResponse</span><span class="o">.</span><span class="na">version</span><span class="o">()));</span>
</code></pre></div></div>

<h4 id="deleteresponse"><code class="language-plaintext highlighter-rouge">DeleteResponse</code></h4>

<p><code class="language-plaintext highlighter-rouge">DeleteResponse</code> 是 Elasticsearch 删除请求的响应对象。它用于返回删除操作的结果，包括文档删除的状态、版本号、索引名称等信息。以下是 <code class="language-plaintext highlighter-rouge">DeleteResponse</code> 类的字段和常用方法：</p>

<p><strong>字段：</strong></p>

<p><code class="language-plaintext highlighter-rouge">DeleteResponse</code> 的字段主要用于返回删除操作的相关信息。常用的字段如下：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">result</code></strong> (<code class="language-plaintext highlighter-rouge">DocWriteResponse.Result</code>): 删除操作的结果。可能的值包括：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">DELETED</code>: 删除成功。</li>
      <li><code class="language-plaintext highlighter-rouge">NOT_FOUND</code>: 删除的文档不存在。</li>
      <li><code class="language-plaintext highlighter-rouge">VERSION_CONFLICT</code>: 版本冲突。</li>
      <li><code class="language-plaintext highlighter-rouge">FAILURE</code>: 失败。</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">id</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 被删除文档的 ID。</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">index</code></strong> (<code class="language-plaintext highlighter-rouge">String</code>): 被删除文档所在的索引名称。</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">version</code></strong> (<code class="language-plaintext highlighter-rouge">long</code>): 被删除文档的版本号。</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">shardInfo</code></strong> (<code class="language-plaintext highlighter-rouge">ShardInfo</code>): 执行删除操作的分片信息，包含了请求处理的分片数量、失败的分片数量等信息。</li>
</ul>

<p><strong>常用方法：</strong></p>

<p><strong>获取删除结果：</strong>，<strong><code class="language-plaintext highlighter-rouge">result()</code></strong> ，获取删除操作的结果，返回值为 <code class="language-plaintext highlighter-rouge">Result</code> 类型，可能的结果包括：</p>

<p><strong>获取文档 ID：</strong>，<strong><code class="language-plaintext highlighter-rouge">id()</code></strong>，获取已删除文档的 ID。</p>

<p><strong>获取索引名称：</strong>，<strong><code class="language-plaintext highlighter-rouge">index()</code></strong>，获取已删除文档所在的索引名称。</p>

<p><strong>获取文档版本号：</strong>，<strong><code class="language-plaintext highlighter-rouge">version()</code></strong> ， 获取已删除文档的版本号。</p>

<p><strong>获取分片信息：</strong>，<strong><code class="language-plaintext highlighter-rouge">shards()</code></strong> ，获取执行删除操作的分片信息，返回 <code class="language-plaintext highlighter-rouge">ShardInfo</code> 对象，包含有关分片的信息，例如成功处理的分片数量、失败的分片数量等。</p>

<p><strong>获取操作执行的分片数量：</strong>，<strong><code class="language-plaintext highlighter-rouge">shards().total()</code></strong>  ，获取执行删除操作时，参与处理的总分片数量。</p>

<p><strong>获取失败的分片数量：</strong>，<strong><code class="language-plaintext highlighter-rouge">shards().failed()</code></strong>  ，获取在执行删除操作时，失败的分片数量。</p>

<p><strong>获取失败的分片信息：</strong>，<strong><code class="language-plaintext highlighter-rouge">shards().failures()</code></strong>  ，获取失败的分片的详细信息，返回一个 <code class="language-plaintext highlighter-rouge">List&lt;ShardFailure&gt;</code>，包含失败的原因和其他信息。</p>

<p><strong>示例代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DeleteResponse</span> <span class="n">deleteResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">d</span> <span class="o">-&gt;</span> <span class="n">d</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">));</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">deleteResponse</span><span class="o">.</span><span class="na">version</span><span class="o">()));</span>


<span class="c1">// 获取删除操作的结果</span>
<span class="nc">Result</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">deleteResponse</span><span class="o">.</span><span class="na">result</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Delete result: "</span> <span class="o">+</span> <span class="n">result1</span><span class="o">);</span>

<span class="c1">// 获取被删除文档的 ID</span>
<span class="nc">String</span> <span class="n">docId</span> <span class="o">=</span> <span class="n">deleteResponse</span><span class="o">.</span><span class="na">id</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted document ID: "</span> <span class="o">+</span> <span class="n">docId</span><span class="o">);</span>

<span class="c1">// 获取文档所在的索引名称</span>
<span class="nc">String</span> <span class="n">index</span> <span class="o">=</span> <span class="n">deleteResponse</span><span class="o">.</span><span class="na">index</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Document index: "</span> <span class="o">+</span> <span class="n">index</span><span class="o">);</span>

<span class="c1">// 获取文档的版本号</span>
<span class="kt">long</span> <span class="n">version</span> <span class="o">=</span> <span class="n">deleteResponse</span><span class="o">.</span><span class="na">version</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted document version: "</span> <span class="o">+</span> <span class="n">version</span><span class="o">);</span>

<span class="c1">// 获取分片信息</span>
<span class="nc">ShardStatistics</span> <span class="n">shards</span> <span class="o">=</span> <span class="n">deleteResponse</span><span class="o">.</span><span class="na">shards</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Shard info: "</span> <span class="o">+</span> <span class="n">shards</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total shards: "</span> <span class="o">+</span> <span class="n">shards</span><span class="o">.</span><span class="na">total</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Failed shards: "</span> <span class="o">+</span> <span class="n">shards</span><span class="o">.</span><span class="na">failed</span><span class="o">());</span>

<span class="c1">// 如果有失败的分片，可以查看失败的具体信息</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ShardFailure</span><span class="o">&gt;</span> <span class="n">failures1</span> <span class="o">=</span> <span class="n">shards</span><span class="o">.</span><span class="na">failures</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">ShardFailure</span> <span class="n">failure</span> <span class="o">:</span> <span class="n">failures1</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Failure reason: "</span> <span class="o">+</span> <span class="n">failure</span><span class="o">.</span><span class="na">reason</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="delete"><code class="language-plaintext highlighter-rouge">delete()</code></h4>

<p>在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">esClient.delete</code> 方法用于删除文档。该方法有几个常见的变体和参数，下面列出了这些变体及其相关说明。</p>

<p><strong><code class="language-plaintext highlighter-rouge">delete(DeleteRequest request)</code></strong> 方法：</p>

<p><strong>功能</strong>：根据传入的 <code class="language-plaintext highlighter-rouge">DeleteRequest</code> 对象来删除文档。
<strong>参数</strong>：<code class="language-plaintext highlighter-rouge">DeleteRequest request</code></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest</code> 是一个包含删除文档所需信息的对象。</li>
  <li>它通常需要指定以下内容：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">index</code>：要删除文档的索引名称。</li>
      <li><code class="language-plaintext highlighter-rouge">id</code>：要删除文档的 ID。</li>
      <li><code class="language-plaintext highlighter-rouge">routing</code>：指定文档的路由（可选）。</li>
      <li><code class="language-plaintext highlighter-rouge">version</code>：指定文档的版本（可选，用于版本控制，避免删除不同版本的文档）。</li>
      <li><code class="language-plaintext highlighter-rouge">versionType</code>：版本控制的类型（可选）。</li>
    </ul>
  </li>
</ul>

<p><strong>返回值</strong>：返回一个 <code class="language-plaintext highlighter-rouge">DeleteResponse</code> 对象，包含删除操作的结果。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DeleteRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeleteRequest</span><span class="o">(</span><span class="s">"index_name"</span><span class="o">,</span> <span class="s">"doc_id"</span><span class="o">);</span>
<span class="nc">DeleteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">delete(Function&lt;DeleteRequest.Builder, ObjectBuilder&lt;DeleteRequest&gt;&gt; fn)</code></strong> 方法：</p>

<p><strong>功能</strong>：使用一个函数式编程风格的构建器来创建 <code class="language-plaintext highlighter-rouge">DeleteRequest</code> 对象，并执行删除操作。
<strong>参数</strong>：一个函数 <code class="language-plaintext highlighter-rouge">fn</code>，该函数将一个 <code class="language-plaintext highlighter-rouge">DeleteRequest.Builder</code> 转换为 <code class="language-plaintext highlighter-rouge">DeleteRequest</code> 对象。</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DeleteRequest.Builder</code> 是用于构建 <code class="language-plaintext highlighter-rouge">DeleteRequest</code> 对象的构建器。</li>
</ul>

<p><strong>返回值</strong>：返回一个 <code class="language-plaintext highlighter-rouge">DeleteResponse</code> 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DeleteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"index_name"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"doc_id"</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">DeleteRequest</code> 类的常用字段和方法：</strong></p>

<p><code class="language-plaintext highlighter-rouge">DeleteRequest</code> 是一个用于表示删除文档请求的类，常用字段和方法包括：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">index</code></strong>：文档所在的索引名称。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">id</code></strong>：要删除文档的 ID。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">routing</code></strong>：路由（可选），用于指定文档的路由。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">version</code></strong>：文档的版本（可选），用于版本控制。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">versionType</code></strong>：版本控制类型（可选），例如 <code class="language-plaintext highlighter-rouge">internal</code> 或 <code class="language-plaintext highlighter-rouge">external</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">timeout</code></strong>：操作超时（可选）。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DeleteRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DeleteRequest</span><span class="o">(</span><span class="s">"index_name"</span><span class="o">,</span> <span class="s">"doc_id"</span><span class="o">);</span>
<span class="n">request</span><span class="o">.</span><span class="na">routing</span><span class="o">(</span><span class="s">"routing_value"</span><span class="o">);</span>
<span class="n">request</span><span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
<span class="n">request</span><span class="o">.</span><span class="na">versionType</span><span class="o">(</span><span class="nc">VersionType</span><span class="o">.</span><span class="na">INTERNAL</span><span class="o">);</span>
<span class="nc">DeleteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">DeleteResponse</code> 类的常用字段和方法：</strong></p>

<p><code class="language-plaintext highlighter-rouge">DeleteResponse</code> 是删除操作的响应对象，常用字段和方法包括：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">getResult()</code></strong>：获取删除操作的结果，例如 <code class="language-plaintext highlighter-rouge">DELETED</code> 或 <code class="language-plaintext highlighter-rouge">NOT_FOUND</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getId()</code></strong>：获取删除文档的 ID。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getIndex()</code></strong>：获取删除文档的索引名称。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getVersion()</code></strong>：获取删除文档的版本号。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getShardInfo()</code></strong>：获取与删除操作相关的分片信息。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DeleteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getResult</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// 获取删除结果</span>
<span class="nc">String</span> <span class="n">docId</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span> <span class="c1">// 获取文档 ID</span>
</code></pre></div></div>

<p>总结：</p>

<p><code class="language-plaintext highlighter-rouge">esClient.delete</code> 方法有两种主要的调用方式：</p>
<ol>
  <li><strong>直接传递 <code class="language-plaintext highlighter-rouge">DeleteRequest</code> 对象</strong>：适用于已经创建好的删除请求对象。</li>
  <li><strong>使用构建器模式</strong>：通过一个函数来构建 <code class="language-plaintext highlighter-rouge">DeleteRequest</code> 对象。</li>
</ol>

<p>通过这两种方式，你可以灵活地删除文档并获取删除操作的响应结果。如果需要，删除请求可以包含路由、版本控制、超时等其他参数，响应则包含删除的结果、文档 ID、索引名和版本号等信息。</p>

<h3 id="条件删除">条件删除</h3>

<p>类似条件更新。</p>

<h3 id="查询">查询</h3>

<p>使用 Elasticsearch 客户端发送 HTTP Post请求 <code class="language-plaintext highlighter-rouge">/products/_search</code> 查询数据，得到类似如下结果：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"_shards"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"failed"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"skipped"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="nl">"successful"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nl">"total"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"hits"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"hits"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="w">
        </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bk-1"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"_index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"products"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"_score"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
        </span><span class="nl">"_source"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"cityBike"</span><span class="p">:</span><span class="w"> </span><span class="s2">"City bike"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"sku"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bk-1"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"v"</span><span class="p">:</span><span class="w"> </span><span class="mi">123</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"max_score"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nl">"total"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"relation"</span><span class="p">:</span><span class="w"> </span><span class="s2">"eq"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"value"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"timed_out"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
  </span><span class="nl">"took"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这个 JSON 响应是来自 Elasticsearch 搜索请求的结果。它包含了有关查询执行情况以及返回的文档的详细信息。以下是各个字段的解释：</p>

<p><code class="language-plaintext highlighter-rouge">_shards</code> 部分描述了 Elasticsearch 执行搜索请求时的分片（shard）状态。Elasticsearch 将数据存储在多个分片中，因此此部分提供了请求在分片上执行的结果。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">failed</code>：表示查询过程中失败的分片数量（在这个例子中是 0，表示没有失败的分片）。</li>
  <li><code class="language-plaintext highlighter-rouge">skipped</code>：表示跳过的分片数量（在这个例子中是 0，表示没有跳过分片）。</li>
  <li><code class="language-plaintext highlighter-rouge">successful</code>：表示成功执行查询的分片数量（在这个例子中是 1，表示有一个分片成功执行）。</li>
  <li><code class="language-plaintext highlighter-rouge">total</code>：表示总共的分片数量（在这个例子中是 1，表示只有一个分片）。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">hits</code>部分包含了查询的匹配结果，包括每个匹配文档的信息。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hits</code>: 一个数组，包含了所有符合查询条件的文档。在这个例子中，只有一个文档符合条件。</li>
  <li><code class="language-plaintext highlighter-rouge">max_score</code>: 表示查询结果中最高的评分（<code class="language-plaintext highlighter-rouge">_score</code>），用来衡量文档与查询条件的匹配度。在这个例子中，<code class="language-plaintext highlighter-rouge">max_score</code> 是 1，表示评分最高的文档的得分为 1。</li>
  <li><code class="language-plaintext highlighter-rouge">total</code>: 这是符合查询条件的文档总数。<code class="language-plaintext highlighter-rouge">relation: "eq"</code> 表示查询结果是“等于”的关系，<code class="language-plaintext highlighter-rouge">value: 1</code> 表示查询返回了 1 个符合条件的文档。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">_id</code>, <code class="language-plaintext highlighter-rouge">_index</code>, <code class="language-plaintext highlighter-rouge">_score</code>, <code class="language-plaintext highlighter-rouge">_source</code>,这些字段描述了每个文档的具体信息。</p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_id</code>: 该字段表示文档的唯一标识符。在这个例子中，文档的 <code class="language-plaintext highlighter-rouge">_id</code> 是 <code class="language-plaintext highlighter-rouge">"bk-1"</code>。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_index</code>: 该字段表示文档所在的索引。在这个例子中，文档存储在 <code class="language-plaintext highlighter-rouge">"products"</code> 索引中。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_score</code>: 这是文档的相关性评分（在 Elasticsearch 中通常用于衡量文档与查询条件的匹配度）。此值在这里为 <code class="language-plaintext highlighter-rouge">1</code>，表示该文档完全匹配查询。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">_source</code>: 这是实际存储在 Elasticsearch 中的文档内容。在这个例子中，文档的内容如下：</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">"cityBike": "City bike"</code>：表示该文档的 <code class="language-plaintext highlighter-rouge">cityBike</code> 字段值为 <code class="language-plaintext highlighter-rouge">"City bike"</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">"sku": "bk-1"</code>：表示该文档的 <code class="language-plaintext highlighter-rouge">sku</code> 字段值为 <code class="language-plaintext highlighter-rouge">"bk-1"</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">"v": 123</code>：表示该文档的 <code class="language-plaintext highlighter-rouge">v</code> 字段值为 <code class="language-plaintext highlighter-rouge">123</code>。</li>
    </ul>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">timed_out</code>,表示查询是否超时。在这个例子中，它是 <code class="language-plaintext highlighter-rouge">false</code>，意味着查询没有超时。</p>

<p><code class="language-plaintext highlighter-rouge">took</code>,表示查询花费的时间（单位是毫秒）。在这个例子中，<code class="language-plaintext highlighter-rouge">took</code> 是 <code class="language-plaintext highlighter-rouge">2</code>，表示查询的执行时间为 2 毫秒。</p>

<p>这个 JSON 响应的结构反映了一个 Elasticsearch 查询的结果，包含了以下主要部分：</p>

<ul>
  <li><strong>分片执行状态</strong>（<code class="language-plaintext highlighter-rouge">_shards</code>）：查询执行的成功和失败情况。</li>
  <li><strong>查询结果</strong>（<code class="language-plaintext highlighter-rouge">hits</code>）：匹配查询条件的文档。</li>
  <li><strong>查询性能</strong>：如查询时间和是否超时。</li>
</ul>

<p>在该示例中，查询成功返回了一个文档，文档的内容包括字段 <code class="language-plaintext highlighter-rouge">cityBike</code>, <code class="language-plaintext highlighter-rouge">sku</code>, 和 <code class="language-plaintext highlighter-rouge">v</code>，并且查询执行速度很快（2 毫秒）。</p>

<hr />

<p>在 Elasticsearch 中，默认情况下，<code class="language-plaintext highlighter-rouge">Search</code> 查询返回的文档数量是 10 条。这是 Elasticsearch 的分页机制（<code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code>）的一部分。要返回更多的数据，你需要显式地设置查询的 <code class="language-plaintext highlighter-rouge">size</code> 参数。</p>

<p>Java代码实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"v"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="mi">50</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
                <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span>
        <span class="nc">Map</span><span class="o">.</span><span class="na">class</span>
<span class="o">);</span>
<span class="nc">HitsMetadata</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">hits</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">hits</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">hits</span><span class="o">.</span><span class="na">hits</span><span class="o">().</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Hit:</span><span class="o">:</span><span class="n">source</span><span class="o">).</span><span class="na">toList</span><span class="o">();</span>
<span class="n">collect</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>这段代码演示了如何在 Elasticsearch 中执行一个简单的搜索查询，获取结果并处理。下面是对每个部分的详细解释：</p>

<p><strong><code class="language-plaintext highlighter-rouge">SearchResponse&lt;Map&gt; response = esClient.search(...)</code></strong>：
这是一个用于执行搜索查询的调用，返回一个 <code class="language-plaintext highlighter-rouge">SearchResponse</code> 对象，其中 <code class="language-plaintext highlighter-rouge">Map</code> 是查询结果的类型。通过这段代码，应用将查询 Elasticsearch 索引并获取匹配的结果。</p>

<p>参数解释：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">builder -&gt; builder.index("products")</code></strong>：指定查询的目标索引为 <code class="language-plaintext highlighter-rouge">products</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">.query(q -&gt; q.match(m -&gt; m.field("v").query(50)))</code></strong>：
    <ul>
      <li>这里使用了 <code class="language-plaintext highlighter-rouge">match</code> 查询来查找字段 <code class="language-plaintext highlighter-rouge">v</code> 的值为 <code class="language-plaintext highlighter-rouge">50</code> 的文档。</li>
      <li><code class="language-plaintext highlighter-rouge">field("v")</code> 指定字段名为 <code class="language-plaintext highlighter-rouge">v</code>，<code class="language-plaintext highlighter-rouge">query(50)</code> 表示查询值为 <code class="language-plaintext highlighter-rouge">50</code> 的文档。</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">.size(10)</code></strong>：限制查询结果返回的文档数目为 10。</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">.from(0)</code></strong>：指定查询结果的起始位置为 <code class="language-plaintext highlighter-rouge">0</code>（即从第一个文档开始返回）。通常用于分页查询。</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Map.class</code></strong>：指定返回的结果类型为 <code class="language-plaintext highlighter-rouge">Map</code>。<code class="language-plaintext highlighter-rouge">Map</code> 表示一个无类型约束的键值对集合（通常为 <code class="language-plaintext highlighter-rouge">String</code> 对应字段名称，<code class="language-plaintext highlighter-rouge">Object</code> 对应字段值），这里每个文档的内容将作为 <code class="language-plaintext highlighter-rouge">Map</code> 对象返回。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">HitsMetadata&lt;Map&gt; hits = response.hits();</code></strong>：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">response.hits()</code></strong>：从 <code class="language-plaintext highlighter-rouge">SearchResponse</code> 对象中提取出 <code class="language-plaintext highlighter-rouge">HitsMetadata</code>，其中包含了查询返回的所有文档的详细信息。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">HitsMetadata&lt;Map&gt;</code></strong>：<code class="language-plaintext highlighter-rouge">HitsMetadata</code> 是一个包含了多条匹配文档的元数据的类，<code class="language-plaintext highlighter-rouge">Map</code> 类型的 <code class="language-plaintext highlighter-rouge">hits</code> 表示每个文档的内容都将被当作 <code class="language-plaintext highlighter-rouge">Map</code> 对象来处理。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">List&lt;Map&gt; collect = hits.hits().stream().map(Hit::source).toList();</code></strong>：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">hits.hits()</code></strong>：获取包含查询结果文档的列表（每个文档用 <code class="language-plaintext highlighter-rouge">Hit</code> 对象表示）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">.stream()</code></strong>：将 <code class="language-plaintext highlighter-rouge">hits.hits()</code> 转换为流（stream）以便进行进一步的操作。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">.map(Hit::source)</code></strong>：<code class="language-plaintext highlighter-rouge">Hit::source</code> 是一个方法引用，表示从每个 <code class="language-plaintext highlighter-rouge">Hit</code> 对象中提取文档内容（即文档的 <code class="language-plaintext highlighter-rouge">_source</code> 部分）。这个方法返回一个 <code class="language-plaintext highlighter-rouge">Map</code> 对象，包含了文档的字段和值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">.toList()</code></strong>：将流中的所有 <code class="language-plaintext highlighter-rouge">Map</code> 对象收集到一个列表中，最终得到包含所有查询结果文档内容的列表。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">collect.forEach(System.out::println);</code></strong>：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">forEach(System.out::println)</code></strong>：对 <code class="language-plaintext highlighter-rouge">collect</code> 列表中的每一个元素（即每一个 <code class="language-plaintext highlighter-rouge">Map</code> 对象）执行 <code class="language-plaintext highlighter-rouge">println</code> 输出操作，逐个打印出查询结果文档的内容。</li>
</ul>

<p>这段代码执行了一个查询，查找索引 <code class="language-plaintext highlighter-rouge">products</code> 中字段 <code class="language-plaintext highlighter-rouge">v</code> 的值为 <code class="language-plaintext highlighter-rouge">50</code> 的文档。返回的每个文档的内容被当作 <code class="language-plaintext highlighter-rouge">Map</code> 对象处理，并且将查询结果中的每个文档内容打印出来。这个代码的核心流程包括：</p>
<ol>
  <li>使用 <code class="language-plaintext highlighter-rouge">esClient.search</code> 执行查询。</li>
  <li>提取查询结果中的文档。</li>
  <li>将每个文档内容提取为 <code class="language-plaintext highlighter-rouge">Map</code> 并收集到一个列表中。</li>
  <li>将结果列表打印出来。</li>
</ol>

<p>执行该查询后，控制台将打印出满足条件（<code class="language-plaintext highlighter-rouge">v = 50</code>）的文档内容。</p>

<h4 id="searchrequest"><code class="language-plaintext highlighter-rouge">SearchRequest</code></h4>

<p><code class="language-plaintext highlighter-rouge">SearchRequest</code> 是 Elasticsearch Java 客户端中用于构建和执行搜索查询的请求对象。以下是 <code class="language-plaintext highlighter-rouge">SearchRequest</code> 类中的主要字段和方法：</p>

<p><strong>主要字段：</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">index</code></strong>：类型：<code class="language-plaintext highlighter-rouge">String[]</code>，指定搜索的索引名称。如果多个索引需要查询，可以传递索引数组。</p>

<p><strong><code class="language-plaintext highlighter-rouge">types</code></strong>（已废弃，建议不再使用）：类型：<code class="language-plaintext highlighter-rouge">String[]</code>，指定查询的类型。在 Elasticsearch 7.x 之后，类型已经被弃用，通常不再使用。</p>

<p><strong><code class="language-plaintext highlighter-rouge">query</code></strong>：类型：<code class="language-plaintext highlighter-rouge">Query</code>，指定搜索查询的主体，通常是一个查询 DSL（如 <code class="language-plaintext highlighter-rouge">match</code>、<code class="language-plaintext highlighter-rouge">term</code> 等）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">size</code></strong>： 类型：<code class="language-plaintext highlighter-rouge">int</code>，默认值：<code class="language-plaintext highlighter-rouge">10</code>，指定要返回的最大结果数。</p>

<p><strong><code class="language-plaintext highlighter-rouge">from</code></strong>：类型：<code class="language-plaintext highlighter-rouge">int</code>， 默认值：<code class="language-plaintext highlighter-rouge">0</code>，指定查询结果的起始偏移量，通常用于分页。</p>

<p><strong><code class="language-plaintext highlighter-rouge">sort</code></strong>：类型：<code class="language-plaintext highlighter-rouge">SortBuilder[]</code>，指定结果排序方式，可以根据字段或自定义排序进行排序。</p>

<p><strong><code class="language-plaintext highlighter-rouge">source</code></strong>：类型：<code class="language-plaintext highlighter-rouge">SourceBuilder</code>，控制 <code class="language-plaintext highlighter-rouge">_source</code> 字段的输出，允许配置字段筛选（包括 <code class="language-plaintext highlighter-rouge">includes</code> 和 <code class="language-plaintext highlighter-rouge">excludes</code>）等。</p>

<p><strong><code class="language-plaintext highlighter-rouge">trackTotalHits</code></strong>：类型：<code class="language-plaintext highlighter-rouge">boolean</code>，默认值：<code class="language-plaintext highlighter-rouge">true</code>，指定是否在返回的结果中包含总命中数。设置为 <code class="language-plaintext highlighter-rouge">false</code> 可以提高性能。</p>

<p><strong><code class="language-plaintext highlighter-rouge">aggregations</code></strong>：类型：<code class="language-plaintext highlighter-rouge">AggregationBuilder</code>，用于指定聚合查询，允许执行如 <code class="language-plaintext highlighter-rouge">terms</code>、<code class="language-plaintext highlighter-rouge">range</code> 等聚合操作。</p>

<p><strong><code class="language-plaintext highlighter-rouge">highlight</code></strong>：类型：<code class="language-plaintext highlighter-rouge">HighlightBuilder</code>，用于指定高亮显示的字段。</p>

<p><strong><code class="language-plaintext highlighter-rouge">suggest</code></strong>：类型：<code class="language-plaintext highlighter-rouge">SuggestBuilder</code>，指定搜索建议（suggest）操作。</p>

<p><strong>主要方法：</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">index(String... index)</code></strong>：设置要查询的索引名称。可以使用一个或多个索引名称。</p>

<p><strong><code class="language-plaintext highlighter-rouge">query(QueryBuilder query)</code></strong>：设置查询条件，<code class="language-plaintext highlighter-rouge">query</code> 是一个 <code class="language-plaintext highlighter-rouge">QueryBuilder</code> 对象，可以是各种类型的查询（如 <code class="language-plaintext highlighter-rouge">match</code>、<code class="language-plaintext highlighter-rouge">term</code>）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">size(int size)</code></strong>：设置返回的最大文档数。</p>

<p><strong><code class="language-plaintext highlighter-rouge">from(int from)</code></strong>：设置查询结果的偏移量，用于分页。</p>

<p><strong><code class="language-plaintext highlighter-rouge">sort(SortBuilder... sort)</code></strong>：设置查询结果的排序规则。</p>

<p><strong><code class="language-plaintext highlighter-rouge">trackTotalHits(boolean trackTotalHits)</code></strong>：设置是否跟踪总命中数。</p>

<p><strong><code class="language-plaintext highlighter-rouge">source(SourceBuilder source)</code></strong>：设置 <code class="language-plaintext highlighter-rouge">_source</code> 字段的筛选条件，控制返回的字段内容。</p>

<p><strong><code class="language-plaintext highlighter-rouge">aggregations(Map&lt;String, AggregationBuilder&gt; aggregations)</code></strong>：设置聚合操作。可以通过键值对形式指定多个聚合操作。</p>

<p><strong><code class="language-plaintext highlighter-rouge">highlight(HighlightBuilder highlight)</code></strong>：设置高亮显示的字段。</p>

<p><strong><code class="language-plaintext highlighter-rouge">suggest(SuggestBuilder suggest)</code></strong>：设置查询建议，主要用于拼写建议或搜索建议。</p>

<p><strong><code class="language-plaintext highlighter-rouge">explain(boolean explain)</code></strong>：设置是否返回查询的详细评分解释。</p>

<p><strong><code class="language-plaintext highlighter-rouge">profile(boolean profile)</code></strong>：设置是否启用性能分析，以帮助理解查询执行的详细情况。</p>

<p><code class="language-plaintext highlighter-rouge">SearchRequest</code> 是构建和执行 Elasticsearch 查询的核心对象，它允许设置查询的索引、查询条件、分页参数、排序、聚合等。通过对 <code class="language-plaintext highlighter-rouge">SearchSourceBuilder</code> 进行构造，能够进一步指定查询的细节。</p>

<hr />

<h4 id="searchresponse"><code class="language-plaintext highlighter-rouge">SearchResponse</code></h4>

<p>在 Elasticsearch 8.x 中，<code class="language-plaintext highlighter-rouge">SearchResponse</code> 类是一个封装了搜索结果的对象，包含了搜索查询的响应信息。它继承自 <code class="language-plaintext highlighter-rouge">BaseResponse</code> 类，并提供了多个字段和方法来处理搜索结果。</p>

<p>主要字段：</p>

<p><strong><code class="language-plaintext highlighter-rouge">hits</code></strong>，类型：<code class="language-plaintext highlighter-rouge">SearchHits</code>，表示搜索到的所有命中的文档。通过这个字段可以访问所有匹配的文档，以及它们的得分、排序等信息。</p>

<p><strong><code class="language-plaintext highlighter-rouge">aggregations</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Aggregations</code>，包含聚合结果。聚合是 Elasticsearch 提供的一种强大功能，用于对数据进行分组、求和、平均等操作。</p>

<p><strong><code class="language-plaintext highlighter-rouge">suggest</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;Suggest.Suggestion&lt;T&gt;&gt;&gt;</code>，包含搜索建议（如果查询使用了建议功能）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">scrollId</code></strong>，类型：<code class="language-plaintext highlighter-rouge">String</code>，在使用滚动查询时，返回一个 scrollId，用于获取接下来的结果。</p>

<p><strong><code class="language-plaintext highlighter-rouge">took</code></strong>，类型：<code class="language-plaintext highlighter-rouge">long</code>，表示执行查询所花费的时间（单位：毫秒）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">timedOut</code></strong>，类型：<code class="language-plaintext highlighter-rouge">boolean</code>，表示搜索是否超时。</p>

<p><strong><code class="language-plaintext highlighter-rouge">shards</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Shards</code>，包含搜索过程中涉及的所有分片的信息。</p>

<p><strong><code class="language-plaintext highlighter-rouge">total</code></strong>，类型：<code class="language-plaintext highlighter-rouge">long</code>，表示查询匹配的文档总数。</p>

<p><strong><code class="language-plaintext highlighter-rouge">failedShards</code></strong>，类型：<code class="language-plaintext highlighter-rouge">List&lt;FailedShard&gt;</code>，表示查询过程中失败的分片信息。</p>

<p>主要方法：与字段同名。</p>

<p>这些字段和方法提供了对 Elasticsearch 搜索响应的全面访问，能够让你获取查询结果、聚合结果、建议、执行时间等重要信息。</p>

<hr />

<h4 id="hitsmetadata"><code class="language-plaintext highlighter-rouge">HitsMetadata</code></h4>

<p>在 Elasticsearch 8.x 中，<code class="language-plaintext highlighter-rouge">HitsMetadata</code> 是一个用来表示搜索结果元数据的类，主要用于封装搜索命中的元信息，如文档的 <code class="language-plaintext highlighter-rouge">_id</code>、得分（score）、排序等。它是 <code class="language-plaintext highlighter-rouge">SearchHits</code> 中 <code class="language-plaintext highlighter-rouge">Hits</code> 数组中单个命中的元数据。</p>

<p>主要字段：
<strong><code class="language-plaintext highlighter-rouge">_id</code></strong>，类型：<code class="language-plaintext highlighter-rouge">String</code>，文档的唯一标识符，即 <code class="language-plaintext highlighter-rouge">_id</code> 字段。</p>

<p><strong><code class="language-plaintext highlighter-rouge">_index</code></strong>，类型：<code class="language-plaintext highlighter-rouge">String</code>，文档所在的索引名称。</p>

<p><strong><code class="language-plaintext highlighter-rouge">_score</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Float</code>，文档的得分，表示该文档与查询条件的匹配度。</p>

<p><strong><code class="language-plaintext highlighter-rouge">_source</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>，文档的原始数据（即 <code class="language-plaintext highlighter-rouge">_source</code> 字段），它是存储在 Elasticsearch 中的实际内容。</p>

<p><strong><code class="language-plaintext highlighter-rouge">_routing</code></strong>，类型：<code class="language-plaintext highlighter-rouge">String</code>，路由信息，用于确定文档所在的分片（如果启用了路由）。</p>

<p><strong><code class="language-plaintext highlighter-rouge">_version</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Long</code>，文档的版本号，适用于启用了版本控制的索引。</p>

<p><strong><code class="language-plaintext highlighter-rouge">fields</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;Object&gt;&gt;</code>，存储查询时请求的字段值。如果在查询中指定了返回特定字段，那么这些字段将包含在 <code class="language-plaintext highlighter-rouge">fields</code> 中。</p>

<p><strong><code class="language-plaintext highlighter-rouge">highlight</code></strong>，类型：<code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;String&gt;&gt;</code>，高亮显示的字段，如果查询中使用了高亮功能。</p>

<p><strong><code class="language-plaintext highlighter-rouge">sort</code></strong>，类型：<code class="language-plaintext highlighter-rouge">List&lt;Object&gt;</code>，文档的排序值。如果查询使用了排序功能，<code class="language-plaintext highlighter-rouge">sort</code> 字段中将包含排序后的结果。</p>

<p><strong><code class="language-plaintext highlighter-rouge">hits</code></strong>,类型：<code class="language-plaintext highlighter-rouge">List&lt;Hit&lt;T&gt;&gt;</code>,用于嵌套查询的内嵌命中结果（例如，nested 查询或子查询的结果）。如果查询包含嵌套或子查询，<code class="language-plaintext highlighter-rouge">hits</code> 将包含这些结果。</p>

<p>主要方法：与字段同名。</p>

<p><code class="language-plaintext highlighter-rouge">HitsMetadata</code> 类是用于封装 Elasticsearch 查询结果中的单个命中文档的元数据。它提供了文档的基本信息，如 ID、索引、得分等，并支持获取高亮、排序、字段等附加信息。通过这些字段和方法，您可以方便地处理和访问查询结果中的各种数据。</p>

<h4 id="hit"><code class="language-plaintext highlighter-rouge">Hit</code></h4>

<p>这是一个 Elasticsearch 查询返回结果的表示类，通常用于存储从 Elasticsearch 中查询到的单个文档的信息。该类可以包含多个字段，包括文档 ID、索引、得分、字段内容、内嵌查询结果、排序信息等。</p>

<p>主要字段解释：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">index</code></strong>: 返回文档所在的索引名称。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">id</code></strong>: 返回文档的 ID。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">score</code></strong>: 查询得分，通常是相关性评分，表示文档与查询的匹配度。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">explanation</code></strong>: 查询解释，包含如何计算得分的信息。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fields</code></strong>: 文档的字段数据，这些字段是额外的自定义字段（通常是 <code class="language-plaintext highlighter-rouge">_source</code> 之外的字段）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">highlight</code></strong>: 高亮显示的字段，用于标明查询中匹配的部分。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">innerHits</code></strong>: 内嵌查询的结果，用于查询包含子文档的情况。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">matchedQueries</code></strong>: 匹配到的查询条件。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">nested</code></strong>: 如果文档是嵌套类型，包含嵌套文档的信息。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ignored</code></strong>: 被忽略的字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ignoredFieldValues</code></strong>: 被忽略字段的具体值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">shard</code></strong>: 该文档所在的分片。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">node</code></strong>: 存储该文档的 Elasticsearch 节点。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">routing</code></strong>: 路由信息，帮助确定文档所在的分片。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">source</code></strong>: 文档的源数据，通常是原始的 JSON 数据。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">seqNo</code></strong>: 文档的序列号。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">primaryTerm</code></strong>: 文档的主版本号。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">version</code></strong>: 文档的版本号。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">sort</code></strong>: 排序信息，记录文档的排序字段。</li>
</ul>

<p>如果你需要查询某些文档并获取它们的结果，你可以使用 <code class="language-plaintext highlighter-rouge">Hit</code> 类来表示这些文档：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchRequest</span> <span class="n">searchRequest</span> <span class="o">=</span> <span class="nc">SearchRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
        <span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"elasticsearch"</span><span class="o">))</span>  <span class="c1">// 查询条件：匹配 'title' 字段</span>
    <span class="o">)</span>
    <span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">priceSort</span><span class="o">,</span> <span class="n">publishDateSort</span><span class="o">,</span> <span class="n">nameSort</span><span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 假设返回的结果是 Hit 对象</span>
<span class="nc">Hit</span><span class="o">&lt;</span><span class="nc">MyDocument</span><span class="o">&gt;</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">hits</span><span class="o">().</span><span class="na">hits</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="nc">MyDocument</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="na">source</span><span class="o">();</span> <span class="c1">// 获取文档源数据</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Hit&lt;TDocument&gt;</code> 类表示 Elasticsearch 查询返回的单个文档，并包含了丰富的元数据，如文档得分、排序信息、内嵌查询结果等。它可以根据不同的查询需求和文档类型灵活配置，并提供了序列化和转换为 JSON 的功能。</p>

<h4 id="sourcefilter-1"><code class="language-plaintext highlighter-rouge">SourceFilter</code></h4>

<p><strong><code class="language-plaintext highlighter-rouge">SourceFilter</code> 类的常用字段与方法</strong>：</p>

<p>用于指定哪些字段包含或排除在返回结果中。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">includes(String... fields)</code></strong>：指定要返回的字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">excludes(String... fields)</code></strong>：指定不返回的字段。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="nc">MyDocument</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"price"</span><span class="o">).</span><span class="na">excludes</span><span class="o">(</span><span class="s">"description"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"category"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"electronics"</span><span class="o">))),</span>
    <span class="nc">MyDocument</span><span class="o">.</span><span class="na">class</span>
<span class="o">);</span>
</code></pre></div></div>

<p>同更新的<code class="language-plaintext highlighter-rouge">SourceFilter</code>。</p>

<h4 id="特殊字段">特殊字段</h4>

<p>在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">keyword</code> 是一种特殊的字段类型，它通常用于不分词（即不被分割成多个词项）的字段。除了 <code class="language-plaintext highlighter-rouge">keyword</code> 类型，Elasticsearch 还支持其他一些特殊的字段标识符（字段类型），这些标识符在创建映射时可以指定。以下是常见的一些特殊字段类型：</p>

<p><strong><code class="language-plaintext highlighter-rouge">keyword</code></strong>，标识需要精确匹配的字段，通常用于 ID、标签、邮箱、域名等字段。字段的内容不会被分词，而是作为一个整体来索引。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">tagInfoList.tagList.keyword</code></li>
  <li>例如：<code class="language-plaintext highlighter-rouge">"tagList": ["tag1", "tag2", "tag3"]</code></li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">text</code></strong>，标识需要被分词的字段，通常用于需要进行全文搜索的字段。例如，文章的内容、评论、描述等字段通常使用 <code class="language-plaintext highlighter-rouge">text</code> 类型。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">title</code>, <code class="language-plaintext highlighter-rouge">description</code></li>
  <li>Elasticsearch 会对 <code class="language-plaintext highlighter-rouge">text</code> 类型的字段进行分词处理，支持全文搜索。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">date</code></strong>，表示日期时间数据。通常用于表示时间戳、事件日期等。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">createdDate</code>, <code class="language-plaintext highlighter-rouge">publishDate</code></li>
  <li>支持多种格式，如 <code class="language-plaintext highlighter-rouge">yyyy-MM-dd</code>, <code class="language-plaintext highlighter-rouge">yyyy-MM-dd HH:mm:ss</code> 等。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">integer</code>, <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">byte</code>, <code class="language-plaintext highlighter-rouge">double</code>, <code class="language-plaintext highlighter-rouge">float</code></strong>,这些是数值类型，用于表示整数和浮点数。不同的类型有不同的存储范围。
<strong>用法</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">price</code> (浮动数值)</li>
  <li><code class="language-plaintext highlighter-rouge">quantity</code> (整数)</li>
  <li><code class="language-plaintext highlighter-rouge">timestamp</code> (长整型时间戳)</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">boolean</code></strong>，表示布尔值，通常是 <code class="language-plaintext highlighter-rouge">true</code> 或 <code class="language-plaintext highlighter-rouge">false</code>。
<strong>用法</strong>：<code class="language-plaintext highlighter-rouge">isActive</code>, <code class="language-plaintext highlighter-rouge">isAvailable</code></p>

<p><strong><code class="language-plaintext highlighter-rouge">object</code></strong>，表示嵌套对象。<code class="language-plaintext highlighter-rouge">object</code> 字段可以包含复杂的结构，类似 JSON 对象。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">address</code>, <code class="language-plaintext highlighter-rouge">userInfo</code></li>
  <li>嵌套对象可以包含其他字段类型，可以是 <code class="language-plaintext highlighter-rouge">text</code>, <code class="language-plaintext highlighter-rouge">keyword</code>, <code class="language-plaintext highlighter-rouge">integer</code> 等。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">nested</code></strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">nested</code> 类型是一个特殊的 <code class="language-plaintext highlighter-rouge">object</code> 类型，用于处理数组中的对象。它为数组中的每个对象分配一个单独的文档，可以在查询时进行嵌套查询。</li>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">comments</code> （评论列表）</li>
  <li><code class="language-plaintext highlighter-rouge">nested</code> 类型与 <code class="language-plaintext highlighter-rouge">object</code> 类型类似，但它为每个子文档创建了一个独立的查询上下文，可以通过 <code class="language-plaintext highlighter-rouge">nested</code> 查询进行高效查询。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">geo_point</code></strong>，表示地理位置数据，通常用于存储经纬度。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">location</code> 或 <code class="language-plaintext highlighter-rouge">coordinates</code></li>
  <li>可以存储如经纬度坐标（<code class="language-plaintext highlighter-rouge">latitude</code>, <code class="language-plaintext highlighter-rouge">longitude</code>）和用于地理位置搜索。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">ip</code></strong>，表示 IP 地址字段。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">ipAddress</code>, <code class="language-plaintext highlighter-rouge">clientIp</code></li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">binary</code></strong>，存储二进制数据，如图像、视频等。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">image</code>, <code class="language-plaintext highlighter-rouge">fileData</code></li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">scaled_float</code></strong>，存储浮动数值，并通过一个缩放因子来避免存储过大的数字。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">discount_rate</code> （存储带缩放比例的浮动数值）</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">token_count</code></strong>，计算文本字段的词项数量，可以用于某些查询分析或统计。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">wordCount</code>（存储一个字段中的词项数）</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">alias</code></strong>用于创建字段别名，它不会存储数据，而只是将查询映射到实际的字段。</p>

<ul>
  <li><strong>用法</strong>：<code class="language-plaintext highlighter-rouge">current_email</code> 可以作为 <code class="language-plaintext highlighter-rouge">email</code> 字段的别名。</li>
</ul>

<p>在查询中，你可以指定字段类型来进行不同的操作，例如，<code class="language-plaintext highlighter-rouge">keyword</code> 字段用于精确匹配，<code class="language-plaintext highlighter-rouge">text</code> 字段用于全文搜索，而 <code class="language-plaintext highlighter-rouge">nested</code> 字段则用于处理嵌套的对象数组等。不同的字段类型适用于不同的场景，因此了解它们的区别和用途对于设计高效的查询非常重要。</p>

<p>如果在 Elasticsearch 中不设置字段类型，Elasticsearch 会尝试根据数据的内容自动推断字段的类型，称为 <strong>动态映射</strong>（Dynamic Mapping）。默认情况下，Elasticsearch 会使用以下规则来推断字段类型：</p>

<p><strong>自动类型推断（Dynamic Mapping）</strong></p>

<ul>
  <li><strong>字符串字段（<code class="language-plaintext highlighter-rouge">text</code> 或 <code class="language-plaintext highlighter-rouge">keyword</code>）</strong>：
    <ul>
      <li>如果字段值是 <strong>文本</strong> 类型（如字符串），Elasticsearch 默认将其映射为 <code class="language-plaintext highlighter-rouge">text</code> 类型，适用于需要分词的字段。如果 Elasticsearch 检测到该字段包含 URL 或电子邮件等常见标识符，它可能会将其映射为 <code class="language-plaintext highlighter-rouge">keyword</code> 类型。</li>
    </ul>
  </li>
  <li><strong>数字字段（<code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">integer</code>, <code class="language-plaintext highlighter-rouge">float</code>, <code class="language-plaintext highlighter-rouge">double</code>, 等）</strong>：
    <ul>
      <li>如果字段值是 <strong>数字</strong> 类型（整数或浮点数），Elasticsearch 会将其映射为合适的数值类型（如 <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">integer</code>, <code class="language-plaintext highlighter-rouge">float</code>）。</li>
    </ul>
  </li>
  <li><strong>日期字段（<code class="language-plaintext highlighter-rouge">date</code>）</strong>：
    <ul>
      <li>如果字段值是 <strong>日期时间格式</strong>（如 <code class="language-plaintext highlighter-rouge">2022-01-01</code> 或 <code class="language-plaintext highlighter-rouge">1629834074</code>），Elasticsearch 会自动推断为 <code class="language-plaintext highlighter-rouge">date</code> 类型。</li>
    </ul>
  </li>
  <li><strong>布尔字段（<code class="language-plaintext highlighter-rouge">boolean</code>）</strong>：
    <ul>
      <li>如果字段值是 <strong>布尔值</strong>（<code class="language-plaintext highlighter-rouge">true</code> 或 <code class="language-plaintext highlighter-rouge">false</code>），Elasticsearch 会将其映射为 <code class="language-plaintext highlighter-rouge">boolean</code> 类型。</li>
    </ul>
  </li>
  <li><strong>数组字段（<code class="language-plaintext highlighter-rouge">object</code>, <code class="language-plaintext highlighter-rouge">nested</code>）</strong>：
    <ul>
      <li>如果字段值是一个 <strong>数组</strong>，Elasticsearch 会尝试推断它是 <code class="language-plaintext highlighter-rouge">array</code> 类型的对象或基本数据类型。如果数组中的元素是对象，则会推断为 <code class="language-plaintext highlighter-rouge">nested</code> 类型；如果是简单类型（如字符串、数字），则会根据元素类型推断。</li>
    </ul>
  </li>
</ul>

<p><strong>动态映射的行为</strong></p>

<ul>
  <li><strong>动态启用</strong>：在默认情况下，Elasticsearch 启用动态映射。这意味着如果索引的映射中没有明确指定某个字段类型，Elasticsearch 会尝试根据文档中的数据推断出字段的类型。</li>
  <li><strong>动态禁用</strong>：你也可以通过设置 <code class="language-plaintext highlighter-rouge">dynamic: false</code> 来禁用动态映射，防止 Elasticsearch 自动创建新字段的映射。此时，如果文档中包含未知字段，Elasticsearch 会拒绝该文档。此选项适用于对数据格式要求严格的场景。</li>
  <li><strong>动态模板</strong>：你还可以使用 <strong>动态模板</strong> 来对字段的类型进行精确控制，例如，指定某些字段自动映射为 <code class="language-plaintext highlighter-rouge">keyword</code> 类型，或者根据字段名称自动使用特定的数据类型。</li>
</ul>

<p><strong>没有显式设置字段类型的后果</strong>
如果你没有为某个字段设置明确的类型，Elasticsearch 会按以下方式处理：</p>

<ul>
  <li><strong>字符串类型</strong>：通常会被自动推断为 <code class="language-plaintext highlighter-rouge">text</code> 类型，但如果该字段的内容表现出某些模式（如 URL、电子邮件地址、IP 地址等），可能会被推断为 <code class="language-plaintext highlighter-rouge">keyword</code> 类型。</li>
  <li><strong>数值类型</strong>：会自动推断为整数、长整型、浮动数值或双精度浮动数值，具体取决于输入的值。</li>
  <li><strong>日期类型</strong>：如果字段值看起来是日期格式，Elasticsearch 会自动将其映射为 <code class="language-plaintext highlighter-rouge">date</code> 类型。</li>
  <li><strong>未知字段</strong>：如果一个字段的类型无法自动推断，Elasticsearch 会尝试将它映射为 <code class="language-plaintext highlighter-rouge">text</code> 或其他常见类型，并且你可以使用 <code class="language-plaintext highlighter-rouge">dynamic</code> 设置控制是否允许自动创建字段。</li>
</ul>

<p><strong>使用动态模板进行控制</strong>
动态模板允许你通过预定义规则控制字段的类型。例如，如果你希望所有带 <code class="language-plaintext highlighter-rouge">.id</code> 后缀的字段都映射为 <code class="language-plaintext highlighter-rouge">keyword</code> 类型，可以使用如下的动态模板：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"mappings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"dynamic_templates"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="p">{</span><span class="w">
        </span><span class="nl">"strings_as_keywords"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"match"</span><span class="p">:</span><span class="w"> </span><span class="s2">"*_id"</span><span class="p">,</span><span class="w">
          </span><span class="nl">"mapping"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"keyword"</span><span class="w">
          </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>禁用动态映射</strong>
如果你希望禁止自动创建新字段，可以设置 <code class="language-plaintext highlighter-rouge">dynamic: false</code> 来禁用动态映射：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"mappings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"dynamic"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="nl">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"text"</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong>默认情况下</strong>，如果不显式指定字段类型，Elasticsearch 会根据字段值的类型自动推断字段的类型，采用动态映射。</li>
  <li>对于大多数应用，Elasticsearch 的自动类型推断足够好，但是在某些场景下，特别是当数据结构复杂时，显式地指定字段类型可以提高索引的性能和准确性，避免不必要的类型推断错误。</li>
</ul>

<h4 id="query"><code class="language-plaintext highlighter-rouge">Query</code></h4>

<p>在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">Query</code> 是一个顶级接口，通常与 <code class="language-plaintext highlighter-rouge">bool</code> 查询、<code class="language-plaintext highlighter-rouge">term</code> 查询、<code class="language-plaintext highlighter-rouge">terms</code> 查询等结合使用。查询通常是通过构建器模式来创建的，允许我们灵活地组合查询条件。</p>

<p><strong>默认情况下，会对非数字和布尔类型分词，因此如果不要分词，请在字段后面加后缀<code class="language-plaintext highlighter-rouge">.keyword</code>。</strong></p>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">Query</code> 的常用构建方式</strong>：</p>

<h5 id="match"><code class="language-plaintext highlighter-rouge">match</code></h5>

<p>全词匹配查询。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"elasticsearch"</span><span class="o">)));</span>
</code></pre></div></div>

<hr />

<h5 id="term"><code class="language-plaintext highlighter-rouge">term</code></h5>

<p>用于精确匹配某个字段的值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">term</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"123"</span><span class="o">)));</span>
</code></pre></div></div>

<hr />

<h5 id="terms"><code class="language-plaintext highlighter-rouge">terms</code></h5>

<p>用于匹配多个值，通常用于字段的多个可能值查询。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.query(
        q -&gt; q.terms(
                t -&gt; t.field("id").terms(tm -&gt;
                        tm.value(List.of(FieldValue.of("123"),FieldValue.of("456")))
                )
        )
)
</code></pre></div></div>

<hr />

<h5 id="bool"><code class="language-plaintext highlighter-rouge">bool</code></h5>

<p>布尔查询，用于组合多个查询条件。包括 <code class="language-plaintext highlighter-rouge">must</code>、<code class="language-plaintext highlighter-rouge">should</code> 和 <code class="language-plaintext highlighter-rouge">mustNot</code> 等。例如，<code class="language-plaintext highlighter-rouge">must</code> 表示查询结果必须匹配的条件，而 <code class="language-plaintext highlighter-rouge">should</code> 表示查询结果最好匹配的条件（但不是必须的）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
    <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m1</span> <span class="o">-&gt;</span> <span class="n">m1</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"elasticsearch"</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">term</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"status"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"active"</span><span class="o">)))</span>
<span class="o">));</span>
</code></pre></div></div>

<p>示例2：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">&gt;&gt;</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
<span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
    <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span>
        <span class="o">.</span><span class="na">term</span><span class="o">(</span><span class="n">tagCategoryQuery</span><span class="o">)</span>   <span class="c1">// 必须匹配的条件：tagCategoryQuery</span>
    <span class="o">)</span>
    <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span>
        <span class="o">.</span><span class="na">terms</span><span class="o">(</span><span class="n">tagListQuery</span><span class="o">)</span>      <span class="c1">// 必须匹配的条件：tagListQuery</span>
    <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p>如果使用<code class="language-plaintext highlighter-rouge">must</code>，那么两个查询条件必须同时满足；如果使用 <code class="language-plaintext highlighter-rouge">should</code>，那么至少一个条件必须满足。示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用Elasticsearch客户端执行一个查询，查询字段 "title" 是否匹配查询词 "elasticsearch"</span>
<span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">c</span> <span class="o">-&gt;</span> <span class="n">c</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"elasticsearch"</span><span class="o">)))</span>  <span class="c1">// 匹配查询</span>
<span class="o">,</span> <span class="nc">Map</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>  <span class="c1">// 返回结果类型为 Map</span>

<span class="c1">// 创建一个 Term 查询，查询字段 "tagInfoList.tagCategory.keyword" 是否为 1</span>
<span class="nc">TermQuery</span> <span class="n">tagCategoryQuery</span> <span class="o">=</span> <span class="nc">TermQuery</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"tagInfoList.tagCategory.keyword"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>

<span class="c1">// 创建一个 Terms 查询，查询字段 "tagInfoList.tagList.keyword" 是否包含 "123" 或 "456"</span>
<span class="nc">TermsQuery</span> <span class="n">tagListQuery</span> <span class="o">=</span> <span class="nc">TermsQuery</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"tagInfoList.tagList.keyword"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">terms</span><span class="o">(</span><span class="n">tm</span> <span class="o">-&gt;</span> <span class="n">tm</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="nc">FieldValue</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"123"</span><span class="o">),</span> <span class="nc">FieldValue</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"456"</span><span class="o">)))));</span>

<span class="c1">// 构建一个 OR 查询，使用 bool 查询的 should 子句，表示满足以下任一条件即为匹配</span>
<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">&gt;&gt;</span> <span class="n">orQuery</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
        <span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
                <span class="c1">// 第一个 should 查询：tagCategoryQuery，查询是否匹配 tagCategory</span>
                <span class="o">.</span><span class="na">should</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">term</span><span class="o">(</span><span class="n">tagCategoryQuery</span><span class="o">))</span>  
                <span class="c1">// 第二个 should 查询：tagListQuery，查询是否匹配 tagList</span>
                <span class="o">.</span><span class="na">should</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">terms</span><span class="o">(</span><span class="n">tagListQuery</span><span class="o">))</span>  
                <span class="c1">// minimumShouldMatch 设置为 "1"，表示至少有一个 should 条件满足即可</span>
                <span class="o">.</span><span class="na">minimumShouldMatch</span><span class="o">(</span><span class="s">"1"</span><span class="o">)</span>
        <span class="o">);</span>

</code></pre></div></div>

<hr />

<h5 id="range"><code class="language-plaintext highlighter-rouge">range</code></h5>

<p>范围查询，用于查找字段值在某个范围内的文档。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"price"</span><span class="o">).</span><span class="na">gte</span><span class="o">(</span><span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">100</span><span class="o">)).</span><span class="na">lte</span><span class="o">(</span><span class="nc">JsonData</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">500</span><span class="o">))))</span>
</code></pre></div></div>

<hr />

<h5 id="prefix"><code class="language-plaintext highlighter-rouge">prefix</code></h5>

<p>前缀查询（查询）</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrefixQuery</span> <span class="n">prefixQuery</span> <span class="o">=</span> <span class="nc">PrefixQuery</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title.keyword"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="s">"prefixValue"</span><span class="o">)</span>
<span class="o">);</span>

<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">&gt;&gt;</span> <span class="n">prefixCondition</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
    <span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
        <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">prefix</span><span class="o">(</span><span class="n">prefixQuery</span><span class="o">))</span>
    <span class="o">);</span>
</code></pre></div></div>

<hr />

<h5 id="match-1"><code class="language-plaintext highlighter-rouge">match</code></h5>

<p>匹配查询</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MatchQuery</span> <span class="n">matchQuery</span> <span class="o">=</span> <span class="nc">MatchQuery</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"description"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"search text"</span><span class="o">)</span>
<span class="o">);</span>

<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">&gt;&gt;</span> <span class="n">matchCondition</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
    <span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
        <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">matchQuery</span><span class="o">))</span>
    <span class="o">);</span>
</code></pre></div></div>

<hr />

<h5 id="wildcard"><code class="language-plaintext highlighter-rouge">wildcard</code></h5>

<p>通配符查询（查询）</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">WildcardQuery</span> <span class="n">wildcardQuery</span> <span class="o">=</span> <span class="nc">WildcardQuery</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="n">w</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"content"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="s">"val*"</span><span class="o">)</span>
<span class="o">);</span>

<span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">.</span><span class="na">Builder</span><span class="o">,</span> <span class="nc">ObjectBuilder</span><span class="o">&lt;</span><span class="nc">Query</span><span class="o">&gt;&gt;</span> <span class="n">wildcardCondition</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
    <span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
        <span class="o">.</span><span class="na">must</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">wildcard</span><span class="o">(</span><span class="n">wildcardQuery</span><span class="o">))</span>
    <span class="o">);</span>
</code></pre></div></div>

<h5 id="regexp"><code class="language-plaintext highlighter-rouge">regexp</code></h5>

<p>正则表达式匹配，提供比 <code class="language-plaintext highlighter-rouge">wildcard</code> 查询更强大的模式匹配能力。正则表达式可以更灵活地定义匹配模式，如字符类、重复次数、分组等。</p>

<hr />

<h5 id="matchphrase"><code class="language-plaintext highlighter-rouge">matchPhrase</code></h5>

<p><code class="language-plaintext highlighter-rouge">match_phrase</code> 是 Elasticsearch 中用于短语匹配（Phrase Matching）的一种查询类型。与普通的 <code class="language-plaintext highlighter-rouge">match</code> 查询不同，<code class="language-plaintext highlighter-rouge">match_phrase</code> 查询会考虑词语的顺序，并且要求词语紧密相邻，因此更适合用于查询语句、短语或句子等场景。</p>

<p><code class="language-plaintext highlighter-rouge">match_phrase</code> 的基本特性：</p>

<ul>
  <li><strong>顺序敏感</strong>：<code class="language-plaintext highlighter-rouge">match_phrase</code> 会按给定的顺序匹配文本，不能像普通的 <code class="language-plaintext highlighter-rouge">match</code> 查询那样不考虑顺序。</li>
  <li><strong>相邻词语匹配</strong>：要求文本中的词语相邻，并且之间没有其他词语（如果设置了 <code class="language-plaintext highlighter-rouge">slop</code>，则允许词语之间有一定的“跳跃”）。</li>
  <li><strong>适用于短语查询</strong>：适合搜索包含特定短语或句子的情况。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">match_phrase</code> 查询语法结构比较简单，通常使用以下格式：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"short phrase"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">field</code>：要搜索的字段。</li>
  <li><code class="language-plaintext highlighter-rouge">"short phrase"</code>：要匹配的短语，多个词会按照给定顺序进行匹配。</li>
</ul>

<p>示例：</p>

<p>假设有以下文档：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch provides fast and scalable search."</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>匹配短语</strong>：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"fast and scalable"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>该查询会搜索包含短语 “fast and scalable” 的文档，注意这要求短语中的词语按顺序出现。</p>

<p><strong>顺序敏感性</strong>：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"scalable fast"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将不会匹配到前面的文档，因为词语的顺序是不同的。<code class="language-plaintext highlighter-rouge">match_phrase</code> 查询是顺序敏感的。</p>

<p><code class="language-plaintext highlighter-rouge">slop</code> 参数：</p>

<p><code class="language-plaintext highlighter-rouge">slop</code> 参数允许在匹配的短语中插入一定数量的词语（即可以“跳跃”）。例如，如果我们设置 <code class="language-plaintext highlighter-rouge">slop</code> 为 2，就表示可以在短语中插入最多 2 个词。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"fast scalable search"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"slop"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>在这个查询中，<code class="language-plaintext highlighter-rouge">slop</code> 设置为 2，表示可以接受 <code class="language-plaintext highlighter-rouge">fast</code>, <code class="language-plaintext highlighter-rouge">scalable</code>, <code class="language-plaintext highlighter-rouge">search</code> 三个词之间最多有 2 个词。也就是说，查询会匹配包含这些词的任何顺序，允许有最多两个词的间隔。</p>

<p><code class="language-plaintext highlighter-rouge">match_phrase</code> 与 <code class="language-plaintext highlighter-rouge">match</code> 的区别：</p>

<ul>
  <li><strong>顺序</strong>：<code class="language-plaintext highlighter-rouge">match</code> 查询不考虑词语的顺序，而 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询要求词语按照指定的顺序排列。</li>
  <li><strong>相邻性</strong>：<code class="language-plaintext highlighter-rouge">match</code> 查询可以在一个字段中任意位置找到匹配词，而 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询要求词语相邻，除非使用 <code class="language-plaintext highlighter-rouge">slop</code>。</li>
</ul>

<p>示例：
使用 <code class="language-plaintext highlighter-rouge">match</code> 查询：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"fast scalable"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>该查询会匹配包含 <code class="language-plaintext highlighter-rouge">fast</code> 和 <code class="language-plaintext highlighter-rouge">scalable</code> 两个词的任何文档，无论它们是否相邻，是否按顺序排列。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询：</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"fast scalable"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>该查询要求文档中 <code class="language-plaintext highlighter-rouge">fast</code> 和 <code class="language-plaintext highlighter-rouge">scalable</code> 两个词要紧密相邻，且按顺序排列。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询的场景：</p>

<p><strong>搜索带有固定顺序的短语</strong>：如果你希望查询精确的短语，并且要求词语之间相对顺序不变，可以使用 <code class="language-plaintext highlighter-rouge">match_phrase</code>。</p>

<p>例如，查询某个特定地址、名称或短语：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"New York City"</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>避免词语出现顺序混乱的情况</strong>：<code class="language-plaintext highlighter-rouge">match_phrase</code> 查询适合用在内容中顺序非常重要的场景，比如标题、句子、文章等。</p>

<p><strong>精准短语搜索</strong>：对于一些需要高度精确匹配的查询，<code class="language-plaintext highlighter-rouge">match_phrase</code> 是非常合适的选择，例如查询产品名称、地理位置等。</p>

<p>示例代码（Java）：</p>

<p>在 Java 中，使用 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询类似于其他查询类型。你可以使用 Elasticsearch 客户端 API 来构建查询：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">matchPhraseQuery</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">mp</span> <span class="o">-&gt;</span> <span class="n">mp</span>
        <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"text"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"fast scalable"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">slop</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// 可选，设置slop来允许跳跃</span>
<span class="o">));</span>
</code></pre></div></div>

<p>总结：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">match_phrase</code> 查询用于精确匹配短语，要求短语中的词语顺序一致且相邻。</li>
  <li><code class="language-plaintext highlighter-rouge">slop</code> 参数允许在短语中插入一定的词语间隔，使得查询更加灵活。</li>
  <li>适用于需要顺序和相邻关系的重要短语匹配场景。</li>
</ul>

<hr />

<h5 id="ids"><code class="language-plaintext highlighter-rouge">ids</code></h5>

<p>查找制定出的文档ID</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ids</span><span class="o">=...</span>
<span class="o">...</span>
<span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">queryBuilder</span> <span class="o">-&gt;</span> <span class="n">queryBuilder</span>
        <span class="o">.</span><span class="na">ids</span><span class="o">(</span><span class="n">idsQueryBuilder</span> <span class="o">-&gt;</span> <span class="n">idsQueryBuilder</span>
                <span class="o">.</span><span class="na">values</span><span class="o">(</span><span class="n">ids</span><span class="o">))</span>
<span class="o">)</span>
</code></pre></div></div>

<p>在这个查询中，它会根据给定的文档 ID 来返回对应的文档。</p>

<p><code class="language-plaintext highlighter-rouge">idsQueryBuilder -&gt; idsQueryBuilder.values(ids)</code>：<code class="language-plaintext highlighter-rouge">idsQueryBuilder</code> 是用来构建 ID 查询的构建器。在这段代码中，通过 <code class="language-plaintext highlighter-rouge">values(ids)</code> 方法传入一个包含文档 ID 的列表，表示希望查找这些 ID 对应的文档。<code class="language-plaintext highlighter-rouge">ids</code> 是一个包含多个文档 ID 的集合（通常是一个 List 或数组）。</p>

<hr />

<h5 id="multimatch"><code class="language-plaintext highlighter-rouge">multiMatch</code></h5>

<p>跨多个字段的全文检索，会分词，<strong>可以设置为短语匹配：<code class="language-plaintext highlighter-rouge">.type(TextQueryType.Phrase)  // 使用短语查询</code>。</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">multiMatch</span><span class="o">(</span><span class="n">mm</span> <span class="o">-&gt;</span> <span class="n">mm</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">search</span><span class="o">)</span>                       <span class="c1">// 查询关键词，通常是用户输入的搜索词</span>
        <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="s">"memberInfo"</span><span class="o">,</span><span class="s">"name"</span><span class="o">)</span>             
        <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="nc">BestFields</span><span class="o">)</span>                    <span class="c1">// 设置查询类型为 BestFields</span>
    <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">multi_match</code> 查询是 Elasticsearch 中用于对多个字段进行相同查询条件的查询。它类似于 <code class="language-plaintext highlighter-rouge">match</code> 查询，但可以一次性匹配多个字段，通常用于对多个文本字段的全文搜索。</p>

<p>当用户希望搜索多个字段时，可以使用 <code class="language-plaintext highlighter-rouge">multi_match</code> 查询。比如在用户搜索时，可能同时需要对 <code class="language-plaintext highlighter-rouge">title</code>、<code class="language-plaintext highlighter-rouge">description</code>、<code class="language-plaintext highlighter-rouge">content</code> 等多个字段进行匹配，而不需要逐个字段进行查询。</p>

<p><strong><code class="language-plaintext highlighter-rouge">.query(search)</code></strong>：设置了搜索的关键词，即用户要查找的文本。在这个代码片段中，<code class="language-plaintext highlighter-rouge">search</code> 变量通常是一个字符串，包含用户输入的搜索条件。</p>

<p><strong><code class="language-plaintext highlighter-rouge">.fields("memberInfo","name")</code></strong>：指定了哪些字段将被用于匹配搜索关键词，注意字段不能用通配符。</p>

<p><strong><code class="language-plaintext highlighter-rouge">.type(BestFields)</code></strong>：设置了 <code class="language-plaintext highlighter-rouge">multi_match</code> 查询的类型为 <code class="language-plaintext highlighter-rouge">BestFields</code>。<code class="language-plaintext highlighter-rouge">BestFields</code> 是 Elasticsearch 中的一种匹配类型，用于选择最相关的字段进行评分计算。</p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">BestFields</code></strong>：这是默认的查询类型，它会根据每个字段的匹配度选择最相关的字段进行评分。如果查询涉及多个字段，<code class="language-plaintext highlighter-rouge">BestFields</code> 会为每个字段计算相关性评分，最终选择评分最高的字段作为匹配结果。</p>
  </li>
  <li>
    <p>在 <code class="language-plaintext highlighter-rouge">BestFields</code> 模式下，如果在多个字段中找到匹配项，Elasticsearch 会根据字段的相关性（比如匹配的词频、字段的文本长度等因素）来选择最相关的一个字段的结果。</p>
  </li>
</ul>

<p>如果 <code class="language-plaintext highlighter-rouge">memberInfo</code> 对象下有多个字段，<code class="language-plaintext highlighter-rouge">BestFields</code> 会自动选择最相关的字段进行评分。比如，如果 <code class="language-plaintext highlighter-rouge">memberInfo</code> 下有 <code class="language-plaintext highlighter-rouge">name</code>、<code class="language-plaintext highlighter-rouge">address</code> 和 <code class="language-plaintext highlighter-rouge">email</code> 字段，查询 <code class="language-plaintext highlighter-rouge">"John"</code> 时，假设：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> 匹配 <code class="language-plaintext highlighter-rouge">"John"</code>，得分为 1.0</li>
  <li><code class="language-plaintext highlighter-rouge">email</code> 匹配 <code class="language-plaintext highlighter-rouge">"john.doe@example.com"</code>，得分为 0.5</li>
  <li><code class="language-plaintext highlighter-rouge">address</code> 没有匹配项，得分为 0</li>
</ul>

<p>在这种情况下，<code class="language-plaintext highlighter-rouge">BestFields</code> 会选择 <code class="language-plaintext highlighter-rouge">name</code> 字段，因为它的匹配度更高，得分为 1.0，返回这个字段作为最相关的匹配字段。</p>

<hr />

<h5 id="textquerytype"><code class="language-plaintext highlighter-rouge">TextQueryType</code></h5>

<p>在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">multi_match</code> 查询用于在多个字段上执行查询。不同的 <code class="language-plaintext highlighter-rouge">multi_match</code> 查询类型可以影响查询结果的计算方式。这些类型主要用于在文本字段上执行多字段匹配，每种类型有不同的应用场景。</p>

<p><code class="language-plaintext highlighter-rouge">TextQueryType</code> 枚举提供了几种常见的 <code class="language-plaintext highlighter-rouge">multi_match</code> 查询类型，每种类型都有不同的行为。接下来我会详细解释每种类型的用法和适用场景。</p>

<p><strong>BestFields (<code class="language-plaintext highlighter-rouge">best_fields</code>)</strong>：这是默认的查询类型。它会选择最佳匹配的字段来返回结果。如果多个字段匹配查询词，<code class="language-plaintext highlighter-rouge">best_fields</code> 会根据每个字段的匹配度（相关性）来选择最相关的一个字段的结果。</p>

<p><strong>适用场景</strong>：适用于当你在多个字段上搜索相同的查询词时，查询应该集中在最相关的字段上，而不是计算所有字段的综合评分。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
       </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch tutorial"</span><span class="p">,</span><span class="w">
       </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
       </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"best_fields"</span><span class="w">
     </span><span class="p">}</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>此查询会在 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 字段中查找 <code class="language-plaintext highlighter-rouge">Elasticsearch tutorial</code>，并根据匹配度选择最相关的字段进行评分。</p>

<p><strong>MostFields (<code class="language-plaintext highlighter-rouge">most_fields</code>)</strong>：与 <code class="language-plaintext highlighter-rouge">best_fields</code> 类似，但是 <code class="language-plaintext highlighter-rouge">most_fields</code> 会尝试为每个匹配的字段增加评分。这意味着它会计算所有匹配字段的总相关性评分，而不是只选择一个字段的结果。</p>

<p><strong>适用场景</strong>：当你希望所有匹配字段对最终评分都有贡献时使用。适合于多字段匹配时，所有字段的匹配都重要的场景。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch tutorial"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
   </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"most_fields"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>此查询会在 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 字段中查找 <code class="language-plaintext highlighter-rouge">Elasticsearch tutorial</code>，并根据这两个字段的匹配度计算总的相关性评分。</p>

<p><strong>CrossFields (<code class="language-plaintext highlighter-rouge">cross_fields</code>)</strong>：将多个字段视为一个单一的字段来进行查询。<code class="language-plaintext highlighter-rouge">cross_fields</code> 会把多个字段的值合并在一起，然后执行一个查询。例如，<code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 字段的内容将被合并为一个查询上下文。</p>

<p><strong>适用场景</strong>：当你希望字段之间的查询词没有严格的顺序关系时使用。适用于多个字段需要一起查询，并且字段之间的内容可以交换或跨字段匹配的场景。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch tutorial"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
   </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cross_fields"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>此查询会将 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 字段的内容合并起来，然后进行一次整体查询。</p>

<p><strong>Phrase (<code class="language-plaintext highlighter-rouge">phrase</code>)</strong>：与普通的 <code class="language-plaintext highlighter-rouge">match</code> 查询不同，<code class="language-plaintext highlighter-rouge">phrase</code> 查询要求查询词必须出现在特定顺序中。它在多字段查询中保持查询词的顺序。</p>

<p><strong>适用场景</strong>：当你需要确保查询词在文本中按指定顺序出现时使用。例如，查询 “Elasticsearch tutorial” 时，只有当这两个词按顺序出现时才匹配。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch tutorial"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
   </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"phrase"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>此查询会检查 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 字段中是否按顺序出现 <code class="language-plaintext highlighter-rouge">Elasticsearch tutorial</code>。</p>

<p><strong>PhrasePrefix (<code class="language-plaintext highlighter-rouge">phrase_prefix</code>)</strong>：类似于 <code class="language-plaintext highlighter-rouge">phrase</code> 查询，但允许查询词的最后一个词是前缀匹配。这意味着在查询词的最后部分可以是一个不完全的单词。</p>

<p><strong>适用场景</strong>：当你希望搜索短语时，允许部分匹配或前缀匹配某个词时使用。适合处理像 “Elasticsearch tut” 这样没有完全输入的查询。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch tut"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
   </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"phrase_prefix"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>此查询会匹配 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 中的短语，允许 <code class="language-plaintext highlighter-rouge">tut</code> 为前缀匹配，例如匹配 <code class="language-plaintext highlighter-rouge">tutorial</code>。</p>

<p><strong>BoolPrefix (<code class="language-plaintext highlighter-rouge">bool_prefix</code>)</strong>：<code class="language-plaintext highlighter-rouge">bool_prefix</code> 查询是一种特殊的布尔查询，它允许对查询的最后一个词进行前缀匹配。与 <code class="language-plaintext highlighter-rouge">phrase_prefix</code> 类似，它支持在查询词的最后部分进行前缀匹配。</p>

<p><strong>适用场景</strong>：适合需要在多个字段上进行布尔查询，并且最后一个词允许前缀匹配的场景。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
 </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Elasticsearch tut"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"title"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
   </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"bool_prefix"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>此查询会匹配 <code class="language-plaintext highlighter-rouge">title</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 中的短语，允许最后一个词（<code class="language-plaintext highlighter-rouge">tut</code>）进行前缀匹配，并使用布尔查询的逻辑。</p>

<p><strong>总结：</strong></p>

<p>这些查询类型提供了不同的方式来匹配多字段查询，适用于不同的文本匹配需求：</p>

<ul>
  <li><strong>BestFields</strong>：选择最相关的字段进行匹配。</li>
  <li><strong>MostFields</strong>：所有匹配字段都对最终评分有贡献。</li>
  <li><strong>CrossFields</strong>：多个字段合并为一个进行查询，适合字段间不需要严格顺序的场景。</li>
  <li><strong>Phrase</strong>：要求查询词按顺序匹配。</li>
  <li><strong>PhrasePrefix</strong>：允许查询词的最后部分进行前缀匹配。</li>
  <li><strong>BoolPrefix</strong>：布尔查询并允许最后部分进行前缀匹配。</li>
</ul>

<p>选择合适的查询类型可以显著提高查询的准确性和性能，取决于你的具体场景需求。</p>

<h5 id="querystring"><code class="language-plaintext highlighter-rouge">queryString</code></h5>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 是 Elasticsearch 中的一种查询类型，允许你在查询中使用 Lucene 查询语法，支持多种查询运算符和符号。它类似于 <code class="language-plaintext highlighter-rouge">match</code> 查询，但提供了更强大的查询功能，允许在一个字段或多个字段中进行复杂的搜索。</p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询的常见用法：</p>

<p><strong>基础查询</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询支持对字段进行自由文本搜索，并且支持多种查询语法，如布尔运算符、通配符、短语查询等。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省"</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将搜索包含 “甘肃省” 的所有文档。</p>

<p><strong>指定查询字段</strong>：</p>

<p>可以通过 <code class="language-plaintext highlighter-rouge">fields</code> 参数指定要查询的字段，或者使用 <code class="language-plaintext highlighter-rouge">*</code> 来表示查询所有字段。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省"</span><span class="p">,</span><span class="w">
     </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"memberInfo.name"</span><span class="p">,</span><span class="w"> </span><span class="s2">"memberInfo.address"</span><span class="p">]</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将在 <code class="language-plaintext highlighter-rouge">memberInfo.name</code> 和 <code class="language-plaintext highlighter-rouge">memberInfo.address</code> 字段中查找 “甘肃省”。</p>

<p><strong>通配符查询</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 支持通配符查询，可以使用 <code class="language-plaintext highlighter-rouge">*</code> 和 <code class="language-plaintext highlighter-rouge">?</code> 来匹配零个或多个字符，以及一个字符。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃*"</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将匹配以 “甘肃” 开头的所有文档，例如 “甘肃省” 或 “甘肃市”。</p>

<p><strong>布尔查询</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 支持布尔运算符 <code class="language-plaintext highlighter-rouge">AND</code>、<code class="language-plaintext highlighter-rouge">OR</code> 和 <code class="language-plaintext highlighter-rouge">NOT</code>，可以用来连接多个查询条件。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 AND (北京 OR 上海)"</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将查找包含 “甘肃省” 且同时包含 “北京” 或 “上海” 的文档。</p>

<p><strong>短语查询</strong>：</p>

<p>可以通过将查询词用双引号括起来来进行短语查询，查找词语按照给定顺序出现的文档。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"</span><span class="se">\"</span><span class="s2">甘肃省 兰州</span><span class="se">\"</span><span class="s2">"</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将查找包含 “甘肃省 兰州” 短语的文档。</p>

<p><strong>字段优先级</strong>：</p>

<p>如果查询中多个字段包含相同的词语，你可以为字段指定权重，以便给特定字段更多的匹配优先级。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省^2 北京"</span><span class="p">,</span><span class="w">
     </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"memberInfo.name"</span><span class="p">,</span><span class="w"> </span><span class="s2">"memberInfo.address"</span><span class="p">]</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>在这个查询中，<code class="language-plaintext highlighter-rouge">memberInfo.name</code> 字段的匹配会比 <code class="language-plaintext highlighter-rouge">memberInfo.address</code> 字段的匹配更重要，因为 <code class="language-plaintext highlighter-rouge">^2</code> 给了 <code class="language-plaintext highlighter-rouge">memberInfo.name</code> 字段一个权重。</p>

<p><strong>解析错误控制</strong>：</p>

<p>你还可以设置 <code class="language-plaintext highlighter-rouge">allow_leading_wildcard</code> 参数来控制是否允许以通配符开头的查询，默认情况下 Elasticsearch 会拒绝以 <code class="language-plaintext highlighter-rouge">*</code> 或 <code class="language-plaintext highlighter-rouge">?</code> 开头的查询。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"*甘肃"</span><span class="p">,</span><span class="w">
     </span><span class="nl">"allow_leading_wildcard"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这允许查询以 <code class="language-plaintext highlighter-rouge">*</code> 开头的查询，例如 <code class="language-plaintext highlighter-rouge">*甘肃</code>。</p>

<p><strong>支持空格分隔符</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询支持空格分隔符来组合多个查询项，允许用户在查询字符串中使用空格来分隔不同的查询条件。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
     </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京 上海"</span><span class="w">
   </span><span class="p">}</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>这将查找包含 “甘肃省”、”北京” 和 “上海” 的文档。</p>

<hr />

<p><strong>控制符</strong></p>

<p>在 Elasticsearch 中，<code class="language-plaintext highlighter-rouge">query_string</code> 查询是一种非常强大的查询方式，它支持复杂的查询语法和灵活的查询表达式。通过 <code class="language-plaintext highlighter-rouge">query_string</code> 查询，你可以构建具有高级查询条件的搜索请求，支持布尔运算符、通配符、短语查询、字段级查询等多种功能。以下是 <code class="language-plaintext highlighter-rouge">query_string</code> 查询的常用方法和功能：</p>

<p><strong><code class="language-plaintext highlighter-rouge">query</code></strong> - 查询字符串</p>

<p><code class="language-plaintext highlighter-rouge">query</code> 是 <code class="language-plaintext highlighter-rouge">query_string</code> 查询的核心，定义了搜索的查询表达式。你可以在查询中使用多个运算符（如 <code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code>, <code class="language-plaintext highlighter-rouge">NOT</code>）来构建复杂的查询。</p>

<p><strong><code class="language-plaintext highlighter-rouge">default_operator</code></strong> - 设置默认操作符</p>

<p><code class="language-plaintext highlighter-rouge">default_operator</code> 用来设置查询中的默认操作符。如果查询字符串中没有明确指定操作符，默认操作符将被应用。常见的操作符有 <code class="language-plaintext highlighter-rouge">OR</code> 和 <code class="language-plaintext highlighter-rouge">AND</code>。</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">AND</code></strong>：如果两个查询词都出现，则返回匹配。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">OR</code></strong>：只要其中一个查询词出现即可。</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"default_operator"</span><span class="p">:</span><span class="w"> </span><span class="s2">"AND"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">).</span><span class="na">defaultOperator</span><span class="o">(</span><span class="nc">QueryStringQuery</span><span class="o">.</span><span class="na">Operator</span><span class="o">.</span><span class="na">AND</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">analyze_wildcard</code></strong> - 启用或禁用通配符分析</p>

<p>Elasticsearch 默认不对通配符 (<code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">?</code>) 进行分析。如果你希望在查询中启用通配符的分析，可以将 <code class="language-plaintext highlighter-rouge">analyze_wildcard</code> 设置为 <code class="language-plaintext highlighter-rouge">true</code>。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃* AND 北京?"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"analyze_wildcard"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃* AND 北京?"</span><span class="o">).</span><span class="na">analyzeWildcard</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">escape</code></strong> - 启用或禁用特殊字符转义</p>

<p>如果你在查询字符串中需要使用特殊字符（如 <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">||</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">()</code>, <code class="language-plaintext highlighter-rouge">{}</code>, <code class="language-plaintext highlighter-rouge">[]</code>, <code class="language-plaintext highlighter-rouge">^</code>, <code class="language-plaintext highlighter-rouge">"</code>, <code class="language-plaintext highlighter-rouge">~</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">:</code>），并且不希望它们被当作运算符处理，你可以设置 <code class="language-plaintext highlighter-rouge">escape</code> 为 <code class="language-plaintext highlighter-rouge">true</code> 来对它们进行转义。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"address:甘肃省 AND description:</span><span class="se">\"</span><span class="s2">北京的景点</span><span class="se">\"</span><span class="s2">"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"escape"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"address:甘肃省 AND description:\"北京的景点\""</span><span class="o">).</span><span class="na">escape</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">quote_field_suffix</code></strong> - 指定短语查询时的字段后缀</p>

<p>如果字段支持短语查询，<code class="language-plaintext highlighter-rouge">quote_field_suffix</code> 用于在短语查询时添加字段后缀。通常情况下，短语查询会在字段名后加上 <code class="language-plaintext highlighter-rouge">.keyword</code> 后缀来指定精确匹配。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"</span><span class="se">\"</span><span class="s2">甘肃省 北京</span><span class="se">\"</span><span class="s2">"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"quote_field_suffix"</span><span class="p">:</span><span class="w"> </span><span class="s2">".keyword"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"\"甘肃省 北京\""</span><span class="o">).</span><span class="na">quoteFieldSuffix</span><span class="o">(</span><span class="s">".keyword"</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">fuzzy_max_expansions</code></strong> - 设置模糊查询的最大扩展数</p>

<p>如果查询字符串中包含模糊查询（例如 <code class="language-plaintext highlighter-rouge">~</code> 后缀的查询），则 <code class="language-plaintext highlighter-rouge">fuzzy_max_expansions</code> 可以限制模糊查询的最大扩展数，避免生成过多的扩展词。</p>

<p>示例：</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省~2"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"fuzzy_max_expansions"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省~2"</span><span class="o">).</span><span class="na">fuzzyMaxExpansions</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">tie_breaker</code></strong> - 多字段查询的得分合并策略</p>

<p>当查询多个字段时，<code class="language-plaintext highlighter-rouge">tie_breaker</code> 用来指定如果某些字段得分相同，应该如何合并它们的得分。<code class="language-plaintext highlighter-rouge">tie_breaker</code> 的值介于 <code class="language-plaintext highlighter-rouge">0</code> 和 <code class="language-plaintext highlighter-rouge">1</code> 之间，默认值为 <code class="language-plaintext highlighter-rouge">0</code>。</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tie_breaker</code> 值接近 0：会优先考虑高得分的字段。</li>
  <li><code class="language-plaintext highlighter-rouge">tie_breaker</code> 值接近 1：会让所有字段得分差距较小。</li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"address^2"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
    </span><span class="nl">"tie_breaker"</span><span class="p">:</span><span class="w"> </span><span class="mf">0.3</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">).</span><span class="na">fields</span><span class="o">(</span><span class="s">"address^2"</span><span class="o">,</span> <span class="s">"description"</span><span class="o">).</span><span class="na">tieBreaker</span><span class="o">(</span><span class="mf">0.3</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">allow_leading_wildcard</code></strong> - 是否允许通配符以 <code class="language-plaintext highlighter-rouge">*</code> 开头</p>

<p>默认情况下，<code class="language-plaintext highlighter-rouge">query_string</code> 查询不允许通配符以 <code class="language-plaintext highlighter-rouge">*</code> 开头，因为这可能导致性能问题。通过设置 <code class="language-plaintext highlighter-rouge">allow_leading_wildcard</code> 为 <code class="language-plaintext highlighter-rouge">true</code>，你可以允许以 <code class="language-plaintext highlighter-rouge">*</code> 开头的通配符查询。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃*"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"allow_leading_wildcard"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃*"</span><span class="o">).</span><span class="na">allowLeadingWildcard</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">minimum_should_match</code></strong> - 设置 <code class="language-plaintext highlighter-rouge">should</code> 子句的最小匹配数</p>

<p><code class="language-plaintext highlighter-rouge">minimum_should_match</code> 用来控制 <code class="language-plaintext highlighter-rouge">should</code> 子句的最小匹配数。它通常与布尔查询结合使用，控制 <code class="language-plaintext highlighter-rouge">should</code> 子句必须满足多少个才能被视为匹配。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 OR 北京"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"minimum_should_match"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> 
    <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 OR 北京"</span><span class="o">).</span><span class="na">minimumShouldMatch</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询非常强大，支持多种操作符、通配符、短语查询等复杂查询需求。常用的方法包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">query</code>：查询字符串本身。</li>
  <li><code class="language-plaintext highlighter-rouge">fields</code>：指定查询的字段。</li>
  <li><code class="language-plaintext highlighter-rouge">default_operator</code>：设置默认操作符（<code class="language-plaintext highlighter-rouge">AND</code> 或 <code class="language-plaintext highlighter-rouge">OR</code>）。</li>
  <li><code class="language-plaintext highlighter-rouge">analyze_wildcard</code>：启用通配符分析。</li>
  <li><code class="language-plaintext highlighter-rouge">escape</code>：启用特殊字符转义。</li>
  <li><code class="language-plaintext highlighter-rouge">quote_field_suffix</code>：设置字段后缀，用于短语查询。</li>
  <li><code class="language-plaintext highlighter-rouge">fuzzy_max_expansions</code>：限制模糊查询的扩展数量。</li>
  <li><code class="language-plaintext highlighter-rouge">tie_breaker</code>：合并多个字段得分时使用的策略。</li>
  <li><code class="language-plaintext highlighter-rouge">allow_leading_wildcard</code>：允许通配符以 <code class="language-plaintext highlighter-rouge">*</code> 开头。</li>
  <li><code class="language-plaintext highlighter-rouge">minimum_should_match</code>：设置最小匹配的 <code class="language-plaintext highlighter-rouge">should</code> 子句数量。</li>
</ul>

<p>这些功能使得 <code class="language-plaintext highlighter-rouge">query_string</code> 查询非常适用于需要复杂查询表达式的场景，如全文搜索和多字段匹配等。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询适用于复杂的查询场景，能够处理通配符、布尔操作、短语查询等。如果你希望支持更多自由文本查询，可以选择这种查询类型。但它也容易出错，特别是当查询字符串不正确时，可能会导致解析错误或性能问题。所以在实际使用时要小心，确保查询语法符合预期。</p>

<p>在 Java 中使用 <code class="language-plaintext highlighter-rouge">query_string</code> 查询，可以通过 Elasticsearch 客户端构建类似的查询。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">queryStringQuery</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> <span class="n">qs</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 AND (北京 OR 上海)"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="s">"memberInfo"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">defaultOperator</span><span class="o">(</span><span class="nc">QueryStringQuery</span><span class="o">.</span><span class="na">Operator</span><span class="o">.</span><span class="na">OR</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">Query.of(q -&gt; q.queryString(...))</code></strong></p>

<p>这里的 <code class="language-plaintext highlighter-rouge">Query.of()</code> 是 Elasticsearch 客户端的构建器方法，用来创建一个查询对象。<code class="language-plaintext highlighter-rouge">queryString</code> 是查询的类型。通过链式调用，你可以为查询指定具体的条件。</p>

<p><strong><code class="language-plaintext highlighter-rouge">query("甘肃省 AND (北京 OR 上海)")</code></strong></p>

<p><code class="language-plaintext highlighter-rouge">queryString</code> 查询的核心是 <code class="language-plaintext highlighter-rouge">query</code> 方法，它接受一个字符串参数，表示查询的文本。该字符串使用 Lucene 查询语法，支持各种查询功能：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AND</code>：表示条件同时满足。</li>
  <li><code class="language-plaintext highlighter-rouge">OR</code>：表示条件中至少满足一个。</li>
  <li>括号：用于分组条件，如 <code class="language-plaintext highlighter-rouge">(北京 OR 上海)</code>，表示北京或上海中的任何一个。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">fields("memberInfo.name")</code></strong></p>

<p>通过 <code class="language-plaintext highlighter-rouge">fields</code> 方法，可以指定查询的字段。这里查询的字段是 <code class="language-plaintext highlighter-rouge">memberInfo</code>。这意味着该查询将会匹配文档中 <code class="language-plaintext highlighter-rouge">memberInfo</code> 字段的内容，而不是全局进行匹配。</p>

<p><code class="language-plaintext highlighter-rouge">**defaultOperator(QueryStringQuery.Operator.OR)</code>**</p>

<p><code class="language-plaintext highlighter-rouge">defaultOperator</code> 指定了默认操作符。Elasticsearch 的 <code class="language-plaintext highlighter-rouge">query_string</code> 查询支持两个操作符：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">OR</code>（默认）：表示如果查询字符串中没有明确指定操作符，则默认为 OR 操作。例如，查询 <code class="language-plaintext highlighter-rouge">甘肃省 北京 上海</code> 实际上相当于 <code class="language-plaintext highlighter-rouge">甘肃省 OR 北京 OR 上海</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">AND</code>：表示如果没有指定操作符，则默认为 AND 操作，所有条件都必须满足。</li>
</ul>

<p>通过设置 <code class="language-plaintext highlighter-rouge">QueryStringQuery.Operator.OR</code>，如果查询中没有指定操作符，则会使用 <code class="language-plaintext highlighter-rouge">OR</code> 进行默认连接。</p>

<h5 id="短语查询">短语查询</h5>

<p><strong><code class="language-plaintext highlighter-rouge">match_phrase</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">match_phrase</code> 查询用于精确匹配短语，确保查询的词语顺序和位置与文档中的匹配内容一致。它是执行短语查询时最常用的一种方式。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"北京 上海"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>该查询将匹配包含精确短语“北京 上海”的文档。词语顺序必须一致，且词语间的空格数量与查询相同。</p>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">mp</span> <span class="o">-&gt;</span> <span class="n">mp</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"address"</span><span class="o">)</span>  <span class="c1">// 字段名</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"北京 上海"</span><span class="o">)</span>  <span class="c1">// 短语查询</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">multi_match</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">multi_match</code> 查询支持多个字段的短语查询。它是 <code class="language-plaintext highlighter-rouge">match</code> 查询的一种扩展，适用于同时在多个字段上进行短语匹配。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"北京 上海"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"address"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"phrase"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>该查询将在字段 <code class="language-plaintext highlighter-rouge">address</code> 和 <code class="language-plaintext highlighter-rouge">description</code> 上执行短语查询，要求同时匹配“北京 上海”。通过设置 <code class="language-plaintext highlighter-rouge">type: "phrase"</code>，确保执行的是短语查询。</p>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">multiMatch</span><span class="o">(</span><span class="n">mm</span> <span class="o">-&gt;</span> <span class="n">mm</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"北京 上海"</span><span class="o">)</span>  <span class="c1">// 查询短语</span>
    <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="s">"address"</span><span class="o">,</span> <span class="s">"description"</span><span class="o">)</span>  <span class="c1">// 字段名</span>
    <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="nc">MultiMatchQuery</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">PHRASE</span><span class="o">)</span>  <span class="c1">// 确保是短语查询</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">query_string</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询支持通过语法进行复杂的短语查询，并且提供了更大的灵活性，尤其是在字段限制、操作符、分词等方面。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"</span><span class="se">\"</span><span class="s2">北京 上海</span><span class="se">\"</span><span class="s2">"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"address"</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询支持包含精确短语的查询，使用 <code class="language-plaintext highlighter-rouge">\"\"</code> 来包裹短语。适合进行多种复杂查询，如使用布尔操作符、通配符等。</p>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> <span class="n">qs</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"\"北京 上海\""</span><span class="o">)</span>  <span class="c1">// 短语查询</span>
    <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="s">"address"</span><span class="o">)</span>  <span class="c1">// 查询字段</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">span_near</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">span_near</code> 查询适用于需要在文档中匹配一组短语，并且短语之间有特定顺序或距离要求的场景。它可以在查询时指定“slop”（允许的词语间距），以及是否要求词语顺序一致。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"span_near"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"clauses"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"span_term"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="s2">"北京"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"span_term"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="s2">"上海"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"slop"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
      </span><span class="nl">"in_order"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>该查询要求词语“北京”和“上海”在 <code class="language-plaintext highlighter-rouge">content</code> 字段中间有最多2个词，并且词语顺序必须一致。</p>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">spanNear</span><span class="o">(</span><span class="n">sn</span> <span class="o">-&gt;</span> <span class="n">sn</span>
    <span class="o">.</span><span class="na">clauses</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q1</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">.</span><span class="na">spanTerm</span><span class="o">(</span><span class="n">st</span> <span class="o">-&gt;</span> <span class="n">st</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"content"</span><span class="o">).</span><span class="na">term</span><span class="o">(</span><span class="s">"北京"</span><span class="o">))),</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q2</span> <span class="o">-&gt;</span> <span class="n">q2</span><span class="o">.</span><span class="na">spanTerm</span><span class="o">(</span><span class="n">st</span> <span class="o">-&gt;</span> <span class="n">st</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"content"</span><span class="o">).</span><span class="na">term</span><span class="o">(</span><span class="s">"上海"</span><span class="o">)))</span>
    <span class="o">))</span>
    <span class="o">.</span><span class="na">slop</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">.</span><span class="na">inOrder</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">phrase_prefix</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">phrase_prefix</code> 查询在短语查询的基础上允许部分词语进行前缀匹配。这种查询常用于匹配以某个词为前缀的短语。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_phrase_prefix"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"天津"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>该查询将匹配所有包含以“天津”开头的短语的文档。</p>

<p>Java 示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">matchPhrasePrefix</span><span class="o">(</span><span class="n">mp</span> <span class="o">-&gt;</span> <span class="n">mp</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"address"</span><span class="o">)</span>  <span class="c1">// 字段名</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"天津"</span><span class="o">)</span>  <span class="c1">// 前缀匹配</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">match</code> 查询 (与 <code class="language-plaintext highlighter-rouge">operator</code> 配合使用)</strong></p>

<p><code class="language-plaintext highlighter-rouge">match</code> 查询是最常见的查询类型，适用于单个词的查询，但在与 <code class="language-plaintext highlighter-rouge">operator</code> 配合使用时，它也可以模仿短语查询的行为。通过设置 <code class="language-plaintext highlighter-rouge">operator: AND</code>，你可以要求查询的所有词语都出现在文档中，但不保证顺序和位置。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"北京 上海"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"operator"</span><span class="p">:</span><span class="w"> </span><span class="s2">"and"</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>该查询将匹配包含“北京”和“上海”的文档，但不要求它们按顺序出现。</p>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"address"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"北京 上海"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">operator</span><span class="o">(</span><span class="nc">MatchQuery</span><span class="o">.</span><span class="na">Operator</span><span class="o">.</span><span class="na">AND</span><span class="o">)</span>  <span class="c1">// 强制所有词语都必须出现</span>
<span class="o">));</span>
</code></pre></div></div>

<p>以下是支持短语查询的常见查询类型：</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">match_phrase</code></strong>：最直接的短语查询，确保词语顺序和位置精确匹配。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">multi_match</code></strong>：适用于多个字段的短语查询，可以通过设置 <code class="language-plaintext highlighter-rouge">type: "phrase"</code> 实现短语匹配。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">query_string</code></strong>：提供复杂的查询语法，支持短语查询，并允许字段限制和操作符。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">span_near</code></strong>：适用于要求短语之间有一定距离或顺序关系的查询。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">phrase_prefix</code></strong>：支持短语查询和前缀匹配，适用于词语前缀的情况。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">match</code></strong>：可以通过设置 <code class="language-plaintext highlighter-rouge">operator: AND</code> 来模拟短语查询，但不保证词语顺序。</li>
</ol>

<p>对于只要求短语匹配且顺序一致的情况，<code class="language-plaintext highlighter-rouge">match_phrase</code> 和 <code class="language-plaintext highlighter-rouge">multi_match</code> 是最常见的选择。而如果你有更复杂的需求，如短语之间有间距、顺序要求等，<code class="language-plaintext highlighter-rouge">span_near</code> 是一个很好的选择。</p>

<h5 id="多字段短语查询">多字段短语查询</h5>

<p>在 Elasticsearch 中，以下几种查询支持短语查询（Phrase Query）并且可以同时查询多个字段：</p>

<p><strong><code class="language-plaintext highlighter-rouge">multi_match</code> 查询</strong>
<code class="language-plaintext highlighter-rouge">multi_match</code> 查询支持短语查询，并允许在多个字段上执行查询。通过将查询类型设置为 <code class="language-plaintext highlighter-rouge">phrase</code>，你可以进行短语查询，并且支持多个字段。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"multi_match"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"address"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">],</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"phrase"</span><span class="w">  </span><span class="err">//</span><span class="w"> </span><span class="err">使用短语查询</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">query</code></strong>：查询内容，支持短语。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fields</code></strong>：多个字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">type</code></strong>：查询类型为 <code class="language-plaintext highlighter-rouge">phrase</code>，表示进行短语查询。</li>
</ul>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">multiMatch</span><span class="o">(</span><span class="n">mm</span> <span class="o">-&gt;</span> <span class="n">mm</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">)</span>  <span class="c1">// 查询内容</span>
    <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="s">"address"</span><span class="o">,</span> <span class="s">"description"</span><span class="o">)</span>  <span class="c1">// 查询的多个字段</span>
    <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="nc">MultiMatchQuery</span><span class="o">.</span><span class="na">Type</span><span class="o">.</span><span class="na">PHRASE</span><span class="o">)</span>  <span class="c1">// 使用短语查询</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">query_string</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">query_string</code> 查询不仅支持复杂的查询语法，还可以进行短语查询，并允许多个字段同时进行匹配。在 <code class="language-plaintext highlighter-rouge">query_string</code> 查询中，短语查询可以通过引号来指定。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"query_string"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="s2">"</span><span class="se">\"</span><span class="s2">甘肃省 北京</span><span class="se">\"</span><span class="s2">"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"fields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"address"</span><span class="p">,</span><span class="w"> </span><span class="s2">"description"</span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">query</code></strong>：查询内容，使用引号包围以进行短语匹配。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fields</code></strong>：多个字段进行匹配。</li>
</ul>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span> <span class="n">qs</span>
    <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"\"甘肃省 北京\""</span><span class="o">)</span>  <span class="c1">// 短语查询</span>
    <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="s">"address"</span><span class="o">,</span> <span class="s">"description"</span><span class="o">)</span>  <span class="c1">// 多个字段</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">bool</code> 查询 (with <code class="language-plaintext highlighter-rouge">should</code> and <code class="language-plaintext highlighter-rouge">match_phrase</code>)</strong></p>

<p><code class="language-plaintext highlighter-rouge">bool</code> 查询可以与 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询一起使用，支持多个字段进行短语查询。通过 <code class="language-plaintext highlighter-rouge">should</code> 子句来指定多个字段。</p>

<p>示例：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bool"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"should"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
      </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">match_phrase</code></strong>：短语查询。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">should</code></strong>：多个字段的短语查询，只要有一个匹配即满足查询条件。</li>
</ul>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span>
    <span class="o">.</span><span class="na">should</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q1</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"address"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">))),</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q2</span> <span class="o">-&gt;</span> <span class="n">q2</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"description"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">)))</span>
    <span class="o">))</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">dis_max</code> 查询 (with <code class="language-plaintext highlighter-rouge">match_phrase</code>)</strong></p>

<p><code class="language-plaintext highlighter-rouge">dis_max</code> 查询可以用于多个短语查询，并返回匹配最强的查询字段。每个查询都可以是短语查询。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"dis_max"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"queries"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"match_phrase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省 北京"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"tie_breaker"</span><span class="p">:</span><span class="w"> </span><span class="mf">0.7</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">match_phrase</code></strong>：短语查询。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">dis_max</code></strong>：选择匹配度最高的字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">tie_breaker</code></strong>：多个查询得分时的加权系数。</li>
</ul>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">disMax</span><span class="o">(</span><span class="n">dm</span> <span class="o">-&gt;</span> <span class="n">dm</span>
    <span class="o">.</span><span class="na">queries</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q1</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"address"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">))),</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q2</span> <span class="o">-&gt;</span> <span class="n">q2</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"description"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"甘肃省 北京"</span><span class="o">)))</span>
    <span class="o">))</span>
    <span class="o">.</span><span class="na">tieBreaker</span><span class="o">(</span><span class="mf">0.7</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">span_near</code> 查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">span_near</code> 查询允许你查找多个短语或单词在文档中的相对位置。如果你希望多个字段之间的短语或单词有特定的顺序或距离，可以使用 <code class="language-plaintext highlighter-rouge">span_near</code> 查询。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"span_near"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"clauses"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"span_term"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"address"</span><span class="p">:</span><span class="w"> </span><span class="s2">"甘肃省"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="p">{</span><span class="w"> </span><span class="nl">"span_term"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"北京"</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"slop"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
      </span><span class="nl">"in_order"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">span_term</code></strong>：每个字段的短语查询。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">slop</code></strong>：允许的词语间距。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">in_order</code></strong>：是否要求词语顺序一致。</li>
</ul>

<p>Java 示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">spanNear</span><span class="o">(</span><span class="n">sn</span> <span class="o">-&gt;</span> <span class="n">sn</span>
    <span class="o">.</span><span class="na">clauses</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q1</span> <span class="o">-&gt;</span> <span class="n">q1</span><span class="o">.</span><span class="na">spanTerm</span><span class="o">(</span><span class="n">st</span> <span class="o">-&gt;</span> <span class="n">st</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"address"</span><span class="o">).</span><span class="na">term</span><span class="o">(</span><span class="s">"甘肃省"</span><span class="o">))),</span>
        <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q2</span> <span class="o">-&gt;</span> <span class="n">q2</span><span class="o">.</span><span class="na">spanTerm</span><span class="o">(</span><span class="n">st</span> <span class="o">-&gt;</span> <span class="n">st</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"description"</span><span class="o">).</span><span class="na">term</span><span class="o">(</span><span class="s">"北京"</span><span class="o">)))</span>
    <span class="o">))</span>
    <span class="o">.</span><span class="na">slop</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
    <span class="o">.</span><span class="na">inOrder</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="o">));</span>
</code></pre></div></div>

<p>以下查询支持短语查询并且可以应用于多个字段：</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">multi_match</code></strong> 查询：支持短语查询 (<code class="language-plaintext highlighter-rouge">phrase</code> 类型)，可以查询多个字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">query_string</code></strong> 查询：通过引号进行短语查询，可以查询多个字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">bool</code> 查询</strong>：通过结合 <code class="language-plaintext highlighter-rouge">should</code> 子句和 <code class="language-plaintext highlighter-rouge">match_phrase</code> 子查询，支持多个字段的短语查询。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">dis_max</code></strong> 查询：多个 <code class="language-plaintext highlighter-rouge">match_phrase</code> 查询，选择得分最高的查询结果。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">span_near</code></strong> 查询：支持多个字段的短语查询，并控制词语的顺序和距离。</li>
</ol>

<p>这些查询方法可以根据不同的业务需求来选择。</p>

<p>实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">memberInfoSearchQuery</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="nc">FieldUtil</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberInfo</span><span class="o">());</span>
            <span class="c1">// 匹配 memberInfo 下的所有字段</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">fields</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">b</span><span class="o">.</span><span class="na">should</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">matchPhrase</span><span class="o">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">m</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">memberInfoSearch</span><span class="o">).</span><span class="na">field</span><span class="o">(</span><span class="n">f</span><span class="o">))));</span>
            <span class="n">b</span><span class="o">.</span><span class="na">minimumShouldMatch</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
        <span class="o">})</span>
<span class="o">);</span>
<span class="nc">Query</span> <span class="n">memberInfoSearchQuery2</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="o">.</span><span class="na">queryString</span><span class="o">(</span><span class="n">qs</span> <span class="o">-&gt;</span>
            <span class="n">qs</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"\""</span><span class="o">+</span><span class="n">memberInfoSearch</span><span class="o">+</span><span class="s">"\""</span><span class="o">)</span> <span class="c1">// 使用短语查询</span>
                    <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="nc">FieldUtil</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberInfo</span><span class="o">())).</span><span class="na">toList</span><span class="o">())</span>
        <span class="o">)</span>
<span class="o">);</span>
<span class="nc">Query</span> <span class="n">memberInfoSearchQuery3</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">multiMatch</span><span class="o">(</span><span class="n">mm</span> <span class="o">-&gt;</span> <span class="n">mm</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">memberInfoSearch</span><span class="o">)</span>  <span class="c1">// 查询短语</span>
        <span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="nc">FieldUtil</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberInfo</span><span class="o">())).</span><span class="na">toList</span><span class="o">())</span>  <span class="c1">// 查询多个字段</span>
        <span class="o">.</span><span class="na">type</span><span class="o">(</span><span class="nc">TextQueryType</span><span class="o">.</span><span class="na">Phrase</span><span class="o">)</span>  <span class="c1">// 使用短语查询</span>
<span class="o">));</span>
<span class="c1">// 以上均只能匹配中文 like，英文和数字无法匹配</span>
<span class="nc">Query</span> <span class="n">memberInfoSearchQuery4</span> <span class="o">=</span> <span class="nc">Query</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">q</span><span class="o">.</span><span class="na">bool</span><span class="o">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="nc">FieldUtil</span><span class="o">.</span><span class="na">getField</span><span class="o">(</span><span class="k">new</span> <span class="nc">MemberInfo</span><span class="o">());</span>
            <span class="c1">// 匹配 memberInfo 下的所有字段</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">fields</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">DatabaseConstants:</span><span class="o">:</span><span class="n">addKeyword</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">b</span><span class="o">.</span><span class="na">should</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">wildcard</span><span class="o">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="s">"*"</span><span class="o">+</span><span class="n">memberInfoSearch</span><span class="o">+</span><span class="s">"*"</span><span class="o">))));</span>
            <span class="n">b</span><span class="o">.</span><span class="na">minimumShouldMatch</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
        <span class="o">})</span>
<span class="o">);</span>
<span class="c1">// 为保持性能，可以通过正则使用不同的查询条件</span>
<span class="nc">Query</span> <span class="n">memberInfoSearchQuery</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">memberInfoSearch</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">"[A-Za-z0-9]+"</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">memberInfoSearchQuery</span> <span class="o">=</span> <span class="n">memberInfoSearchQuery4</span><span class="o">;</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="n">memberInfoSearchQuery</span> <span class="o">=</span> <span class="n">memberInfoSearchQuery3</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="sort"><code class="language-plaintext highlighter-rouge">Sort</code></h4>

<p>在 Elasticsearch 8.x 中，<code class="language-plaintext highlighter-rouge">Sort</code> 用于对查询结果进行排序。以下是常用的字段和方法，使用 Elasticsearch 8.x 的查询 DSL（Domain Specific Language）风格：</p>

<p><strong>Sort by Field</strong></p>

<p>可以通过字段名对查询结果进行排序，字段可以是文本、数字、日期等类型。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SortField</span> <span class="n">titleSort</span> <span class="o">=</span> <span class="nc">SortField</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">))</span>  <span class="c1">// 按照 "title" 字段排序</span>
    <span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="nc">SortOrder</span><span class="o">.</span><span class="na">ASC</span><span class="o">)</span>  <span class="c1">// 按升序排序</span>
<span class="o">);</span>

<span class="nc">SortField</span> <span class="n">priceSort</span> <span class="o">=</span> <span class="nc">SortField</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
    <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"price"</span><span class="o">))</span>  <span class="c1">// 按照 "price" 字段排序</span>
    <span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="nc">SortOrder</span><span class="o">.</span><span class="na">DESC</span><span class="o">)</span>  <span class="c1">// 按降序排序</span>
<span class="o">);</span>
</code></pre></div></div>

<p>使用脚本：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建脚本，用于根据 price 字段的值进行排序</span>
<span class="nc">Script</span> <span class="n">script</span> <span class="o">=</span> <span class="nc">Script</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
        <span class="o">.</span><span class="na">inline</span><span class="o">(</span><span class="n">inlineScriptBuilder</span> <span class="o">-&gt;</span> <span class="n">inlineScriptBuilder</span>
                <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="s">"doc['price'].value * 2"</span><span class="o">)</span>  <span class="c1">// inline 脚本：字段 'price' 的值乘以 2</span>
        <span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 创建排序选项，使用脚本排序</span>
<span class="nc">SortOptions</span> <span class="n">scriptSort</span> <span class="o">=</span> <span class="nc">SortOptions</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">sc</span> <span class="o">-&gt;</span> <span class="n">sc</span>
                <span class="o">.</span><span class="na">script</span><span class="o">(</span><span class="n">script</span><span class="o">)</span>  <span class="c1">// 使用定义好的脚本进行排序</span>
        <span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 使用 SortOptions 创建排序请求</span>
<span class="nc">SearchRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">SearchRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
                <span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"elasticsearch"</span><span class="o">))</span>  <span class="c1">// 查询条件：匹配 'title' 字段</span>
        <span class="o">)</span>
        <span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">scriptSort</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<p>地理位置排序、嵌套字段排序…</p>

<p>多条件排序</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建按价格升序排序的 SortOptions</span>
<span class="nc">SortOptions</span> <span class="n">priceSort</span> <span class="o">=</span> <span class="nc">SortOptions</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span>
                <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"price"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="nc">SortOrder</span><span class="o">.</span><span class="na">Asc</span><span class="o">)</span>  <span class="c1">// 升序排序</span>
        <span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 创建按发布日期降序排序的 SortOptions</span>
<span class="nc">SortOptions</span> <span class="n">publishDateSort</span> <span class="o">=</span> <span class="nc">SortOptions</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span>
                <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"publish_date"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="nc">SortOrder</span><span class="o">.</span><span class="na">Asc</span><span class="o">)</span>  <span class="c1">// 降序排序</span>
        <span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 创建按名称升序排序的 SortOptions</span>
<span class="nc">SortOptions</span> <span class="n">nameSort</span> <span class="o">=</span> <span class="nc">SortOptions</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span>
                <span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"name"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">order</span><span class="o">(</span><span class="nc">SortOrder</span><span class="o">.</span><span class="na">Asc</span><span class="o">)</span>  <span class="c1">// 升序排序</span>
        <span class="o">)</span>
<span class="o">);</span>

<span class="c1">// 创建搜索请求，并应用多字段排序</span>
<span class="nc">SearchRequest</span> <span class="n">searchRequest</span> <span class="o">=</span> <span class="nc">SearchRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span>
                <span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"title"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="s">"elasticsearch"</span><span class="o">))</span>  <span class="c1">// 查询条件：匹配 'title' 字段</span>
        <span class="o">)</span>
        <span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">priceSort</span><span class="o">,</span><span class="n">publishDateSort</span><span class="o">,</span><span class="n">nameSort</span><span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div>

<h4 id="search"><code class="language-plaintext highlighter-rouge">search()</code></h4>

<p><code class="language-plaintext highlighter-rouge">esClient.search</code> 是 Elasticsearch 中用于执行搜索操作的常用方法，支持多种查询和配置选项。</p>

<p><code class="language-plaintext highlighter-rouge">esClient.search</code> 提供了强大的查询功能，通过不同的构建方式，可以灵活地指定查询条件、分页、排序、字段过滤等。你可以通过 <code class="language-plaintext highlighter-rouge">SearchRequest</code> 对象或者构建器模式来配置搜索请求，并通过 <code class="language-plaintext highlighter-rouge">SearchResponse</code> 对象获取查询结果及相关信息。</p>

<p><strong><code class="language-plaintext highlighter-rouge">esClient.search(SearchRequest request)</code></strong> 方法：</p>

<ul>
  <li>
    <p><strong>功能</strong>：执行搜索查询并返回搜索结果。</p>
  </li>
  <li>
    <p><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">SearchRequest request</code>，该请求对象包含了查询所需的所有信息。</p>

    <p><strong>常用字段</strong>：</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">index</code>：要搜索的索引名称，可以是一个字符串，也可以是一个字符串数组。</li>
      <li><code class="language-plaintext highlighter-rouge">query</code>：查询条件，用于定义搜索的逻辑，例如使用 <code class="language-plaintext highlighter-rouge">match</code>, <code class="language-plaintext highlighter-rouge">term</code>, <code class="language-plaintext highlighter-rouge">bool</code> 等查询。</li>
      <li><code class="language-plaintext highlighter-rouge">source</code>：源过滤器，用于控制返回哪些字段，支持 <code class="language-plaintext highlighter-rouge">includes</code> 或 <code class="language-plaintext highlighter-rouge">excludes</code>。</li>
      <li><code class="language-plaintext highlighter-rouge">from</code>：指定查询的起始位置，用于分页。</li>
      <li><code class="language-plaintext highlighter-rouge">size</code>：指定每页的返回结果数目。</li>
      <li><code class="language-plaintext highlighter-rouge">sort</code>：用于指定排序条件。</li>
      <li><code class="language-plaintext highlighter-rouge">trackTotalHits</code>：控制是否计算总匹配数目。</li>
      <li><code class="language-plaintext highlighter-rouge">timeout</code>：查询超时时间。</li>
    </ul>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">esClient.search(Function&lt;SearchRequest.Builder, ObjectBuilder&lt;SearchRequest&gt;&gt; fn)</code></strong> 方法：</p>

<ul>
  <li><strong>功能</strong>：使用一个函数来构建 <code class="language-plaintext highlighter-rouge">SearchRequest</code>，这是一个函数式编程风格的调用。</li>
  <li><strong>参数</strong>：一个构建函数 <code class="language-plaintext highlighter-rouge">fn</code>，将一个 <code class="language-plaintext highlighter-rouge">SearchRequest.Builder</code> 转换为 <code class="language-plaintext highlighter-rouge">SearchRequest</code> 对象。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">builder</span> <span class="o">-&gt;</span> <span class="n">builder</span>
                <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">q</span> <span class="o">-&gt;</span> <span class="n">q</span><span class="o">.</span><span class="na">match</span><span class="o">(</span><span class="n">m</span> <span class="o">-&gt;</span> <span class="n">m</span><span class="o">.</span><span class="na">field</span><span class="o">(</span><span class="s">"v"</span><span class="o">).</span><span class="na">query</span><span class="o">(</span><span class="mi">50</span><span class="o">)))</span>
                <span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
                <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span>
        <span class="nc">Map</span><span class="o">.</span><span class="na">class</span>
<span class="o">);</span>
<span class="nc">HitsMetadata</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">hits</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">hits</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">hits</span><span class="o">.</span><span class="na">hits</span><span class="o">().</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">Hit:</span><span class="o">:</span><span class="n">source</span><span class="o">).</span><span class="na">toList</span><span class="o">();</span>
<span class="n">collect</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="滚动查询">滚动查询</h3>

<p>在 Elasticsearch 中，默认情况下，<code class="language-plaintext highlighter-rouge">Search</code> 查询返回的文档数量是 10 条。这是 Elasticsearch 的分页机制（<code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code>）的一部分。要返回更多的数据，你需要显式地设置查询的 <code class="language-plaintext highlighter-rouge">size</code> 参数，或者使用分页（<code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code>）来获取更多结果。</p>

<p><strong>增加返回结果的数量 (<code class="language-plaintext highlighter-rouge">size</code>)</strong>：</p>

<p>你可以通过设置 <code class="language-plaintext highlighter-rouge">size</code> 参数来改变每次查询返回的文档数量。比如，设置为 100 或更多：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexName</span><span class="o">)</span>
        <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="n">source</span> <span class="o">-&gt;</span> <span class="n">source</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="n">includeFields</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
        <span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span> <span class="c1">// 设置返回的结果数量</span>
        <span class="n">clazz</span>
<span class="o">);</span>
</code></pre></div></div>

<p>这样会返回 100 条数据。你可以根据需要调整 <code class="language-plaintext highlighter-rouge">size</code> 的值。</p>

<p><strong>使用分页 (from/size)</strong>：</p>

<p>如果数据量较大，可以使用分页来分批次查询。例如，你可以通过 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code> 来控制查询的起始点和每次返回的数量：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">page</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>  <span class="c1">// 页码，第一页为 0，第二页为 1，依此类推</span>
<span class="kt">int</span> <span class="n">pageSize</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>  <span class="c1">// 每页返回的数量</span>

<span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexName</span><span class="o">)</span>
        <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="n">source</span> <span class="o">-&gt;</span> <span class="n">source</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="n">includeFields</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
        <span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">page</span> <span class="o">*</span> <span class="n">pageSize</span><span class="o">)</span>  <span class="c1">// 分页查询，从第 `page` 页开始</span>
        <span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="n">pageSize</span><span class="o">),</span>  <span class="c1">// 每页返回的数量</span>
        <span class="n">clazz</span>
<span class="o">);</span>
</code></pre></div></div>

<p>这样，你就可以通过增加 <code class="language-plaintext highlighter-rouge">from</code> 来获取不同的分页数据。</p>

<p><strong><code class="language-plaintext highlighter-rouge">scroll</code> 查询</strong>：</p>

<p>如果你的数据量非常大，可以使用 <code class="language-plaintext highlighter-rouge">scroll</code> 查询来分页获取数据。<code class="language-plaintext highlighter-rouge">scroll</code> 是 Elasticsearch 用来高效查询大数据量的一种方式，它会持续保持一个上下文，可以多次请求来获取更多的数据，而不需要重新执行完整的查询。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">scroll</code> 查询的例子：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexName</span><span class="o">)</span>
        <span class="o">.</span><span class="na">scroll</span><span class="o">(</span><span class="s">"1m"</span><span class="o">)</span>  <span class="c1">// 设置 scroll 上下文的有效时间</span>
        <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="n">source</span> <span class="o">-&gt;</span> <span class="n">source</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="n">includeFields</span><span class="o">)))</span>
        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
        <span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span>  <span class="c1">// 每次返回 100 条数据</span>
        <span class="n">clazz</span>
<span class="o">);</span>

<span class="nc">String</span> <span class="n">scrollId</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">scrollId</span><span class="o">();</span>
<span class="c1">// 处理返回的文档数据，然后根据 scrollId 继续查询下一页的数据</span>
</code></pre></div></div>

<p>通过调整这些参数，可以控制查询结果的数量和分页方式，避免每次只能查询到 10 条数据的问题。</p>

<hr />

<p>在 Elasticsearch 中，默认情况下每个查询的 <code class="language-plaintext highlighter-rouge">size</code> 最大值是 <strong>10,000</strong> 条。如果你设置了 <code class="language-plaintext highlighter-rouge">size</code> 参数超过 10,000，Elasticsearch 会返回一个错误，提示不能超过这个限制。</p>

<p>不过，实际上，如果你想要检索超过 10,000 条数据，可以考虑以下两种方法：</p>

<p><strong>通过 <code class="language-plaintext highlighter-rouge">scroll</code> 查询批量获取数据</strong></p>

<p><code class="language-plaintext highlighter-rouge">scroll</code> 查询是 Elasticsearch 提供的一种方法，适用于查询大量数据，特别是当你需要返回大量记录时。使用 <code class="language-plaintext highlighter-rouge">scroll</code> 查询时，Elasticsearch 会保持一个上下文，使得你可以分页查询并逐步获取数据，而不需要一次性返回所有结果。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 滚动查询
 * @param indexName 索引名称
 * @param query 查询条件
 * @param includeFields 返回字段
 * @param clazz 返回类型
 * @return
 * @param &lt;T&gt; 返回类型
 * @throws IOException
 */</span>
<span class="kd">public</span>   <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">searchListByScroll</span><span class="o">(</span><span class="nc">String</span> <span class="n">indexName</span><span class="o">,</span>  <span class="nc">Query</span> <span class="n">query</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">includeFields</span><span class="o">,</span> <span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="o">{</span>
        <span class="c1">// 首先创建一次查询，获取滚动 ID 和初始结果</span>
        <span class="nc">SearchResponse</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span>
                        <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">indexName</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">scroll</span><span class="o">(</span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">s2</span><span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="mi">60_000</span><span class="o">))</span>  <span class="c1">// 1分钟滚动上下文</span>
                        <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="n">source</span> <span class="o">-&gt;</span> <span class="n">source</span><span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">includes</span><span class="o">(</span><span class="n">includeFields</span><span class="o">)))</span>
                        <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span>  <span class="c1">// 每次查询返回10000条</span>
                <span class="n">clazz</span>
        <span class="o">);</span>

        <span class="c1">// 获取scrollId</span>
        <span class="nc">String</span> <span class="n">scrollId</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">scrollId</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">HitsMetadata</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">hits</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">hits</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hits</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">handleResult</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">hits</span><span class="o">,</span> <span class="n">resultList</span><span class="o">);</span>

        <span class="c1">// 使用 scrollId 获取后续的数据</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">finalScrollId</span> <span class="o">=</span> <span class="n">scrollId</span><span class="o">;</span>
            <span class="nc">ScrollResponse</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">scrollResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">scroll</span><span class="o">(</span><span class="n">scroll</span> <span class="o">-&gt;</span> <span class="n">scroll</span>
                            <span class="o">.</span><span class="na">scrollId</span><span class="o">(</span><span class="n">finalScrollId</span><span class="o">)</span>  <span class="c1">// 使用之前的scrollId继续查询</span>
                            <span class="o">.</span><span class="na">scroll</span><span class="o">(</span><span class="n">s2</span><span class="o">-&gt;</span><span class="n">s2</span><span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="mi">60_000</span><span class="o">))</span>  <span class="c1">// 设置scroll上下文有效时间</span>
                    <span class="o">,</span><span class="n">clazz</span>
            <span class="o">);</span>
            <span class="nc">HitsMetadata</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">hits2</span> <span class="o">=</span> <span class="n">scrollResponse</span><span class="o">.</span><span class="na">hits</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">hits2</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">handleResult</span><span class="o">(</span><span class="n">clazz</span><span class="o">,</span> <span class="n">hits2</span><span class="o">,</span> <span class="n">resultList</span><span class="o">);</span>
            <span class="n">scrollId</span> <span class="o">=</span> <span class="n">scrollResponse</span><span class="o">.</span><span class="na">scrollId</span><span class="o">();</span>  <span class="c1">// 更新scrollId</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">handleResult</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">,</span> <span class="nc">HitsMetadata</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">hits</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Hit</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">hit</span> <span class="o">:</span> <span class="n">hits</span><span class="o">.</span><span class="na">hits</span><span class="o">())</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">source</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="na">source</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">id</span> <span class="o">=</span> <span class="n">hit</span><span class="o">.</span><span class="na">id</span><span class="o">();</span>
            <span class="nc">Field</span> <span class="n">idField</span> <span class="o">=</span> <span class="nc">DataUtil</span><span class="o">.</span><span class="na">getIdField</span><span class="o">(</span><span class="n">clazz</span><span class="o">);</span>
            <span class="n">idField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
            <span class="n">idField</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"设置id字段失败，请检查实体类是否包含id字段，或者id字段类型是否为String类型"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">resultList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">source</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>使用 <code class="language-plaintext highlighter-rouge">search_after</code> 分页查询</strong></p>

<p><code class="language-plaintext highlighter-rouge">search_after</code> 是 Elasticsearch 提供的另一种用于分页的方法，它基于上一页查询结果的排序字段来获取下一页的数据。它的优点是可以用于检索比 <code class="language-plaintext highlighter-rouge">from</code>/<code class="language-plaintext highlighter-rouge">size</code> 更大的数据量，同时避免了深分页带来的性能问题。</p>

<p><code class="language-plaintext highlighter-rouge">searchAfter</code> 是 Elasticsearch 中一个用于实现 <strong>深分页</strong>（deep pagination）或 <strong>基于游标的分页</strong>（cursor-based pagination）的功能。它通过指定前一次查询返回的最后一个文档的排序值来进行分页，从而避免了使用传统的 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code> 参数进行分页时可能遇到的性能问题，特别是在数据量非常大的情况下。</p>

<p>传统的基于 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code> 的分页方法对于大量数据（尤其是深分页，即查询较后面的结果时）会变得低效。每次请求都会跳过前面的大量文档，导致性能下降。而 <code class="language-plaintext highlighter-rouge">searchAfter</code> 使用一个游标（通常是上一次查询的最后一个文档的排序值），使得查询效率更高，并且可以在深层分页时避免效率低下的问题。</p>

<p><strong><code class="language-plaintext highlighter-rouge">searchAfter</code> 的工作原理</strong></p>

<p><strong>排序字段</strong>：为了使用 <code class="language-plaintext highlighter-rouge">searchAfter</code>，必须对查询结果进行排序，通常是使用一个唯一的字段（如文档的 <code class="language-plaintext highlighter-rouge">_id</code>）进行排序。排序字段的顺序非常重要，因为 <code class="language-plaintext highlighter-rouge">searchAfter</code> 会根据这些排序字段来跳过之前的文档并找到接下来的结果。</p>

<p><strong>提供排序值</strong>：<code class="language-plaintext highlighter-rouge">searchAfter</code> 需要提供一个排序值，这个值通常是来自上一个查询返回的最后一条文档的排序值。基于这个排序值，Elasticsearch 可以找到从上一次查询之后的下一条记录，并继续查询。</p>

<p><strong>传统分页（<code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code>）</strong></p>

<p>使用 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code> 进行分页时，每次查询都会计算跳过多少文档。例如：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET</span><span class="w"> </span><span class="err">/my_index/_search</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"from"</span><span class="p">:</span><span class="w"> </span><span class="mi">1000</span><span class="p">,</span><span class="w">
  </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_all"</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"sort"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"asc"</span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>在这个例子中，<code class="language-plaintext highlighter-rouge">from</code> 需要计算跳过前 1000 个文档，然后返回 10 个文档。随着 <code class="language-plaintext highlighter-rouge">from</code> 值的增大，查询效率会降低。</p>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">searchAfter</code></strong></p>

<p>使用 <code class="language-plaintext highlighter-rouge">searchAfter</code> 时，你只需要提供上一查询的最后一个排序值。假设你有一个按 <code class="language-plaintext highlighter-rouge">date</code> 字段升序排序的查询，返回第一个文档后，你可以使用这个文档的 <code class="language-plaintext highlighter-rouge">date</code> 字段作为 <code class="language-plaintext highlighter-rouge">searchAfter</code> 的值来进行下一次查询。</p>

<p>假设第一次查询返回了以下文档：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2021-01-01T00:00:00"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>然后你可以使用返回的 <code class="language-plaintext highlighter-rouge">date</code> 字段作为 <code class="language-plaintext highlighter-rouge">searchAfter</code> 参数，来获取接下来的数据：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET</span><span class="w"> </span><span class="err">/my_index/_search</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_all"</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"sort"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"asc"</span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"search_after"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"2021-01-01T00:00:00"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>多个排序字段</strong></p>

<p>如果你希望使用多个字段进行排序（例如按时间和 <code class="language-plaintext highlighter-rouge">_id</code> 排序），你需要在 <code class="language-plaintext highlighter-rouge">searchAfter</code> 中提供这些排序字段的值的数组。例如：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">GET</span><span class="w"> </span><span class="err">/my_index/_search</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"size"</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
  </span><span class="nl">"query"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"match_all"</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"sort"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="s2">"asc"</span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="nl">"_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"asc"</span><span class="p">}</span><span class="w">
  </span><span class="p">],</span><span class="w">
  </span><span class="nl">"search_after"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"2021-01-01T00:00:00"</span><span class="p">,</span><span class="w"> </span><span class="s2">"1"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>在这种情况下，<code class="language-plaintext highlighter-rouge">searchAfter</code> 需要同时传入 <code class="language-plaintext highlighter-rouge">date</code> 和 <code class="language-plaintext highlighter-rouge">_id</code> 的值。</p>

<p><strong><code class="language-plaintext highlighter-rouge">searchAfter</code> 与传统分页的区别</strong></p>

<ul>
  <li><strong>性能</strong>：<code class="language-plaintext highlighter-rouge">searchAfter</code> 在进行深分页时比 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code> 更高效，因为它不需要计算跳过多少文档，避免了大量文档的排序和过滤。</li>
  <li><strong>依赖排序</strong>：<code class="language-plaintext highlighter-rouge">searchAfter</code> 必须依赖排序字段，这意味着你的查询必须指定排序字段，并且这些字段需要有唯一性或者能确保正确的顺序。</li>
  <li><strong>状态保持</strong>：每次使用 <code class="language-plaintext highlighter-rouge">searchAfter</code> 时，必须保存上次查询的最后一个文档的排序值，进行状态传递。对于传统的基于 <code class="language-plaintext highlighter-rouge">from</code> 的分页方式，页面状态是由客户端控制的，而 <code class="language-plaintext highlighter-rouge">searchAfter</code> 基于查询结果本身的排序值来继续查询。</li>
</ul>

<p><strong>注意事项</strong></p>

<ul>
  <li><strong>排序字段的一致性</strong>：<code class="language-plaintext highlighter-rouge">searchAfter</code> 依赖于排序字段的值，确保这些字段的顺序和排序规则一致性非常重要。如果数据发生变化（例如新文档插入或排序字段值更新），可能会导致分页结果不一致。</li>
  <li><strong>适用场景</strong>：<code class="language-plaintext highlighter-rouge">searchAfter</code> 最适用于返回大量数据时，特别是需要从查询结果的中间或底部开始获取数据时。</li>
  <li><strong>限制</strong>：<code class="language-plaintext highlighter-rouge">searchAfter</code> 不支持 <code class="language-plaintext highlighter-rouge">from</code> 和 <code class="language-plaintext highlighter-rouge">size</code>，即它不能与这些参数一起使用。</li>
</ul>

<p><strong>总结</strong></p>

<p><code class="language-plaintext highlighter-rouge">searchAfter</code> 是 Elasticsearch 中为了解决深分页时的性能问题而设计的一种更高效的分页机制。它通过传递上一查询返回结果的排序值来继续查询，避免了传统分页中随着数据量增大而导致的效率低下的问题。</p>

<hr />

<p><strong>通过 <code class="language-plaintext highlighter-rouge">index.max_result_window</code> 配置提升返回结果的上限</strong></p>

<p>默认情况下，Elasticsearch 对每次查询的 <code class="language-plaintext highlighter-rouge">size</code> 限制为 10,000 条，<code class="language-plaintext highlighter-rouge">index.max_result_window</code> 配置项控制了这一限制。如果你需要返回超过 10,000 条数据，可以通过修改此设置来提升限制。</p>

<p><strong>注意：</strong> 提升 <code class="language-plaintext highlighter-rouge">max_result_window</code> 可能会导致性能下降，尤其是在大规模数据集上进行查询时。</p>

<p>配置方法：</p>

<p>修改 <code class="language-plaintext highlighter-rouge">index.max_result_window</code>：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PUT</span><span class="w"> </span><span class="err">/your_index/_settings</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"settings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"index.max_result_window"</span><span class="p">:</span><span class="w"> </span><span class="mi">20000</span><span class="w">  </span><span class="err">//</span><span class="w"> </span><span class="err">设置为所需的最大值</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>更新后，您可以在查询时使用 <code class="language-plaintext highlighter-rouge">size</code> 设置返回数据的数量大于 10,000 条。</p>

<blockquote>
  <p><strong>警告</strong>：增加 <code class="language-plaintext highlighter-rouge">max_result_window</code> 可能导致内存消耗增加，因此在修改时请确保你的 Elasticsearch 集群有足够的内存来处理大量数据返回。</p>
</blockquote>

<p>总结</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">scroll</code> 查询</strong>：用于处理大规模数据集，避免一次性返回大量数据。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">search_after</code> 分页</strong>：适用于处理排序字段的分页，避免深分页性能问题。</li>
  <li><strong>提升 <code class="language-plaintext highlighter-rouge">index.max_result_window</code></strong>：直接增加查询结果的返回上限，但需谨慎使用。</li>
</ol>

<p>通常，建议使用 <strong><code class="language-plaintext highlighter-rouge">scroll</code> 查询</strong> 或 <strong><code class="language-plaintext highlighter-rouge">search_after</code> 分页</strong> 来处理大数据量查询，尤其是当返回超过 10,000 条数据时。</p>

<h3 id="管道">管道</h3>

<p>管道通常在 Elasticsearch 中是预先定义好的，它是一个由多个处理步骤组成的过程。你可以通过 Elasticsearch 的 <strong>Ingest Node API</strong> 创建和管理管道。一个管道包含一个或多个处理器（processors），例如：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">set processor</code></strong>：用于设置或修改字段的值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">rename processor</code></strong>：用于重命名字段。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">date processor</code></strong>：将日期字符串转换为日期类型。</li>
</ul>

<h4 id="使用-http">使用 HTTP</h4>

<p>假设你想创建一个管道，该管道用于将所有传入文档的 <code class="language-plaintext highlighter-rouge">timestamp</code> 字段转换为日期类型。可以使用 Elasticsearch 的管道 API 来定义管道。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">PUT</span><span class="w"> </span><span class="err">_ingest/pipeline/my-pipeline</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Pipeline to convert timestamp to date"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"processors"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"date"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"timestamp"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"target_field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"@timestamp"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"formats"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span><span class="p">]</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>在这个例子中，<code class="language-plaintext highlighter-rouge">my-pipeline</code> 管道会将所有文档的 <code class="language-plaintext highlighter-rouge">timestamp</code> 字段转换成 <code class="language-plaintext highlighter-rouge">@timestamp</code> 字段，格式为 <code class="language-plaintext highlighter-rouge">yyyy-MM-dd'T'HH:mm:ss.SSS'Z'</code>。</p>

<p>这个请求用于在 Elasticsearch 中创建一个名为 <code class="language-plaintext highlighter-rouge">my-pipeline</code> 的 <strong>ingest pipeline</strong>。Ingest pipeline 是 Elasticsearch 的一种机制，用于在文档被索引之前对文档进行处理。具体到这个例子，它创建了一个管道，该管道使用了一个 <strong>日期处理器（date processor）</strong> 来将 <code class="language-plaintext highlighter-rouge">timestamp</code> 字段的值转换为一个标准的日期格式，并存储到新的字段 <code class="language-plaintext highlighter-rouge">@timestamp</code> 中。</p>

<p><strong>参数解释：</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">PUT _ingest/pipeline/my-pipeline</code></strong></p>

<ul>
  <li>这是创建管道的请求。它使用了 <code class="language-plaintext highlighter-rouge">PUT</code> 方法，并通过 URL <code class="language-plaintext highlighter-rouge">_ingest/pipeline/my-pipeline</code> 指定管道名称为 <code class="language-plaintext highlighter-rouge">my-pipeline</code>。</li>
  <li>这个请求会在 Elasticsearch 中创建或更新名为 <code class="language-plaintext highlighter-rouge">my-pipeline</code> 的管道。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">description</code></strong>: <code class="language-plaintext highlighter-rouge">"Pipeline to convert timestamp to date"</code>:这是对管道的描述。这个字段是可选的，主要用于为管道提供一个简短的描述，帮助用户理解该管道的功能。</p>

<p><strong><code class="language-plaintext highlighter-rouge">processors</code></strong>: <code class="language-plaintext highlighter-rouge">[...]</code></p>

<ul>
  <li><strong>processors</strong> 是一个数组，包含多个处理器（processors），用于定义对文档的处理步骤。</li>
  <li>每个处理器会以特定的方式处理文档中的数据字段。在这个例子中，数组中只有一个处理器——<code class="language-plaintext highlighter-rouge">date</code> 处理器。</li>
</ul>

<hr />

<p><strong>小结：</strong></p>

<p><strong>创建 <code class="language-plaintext highlighter-rouge">my-pipeline</code> 管道</strong>：<code class="language-plaintext highlighter-rouge">PUT _ingest/pipeline/my-pipeline</code>。如果管道不存在，则会创建一个新的管道。</p>

<p><strong>删除 <code class="language-plaintext highlighter-rouge">my-pipeline</code> 管道</strong>：<code class="language-plaintext highlighter-rouge">DELETE _ingest/pipeline/my-pipeline</code></p>

<p><strong>更新 <code class="language-plaintext highlighter-rouge">my-pipeline</code> 管道</strong>：同创建，如果管道存在则覆盖。</p>

<p><strong>获取指定管道的详细信息</strong>：<code class="language-plaintext highlighter-rouge">GET /_ingest/pipeline/{pipeline_id}</code>，其中 <code class="language-plaintext highlighter-rouge">{pipeline_id}</code> 是查询的管道的名称。</p>

<p><strong>列出所有管道</strong>：<code class="language-plaintext highlighter-rouge">GET /_ingest/pipeline</code>。</p>

<h4 id="使用java">使用Java</h4>

<p><strong>创建 Ingest 管道</strong></p>

<p>在 Elasticsearch 中创建管道，需要使用 <code class="language-plaintext highlighter-rouge">PutPipelineRequest</code> 类来设置管道的配置。</p>

<p><strong>步骤</strong>：</p>
<ol>
  <li>设置管道的名称和描述。</li>
  <li>配置管道中的处理器（例如 <code class="language-plaintext highlighter-rouge">date</code> 处理器）。</li>
  <li>执行 <code class="language-plaintext highlighter-rouge">putPipeline</code> 请求来创建管道。</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 配置管道请求</span>
<span class="nc">PutPipelineRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">PutPipelineRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">p</span> <span class="o">-&gt;</span> <span class="n">p</span>
    <span class="o">.</span><span class="na">pipeline</span><span class="o">(</span><span class="s">"my-pipeline"</span><span class="o">)</span>  <span class="c1">// 设置管道名称</span>
    <span class="o">.</span><span class="na">description</span><span class="o">(</span><span class="s">"Pipeline to convert timestamp to date"</span><span class="o">)</span>  <span class="c1">// 设置管道描述</span>
    <span class="o">.</span><span class="na">processors</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>  <span class="c1">// 设置处理器</span>
        <span class="k">new</span> <span class="nf">DateProcessor</span><span class="o">(</span><span class="s">"timestamp"</span><span class="o">,</span> <span class="s">"@timestamp"</span><span class="o">,</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"</span><span class="o">))</span>
    <span class="o">))</span>
<span class="o">);</span>

<span class="c1">// 执行创建管道请求</span>
<span class="nc">PutPipelineResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">ingest</span><span class="o">().</span><span class="na">putPipeline</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>

<span class="c1">// 输出创建结果</span>
<span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">acknowledged</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Pipeline created successfully."</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Failed to create pipeline."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>关键部分</strong>：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">PutPipelineRequest.of(p -&gt; p...)</code></strong>：这段代码构建了管道请求，指定了管道名称、描述以及处理器。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">DateProcessor</code></strong>：这是处理日期格式的处理器，它将字段 <code class="language-plaintext highlighter-rouge">timestamp</code> 的值转换为日期，并将结果存储到 <code class="language-plaintext highlighter-rouge">@timestamp</code> 字段中。</li>
</ul>

<hr />

<p><strong>修改 Ingest 管道</strong></p>

<p>在 Elasticsearch 中，<strong>没有直接修改管道的 API</strong>，可以直接使用创建 Ingest 管道的方式覆盖。</p>

<hr />

<p><strong>删除Ingest 管道</strong></p>

<p>删除管道的操作可以通过 <code class="language-plaintext highlighter-rouge">DeletePipelineRequest</code> 来实现。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建删除管道请求</span>
<span class="nc">DeletePipelineRequest</span> <span class="n">deleteRequest</span> <span class="o">=</span> <span class="nc">DeletePipelineRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">pipeline</span><span class="o">(</span><span class="s">"my-pipeline"</span><span class="o">));</span>

<span class="c1">// 执行删除请求</span>
<span class="nc">DeletePipelineResponse</span> <span class="n">deleteResponse</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">ingest</span><span class="o">().</span><span class="na">deletePipeline</span><span class="o">(</span><span class="n">deleteRequest</span><span class="o">);</span>

<span class="c1">// 输出删除结果</span>
<span class="k">if</span> <span class="o">(</span><span class="n">deleteResponse</span><span class="o">.</span><span class="na">acknowledged</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Pipeline deleted successfully."</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Failed to delete pipeline."</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>查询指定管道</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 查询指定管道</span>
<span class="nc">GetPipelineRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">GetPipelineRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="na">pipeline</span><span class="o">(</span><span class="s">"my-pipeline"</span><span class="o">));</span>
<span class="c1">// 执行查询</span>
<span class="nc">GetPipelineResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">ingest</span><span class="o">().</span><span class="na">getPipeline</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
<span class="c1">// 输出管道的详细信息</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Pipeline details: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">pipelines</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p><strong>查询所有管道</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 查询所有管道</span>
<span class="nc">GetPipelineRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">GetPipelineRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">);</span>  <span class="c1">// 为空表示获取所有管道</span>

<span class="c1">// 执行查询</span>
<span class="nc">GetPipelineResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">ingest</span><span class="o">().</span><span class="na">getPipeline</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>

<span class="c1">// 输出所有管道的详细信息</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"All pipelines: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">pipelines</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p><strong>小结</strong></p>

<ul>
  <li><strong>创建管道</strong>：使用 <code class="language-plaintext highlighter-rouge">PutPipelineRequest</code> 和 <code class="language-plaintext highlighter-rouge">client.ingest().putPipeline()</code> 方法。</li>
  <li><strong>删除管道</strong>：使用 <code class="language-plaintext highlighter-rouge">DeletePipelineRequest</code> 和 <code class="language-plaintext highlighter-rouge">client.ingest().deletePipeline()</code> 方法。</li>
  <li><strong>修改管道</strong>：与创建相同，如果管道存在则覆盖。</li>
  <li><strong>查询管道</strong>：使用 <code class="language-plaintext highlighter-rouge">GetPipelineRequest</code> 和 <code class="language-plaintext highlighter-rouge">client.ingest().getPipeline()</code>。</li>
</ul>

<p>这些操作可以帮助您灵活管理 Elasticsearch 中的 Ingest 管道，确保数据在被索引之前能按照需求进行处理。</p>

<hr />

<h4 id="处理器"><strong>处理器</strong></h4>

<p>Elasticsearch 的 <strong>Ingest Pipeline</strong> 提供了多种处理器（processors），用于在文档被索引前对数据进行处理。除了 <code class="language-plaintext highlighter-rouge">set processor</code>、<code class="language-plaintext highlighter-rouge">rename processor</code> 和 <code class="language-plaintext highlighter-rouge">date processor</code> 之外，还有许多其他处理器，每种处理器用于不同的任务。以下是一些常用的处理器及其功能：</p>

<p><strong>date</strong>: 用于将一个字段的字符串值转换为日期类型。它接收一个或多个输入格式（<code class="language-plaintext highlighter-rouge">formats</code>），并尝试按照这些格式将该字段解析为日期。<strong>常用场景</strong>: 转换日期字符串为日期类型，便于后续的日期操作。下面是该 <code class="language-plaintext highlighter-rouge">date</code> 处理器的各个参数的详细解释：</p>

<p><strong><code class="language-plaintext highlighter-rouge">field</code></strong>: <code class="language-plaintext highlighter-rouge">"timestamp"</code>，这是要转换为日期格式的字段。也就是文档中的 <code class="language-plaintext highlighter-rouge">timestamp</code> 字段的值将被处理并转换为日期。如果文档中存在 <code class="language-plaintext highlighter-rouge">timestamp</code> 字段，处理器会尝试将它的值解析为日期。</p>

<p><strong><code class="language-plaintext highlighter-rouge">target_field</code></strong>: <code class="language-plaintext highlighter-rouge">"@timestamp"</code>，这是转换后结果的目标字段。转换后的日期值将被存储在 <code class="language-plaintext highlighter-rouge">@timestamp</code> 字段中。如果文档中没有 <code class="language-plaintext highlighter-rouge">@timestamp</code> 字段，Elasticsearch 会自动创建它。如果该字段已经存在，<code class="language-plaintext highlighter-rouge">date</code> 处理器会覆盖它。</p>

<p><strong><code class="language-plaintext highlighter-rouge">formats</code></strong>: <code class="language-plaintext highlighter-rouge">["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]</code></p>

<p>这是一个格式数组，用于定义如何解析 <code class="language-plaintext highlighter-rouge">timestamp</code> 字段的值。在这个例子中，只有一个格式：<code class="language-plaintext highlighter-rouge">yyyy-MM-dd'T'HH:mm:ss.SSS'Z'</code>。</p>

<p>这个格式遵循 ISO 8601 日期格式：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">yyyy</code>：年份（四位数）</li>
  <li><code class="language-plaintext highlighter-rouge">MM</code>：月份（两位数）</li>
  <li><code class="language-plaintext highlighter-rouge">dd</code>：日期（两位数）</li>
  <li><code class="language-plaintext highlighter-rouge">T</code>：时间分隔符</li>
  <li><code class="language-plaintext highlighter-rouge">HH</code>：小时（24小时制，两位数）</li>
  <li><code class="language-plaintext highlighter-rouge">mm</code>：分钟（两位数）</li>
  <li><code class="language-plaintext highlighter-rouge">ss</code>：秒数（两位数）</li>
  <li><code class="language-plaintext highlighter-rouge">SSS</code>：毫秒数（3位数）</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">Z</code>：表示零时区，通常用于表示 UTC 时间。</p>
  </li>
  <li>例如，<code class="language-plaintext highlighter-rouge">2024-12-07T10:30:00.000Z</code> 表示 2024 年 12 月 7 日 10:30:00（UTC 时间）。</li>
</ul>

<p><strong>Set</strong>: 用于设置或修改字段的值。如果字段已经存在，该字段的值将被覆盖；如果字段不存在，则会创建该字段。<strong>常用场景</strong>: 为文档中的某个字段赋予固定的值。这个例子将字段 <code class="language-plaintext highlighter-rouge">status</code> 的值设置为 <code class="language-plaintext highlighter-rouge">"active"</code>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"set"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"status"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"value"</span><span class="p">:</span><span class="w"> </span><span class="s2">"active"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Rename</strong>: 用于重命名字段，将一个字段的值赋给另一个字段并删除原始字段。<strong>常用场景</strong>: 重命名字段，以便后续处理或符合索引的设计。这个例子将 <code class="language-plaintext highlighter-rouge">old_name</code> 字段重命名为 <code class="language-plaintext highlighter-rouge">new_name</code>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"rename"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"old_name"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"target_field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"new_name"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Uppercase Processor</strong>: 将字段的值转换为大写形式。<strong>常用场景</strong>: 统一字段值的大小写，便于检索或避免大小写不一致的问题。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"uppercase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"name"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Lowercase Processor</strong>: 将字段的值转换为小写形式。<strong>常用场景</strong>: 将文本数据统一为小写，确保大小写一致性。这个例子将 <code class="language-plaintext highlighter-rouge">email</code> 字段的值转换为小写。:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"lowercase"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"email"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Trim Processor</strong>: 去掉字段值的前后空白字符。<strong>常用场景</strong>: 去除用户输入字段中的多余空格，确保数据一致性。这个例子会去掉 <code class="language-plaintext highlighter-rouge">username</code> 字段前后的空格。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"trim"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"username"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Grok Processor</strong>: 使用 <strong>Grok</strong> 模式（类似正则表达式）从文本中提取信息。<strong>常用场景</strong>: 用于从字段中提取和解析特定模式的数据（如日志文件解析、IP 地址解析等）。这个例子使用 <code class="language-plaintext highlighter-rouge">Grok</code> 模式从 <code class="language-plaintext highlighter-rouge">message</code> 字段中提取出 IPv4 地址并将其存储到 <code class="language-plaintext highlighter-rouge">client_ip</code> 字段。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"grok"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"message"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"patterns"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"%{IPV4:client_ip}"</span><span class="p">]</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Remove Processor</strong>: 删除指定的字段。<strong>常用场景</strong>: 清理无用或敏感的字段，减少存储空间。这个例子会删除 <code class="language-plaintext highlighter-rouge">password</code> 字段。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"remove"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"password"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Json Processor</strong>:从字符串中提取 JSON 数据，并将其解析为字段。<strong>常用场景</strong>: 将嵌套的 JSON 字符串解析为 JSON 对象。这个例子会将 <code class="language-plaintext highlighter-rouge">json_string</code> 字段的 JSON 数据解析为 JSON 对象，并将结果存储到 <code class="language-plaintext highlighter-rouge">json_object</code> 字段。</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"json"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"json_string"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"target_field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"json_object"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Convert Processor</strong>: 将字段的值转换为指定类型（如字符串、整数、布尔值等）。<strong>常用场景</strong>: 确保字段值的数据类型符合预期。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"convert"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"price"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"float"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Script Processor</strong>: 使用脚本动态计算字段的值。<strong>常用场景</strong>: 根据复杂的逻辑动态修改字段值。这个例子通过脚本计算 <code class="language-plaintext highlighter-rouge">discount</code> 字段的值，依据 <code class="language-plaintext highlighter-rouge">price</code> 字段的值来设置不同的折扣。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"script"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"source"</span><span class="p">:</span><span class="w"> </span><span class="s2">"if (ctx.price &lt; 10) { ctx.discount = 0.1 } else { ctx.discount = 0.05 }"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>Split Processor</strong>: 将一个字段的值拆分成多个值，通常是通过分隔符。<strong>常用场景</strong>: 将一个字段的多个值拆分到不同的字段中。这个例子将 <code class="language-plaintext highlighter-rouge">full_name</code> 字段的值按空格拆分，结果存储到 <code class="language-plaintext highlighter-rouge">name_parts</code> 字段中。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"split"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"full_name"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"separator"</span><span class="p">:</span><span class="w"> </span><span class="s2">" "</span><span class="p">,</span><span class="w">
   </span><span class="nl">"target_field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"name_parts"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>IP Processor</strong>: 解析 IP 地址并将其转换为标准格式。<strong>常用场景</strong>: 用于从字符串中提取并解析 IP 地址。这个例子会解析 <code class="language-plaintext highlighter-rouge">ip_address</code> 字段中的 IP 地址并将其存储到 <code class="language-plaintext highlighter-rouge">parsed_ip</code> 字段。</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
 </span><span class="nl">"ip"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ip_address"</span><span class="p">,</span><span class="w">
   </span><span class="nl">"target_field"</span><span class="p">:</span><span class="w"> </span><span class="s2">"parsed_ip"</span><span class="w">
 </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>总结</strong></p>

<p>Elasticsearch 提供的 <strong>Ingest Pipeline</strong> 处理器允许用户在索引数据之前灵活地处理和转换数据。通过这些处理器，用户可以清洗数据、修改字段、提取信息、转换数据类型等，确保索引中的数据符合预期格式并满足搜索需求。根据具体应用场景，开发人员可以选择合适的处理器组合来实现数据处理流程。</p>

<h3 id="批量操作">批量操作</h3>

<p>批量请求允许在一个请求中向 Elasticsearch 发送多个与文档相关的操作。要创建此请求，可以方便地将 builder 对象用于主请求，并为每个操作使用 Fluent DSL。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">sku</span><span class="o">,</span> <span class="nc">String</span> <span class="n">cityBike</span><span class="o">,</span> <span class="kt">double</span> <span class="n">v</span><span class="o">)</span> <span class="o">{}</span>
<span class="nc">Product</span> <span class="n">product1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">" City bike "</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>
<span class="nc">Product</span> <span class="n">product2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-2"</span><span class="o">,</span> <span class="s">" City bike "</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>
<span class="nc">Product</span> <span class="n">product3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-3"</span><span class="o">,</span> <span class="s">" City bike "</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>
<span class="nc">Product</span> <span class="n">product4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-4"</span><span class="o">,</span> <span class="s">" City bike "</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">product1</span><span class="o">,</span><span class="n">product2</span><span class="o">,</span><span class="n">product3</span><span class="o">,</span><span class="n">product4</span><span class="o">);</span>
<span class="c1">// * 使用 Fluent DSL</span>
<span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>
<span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">p</span><span class="o">-&gt;</span> 
    <span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span>
        <span class="o">.</span><span class="na">index</span><span class="o">(</span> <span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span>
            <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">sku</span><span class="o">())</span>
            <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
<span class="o">)));</span>
<span class="nc">BulkResponse</span> <span class="n">result</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">bulk</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>

<span class="k">if</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">errors</span><span class="o">()){</span>
    <span class="n">result</span><span class="o">.</span><span class="na">items</span><span class="o">().</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span><span class="o">-&gt;{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">error</span><span class="o">()!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">error</span><span class="o">().</span><span class="na">reason</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="bulkrequest"><code class="language-plaintext highlighter-rouge">BulkRequest</code></h4>

<p><code class="language-plaintext highlighter-rouge">BulkRequest</code> 是 Elasticsearch Java API 提供的用于批量操作的请求类。它允许在一个请求中执行多个操作（如创建、更新、删除）。以下是其常用方法和变量的详细说明：</p>

<p><strong>主要变量</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">operations</code></strong>：存储所有要在批量操作中执行的操作列表。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">List&lt;BulkOperation&gt;</code></li>
  <li><strong>作用</strong>：每个 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 对象表示一个具体的操作，例如索引文档、更新文档或删除文档。</li>
  <li>
    <p><strong>使用示例</strong>：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>
<span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)));</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">timeout</code></strong>：设置批量请求的超时时间。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">Time</code></li>
  <li><strong>作用</strong>：如果批量操作未在指定时间内完成，可能会被终止。</li>
  <li><strong>使用示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="s">"2m"</span><span class="o">);</span> <span class="c1">// 设置超时为 2 分钟</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">refresh</code></strong>：指定是否刷新索引，使文档在批量操作后立即可见，方法同<code class="language-plaintext highlighter-rouge">IndexRequest</code>。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">Enum</code>（<code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">false</code>, <code class="language-plaintext highlighter-rouge">wait_for</code>）</li>
  <li>
    <p><strong>使用示例</strong>：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">True</span><span class="o">);</span> <span class="c1">// 操作完成后刷新索引</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<p><strong>常用方法</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">operations()</code></strong>：获取当前 <code class="language-plaintext highlighter-rouge">BulkRequest</code> 中的所有操作。</p>

<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">List&lt;BulkOperation&gt;</code></li>
  <li><strong>使用场景</strong>：可以检查请求中包含的所有操作。</li>
  <li>
    <p><strong>示例</strong>：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">BulkOperation</span><span class="o">&gt;</span> <span class="n">ops</span> <span class="o">=</span> <span class="n">bulkRequest</span><span class="o">.</span><span class="na">operations</span><span class="o">();</span>
<span class="n">ops</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">op</span><span class="o">.</span><span class="na">toString</span><span class="o">()));</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">operations(BulkOperation operation)</code></strong>：添加一个操作到批量请求中。</p>

<ul>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">operation</code>：一个 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 对象。</li>
  <li><strong>使用场景</strong>：逐个添加操作。</li>
  <li>
    <p><strong>示例</strong>：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)));</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">operations(List&lt;BulkOperation&gt; operations)</code></strong>：批量添加多个操作到请求中。</p>

<ul>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">operations</code>：一个包含多个 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 的列表。</li>
  <li><strong>使用场景</strong>：在一次调用中添加所有操作。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">BulkOperation</span><span class="o">&gt;</span> <span class="n">operations</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">operations</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">().</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)).</span><span class="na">build</span><span class="o">());</span>
<span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">operations</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">timeout(String timeout)</code></strong>：设置操作的超时时间。</p>

<ul>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">timeout</code>：一个字符串表示的时间值（例如 <code class="language-plaintext highlighter-rouge">"1m"</code> 表示 1 分钟）。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">BulkRequest.Builder</code></li>
  <li><strong>使用场景</strong>：控制批量操作的最大耗时。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="s">"1m"</span><span class="o">);</span> <span class="c1">// 设置超时时间为 1 分钟</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">refresh(Refresh refresh)</code></strong>：设置是否刷新索引，方法同<code class="language-plaintext highlighter-rouge">IndexRequest</code>。</p>

<ul>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">refresh</code>：一个枚举值，可以是 <code class="language-plaintext highlighter-rouge">Refresh.True</code>, <code class="language-plaintext highlighter-rouge">Refresh.False</code>, 或 <code class="language-plaintext highlighter-rouge">Refresh.WaitFor</code>。</li>
  <li><strong>使用场景</strong>：确保数据在操作完成后立即可见。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">WaitFor</span><span class="o">);</span> <span class="c1">// 等待刷新完成</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">build()</code></strong>：构建一个 <code class="language-plaintext highlighter-rouge">BulkRequest</code> 对象。</p>

<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">BulkRequest</code></li>
  <li><strong>使用场景</strong>：完成对 <code class="language-plaintext highlighter-rouge">BulkRequest.Builder</code> 的配置后生成请求对象。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<hr />

<p><strong>批量操作类型的支持</strong></p>

<p><code class="language-plaintext highlighter-rouge">BulkRequest</code> 支持三种操作类型，通过 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 设置具体操作类型：</p>

<p><strong>索引操作（Index）</strong>：用于新增文档。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">)));</span>
</code></pre></div></div>

<p><strong>更新操作（Update）</strong>：用于更新已有文档。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">upd</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">doc</span><span class="o">(</span><span class="n">updateDoc</span><span class="o">)));</span>
</code></pre></div></div>

<p><strong>删除操作（Delete）</strong>：用于删除文档。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">del</span> <span class="o">-&gt;</span> <span class="n">del</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">)));</span>
</code></pre></div></div>

<p>示例：构建一个包含多个操作的 <code class="language-plaintext highlighter-rouge">BulkRequest</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>

<span class="c1">// 添加索引操作</span>
<span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City Bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">))));</span>

<span class="c1">// 添加更新操作</span>
<span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">upd</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"2"</span><span class="o">).</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mf">150.0</span><span class="o">))));</span>

<span class="c1">// 添加删除操作</span>
<span class="n">builder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">del</span> <span class="o">-&gt;</span> <span class="n">del</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"3"</span><span class="o">)));</span>

<span class="c1">// 设置刷新选项和超时时间</span>
<span class="n">builder</span><span class="o">.</span><span class="na">refresh</span><span class="o">(</span><span class="nc">Refresh</span><span class="o">.</span><span class="na">WaitFor</span><span class="o">);</span>
<span class="n">builder</span><span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="s">"2m"</span><span class="o">);</span>

<span class="c1">// 构建并执行请求</span>
<span class="nc">BulkResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">bulk</span><span class="o">(</span><span class="n">builder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>

<span class="c1">// 检查响应是否有错误</span>
<span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">errors</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">response</span><span class="o">.</span><span class="na">items</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">item</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">error</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">error</span><span class="o">().</span><span class="na">reason</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bulk request executed successfully!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>适用场景</p>
<ol>
  <li>大量文档的增删改操作。</li>
  <li>对性能要求较高，减少 HTTP 请求数。</li>
  <li>在分布式场景中需要快速处理批量任务。</li>
</ol>

<h4 id="bulkoperation"><code class="language-plaintext highlighter-rouge">BulkOperation</code></h4>

<p><code class="language-plaintext highlighter-rouge">BulkOperation</code> 是 Elasticsearch Java API 中批量操作请求的组成部分，用于描述单个操作（如创建、更新或删除）。以下是 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 的主要变量和方法的详细介绍。</p>

<p><strong>主要变量</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">index</code></strong>：存储索引操作（<code class="language-plaintext highlighter-rouge">IndexOperation</code>）的定义。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">IndexOperation&lt;TDocument&gt;</code></li>
  <li><strong>作用</strong>：表示一个文档的新增操作。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkOperation</span> <span class="n">op</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">update</code></strong>：存储更新操作（<code class="language-plaintext highlighter-rouge">UpdateOperation</code>）的定义。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">UpdateOperation&lt;TDocument, TPartialDocument&gt;</code></li>
  <li><strong>作用</strong>：表示一个文档的更新操作，可以更新部分或全部内容。</li>
  <li>
    <p><strong>示例</strong>：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkOperation</span> <span class="n">op</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">upd</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mf">150.0</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">delete</code></strong>：存储删除操作（<code class="language-plaintext highlighter-rouge">DeleteOperation</code>）的定义。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">DeleteOperation</code></li>
  <li><strong>作用</strong>：表示一个文档的删除操作。</li>
  <li>
    <p><strong>示例</strong>：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkOperation</span> <span class="n">op</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">del</span> <span class="o">-&gt;</span> <span class="n">del</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">operationType</code></strong>：标识当前操作的类型（<code class="language-plaintext highlighter-rouge">index</code>、<code class="language-plaintext highlighter-rouge">update</code>、<code class="language-plaintext highlighter-rouge">delete</code>）。</p>

<ul>
  <li><strong>类型</strong>：<code class="language-plaintext highlighter-rouge">BulkOperation.Kind</code></li>
  <li><strong>作用</strong>：用于区分操作类型。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Kind</span> <span class="n">type</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="na">operationType</span><span class="o">();</span> <span class="c1">// 返回操作类型</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong>常用方法</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">index(Function&lt;IndexOperation.Builder&lt;TDocument&gt;, ObjectBuilder&lt;IndexOperation&lt;TDocument&gt;&gt;&gt; fn)</code></strong></p>
<ul>
  <li><strong>描述</strong>：设置一个索引操作。</li>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">fn</code>：一个函数，用于配置 <code class="language-plaintext highlighter-rouge">IndexOperation</code>。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">BulkOperation.Builder</code></li>
  <li><strong>使用场景</strong>：添加一个文档的索引操作。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="n">product</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">update(Function&lt;UpdateOperation.Builder&lt;TDocument, TPartialDocument&gt;, ObjectBuilder&lt;UpdateOperation&lt;TDocument, TPartialDocument&gt;&gt;&gt; fn)</code></strong></p>

<ul>
  <li><strong>描述</strong>：设置一个更新操作。</li>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">fn</code>：一个函数，用于配置 <code class="language-plaintext highlighter-rouge">UpdateOperation</code>。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">BulkOperation.Builder</code></li>
  <li><strong>使用场景</strong>：对文档进行更新。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">upd</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mf">200.0</span><span class="o">)));</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">delete(Function&lt;DeleteOperation.Builder, ObjectBuilder&lt;DeleteOperation&gt;&gt; fn)</code></strong></p>

<ul>
  <li><strong>描述</strong>：设置一个删除操作。</li>
  <li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">fn</code>：一个函数，用于配置 <code class="language-plaintext highlighter-rouge">DeleteOperation</code>。</li>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">BulkOperation.Builder</code></li>
  <li><strong>使用场景</strong>：删除文档。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">del</span> <span class="o">-&gt;</span> <span class="n">del</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">));</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">operationType()</code></strong>：返回当前操作的类型。</p>
<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">BulkOperation.Kind</code></li>
  <li><strong>使用场景</strong>：确定操作的类型（如 <code class="language-plaintext highlighter-rouge">index</code>, <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">delete</code>）。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Kind</span> <span class="n">type</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="na">operationType</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Kind</span><span class="o">.</span><span class="na">Index</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"This is an index operation"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">toJsonp()</code></strong>：将当前操作序列化为 JSON。</p>
<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">void</code></li>
  <li><strong>使用场景</strong>：调试或记录操作时查看其 JSON 表示。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">op</span><span class="o">.</span><span class="na">toJsonp</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span> <span class="c1">// 将操作序列化为 JSON 格式</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">equals()</code></strong>：检查两个 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 是否相等。</p>
<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">boolean</code></li>
  <li><strong>使用场景</strong>：判断两个 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 是否具有相同的内容。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">op1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">op2</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"The operations are the same"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">hashCode()</code></strong>：返回 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 的哈希码。</p>
<ul>
  <li><strong>返回值</strong>：<code class="language-plaintext highlighter-rouge">int</code></li>
  <li><strong>使用场景</strong>：在集合（如 <code class="language-plaintext highlighter-rouge">HashMap</code> 或 <code class="language-plaintext highlighter-rouge">HashSet</code>）中存储 <code class="language-plaintext highlighter-rouge">BulkOperation</code>。</li>
  <li><strong>示例</strong>：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="na">hashCode</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hash code: "</span> <span class="o">+</span> <span class="n">hash</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>示例：构建不同类型的 <code class="language-plaintext highlighter-rouge">BulkOperation</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 构建索引操作</span>
<span class="nc">BulkOperation</span> <span class="n">indexOp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City Bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// 构建更新操作</span>
<span class="nc">BulkOperation</span> <span class="n">updateOp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">upd</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">doc</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mf">150.0</span><span class="o">)))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// 构建删除操作</span>
<span class="nc">BulkOperation</span> <span class="n">deleteOp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">()</span>
    <span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">del</span> <span class="o">-&gt;</span> <span class="n">del</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="s">"1"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// 使用操作</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">indexOp</span><span class="o">.</span><span class="na">operationType</span><span class="o">());</span> <span class="c1">// 输出: Index</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">updateOp</span><span class="o">.</span><span class="na">operationType</span><span class="o">());</span> <span class="c1">// 输出: Update</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deleteOp</span><span class="o">.</span><span class="na">operationType</span><span class="o">());</span> <span class="c1">// 输出: Delete</span>
</code></pre></div></div>

<p><strong>适用场景</strong></p>
<ul>
  <li>在批量操作中细粒度控制单个操作的内容。</li>
  <li>使用不同操作类型组合复杂的批量请求。</li>
  <li>动态构建操作类型以适应不同的业务需求。</li>
</ul>

<h4 id="indexrequest和indexoperation"><code class="language-plaintext highlighter-rouge">IndexRequest</code>和<code class="language-plaintext highlighter-rouge">IndexOperation</code></h4>

<p><code class="language-plaintext highlighter-rouge">IndexRequest.Builder&lt;Object&gt;</code> 和 <code class="language-plaintext highlighter-rouge">co.elastic.clients.elasticsearch.core.bulk.IndexOperation.Builder&lt;Object&gt;</code> 是 Elasticsearch Java API 中的两个不同类，虽然它们的功能有相似之处，但用途和上下文不同。</p>

<p><strong><code class="language-plaintext highlighter-rouge">IndexRequest.Builder&lt;Object&gt;</code></strong></p>

<p>用于构建单个索引请求 (<code class="language-plaintext highlighter-rouge">IndexRequest</code>)。主要用于执行单个 <code class="language-plaintext highlighter-rouge">index</code> 操作。</p>

<p><strong>常用场景</strong></p>
<ul>
  <li>直接通过 <code class="language-plaintext highlighter-rouge">IndexRequest</code> 插入或更新一个文档。</li>
  <li>用于非批量的单文档操作。</li>
</ul>

<p><strong>关键方法</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.index(String index)</code>：设置索引名称。</li>
  <li><code class="language-plaintext highlighter-rouge">.id(String id)</code>：设置文档 ID。</li>
  <li><code class="language-plaintext highlighter-rouge">.document(Object document)</code>：设置文档内容。</li>
  <li><code class="language-plaintext highlighter-rouge">.refresh(String refreshPolicy)</code>：设置刷新策略。</li>
  <li><code class="language-plaintext highlighter-rouge">.routing(String routing)</code>：设置路由。</li>
</ul>

<p><strong>示例</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;();</span>
<span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">request</span> <span class="o">=</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City Bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">IndexOperation.Builder&lt;Object&gt;</code></strong></p>

<p>用于构建批量操作中的单个索引操作 (<code class="language-plaintext highlighter-rouge">IndexOperation</code>)。是 <code class="language-plaintext highlighter-rouge">BulkRequest</code> 的组成部分，用于处理多文档的批量操作。</p>

<p><strong>常用场景</strong></p>
<ul>
  <li>在批量操作中添加一个文档的索引操作。</li>
  <li>用于 <code class="language-plaintext highlighter-rouge">BulkRequest</code>，支持与其他操作（如 <code class="language-plaintext highlighter-rouge">update</code>、<code class="language-plaintext highlighter-rouge">delete</code>）混合使用。</li>
</ul>

<p><strong>关键方法</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">.index(String index)</code>：设置索引名称。</li>
  <li><code class="language-plaintext highlighter-rouge">.id(String id)</code>：设置文档 ID。</li>
  <li><code class="language-plaintext highlighter-rouge">.document(Object document)</code>：设置文档内容。</li>
</ul>

<p><strong>示例</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IndexOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexOperation</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;&gt;();</span>
<span class="nc">IndexOperation</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">operation</span> <span class="o">=</span> <span class="n">builder</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City Bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><strong>主要区别</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>特性</strong></th>
      <th>**IndexRequest.Builder<object>**</object></th>
      <th>**IndexOperation.Builder<object>**</object></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>用途</strong></td>
      <td>用于构建单个索引请求。</td>
      <td>用于构建批量操作中的单个索引操作。</td>
    </tr>
    <tr>
      <td><strong>适用范围</strong></td>
      <td>独立的 <code class="language-plaintext highlighter-rouge">IndexRequest</code>。</td>
      <td>嵌套在 <code class="language-plaintext highlighter-rouge">BulkRequest</code> 中作为 <code class="language-plaintext highlighter-rouge">BulkOperation</code> 的一部分。</td>
    </tr>
    <tr>
      <td><strong>所属类</strong></td>
      <td><code class="language-plaintext highlighter-rouge">co.elastic.clients.elasticsearch.core.IndexRequest.Builder</code></td>
      <td><code class="language-plaintext highlighter-rouge">co.elastic.clients.elasticsearch.core.bulk.IndexOperation.Builder</code></td>
    </tr>
    <tr>
      <td><strong>与批量操作的关联</strong></td>
      <td>不直接用于批量操作。</td>
      <td>专门用于批量操作 (<code class="language-plaintext highlighter-rouge">BulkRequest</code>) 的子操作。</td>
    </tr>
    <tr>
      <td><strong>额外设置</strong></td>
      <td>支持 <code class="language-plaintext highlighter-rouge">refresh</code>, <code class="language-plaintext highlighter-rouge">routing</code> 等请求级别参数设置。</td>
      <td>更简单，专注于批量操作中必要的字段（索引名、文档 ID、文档内容）。</td>
    </tr>
  </tbody>
</table>

<hr />

<p><strong>它们是否可以替代？</strong></p>
<ul>
  <li><strong>不可以完全替代</strong>：<code class="language-plaintext highlighter-rouge">IndexRequest.Builder&lt;Object&gt;</code> 专注于单文档的独立索引操作，而 <code class="language-plaintext highlighter-rouge">IndexOperation.Builder&lt;Object&gt;</code> 是批量请求的组件之一。</li>
  <li><strong>共同点</strong>：两者都提供 <code class="language-plaintext highlighter-rouge">.index</code>、<code class="language-plaintext highlighter-rouge">.id</code> 和 <code class="language-plaintext highlighter-rouge">.document</code> 方法用于定义文档的索引行为。</li>
</ul>

<hr />

<p><strong>组合使用示例</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 单个索引请求</span>
<span class="nc">IndexRequest</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">singleIndexRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IndexRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;()</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-1"</span><span class="o">,</span> <span class="s">"City Bike"</span><span class="o">,</span> <span class="mf">123.0</span><span class="o">))</span>
    <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// 批量操作中的索引请求</span>
<span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span> <span class="n">bulkBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BulkRequest</span><span class="o">.</span><span class="na">Builder</span><span class="o">();</span>
<span class="n">bulkBuilder</span><span class="o">.</span><span class="na">operations</span><span class="o">(</span><span class="n">op</span> <span class="o">-&gt;</span> <span class="n">op</span><span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="n">idx</span> <span class="o">-&gt;</span> <span class="n">idx</span>
    <span class="o">.</span><span class="na">index</span><span class="o">(</span><span class="s">"products"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="s">"bk-2"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">document</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"bk-2"</span><span class="o">,</span> <span class="s">"Mountain Bike"</span><span class="o">,</span> <span class="mf">456.0</span><span class="o">))</span>
<span class="o">));</span>

<span class="nc">BulkResponse</span> <span class="n">bulkResponse</span> <span class="o">=</span> <span class="n">esClient</span><span class="o">.</span><span class="na">bulk</span><span class="o">(</span><span class="n">bulkBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
</code></pre></div></div>

<h4 id="bulkresponse"><code class="language-plaintext highlighter-rouge">BulkResponse</code></h4>

<p><code class="language-plaintext highlighter-rouge">BulkResponse</code> 是 Elasticsearch Java API 中用于表示批量操作结果的类，包含了关于批量操作成功与否的详细信息，包括每个操作的状态和可能的错误。</p>

<p><strong>核心变量</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">items</code></strong>：<strong>类型</strong>: <code class="language-plaintext highlighter-rouge">List&lt;BulkResponseItem&gt;</code></p>

<ul>
  <li><strong>说明</strong>: 包含每个批量操作的结果列表。每个操作对应一个 <code class="language-plaintext highlighter-rouge">BulkResponseItem</code>，其中详细记录了操作类型、状态码、错误信息等。</li>
  <li><strong>用途</strong>:用于逐项检查批量操作是否成功。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">BulkResponseItem</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">items</span><span class="o">();</span>
 <span class="k">for</span> <span class="o">(</span><span class="nc">BulkResponseItem</span> <span class="n">item</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Operation: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">operation</span><span class="o">());</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Status: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">status</span><span class="o">());</span>
 <span class="o">}</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">errors</code></strong>：<strong>类型</strong>: <code class="language-plaintext highlighter-rouge">boolean</code></p>

<ul>
  <li><strong>说明</strong>: 如果 <code class="language-plaintext highlighter-rouge">true</code>，则表明批量操作中至少有一个请求失败。</li>
  <li><strong>用途</strong>:用来快速判断是否需要处理错误。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">errors</span><span class="o">())</span> <span class="o">{</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"There were errors in the bulk operation."</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">took</code></strong>：<strong>类型</strong>: <code class="language-plaintext highlighter-rouge">long</code></p>

<ul>
  <li><strong>说明</strong>: 批量操作耗时，单位为毫秒。</li>
  <li><strong>用途</strong>:可用于性能分析和调试。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bulk operation took: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">took</span><span class="o">()</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p><strong>主要方法</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">items()</code></strong>：<strong>返回类型</strong>: <code class="language-plaintext highlighter-rouge">List&lt;BulkResponseItem&gt;</code></p>

<ul>
  <li><strong>作用</strong>:获取批量操作中每个请求的结果。</li>
  <li><strong>常用场景</strong>:检查每个操作是否成功或失败。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="o">(</span><span class="nc">BulkResponseItem</span> <span class="n">item</span> <span class="o">:</span> <span class="n">response</span><span class="o">.</span><span class="na">items</span><span class="o">())</span> <span class="o">{</span>
     <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">error</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">error</span><span class="o">().</span><span class="na">reason</span><span class="o">());</span>
     <span class="o">}</span>
 <span class="o">}</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">errors()</code></strong>：<strong>返回类型</strong>: <code class="language-plaintext highlighter-rouge">boolean</code></p>

<ul>
  <li><strong>作用</strong>:检查批量操作中是否有错误。</li>
  <li><strong>常用场景</strong>:在日志中记录错误，或执行相应的错误处理逻辑。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">errors</span><span class="o">())</span> <span class="o">{</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Some operations failed!"</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">took()</code></strong>：<strong>返回类型</strong>: <code class="language-plaintext highlighter-rouge">long</code></p>

<ul>
  <li><strong>作用</strong>:获取整个批量操作的耗时。</li>
  <li><strong>常用场景</strong>:用于性能监控。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Operation took: "</span> <span class="o">+</span> <span class="n">response</span><span class="o">.</span><span class="na">took</span><span class="o">()</span> <span class="o">+</span> <span class="s">" ms"</span><span class="o">);</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">toString()</code></strong>：<strong>返回类型</strong>: <code class="language-plaintext highlighter-rouge">String</code></p>

<ul>
  <li><strong>作用</strong>:获取 <code class="language-plaintext highlighter-rouge">BulkResponse</code> 的字符串表示，包含关键信息（如错误和时间）。</li>
  <li><strong>常用场景</strong>:调试时查看响应详情。</li>
  <li><strong>示例</strong>:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<h4 id="bulkresponseitem"><code class="language-plaintext highlighter-rouge">BulkResponseItem</code></h4>

<p><code class="language-plaintext highlighter-rouge">BulkResponseItem</code> 是批量操作中每个操作的结果对象，包含了操作的状态和错误信息。</p>

<p><strong>核心变量</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">index</code></strong>:操作目标的索引名。用于标识此次操作涉及的索引。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">id</code></strong>:操作目标文档的 ID。确定文档的唯一标识。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">status</code></strong>: 返回 HTTP 状态码，表示该操作的执行结果。例如，状态码 <code class="language-plaintext highlighter-rouge">200</code> 表示成功。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">version</code></strong>:文档的版本号。跟踪文档的更新状态。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">operation</code></strong>：表示操作类型，例如 <code class="language-plaintext highlighter-rouge">index</code>、<code class="language-plaintext highlighter-rouge">create</code>、<code class="language-plaintext highlighter-rouge">update</code> 或 <code class="language-plaintext highlighter-rouge">delete</code>。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">error</code></strong> : 错误信息，类型为 <code class="language-plaintext highlighter-rouge">ErrorCause</code>，如果没有错误则为 <code class="language-plaintext highlighter-rouge">null</code>。</li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">result</code></strong>：操作结果，表示文档的操作状态，常见的值包括：</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">"created"</code>: 文档被成功创建。</li>
      <li><code class="language-plaintext highlighter-rouge">"updated"</code>: 文档被成功更新。</li>
      <li><code class="language-plaintext highlighter-rouge">"deleted"</code>: 文档被成功删除</li>
      <li><code class="language-plaintext highlighter-rouge">"not_found"</code>: 在执行操作时，文档不存在。</li>
      <li><code class="language-plaintext highlighter-rouge">"noop"</code>: 没有操作（例如在某些条件下没有对文档进行更改）。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">shardInfo</code></strong>：类型**: <code class="language-plaintext highlighter-rouge">ShardStatistics</code>，提供有关分片执行信息的统计，例如成功、失败、总分片数。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">seqNo</code></strong>: <code class="language-plaintext highlighter-rouge">long</code>,表示操作对应的序列号（sequence number）。用于跟踪操作顺序。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">primaryTerm</code></strong>: <code class="language-plaintext highlighter-rouge">long</code>。 表示操作发生时的主分片术语（primary term）。与序列号一起用于实现乐观并发控制。</li>
</ol>

<p><strong>方法</strong></p>

<p>要获取这些值，可以通过同名方法获取。</p>

<p><strong>示例</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">BulkResponseItem</span> <span class="n">item</span> <span class="o">:</span> <span class="n">response</span><span class="o">.</span><span class="na">items</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Index: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">index</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ID: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">id</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Status: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">status</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">error</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error: "</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">error</span><span class="o">().</span><span class="na">reason</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="复制索引">复制索引</h3>

<p>在建立新索引前，可以指定映射：</p>

<p><code class="language-plaintext highlighter-rouge">put /索引名</code></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"mappings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"memberInfo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"phone"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"text"</span><span class="w">
          </span><span class="p">}</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">post /_reindex</code></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"source"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tb_member_portrait"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"dest"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tb_member_portrait2"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>完成复制</p>]]></content><author><name>acteds</name></author><category term="Java" /><category term="elasticsearch" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">form-data传输</title><link href="/2024/12/04/form-data%E4%BC%A0%E8%BE%93/" rel="alternate" type="text/html" title="form-data传输" /><published>2024-12-04T00:00:00+08:00</published><updated>2024-12-04T00:00:00+08:00</updated><id>/2024/12/04/form-data%E4%BC%A0%E8%BE%93</id><content type="html" xml:base="/2024/12/04/form-data%E4%BC%A0%E8%BE%93/"><![CDATA[<h1 id="引言">引言</h1>

<p><code class="language-plaintext highlighter-rouge">http</code>-<code class="language-plaintext highlighter-rouge">form-data</code>，传输方式的一些说明。</p>

<h1 id="http">http</h1>

<h2 id="form-data">form-data</h2>

<h3 id="基本概念"><strong>基本概念</strong></h3>
<p><code class="language-plaintext highlighter-rouge">form-data</code> 是一种用于通过 HTTP POST 请求传输数据的编码方式，通常用于上传文件和发送表单数据。它允许将数据按字段进行分组，每个字段可以包含文本或二进制数据（如文件）。这种编码方式将表单数据按键值对形式进行传输，每个字段与其他字段之间通过边界分隔。</p>

<ul>
  <li><strong>表单数据（Form Data）</strong>：即在 HTML 表单中通过 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code> 标签和其他表单元素传递的数据。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">multipart/form-data</code></strong>：指定数据采用多部分表单数据格式，每部分可以是文本字段，也可以是文件。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">form-data</code> 传输的组成</strong></p>

<ul>
  <li><strong>Content-Type</strong>: <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 这意味着请求的数据是多部分的，通常用于文件上传。</li>
  <li><strong>边界（boundary）</strong>: 这是一种分隔符，用于标识不同的字段和数据部分。<code class="language-plaintext highlighter-rouge">boundary</code> 是一个字符串，通常由服务器自动生成。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">form-data</code> 示例</strong></p>

<p><strong>表单数据传输</strong></p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">"/upload"</span> <span class="na">method=</span><span class="s">"post"</span> <span class="na">enctype=</span><span class="s">"multipart/form-data"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"file"</span> <span class="na">name=</span><span class="s">"file"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"user1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Upload"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</code></pre></div></div>

<p>当表单提交时，浏览器会自动将数据转化为 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 格式并发送。</p>

<p><strong>Request Headers</strong></p>

<p>请求的头部包含如下信息：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Length: 1234
</code></pre></div></div>

<p><strong>Request Body (Body Body)</strong></p>

<p>表单数据的主体部分会如下所示进行编码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

user1
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

&lt;文件内容&gt;
------WebKitFormBoundary7MA4YWxkTrZu0gW--
</code></pre></div></div>

<p>这里每一部分的数据使用边界字符串 <code class="language-plaintext highlighter-rouge">------WebKitFormBoundary7MA4YWxkTrZu0gW</code> 分隔，文件和文本字段都可以在同一个请求体内传输。</p>

<h3 id="限制">限制</h3>
<p><code class="language-plaintext highlighter-rouge">multipart/form-data</code> 是一种用于通过 HTTP POST 请求上传文件和提交表单数据的编码方式。尽管它广泛用于文件上传和表单数据提交，但在某些情况下会遇到大小和数据类型的限制。</p>

<p><strong>大小限制</strong>
<code class="language-plaintext highlighter-rouge">multipart/form-data</code> 请求的最大传输大小通常受以下因素的限制：</p>

<p><strong>服务器配置</strong>
<strong>Spring Boot (Tomcat 默认)</strong>: Spring Boot 使用的嵌入式 Tomcat 服务器有默认的文件上传大小限制。通常是 2MB。</p>

<p>可以在 <code class="language-plaintext highlighter-rouge">application.properties</code> 或 <code class="language-plaintext highlighter-rouge">application.yml</code> 中修改该配置：</p>
<div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">spring.servlet.multipart.max-file-size</span><span class="p">=</span><span class="s">10MB   # 限制单个文件的大小</span>
<span class="py">spring.servlet.multipart.max-request-size</span><span class="p">=</span><span class="s">20MB # 限制整个请求的大小</span>
</code></pre></div></div>

<p>对于 <code class="language-plaintext highlighter-rouge">application.yml</code>，配置如下：</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
<span class="na">servlet</span><span class="pi">:</span>
  <span class="na">multipart</span><span class="pi">:</span>
    <span class="na">max-file-size</span><span class="pi">:</span> <span class="s">10MB</span>
    <span class="na">max-request-size</span><span class="pi">:</span> <span class="s">20MB</span>
</code></pre></div></div>

<p><strong>NGINX / 反向代理配置</strong>
如果你的应用通过 NGINX 作为反向代理访问，还需要配置 NGINX 的文件上传大小限制。默认情况下，NGINX 可能限制最大上传文件大小为 1MB。</p>

<div class="language-nginx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">client_max_body_size</span> <span class="mi">20M</span><span class="p">;</span>  <span class="c1"># 设置最大请求体大小为 20MB</span>
</code></pre></div></div>

<p><strong>Web服务器和应用服务器的其他限制</strong></p>
<ul>
  <li><strong>Apache</strong>、<strong>Tomcat</strong>、<strong>Jetty</strong> 等服务器也有类似的上传大小限制，通常可以通过相应的配置文件调整：
    <ul>
      <li>Tomcat 中 <code class="language-plaintext highlighter-rouge">server.xml</code> 中的 <code class="language-plaintext highlighter-rouge">maxPostSize</code> 设置。</li>
      <li>Apache 中的 <code class="language-plaintext highlighter-rouge">LimitRequestBody</code> 设置。</li>
    </ul>
  </li>
</ul>

<p><strong>数据类型限制</strong>
<code class="language-plaintext highlighter-rouge">multipart/form-data</code> 本身不限制数据类型，理论上可以传递任何类型的数据（包括文本、数字、二进制数据、文件等）。不过，某些数据类型可能会遇到处理上的限制。</p>

<p><strong>文本数据</strong></p>
<ul>
  <li>表单字段通常以 <code class="language-plaintext highlighter-rouge">key-value</code> 形式传输（如：<code class="language-plaintext highlighter-rouge">key=value</code>）。Spring 和其他框架会自动解析表单中的文本数据。</li>
  <li>对于长文本数据，<code class="language-plaintext highlighter-rouge">multipart/form-data</code> 没有特别的限制，只要不超过请求大小的限制即可。</li>
</ul>

<p><strong>文件数据</strong></p>
<ul>
  <li>文件内容通过 <code class="language-plaintext highlighter-rouge">Content-Type</code> 和 <code class="language-plaintext highlighter-rouge">Content-Disposition</code> 头传输，每个文件都会有文件名、类型、大小等元数据。</li>
  <li><strong>文件大小</strong>：如前所述，上传的文件大小会受到服务器配置的限制。</li>
  <li><strong>文件类型</strong>：文件的 <code class="language-plaintext highlighter-rouge">Content-Type</code>（MIME 类型）由浏览器自动生成，也可以在前端指定。例如，<code class="language-plaintext highlighter-rouge">image/jpeg</code>、<code class="language-plaintext highlighter-rouge">application/pdf</code>、<code class="language-plaintext highlighter-rouge">text/plain</code> 等。</li>
</ul>

<p><strong>大文件传输</strong></p>
<ul>
  <li>上传非常大的文件时，<code class="language-plaintext highlighter-rouge">multipart/form-data</code> 可能会出现性能问题，特别是当文件和其他表单字段一起上传时，处理可能会比较慢。</li>
  <li>大文件上传时，可以考虑使用分块上传（比如 HTML5 的 <code class="language-plaintext highlighter-rouge">FileReader</code> API 和服务器端的分块处理）。</li>
</ul>

<p><strong>编码和字符集限制</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">multipart/form-data</code> 默认使用 <strong><code class="language-plaintext highlighter-rouge">ISO-8859-1</code></strong> 编码方式，可能会在处理非拉丁字符集（如中文、阿拉伯文等）时遇到问题。为了正确处理字符集，可以在 <code class="language-plaintext highlighter-rouge">Content-Type</code> 中显式指定字符集：</li>
</ul>

<div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Content-Type: multipart/form-data; charset=UTF-8; boundary=---boundary-string
</span></code></pre></div></div>

<ul>
  <li>然而，<code class="language-plaintext highlighter-rouge">multipart/form-data</code> 本身并没有强制要求字符集设置为 <code class="language-plaintext highlighter-rouge">UTF-8</code>。对于表单文本字段的内容，推荐使用 UTF-8 编码来避免字符集不兼容问题。</li>
</ul>

<p><strong>特殊字符问题</strong>
在上传包含特殊字符（如 <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">=</code>, <code class="language-plaintext highlighter-rouge">%</code>, <code class="language-plaintext highlighter-rouge">#</code> 等）或文件名中包含空格、中文字符时，需要进行 URL 编码或 Base64 编码，否则可能会导致请求失败。</p>

<p><strong>浏览器和客户端限制</strong>
不同浏览器或客户端对 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 可能有不同的支持和限制：</p>
<ul>
  <li>文件大小限制：浏览器通常会限制每个文件的最大上传大小。浏览器可能会阻止超过某个大小的文件上传。</li>
  <li>单个请求中的字段数：虽然没有硬性规定，但多数浏览器和服务器对单个请求中的字段数量有限制。</li>
</ul>

<h3 id="数组类型处理">数组类型处理</h3>

<p><code class="language-plaintext highlighter-rouge">multipart/form-data</code> 本身并不直接支持数组或列表类型，但可以通过特定方式传递数组或列表数据。实际上，可以通过以下两种常见方法来模拟数组或列表的传递：</p>

<p><strong>通过多个同名字段传递数组数据</strong></p>

<p>在 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 请求中，可以通过使用多个具有<strong>相同名字</strong>的字段来传递数组数据。Spring 会自动将这些字段映射到 <code class="language-plaintext highlighter-rouge">String[]</code> 或 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> 等集合类型。</p>

<p>在这种方式下，Spring 会自动将每个 <code class="language-plaintext highlighter-rouge">uniqueKey</code> 字段（如 <code class="language-plaintext highlighter-rouge">uniqueKey=key1&amp;uniqueKey=key2&amp;uniqueKey=key3</code>）解析为 <code class="language-plaintext highlighter-rouge">String[]</code> 类型，即 <code class="language-plaintext highlighter-rouge">["key1", "key2", "key3"]</code>。</p>

<p><strong>通过逗号分隔的字符串传递数组</strong></p>

<p>如果你希望将列表作为一个单独的字段传递，可以使用逗号分隔的字符串，并在后端将其转换为 <code class="language-plaintext highlighter-rouge">List</code> 或 <code class="language-plaintext highlighter-rouge">String[]</code>。</p>

<p>在这种方式下，<code class="language-plaintext highlighter-rouge">uniqueKey</code> 参数会作为一个字符串传递，包含逗号分隔的元素。你可以在后端使用 <code class="language-plaintext highlighter-rouge">split(",")</code> 方法将其转换为 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code> 或 <code class="language-plaintext highlighter-rouge">String[]</code>。</p>

<p><strong>使用 JSON 格式传递数组</strong></p>

<p>另一种方法是通过 JSON 格式传递数组。为了实现这一点，你可以将整个数组或复杂的对象封装为 JSON 字符串，并在后端将其解析为 Java 对象。这种方法通常用于传递更复杂的数据结构。</p>

<p>在这种方法中，前端需要传递一个合法的 JSON 字符串，后端使用 <code class="language-plaintext highlighter-rouge">ObjectMapper</code> 来解析它为 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>。</p>

<p><strong>总结</strong></p>

<p>虽然 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 不直接支持数组类型，但可以通过以下方式来传递数组数据：</p>

<ol>
  <li>
    <p><strong>多个同名字段</strong>：通过在请求中传递多个具有相同名称的字段（例如，<code class="language-plaintext highlighter-rouge">uniqueKey=key1&amp;uniqueKey=key2&amp;uniqueKey=key3</code>）来模拟数组，Spring 会自动将其映射为 <code class="language-plaintext highlighter-rouge">String[]</code> 或 <code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>。</p>
  </li>
  <li>
    <p><strong>逗号分隔的字符串</strong>：通过传递一个逗号分隔的字符串（例如，<code class="language-plaintext highlighter-rouge">uniqueKey=key1,key2,key3</code>），在后端将其拆分为数组或列表。</p>
  </li>
  <li>
    <p><strong>JSON 格式</strong>：通过将数组封装为 JSON 字符串传递，并在后端解析为数组或列表（例如，<code class="language-plaintext highlighter-rouge">uniqueKey=["key1","key2","key3"]</code>）。</p>
  </li>
</ol>]]></content><author><name>acteds</name></author><category term="Java" /><category term="http" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">并行流的相关问题</title><link href="/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" rel="alternate" type="text/html" title="并行流的相关问题" /><published>2024-12-03T00:00:00+08:00</published><updated>2024-12-03T00:00:00+08:00</updated><id>/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98</id><content type="html" xml:base="/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"><![CDATA[<h1 id="引言">引言</h1>

<p>并行流的相关问题，顺序问题，以及多线程问题。</p>

<h1 id="java">Java</h1>

<h2 id="stream流">Stream流</h2>

<h3 id="并行流">并行流</h3>

<h4 id="顺序">顺序</h4>

<p>并行流 (<code class="language-plaintext highlighter-rouge">parallelStream</code>) 并不保证元素的顺序。默认情况下，<code class="language-plaintext highlighter-rouge">parallelStream</code> 会分割任务并让多个线程并行处理数据，这样<strong>处理顺序</strong>是不可预测的，因此它无法保证结果的顺序。</p>

<p><strong>保证结果顺序：</strong></p>

<p><strong>使用顺序流</strong>：如果你不特别需要并行处理，可以改为使用顺序流（即使用 <code class="language-plaintext highlighter-rouge">stream()</code> 而不是 <code class="language-plaintext highlighter-rouge">parallelStream()</code>），这样可以确保顺序不变。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getStringCellValue</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">collect</code> 时强制保序</strong>：如果你坚持使用并行流，并且仍然需要保持顺序，可以在收集结果时使用 <code class="language-plaintext highlighter-rouge">Collectors.toList()</code>，因为它会<strong>按顺序将流中的元素收集到列表</strong>中，即使是并行流：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">true</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getStringCellValue</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<p>还可以显示的在流的末尾使用 <code class="language-plaintext highlighter-rouge">sorted()</code> 或 <code class="language-plaintext highlighter-rouge">forEachOrdered()</code> 来强制保持顺序。</p>

<hr />

<p>但是，<strong>即使你使用 <code class="language-plaintext highlighter-rouge">Collectors.toList()</code></strong>，并行流的<strong>内部执行顺序</strong>仍然不可预测，即：</p>

<p>并行流在执行时不会保证操作的顺序。流中的操作可能会被多个线程并行执行，这样即使是 <code class="language-plaintext highlighter-rouge">map</code> 或 <code class="language-plaintext highlighter-rouge">filter</code> 这些按顺序执行的操作，在并行流中也可能会导致结果的顺序发生改变。</p>

<p>为什么并行流与 <code class="language-plaintext highlighter-rouge">Collectors.toList()</code> 保持顺序？</p>

<p>流的合并方式： 当使用 <code class="language-plaintext highlighter-rouge">parallelStream</code> 时，数据会被分割成多个片段，每个线程处理其中的一部分。每个片段中的操作是顺序的，但它们之间的合并顺序不一定保持一致。</p>

<p><code class="language-plaintext highlighter-rouge">Collectors.toList()</code> 的行为：</p>

<p><code class="language-plaintext highlighter-rouge">Collectors.toList()</code> 是一个 无状态收集器，它只是将流中的元素收集到一个新的列表中。由于 <code class="language-plaintext highlighter-rouge">List</code> 是有顺序的容器，所以它会保持收集的顺序，即使是并行流。因为在 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 的情况下，流会分割成多个子流，并行处理后最终合并，而合并时，<code class="language-plaintext highlighter-rouge">toList</code> 会保持各个子流处理后的顺序。</p>

<h4 id="多线程">多线程</h4>

<p>并行流（<code class="language-plaintext highlighter-rouge">parallelStream</code>）是 Java 8 引入的功能，它通过分割数据源来使用多个线程并行地处理数据，从而提高处理速度。但并行流的多线程使用也带来了一些潜在的问题，特别是在以下几种情况下：</p>

<p><strong>线程安全问题</strong></p>

<p>并行流使用多个线程同时操作同一数据，这可能会引发线程安全问题。例如，如果你在流的操作中修改共享的可变对象，或者在 <code class="language-plaintext highlighter-rouge">collect</code> 操作中使用了非线程安全的集合，就可能会出现并发修改的问题。</p>

<p>解决方案：</p>

<ul>
  <li>对于共享的资源，确保线程安全。可以使用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>、<code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList</code> 等线程安全的集合。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">synchronized</code> 或 <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 来保证每个线程操作自己的副本。</li>
  <li>避免在流中直接修改外部共享的状态，特别是在 <code class="language-plaintext highlighter-rouge">forEach</code> 操作中。</li>
</ul>

<p><strong>状态不一致</strong></p>

<p>并行流中的一些操作可能会导致中间结果的不一致。例如，在并行流的某个操作中修改了共享状态，可能会造成中间状态在多个线程之间不一致，最终导致结果不正确。</p>

<p>解决方案：</p>
<ul>
  <li>避免修改流中的共享状态，尤其是不可变对象的状态。</li>
  <li>使用不可变对象和线程本地数据来避免状态不一致。</li>
  <li>对于需要修改状态的操作，确保该操作是原子性的。</li>
</ul>

<p><strong>线程池饱和</strong>
并行流会使用公共的 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> 来管理线程池。如果并行流的任务过多，线程池可能会耗尽，导致线程饱和，甚至阻塞其他任务。</p>

<p>解决方案：</p>

<ul>
  <li>可以通过设置系统属性 <code class="language-plaintext highlighter-rouge">java.util.concurrent.ForkJoinPool.common.parallelism</code> 来控制 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> 的线程池大小（默认为 <code class="language-plaintext highlighter-rouge">availableProcessors</code>）。</li>
  <li>对于非常重的任务，考虑使用自定义的线程池，而不是依赖默认的公共线程池。</li>
</ul>

<p><strong>示例代码：避免线程安全问题</strong></p>

<p>假设你在使用并行流时修改了共享的 <code class="language-plaintext highlighter-rouge">List</code>，这将导致线程安全问题：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sharedList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>

<span class="c1">// 错误的并行流：会修改共享资源，造成线程安全问题</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">sharedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 不安全</span>

<span class="c1">// 正确的做法：使用线程安全的集合或避免共享资源</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">safeList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">safeList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 安全</span>
</code></pre></div></div>

<p>或者，避免在流操作中修改外部状态：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误的做法：修改外部共享状态</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">externalList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">externalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 可能不安全</span>

<span class="c1">// 正确的做法：使用局部变量或者线程局部变量</span>
<span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">localList</span> <span class="o">=</span> <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">withInitial</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">localList</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 安全</span>
</code></pre></div></div>

<p>并行流在适当的场景下可以显著提升性能，但如果使用不当，会导致性能问题或线程安全问题。为了安全高效地使用并行流：</p>
<ul>
  <li>确保流中的操作是线程安全的。</li>
  <li>避免并行化不适合并行的任务。</li>
  <li>处理数据时，确保操作的顺序性（如果需要的话）。</li>
  <li>留意线程池资源限制和并行度的配置。</li>
</ul>

<p>使用并行流时要权衡其带来的好处与潜在的复杂性和开销。</p>

<h4 id="使用场景">使用场景</h4>

<p>如果数据量小，使用 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 仍然会开启多个线程，但在这种情况下，开多线程的开销可能大于并行处理带来的性能提升。<code class="language-plaintext highlighter-rouge">parallelStream()</code> 并不会自动判断数据量大小并决定是否启用并行。</p>

<p>详细解释：</p>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">parallelStream()</code> 的工作原理</strong>： 
<code class="language-plaintext highlighter-rouge">parallelStream()</code> 会将数据分成多个片段，并在不同的线程中并行处理这些片段。具体来说，它使用了 <strong><code class="language-plaintext highlighter-rouge">ForkJoinPool</code></strong> 来管理线程池，默认情况下，会根据 CPU 核心数来决定线程池的大小。</p>
  </li>
  <li>
    <p><strong>线程开销</strong>： 
对于较小的数据量，线程的创建、上下文切换和管理等开销可能超过并行化处理所带来的性能提升。这是因为每个线程都有一定的启动成本，而如果数据量不够大，单线程的处理可能已经足够高效。</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">parallelStream()</code> 会开线程</strong>： 
即使数据量很小，调用 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 依然会启动多个线程，具体线程数取决于 <strong><code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code></strong> 的设置，默认情况下，它会根据机器的 <strong>CPU 核心数</strong> 来分配线程数。如果你的 CPU 核心数较多，<code class="language-plaintext highlighter-rouge">parallelStream()</code> 会使用多个线程来处理即使是小的数据集。</p>
  </li>
  <li>
    <p><strong>性能评估</strong>：</p>
    <ul>
      <li>对于小数据集，<strong>顺序流（<code class="language-plaintext highlighter-rouge">stream()</code>）</strong> 往往比并行流更高效，因为线程开销、任务划分和合并等都增加了额外的成本。</li>
      <li>如果你有大量的数据并行处理，并且<strong>数据量大于处理开销</strong>，<code class="language-plaintext highlighter-rouge">parallelStream()</code> 的并行化处理可能会带来明显的性能提升。</li>
    </ul>
  </li>
</ol>

<p>结论：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">parallelStream()</code> 不会自动判断数据量的大小。</li>
  <li>即使数据量小，<code class="language-plaintext highlighter-rouge">parallelStream()</code> 仍会启动多个线程，但这可能会导致性能下降。</li>
  <li>如果数据量较小，推荐使用顺序流（<code class="language-plaintext highlighter-rouge">stream()</code>），这样可以避免不必要的线程开销。</li>
</ul>

<p>如果你的数据量较小，可以通过对比测试顺序流和并行流的性能，来决定是否使用并行流。</p>

<hr />

<p>“<strong>大</strong>”和“<strong>小</strong>”数据量是相对的，具体取决于多种因素，包括数据的复杂性、处理任务的复杂度、硬件环境、并行化的开销等。没有一个固定的阈值来判断数据量是“大”还是“小”，但可以根据以下几个维度来理解和评估：</p>

<p><strong>数据量的维度</strong></p>
<ul>
  <li><strong>条目数</strong>：指的是集合中元素的数量。比如，<code class="language-plaintext highlighter-rouge">List</code> 中有 1000 条数据，或者 10,000 条数据。</li>
  <li><strong>元素大小</strong>：每个数据项的大小。例如，每个数据项可能是一个简单的整数，或者包含多个字段和复杂的数据结构。</li>
</ul>

<p><strong>一般经验</strong>：</p>
<ul>
  <li>小数据量：通常为 1000 条以下的数据。</li>
  <li>中等数据量：大约 1000 到 100,000 条。</li>
  <li>大数据量：超过 100,000 条数据，尤其是需要做复杂计算时。</li>
</ul>

<p><strong>操作的复杂度</strong></p>
<ul>
  <li><strong>简单操作</strong>：例如对简单数据类型（如整数、字符串等）的求和、查找等操作。</li>
  <li>
    <p><strong>复杂操作</strong>：例如对每个数据项进行复杂的计算、条件筛选、合并、排序、分组等操作。</p>
  </li>
  <li><strong>小数据量</strong> 和 <strong>简单操作</strong>：并行流的开销不明显，可能没有必要使用 <code class="language-plaintext highlighter-rouge">parallelStream()</code>，使用顺序流更为高效。</li>
  <li><strong>小数据量</strong> 和 <strong>复杂操作</strong>：即使数据量小，复杂的操作可能使得并行化处理带来明显的性能提升。</li>
</ul>

<p><strong>硬件和环境的影响</strong></p>
<ul>
  <li><strong>CPU 核心数</strong>：计算机的核心数直接影响并行流的性能。如果只有 2 个核心，使用 4 个线程的并行流可能不会带来太多的性能提升，甚至可能因线程调度开销而影响性能。如果有 16 核或更多的 CPU，数据量更大时并行流的效果会更加明显。</li>
  <li><strong>内存和 I/O 操作</strong>：如果涉及到 I/O 操作（例如从数据库读取大量数据或进行网络请求），那么并行流的好处可能会受到系统 I/O 性能的限制。如果 CPU 处理时间是瓶颈，那么并行化会带来明显提升。</li>
</ul>

<p><strong>性能评估：</strong></p>
<ul>
  <li>对于 <strong>小数据量</strong> 和 <strong>简单操作</strong>，例如几百条数据的简单映射或过滤，顺序流通常更高效，因为创建和调度线程的开销可能超过并行处理的优势。</li>
  <li>对于 <strong>大数据量</strong> 或 <strong>复杂操作</strong>，如需要排序、大量计算或高复杂度的映射等，并行流能够有效利用多核 CPU 的并行处理能力，减少处理时间。</li>
</ul>

<p><strong>经验法则</strong></p>
<ul>
  <li><strong>小数据量</strong>：几百到几千条数据，建议使用 <strong>顺序流</strong>（<code class="language-plaintext highlighter-rouge">stream()</code>）。</li>
  <li><strong>中等数据量</strong>：几千到十几万条数据，使用 <strong>顺序流</strong> 和 <strong>并行流</strong> 性能相近，可以根据实际测试决定。</li>
  <li><strong>大数据量</strong>：超过十万条数据，特别是当数据量远大于 CPU 核心数时，使用 <strong>并行流</strong>（<code class="language-plaintext highlighter-rouge">parallelStream()</code>）通常能获得更好的性能。</li>
</ul>

<p><strong>具体建议：</strong></p>
<ul>
  <li><strong>实验</strong>：可以进行简单的性能测试，对比 <strong>顺序流</strong> 和 <strong>并行流</strong> 的执行时间，特别是在你的数据集和硬件环境下。对于小数据量，通常可以避免使用并行流。</li>
  <li><strong>监控和调优</strong>：在实际应用中，监控处理过程中的资源使用情况，如 CPU、内存等，并根据需要调整。</li>
</ul>

<p>总结：</p>
<ul>
  <li><strong>小数据量</strong>：通常指几百到几千条数据，顺序流更高效。</li>
  <li><strong>大数据量</strong>：通常指超过十万条数据，并且需要进行计算、排序等操作时，使用并行流能带来显著性能提升。</li>
  <li>数据量“多”还是“少”没有严格标准，主要是看操作的复杂性和系统的硬件资源。在处理小数据量时，避免使用 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 会更高效。</li>
</ul>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Excel导入导出</title><link href="/2024/11/18/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/" rel="alternate" type="text/html" title="Excel导入导出" /><published>2024-11-18T00:00:00+08:00</published><updated>2024-11-18T00:00:00+08:00</updated><id>/2024/11/18/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA</id><content type="html" xml:base="/2024/11/18/Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"><![CDATA[<h1 id="引言">引言</h1>

<p>Excel的导入导出、以及CSV文件的导出。</p>

<h1 id="java">Java</h1>

<h2 id="excel导入导出">Excel导入导出</h2>

<p>依赖添加：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependencies&gt;</span>
    <span class="c">&lt;!-- Apache POI Core for Excel (xls) support --&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.apache.poi<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>poi<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>5.2.3<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>

    <span class="c">&lt;!-- Apache POI OOXML for Excel 2007+ (xlsx) support --&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.apache.poi<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>poi-ooxml<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>5.2.3<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>

    <span class="c">&lt;!-- Optional: Apache POI for handling Excel (xlsx) schemas --&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.apache.poi<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>poi-ooxml-schemas<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>5.2.3<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>

    <span class="c">&lt;!-- Optional: Apache POI Scratchpad for more advanced Excel functionalities --&gt;</span>
    <span class="nt">&lt;dependency&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.apache.poi<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>poi-ooxml-scratchpad<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>5.2.3<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>
<span class="nt">&lt;/dependencies&gt;</span>
</code></pre></div></div>

<h3 id="导出">导出</h3>

<p>首先新建一个带异常抛出的<code class="language-plaintext highlighter-rouge">Consumer</code>接口。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 带异常抛出的Consumer
 * @author aotmd
 * @version 1.0
 * @date 2024/11/26 17:34
 */</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="cm">/**
     * 对给定的参数执行此操作，并且可能会引发异常。
     *
     * @param t 输入参数
     * @throws Exception 如果在处理过程中发生任何错误
     */</span>
    <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>然后建立一个服务层：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExcelService</span> <span class="o">{}</span>
</code></pre></div></div>

<p>对于导出，可以直接使用<code class="language-plaintext highlighter-rouge">SXSSFWorkbook</code>类，它会动态管理存储在内存中的行，防止内存溢出。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** 在刷新之前保留在内存中的行数，请参见上文。 */</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">rowAccessWindowSize</span> <span class="o">=</span> <span class="no">DEFAULT_WINDOW_SIZE</span><span class="o">;</span>

<span class="cm">/**
* 设置写操作，在刷新之前保留在内存中的行数
* @param rowAccessWindowSize 在刷新之前保留在内存中的行数
*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRowAccessWindowSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowAccessWindowSize</span><span class="o">)</span> <span class="o">{</span>
<span class="k">this</span><span class="o">.</span><span class="na">rowAccessWindowSize</span> <span class="o">=</span> <span class="n">rowAccessWindowSize</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
* 导出Excel
* @param os 输出流
* @param chineseTableHeader 中文表头
* @param callback 回调
*/</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">exportExcel</span><span class="o">(</span><span class="nc">OutputStream</span> <span class="n">os</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">chineseTableHeader</span><span class="o">,</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="nc">Sheet</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
<span class="cm">/*设置页码*/</span>
<span class="c1">// 创建Excel工作簿</span>
<span class="k">try</span> <span class="o">(</span><span class="nc">SXSSFWorkbook</span> <span class="n">wb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SXSSFWorkbook</span><span class="o">(</span><span class="n">rowAccessWindowSize</span><span class="o">))</span> <span class="o">{</span>
    <span class="nc">Sheet</span> <span class="n">sheet</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="na">createSheet</span><span class="o">(</span><span class="s">"Sheet1"</span><span class="o">);</span>
    <span class="c1">// 设置每列的宽度</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chineseTableHeader</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">sheet</span><span class="o">.</span><span class="na">setColumnWidth</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">5000</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 创建一个CellStyle对象，用于设置加粗样式</span>
    <span class="nc">CellStyle</span> <span class="n">headerCellStyle</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="na">createCellStyle</span><span class="o">();</span>
    <span class="nc">Font</span> <span class="n">headerFont</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="na">createFont</span><span class="o">();</span>
    <span class="n">headerFont</span><span class="o">.</span><span class="na">setBold</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>  <span class="c1">// 设置加粗</span>
    <span class="n">headerCellStyle</span><span class="o">.</span><span class="na">setFont</span><span class="o">(</span><span class="n">headerFont</span><span class="o">);</span>  <span class="c1">// 将加粗字体应用到样式中</span>

    <span class="c1">// 写入表头</span>
    <span class="nc">Row</span> <span class="n">headerRow</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="na">createRow</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">colIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">chineseTableHeader</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">headerRow</span><span class="o">.</span><span class="na">createCell</span><span class="o">(</span><span class="n">colIndex</span><span class="o">++);</span>
        <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">cell</span><span class="o">.</span><span class="na">setCellStyle</span><span class="o">(</span><span class="n">headerCellStyle</span><span class="o">);</span>  <span class="c1">// 应用加粗样式</span>
    <span class="o">}</span>
    <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">sheet</span><span class="o">);</span>
    <span class="n">wb</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">os</span><span class="o">);</span>
    <span class="n">os</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    <span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导出数据抛出异常"</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"导出数据抛出异常"</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法会自动填充表头，并设置加粗样式，然后执行回调方法。</p>

<p>还可以添加一个写入数据行的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 写入数据行到Excel
 *
 * @param sheet       excel对象
 * @param data        数据
 * @param fieldHeader 属性key
 * @param rowIndex    第几行
 */</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">writeDataRowsToExcel</span><span class="o">(</span><span class="nc">Sheet</span> <span class="n">sheet</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fieldHeader</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">colIndex</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Row</span> <span class="n">dataRow</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="na">createRow</span><span class="o">(</span><span class="n">rowIndex</span><span class="o">++);</span>
        <span class="n">colIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">titleKey</span> <span class="o">:</span> <span class="n">fieldHeader</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">dataRow</span><span class="o">.</span><span class="na">createCell</span><span class="o">(</span><span class="n">colIndex</span><span class="o">++);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">line</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">titleKey</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">titleKey</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="n">o</span><span class="o">;</span>
                <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Double</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">((</span><span class="nc">Double</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">rowIndex</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">excelService</span><span class="o">.</span><span class="na">setRowAccessWindowSize</span><span class="o">(</span><span class="no">NUM_PER_PAGE</span><span class="o">);</span>
<span class="n">excelService</span><span class="o">.</span><span class="na">exportExcel</span><span class="o">(</span><span class="n">outputStream</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">,</span> <span class="o">(</span><span class="n">sheet</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 写入数据行，从第1行开始</span>
    <span class="kt">int</span> <span class="n">rowIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="cm">/*获取数据*/</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="o">...;</span>
    <span class="n">rowIndex</span> <span class="o">=</span> <span class="n">excelService</span><span class="o">.</span><span class="na">writeDataRowsToExcel</span><span class="o">(</span><span class="n">sheet</span><span class="o">,</span> <span class="n">rowsData</span><span class="o">,</span> <span class="n">keys</span><span class="o">,</span> <span class="n">rowIndex</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">rowIndex</code>是下一个空行的索引，如果是分段写入，就需要这个值，如果需要通过这个值获取总行数，注意最后减一。</p>

<h3 id="导入">导入</h3>

<p>添加依赖：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--大xlsx文件导入--&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.github.pjfanning/excel-streaming-reader --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.github.pjfanning<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>excel-streaming-reader<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.3.6<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>添加方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 导入Excel
 * @param is 输入流
 * @param callback 回调
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">importExcel</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">is</span><span class="o">,</span> <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="nc">Sheet</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 使用StreamingReader包装后，就只能使用流来操作行了，不能指定获取指定行了</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">Workbook</span> <span class="n">workbook</span> <span class="o">=</span> <span class="nc">StreamingReader</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">rowCacheSize</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>    <span class="c1">// 设置内存中保持的行数，默认是10</span>
            <span class="o">.</span><span class="na">bufferSize</span><span class="o">(</span><span class="mi">4096</span><span class="o">)</span><span class="c1">// 设置读取 InputStream 时的缓冲区大小（字节）</span>
            <span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">is</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">Sheet</span> <span class="n">sheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="na">getSheetAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">sheet</span><span class="o">.</span><span class="na">getLastRowNum</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导入的数据查过10000行"</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"导入的数据查过10000行"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Row</span><span class="o">&gt;</span> <span class="n">rowIterator</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="c1">// 获取数据的表头,第一行</span>
        <span class="nc">Row</span> <span class="n">r</span> <span class="o">=</span> <span class="n">rowIterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getStringCellValue</span><span class="o">)</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

        <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">sheet</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导入时发生异常：{}"</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"导入时发生异常：{}"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">.rowCacheSize(100)</code> 这里也可以抽出来做为配置项。</p>

<p>执行回调方法会传入两个参数，一个是对象，一个是读取到的表头，注意这里迭代器已经消耗完第一行了。</p>

<p>还可以加一个读每行数据的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 获取原值
 *
 * @param cell 单元格
 * @return
 */</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getValue</span><span class="o">(</span><span class="nc">Cell</span> <span class="n">cell</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 单元格类型</span>
    <span class="nc">CellType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getCellType</span><span class="o">();</span>
    <span class="c1">// 值</span>
    <span class="nc">Object</span> <span class="n">value</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">NUMERIC</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 字符串或数字类型</span>
        <span class="kt">double</span> <span class="n">numericCellValue</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getNumericCellValue</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">numericCellValue</span> <span class="o">==</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">numericCellValue</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">numericCellValue</span><span class="o">;</span><span class="c1">// 转为整数</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">numericCellValue</span><span class="o">;</span> <span class="c1">//保持为浮动数</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getStringCellValue</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">excelService</span><span class="o">.</span><span class="na">importExcel</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">(),</span> <span class="o">(</span><span class="n">sheet</span><span class="o">,</span> <span class="n">chineseTableHeader</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 得到实际表头</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="n">getTableHeader</span><span class="o">(</span><span class="n">chineseTableHeader</span><span class="o">,</span> <span class="n">importMetadata</span><span class="o">.</span><span class="na">tableColumn</span><span class="o">);</span>
    <span class="c1">// 获得需要写入的数据的索引</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">index</span> <span class="o">=</span> <span class="n">getIndex</span><span class="o">(</span><span class="n">tableHeader</span><span class="o">);</span>
    <span class="c1">// 存储插入到原表的数据</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">insertOriginal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 获取迭代器</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Row</span> <span class="n">row</span> <span class="o">:</span> <span class="n">sheet</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 跳过excel空行</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">row</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">true</span><span class="o">).</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getCellType</span><span class="o">).</span><span class="na">allMatch</span><span class="o">(</span><span class="n">cellType</span> <span class="o">-&gt;</span> <span class="n">cellType</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">BLANK</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 原数据</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">insertOriginalMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">index</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span><span class="o">-&gt;{</span>
                <span class="c1">// 单元格值</span>
                <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="na">getCell</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="c1">// 键</span>
                <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">tableHeader</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">cell</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">insertOriginalMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">excelService</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">cell</span><span class="o">);</span>
                <span class="n">excelDataMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="o">});</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"数据类型错误："</span><span class="o">+</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 插入原表的数据</span>
        <span class="n">insertOriginal</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">insertOriginal</span><span class="o">);</span>
        <span class="c1">// 如果要插入明细表的数据达到500条则开始插入操作。</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">insertUploadDetail</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="mi">500</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">insertOriginal</span><span class="o">(...);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 将剩余的数据插入</span>
    <span class="n">insertOriginal</span><span class="o">(...);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>导入还可能需要校验数据的合法性，以及数组类型，或者上传明细记录等业务处理，不一一展示。</p>

<p>注意并行流导致的共享变量写入问题，可能导致数据丢失。</p>

<h3 id="文本读取时变为浮点数">文本读取时变为浮点数</h3>

<p>在 Excel 文件中，尤其是对于大型数字（如手机号码、身份证号码等），有时它们会被自动识别为数值类型（<code class="language-plaintext highlighter-rouge">NUMERIC</code>），但实际上你需要将它们作为文本来处理。因为 Excel 会将大数字（如 <code class="language-plaintext highlighter-rouge">18844344316</code>）转换为 <code class="language-plaintext highlighter-rouge">double</code>，可能会失去精度，或者会自动以科学计数法（如 <code class="language-plaintext highlighter-rouge">1.8844344316E10</code>）显示。</p>

<p>为了确保读取正确的文本，可以尝试以下几种方法来获取单元格中的值：</p>

<p><strong>检查单元格是否为文本类型</strong></p>

<p>如果数据在 Excel 中是文本格式（即没有被误识别为数值），你可以直接读取为字符串。对于 <code class="language-plaintext highlighter-rouge">NUMERIC</code> 类型的单元格，你需要检查其值是否为 <code class="language-plaintext highlighter-rouge">double</code>，然后转回为字符串。</p>

<p><strong>强制将 <code class="language-plaintext highlighter-rouge">NUMERIC</code> 类型转为字符串</strong></p>

<p>如果遇到的是 <code class="language-plaintext highlighter-rouge">NUMERIC</code> 类型的单元格，并且该单元格的内容应该是一个大数字（如电话号码），可以使用以下方法将其读取为字符串，而不是 <code class="language-plaintext highlighter-rouge">double</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.poi.ss.usermodel.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.text.DecimalFormat</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExcelReader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 假设 cell 是当前单元格</span>
        <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="o">...;</span>

        <span class="c1">// 获取单元格类型</span>
        <span class="nc">CellType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getCellType</span><span class="o">();</span>

        <span class="c1">// 值</span>
        <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果是字符串类型</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getStringCellValue</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">NUMERIC</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果是数字类型，处理为字符串</span>
            <span class="kt">double</span> <span class="n">numericValue</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getNumericCellValue</span><span class="o">();</span>

            <span class="c1">// 使用 DecimalFormat 强制转换为字符串，不进行科学计数法</span>
            <span class="nc">DecimalFormat</span> <span class="n">df</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DecimalFormat</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="n">numericValue</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"单元格的值: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>使用 <code class="language-plaintext highlighter-rouge">DataFormatter</code> 来处理</strong></p>

<p><code class="language-plaintext highlighter-rouge">DataFormatter</code> 是 Apache POI 提供的一个工具，它可以根据单元格的实际显示格式来读取数据。这对于处理数值格式化问题特别有用，尤其是在数据被自动转换为数值类型时。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.poi.ss.usermodel.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.poi.ss.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExcelReader</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 假设 cell 是当前单元格</span>
        <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="o">...;</span>

        <span class="c1">// 使用 DataFormatter 获取值</span>
        <span class="nc">DataFormatter</span> <span class="n">dataFormatter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataFormatter</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">cellValue</span> <span class="o">=</span> <span class="n">dataFormatter</span><span class="o">.</span><span class="na">formatCellValue</span><span class="o">(</span><span class="n">cell</span><span class="o">);</span>

        <span class="c1">// 输出读取的单元格值</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"单元格的值: "</span> <span class="o">+</span> <span class="n">cellValue</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>设置 Excel 中的单元格格式</strong></p>

<p>如果你控制 Excel 文件的创建，确保该列的格式设置为文本格式。这可以避免 Excel 自动将大数字识别为 <code class="language-plaintext highlighter-rouge">double</code>。</p>

<p>在 Apache POI 中，可以设置单元格格式为文本：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CellStyle</span> <span class="n">cellStyle</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="na">createCellStyle</span><span class="o">();</span>
<span class="nc">DataFormat</span> <span class="n">format</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="na">createDataFormat</span><span class="o">();</span>
<span class="n">cellStyle</span><span class="o">.</span><span class="na">setDataFormat</span><span class="o">(</span><span class="n">format</span><span class="o">.</span><span class="na">getFormat</span><span class="o">(</span><span class="s">"@"</span><span class="o">));</span> <span class="c1">// "@" 表示文本格式</span>
<span class="n">cell</span><span class="o">.</span><span class="na">setCellStyle</span><span class="o">(</span><span class="n">cellStyle</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>强制读取为字符串</strong></p>

<p>如果你确定单元格中的数据应该是文本（如电话号码），即使 Excel 将其处理为数值类型，你也可以通过 <code class="language-plaintext highlighter-rouge">getStringCellValue</code> 强制将其作为字符串读取。为了确保数字不被科学计数法转换，你可以先将 <code class="language-plaintext highlighter-rouge">NUMERIC</code> 类型转换为字符串。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">NUMERIC</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">cellText</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">cell</span><span class="o">.</span><span class="na">getNumericCellValue</span><span class="o">());</span>
    <span class="c1">// 如果 cellText 显示为科学计数法，可以通过 String.format 转换成标准格式</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%.0f"</span><span class="o">,</span> <span class="n">cell</span><span class="o">.</span><span class="na">getNumericCellValue</span><span class="o">());</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getStringCellValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>读取前将单元格设置为文本类型读取</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cell</span><span class="o">.</span><span class="na">setCellType</span><span class="o">(</span><span class="nc">CellType</span><span class="o">.</span><span class="na">STRING</span><span class="o">);</span> 
</code></pre></div></div>

<p>总结：</p>

<ol>
  <li><strong>对于数字类型（<code class="language-plaintext highlighter-rouge">NUMERIC</code>），使用 <code class="language-plaintext highlighter-rouge">DecimalFormat</code></strong> 来确保数值以文本形式显示，避免科学计数法。</li>
  <li><strong>使用 <code class="language-plaintext highlighter-rouge">DataFormatter</code></strong>，它能够智能处理数值与文本类型，并确保读取时按照实际显示格式处理。</li>
  <li><strong>强制读取为文本</strong>，特别是对于像电话号码、身份证号等数据，不应将其当作数字类型处理，避免出现精度丢失或科学计数法的情况。</li>
</ol>

<h3 id="完整代码">完整代码</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.ilw.formflowprovider.center.service.other</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.github.pjfanning.xlsx.StreamingReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.poi.ss.usermodel.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.poi.xssf.streaming.SXSSFWorkbook</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Iterator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Collectors</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.StreamSupport</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">poi</span><span class="o">.</span><span class="na">xssf</span><span class="o">.</span><span class="na">streaming</span><span class="o">.</span><span class="na">SXSSFWorkbook</span><span class="o">.</span><span class="na">DEFAULT_WINDOW_SIZE</span><span class="o">;</span>

<span class="cm">/**
 * Excel导出服务层
 * @author aotmd
 * @version 1.0
 * @date 2024/11/20 11:05
 */</span>
<span class="nd">@Service</span>
<span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExcelService</span> <span class="o">{</span>
    <span class="cm">/** 在刷新之前保留在内存中的行数，请参见上文。 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">rowAccessWindowSize</span> <span class="o">=</span> <span class="no">DEFAULT_WINDOW_SIZE</span><span class="o">;</span>

    <span class="cm">/**
     * 设置写操作，在刷新之前保留在内存中的行数
     * @param rowAccessWindowSize 在刷新之前保留在内存中的行数
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRowAccessWindowSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">rowAccessWindowSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">rowAccessWindowSize</span> <span class="o">=</span> <span class="n">rowAccessWindowSize</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 导出Excel
     * @param os 输出流
     * @param chineseTableHeader 中文表头
     * @param callback 回调
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exportExcel</span><span class="o">(</span><span class="nc">OutputStream</span> <span class="n">os</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">chineseTableHeader</span><span class="o">,</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="nc">Sheet</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*设置页码*/</span>
        <span class="c1">// 创建Excel工作簿</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">SXSSFWorkbook</span> <span class="n">wb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SXSSFWorkbook</span><span class="o">(</span><span class="n">rowAccessWindowSize</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Sheet</span> <span class="n">sheet</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="na">createSheet</span><span class="o">(</span><span class="s">"Sheet1"</span><span class="o">);</span>
            <span class="c1">// 设置每列的宽度</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chineseTableHeader</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sheet</span><span class="o">.</span><span class="na">setColumnWidth</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="mi">5000</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="c1">// 创建一个CellStyle对象，用于设置加粗样式</span>
            <span class="nc">CellStyle</span> <span class="n">headerCellStyle</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="na">createCellStyle</span><span class="o">();</span>
            <span class="nc">Font</span> <span class="n">headerFont</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="na">createFont</span><span class="o">();</span>
            <span class="n">headerFont</span><span class="o">.</span><span class="na">setBold</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>  <span class="c1">// 设置加粗</span>
            <span class="n">headerCellStyle</span><span class="o">.</span><span class="na">setFont</span><span class="o">(</span><span class="n">headerFont</span><span class="o">);</span>  <span class="c1">// 将加粗字体应用到样式中</span>

            <span class="c1">// 写入表头</span>
            <span class="nc">Row</span> <span class="n">headerRow</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="na">createRow</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">colIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">chineseTableHeader</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">headerRow</span><span class="o">.</span><span class="na">createCell</span><span class="o">(</span><span class="n">colIndex</span><span class="o">++);</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="n">cell</span><span class="o">.</span><span class="na">setCellStyle</span><span class="o">(</span><span class="n">headerCellStyle</span><span class="o">);</span>  <span class="c1">// 应用加粗样式</span>
            <span class="o">}</span>
            <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">sheet</span><span class="o">);</span>
            <span class="n">wb</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">os</span><span class="o">);</span>
            <span class="n">os</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导出数据抛出异常"</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"导出数据抛出异常"</span><span class="o">,</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 导入Excel
     * @param is 输入流
     * @param callback 回调
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">importExcel</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">is</span><span class="o">,</span> <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="nc">Sheet</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 使用StreamingReader包装后，就只能使用流来操作行了，不能指定获取指定行了</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">Workbook</span> <span class="n">workbook</span> <span class="o">=</span> <span class="nc">StreamingReader</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">rowCacheSize</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>    <span class="c1">// 设置内存中保持的行数，默认是10</span>
                <span class="o">.</span><span class="na">bufferSize</span><span class="o">(</span><span class="mi">4096</span><span class="o">)</span><span class="c1">// 设置读取 InputStream 时的缓冲区大小（字节）</span>
                <span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="n">is</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Sheet</span> <span class="n">sheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="na">getSheetAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">sheet</span><span class="o">.</span><span class="na">getLastRowNum</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导入的数据查过10000行"</span><span class="o">);</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"导入的数据查过10000行"</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Row</span><span class="o">&gt;</span> <span class="n">rowIterator</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
            <span class="c1">// 获取数据的表头,第一行</span>
            <span class="nc">Row</span> <span class="n">r</span> <span class="o">=</span> <span class="n">rowIterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getStringCellValue</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>

            <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">sheet</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导入时发生异常：{}"</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"导入时发生异常：{}"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 写入数据行到Excel
     *
     * @param sheet       excel对象
     * @param data        数据
     * @param fieldHeader 属性key
     * @param rowIndex    第几行,注意最后返回的是新行
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">writeDataRowsToExcel</span><span class="o">(</span><span class="nc">Sheet</span> <span class="n">sheet</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fieldHeader</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rowIndex</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">colIndex</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">line</span> <span class="o">:</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Row</span> <span class="n">dataRow</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="na">createRow</span><span class="o">(</span><span class="n">rowIndex</span><span class="o">++);</span>
            <span class="n">colIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">titleKey</span> <span class="o">:</span> <span class="n">fieldHeader</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Cell</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">dataRow</span><span class="o">.</span><span class="na">createCell</span><span class="o">(</span><span class="n">colIndex</span><span class="o">++);</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">line</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">titleKey</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="nc">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">titleKey</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="n">o</span><span class="o">;</span>
                    <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Double</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">cell</span><span class="o">.</span><span class="na">setCellValue</span><span class="o">((</span><span class="nc">Double</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">rowIndex</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取原值
     *
     * @param cell 单元格
     * @return
     */</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getValue</span><span class="o">(</span><span class="nc">Cell</span> <span class="n">cell</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 单元格类型</span>
        <span class="nc">CellType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getCellType</span><span class="o">();</span>
        <span class="c1">// 值</span>
        <span class="nc">Object</span> <span class="n">value</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">NUMERIC</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 字符串或数字类型</span>
            <span class="kt">double</span> <span class="n">numericCellValue</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getNumericCellValue</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">numericCellValue</span> <span class="o">==</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">numericCellValue</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">value</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">numericCellValue</span><span class="o">;</span><span class="c1">// 转为整数</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">numericCellValue</span><span class="o">;</span> <span class="c1">//保持为浮动数</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">CellType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="na">getStringCellValue</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="csv导入导出">CSV导入导出</h2>

<h3 id="导出-1">导出</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CsvService</span> <span class="o">{</span>

    <span class="cm">/**
     * 导出CSV
     * @param tableHeader 表头
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exportCsv</span><span class="o">(</span><span class="nc">OutputStream</span> <span class="n">os</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span><span class="o">,</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="nc">BufferedWriter</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 写入BOM头，通知Excel使用UTF-8编码</span>
        <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xEF</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xBB</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xBF</span> <span class="o">});</span>
        <span class="c1">// 将BufferedWriter包裹在BufferedOutputStream中</span>
        <span class="c1">// 写入 CSV 文件</span>
        <span class="c1">// 32KB缓冲区</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">os</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">),</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 写入表头</span>
            <span class="nc">String</span> <span class="n">headerLine</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">);</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">headerLine</span><span class="o">);</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>  <span class="c1">// 换行</span>
            <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">writer</span><span class="o">);</span><span class="c1">//执行逻辑</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>  <span class="c1">// 确保所有数据都写入到响应流</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导出CSV数据抛出异常"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 写入CSV的数据（带转义处理）
     * @param writer 输出流
     * @param data 数据（数组）
     * @param fieldHeader 字段名
     * @throws IOException
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">writeCsvData</span><span class="o">(</span><span class="nc">BufferedWriter</span> <span class="n">writer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fieldHeader</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">rowData</span> <span class="o">:</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">StringBuilder</span> <span class="n">line</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fieldHeader</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">rowData</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">field</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">line</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\"\""</span><span class="o">);</span>  <span class="c1">// 对空值进行转义处理</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="nc">String</span> <span class="n">valueStr</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="n">value</span><span class="o">;</span>
                        <span class="n">valueStr</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">valueStr</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="c1">// 对字段值进行转义处理</span>
                    <span class="n">valueStr</span> <span class="o">=</span> <span class="n">escapeCsvValue</span><span class="o">(</span><span class="n">valueStr</span><span class="o">);</span>
                    <span class="n">line</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\""</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">valueStr</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\""</span><span class="o">);</span>  <span class="c1">// 用双引号包裹数据</span>
                <span class="o">}</span>
                <span class="n">line</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>  <span class="c1">// 每个字段后面加上逗号</span>
            <span class="o">}</span>
            <span class="c1">// 移除行尾的逗号</span>
            <span class="n">line</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>  <span class="c1">// 换行</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 转义CSV中的特殊字符
     * @param value 字段值
     * @return 转义后的字符串
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">escapeCsvValue</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 替换双引号为两个双引号</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\""</span><span class="o">,</span> <span class="s">"\"\""</span><span class="o">);</span>
        <span class="c1">// 去除可能的换行符和回车符</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\n"</span><span class="o">,</span> <span class="s">" "</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">"\r"</span><span class="o">,</span> <span class="s">" "</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>注意设置BOM头，强制指定编码。使用Apipost接口调试时，会自动忽略掉BOM头，不用担心，改用浏览器调试就有正常的BOM头。</p>

<p>使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csvService</span><span class="o">.</span><span class="na">exportCsv</span><span class="o">(</span><span class="n">outputStream</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">,</span> <span class="o">(</span><span class="n">writer</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">data0</span><span class="o">;</span>
    <span class="c1">// 分页获取数据并追加写入CSV文件</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxPage</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="o">...</span>
        <span class="n">csvService</span><span class="o">.</span><span class="na">writeCsvData</span><span class="o">(</span><span class="n">writer</span><span class="o">,</span> <span class="n">result</span><span class="o">,</span> <span class="n">keys</span><span class="o">);</span>
        <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<h3 id="导入-1">导入</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**导入每批次处理1000条数据*/</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">batchSize</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>

<span class="cm">/**
 * 设置导入每次处理数量
 * @param batchSize 处理数量
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBatchSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">batchSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">batchSize</span> <span class="o">=</span> <span class="n">batchSize</span><span class="o">;</span>
<span class="o">}</span>
<span class="cm">/**
 * 导入CSV数据
 * @param inputStream 输入流
 * @param callback 处理每行数据的回调函数
 * @throws IOException
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">importCsv</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">inputStream</span><span class="o">,</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">inputStream</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)))</span> <span class="o">{</span>
        <span class="c1">// 跳过BOM头</span>
        <span class="n">reader</span><span class="o">.</span><span class="na">mark</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">()</span> <span class="o">!=</span> <span class="mh">0xEF</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">reader</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// 读取表头</span>
        <span class="nc">String</span> <span class="n">headerLine</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fileHeader</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">headerLine</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>

        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">dataList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
        <span class="c1">// 每批次处理1000条数据</span>
        <span class="n">batchSize</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 逐行读取并处理CSV数据</span>
        <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">rowData</span> <span class="o">=</span> <span class="n">parseCsvRow</span><span class="o">(</span><span class="n">line</span><span class="o">,</span> <span class="n">fileHeader</span><span class="o">);</span>
            <span class="n">dataList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rowData</span><span class="o">);</span>

            <span class="c1">// 每处理完一个批次数据，调用回调函数</span>
            <span class="k">if</span> <span class="o">(++</span><span class="n">count</span> <span class="o">%</span> <span class="n">batchSize</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">dataList</span><span class="o">));</span>
                <span class="n">dataList</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">// 清空当前批次数据</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 处理剩余的不足一批的数据</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">dataList</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">dataList</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导入CSV数据抛出异常"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"导入CSV文件时出现错误"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 解析CSV每行数据并映射为Map
 * @param line CSV中的一行数据
 * @param tableHeader 表头
 * @return 行数据的Map
 */</span>
<span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">parseCsvRow</span><span class="o">(</span><span class="nc">String</span> <span class="n">line</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">rowData</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tableHeader</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">tableHeader</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">fields</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

        <span class="c1">// 处理转义字符</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">unescapeCsvValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
        <span class="n">rowData</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">rowData</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**
 * 转义CSV中的特殊字符（例如，双引号、换行符等）
 * @param value 字段值
 * @return 还原转义后的字符串
 */</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="nf">unescapeCsvValue</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 去除双引号</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"\""</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"\""</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 替换双引号为一个双引号</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\"\""</span><span class="o">,</span> <span class="s">"\""</span><span class="o">);</span>
    <span class="c1">// 去除换行符和回车符</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="s">"\n"</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="s">"\r"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">csvService</span><span class="o">.</span><span class="na">importCsv</span><span class="o">(</span><span class="n">csvInputStream</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">,</span> <span class="n">dataList</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="c1">// 这里处理导入的数据，比如保存到数据库</span>
    <span class="n">dataList</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">row</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"导入的数据："</span> <span class="o">+</span> <span class="n">row</span><span class="o">);</span>
    <span class="o">});</span>
<span class="o">});</span>
</code></pre></div></div>

<h3 id="完整代码-1">完整代码</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.ilw.formflowprovider.center.service.other</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">lombok.extern.slf4j.Slf4j</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="cm">/**
 * CSV导出服务层
 * @author aotmd
 * @version 1.0
 * @date 2024/11/20 10:49
 */</span>
<span class="nd">@Slf4j</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CsvService</span> <span class="o">{</span>
    <span class="cm">/**导入每批次处理1000条数据*/</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">batchSize</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>

    <span class="cm">/**
     * 设置导入每次处理数量
     * @param batchSize 处理数量
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBatchSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">batchSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">batchSize</span> <span class="o">=</span> <span class="n">batchSize</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 导出CSV
     * @param tableHeader 表头
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exportCsv</span><span class="o">(</span><span class="nc">OutputStream</span> <span class="n">os</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span><span class="o">,</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="nc">BufferedWriter</span><span class="o">&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">// 写入BOM头，通知Excel使用UTF-8编码</span>
        <span class="n">os</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xEF</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xBB</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xBF</span> <span class="o">});</span>
        <span class="c1">// 将BufferedWriter包裹在BufferedOutputStream中</span>
        <span class="c1">// 写入 CSV 文件</span>
        <span class="c1">// 32KB缓冲区</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">os</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">),</span><span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 写入表头</span>
            <span class="nc">String</span> <span class="n">headerLine</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">tableHeader</span><span class="o">);</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">headerLine</span><span class="o">);</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>  <span class="c1">// 换行</span>
            <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">writer</span><span class="o">);</span><span class="c1">//执行逻辑</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>  <span class="c1">// 确保所有数据都写入到响应流</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导出CSV数据抛出异常"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 写入CSV的数据（带转义处理）
     * @param writer 输出流
     * @param data 数据（数组）
     * @param fieldHeader 字段名
     * @throws IOException
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">writeCsvData</span><span class="o">(</span><span class="nc">BufferedWriter</span> <span class="n">writer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fieldHeader</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">rowData</span> <span class="o">:</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">StringBuilder</span> <span class="n">line</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fieldHeader</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">rowData</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">field</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">line</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\"\""</span><span class="o">);</span>  <span class="c1">// 对空值进行转义处理</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="nc">String</span> <span class="n">valueStr</span><span class="o">;</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="n">value</span><span class="o">;</span>
                        <span class="n">valueStr</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">valueStr</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
                    <span class="o">}</span>
                    <span class="c1">// 对字段值进行转义处理</span>
                    <span class="n">valueStr</span> <span class="o">=</span> <span class="n">escapeCsvValue</span><span class="o">(</span><span class="n">valueStr</span><span class="o">);</span>
                    <span class="n">line</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\""</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">valueStr</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\""</span><span class="o">);</span>  <span class="c1">// 用双引号包裹数据</span>
                <span class="o">}</span>
                <span class="n">line</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>  <span class="c1">// 每个字段后面加上逗号</span>
            <span class="o">}</span>
            <span class="c1">// 移除行尾的逗号</span>
            <span class="n">line</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span>  <span class="c1">// 换行</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 转义CSV中的特殊字符
     * @param value 字段值
     * @return 转义后的字符串
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">escapeCsvValue</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 替换双引号为两个双引号</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\""</span><span class="o">,</span> <span class="s">"\"\""</span><span class="o">);</span>
        <span class="c1">// 去除可能的换行符和回车符</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\n"</span><span class="o">,</span> <span class="s">" "</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">"\r"</span><span class="o">,</span> <span class="s">" "</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="cm">/**
     * 导入CSV数据
     * @param inputStream 输入流
     * @param callback 处理每行数据的回调函数
     * @throws IOException
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">importCsv</span><span class="o">(</span><span class="nc">InputStream</span> <span class="n">inputStream</span><span class="o">,</span> <span class="nc">ConsumerWithException</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;&gt;</span> <span class="n">callback</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">inputStream</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)))</span> <span class="o">{</span>
            <span class="c1">// 跳过BOM头</span>
            <span class="n">reader</span><span class="o">.</span><span class="na">mark</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">reader</span><span class="o">.</span><span class="na">read</span><span class="o">()</span> <span class="o">!=</span> <span class="mh">0xEF</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">reader</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 读取表头</span>
            <span class="nc">String</span> <span class="n">headerLine</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">fileHeader</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">headerLine</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>

            <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;&gt;</span> <span class="n">dataList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="nc">String</span> <span class="n">line</span><span class="o">;</span>
            <span class="c1">// 每批次处理1000条数据</span>
            <span class="n">batchSize</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// 逐行读取并处理CSV数据</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">rowData</span> <span class="o">=</span> <span class="n">parseCsvRow</span><span class="o">(</span><span class="n">line</span><span class="o">,</span> <span class="n">fileHeader</span><span class="o">);</span>
                <span class="n">dataList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rowData</span><span class="o">);</span>

                <span class="c1">// 每处理完一个批次数据，调用回调函数</span>
                <span class="k">if</span> <span class="o">(++</span><span class="n">count</span> <span class="o">%</span> <span class="n">batchSize</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">dataList</span><span class="o">));</span>
                    <span class="n">dataList</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">// 清空当前批次数据</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 处理剩余的不足一批的数据</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">dataList</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">callback</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">dataList</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"导入CSV数据抛出异常"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span><span class="s">"导入CSV文件时出现错误"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 解析CSV每行数据并映射为Map
     * @param line CSV中的一行数据
     * @param tableHeader 表头
     * @return 行数据的Map
     */</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">parseCsvRow</span><span class="o">(</span><span class="nc">String</span> <span class="n">line</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">rowData</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tableHeader</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">tableHeader</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">fields</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="c1">// 处理转义字符</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">unescapeCsvValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
            <span class="n">rowData</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">rowData</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 转义CSV中的特殊字符（例如，双引号、换行符等）
     * @param value 字段值
     * @return 还原转义后的字符串
     */</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">unescapeCsvValue</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 去除双引号</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"\""</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"\""</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 替换双引号为一个双引号</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\"\""</span><span class="o">,</span> <span class="s">"\""</span><span class="o">);</span>
        <span class="c1">// 去除换行符和回车符</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="s">"\n"</span><span class="o">).</span><span class="na">replace</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="s">"\r"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">本地环境正常，k8s上中文乱码解决方法</title><link href="/2024/11/15/%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%AD%A3%E5%B8%B8-k8s%E4%B8%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="本地环境正常，k8s上中文乱码解决方法" /><published>2024-11-15T00:00:00+08:00</published><updated>2024-11-15T00:00:00+08:00</updated><id>/2024/11/15/%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%AD%A3%E5%B8%B8%EF%BC%8Ck8s%E4%B8%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95</id><content type="html" xml:base="/2024/11/15/%E6%9C%AC%E5%9C%B0%E7%8E%AF%E5%A2%83%E6%AD%A3%E5%B8%B8-k8s%E4%B8%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"><![CDATA[<h1 id="引言">引言</h1>

<p>本地环境正常，docker容器正常，k8s上中文乱码。</p>

<h1 id="k8s上中文乱码">k8s上中文乱码</h1>

<p>具体问题为：在本地调试Post方法，对于同一接口，<code class="language-plaintext highlighter-rouge">@RequestBody</code>传递中文参数正常，<code class="language-plaintext highlighter-rouge">@RequestParam</code>传递中文参数正常。打包为docker镜像也正常，部署到k8s则出现问题，对于同一接口，<code class="language-plaintext highlighter-rouge">@RequestBody</code>传递中文参数正常，<code class="language-plaintext highlighter-rouge">@RequestParam</code>传递中文参数乱码。</p>

<p>可能原因：某个节点环境不正常。</p>

<p><code class="language-plaintext highlighter-rouge">dockerfile</code>文件：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CMD java <span class="nv">$J_ARG</span> <span class="nt">-Dfile</span>.encoding<span class="o">=</span>UTF8
</code></pre></div></div>

<p>这里编码应该为<code class="language-plaintext highlighter-rouge">UTF-8</code>。</p>

<p>修改配置文件也可以：</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">http</span><span class="pi">:</span>
    <span class="na">encoding</span><span class="pi">:</span>
      <span class="na">charset</span><span class="pi">:</span> <span class="s">UTF-8</span>
      <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
      <span class="na">force</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">多级Map连续设值</title><link href="/2024/11/07/%E5%B5%8C%E5%A5%97Map%E7%9A%84%E5%B9%B3%E9%93%BA%E4%BA%8E%E5%8F%8D%E5%90%91%E6%93%8D%E4%BD%9C/" rel="alternate" type="text/html" title="多级Map连续设值" /><published>2024-11-07T00:00:00+08:00</published><updated>2024-11-07T00:00:00+08:00</updated><id>/2024/11/07/%E5%B5%8C%E5%A5%97Map%E7%9A%84%E5%B9%B3%E9%93%BA%E4%BA%8E%E5%8F%8D%E5%90%91%E6%93%8D%E4%BD%9C</id><content type="html" xml:base="/2024/11/07/%E5%B5%8C%E5%A5%97Map%E7%9A%84%E5%B9%B3%E9%93%BA%E4%BA%8E%E5%8F%8D%E5%90%91%E6%93%8D%E4%BD%9C/"><![CDATA[<h1 id="引言">引言</h1>
<p>将多级Map平铺和反向操作的方法。</p>

<h1 id="map">Map</h1>

<h2 id="flattenmap-方法"><code class="language-plaintext highlighter-rouge">flattenMap</code> 方法</h2>

<p><strong><code class="language-plaintext highlighter-rouge">flattenMap</code></strong>：将一个嵌套的 <code class="language-plaintext highlighter-rouge">Map</code> 转换为平铺的 <code class="language-plaintext highlighter-rouge">Map</code>，每一层的键用 <code class="language-plaintext highlighter-rouge">.</code> 连接，扁平化嵌套结构。</p>

<p><strong>方法定义</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">flattenMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">nestedMap</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>参数</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">nestedMap</code></strong> (<code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>)：一个嵌套的 <code class="language-plaintext highlighter-rouge">Map</code>，其键值可能为更深层次的 <code class="language-plaintext highlighter-rouge">Map</code> 或基本数据类型。</p>

<p><strong>返回值</strong></p>

<p>返回一个平铺的 <code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>，其中嵌套的结构被展开，键名通过 <code class="language-plaintext highlighter-rouge">.</code> 分隔符表示路径。</p>

<p><strong>功能</strong></p>

<p>该方法将嵌套的 <code class="language-plaintext highlighter-rouge">Map</code> 转换为平铺的 <code class="language-plaintext highlighter-rouge">Map</code>，将嵌套对象的键名通过 <code class="language-plaintext highlighter-rouge">.</code> 符号进行连接，生成扁平化的键值对。</p>

<p>例如，<code class="language-plaintext highlighter-rouge">data.testobj.name</code> 嵌套Map会被平铺为 <code class="language-plaintext highlighter-rouge">data.testobj.name</code> 键。</p>

<p><strong>示例</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">nestedMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">testobj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">testobj</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"age"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="n">testobj</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">);</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">data</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"count"</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
<span class="n">data</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"testobj"</span><span class="o">,</span> <span class="n">testobj</span><span class="o">);</span>

<span class="n">nestedMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"data"</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
<span class="n">nestedMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"_id"</span><span class="o">,</span> <span class="s">"67089190f180b00a00476c67"</span><span class="o">);</span>
<span class="n">nestedMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"collectionName"</span><span class="o">,</span> <span class="s">"co_common_test1"</span><span class="o">);</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">flatMap</span> <span class="o">=</span> <span class="n">flattenMap</span><span class="o">(</span><span class="n">nestedMap</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>输出</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
    <span class="s">"data.count"</span><span class="o">:</span> <span class="mi">6</span><span class="o">,</span>
    <span class="s">"data.testobj.age"</span><span class="o">:</span> <span class="mi">5</span><span class="o">,</span>
    <span class="s">"data.testobj.name"</span><span class="o">:</span> <span class="s">"3"</span><span class="o">,</span>
    <span class="s">"_id"</span><span class="o">:</span> <span class="s">"67089190f180b00a00476c67"</span><span class="o">,</span>
    <span class="s">"collectionName"</span><span class="o">:</span> <span class="s">"co_common_test1"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>注意事项</strong></p>

<p>该方法将嵌套的 <code class="language-plaintext highlighter-rouge">Map</code> 结构递归展开，每一层的键名通过 <code class="language-plaintext highlighter-rouge">.</code> 符号进行连接，形成一个平铺的结构。</p>

<p>如果 <code class="language-plaintext highlighter-rouge">nestedMap</code> 中的某个值是非 <code class="language-plaintext highlighter-rouge">Map</code> 类型，则会将该值作为扁平化后的结果。</p>

<h2 id="unflattenmap-方法"><code class="language-plaintext highlighter-rouge">unflattenMap</code> 方法</h2>

<p><strong><code class="language-plaintext highlighter-rouge">unflattenMap</code></strong>：将一个平铺的 <code class="language-plaintext highlighter-rouge">Map</code>（带点的键）转换为嵌套的 <code class="language-plaintext highlighter-rouge">Map</code> 结构，逐级展开。</p>

<p><strong>方法定义</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">unflattenMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">flatMap</span><span class="o">);</span>
</code></pre></div></div>

<p><strong>参数</strong></p>

<p><strong><code class="language-plaintext highlighter-rouge">flatMap</code></strong> (<code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>)：一个平铺的 <code class="language-plaintext highlighter-rouge">Map</code>，其键名使用 <code class="language-plaintext highlighter-rouge">.</code> 作为分隔符（例如 <code class="language-plaintext highlighter-rouge">data.count</code>, <code class="language-plaintext highlighter-rouge">data.testobj.name</code>），表示嵌套的结构。</p>

<p><strong>返回值</strong></p>

<p>返回一个嵌套的 <code class="language-plaintext highlighter-rouge">Map&lt;String, Object&gt;</code>，其中键对应的路径会被还原为嵌套的对象结构。</p>

<p><strong>功能</strong></p>

<p>该方法将一个平铺的 <code class="language-plaintext highlighter-rouge">Map</code> 转换为嵌套的 <code class="language-plaintext highlighter-rouge">Map</code>。平铺的 <code class="language-plaintext highlighter-rouge">Map</code> 中的键名是通过 <code class="language-plaintext highlighter-rouge">.</code> 分隔符表示的路径。该方法会根据路径拆分并逐层构建嵌套的 <code class="language-plaintext highlighter-rouge">Map</code> 结构。</p>

<p>例如，<code class="language-plaintext highlighter-rouge">data.testobj.name</code> 会被展开为 <code class="language-plaintext highlighter-rouge">Map</code> 结构：<code class="language-plaintext highlighter-rouge">data -&gt; testobj -&gt; name</code>。</p>

<p><strong>示例</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">flatMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">flatMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"data.count"</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
<span class="n">flatMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"data.testobj.age"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="n">flatMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"_id"</span><span class="o">,</span> <span class="s">"67089190f180b00a00476c67"</span><span class="o">);</span>
<span class="n">flatMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"collectionName"</span><span class="o">,</span> <span class="s">"co_common_test1"</span><span class="o">);</span>
<span class="n">flatMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"data.testobj.name"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">);</span>

<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">nestedMap</span> <span class="o">=</span> <span class="n">unflattenMap</span><span class="o">(</span><span class="n">flatMap</span><span class="o">);</span>
</code></pre></div></div>
<p><strong>输出</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
    <span class="s">"data"</span><span class="o">:</span> <span class="o">{</span>
        <span class="s">"count"</span><span class="o">:</span> <span class="mi">6</span><span class="o">,</span>
        <span class="s">"testobj"</span><span class="o">:</span> <span class="o">{</span>
            <span class="s">"age"</span><span class="o">:</span> <span class="mi">5</span><span class="o">,</span>
            <span class="s">"name"</span><span class="o">:</span> <span class="s">"3"</span>
        <span class="o">}</span>
    <span class="o">},</span>
    <span class="s">"_id"</span><span class="o">:</span> <span class="s">"67089190f180b00a00476c67"</span><span class="o">,</span>
    <span class="s">"collectionName"</span><span class="o">:</span> <span class="s">"co_common_test1"</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>注意事项</strong></p>

<p>该方法假设所有带点路径的键都需要进行解包，逐级生成嵌套 <code class="language-plaintext highlighter-rouge">Map</code>。</p>

<p>如果 <code class="language-plaintext highlighter-rouge">flatMap</code> 中某个路径已经存在嵌套结构，则该路径的值将被复写为新的值。</p>

<p>这两个方法可以方便地在平铺和嵌套 <code class="language-plaintext highlighter-rouge">Map</code> 之间转换，使得对复杂结构的数据操作更加简便。</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">多级Map连续设值</title><link href="/2024/11/06/%E5%A4%9A%E7%BA%A7Map%E8%BF%9E%E7%BB%AD%E8%AE%BE%E5%80%BC/" rel="alternate" type="text/html" title="多级Map连续设值" /><published>2024-11-06T00:00:00+08:00</published><updated>2024-11-06T00:00:00+08:00</updated><id>/2024/11/06/%E5%A4%9A%E7%BA%A7Map%E8%BF%9E%E7%BB%AD%E8%AE%BE%E5%80%BC</id><content type="html" xml:base="/2024/11/06/%E5%A4%9A%E7%BA%A7Map%E8%BF%9E%E7%BB%AD%E8%AE%BE%E5%80%BC/"><![CDATA[<h1 id="引言">引言</h1>
<p>一个简单的，连续设置Map值的方法。</p>

<h1 id="map">Map</h1>

<h2 id="多级map连续设值">多级Map连续设值</h2>

<p>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cm">/**
 * 通过路径连续设置值，分隔符为.号
 * @param map 键值对
 * @param path 路径
 * @param value 设置的值
 * @param &lt;T&gt; 值类型
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">setValueByPath</span><span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">,</span> <span class="nc">String</span> <span class="n">path</span><span class="o">,</span> <span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">path</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">path</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"路径不能为空"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nc">String</span><span class="o">[]</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">);</span>
    <span class="nc">Object</span> <span class="n">current</span> <span class="o">=</span> <span class="n">map</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">keys</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keys</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">currentMap</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;)</span> <span class="n">current</span><span class="o">;</span>
            <span class="c1">// 如果当前Map中没有该key，创建一个新的Map</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">currentMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">currentMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;());</span>
            <span class="o">}</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">currentMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"路径中的某个节点不是Map类型，路径: "</span> <span class="o">+</span> <span class="n">path</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// 最后一个key，设置值</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">current</span> <span class="k">instanceof</span> <span class="nc">Map</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">currentMap</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;)</span> <span class="n">current</span><span class="o">;</span>
        <span class="n">currentMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">keys</span><span class="o">[</span><span class="n">keys</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">],</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"设置值时出错，路径指向的目标不是Map类型，路径: "</span> <span class="o">+</span> <span class="n">path</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

<span class="c1">// 测试路径设置</span>
<span class="n">setValueByPath</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="s">"data.count"</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
<span class="n">setValueByPath</span><span class="o">(</span><span class="n">map</span><span class="o">,</span> <span class="s">"data.count.details.value"</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>

<span class="c1">// 打印结果</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry></feed>