<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="https://acteds.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://acteds.github.io/" rel="alternate" type="text/html" /><updated>2024-04-13T17:19:30+08:00</updated><id>https://acteds.github.io/feed.xml</id><title type="html">个人博客</title><subtitle></subtitle><author><name>acteds</name></author><entry><title type="html">简单实现HashMap</title><link href="https://acteds.github.io/2024/04/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0HashMap/" rel="alternate" type="text/html" title="简单实现HashMap" /><published>2024-04-08T00:00:00+08:00</published><updated>2024-04-08T00:00:00+08:00</updated><id>https://acteds.github.io/2024/04/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0HashMap</id><content type="html" xml:base="https://acteds.github.io/2024/04/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0HashMap/"><![CDATA[<h1 id="引言">引言</h1>
<p>  简单实现HashMap。</p>

<h1 id="简单实现hashmap">简单实现HashMap</h1>

<p>  实现的方法：</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V put(K key, V value)</td>
      <td>把<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>做映射并放入<code class="language-plaintext highlighter-rouge">Map</code>。如果放入的<code class="language-plaintext highlighter-rouge">key</code><strong>已经存在</strong>，则会更新<code class="language-plaintext highlighter-rouge">value</code>并返回被删除的旧的<code class="language-plaintext highlighter-rouge">value</code>，否则，返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>V get(K key)</td>
      <td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>Set<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code> keySet()</td>
      <td>返回<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">Set</code>集合。</td>
    </tr>
    <tr>
      <td>V remove(K key)</td>
      <td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的键值对删除，并弹出<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
  </tbody>
</table>

<p>  包括哈希冲突处理，扩容处理，可设置默认大小与负载因子，默认大小会自动提高到最近的2的幂，扩容时容量翻倍。<br />
  扩容操作包括以下步骤：</p>
<ol>
  <li>创建一个新的数组，大小是原数组的两倍。</li>
  <li>将原数组中的元素<strong>重新计算哈希值</strong>，并根据新数组的大小<strong>重新分配位置</strong>。</li>
  <li>将重新计算位置后的元素放入新数组中。</li>
  <li>将新数组设置为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的数组，替换原数组。</li>
</ol>

<p>  与重新生成一个HashMap相比，扩容不需要重新建立键值对，也不需要判断<code class="language-plaintext highlighter-rouge">key</code>覆盖，但在哈希冲突后依然要重新建立链表。<br />
  链表为空时没有销毁，而是保留，以备下次使用，提高性能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyHashMap</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">0.75</span><span class="no">F</span><span class="o">);</span>
<span class="c1">//        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(1, 0.75F);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"游泳"</span><span class="o">,</span> <span class="s">"小红"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"跑步"</span><span class="o">,</span> <span class="s">"小刚"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美~"</span><span class="o">)+</span><span class="s">"已弹出"</span><span class="o">);</span><span class="c1">//弹出被覆盖Value</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"画画"</span><span class="o">,</span> <span class="s">"小强"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"编程"</span><span class="o">,</span> <span class="s">"小明"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span><span class="c1">//删除key为篮球的键值对</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱、跳、rap、篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">devOut</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"key="</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="s">",value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 自定义hashMap
 * @param &lt;K&gt; key
 * @param &lt;V&gt; value
 */</span>
<span class="kd">class</span> <span class="nc">MyHashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="cm">/** 数组大小*/</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="o">;</span>
    <span class="cm">/** 填充因子 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">actualSize</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="cm">/** 负载因子 */</span>
    <span class="kd">private</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">=</span><span class="mf">0.75f</span><span class="o">;</span>

    <span class="cm">/**
     *
     * @param initialCapacity 数组初始长度
     * @param loadFactor 负载因子
     */</span>
    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span><span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"非法初始容量: "</span> <span class="o">+</span> <span class="n">initialCapacity</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="nc">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">)||</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="no">F</span> <span class="o">||</span> <span class="n">loadFactor</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"非法负载因子: "</span> <span class="o">+</span> <span class="n">loadFactor</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="mi">1073741824</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">initialCapacity</span> <span class="o">=</span> <span class="mi">1073741824</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 提升到2的整数幂</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">nextPowerOfTwo</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span><span class="o">=</span><span class="n">loadFactor</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果capacity不是2的整数幂，则增加到大于capacity的最近的2的整数幂
     * @param capacity 待提升数字
     * @return 2的整数幂
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">nextPowerOfTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">capacity</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">capacity</span><span class="o">;</span> <span class="c1">// 如果a已经是2的整数幂，则直接返回a</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">power</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">power</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 不断左移，直到找到大于a的最近的2的整数幂</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">power</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]==</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取key哈希值。
     * @param key 键
     * @return key的哈希值
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getKeyHash</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">hash</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">hash</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">hash</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">//哈希桶是空的</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">);</span>
            <span class="n">actualSize</span><span class="o">++;</span>
            <span class="n">expansion</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 哈希桶已占用,哈希冲突</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
            <span class="c1">//覆盖检测</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">)){</span>
                <span class="no">V</span> <span class="n">v</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                <span class="n">item</span><span class="o">.</span><span class="na">setV</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                <span class="c1">//如果覆盖，则弹出旧值</span>
                <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//无覆盖则生成链表,并添加</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="c1">//旧元素</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
            <span class="c1">//新元素</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">));</span>
            <span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="n">list</span><span class="o">;</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="c1">//是否为空链表</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">));</span>
                <span class="n">actualSize</span><span class="o">++;</span>
                <span class="n">expansion</span><span class="o">();</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//覆盖检测</span>
            <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">)){</span>
                    <span class="no">V</span> <span class="n">v</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                    <span class="n">item</span><span class="o">.</span><span class="na">setV</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                    <span class="c1">//如果覆盖，则弹出旧值</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//无覆盖则添加</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">));</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 删除指定key的键值对
     * @param key key
     * @return value
     */</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">remove</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 是一个元素,则删除,并弹出value</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="kc">null</span><span class="o">;</span>
            <span class="n">actualSize</span><span class="o">--;</span>
            <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// 是链表,则遍历,找到key相等的删除并弹出</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">)){</span>
                    <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                    <span class="c1">// 如果链表为空则降低填充因子</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                        <span class="n">actualSize</span><span class="o">--;</span>
                    <span class="o">}</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回所有key
     * @return Set&lt;K&gt;
     */</span>
    <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">keySet</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">keySet</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">traverse</span><span class="o">((</span><span class="n">t</span><span class="o">)-&gt;{</span>
                <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">keySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">());</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">keySet</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 遍历MyHashMap,每个元素调用都调用一次callback
     * @param callback 回调函数,每个元素调用一次
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span><span class="k">continue</span><span class="o">;}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
                <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">o</span><span class="o">;</span>
                <span class="n">callback</span><span class="o">.</span><span class="na">onCallback</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">o</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">callback</span><span class="o">.</span><span class="na">onCallback</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 扩容
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">expansion</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">actualSize</span> <span class="o">/</span><span class="n">size</span><span class="o">&gt;=</span><span class="n">loadFactor</span><span class="o">){</span>
            <span class="c1">// 创建一个新的数组，大小是原数组的两倍。</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"扩容前："</span><span class="o">+</span><span class="n">devOut</span><span class="o">());</span>
            <span class="nc">Object</span><span class="o">[]</span> <span class="n">newArray</span><span class="o">=</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">size</span><span class="o">*</span><span class="mi">2</span><span class="o">];</span>
            <span class="c1">//重新设置哈希算法,容量翻倍</span>
            <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">*=</span><span class="mi">2</span><span class="o">;</span>
            <span class="c1">// 重新计算填充因子</span>
            <span class="kt">var</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">()</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">actualSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">};</span>
            <span class="c1">// 将原数组中的元素重新计算哈希值，并根据新数组的大小重新分配位置。</span>
            <span class="c1">// 将重新计算位置后的元素放入新数组中。</span>

            <span class="n">traverse</span><span class="o">((</span><span class="n">t</span><span class="o">)-&gt;{</span>
                <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">t0</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="no">K</span> <span class="n">key</span><span class="o">=</span><span class="n">t0</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                <span class="no">V</span> <span class="n">value</span><span class="o">=</span><span class="n">t0</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="c1">// 哈希桶是空的</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="n">t0</span><span class="o">;</span>
                    <span class="n">ref</span><span class="o">.</span><span class="na">actualSize</span><span class="o">++;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// 哈希桶已占用,哈希冲突</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
                    <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
                    <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                    <span class="c1">//覆盖检测（添加前就检测了，不会有重复的key）</span>
                    <span class="c1">//无覆盖则生成链表,并添加</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                    <span class="c1">//旧元素</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                    <span class="c1">//新元素</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t0</span><span class="o">);</span>
                    <span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="n">list</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
                    <span class="c1">//是否为空链表（也不用检测了，因为扩容不会执行remove）</span>
                    <span class="c1">//覆盖检测（添加前就检测了，不会有重复的key）</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t0</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="c1">// 将新数组设置为 `HashMap` 的数组，替换原数组。</span>
            <span class="k">this</span><span class="o">.</span><span class="na">array</span><span class="o">=</span><span class="n">newArray</span><span class="o">;</span>
            <span class="c1">// 重设填充因子</span>
            <span class="k">this</span><span class="o">.</span><span class="na">actualSize</span><span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="na">actualSize</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"扩容后："</span><span class="o">+</span><span class="n">devOut</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 定义一个回调接口</span>
    <span class="kd">interface</span> <span class="nc">Callback</span><span class="o">{</span>
         <span class="kt">void</span> <span class="nf">onCallback</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span><span class="na">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">StringBuffer</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">append</span><span class="o">(</span><span class="s">"{"</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">};</span>
        <span class="n">traverse</span><span class="o">((</span><span class="n">t</span><span class="o">)-&gt;{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
            <span class="n">ref</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ref</span><span class="o">.</span><span class="na">flag</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"}"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">devOut</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"当前已用%d个哈希桶，哈希桶总数量：%d，结构：%s"</span><span class="o">,</span> <span class="n">actualSize</span><span class="o">,</span><span class="n">size</span><span class="o">,</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">class</span> <span class="nc">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;{</span>
        <span class="kd">private</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span><span class="kd">private</span> <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">KV</span><span class="o">(</span><span class="no">K</span> <span class="n">k</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span><span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;}</span>
        <span class="kd">public</span> <span class="no">K</span> <span class="nf">getK</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">k</span><span class="o">;}</span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setK</span><span class="o">(</span><span class="no">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;}</span><span class="kd">public</span> <span class="no">V</span> <span class="nf">getV</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">v</span><span class="o">;}</span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setV</span><span class="o">(</span><span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;}</span>
        <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">v</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  控制台输出：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>扩容前：当前已用1个哈希桶，哈希桶总数量：1，结构：[null=123]
扩容后：当前已用1个哈希桶，哈希桶总数量：2，结构：[null=123, null]
com.aotmd.MyHashMap{null=123}
com.aotmd.MyHashMap{}
不存在
不存在
扩容前：当前已用2个哈希桶，哈希桶总数量：2，结构：[跑步=小刚, [篮球=小蔡, 游泳=小红]]
扩容后：当前已用3个哈希桶，哈希桶总数量：4，结构：[跑步=小刚, 篮球=小蔡, null, 游泳=小红]
小美已弹出
已删除
当前已用3个哈希桶，哈希桶总数量：4，结构：[[跑步=小刚, 画画=小强], [编程=小明], null, [游泳=小红, 唱歌=小美~, 唱、跳、rap、篮球=小蔡]]
key=唱歌,value = 小美~
key=跑步,value = 小刚
key=游泳,value = 小红
key=编程,value = 小明
key=唱、跳、rap、篮球,value = 小蔡
key=画画,value = 小强
com.aotmd.MyHashMap{跑步=小刚,画画=小强,编程=小明,游泳=小红,唱歌=小美~,唱、跳、rap、篮球=小蔡}
</code></pre></div></div>
<p>  修改一下,使用系统的HashMap,测试一下是否一致:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//MyHashMap&lt;String, String&gt; map = new MyHashMap&lt;&gt;(1, 0.75F);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">0.75</span><span class="no">F</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"游泳"</span><span class="o">,</span> <span class="s">"小红"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"跑步"</span><span class="o">,</span> <span class="s">"小刚"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美~"</span><span class="o">)+</span><span class="s">"已弹出"</span><span class="o">);</span><span class="c1">//弹出被覆盖Value</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"画画"</span><span class="o">,</span> <span class="s">"小强"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"编程"</span><span class="o">,</span> <span class="s">"小明"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span><span class="c1">//删除key为篮球的键值对</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱、跳、rap、篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
<span class="c1">//System.out.println(map.devOut());</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"key="</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="s">",value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div>
<p>  控制台输出：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{null=123}
{}
不存在
不存在
小美已弹出
已删除
key=唱歌,value = 小美~
key=编程,value = 小明
key=唱、跳、rap、篮球,value = 小蔡
key=跑步,value = 小刚
key=游泳,value = 小红
key=画画,value = 小强
{唱歌=小美~, 编程=小明, 唱、跳、rap、篮球=小蔡, 跑步=小刚, 游泳=小红, 画画=小强}
</code></pre></div></div>
<p>  没有问题</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Java集合-常用实现类</title><link href="https://acteds.github.io/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/" rel="alternate" type="text/html" title="Java集合-常用实现类" /><published>2024-04-07T00:00:00+08:00</published><updated>2024-04-07T00:00:00+08:00</updated><id>https://acteds.github.io/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB</id><content type="html" xml:base="https://acteds.github.io/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/"><![CDATA[<h1 id="引言">引言</h1>
<p>  java集合常用实现类，还包括函数式接口，方法引用笔记。</p>

<h1 id="集合">集合</h1>
<p>  在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <span class="c1">// 可以持有10个String对象</span>
<span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span> <span class="c1">// 可以放入String对象</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 可以获取String对象</span>
</code></pre></div></div>
<p>  既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>
<ul>
  <li>数组初始化后大小不可变；</li>
  <li>数组只能按索引顺序存取。</li>
</ul>

<p>  因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>
<ul>
  <li>可变大小的顺序链表；</li>
  <li>保证无重复元素的集合；</li>
</ul>

<h1 id="collection">Collection</h1>
<p>  Java标准库自带的<code class="language-plaintext highlighter-rouge">java.util</code>包提供了集合类：<code class="language-plaintext highlighter-rouge">Collection</code>，它是除<code class="language-plaintext highlighter-rouge">Map</code>外所有其他集合类的根接口。Java的<code class="language-plaintext highlighter-rouge">java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">List</code>：一种有序列表的集合，例如，按索引排列的<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">List</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">Set</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">name</code>查找对应<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">Map</code>。</li>
</ul>

<p>  Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code class="language-plaintext highlighter-rouge">List</code>，具体的实现类有<code class="language-plaintext highlighter-rouge">ArrayList</code>，<code class="language-plaintext highlighter-rouge">LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型
</code></pre></div></div>
<p>  最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。<br />
  由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Hashtable</code>：一种线程安全的<code class="language-plaintext highlighter-rouge">Map</code>实现；</li>
  <li><code class="language-plaintext highlighter-rouge">Vector</code>：一种线程安全的<code class="language-plaintext highlighter-rouge">List</code>实现；</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code>：基于<code class="language-plaintext highlighter-rouge">Vector</code>实现的<code class="language-plaintext highlighter-rouge">LIFO</code>的栈。</li>
</ul>

<p>  还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Enumeration&lt;E&gt;</code>：已被<code class="language-plaintext highlighter-rouge">Iterator&lt;E&gt;</code>取代。</li>
</ul>

<h1 id="list">List</h1>
<p>  <strong><code class="language-plaintext highlighter-rouge">List</code>的子接口</strong>除了<code class="language-plaintext highlighter-rouge">List</code>接口外，还有<code class="language-plaintext highlighter-rouge">Deque</code>（双端队列）和<code class="language-plaintext highlighter-rouge">Queue</code>（队列）等接口，它们分别代表具有不同特性的列表。<code class="language-plaintext highlighter-rouge">Deque</code>支持在两端添加和删除元素，而<code class="language-plaintext highlighter-rouge">Queue</code>通常采用先进先出（FIFO）的方式管理元素。<br />
  在Java 8中，集合框架引入了一些新的特性，如<code class="language-plaintext highlighter-rouge">forEach()</code>方法、<code class="language-plaintext highlighter-rouge">stream</code>流操作、函数式接口等，可以更方便地对集合进行操作和处理。<br />
  在实际应用中，需要增删元素的有序列表，我们使用最多的是<code class="language-plaintext highlighter-rouge">ArrayList</code>。<br />
  <code class="language-plaintext highlighter-rouge">ArrayList</code>把添加和删除的操作封装起来，让我们操作<code class="language-plaintext highlighter-rouge">List</code>类似于操作数组，却不用关心内部元素如何移动。<br />
  <code class="language-plaintext highlighter-rouge">List&lt;E&gt;</code>接口有几个主要的接口方法：</p>
<ul>
  <li>在末尾添加一个元素：<code class="language-plaintext highlighter-rouge">boolean add(E e)</code></li>
  <li>在指定索引添加一个元素：<code class="language-plaintext highlighter-rouge">boolean add(int index, E e)</code></li>
  <li>删除指定索引的元素：<code class="language-plaintext highlighter-rouge">E remove(int index)</code></li>
  <li>删除某个元素：<code class="language-plaintext highlighter-rouge">boolean remove(Object e)</code></li>
  <li>获取指定索引的元素：<code class="language-plaintext highlighter-rouge">E get(int index)</code></li>
  <li>获取链表大小（包含元素的个数）：<code class="language-plaintext highlighter-rouge">int size()</code></li>
</ul>

<p>  实现<code class="language-plaintext highlighter-rouge">List</code>接口并非只能通过数组（即<code class="language-plaintext highlighter-rouge">ArrayList</code>的实现方式）来实现，另一种<code class="language-plaintext highlighter-rouge">LinkedList</code>通过“链表”也实现了List接口。在<code class="language-plaintext highlighter-rouge">LinkedList</code>中，它的内部每个元素都指向在<code class="language-plaintext highlighter-rouge">LinkedList</code>中，它的内部每个元素都指向下一个元素：</p>
<pre><code class="language-ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐
HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │
        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘
</code></pre>

<p>  我们来比较一下<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">ArrayList</th>
      <th style="text-align: left">LinkedList</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">获取指定元素</td>
      <td style="text-align: left">速度很快</td>
      <td style="text-align: left">需要从头开始查找元素</td>
    </tr>
    <tr>
      <td style="text-align: left">添加元素到末尾</td>
      <td style="text-align: left">速度很快</td>
      <td style="text-align: left">速度很快</td>
    </tr>
    <tr>
      <td style="text-align: left">在指定位置添加/删除</td>
      <td style="text-align: left">需要移动元素</td>
      <td style="text-align: left">不需要移动元素</td>
    </tr>
    <tr>
      <td style="text-align: left">内存占用</td>
      <td style="text-align: left">少</td>
      <td style="text-align: left">较大</td>
    </tr>
  </tbody>
</table>

<p>  <code class="language-plaintext highlighter-rouge">ArrayList</code>适合随机访问，而<code class="language-plaintext highlighter-rouge">LinkedList</code>适合插入和删除操作频繁的场景。<br />
  通常情况下，我们总是优先使用<code class="language-plaintext highlighter-rouge">ArrayList</code>。<code class="language-plaintext highlighter-rouge">List</code>接口<strong>允许</strong>添加<strong>重复</strong>的元素，<code class="language-plaintext highlighter-rouge">List</code>还<strong>允许添加</strong><code class="language-plaintext highlighter-rouge">null</code>。<br />
  除了使用<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>，我们还可以通过<code class="language-plaintext highlighter-rouge">List</code>接口提供的<code class="language-plaintext highlighter-rouge">of()</code>方法，根据给定元素快速创建<code class="language-plaintext highlighter-rouge">List</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</code></pre></div></div>
<p>  但是<code class="language-plaintext highlighter-rouge">List.of()</code>方法不接受<code class="language-plaintext highlighter-rouge">null</code>值，如果传入<code class="language-plaintext highlighter-rouge">null</code>，会抛出<code class="language-plaintext highlighter-rouge">NullPointerException</code>异常。</p>
<h2 id="遍历list">遍历List</h2>
<p>  可以用<code class="language-plaintext highlighter-rouge">for</code>循环根据索引配合<code class="language-plaintext highlighter-rouge">get(int)</code>方法遍历，但这种方式并不推荐，一是代码复杂，二是因为<code class="language-plaintext highlighter-rouge">get(int)</code>方法只有<code class="language-plaintext highlighter-rouge">ArrayList</code>的实现是高效的，换成<code class="language-plaintext highlighter-rouge">LinkedList</code>后，索引越大，访问速度越慢。<br />
  迭代器<code class="language-plaintext highlighter-rouge">Iterator</code>本身也是一个对象，但它是由<code class="language-plaintext highlighter-rouge">List</code>的<strong>实例</strong>调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法的时候创建的。<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何遍历一个<code class="language-plaintext highlighter-rouge">List</code>，并且不同的<code class="language-plaintext highlighter-rouge">List</code>类型，返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象实现也是不同的，但<strong>总是</strong>具有<strong>最高</strong>的访问效率。</p>

<p>  <code class="language-plaintext highlighter-rouge">Iterator</code>对象有两个方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">boolean hasNext()</code>判断是否有下一个元素</li>
  <li><code class="language-plaintext highlighter-rouge">E next()</code>返回下一个元素。</li>
</ul>

<p>  使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历<code class="language-plaintext highlighter-rouge">List</code>代码如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
    <span class="nc">Integer</span> <span class="n">next</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  由于<code class="language-plaintext highlighter-rouge">Iterator</code>遍历是如此常用，所以，Java的<code class="language-plaintext highlighter-rouge">for each</code>循环本身就可以帮我们使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">next</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  只要实现了<code class="language-plaintext highlighter-rouge">Iterable</code>接口的集合类都可以直接用<code class="language-plaintext highlighter-rouge">for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code class="language-plaintext highlighter-rouge">for each</code>循环变成<code class="language-plaintext highlighter-rouge">Iterator</code>的调用，原因就在于<code class="language-plaintext highlighter-rouge">Iterable</code>接口定义了一个<code class="language-plaintext highlighter-rouge">Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>实例。<br />
  在使用迭代器遍历集合时，如果在遍历过程中<strong>修改</strong>了集合的结构（例如添加或删除元素），会导致<code class="language-plaintext highlighter-rouge">ConcurrentModificationException</code>异常。为了避免这种情况，可以使用迭代器的<code class="language-plaintext highlighter-rouge">remove()</code>方法来删除元素，而不是直接调用集合的删除方法。</p>
<h2 id="list和array转换">List和Array转换</h2>
<p>  把<code class="language-plaintext highlighter-rouge">List</code>变为<code class="language-plaintext highlighter-rouge">Array</code>有三种方法：<br />
  <strong>1.</strong>调用<code class="language-plaintext highlighter-rouge">toArray()</code>方法直接返回一个<code class="language-plaintext highlighter-rouge">Object[]</code>数组，这种方法会丢失类型信息，所以实际应用很少。<br />
  <strong>2.</strong>给<code class="language-plaintext highlighter-rouge">toArray(T[])</code>传入一个类型相同的<code class="language-plaintext highlighter-rouge">Array</code>，<code class="language-plaintext highlighter-rouge">List</code>内部自动把元素复制到传入的<code class="language-plaintext highlighter-rouge">Array</code>中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">56</span><span class="o">);</span>
    <span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">n</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">toArray(T[])</code>是泛型方法，因此<code class="language-plaintext highlighter-rouge">T</code>是<strong>独立</strong>的，可以传入其他类型的数组，比如<code class="language-plaintext highlighter-rouge">Number</code>类型，如果传入不兼容类型的数组，则会抛出<code class="language-plaintext highlighter-rouge">ArrayStoreException</code>，如果传入的数组长度小了，则会自动创建一个刚好够大的数组，如果多了则对多的部分填<code class="language-plaintext highlighter-rouge">null</code>。<br />
  最常用的是传入一个“恰好”大小的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
</code></pre></div></div>
<p>  <strong>3.</strong>更简洁的写法是使用<code class="language-plaintext highlighter-rouge">List</code>接口定义的<code class="language-plaintext highlighter-rouge">T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div>
<p>  当使用 <code class="language-plaintext highlighter-rouge">toArray(IntFunction&lt;A[]&gt; generator)</code> 方法时，它会使用传入的 <code class="language-plaintext highlighter-rouge">generator</code> 函数来创建一个新的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，数组的大小通常为列表的大小。<code class="language-plaintext highlighter-rouge">IntFunction&lt;A[]&gt; generator</code> 是一个函数式接口，接受一个整数参数并返回一个泛型数组。可以通过方法引用 <code class="language-plaintext highlighter-rouge">Integer[]::new</code> 来指定生成的数组类型。<a href="#方法引用">详细解释请看这里</a>。<br />
  反过来，把<code class="language-plaintext highlighter-rouge">Array</code>变为<code class="language-plaintext highlighter-rouge">List</code>就简单多了，通过<code class="language-plaintext highlighter-rouge">List.of(T...)</code>方法最简单：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">};</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
</code></pre></div></div>
<p>  对于JDK 11之前的版本，可以使用<code class="language-plaintext highlighter-rouge">Arrays.asList(T...)</code>方法把数组转换成<code class="language-plaintext highlighter-rouge">List</code>。<br />
  因为返回的<code class="language-plaintext highlighter-rouge">List</code>不一定就是<code class="language-plaintext highlighter-rouge">ArrayList</code>或者<code class="language-plaintext highlighter-rouge">LinkedList</code>，因此转换后返回的是一个<strong>只读</strong><code class="language-plaintext highlighter-rouge">List</code>。</p>

<h2 id="equals方法">equals()方法</h2>
<p>  <code class="language-plaintext highlighter-rouge">boolean contains(Object o)</code>方法判断<code class="language-plaintext highlighter-rouge">List</code>是否包含某个指定元素。<br />
  <code class="language-plaintext highlighter-rouge">int indexOf(Object o)</code>方法返回某个元素的索引，如果元素不存在，就返回<code class="language-plaintext highlighter-rouge">-1</code>。<br />
  实际上<code class="language-plaintext highlighter-rouge">contains()</code>内部也是调用的<code class="language-plaintext highlighter-rouge">indexOf()</code>,<code class="language-plaintext highlighter-rouge">indexOf()</code>内部<strong>会使用</strong><code class="language-plaintext highlighter-rouge">equals()</code><strong>判断是否相等</strong>而不是使用<code class="language-plaintext highlighter-rouge">==</code>判断。<code class="language-plaintext highlighter-rouge">ArrayList&lt;&gt;</code>的<code class="language-plaintext highlighter-rouge">indexOf()</code>的源码如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">E</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  因此如果<strong>要使用</strong><code class="language-plaintext highlighter-rouge">List</code>的<code class="language-plaintext highlighter-rouge">contains()</code>、<code class="language-plaintext highlighter-rouge">indexOf()</code>方法，<strong>必须</strong>正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>方法，否则，放进去的实例的<code class="language-plaintext highlighter-rouge">equals()</code>方法就是继承自<code class="language-plaintext highlighter-rouge">Object</code>的<code class="language-plaintext highlighter-rouge">equals()</code>，也就是<code class="language-plaintext highlighter-rouge">==</code>，因此永远不相等。</p>

<hr />

<p><strong>编写equals</strong>
  <code class="language-plaintext highlighter-rouge">equals()</code>方法必须满足以下条件：</p>
<ul>
  <li>自反性（Reflexive）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>来说，<code class="language-plaintext highlighter-rouge">x.equals(x)</code>必须返回<code class="language-plaintext highlighter-rouge">true</code>；</li>
  <li>对称性（Symmetric）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>来说，如果<code class="language-plaintext highlighter-rouge">x.equals(y)</code>为<code class="language-plaintext highlighter-rouge">true</code>，则<code class="language-plaintext highlighter-rouge">y.equals(x)</code>也必须为<code class="language-plaintext highlighter-rouge">true</code>；</li>
  <li>传递性（Transitive）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>和<code class="language-plaintext highlighter-rouge">z</code>来说，如果<code class="language-plaintext highlighter-rouge">x.equals(y)</code>为<code class="language-plaintext highlighter-rouge">true</code>，<code class="language-plaintext highlighter-rouge">y.equals(z)</code>也为<code class="language-plaintext highlighter-rouge">true</code>，那么<code class="language-plaintext highlighter-rouge">x.equals(z)</code>也必须为<code class="language-plaintext highlighter-rouge">true</code>；</li>
  <li>一致性（Consistent）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>来说，只要<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>状态不变，则<code class="language-plaintext highlighter-rouge">x.equals(y)</code>总是一致地返回<code class="language-plaintext highlighter-rouge">true</code>或者<code class="language-plaintext highlighter-rouge">false</code>；</li>
  <li>对<code class="language-plaintext highlighter-rouge">null</code>的比较：即<code class="language-plaintext highlighter-rouge">x.equals(null)</code>永远返回<code class="language-plaintext highlighter-rouge">false</code>。</li>
</ul>

<p>  以<code class="language-plaintext highlighter-rouge">Person</code>类为例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  首先，定义“相等”的逻辑含义。对于<code class="language-plaintext highlighter-rouge">Person</code>类，如果<code class="language-plaintext highlighter-rouge">name</code>相等，并且<code class="language-plaintext highlighter-rouge">age</code>相等，我们就认为两个<code class="language-plaintext highlighter-rouge">Person</code>实例相等。对于<strong>引用字段</strong>比较，使用<code class="language-plaintext highlighter-rouge">equals()</code>，对于<strong>基本类型字段</strong>的比较，使用<code class="language-plaintext highlighter-rouge">==</code>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">nameEquals</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//如果都是null则相等</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nameEquals</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//如果this.name不是null则调用它的equals</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nameEquals</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nameEquals</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  如果<code class="language-plaintext highlighter-rouge">Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code class="language-plaintext highlighter-rouge">Objects.equals()</code>静态方法，注意不是<code class="language-plaintext highlighter-rouge">Object</code>而是<code class="language-plaintext highlighter-rouge">Objects</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">Objects.equals()</code>静态方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</code></pre></div></div>
<p>  是同一个对象或都是<code class="language-plaintext highlighter-rouge">null</code>，<code class="language-plaintext highlighter-rouge">a</code>不是<code class="language-plaintext highlighter-rouge">null</code>则调用<code class="language-plaintext highlighter-rouge">a</code>的<code class="language-plaintext highlighter-rouge">equals</code><br />
  要求是同一个类的写法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="map">Map</h1>
<p>  通过一个键去查询对应的值。使用<code class="language-plaintext highlighter-rouge">List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code class="language-plaintext highlighter-rouge">Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code class="language-plaintext highlighter-rouge">key</code>快速查找<code class="language-plaintext highlighter-rouge">value</code>（元素）。<br />
  <code class="language-plaintext highlighter-rouge">Map</code>也是一个接口，最常用的实现类是<code class="language-plaintext highlighter-rouge">HashMap</code>。除了<code class="language-plaintext highlighter-rouge">HashMap</code>外，还有<code class="language-plaintext highlighter-rouge">TreeMap</code>（基于红黑树实现）和<code class="language-plaintext highlighter-rouge">LinkedHashMap</code>（保持插入顺序或访问顺序）等<code class="language-plaintext highlighter-rouge">Map</code>的实现类，它们可以根据具体的需求选择合适的实现类。<br />
  <code class="language-plaintext highlighter-rouge">HashMap</code>之所以能根据<code class="language-plaintext highlighter-rouge">key</code>直接拿到<code class="language-plaintext highlighter-rouge">value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code class="language-plaintext highlighter-rouge">value</code>，并根据key直接计算出<code class="language-plaintext highlighter-rouge">value</code>应该存储在哪个索引。<br />
  <code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">key</code>不能重复，<code class="language-plaintext highlighter-rouge">value</code>可以重复。<code class="language-plaintext highlighter-rouge">Map</code><strong>不保证顺序</strong>。</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V put(K key, V value)</td>
      <td>把<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>做了映射并放入<code class="language-plaintext highlighter-rouge">Map</code>。如果放入的<code class="language-plaintext highlighter-rouge">key</code><strong>已经存在</strong>，则会更新<code class="language-plaintext highlighter-rouge">value</code>并返回被删除的旧的<code class="language-plaintext highlighter-rouge">value</code>，否则，返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>V get(K key)</td>
      <td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>boolean containsKey(K key)</td>
      <td>查询某个<code class="language-plaintext highlighter-rouge">key</code>是否存在。</td>
    </tr>
    <tr>
      <td>boolean containsValue(V value)</td>
      <td>查询某个<code class="language-plaintext highlighter-rouge">value</code>是否存在。</td>
    </tr>
    <tr>
      <td>keySet()</td>
      <td>返回<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">Set</code>集合。</td>
    </tr>
    <tr>
      <td>entrySet()</td>
      <td>返回此地图中包含的映射的<code class="language-plaintext highlighter-rouge">Set</code>视图。</td>
    </tr>
  </tbody>
</table>

<p><strong>遍历</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k1"</span><span class="o">,</span><span class="s">"v1"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k2"</span><span class="o">,</span><span class="s">"v2"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k3"</span><span class="o">,</span><span class="s">"v3"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStringEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringStringEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringStringEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value = "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>  使用<code class="language-plaintext highlighter-rouge">key</code>存取<code class="language-plaintext highlighter-rouge">value</code>的时候，就会引出一个问题：<br />
  获取<code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">value</code>时，传入的<code class="language-plaintext highlighter-rouge">key</code>不一定就是放入的那个<code class="language-plaintext highlighter-rouge">key</code>对象。而<code class="language-plaintext highlighter-rouge">Map</code>依然能够正常读取。换句话讲，取<code class="language-plaintext highlighter-rouge">value</code>时，两个<code class="language-plaintext highlighter-rouge">key</code>应该内容相同，但不一定是同一个对象。<br />
  因为在<code class="language-plaintext highlighter-rouge">Map</code>的内部，对<code class="language-plaintext highlighter-rouge">key</code>做比较是通过<code class="language-plaintext highlighter-rouge">equals()</code>实现的，这一点和<code class="language-plaintext highlighter-rouge">List</code>查找元素需要正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>是一样的，即正确使用<code class="language-plaintext highlighter-rouge">Map</code><strong>必须保证</strong>：作为<code class="language-plaintext highlighter-rouge">key</code>的对象必须<strong>正确覆写</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法。<br />
  通过<code class="language-plaintext highlighter-rouge">key</code>计算索引的方式就是调用<code class="language-plaintext highlighter-rouge">key</code>对象的<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，它返回一个<code class="language-plaintext highlighter-rouge">int</code>整数。<code class="language-plaintext highlighter-rouge">HashMap</code>正是通过这个方法直接定位<code class="language-plaintext highlighter-rouge">key</code>对应的<code class="language-plaintext highlighter-rouge">value</code>的索引，继而直接返回<code class="language-plaintext highlighter-rouge">value</code>。<br />
  <code class="language-plaintext highlighter-rouge">hashCode()</code>方法要严格遵循以下规范：</p>
<ol>
  <li>如果两个对象<strong>相等</strong>，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code><strong>必须</strong>相等；</li>
  <li>如果两个对象<strong>不相等</strong>，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code><strong>尽量</strong>不要相等。</li>
  <li><code class="language-plaintext highlighter-rouge">equals()</code>用到的用于比较的每一个字段，都必须在<code class="language-plaintext highlighter-rouge">hashCode()</code>中用于计算；<code class="language-plaintext highlighter-rouge">equals()</code>中没有使用到的字段，绝不可放在<code class="language-plaintext highlighter-rouge">hashCode()</code>中计算。</li>
</ol>

<p>  而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code class="language-plaintext highlighter-rouge">hashCode()</code>，会造成<code class="language-plaintext highlighter-rouge">Map</code>内部存储冲突，即<strong>哈希冲突</strong>，使存取的效率下降。<br />
  示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">firstName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">firstName</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">lastName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lastName</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="n">age</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  也可以直接使用<code class="language-plaintext highlighter-rouge">Objects.hash()</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span><span class="n">lastName</span><span class="o">,</span><span class="n">age</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  对于放入<code class="language-plaintext highlighter-rouge">HashMap</code>的<code class="language-plaintext highlighter-rouge">value</code>对象，没有任何要求。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">));</span>
</code></pre></div></div>
<p>  在<code class="language-plaintext highlighter-rouge"> HashMap</code> 中使用 <code class="language-plaintext highlighter-rouge">null</code> 作为键是可以编译通过的，因为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的实现允许键为 <code class="language-plaintext highlighter-rouge">null</code>。在这种情况下，<code class="language-plaintext highlighter-rouge">null</code> 的哈希码会被计算为 0，并存储在哈希表的第一个位置。因此，当你调用 <code class="language-plaintext highlighter-rouge">map.get(null)</code> 时，会返回键为 <code class="language-plaintext highlighter-rouge">null</code> 对应的值 “123”。但需要注意的是，在使用 <code class="language-plaintext highlighter-rouge">null </code>作为键时要格外小心，因为它可能会导致混淆和错误。</p>
<h2 id="哈希冲突">哈希冲突</h2>
<p>  如果不同的两个<code class="language-plaintext highlighter-rouge">key</code>，例如<code class="language-plaintext highlighter-rouge">"a"</code>和<code class="language-plaintext highlighter-rouge">"b"</code>，它们的<code class="language-plaintext highlighter-rouge">hashCode()</code>恰好是相同的，就会造成<strong>哈希冲突</strong>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">));</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Hong"</span><span class="o">));</span>
</code></pre></div></div>
<p>  假设<code class="language-plaintext highlighter-rouge">"a"</code>和<code class="language-plaintext highlighter-rouge">"b"</code>这两个<code class="language-plaintext highlighter-rouge">key</code>最终计算出的索引都是5，造成哈希冲突，那么在<code class="language-plaintext highlighter-rouge">HashMap</code>的数组中，实际存储的不是一个<code class="language-plaintext highlighter-rouge">Person</code>实例，而是一个<code class="language-plaintext highlighter-rouge">List</code>，它包含两个<code class="language-plaintext highlighter-rouge">Entry</code>，一个是<code class="language-plaintext highlighter-rouge">"a"</code>的映射，一个是<code class="language-plaintext highlighter-rouge">"b"</code>的映射：</p>
<pre><code class="language-ascii">  ┌───┐
0 │   │
  ├───┤
1 │   │
  ├───┤
2 │   │
  ├───┤
3 │   │
  ├───┤
4 │   │
  ├───┤
5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;
  ├───┤
6 │   │
  ├───┤
7 │   │
  └───┘
</code></pre>
<p>  在查找的时候，例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
</code></pre></div></div>
<p>  HashMap内部通过<code class="language-plaintext highlighter-rouge">"a"</code>找到的实际上是<code class="language-plaintext highlighter-rouge">List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个<code class="language-plaintext highlighter-rouge">List</code>，并找到一个<code class="language-plaintext highlighter-rouge">Entry</code>，它的<code class="language-plaintext highlighter-rouge">key</code>字段是<code class="language-plaintext highlighter-rouge">"a"</code>，才能返回对应的<code class="language-plaintext highlighter-rouge">Person</code>实例。<br />
  我们把不同的<code class="language-plaintext highlighter-rouge">key</code>具有相同的<code class="language-plaintext highlighter-rouge">hashCode()</code>的情况称之为<strong>哈希冲突</strong>。在冲突的时候，一种最简单的解决办法是用<code class="language-plaintext highlighter-rouge">List</code>存储<code class="language-plaintext highlighter-rouge">hashCode()</code>相同的<code class="language-plaintext highlighter-rouge">key-value</code>。显然，如果冲突的概率越大，这个<code class="language-plaintext highlighter-rouge">List</code>就越长，<code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">get()</code>方法效率就越低，这就是为什么要尽量满足条件二：如果两个对象不相等，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code>尽量不要相等。<br />
  HashMap中依据<code class="language-plaintext highlighter-rouge">key</code>的hash值来确定<code class="language-plaintext highlighter-rouge">value</code>存储位置，所以<strong>一定</strong>要重写<code class="language-plaintext highlighter-rouge">hashCode</code>方法，而重写<code class="language-plaintext highlighter-rouge">equals</code>方法，是为了解决<code class="language-plaintext highlighter-rouge">hash</code><strong>冲突</strong>，如果两个<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">hash</code>值相同，就会调用<code class="language-plaintext highlighter-rouge">equals</code>方法，比较<code class="language-plaintext highlighter-rouge">key</code>值是否相同。<br />
  在存储时：如果<code class="language-plaintext highlighter-rouge">hash</code>值相同，且<code class="language-plaintext highlighter-rouge">equals</code>结果相同就覆盖更新<code class="language-plaintext highlighter-rouge">value</code>值，如果<code class="language-plaintext highlighter-rouge">equals</code>结果不同，即不是同一个<code class="language-plaintext highlighter-rouge">key</code>，<code class="language-plaintext highlighter-rouge">HashMap</code>会将这两个<code class="language-plaintext highlighter-rouge">key-value</code>对以链表或红黑树的形式存储在同一个位置上。<br />
  在取值时：如果计算的<code class="language-plaintext highlighter-rouge">hash</code>值所指的索引位置有多个值，则根据<code class="language-plaintext highlighter-rouge">equals</code>方法找到对应的<code class="language-plaintext highlighter-rouge">key-value</code>对。如果<code class="language-plaintext highlighter-rouge">equals</code>结果相同就返回当前<code class="language-plaintext highlighter-rouge">value</code>值，如果不同就遍历<code class="language-plaintext highlighter-rouge">List</code>中下一个元素。即要<code class="language-plaintext highlighter-rouge">key</code>与<code class="language-plaintext highlighter-rouge">hash</code>同时匹配才会认为是同一个<code class="language-plaintext highlighter-rouge">key</code>。<br />
  JDK中源码:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))){</span><span class="n">ops</span><span class="o">;}</span>
</code></pre></div></div>
<h2 id="扩容">扩容</h2>
<p>  <code class="language-plaintext highlighter-rouge">HashMap</code>初始化时<strong>默认</strong>的<strong>数组大小</strong>为16，任何<code class="language-plaintext highlighter-rouge">key</code>，无论它的<code class="language-plaintext highlighter-rouge">hashCode()</code>有多大，都可以简单地通过：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="o">;</span> <span class="c1">// 0xf = 15</span>
</code></pre></div></div>
<p>  把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。<br />
  这里的<strong>数组大小指哈希桶的数量</strong>，<strong>不等于</strong>键值对的数量，而是指的是可以容纳的哈希桶的数量。每个哈希桶可以存储<strong>多个键值对</strong>（链表，红黑树），因此即使存储了大量的键值对，如果它们的<strong>哈希值冲突</strong>导致它们应该存储在同一个哈希桶中，实际上只会占用一个哈希桶的空间。<code class="language-plaintext highlighter-rouge">HashMap</code>会根据键值对的数量动态调整数组的大小，以保持较低的<strong>填充因子</strong>，从而保证较好的性能。<br />
  <code class="language-plaintext highlighter-rouge">HashMap</code>的<strong>填充因子</strong>超过一定阈值时，<code class="language-plaintext highlighter-rouge">HashMap</code>会在内部自动扩容，每次<strong>扩容一倍</strong>。<br />
  阈值根据<strong>负载因子</strong>确定,默认为<strong>0.75f</strong>。<br />
  如果初始容量为 1024，那么当 <code class="language-plaintext highlighter-rouge">HashMap</code> 的 size 超过 1024 * 负载因子（默认是 0.75f）= 768 时，就会触发扩容操作，此时新的数组大小将是原来的两倍，即 2048。<br />
  扩容操作包括以下步骤：</p>
<ol>
  <li>创建一个新的数组，大小是原数组的两倍。</li>
  <li>将原数组中的元素<strong>重新计算哈希值</strong>，并根据新数组的大小<strong>重新分配位置</strong>。</li>
  <li>将重新计算位置后的元素放入新数组中。</li>
  <li>将新数组设置为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的数组，替换原数组。</li>
</ol>

<p>  <code class="language-plaintext highlighter-rouge">HashMap</code> 的扩容操作是一个比较<strong>耗时</strong>的操作，因为需要重新计算哈希值并重新分配位置。因此，尽量在初始化时指定 <code class="language-plaintext highlighter-rouge">HashMap</code> 的<strong>初始容量</strong>和<strong>负载因子</strong>，避免频繁扩容，提高性能。<br />
  在 <strong>HashMap</strong> 中，每个数组元素（哈希桶）可以存储一个链表或红黑树头节点。当<strong>链表</strong>的元素数量<strong>超过</strong>一定阈值（<strong>默认为 8</strong>）时，链表会转换为红黑树，以提高查找效率。当<strong>红黑树</strong>中的节点数量<strong>少于</strong>一个阈值（<strong>默认为6</strong>）时，红黑树会转换回链表结构。这种转换是为了避免在红黑树中维护的额外开销，因为当节点数量较少时，链表可能比红黑树更有效率。<br />
  红黑树在<code class="language-plaintext highlighter-rouge">HashMap</code>中是从<strong>JDK 8</strong>开始引入的。<strong>在JDK 8之前</strong>，<code class="language-plaintext highlighter-rouge">HashMap</code>使用的是<strong>数组+链表</strong>的方式来处理哈希冲突。<br />
  通常<strong>建议将容量设置为 2 的幂次方</strong>，如果设置的容量不是 2 的幂次方，<code class="language-plaintext highlighter-rouge">HashMap</code> 会自动向上取最接近的 2 的幂次方作为实际的容量。负载因子应该是一个大于0且小于1的浮点数，注意加f。<br />
  只能在初始化时设置容量和扩容因子</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">16</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="线程安全问题">线程安全问题</h2>
<p>  <code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">HashMap</code>等集合类是非线程安全的，这意味着如果多个线程同时访问这些集合并且至少一个线程修改了集合，就可能导致不确定的结果，比如数据丢失、数据不一致等问题。为了在多线程环境中安全地使用集合，可以使用<code class="language-plaintext highlighter-rouge">Collections</code>工具类提供的<code class="language-plaintext highlighter-rouge">SynchronizedList</code>和<code class="language-plaintext highlighter-rouge">SynchronizedMap</code>方法来获取线程安全的集合：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">synchronizedList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">synchronizedMap</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;());</span>
</code></pre></div></div>
<p>  这样就可以确保在多线程环境中对集合的操作是安全的。需要注意的是，虽然这些方法提供了线程安全的集合，但在高并发的情况下仍然需要谨慎处理，以避免出现性能问题。</p>

<h1 id="enummap">EnumMap</h1>
<p>  <code class="language-plaintext highlighter-rouge">HashMap</code>是一种通过对key计算<code class="language-plaintext highlighter-rouge">hashCode()</code>，通过空间换时间的方式，直接定位到<code class="language-plaintext highlighter-rouge">value</code>所在的内部数组的索引，因此，查找效率非常高。<br />
  如果作为<code class="language-plaintext highlighter-rouge">key</code>的对象是<code class="language-plaintext highlighter-rouge">enum</code>类型，还可以使用<code class="language-plaintext highlighter-rouge">EnumMap</code>，它在内部以一个非常紧凑的数组存储<code class="language-plaintext highlighter-rouge">value</code>，并且根据<code class="language-plaintext highlighter-rouge">enum</code>类型的<code class="language-plaintext highlighter-rouge">key</code><strong>直接定位</strong>到内部数组的索引，并<strong>不需要计算</strong><code class="language-plaintext highlighter-rouge">hashCode()</code>，不但效率最高，而且没有额外的空间浪费。实例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">DayOfWeek</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EnumMap</span><span class="o">&lt;&gt;(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">MONDAY</span><span class="o">,</span> <span class="s">"星期一"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">TUESDAY</span><span class="o">,</span> <span class="s">"星期二"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">WEDNESDAY</span><span class="o">,</span> <span class="s">"星期三"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">THURSDAY</span><span class="o">,</span> <span class="s">"星期四"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">FRIDAY</span><span class="o">,</span> <span class="s">"星期五"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SATURDAY</span><span class="o">,</span> <span class="s">"星期六"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">,</span> <span class="s">"星期日"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">MONDAY</span><span class="o">));</span>
</code></pre></div></div>
<p>  注意实例化时，需要将枚举的<strong>class</strong>传入构造方法。<br />
  使用<code class="language-plaintext highlighter-rouge">EnumMap</code>的时候，我们总是用<code class="language-plaintext highlighter-rouge">Map</code>接口来引用它，因此，实际上把<code class="language-plaintext highlighter-rouge">HashMap</code>和<code class="language-plaintext highlighter-rouge">EnumMap</code>互换，在客户端看来没有任何区别。<code class="language-plaintext highlighter-rouge">EnumMap</code>内部就存一个数组，数组大小需要根据<code class="language-plaintext highlighter-rouge">Enum</code>类型的<code class="language-plaintext highlighter-rouge">values.length</code>确定，每个<code class="language-plaintext highlighter-rouge">Enum</code>的实例都有一个唯一索引<code class="language-plaintext highlighter-rouge">ordinal()</code>。<br />
  由于<code class="language-plaintext highlighter-rouge">Enum</code>的<code class="language-plaintext highlighter-rouge">ordinal</code>方法提供了一个稳定的顺序，<code class="language-plaintext highlighter-rouge">EnumMap</code>可以直接使用数组来存储<code class="language-plaintext highlighter-rouge">value</code>，而<strong>不需要</strong>进行<code class="language-plaintext highlighter-rouge">hash</code>计算或者<code class="language-plaintext highlighter-rouge">equals</code>比较，因此在效率上有很大的优势。<br />
  <code class="language-plaintext highlighter-rouge">EnumMap</code>是有序的，它的顺序和<code class="language-plaintext highlighter-rouge">Enum</code>中<code class="language-plaintext highlighter-rouge">enum</code>常量的顺序一致。这一特性在需要按照<code class="language-plaintext highlighter-rouge">Enum</code>定义的顺序进行操作时非常有用。</p>
<h1 id="treemap">TreeMap</h1>
<p>  还有一种<code class="language-plaintext highlighter-rouge">Map</code>，它在内部会对Key进行排序，这种<code class="language-plaintext highlighter-rouge">Map</code>就是<code class="language-plaintext highlighter-rouge">SortedMap</code>。<code class="language-plaintext highlighter-rouge">SortedMap</code>是接口，它的实现类是<code class="language-plaintext highlighter-rouge">TreeMap</code>。</p>
<pre><code class="language-ascii">       ┌───┐
       │Map│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashMap│ │SortedMap│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeMap │
          └─────────┘
</code></pre>
<p>  <code class="language-plaintext highlighter-rouge">SortedMap</code><strong>保证</strong>遍历时以Key的<strong>顺序</strong>来进行<strong>排序</strong>。例如，放入的Key是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>、<code class="language-plaintext highlighter-rouge">"orange"</code>，遍历的顺序一定是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"orange"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>，因为<code class="language-plaintext highlighter-rouge">String</code>默认按字母排序。<br />
  使用<code class="language-plaintext highlighter-rouge">TreeMap</code>时，放入的Key<strong>必须实现</strong><code class="language-plaintext highlighter-rouge">Comparable</code>接口。<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Integer</code>这些类已经实现了<code class="language-plaintext highlighter-rouge">Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。<code class="language-plaintext highlighter-rouge">TreeMap</code><strong>不使用</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>。<br />
  如果作为Key的class没有实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，那么，<strong>必须</strong>在<strong>创建</strong><code class="language-plaintext highlighter-rouge">TreeMap</code>时同时<strong>指定</strong>一个自定义排序算法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Person</span> <span class="n">p1</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Tom"</span><span class="o">),</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">),</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lily"</span><span class="o">),</span> <span class="mi">3</span><span class="o">);</span>
        <span class="c1">//{Person: Bob}{Person: Lily}{Person: Tom}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">)));</span> <span class="c1">// 2</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span> <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nc">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"{Person: "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"}"</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>，如果<code class="language-plaintext highlighter-rouge">a&lt;b</code>，则返回负数，通常是<code class="language-plaintext highlighter-rouge">-1</code>，如果<code class="language-plaintext highlighter-rouge">a==b</code>，则返回<code class="language-plaintext highlighter-rouge">0</code>，如果<code class="language-plaintext highlighter-rouge">a&gt;b</code>，则返回正数，通常是<code class="language-plaintext highlighter-rouge">1</code>。<code class="language-plaintext highlighter-rouge">TreeMap</code>内部根据比较结果对Key进行排序。</p>
<h1 id="properties">Properties</h1>
<p>  在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 上次最后打开的文件:</span>
<span class="n">last_open_file</span><span class="o">=</span><span class="sr">/data/</span><span class="n">hello</span><span class="p">.</span><span class="nf">txt</span>
<span class="c1"># 自动保存文件的时间间隔:</span>
<span class="n">auto_save_interval</span><span class="o">=</span><span class="mi">60</span>
</code></pre></div></div>
<p>  配置文件的特点是，它的Key-Value一般都是<code class="language-plaintext highlighter-rouge">String</code>-<code class="language-plaintext highlighter-rouge">String</code>类型的，因此我们完全可以用<code class="language-plaintext highlighter-rouge">Map&lt;String, String&gt;</code>来表示它。<br />
  因为配置文件非常常用，所以Java集合库提供了一个<code class="language-plaintext highlighter-rouge">Properties</code>来表示一组“配置”。由于历史遗留原因，<code class="language-plaintext highlighter-rouge">Properties</code>内部本质上是一个<code class="language-plaintext highlighter-rouge">Hashtable</code>，但我们只需要用到<code class="language-plaintext highlighter-rouge">Properties</code>自身关于读写配置的接口。<br />
  <strong>读取配置文件</strong><br />
  用<code class="language-plaintext highlighter-rouge">Properties</code>读取配置文件非常简单。Java默认配置文件以<code class="language-plaintext highlighter-rouge">.properties</code>为扩展名，每行以<code class="language-plaintext highlighter-rouge">key=value</code>表示，以<code class="language-plaintext highlighter-rouge">#</code>号开头的是注释。以下是一个典型的配置文件：</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># setting.properties</span>

<span class="n">last_open_file</span><span class="o">=</span><span class="sr">/data/</span><span class="n">hello</span><span class="p">.</span><span class="nf">txt</span>
<span class="n">auto_save_interval</span><span class="o">=</span><span class="mi">60</span>
</code></pre></div></div>
<p>  可以从文件系统读取这个<code class="language-plaintext highlighter-rouge">.properties</code>文件：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">f</span> <span class="o">=</span> <span class="s">"src/com/aotmd/text.properties"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">FileInputStream</span> <span class="n">fileInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fileInputStream</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">filepath</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"last_open_file"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"auto_save_interval"</span><span class="o">,</span> <span class="s">"120"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interval = "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"filepath = "</span> <span class="o">+</span> <span class="n">filepath</span><span class="o">);</span>
</code></pre></div></div>
<p>  用<code class="language-plaintext highlighter-rouge">Properties</code>读取配置文件，一共有三步：</p>
<ol>
  <li>创建<code class="language-plaintext highlighter-rouge">Properties</code>实例；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">load()</code>读取文件；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">getProperty()</code>获取配置。</li>
</ol>

<table>
  <thead>
    <tr>
      <th>返回值类型</th>
      <th>方法</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>String</td>
      <td>getProperty(String key)</td>
      <td>根据指定的键在此属性列表中搜索属性，如果<code class="language-plaintext highlighter-rouge">key</code>不存在，将返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>String</td>
      <td>getProperty(String key, String defaultValue)</td>
      <td>获取指定键的属性值，如果该键不存在，则返回<code class="language-plaintext highlighter-rouge">defaultValue</code>。</td>
    </tr>
    <tr>
      <td>Object</td>
      <td>setProperty(String key, String value)</td>
      <td>设置指定键的值。如果键已经存在，则更新其值。</td>
    </tr>
    <tr>
      <td>Set<code class="language-plaintext highlighter-rouge">&lt;String&gt;</code></td>
      <td>stringPropertyNames()</td>
      <td>返回属性列表中的键集，其中该键及其对应的值是字符串。</td>
    </tr>
    <tr>
      <td>Enumeration&lt;?&gt;</td>
      <td>propertyNames()</td>
      <td>返回此属性列表中的键集，其中键及其对应的值不一定是字符串。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>list(PrintStream out)</td>
      <td>将属性列表输出到指定的输出流。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>list(PrintWriter out)</td>
      <td>将属性列表输出到指定的输出流。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>load(InputStream inStream)</td>
      <td>从输入流中读取属性列表（键和元素对）。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>store(OutputStream out, String comments)</td>
      <td>将此属性列表（键和元素对）以适合使用<code class="language-plaintext highlighter-rouge">load(InputStream)</code>方法加载的格式写入<code class="language-plaintext highlighter-rouge">out</code>。<code class="language-plaintext highlighter-rouge">comments</code>写入的注释</td>
    </tr>
  </tbody>
</table>

<p>  也可以从<code class="language-plaintext highlighter-rouge">classpath</code>读取<code class="language-plaintext highlighter-rouge">.properties</code>文件，因为<code class="language-plaintext highlighter-rouge">load(InputStream)</code>方法接收一个<code class="language-plaintext highlighter-rouge">InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props1</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"./text.properties"</span><span class="o">));</span>
<span class="nc">String</span> <span class="n">filepath1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"last_open_file"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">interval1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"auto_save_interval"</span><span class="o">,</span> <span class="s">"120"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interval = "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"filepath = "</span> <span class="o">+</span> <span class="n">filepath</span><span class="o">);</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">Main.class.getResourceAsStream("./text.properties")</code>用于获取位于与<code class="language-plaintext highlighter-rouge">Main.class</code>相同目录下的<code class="language-plaintext highlighter-rouge">text.properties</code>文件的输入流。<br />
  <code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>是一个用于获取资源的方法，它会返回一个<code class="language-plaintext highlighter-rouge">InputStream</code>对象，可以用于读取资源文件的内容。<br />
  <code class="language-plaintext highlighter-rouge">"./text.properties"</code>表示相对于<code class="language-plaintext highlighter-rouge">Main.class</code>所在目录的路径，即在<code class="language-plaintext highlighter-rouge">Main.class</code>所在目录下寻找名为<code class="language-plaintext highlighter-rouge">text.properties</code>的文件。<br />
  如果有多个<code class="language-plaintext highlighter-rouge">.properties</code>文件，可以反复调用<code class="language-plaintext highlighter-rouge">load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/common/setting.properties"</span><span class="o">));</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"C:\\conf\\setting.properties"</span><span class="o">));</span>
</code></pre></div></div>
<p>  上面的代码演示了<code class="language-plaintext highlighter-rouge">Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。<br />
  <code class="language-plaintext highlighter-rouge">Properties</code>设计的目的是存储<code class="language-plaintext highlighter-rouge">String</code>类型的key－value，但<code class="language-plaintext highlighter-rouge">Properties</code>实际上是从<code class="language-plaintext highlighter-rouge">Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了<code class="language-plaintext highlighter-rouge">getProperty()</code>和<code class="language-plaintext highlighter-rouge">setProperty()</code>方法外，还有从<code class="language-plaintext highlighter-rouge">Hashtable</code>继承下来的<code class="language-plaintext highlighter-rouge">get()</code>和<code class="language-plaintext highlighter-rouge">put()</code>方法，这些方法的参数签名是<code class="language-plaintext highlighter-rouge">Object</code>，我们在使用<code class="language-plaintext highlighter-rouge">Properties</code>的时候，不要去调用这些从<code class="language-plaintext highlighter-rouge">Hashtable</code>继承下来的方法。<br />
 <strong>写入配置文件</strong>
  如果通过<code class="language-plaintext highlighter-rouge">setProperty()</code>修改了<code class="language-plaintext highlighter-rouge">Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code class="language-plaintext highlighter-rouge">store()</code>方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">f</span> <span class="o">=</span> <span class="s">"src/com/aotmd/text.properties"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"language"</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">);</span>
<span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">fos</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">),</span> <span class="s">"这是写入的properties注释"</span><span class="o">);</span>

<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">fis</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">String</span> <span class="n">language</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"language"</span> <span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"language = "</span> <span class="o">+</span> <span class="n">language</span><span class="o">);</span>
</code></pre></div></div>
<p>  早期版本的Java规定<code class="language-plaintext highlighter-rouge">.properties</code>文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code class="language-plaintext highlighter-rouge">name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code class="language-plaintext highlighter-rouge">.properties</code>文件可以使用UTF-8编码了。</p>
<h1 id="set">Set</h1>
<p>  <code class="language-plaintext highlighter-rouge">Map</code>用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但<strong>需要</strong>正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>方法，还要<strong>正确覆写</strong><code class="language-plaintext highlighter-rouge">hashCode()</code>方法。<br />
  如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用<code class="language-plaintext highlighter-rouge">Set</code>。<br />
  <code class="language-plaintext highlighter-rouge">Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>
<ul>
  <li>将元素添加进<code class="language-plaintext highlighter-rouge">Set&lt;E&gt;</code>：<code class="language-plaintext highlighter-rouge">boolean add(E e)</code></li>
  <li>将元素从<code class="language-plaintext highlighter-rouge">Set&lt;E&gt;</code>删除：<code class="language-plaintext highlighter-rouge">boolean remove(Object e)</code></li>
  <li>判断是否包含元素：<code class="language-plaintext highlighter-rouge">boolean contains(Object e)</code>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"abc"</span><span class="o">));</span> <span class="c1">// true</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// true</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// false，添加失败，因为元素已存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// true，元素存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"XYZ"</span><span class="o">));</span> <span class="c1">// false，元素不存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"hello"</span><span class="o">));</span> <span class="c1">// false，删除失败，因为元素不存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span> <span class="c1">// 2，一共两个元素</span>
</code></pre></div>    </div>
    <p>  <code class="language-plaintext highlighter-rouge">Set</code>实际上<strong>相当于</strong>只存储key、不存储value的<code class="language-plaintext highlighter-rouge">Map</code>。经常用<code class="language-plaintext highlighter-rouge">Set</code>去除重复元素。<br />
  放入<code class="language-plaintext highlighter-rouge">Set</code>的元素和<code class="language-plaintext highlighter-rouge">Map</code>的key类似，都要<strong>正确实现</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，否则该元素无法正确地放入<code class="language-plaintext highlighter-rouge">Set</code>。<br />
  最常用的<code class="language-plaintext highlighter-rouge">Set</code>实现类是<code class="language-plaintext highlighter-rouge">HashSet</code>，实际上，<code class="language-plaintext highlighter-rouge">HashSet</code>仅仅是对<code class="language-plaintext highlighter-rouge">HashMap</code>的一个简单封装，它的核心代码如下：</p>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">// 持有一个HashMap:</span>
  <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">E</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
  <span class="c1">// 放入HashMap的value:</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="no">PRESENT</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">PRESENT</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;}</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">o</span><span class="o">);}</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">==</span> <span class="no">PRESENT</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <p>  <code class="language-plaintext highlighter-rouge">Set</code>接口并不保证有序，而<code class="language-plaintext highlighter-rouge">SortedSet</code>接口则保证元素是有序的：</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">HashSet</code>是<strong>无序</strong>的，因为它实现了<code class="language-plaintext highlighter-rouge">Set</code>接口，并没有实现<code class="language-plaintext highlighter-rouge">SortedSet</code>接口；</li>
  <li><code class="language-plaintext highlighter-rouge">TreeSet</code>是<strong>有序</strong>的，因为它实现了<code class="language-plaintext highlighter-rouge">SortedSet</code>接口。</li>
</ul>

<p>  用一张图表示：</p>
<pre><code class="language-ascii">       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
</code></pre>
<p>  使用<code class="language-plaintext highlighter-rouge">TreeSet</code>和使用<code class="language-plaintext highlighter-rouge">TreeMap</code>的要求一样，添加的元素必须正确实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，如果没有实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，那么创建<code class="language-plaintext highlighter-rouge">TreeSet</code>时必须传入一个<code class="language-plaintext highlighter-rouge">Comparator</code>对象。<br />
  <code class="language-plaintext highlighter-rouge">Set</code>用于存储不重复的元素集合：</p>
<ul>
  <li>放入<code class="language-plaintext highlighter-rouge">HashSet</code>的元素与作为<code class="language-plaintext highlighter-rouge">HashMap</code>的key要求相同；</li>
  <li>放入<code class="language-plaintext highlighter-rouge">TreeSet</code>的元素与作为<code class="language-plaintext highlighter-rouge">TreeMap</code>的Key要求相同；</li>
</ul>

<p>  利用<code class="language-plaintext highlighter-rouge">Set</code>可以去除重复元素；<br />
  遍历<code class="language-plaintext highlighter-rouge">SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p>
<h1 id="queue">Queue</h1>
<p>  队列（<code class="language-plaintext highlighter-rouge">Queue</code>）是一种经常使用的集合。<code class="language-plaintext highlighter-rouge">Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code class="language-plaintext highlighter-rouge">List</code>的区别在于，<code class="language-plaintext highlighter-rouge">List</code>可以在任意位置添加和删除元素，而<code class="language-plaintext highlighter-rouge">Queue</code>只有两个操作：</p>
<ul>
  <li>把元素添加到队列末尾；</li>
  <li>从队列头部取出元素。</li>
</ul>

<p>  在Java的标准库中，队列接口<code class="language-plaintext highlighter-rouge">Queue</code>定义了以下几个方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">int size()</code>：获取队列长度；</li>
  <li><code class="language-plaintext highlighter-rouge">boolean add(E)</code>/<code class="language-plaintext highlighter-rouge">boolean offer(E)</code>：添加元素到队尾；</li>
  <li><code class="language-plaintext highlighter-rouge">E remove()</code>/<code class="language-plaintext highlighter-rouge">E poll()</code>：获取队首元素并从队列中删除；</li>
  <li><code class="language-plaintext highlighter-rouge">E element()</code>/<code class="language-plaintext highlighter-rouge">E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>

<p>  对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。</p>

<p>  注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素<strong>失败</strong>时，这两个方法的<strong>行为</strong>是<strong>不同</strong>的。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">throw Exception</th>
      <th style="text-align: left">返回false或null</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">添加元素到队尾</td>
      <td style="text-align: left">add(E e)</td>
      <td style="text-align: left">boolean offer(E e)，添加失败返回false</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素并删除</td>
      <td style="text-align: left">E remove()</td>
      <td style="text-align: left">E poll()，失败返回null</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素但不删除</td>
      <td style="text-align: left">E element()</td>
      <td style="text-align: left">E peek()，失败返回null</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"remove"</span><span class="o">);</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"element"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">element</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

<span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"poll"</span><span class="o">);</span>
<span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"peek"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</code></pre></div></div>

<p>  <strong>不要</strong>把<code class="language-plaintext highlighter-rouge">null</code>添加到队列中，否则<code class="language-plaintext highlighter-rouge">poll()</code>方法返回<code class="language-plaintext highlighter-rouge">null</code>时，很难确定是取到了<code class="language-plaintext highlighter-rouge">null</code>元素还是队列为空。</p>

<p>  <code class="language-plaintext highlighter-rouge">LinkedList</code>即实现了<code class="language-plaintext highlighter-rouge">List</code>接口，又实现了<code class="language-plaintext highlighter-rouge">Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这是一个List:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 这是一个Queue:</span>
<span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<h1 id="priorityqueue">PriorityQueue</h1>

<p>  <code class="language-plaintext highlighter-rouge">Queue</code>是一个先进先出（FIFO）的队列。<code class="language-plaintext highlighter-rouge">PriorityQueue</code>和<code class="language-plaintext highlighter-rouge">Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code class="language-plaintext highlighter-rouge">PriorityQueue</code>调用<code class="language-plaintext highlighter-rouge">remove()</code>或<code class="language-plaintext highlighter-rouge">poll()</code>方法，返回的总是优先级最高的元素。</p>

<p>  要使用<code class="language-plaintext highlighter-rouge">PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 添加3个元素到队列:</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"apple"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"pear"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// apple</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// banana</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// pear</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// null,因为队列为空</span>
</code></pre></div></div>

<p>  放入的顺序是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>、<code class="language-plaintext highlighter-rouge">"banana"</code>，但是取出的顺序却是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"banana"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>，这是因为从字符串的排序看，<code class="language-plaintext highlighter-rouge">"apple"</code>排在最前面，<code class="language-plaintext highlighter-rouge">"pear"</code>排在最后面。</p>

<p>  放入<code class="language-plaintext highlighter-rouge">PriorityQueue</code>的元素，必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，<code class="language-plaintext highlighter-rouge">PriorityQueue</code>会根据元素的<strong>排序顺序</strong>决定出队的优先级。</p>

<p>  <code class="language-plaintext highlighter-rouge">PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口），也可以通过<code class="language-plaintext highlighter-rouge">Comparator</code>自定义排序算法（元素就不必实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">u1</span><span class="o">,</span><span class="n">u2</span><span class="o">)-&gt;{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">u2</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span>
                <span class="kt">int</span> <span class="n">no1</span><span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
                <span class="kt">int</span> <span class="n">no2</span><span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">u2</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
                <span class="k">return</span> <span class="n">no1</span><span class="o">-</span><span class="n">no2</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'V'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// u1的号码是V开头,优先级高:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="c1">// 添加3个元素到队列:</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"A1"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"A2"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Boss"</span><span class="o">,</span> <span class="s">"V1"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Boss"</span><span class="o">,</span> <span class="s">"V10"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Boss/V1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Boss/V10</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Bob/A1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Alice/A2</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span><span class="n">number</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span><span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"User{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", number='"</span> <span class="o">+</span> <span class="n">number</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="deque">Deque</h1>

<p>  <code class="language-plaintext highlighter-rouge">Queue</code>是队列，只能一头进，另一头出。</p>

<p>  如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code class="language-plaintext highlighter-rouge">Deque</code>。</p>

<p>  Java集合提供了接口<code class="language-plaintext highlighter-rouge">Deque</code>来实现一个双端队列，它的功能是：</p>

<ul>
  <li>既可以添加到队尾，也可以添加到队首；</li>
  <li>既可以从队首获取，又可以从队尾获取。</li>
</ul>

<p>  比较<code class="language-plaintext highlighter-rouge">Queue</code>和<code class="language-plaintext highlighter-rouge">Deque</code>出队和入队的方法：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">Queue</th>
      <th style="text-align: left">Deque</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">添加元素到队尾</td>
      <td style="text-align: left">add(E e) / offer(E e)</td>
      <td style="text-align: left">addLast(E e) / offerLast(E e)</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素并删除</td>
      <td style="text-align: left">E remove() / E poll()</td>
      <td style="text-align: left">E removeFirst() / E pollFirst()</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素但不删除</td>
      <td style="text-align: left">E element() / E peek()</td>
      <td style="text-align: left">E getFirst() / E peekFirst()</td>
    </tr>
    <tr>
      <td style="text-align: left">添加元素到队首</td>
      <td style="text-align: left">无</td>
      <td style="text-align: left">addFirst(E e) / offerFirst(E e)</td>
    </tr>
    <tr>
      <td style="text-align: left">取队尾元素并删除</td>
      <td style="text-align: left">无</td>
      <td style="text-align: left">E removeLast() / E pollLast()</td>
    </tr>
    <tr>
      <td style="text-align: left">取队尾元素但不删除</td>
      <td style="text-align: left">无</td>
      <td style="text-align: left">E getLast() / E peekLast()</td>
    </tr>
  </tbody>
</table>

<p>  对于添加元素到队尾的操作，<code class="language-plaintext highlighter-rouge">Queue</code>提供了<code class="language-plaintext highlighter-rouge">add()</code>/<code class="language-plaintext highlighter-rouge">offer()</code>方法，而<code class="language-plaintext highlighter-rouge">Deque</code>提供了<code class="language-plaintext highlighter-rouge">addLast()</code>/<code class="language-plaintext highlighter-rouge">offerLast()</code>方法。添加元素到队首、取队尾元素的操作在<code class="language-plaintext highlighter-rouge">Queue</code>中不存在，在<code class="language-plaintext highlighter-rouge">Deque</code>中由<code class="language-plaintext highlighter-rouge">addFirst()</code>/<code class="language-plaintext highlighter-rouge">removeLast()</code>等方法提供。<br />
  <code class="language-plaintext highlighter-rouge">Deque</code>接口实际上扩展自<code class="language-plaintext highlighter-rouge">Queue</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>
<p>  因此，<code class="language-plaintext highlighter-rouge">Queue</code>提供的<code class="language-plaintext highlighter-rouge">add()</code>/<code class="language-plaintext highlighter-rouge">offer()</code>方法在<code class="language-plaintext highlighter-rouge">Deque</code>中也可以使用，但是，使用<code class="language-plaintext highlighter-rouge">Deque</code>，最好不要调用<code class="language-plaintext highlighter-rouge">offer()</code>，而是调用<code class="language-plaintext highlighter-rouge">offerLast()</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span> <span class="c1">// A</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"B"</span><span class="o">);</span> <span class="c1">// A &lt;- B</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="s">"C"</span><span class="o">);</span> <span class="c1">// C &lt;- A &lt;- B</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// C, 剩下A &lt;- B</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span> <span class="c1">// B, 剩下A</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// A</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// null</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  如果直接写<code class="language-plaintext highlighter-rouge">deque.offer()</code>，我们就需要思考，<code class="language-plaintext highlighter-rouge">offer()</code>实际上是<code class="language-plaintext highlighter-rouge">offerLast()</code>，我们明确地写上<code class="language-plaintext highlighter-rouge">offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。<br />
  因此，使用<code class="language-plaintext highlighter-rouge">Deque</code>，推荐总是明确调用<code class="language-plaintext highlighter-rouge">offerLast()</code>/<code class="language-plaintext highlighter-rouge">offerFirst()</code>或者<code class="language-plaintext highlighter-rouge">pollFirst()</code>/<code class="language-plaintext highlighter-rouge">pollLast()</code>方法。<br />
  <code class="language-plaintext highlighter-rouge">Deque</code>是一个接口，它的实现类有<code class="language-plaintext highlighter-rouge">ArrayDeque</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>。<br />
  我们发现<code class="language-plaintext highlighter-rouge">LinkedList</code>真是一个全能选手，它即是<code class="language-plaintext highlighter-rouge">List</code>，又是<code class="language-plaintext highlighter-rouge">Queue</code>，还是<code class="language-plaintext highlighter-rouge">Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不推荐的写法:</span>
<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">d1</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span>
<span class="c1">// 推荐的写法：</span>
<span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">d2</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span>
</code></pre></div></div>
<p>  可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h1 id="stack">Stack</h1>
<p>  栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。<br />
  <code class="language-plaintext highlighter-rouge">Queue</code>的特点FIFO：所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进<code class="language-plaintext highlighter-rouge">Stack</code>的元素一定最早出<code class="language-plaintext highlighter-rouge">Stack</code>的。因此，<code class="language-plaintext highlighter-rouge">Stack</code>是这样一种数据结构：只能不断地往<code class="language-plaintext highlighter-rouge">Stack</code>中压入（push）元素，最后进去的必须最早弹出（pop）来。<br />
  在Java中，我们用<code class="language-plaintext highlighter-rouge">Deque</code>可以实现<code class="language-plaintext highlighter-rouge">Stack</code>的功能：</p>
<ul>
  <li>把元素压栈：<code class="language-plaintext highlighter-rouge">push(E)</code>/<code class="language-plaintext highlighter-rouge">addFirst(E)</code>；</li>
  <li>把栈顶的元素“弹出”：<code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">removeFirst()</code>；</li>
  <li>取栈顶元素但不弹出：<code class="language-plaintext highlighter-rouge">peek()</code>/<code class="language-plaintext highlighter-rouge">peekFirst()</code>。</li>
</ul>

<p>  为什么Java的集合类没有单独的<code class="language-plaintext highlighter-rouge">Stack</code>接口呢？因为有个遗留类名字就叫<code class="language-plaintext highlighter-rouge">Stack</code>，出于兼容性考虑，所以没办法创建<code class="language-plaintext highlighter-rouge">Stack</code>接口，只能用<code class="language-plaintext highlighter-rouge">Deque</code>接口来“模拟”一个<code class="language-plaintext highlighter-rouge">Stack</code>了。<br />
  当我们把<code class="language-plaintext highlighter-rouge">Deque</code>作为<code class="language-plaintext highlighter-rouge">Stack</code>使用时，注意只调用<code class="language-plaintext highlighter-rouge">push()</code>/<code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">peek()</code>方法，不要调用<code class="language-plaintext highlighter-rouge">addFirst()</code>/<code class="language-plaintext highlighter-rouge">removeFirst()</code>/<code class="language-plaintext highlighter-rouge">peekFirst()</code>方法，这样代码更加清晰。</p>

<p>  Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发<code class="language-plaintext highlighter-rouge">StackOverflowError</code>。<br />
  除基取余倒排列：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">toHex</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">s</span> <span class="o">={</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"4"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"7"</span><span class="o">,</span><span class="s">"8"</span><span class="o">,</span><span class="s">"9"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"C"</span><span class="o">,</span><span class="s">"D"</span><span class="o">,</span><span class="s">"E"</span><span class="o">,</span><span class="s">"F"</span><span class="o">};</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">n</span><span class="o">%</span><span class="mi">16</span><span class="o">]);</span>
        <span class="n">n</span><span class="o">/=</span><span class="mi">16</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="iterator">Iterator</h1>
<p>  Java的集合类都可以使用<code class="language-plaintext highlighter-rouge">for each</code>循环，<code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Set</code>和<code class="language-plaintext highlighter-rouge">Queue</code>会迭代每个元素，<code class="language-plaintext highlighter-rouge">Map</code>会迭代每个key。以<code class="language-plaintext highlighter-rouge">List</code>为例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Orange"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  实际上，Java编译器并不知道如何遍历<code class="language-plaintext highlighter-rouge">List</code>。上述代码能够编译通过，只是因为编译器把<code class="language-plaintext highlighter-rouge">for each</code>循环通过<code class="language-plaintext highlighter-rouge">Iterator</code>改写为了普通的<code class="language-plaintext highlighter-rouge">for</code>循环：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
     <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这种通过<code class="language-plaintext highlighter-rouge">Iterator</code>对象遍历集合的模式称为迭代器。<br />
  使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关心它们内部的存储结构。<br />
  例如，我们虽然知道<code class="language-plaintext highlighter-rouge">ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code class="language-plaintext highlighter-rouge">get(int)</code>方法。虽然我们可以用<code class="language-plaintext highlighter-rouge">for</code>循环遍历：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code class="language-plaintext highlighter-rouge">ArrayList</code>换成<code class="language-plaintext highlighter-rouge">LinkedList</code>，<code class="language-plaintext highlighter-rouge">get(int)</code>方法耗时会随着<code class="language-plaintext highlighter-rouge">index</code>的增加而增加。如果把<code class="language-plaintext highlighter-rouge">ArrayList</code>换成<code class="language-plaintext highlighter-rouge">Set</code>，上述代码就无法编译，因为<code class="language-plaintext highlighter-rouge">Set</code>内部没有索引。<br />
  用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历就没有上述问题，因为<code class="language-plaintext highlighter-rouge">Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的<code class="language-plaintext highlighter-rouge">for each</code>循环自动转换为<code class="language-plaintext highlighter-rouge">Iterator</code>遍历。<br />
  如果我们自己编写了一个集合类，想要使用<code class="language-plaintext highlighter-rouge">for each</code>循环，只需满足以下条件：</p>
<ul>
  <li>集合类实现<code class="language-plaintext highlighter-rouge">Iterable</code>接口，该接口要求返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象；</li>
  <li>用<code class="language-plaintext highlighter-rouge">Iterator</code>对象迭代集合内部数据。</li>
</ul>

<p>  这里的关键在于，集合类通过调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法，返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象，这个对象必须自己知道如何遍历该集合。<br />
  一个简单的<code class="language-plaintext highlighter-rouge">Iterator</code>示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">rlist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReverseList</span><span class="o">&lt;&gt;();</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Pear"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">rlist</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="no">T</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">ReverseList</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">++);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  虽然实现类稍微比较复杂，但这是底层集合库，只需编写一次。而调用方则完全按<code class="language-plaintext highlighter-rouge">for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。<br />
  在编写<code class="language-plaintext highlighter-rouge">Iterator</code>的时候，通常可以用一个内部类来实现<code class="language-plaintext highlighter-rouge">Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类可以用<code class="language-plaintext highlighter-rouge">ReverseList.this</code>获得当前外部类的<code class="language-plaintext highlighter-rouge">this</code>引用，然后，通过这个<code class="language-plaintext highlighter-rouge">this</code>引用就可以访问<code class="language-plaintext highlighter-rouge">ReverseList</code>的所有字段和方法。<br />
  <code class="language-plaintext highlighter-rouge">Iterator</code>是一种抽象的数据访问模型。使用<code class="language-plaintext highlighter-rouge">Iterator</code>模式进行迭代的好处有：</p>
<ul>
  <li>对任何集合都采用同一种访问模型；</li>
  <li>调用者对集合内部结构一无所知；</li>
  <li>集合类返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何迭代。</li>
</ul>

<p>  Java提供了标准的迭代器模型，即集合类实现<code class="language-plaintext highlighter-rouge">java.util.Iterable</code>接口，返回<code class="language-plaintext highlighter-rouge">java.util.Iterator</code>实例。</p>
<h1 id="collections">Collections</h1>
<p>  <code class="language-plaintext highlighter-rouge">Collections</code>是JDK提供的工具类，同样位于<code class="language-plaintext highlighter-rouge">java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。 注意<strong>Collections</strong>结尾多了一个s，不是<strong>Collection</strong>！<br />
  <code class="language-plaintext highlighter-rouge">addAll()</code>方法可以给一个<code class="language-plaintext highlighter-rouge">Collection</code>类型的集合添加若干元素。因为方法签名是<code class="language-plaintext highlighter-rouge">Collection</code>，所以我们可以传入<code class="language-plaintext highlighter-rouge">List</code>，<code class="language-plaintext highlighter-rouge">Set</code>等各种集合类型。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="no">T</span><span class="o">...</span> <span class="n">elements</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">List&lt;T&gt; emptyList()</code></td>
      <td>创建空List，返回的空集合是<strong>不可变集合</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; emptyMap()</code></td>
      <td>创建空Map，返回的空集合是<strong>不可变集合</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Set&lt;T&gt; emptySet()</code></td>
      <td>创建空Set，返回的空集合是<strong>不可变集合</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">List&lt;T&gt; singletonList(T o)</code></td>
      <td>创建一个元素的List，也是<strong>不可变集合</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; singletonMap(K key, V value)</code></td>
      <td>创建一个元素的Map，也是<strong>不可变集合</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Set&lt;T&gt; singleton(T o)</code></td>
      <td>创建一个元素的Set，也是<strong>不可变集合</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sort(list)</code></td>
      <td>对List排序</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">shuffle(list)</code></td>
      <td>对List洗牌，打乱顺序</td>
    </tr>
  </tbody>
</table>

<p>  也可以用各个集合接口提供的<code class="language-plaintext highlighter-rouge">of(T...)</code>方法，它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合。</p>

<p><strong>不可变集合</strong></p>

<p>  <code class="language-plaintext highlighter-rouge">Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
  <li>封装成不可变List：<code class="language-plaintext highlighter-rouge">List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
  <li>封装成不可变Set：<code class="language-plaintext highlighter-rouge">Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
  <li>封装成不可变Map：<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>

<p>  这种封装实际上是通过<strong>创建</strong>一个<strong>代理对象</strong>，<strong>拦截</strong>掉所有修改方法实现的。然而，继续对原始的可变<code class="language-plaintext highlighter-rouge">List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code class="language-plaintext highlighter-rouge">List</code>。因此，如果我们希望把一个可变<code class="language-plaintext highlighter-rouge">List</code>封装成不可变<code class="language-plaintext highlighter-rouge">List</code>，那么，返回不可变<code class="language-plaintext highlighter-rouge">List</code>后，最好立刻扔掉可变<code class="language-plaintext highlighter-rouge">List</code>的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code class="language-plaintext highlighter-rouge">List</code>变化了。</p>

<p>  <strong>线程安全集合</strong></p>

<p>  <code class="language-plaintext highlighter-rouge">Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<ul>
  <li>变为线程安全的List：<code class="language-plaintext highlighter-rouge">List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
  <li>变为线程安全的Set：<code class="language-plaintext highlighter-rouge">Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
  <li>变为线程安全的Map：<code class="language-plaintext highlighter-rouge">Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
</ul>

<p>  从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>

<h1 id="其他">其他</h1>
<h2 id="方法引用">方法引用</h2>
<p>  展开<code class="language-plaintext highlighter-rouge">Integer[]::new</code>后：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div>
<p>  在这里，<code class="language-plaintext highlighter-rouge">IntFunction&lt;Integer[]&gt;</code> 是一个函数式接口，它定义了一个<code class="language-plaintext highlighter-rouge">IntFunction&lt;Integer[]&gt;</code>的匿名实现，实现了<code class="language-plaintext highlighter-rouge">apply</code>方法来创建一个指定大小的<code class="language-plaintext highlighter-rouge">Integer</code>数组。然后，通过<code class="language-plaintext highlighter-rouge">toArray</code>方法将列表转换为该数组。<br />
  通过lambda 表达式简化后变成：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div>
<p>  这个 lambda 表达式接受一个整数参数 <code class="language-plaintext highlighter-rouge">size</code>，并返回一个新的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，长度为 <code class="language-plaintext highlighter-rouge">size</code>。<br />
  通过方法引用再次简化后变成：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">Integer[]::new</code> 表示一个构造函数引用，它接受一个整数参数（数组的长度）并返回一个 <code class="language-plaintext highlighter-rouge">Integer</code> 数组。这样，<code class="language-plaintext highlighter-rouge">toArray(Integer[]::new)</code> 将生成一个与 <code class="language-plaintext highlighter-rouge">list</code> 大小相同的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，并将 <code class="language-plaintext highlighter-rouge">list</code> 中的元素复制到这个数组中。</p>

<h2 id="函数式接口">函数式接口</h2>
<p>  函数式接口是Java中的一个概念，它是指只包含一个抽象方法的接口。函数式接口可以用作Lambda表达式的类型，从而支持函数式编程的特性。在Java中，函数式接口可以通过<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code>注解来标识，确保接口只包含一个抽象方法。<br />
  当使用函数式接口时，编译器会根据<strong>Lambda表达式</strong>或<strong>方法引用</strong>的上下文，将其<strong>转换为函数式接口的实</strong>例，并在需要时调用相应的方法。这些实例可以在运行时被JVM执行。<br />
  因此，函数式接口的调用是在运行时由<strong>JVM执行</strong>的，<strong>编译器</strong>负责将<strong>Lambda表达式</strong>或<strong>方法引用</strong>转换为<strong>函数式接口</strong>的实例，以便在程序运行时进行调用。</p>

<h3 id="方法引用-1"><strong>方法引用：</strong></h3>

<table>
  <thead>
    <tr>
      <th>引用类型</th>
      <th>方法引用示例</th>
      <th>对应调用示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>静态方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">Main::staticMethod</code></td>
      <td><code class="language-plaintext highlighter-rouge">Main.staticMethod(...)</code></td>
    </tr>
    <tr>
      <td>实例方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">main::instanceMethod</code></td>
      <td><code class="language-plaintext highlighter-rouge">main.instanceMethod(...)</code></td>
    </tr>
    <tr>
      <td>构造方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">Main::new</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main(...)</code></td>
    </tr>
    <tr>
      <td>数组构造方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">Main[]::new</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main[?]</code></td>
    </tr>
  </tbody>
</table>

<p>  这些方法引用可以简化代码，使其更易读和易维护。</p>

<h3 id="无参引用调用"><strong>无参引用调用：</strong></h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>接口</th>
      <th>代码</th>
      <th>等效调用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>静态方法</td>
      <td>Runnable</td>
      <td><code class="language-plaintext highlighter-rouge">Runnable r=Main::staticMethod;r.run();</code></td>
      <td><code class="language-plaintext highlighter-rouge">Main.staticMethod();</code></td>
    </tr>
    <tr>
      <td>实例方法</td>
      <td>Runnable</td>
      <td><code class="language-plaintext highlighter-rouge">Runnable r=main::instanceMethod;r.run();</code></td>
      <td><code class="language-plaintext highlighter-rouge">main.instanceMethod();</code></td>
    </tr>
    <tr>
      <td>构造方法</td>
      <td>Supplier</td>
      <td><code class="language-plaintext highlighter-rouge">Supplier&lt;Main&gt; s=Main::new;s.get();</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main();</code></td>
    </tr>
    <tr>
      <td>数组</td>
      <td>IntFunction</td>
      <td><code class="language-plaintext highlighter-rouge">IntFunction&lt;Main[]&gt; g=Main[]::new;g.apply(5);</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main[5];</code></td>
    </tr>
  </tbody>
</table>

<p>  实例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.IntFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"静态方法"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">instanceMethod</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例方法"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"构造方法"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 静态方法引用</span>
        <span class="nc">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="n">r1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span><span class="c1">//Main.staticMethod()</span>
        <span class="c1">// 实例方法引用</span>
        <span class="nc">Main</span> <span class="n">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">();</span>
        <span class="nc">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="nl">main:</span><span class="o">:</span><span class="n">instanceMethod</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="n">r2</span><span class="o">.</span><span class="na">run</span><span class="o">();</span><span class="c1">//main.instanceMethod()</span>
        <span class="c1">// 构造方法引用</span>
        <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Main</span><span class="o">&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="nc">Main</span> <span class="n">main2</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span><span class="c1">//new Main()</span>
        <span class="c1">// 数组构造方法引用</span>
        <span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Main</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="nc">Main</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span><span class="c1">//new Main[5]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="带参引用调用方法"><strong>带参引用调用方法：</strong></h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>接口</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>无参方法</td>
      <td>Runnable</td>
      <td><code class="language-plaintext highlighter-rouge">run()</code>调用</td>
    </tr>
    <tr>
      <td>一个参数</td>
      <td>Consumer<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code></td>
      <td><code class="language-plaintext highlighter-rouge">.accept(T)</code>调用</td>
    </tr>
    <tr>
      <td>两个参数</td>
      <td>BiConsumer&lt;T,U&gt;</td>
      <td><code class="language-plaintext highlighter-rouge">accept(T,U)</code>调用</td>
    </tr>
    <tr>
      <td>更多个参数</td>
      <td>自定义函数式接口，并使用<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code></td>
      <td>调用随便</td>
    </tr>
  </tbody>
</table>

<p>  实例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"静态方法:"</span><span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法引用</span>
        <span class="nc">Runnable</span> <span class="n">a</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">a</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        
        <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">c</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        
        <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">b</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"123"</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
        
        <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">t</span><span class="o">.</span><span class="na">随便</span><span class="o">(</span><span class="s">"123"</span><span class="o">,</span><span class="s">"345"</span><span class="o">,</span><span class="s">"456"</span><span class="o">);</span>
        
        <span class="c1">// 柯里化（currying）的技巧，将一个多参数的方法转换为一系列单参数的方法。</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">cr2</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">v1</span><span class="o">);</span>
        <span class="n">cr2</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">run</span><span class="o">();</span>
        
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;&gt;</span> <span class="n">cr3</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">);</span>
        <span class="n">cr3</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">accept</span><span class="o">(</span><span class="s">"Consumer"</span><span class="o">);</span>
        
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">cr</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">);</span>
        <span class="n">cr</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">随便</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">自定义接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="n">随便</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  柯里化是一种函数式编程的技术，通过这种技巧可以将多参数函数转换为一系列接受单个参数的函数。</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">cr2</code>是一个<code class="language-plaintext highlighter-rouge">Function&lt;Integer, Runnable&gt;</code>，它接受一个整数参数，并返回一个<code class="language-plaintext highlighter-rouge">Runnable</code>，这个<code class="language-plaintext highlighter-rouge">Runnable</code>调用了<code class="language-plaintext highlighter-rouge">Main.staticMethod</code>方法。</li>
  <li><code class="language-plaintext highlighter-rouge">cr3</code>是一个<code class="language-plaintext highlighter-rouge">Function&lt;Integer, Function&lt;Integer, Consumer&lt;String&gt;&gt;&gt;</code>，它接受两个整数参数，并返回一个<code class="language-plaintext highlighter-rouge">Consumer&lt;String&gt;</code>，这个<code class="language-plaintext highlighter-rouge">Consumer&lt;String&gt;</code>调用了<code class="language-plaintext highlighter-rouge">Main.staticMethod</code>方法。</li>
  <li><code class="language-plaintext highlighter-rouge">cr</code>是一个<code class="language-plaintext highlighter-rouge">Function&lt;Integer, 自定义接口&lt;Integer, Integer, Integer&gt;&gt;</code>，它接受一个整数参数，并返回一个自定义接口的实例，这个自定义接口接受三个整数参数，并调用了<code class="language-plaintext highlighter-rouge">Main.staticMethod</code>方法。</li>
</ol>

<p>  通过柯里化，可以更灵活地使用多参数方法，将其转换为一系列单参数方法，使得代码更加模块化和易于理解。</p>

<hr />

<h3 id="带参引用调用构造方法"><strong>带参引用调用构造方法：</strong></h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>接口</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>无参方法</td>
      <td>Supplier<类名></类名></td>
      <td><code class="language-plaintext highlighter-rouge">get()</code>调用</td>
    </tr>
    <tr>
      <td>一个参数</td>
      <td>Function&lt;T,类名&gt;</td>
      <td><code class="language-plaintext highlighter-rouge">apply(T)</code>调用</td>
    </tr>
    <tr>
      <td>两个参数</td>
      <td>BiFunction&lt;T,U,类名&gt;</td>
      <td><code class="language-plaintext highlighter-rouge">apply(T,U)</code>调用</td>
    </tr>
    <tr>
      <td>更多个参数</td>
      <td>自定义函数式接口，并使用<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code></td>
      <td>调用随便</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span><span class="na">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"构造方法："</span><span class="o">+</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 构造方法引用</span>
        <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Main</span><span class="o">&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main1</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">constructor</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main2</span> <span class="o">=</span> <span class="n">constructor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"你好"</span><span class="o">);</span>

        <span class="nc">BiFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">constructor2</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main3</span> <span class="o">=</span> <span class="n">constructor2</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">);</span>

        <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">constructor3</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main4</span> <span class="o">=</span> <span class="n">constructor3</span><span class="o">.</span><span class="na">随便</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="c1">//柯里化</span>
        <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;&gt;</span> <span class="n">cr4</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">,</span> <span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">);</span>
        <span class="nc">Main</span> <span class="n">main5</span> <span class="o">=</span> <span class="n">cr4</span><span class="o">.</span><span class="na">随便</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="na">随便</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">自定义接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">V</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="n">随便</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="展开一个mainnew">展开一个<code class="language-plaintext highlighter-rouge">Main::new;</code></h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span><span class="na">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"构造方法："</span><span class="o">+</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法引用</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f1</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="c1">// Lambda</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">};</span>
        <span class="c1">// 匿名内部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// 普通内部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f4</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Main</span><span class="o">().</span><span class="na">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="c1">// 静态内部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f5</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Main</span><span class="o">.</span><span class="na">B</span><span class="o">();</span>
        <span class="c1">// 外部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f6</span> <span class="o">=</span><span class="k">new</span> <span class="no">C</span><span class="o">();</span>

        <span class="n">f1</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f2</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f3</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f4</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f4</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f5</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f5</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f6</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f6</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
    <span class="o">}</span>
    <span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="n">方法</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  控制台：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">构造方法</span><span class="err">：</span><span class="o">[]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="err">$</span><span class="n">$Lambda</span><span class="err">$</span><span class="mi">14</span><span class="o">/</span><span class="mh">0x00000008000c0b40</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="err">$</span><span class="n">$Lambda</span><span class="err">$</span><span class="mi">15</span><span class="o">/</span><span class="mh">0x00000008000c0d80</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="err">$</span><span class="mi">1</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="n">$A</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="n">$B</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">C</span><span class="o">]</span>
</code></pre></div></div>
<p>  从上到下，越来越“low“。</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Java泛型</title><link href="https://acteds.github.io/2024/03/21/%E6%B3%9B%E5%9E%8B/" rel="alternate" type="text/html" title="Java泛型" /><published>2024-03-21T00:00:00+08:00</published><updated>2024-03-21T00:00:00+08:00</updated><id>https://acteds.github.io/2024/03/21/%E6%B3%9B%E5%9E%8B</id><content type="html" xml:base="https://acteds.github.io/2024/03/21/%E6%B3%9B%E5%9E%8B/"><![CDATA[<h1 id="引言">引言</h1>
<p>  java泛型笔记。</p>

<h1 id="泛型">泛型</h1>
<p>  泛型就是编写模板代码来适应任意类型；<br />
  泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；<br />
  泛型的继承关系<strong>可以</strong>把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！），但<strong>不能</strong>把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！<code class="language-plaintext highlighter-rouge">T</code>也不能变成父类）。<br />
  如果实例化时<strong>不定义泛型类型</strong>时，那么默认会使用<code class="language-plaintext highlighter-rouge">Object</code>作为泛型类型参数。如<code class="language-plaintext highlighter-rouge">MyClass myClass = new MyClass();</code>，那么<code class="language-plaintext highlighter-rouge">T</code>会被擦除为<code class="language-plaintext highlighter-rouge">Object</code>，相当于<code class="language-plaintext highlighter-rouge">MyClass&lt;Object&gt; myClass = new MyClass&lt;Object&gt;();</code>。<br />
  编译器如果能自动推断出泛型类型，可以省略后面的泛型类型。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
</code></pre></div></div>
<p>  编译器看到泛型类型<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>就<strong>可以</strong>自动推断出后面的<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>的泛型类型<strong>必须</strong>是<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>  除了<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code class="language-plaintext highlighter-rouge">Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>这个泛型接口。</p>
<h2 id="泛型类">泛型类</h2>
<p>  泛型类写法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  定义泛型类时，在类名后面定义<code class="language-plaintext highlighter-rouge">泛型类型参数</code>。<br />
  <strong>在泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</strong><br />
  初始化：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span><span class="c1">//或new Pair&lt;String&gt;("1","2");</span>
</code></pre></div></div>
<h2 id="泛型方法">泛型方法</h2>
<h3 id="泛型方法的定义">泛型方法的定义</h3>

<p>  泛型方法写法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  在Java中，泛型方法的定义通常如下所示：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">返回类型</span> <span class="n">方法名</span><span class="o">(</span><span class="n">参数列表</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 方法体</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：泛型类型参数声明，放在<strong>返回类型之前</strong>，表示该方法是一个泛型方法，并且可以接受类型为<code class="language-plaintext highlighter-rouge">T</code>的参数或返回类型为<code class="language-plaintext highlighter-rouge">T</code>的值。</li>
  <li>返回类型：方法的返回类型，可以是泛型类型<code class="language-plaintext highlighter-rouge">T</code>或其他类型。</li>
  <li>方法名：方法的名称。</li>
  <li>参数列表：方法的参数列表，可以包含泛型类型<code class="language-plaintext highlighter-rouge">T</code>。</li>
  <li>方法体：方法的具体实现。</li>
</ul>

<p>  在泛型方法中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是用来声明泛型类型参数的。当调用泛型方法时，可以根据实际情况传入不同的类型参数。例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="nc">Integer</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它可以接受任意类型的参数并返回相同类型的值。在调用<code class="language-plaintext highlighter-rouge">myMethod</code>时，根据传入的参数类型确定返回类型，从而实现了泛型方法的灵活性。</p>

<p>  在泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p>

<p>  <strong>而在方法中定义的泛型类型参数只适用于该方法</strong>。</p>

<h3 id="同时定义泛型类与泛型方法">同时定义泛型类与泛型方法</h3>
<p>  如果在类名后面定义了泛型类型参数，在类的方法中仍然<strong>可以</strong>使用独立的泛型类型参数。这两者是独立的，例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  在这个例子中，<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>是一个泛型类，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>表示类的泛型类型参数。<code class="language-plaintext highlighter-rouge">printValue</code>是泛型方法，<code class="language-plaintext highlighter-rouge">printValue</code>中的<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code>是方法级别的泛型类型参数，泛型方法的<code class="language-plaintext highlighter-rouge">K</code>与类的<code class="language-plaintext highlighter-rouge">T</code>是相互独立的。</p>

<p>  <strong>在泛型方法中可以使用泛型类的标识符</strong>。泛型类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>中的泛型方法也可以使用类的泛型标识符<code class="language-plaintext highlighter-rouge">T</code>以下是一个示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">U</span> <span class="n">u</span><span class="o">,</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyClass value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">u</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Main</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="n">myClass</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">,</span><span class="s">"haha"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>  在这个例子中，<code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它使用了泛型方法类型参数<code class="language-plaintext highlighter-rouge">U</code>，这个类型参数与泛型类<code class="language-plaintext highlighter-rouge">MyClass</code>中的类型参数<code class="language-plaintext highlighter-rouge">T</code>是不同的，它也使用了泛型类方法类型参数<code class="language-plaintext highlighter-rouge">T</code>。在<code class="language-plaintext highlighter-rouge">myMethod&lt;Integer&gt;(123, "haha")</code>这个调用中，类型参数<code class="language-plaintext highlighter-rouge">U</code>被指定为<code class="language-plaintext highlighter-rouge">Integer</code>，类型参数<code class="language-plaintext highlighter-rouge">T</code>在类实例化时被推断为<code class="language-plaintext highlighter-rouge">String</code>。因此，<code class="language-plaintext highlighter-rouge">myMethod</code>方法的第一个参数<code class="language-plaintext highlighter-rouge">u</code>是<code class="language-plaintext highlighter-rouge">Integer</code>类型，第二个参数<code class="language-plaintext highlighter-rouge">t</code>是<code class="language-plaintext highlighter-rouge">String</code>类型。</p>

<h3 id="泛型类与泛型方法使用相同的泛型类型参数名">泛型类与泛型方法使用相同的泛型类型参数名</h3>

<p>  如果在类名后面定义了泛型类型参数，并且在方法中使用了<strong>相同的泛型类型参数名</strong>，这并不会产生冲突，因为它们在不同的作用域中。类的泛型类型参数适用于整个类，而方法的泛型类型参数只适用于该方法。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">T</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  在这个例子中，类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示类的类型参数。泛型方法<code class="language-plaintext highlighter-rouge">printValue</code>中也有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示方法级别的类型参数。这两个<code class="language-plaintext highlighter-rouge">T</code>是不同的，在方法中使用的<code class="language-plaintext highlighter-rouge">T</code>只在方法范围内有效，不会与类的泛型类型参数产生冲突。</p>

<p>  但这样写会在泛型方法中隐藏类的同名泛型类型参数，在泛型方法中就<strong>用不了</strong>类的同名泛型类型参数了，因为它已经被方法中定义的泛型类型参数隐藏了，而并不存在一个<code class="language-plaintext highlighter-rouge">this.</code>来调用泛型类的泛型类型参数。</p>

<p>  因此<strong>不建议这么做</strong>，因为这样也很容易让人误解。<strong>更不建议将</strong><code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">Stirng</code>之类的，别人看了会打人，而且同样会隐藏<code class="language-plaintext highlighter-rouge">Stirng</code>，从而导致你要通过<code class="language-plaintext highlighter-rouge">java.lang.String</code>使用<code class="language-plaintext highlighter-rouge">String</code>。</p>

<h3 id="静态泛型方法">静态泛型方法</h3>

<p>  编写泛型类时，要特别注意，<strong>泛型类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。</strong><br />
  因为泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。<br />
  在静态方法中，同样可以变成泛型方法，使用泛型类型参数，就是之前泛型方法的写法加个<code class="language-plaintext highlighter-rouge">static</code>，语法一模一样。<br />
  例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myStaticMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Static method: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">myStaticMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  在这个例子中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是在静态泛型方法<code class="language-plaintext highlighter-rouge">myStaticMethod</code>的返回类型<code class="language-plaintext highlighter-rouge">void</code>之前声明的，用于定义该方法的泛型类型参数。在调用静态方法时，需要使用<strong><code class="language-plaintext highlighter-rouge">MyClass.&lt;String&gt;</code></strong>来指定类型参数。</p>
<ul>
  <li>泛型类的泛型类型参数是在实例化对象时确定的，而静态方法是在类加载时就可以直接调用的，无需创建对象实例。所以静态方法中的返回值、参数等不能使用泛型类的泛型类型参数。因此静态方法如果需要使用泛型，必须定义自己的泛型类型参数。</li>
  <li><strong>必须</strong>将静态方法的泛型类型参数和泛型类的泛型类型参数<strong>区分开</strong>。<strong>其实相同也没关系</strong>，就是容易让人误解，也不存在覆盖泛型类类型参数的问题，因为本来静态方法就不能用类的非静态的东西，但在静态泛型方法内还是存在同名隐藏问题，比如之前说的将<code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">String</code>。</li>
</ul>

<h2 id="多个泛型类型">多个泛型类型</h2>

<p>  泛型还可以定义多种类型。例如，我们希望<code class="language-plaintext highlighter-rouge">Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">K</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">K</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  使用的时候，需要指出两种类型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"test"</span><span class="o">,</span> <span class="mi">123</span><span class="o">);</span>
</code></pre></div></div>
<p>  Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对<code class="language-plaintext highlighter-rouge">Key</code>使用一种类型，对<code class="language-plaintext highlighter-rouge">Value</code>使用另一种类型。</p>

<h2 id="擦拭法">擦拭法</h2>

<p>  所谓擦拭法是指，<strong>虚拟机</strong>对泛型其实一无所知，所有的工作都是<strong>编译器</strong>做的。因此<strong>编译器</strong>把类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>视为<code class="language-plaintext highlighter-rouge">Object</code>；<strong>编译器</strong>根据<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>实现<strong>安全的强制转型</strong>。<br />
  例如，我们编写了一个泛型类<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>，这是<strong>编译器</strong>看到的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  而<strong>虚拟机</strong>根本不知道泛型。这是虚拟机执行的代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Object</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  使用泛型的时候，我们编写的代码也是如此，<strong>编译器</strong>看到的代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div>
<p>  而<strong>虚拟机</strong>执行的代码并没有泛型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div>
<p>  Java的泛型是由<strong>编译器</strong>在<strong>编译时</strong>实行的，<strong>编译器</strong>内部<strong>永远</strong>把所有类型<code class="language-plaintext highlighter-rouge">T</code>视为<code class="language-plaintext highlighter-rouge">Object</code>处理，但是，在需要<strong>转型</strong>的时候，<strong>编译器</strong>会根据<code class="language-plaintext highlighter-rouge">T</code>的类型<strong>自动</strong>为我们实行安全地强制转型。<br />
  <strong>局限一</strong>：<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能是基本类型，例如<code class="language-plaintext highlighter-rouge">int</code>，因为实际类型是<code class="language-plaintext highlighter-rouge">Object</code>，<code class="language-plaintext highlighter-rouge">Object</code>类型无法持有基本类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="c1">// compile error!</span>
</code></pre></div></div>
<p>  <strong>局限二</strong>：无法取得带泛型的<code class="language-plaintext highlighter-rouge">Class</code>。观察以下代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Class</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  因为<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Object</code>，我们对<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;</code>和<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型获取<code class="language-plaintext highlighter-rouge">Class</code>时，获取到的是同一个<code class="language-plaintext highlighter-rouge">Class</code>，也就是<code class="language-plaintext highlighter-rouge">Pair</code>类的<code class="language-plaintext highlighter-rouge">Class</code>。<br />
  换句话说，所有泛型实例，<strong>无论</strong><code class="language-plaintext highlighter-rouge">T</code>的类型是什么，<code class="language-plaintext highlighter-rouge">getClass()</code>都返回<strong>同一个</strong><code class="language-plaintext highlighter-rouge">Class</code>实例，因为编译后它们全部都是<code class="language-plaintext highlighter-rouge">Pair</code>类，使用<code class="language-plaintext highlighter-rouge">Object</code>替换<code class="language-plaintext highlighter-rouge">T</code>。<br />
  <strong>局限三</strong>：无法判断带泛型的类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
<span class="c1">// Compile error：</span>
<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="o">{}</span>
</code></pre></div></div>
<p>  原因和前面一样，并不存在<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>，而是只有唯一的<code class="language-plaintext highlighter-rouge">Pair.class</code>。<br />
  <strong>局限四</strong>：不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Compile error：</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  上述代码无法通过编译，因为构造方法的两行语句：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
</code></pre></div></div>
<p>  <strong>擦拭后</strong>实际上变成了：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div>
<p>  这样一来，创建<code class="language-plaintext highlighter-rouge">new Pair&lt;String&gt;()</code>和创建<code class="language-plaintext highlighter-rouge">new Pair&lt;Integer&gt;()</code>，内部的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>全部成了<code class="language-plaintext highlighter-rouge">Object</code>类型，显然编译器要阻止这种类型不对的代码，为了<strong>防止</strong>可能的错误出现<strong>编译器</strong>直接<strong>一刀切</strong>这个操作。</p>

<p>  而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了一个抽象类：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>  上面的<code class="language-plaintext highlighter-rouge">Number</code>是不能直接实例化的，所以编译器要阻止这种行为。</p>

<p>  顺便提一下，如果改成了利用反射实例化：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  借助<code class="language-plaintext highlighter-rouge">class.newInstance()</code>创建实例时编译器要求强制处理可能出现的异常，相当于做了兼容。直接<code class="language-plaintext highlighter-rouge">new</code>的话如果泛型类型为抽象类，则会出错。<br />
  上述代码借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>参数并通过反射来实例化<code class="language-plaintext highlighter-rouge">T</code>类型，使用的时候，也必须传入<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>。例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="不恰当的覆写方法">不恰当的覆写方法</h3>
<p>  有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  在 Java 中，泛型类型在编译时会被擦除，<strong>编译器</strong>会把泛型类型的信息擦除掉，将其替换为其上限类型（如果有指定上限类型的话），或者替换为 <code class="language-plaintext highlighter-rouge">Object</code> 类型。这是为了与 Java 的运行时类型擦除机制相适配 <br />
  定义的<code class="language-plaintext highlighter-rouge">equals(T t)</code>方法实际上会被擦拭成<code class="language-plaintext highlighter-rouge">equals(Object t)</code>，而这个方法是继承自<code class="language-plaintext highlighter-rouge">Object</code>的，而<strong>编译器</strong>会阻止一个实际上会变成覆写的泛型方法定义。<br />
  因为仅仅通过泛型代码的定义，<strong>编译器</strong>是<strong>无法确定</strong>泛型<strong>是否覆写</strong>了此方法。</p>

<p>  在泛型类型擦除后，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code>与 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法的签名相同。因此，从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法。<br />
  但是，由于 Java 泛型的设计，<strong>编译器</strong>会在编译时对泛型类型进行额外的类型检查，以确保类型安全。在这种情况下，<strong>编译器</strong>会注意到 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法<strong>使用了泛型类型</strong> <code class="language-plaintext highlighter-rouge">T</code>，而 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法使用了原始的 <code class="language-plaintext highlighter-rouge">Object</code> 类型，在编译时这会被认为是<strong>不同</strong>的方法。<br />
  因此，编译器会认为 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法<strong>不是重写</strong>，而是一个<strong>新定义的方法</strong>。<br />
  这也是为了确保子类重写父类方法时不会改变方法的行为，避免在子类中意外修改了父类的行为。</p>

<p>  综上所述，虽然从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法，但在编译器的类型检查中，它们会被认为是<strong>不同</strong>的方法，因为泛型类型 <code class="language-plaintext highlighter-rouge">T</code> 在编译时会被认为是不同的参数类型。</p>

<hr />

<p>  虽然擦除后不是覆写，但编译器装作有泛型的行为，导致在调用<code class="language-plaintext highlighter-rouge">test()</code>时编译器不知道调用哪个<code class="language-plaintext highlighter-rouge">test()</code>，非预期效果，编译器报错：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Test</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">t1</span><span class="o">=</span><span class="k">new</span> <span class="nc">Test</span><span class="o">&lt;&gt;();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"test"</span><span class="o">)){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="c1">//        t1.test((Number)124);//错误:java: 对test的引用不明确com.aotmd.SuperTest 中的方法 test(java.lang.Number) 和 com.aotmd.Test 中的方法 test(T) 都匹配</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SuperTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">test</span><span class="o">((</span><span class="nc">Number</span><span class="o">)</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SuperTest</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">Number</span> <span class="n">o</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  结果：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class com.aotmd.Test
public void com.aotmd.Test.test(java.lang.Object)
public void com.aotmd.SuperTest.test(java.lang.Number)
</code></pre></div></div>

<h3 id="泛型继承">泛型继承</h3>
<p>  一个类可以继承自一个泛型类。例如：父类是<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>，子类是<code class="language-plaintext highlighter-rouge">IntPair</code>，可以这么继承：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>
<p>  使用的时候，因为子类<code class="language-plaintext highlighter-rouge">IntPair</code>并没有泛型，所以正常使用即可：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntPair</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntPair</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div>
<p>  前面讲了，我们无法获取<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的<code class="language-plaintext highlighter-rouge">T</code>类型，即给定一个变量<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt; p</code>，也无法从<code class="language-plaintext highlighter-rouge">p</code>中获取到<code class="language-plaintext highlighter-rouge">Integer</code>类型。<br />
  但是，在父类是泛型类型的情况下，编译器就必须把类型<code class="language-plaintext highlighter-rouge">T</code>（对<code class="language-plaintext highlighter-rouge">IntPair</code>来说，也就是<code class="language-plaintext highlighter-rouge">Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code class="language-plaintext highlighter-rouge">IntPair</code>只能存取<code class="language-plaintext highlighter-rouge">Integer</code>这种类型。<br />
  在继承了泛型类型的情况下，子类<strong>可以</strong>获取父类的泛型类型。例如：<code class="language-plaintext highlighter-rouge">IntPair</code>可以获取到父类的泛型类型<code class="language-plaintext highlighter-rouge">Integer</code>。获取父类的泛型类型代码比较复杂：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.ParameterizedType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">IntPair</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">IntPair</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="nc">Type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getGenericSuperclass</span><span class="o">();</span><span class="c1">//获取泛型父类的class</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="nc">ParameterizedType</span><span class="o">)</span> <span class="o">{</span><span class="c1">//判断是否为ParameterizedType，如果是，则表示泛型父类有实际类型参数。</span>
            <span class="nc">ParameterizedType</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ParameterizedType</span><span class="o">)</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">Type</span><span class="o">[]</span> <span class="n">types</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">();</span> <span class="c1">// 获取实际类型参数的数组，本例中数组长度为1。</span>
            <span class="nc">Type</span> <span class="n">firstType</span> <span class="o">=</span> <span class="n">types</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 获取第一个实际类型参数</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">firstType</span><span class="o">);</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">typeClass</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">firstType</span><span class="o">;</span><span class="c1">//将其转换为 Class 对象，若还是泛型K则转换失败。</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">typeClass</span><span class="o">);</span> <span class="c1">// Integer</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  修改<code class="language-plaintext highlighter-rouge">IntPair</code>，然后重新运行，类型转换会出错:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">IntPair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="no">K</span> <span class="n">o1</span><span class="o">,</span><span class="no">K</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span><span class="n">o2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  因为Java引入了泛型，所以，只用<code class="language-plaintext highlighter-rouge">Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p>
<pre><code class="language-ascii">                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
</code></pre>
<h3 id="小结">小结</h3>

<p>  Java的泛型是采用擦拭法实现的；<br />
  擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p>
<ul>
  <li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li>
  <li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li>
  <li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li>
  <li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li>
</ul>

<p>  泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>；<br />
  子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p>

<h2 id="extends通配符在形式参数的作用">extends通配符在形式参数的作用</h2>
<p>  之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，他们之前没有什么关系。<br />
  假设我们定义了<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  然后对<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  上述代码是可以正常编译的。使用的时候，我们传入：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div>
<p>  注意：传入的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，实际参数类型是<code class="language-plaintext highlighter-rouge">(Integer, Integer)</code>。<br />
  既然实际参数是<code class="language-plaintext highlighter-rouge">Integer</code>类型，试试传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div>
<p>  直接运行，会得到一个编译错误：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: Pair&lt;Integer&gt;无法转换为Pair&lt;Number&gt;
</code></pre></div></div>
<p>  原因很明显，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，它们之间没什么关系，因此，<code class="language-plaintext highlighter-rouge">add(Pair&lt;Number&gt; p)</code>方法，不接受参数类型<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>。<br />
  方法里的代码逻辑是没有问题，<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">Integer</code>的父类。问题在于方法参数类型定死了只能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>。</p>

<hr />

<p>  有没有办法使得方法参数接受<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>使得方法能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。我们把代码改写如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  这样一来，给方法传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型时，它符合参数<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型。这种使用<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code class="language-plaintext highlighter-rouge">T</code>的上界限定在<code class="language-plaintext highlighter-rouge">Number</code>了。<br />
  这样写除了可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型，还可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型，<code class="language-plaintext highlighter-rouge">Pair&lt;BigDecimal&gt;</code>类型等等，因为<code class="language-plaintext highlighter-rouge">Double</code>和<code class="language-plaintext highlighter-rouge">BigDecimal</code>都是<code class="language-plaintext highlighter-rouge">Number</code>的子类。<br />
  对<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型调用<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，实际的方法签名变成了：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>  即返回值是<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>的子类，因为 <code class="language-plaintext highlighter-rouge">Number</code> 是 <code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code> 的上界，所以返回值可以安全地赋值给 <code class="language-plaintext highlighter-rouge">Number</code> 类型的变量 <code class="language-plaintext highlighter-rouge">first</code>(向上提升)：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>  不能赋值给<code class="language-plaintext highlighter-rouge">Integer</code>，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物，也即可能的向下转型是不安全的：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span><span class="c1">//错误</span>
</code></pre></div></div>
<p>  这是因为实际的返回类型可能是<code class="language-plaintext highlighter-rouge">Integer</code>，也可能是<code class="language-plaintext highlighter-rouge">Double</code>或者其他类型，编译器只能确定类型一定是<code class="language-plaintext highlighter-rouge">Number</code>的子类（包括<code class="language-plaintext highlighter-rouge">Number</code>类型本身），但具体类型无法确定。</p>

<hr />

<p>  尝试写操作：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: java.lang.Integer无法转换为capture#1, 共 ? extends java.lang.Number
</code></pre></div></div>
<p>  编译错误发生在<code class="language-plaintext highlighter-rouge">p.setFirst()</code>，我们对<code class="language-plaintext highlighter-rouge">add(Pair&lt;? extends Number&gt; p)</code>传入了<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，对于<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>为什么不能传入<code class="language-plaintext highlighter-rouge">Integer</code>呢？<br />
  因为我们还能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，而传入<code class="language-plaintext highlighter-rouge">setFirst</code>的代码类型并不会变成<code class="language-plaintext highlighter-rouge">Double</code>类型，代码是固定的，形式参数类型为<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>当然是无法接受<code class="language-plaintext highlighter-rouge">Integer</code>类型的。<br />
  为了避免产生安全问题，编译器一刀切，直接<strong>不接受任何写行为</strong>。<br />
  唯一的例外是可以给方法参数传入<code class="language-plaintext highlighter-rouge">null</code>，因为泛型只接受引用类型，也即对象，因为擦除法都擦成<code class="language-plaintext highlighter-rouge">Object</code>了，而所有的对象都可以赋值<code class="language-plaintext highlighter-rouge">null</code>，所以这是安全的行为。</p>

<p>  总的来说，调用：<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读，则需要用上界接收。写则因为可能向下转型的原因被切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。</p>

<h3 id="extends通配符形式参数实例">extends通配符形式参数实例</h3>

<p>  Java标准库的<code class="language-plaintext highlighter-rouge">java.util.List&lt;T&gt;</code>接口实现的是一个类似“可变数组”的列表，主要功能包括：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span> <span class="c1">// 获取个数</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span> <span class="c1">// 根据索引获取指定元素</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 添加一个新元素</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 删除一个已有元素</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  定义一个方法来处理列表的每个元素：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sumOfList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  使用<code class="language-plaintext highlighter-rouge">? extends Integer</code>限制了只读，只能调用<code class="language-plaintext highlighter-rouge">size()</code>，<code class="language-plaintext highlighter-rouge">get()</code>，不能调用<code class="language-plaintext highlighter-rouge">add()</code>，<code class="language-plaintext highlighter-rouge">remove()</code>。</p>

<h3 id="使用extends在类限定t类型">使用extends在类限定T类型</h3>
<p>  在定义<strong>泛型类型</strong><code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的时候，也可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div>
<p>  现在，我们只能定义：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">p3</span><span class="o">;</span>
</code></pre></div></div>
<p>  因为<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">Integer</code>和<code class="language-plaintext highlighter-rouge">Double</code>都符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>。<br />
  非<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类类型将无法通过编译：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span> <span class="c1">// compile error!</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span> <span class="c1">// compile error!</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Object</code>都不符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>，它们不是<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p>

<h3 id="小结-1">小结</h3>

<p>  <font color="red"><b>使用类似`&lt;? extends Number&gt;`通配符参与方法的形式参数时表示：</b></font></p>
<ul>
  <li><strong>调用：<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读，则必须至少用上界<code class="language-plaintext highlighter-rouge">Number</code>接收，也可以用<code class="language-plaintext highlighter-rouge">Number</code>的父类接收，比如<code class="language-plaintext highlighter-rouge">Object</code>，避免可能的向下转型。</strong></li>
  <li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? extends Number&gt; o)</code>写则，因为可能向下转型的原因被一刀切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。(如果有下界倒是可以赋值下界或下界的子类，避免向下转型了)</strong></li>
  <li><strong>方法被修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的泛型类型。</strong></li>
</ul>

<p>  <font color="red"><b>`&lt;? extends 上界&gt;`：传参类型&lt;=上界，只能写`null`，读&gt;=上界。</b></font></p>

<p>  其实<strong>不在方法参数</strong>也能用<code class="language-plaintext highlighter-rouge">&lt;? extends 上界&gt;</code>，效果是相同的。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  使用类似<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示：</p>
<ul>
  <li><strong>泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</strong></li>
</ul>

<h2 id="super通配符在形式参数的作用">super通配符在形式参数的作用</h2>
<p>  之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，他们之前没有什么关系。<br />
  考察下面的<code class="language-plaintext highlighter-rouge">set</code>方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是允许的，而传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>是不允许的。<br />
  和<code class="language-plaintext highlighter-rouge">extends</code>通配符相反，这次，我们希望接受泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。还是向上提升的问题，父类可以指向子类，所以写操作是安全的。同样的，向下转型不安全，因此禁止读取。</p>

<p>  使用<code class="language-plaintext highlighter-rouge">super</code>通配符来改写这个方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。<br />
  下面的代码可以被正常编译：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mf">12.3</span><span class="o">,</span> <span class="mf">4.56</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p2</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setSame</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>方法签名实际上是：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">);</span>
</code></pre></div></div>
<p>  因此，可以安全地传入<code class="language-plaintext highlighter-rouge">Integer</code>类型。如果你传<code class="language-plaintext highlighter-rouge">Number</code>类型，不好意思，因为泛型有可能是<code class="language-plaintext highlighter-rouge">Integer</code>所以不可以，即：有可能造成<code class="language-plaintext highlighter-rouge">Number</code>转<code class="language-plaintext highlighter-rouge">Integer</code>了，即向下转型。所以你想写入，则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入，也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能的向下转型。<br />
  而<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，它的方法签名实际上是：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span> <span class="kd">super</span> <span class="nc">Integer</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>  无法使用<code class="language-plaintext highlighter-rouge">Integer</code>类型来接收<code class="language-plaintext highlighter-rouge">getFirst()</code>的返回值，还是老样子，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物，也即可能的向下转型是不安全的：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>  因为如果传入的实际类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，在上面的代码中编译器无法将<code class="language-plaintext highlighter-rouge">Number</code>类型转型为<code class="language-plaintext highlighter-rouge">Integer</code>，即向下转型。<br />
  唯一可以接收<code class="language-plaintext highlighter-rouge">getFirst()</code>方法返回值的是<code class="language-plaintext highlighter-rouge">Object</code>类型，因为它是所有类的父类，它能包容一切，除它自己外，所有对它的赋值都是向上提升，因此是安全的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>  <font color="red"><b>使用类似`&lt;? super Integer&gt;`通配符参与方法的形式参数时表示：</b></font></p>
<ul>
  <li><strong>调用：<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt; getFirst();</code>读，因为没有限定上界，那只能用<code class="language-plaintext highlighter-rouge">Object</code>接收，避免可能的向下转型。</strong></li>
  <li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? super Integer&gt; o)</code>写则，则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入，也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能向下转型。</strong></li>
  <li><strong>方法修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的泛型类型。</strong></li>
</ul>

<p>  <font color="red"><b>`&lt;? super 下界&gt;`：传参类型&gt;=下界，写&lt;=下界，读只能`Object`。</b></font></p>

<p>  其实不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? super 下界&gt;</code>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="对比extends和super通配符在形式参数的作用">对比extends和super通配符在形式参数的作用</h3>
<p>  对比<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>，作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
  <li>
    <font color="red"><b>`&lt;? extends T&gt;`：传参类型&lt;=`T`，只能写`null`，读&gt;=`T`。</b></font>
  </li>
  <li>
    <font color="red"><b>`&lt;? super T&gt;`：  传参类型&gt;=`T`，写&lt;=`T`，读只能`Object`。</b></font>
  </li>
</ul>

<p>  一个是允许读不允许写，另一个是允许写不允许读。<br />
  Java标准库的<code class="language-plaintext highlighter-rouge">Collections</code>类定义的<code class="language-plaintext highlighter-rouge">copy()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="c1">// 把src的每个元素复制到dest中：</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  它的作用是把一个<code class="language-plaintext highlighter-rouge">List</code>的每个元素依次添加到另一个<code class="language-plaintext highlighter-rouge">List</code>中。它的第一个参数是<code class="language-plaintext highlighter-rouge">List&lt;? super T&gt;</code>，表示目标<code class="language-plaintext highlighter-rouge">List</code>，第二个参数<code class="language-plaintext highlighter-rouge">List&lt;? extends T&gt;</code>，表示要复制的<code class="language-plaintext highlighter-rouge">List</code>。我们可以简单地用<code class="language-plaintext highlighter-rouge">for</code>循环实现复制。在<code class="language-plaintext highlighter-rouge">for</code>循环中，对于类型<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">src</code>可以安全的读，而对于类型<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">dest</code>可以安全的写。<br />
  这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的定义就完美地展示了<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>的意图：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部不会读取<code class="language-plaintext highlighter-rouge">dest</code>，因为不能调用<code class="language-plaintext highlighter-rouge">dest.get()</code>来获取<code class="language-plaintext highlighter-rouge">T</code>的引用；</li>
  <li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部也不会修改<code class="language-plaintext highlighter-rouge">src</code>，因为不能调用<code class="language-plaintext highlighter-rouge">src.add(T)</code>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok：</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">numList</span><span class="o">,</span> <span class="n">intList</span><span class="o">);</span>
</code></pre></div></div>
<p>  这两个 <code class="language-plaintext highlighter-rouge">T</code> 是<strong>同一个类型</strong>。在方法签名中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> 定义了方法级别的泛型类型参数，表示 <code class="language-plaintext highlighter-rouge">copy</code> 方法是一个泛型方法，它接受一个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的参数。类型参数的推断是基于传入参数的类型来确定的，编译器会尝试推断出最具体的类型，然后将其用作所有相关类型参数的类型。如果无法推断出一个具体的类型，编译器将无法确定如何匹配类型参数，从而导致编译错误。</p>

<p>  使用前面的结论：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>：<code class="language-plaintext highlighter-rouge">Integer</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>，只能写<code class="language-plaintext highlighter-rouge">null</code>，读&gt;=<code class="language-plaintext highlighter-rouge">T</code>。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>：  <code class="language-plaintext highlighter-rouge">Number</code>&gt;=<code class="language-plaintext highlighter-rouge">T</code>，写&lt;=<code class="language-plaintext highlighter-rouge">T</code>，读只能<code class="language-plaintext highlighter-rouge">Object</code>。</strong></li>
</ul>

<p>  可以得出：<code class="language-plaintext highlighter-rouge">Integer</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>&lt;=<code class="language-plaintext highlighter-rouge">Number</code>。<br />
  在在这次调用中<code class="language-plaintext highlighter-rouge">T</code>的类型确定需要满足两个条件，即：</p>

<ul>
  <li>因为<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>，所以<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">T</code>或<code class="language-plaintext highlighter-rouge">T</code>的父类，也就是说<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Number</code>或其子类</li>
  <li>因为<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>，所以<code class="language-plaintext highlighter-rouge">Integer</code>是<code class="language-plaintext highlighter-rouge">T</code>或<code class="language-plaintext highlighter-rouge">T</code>的子类，也就是说<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Integer</code>或其父类</li>
</ul>

<p>  因此，<code class="language-plaintext highlighter-rouge">T</code> 可以被推断为 <code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Integer</code>，从而实现了将 <code class="language-plaintext highlighter-rouge">Integer</code> 类型的列表复制到 <code class="language-plaintext highlighter-rouge">Number</code> 类型的列表的操作。这种根据实际类型推断泛型类型参数的过程称为类型推断。</p>

<p>  这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的另一个好处是可以安全地把一个<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>添加到<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>，但是无法反过来添加：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">intList</span><span class="o">,</span> <span class="n">numList</span><span class="o">);</span>
</code></pre></div></div>
<p>  因为不存在<code class="language-plaintext highlighter-rouge">Number</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>&lt;=<code class="language-plaintext highlighter-rouge">Integer</code>这样的类型。</p>

<p>  而这些都是通过<code class="language-plaintext highlighter-rouge">super</code>和<code class="language-plaintext highlighter-rouge">extends</code>通配符，并由编译器强制检查来实现的。</p>

<h3 id="使用super在类限定t类型">使用super在类限定T类型</h3>

<p>  前面说了可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div>
<p>  将T限制为<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。<br />
  那么有没有<code class="language-plaintext highlighter-rouge">super</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型呢?我想到这样的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">super</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div>
<p>  将T限制为<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的父类。<br />
  <strong>不，java中没有实现在类中对下界进行限定</strong>。</p>

<h3 id="无限定通配符">无限定通配符</h3>

<p>  Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code class="language-plaintext highlighter-rouge">?</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sample</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>
<p>  因为<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符既没有<code class="language-plaintext highlighter-rouge">extends</code>，也没有<code class="language-plaintext highlighter-rouge">super</code>，因此：</p>
<ul>
  <li>不允许调用<code class="language-plaintext highlighter-rouge">set(T)</code>方法并传入引用（<code class="language-plaintext highlighter-rouge">null</code>除外）；</li>
  <li>不允许调用<code class="language-plaintext highlighter-rouge">T get()</code>方法并获取<code class="language-plaintext highlighter-rouge">T</code>引用（只能获取<code class="language-plaintext highlighter-rouge">Object</code>引用）。</li>
</ul>

<p>  也就是说：<font color="red"><b>`&lt;?&gt;`传参类型随便，只能写`null`(因为无上界)，读只能`Object`(因为无下界)。</b></font></p>

<p>  换句话说，既不能读，也不能写，那只能做一些<code class="language-plaintext highlighter-rouge">null</code>判断：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符有一个独特的特点，就是：<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>是所有<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的超类(抢了OBject的工作)：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// 安全地向上转型</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  上述代码是可以正常编译运行的，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>的子类，可以安全地向上转型。<br />
  <strong>实际上<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</strong><br />
  那么有没有一个等同于<code class="language-plaintext highlighter-rouge">&lt;? super 最下子类</code>&gt;答案是没有的，因为这个最下子类并不是一个具体的东西，如果有，那么他也可以匹配任何类型，只能写null和最下子类，只能用Object读。功能基本和<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>重复了</p>

<h1 id="总结">总结</h1>

<h2 id="说明">说明</h2>

<p>  泛型的继承关系<strong>可以</strong>把类向上转型，而泛型参数<strong>不能产生变化</strong>。<br />
  如果实例化时<strong>不定义泛型类型参数</strong>时，那么默认会使用<code class="language-plaintext highlighter-rouge">Object</code>作为泛型类型参数。<br />
  编译器如果能自动推断出泛型类型，可以省略定义后面的泛型类型。</p>

<h2 id="定义">定义</h2>

<p>  定义泛型类时，在类名后面定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，定义泛型方法时，在<strong>返回类型前面</strong>定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。<br />
  泛型类定义的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><strong>只能用于整个类的实例</strong>，而不能用于类的静态成员（静态字段、静态方法、静态内部类）。<br />
  泛型方法定义的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><strong>只适用于该方法</strong>，在泛型类中的方法仍然可以设置为泛型方法，也可以使用泛型类的标识符。<br />
  如果泛型类是<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，泛型方法也是<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，这两个<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是不同的，在泛型方法中会隐藏泛型类的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。<strong>不建议这么做</strong>，因为这样也很容易让人误解。<strong>更不建议将</strong><code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">Stirng</code>之类的，别人看了会打人，而且同样会隐藏<code class="language-plaintext highlighter-rouge">Stirng</code>，从而导致你要通过<code class="language-plaintext highlighter-rouge">java.lang.String</code>使用<code class="language-plaintext highlighter-rouge">String</code>。    <br />
  泛型类的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。静态方法同样可以变成泛型方法，使用同样的方法，在<strong>返回类型前面</strong>定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。<br />
  泛型还可以定义多种类型。如类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>，Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。</p>

<h2 id="擦拭法-1">擦拭法</h2>

<p>  擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p>
<ul>
  <li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li>
  <li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li>
  <li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li>
  <li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li>
</ul>

<p>  泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>。<br />
  一个类可以继承自一个泛型类，子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p>

<h2 id="extendssuper">extends、super、？</h2>

<p>  作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>的区别在于：</p>
<ul>
  <li>
    <font color="red"><b>`&lt;? extends T&gt;`：传参类型&lt;=`T`，只能写`null`，读&gt;=`T`。</b></font>
  </li>
  <li>
    <font color="red"><b>`&lt;? super T&gt;`：  传参类型&gt;=`T`，写&lt;=`T`，读只能`Object`。</b></font>
  </li>
  <li>
    <font color="red"><b>`&lt;?&gt;`传参类型随便，只能写`null`(因为无上界)，读只能`Object`(因为无下界)。</b></font>
  </li>
</ul>

<p>  <code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。<br />
  大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符。<br />
  <strong>不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>。</strong><br />
  用<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示<strong>使用时泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</strong><br />
  其实就是因为java<strong>向上提升安全，而向下转型不安全</strong></p>

<h1 id="泛型和反射">泛型和反射</h1>

<p>  Java的部分反射API也是泛型。例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>就是泛型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile warning:</span>
<span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// no warning:</span>
<span class="nc">Class</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</code></pre></div></div>
<p>  调用<code class="language-plaintext highlighter-rouge">Class</code>的<code class="language-plaintext highlighter-rouge">getSuperclass()</code>方法返回的<code class="language-plaintext highlighter-rouge">Class</code>类型是<code class="language-plaintext highlighter-rouge">Class&lt;? super T&gt;</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">sup</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
</code></pre></div></div>
<p>  构造方法<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>也是泛型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="泛型数组">泛型数组</h3>
<p>  我们可以声明带泛型的数组，但不能用<code class="language-plaintext highlighter-rouge">new</code>操作符创建带泛型的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ok</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// compile error!</span>
</code></pre></div></div>
<p>  必须通过强制转型实现带泛型的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div>
<p>  使用泛型数组要特别小心，因为数组实际上在运行期<strong>没有</strong>泛型，编译器可以强制检查变量<code class="language-plaintext highlighter-rouge">ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code class="language-plaintext highlighter-rouge">arr</code>，因为它<strong>不是</strong>泛型数组。因为这两个变量实际上指向<strong>同一个</strong>数组，所以，操作<code class="language-plaintext highlighter-rouge">arr</code>可能导致从<code class="language-plaintext highlighter-rouge">ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span><span class="c1">//指向了不是String的内容</span>
<span class="c1">// ClassCastException:</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span><span class="c1">//类型转换错误</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>  要安全地使用泛型数组，必须扔掉<code class="language-plaintext highlighter-rouge">arr</code>的引用：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div>
<p>  上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code class="language-plaintext highlighter-rouge">ps</code>进行操作，这种操作就是安全的。<br />
  带泛型的数组实际上是编译器的类型擦除：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</code></pre></div></div>
<p>  所以我们<strong>不能</strong>直接创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>，因为擦拭后代码变为<code class="language-plaintext highlighter-rouge">Object[]</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile error:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  显然编译器要阻止这种类型不对的代码，为了防止可能的错误出现编译器直接一刀切这个操作。<br />
  而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了抽象类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[]</span> <span class="n">pair</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Abc</span><span class="o">().</span><span class="na">createArray</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  上面的<code class="language-plaintext highlighter-rouge">Number</code>是不能直接实例化的，所以编译器要阻止这种行为。</p>

<p>  <strong>必须</strong>借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>来创建泛型数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">().</span><span class="na">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">first</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  泛型方法写法，<code class="language-plaintext highlighter-rouge">&lt;Pair&gt;</code>可省略：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">().&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span><span class="n">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">K</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  静态泛型方法写法，<code class="language-plaintext highlighter-rouge">&lt;Pair&gt;</code>可省略：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="nc">Pair</span><span class="o">.&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span><span class="n">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">K</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数</h3>

<p>  还可以利用<strong>可变参数</strong>创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayHelper</span> <span class="o">{</span>
    <span class="nd">@SafeVarargs</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>
<p>  在上面的例子中，我们看到，通过：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  <strong>似乎</strong>可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  直接调用<code class="language-plaintext highlighter-rouge">asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code class="language-plaintext highlighter-rouge">ClassCastException</code>，原因还是因为擦拭法，在<code class="language-plaintext highlighter-rouge">pickTwo()</code>方法内部，编译器无法检测<code class="language-plaintext highlighter-rouge">K[]</code>的正确类型，因此返回了<code class="language-plaintext highlighter-rouge">Object[]</code>。<br />
  如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code class="language-plaintext highlighter-rouge">@SafeVarargs</code>消除警告。<br />
  如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。<br />
  更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p>

<p>  泛型是通过类型擦除来实现的，而可变参数<strong>只是</strong>一个传递数组变量的语法糖，本质上还是<strong>创建</strong>一个数组然后传入。<br />
  所以泛型可变参数实际上就是 <code class="language-plaintext highlighter-rouge">Object</code> 数组，这样代码就可以等价为：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span> <span class="n">asArray</span><span class="o">(</span><span class="n">ss</span><span class="o">);</span> <span class="c1">// asArray 返回的就是 ss 只不过声明为 Object[]，实际上还是 String[],子类赋值给父类,然后转回子类</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span> <span class="c1">// pickTwo 返回的是一个新创建的 Object[]，只不过里面的元素实际上是字符串</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">k1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k2</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">};</span><span class="c1">//语法糖</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">objs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * asArray 本质上没有做任何处理，只是把传入的数据返回了而已。
     */</span>
    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>  以下是用jad反编译的，jad反编译后的是被擦拭后的，而使用cfr、jdgui反编译都是接近于源码的便于阅读的。(<a href="http://java-decompiler.github.io/">jd-gui工具</a>，<a href="https://github.com/iloveeclipse/plugins">Bytecode Outline</a>插件，不但可以看字节码，还可以看如何生成字节码。）<br />
  反编译后的代码中出现的<code class="language-plaintext highlighter-rouge">transient</code>关键字，这是由于反编译工具对代码进行了简化和优化。transient关键字通常用于修饰成员变量，表示这些变量不会被序列化，与我们讨论的问题无关。</p>

<p>  源代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">toS2</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">toS</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    
    <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="c1">// ClassCastException:</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">toS</span><span class="o">(</span><span class="no">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">toS2</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">toS2</span><span class="o">(</span><span class="no">T</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  反编译后：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">toS2</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">toS</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span><span class="n">asArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span>
        <span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span>
    <span class="o">});</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="nc">String</span> <span class="n">firstTwo</span><span class="o">[]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span><span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">k1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k2</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k3</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[]</span> <span class="o">{</span>
        <span class="n">k1</span><span class="o">,</span> <span class="n">k2</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">transient</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="nc">Object</span> <span class="n">objs</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">toS</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">toS2</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">toS2</span><span class="o">(</span><span class="nc">Object</span> <span class="n">objs</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>  <strong>可变参数的方法，实际接收的是一个数组</strong>，所以调用可变参数的方法时，会把参数封装成一个数组。如果在泛型方法里，调用泛型可变参数的方法，那么入参会被擦拭成<code class="language-plaintext highlighter-rouge">Object</code>数组。<br />
  报错解释：<code class="language-plaintext highlighter-rouge">main</code>直接调用<code class="language-plaintext highlighter-rouge">asArray</code>时，编译器知道<code class="language-plaintext highlighter-rouge">asArray</code>的入参是<code class="language-plaintext highlighter-rouge">String</code>，但是在调用<code class="language-plaintext highlighter-rouge">pickTwo</code>中编译器不知道<code class="language-plaintext highlighter-rouge">K</code>的类型将会是什么，所以调用<code class="language-plaintext highlighter-rouge">asArray</code>时入参封装（擦拭）成了<code class="language-plaintext highlighter-rouge">Object[]</code>，main中得到返回值强转为<code class="language-plaintext highlighter-rouge">String[]</code>时，就会报错。而在<code class="language-plaintext highlighter-rouge">toS</code>、<code class="language-plaintext highlighter-rouge">toS2</code>中尽管也会被擦拭成<code class="language-plaintext highlighter-rouge">Object</code>，但只是用<code class="language-plaintext highlighter-rouge">Object</code>持有对象引用，对象类型并没有改变，所以在<code class="language-plaintext highlighter-rouge">main</code>中强转时不会报错。</p>

<p>  可变参数改成反射则没有问题：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">K</span><span class="o">[]</span> <span class="n">ks</span><span class="o">=</span><span class="n">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">,</span><span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pickTwo:"</span><span class="o">+</span><span class="n">ks</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ks</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span><span class="no">T</span> <span class="n">t2</span><span class="o">,</span><span class="no">T</span> <span class="n">t3</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"asArray:"</span><span class="o">+</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="no">T</span><span class="o">[]</span> <span class="n">ts</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="mi">3</span><span class="o">);</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">t1</span><span class="o">;</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="n">t2</span><span class="o">;</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="n">t3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ts</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Java反射、注解</title><link href="https://acteds.github.io/2024/03/13/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" rel="alternate" type="text/html" title="Java反射、注解" /><published>2024-03-13T00:00:00+08:00</published><updated>2024-03-13T00:00:00+08:00</updated><id>https://acteds.github.io/2024/03/13/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3</id><content type="html" xml:base="https://acteds.github.io/2024/03/13/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/"><![CDATA[<h1 id="引言">引言</h1>
<p>  java反射和注解的笔记。</p>

<h1 id="反射">反射</h1>
<p>  获取<strong>class</strong>的<strong>Class</strong>实例：<br />
  直接通过<strong>class</strong>的静态变量<strong>class</strong>获取：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</code></pre></div></div>
<p>  通过实例变量提供的<code class="language-plaintext highlighter-rouge">getClass()</code>方法获取：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</code></pre></div></div>
<p>  通过静态方法<code class="language-plaintext highlighter-rouge">Class.forName()</code>获取：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"java.lang.String"</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="class实例基本信息"><strong>Class实例基本信息：</strong></h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>String</td>
      <td>getName()</td>
      <td>返回类的完全限定名。</td>
    </tr>
    <tr>
      <td>String</td>
      <td>getSimpleName()</td>
      <td>返回类的简单名称，不包含包名部分。</td>
    </tr>
    <tr>
      <td>String</td>
      <td>getPackage().getName()</td>
      <td>返回类所在包的名称。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isInterface()</td>
      <td>判断是否为接口。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isEnum()</td>
      <td>判断是否为枚举类型。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isArray()</td>
      <td>判断是否为数组类型。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isPrimitive()</td>
      <td>判断是否为基本数据类型。</td>
    </tr>
    <tr>
      <td>Class</td>
      <td>getSuperclass()</td>
      <td>返回表示该类的父类的 Class 对象。</td>
    </tr>
    <tr>
      <td>int</td>
      <td>getModifiers()</td>
      <td>返回表示类或接口的 Java 语言修饰符的整数。例如，public、static 等修饰符。</td>
    </tr>
    <tr>
      <td>Class[]</td>
      <td>getInterfaces()</td>
      <td>返回一个包含表示<strong>该类</strong>实现的接口的 Class 对象的数组。(接口同理)</td>
    </tr>
    <tr>
      <td>ClassLoader</td>
      <td>getClassLoader()</td>
      <td>返回该类的类加载器。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isAssignableFrom(Class)</td>
      <td>判断当前 <code class="language-plaintext highlighter-rouge">Class</code> 对象所表示的类或接口与指定 <code class="language-plaintext highlighter-rouge">Class</code> 参数表示的类或接口是否相同，或是否是其超类或超接口。</td>
    </tr>
    <tr>
      <td>Class</td>
      <td>getGenericSuperclass()</td>
      <td>获取泛型父类的<code class="language-plaintext highlighter-rouge">class</code>。</td>
    </tr>
  </tbody>
</table>

<h2 id="访问字段的方法"><strong>访问字段的方法</strong></h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Field</td>
      <td>getField(String name)</td>
      <td>根据字段名获取某个public的field（包括父类继承）。</td>
    </tr>
    <tr>
      <td>Field</td>
      <td>getDeclaredField(String name)</td>
      <td>根据字段名获取当前类的某个field（不包括父类继承）。</td>
    </tr>
    <tr>
      <td>Field[]</td>
      <td>getFields()</td>
      <td>获取所有public的field（包括父类继承）。</td>
    </tr>
    <tr>
      <td>Field[]</td>
      <td>getDeclaredFields()</td>
      <td>获取当前类的所有field（不包括父类继承）。</td>
    </tr>
  </tbody>
</table>

<p>  一个<code class="language-plaintext highlighter-rouge">Field</code>对象包含了一个字段的所有信息：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getName()</code>：返回字段名称，例如，<code class="language-plaintext highlighter-rouge">"name"</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getType()</code>：返回字段类型，也是一个<code class="language-plaintext highlighter-rouge">Class</code>实例，例如，<code class="language-plaintext highlighter-rouge">String.class</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回字段的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li>
</ul>

<p>  <strong>Field的方法</strong></p>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>void</td>
      <td>set(Object o,Object v)</td>
      <td>设置指定对象o上此 Field 表示的字段的值为v。</td>
    </tr>
    <tr>
      <td>Object</td>
      <td>get(Object o)</td>
      <td>返回指定对象o上此 Field 表示的字段的值。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>setAccessible(boolean)</td>
      <td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有字段)</td>
    </tr>
  </tbody>
</table>

<p>  通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">get(实例变量)</code>可以得到该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值。<br />
  通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">set(实例变量,新值)</code>可以设置该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值。<br />
  默认是不允许访问<code class="language-plaintext highlighter-rouge">private</code>字段的，可以通过调用<code class="language-plaintext highlighter-rouge">Field</code>的<code class="language-plaintext highlighter-rouge">setAccessible(true)</code>实现访问。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
        <span class="n">f</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span> <span class="c1">// "Xiao Ming"</span>
        <span class="n">f</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">p</span><span class="o">,</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h2 id="访问方法的方法"><strong>访问方法的方法</strong></h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Method</td>
      <td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
      <td>获取某个<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>。（包括父类继承）name：方法名,parameterTypes：形式参数的Class。</td>
    </tr>
    <tr>
      <td>Method</td>
      <td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
      <td>获取当前类的某个<code class="language-plaintext highlighter-rouge">Method</code>。（不包括父类继承）name：方法名,parameterTypes：形式参数的Class。</td>
    </tr>
    <tr>
      <td>Method[]</td>
      <td>getMethods()</td>
      <td>获取所有<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>。（包括父类继承）</td>
    </tr>
    <tr>
      <td>Method[]</td>
      <td>getDeclaredMethods()</td>
      <td>获取当前类的所有<code class="language-plaintext highlighter-rouge">Method</code>。（不包括父类继承）</td>
    </tr>
  </tbody>
</table>

<p>  一个<code class="language-plaintext highlighter-rouge">Method</code>对象包含一个方法的所有信息：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getName()</code>：返回方法名称，例如：<code class="language-plaintext highlighter-rouge">"getScore"</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code class="language-plaintext highlighter-rouge">String.class</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code class="language-plaintext highlighter-rouge">{String.class, int.class}</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回方法的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li>
</ul>

<p>  <strong>Method的方法</strong></p>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>invoke(Object o,Object …arg)</td>
      <td>调用指定对象o上此 Method表示的方法，方法的形式参数为arg。若为静态方法，则o设置为null。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>setAccessible(boolean b)</td>
      <td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// String对象：</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello world"</span><span class="o">;</span>
<span class="c1">// 获取String substring(int)方法，参数为int：</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"substring"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 在s对象上调用该方法并获取结果：</span>
<span class="nc">String</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
<span class="c1">// 打印调用结果：</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="访问构造方法的方法">访问构造方法的方法</h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Object</td>
      <td>newInstance()</td>
      <td>只能调用公有的无参数构造方法。(已废弃，应写    getDeclaredConstructor().newInstance())。</td>
    </tr>
    <tr>
      <td>Constructor</td>
      <td>getConstructor(Class … arg)</td>
      <td>获取指定类的指定<strong>公有</strong>构造方法，arg为形式参数。</td>
    </tr>
    <tr>
      <td>Constructor</td>
      <td>getDeclaredConstructor(Class… arg)</td>
      <td>获取指定类的构造方法，arg为形式参数。</td>
    </tr>
    <tr>
      <td>Constructor[]</td>
      <td>getConstructors()</td>
      <td>返回该类的所有<strong>公有</strong>构造方法。</td>
    </tr>
    <tr>
      <td>Constructor[]</td>
      <td>getDeclaredConstructors()</td>
      <td>返回该类的所有构造方法。</td>
    </tr>
  </tbody>
</table>

<p>  <strong>Constructor 的方法</strong></p>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Object</td>
      <td>newInstance(Object …arg)</td>
      <td>调用构造方法，参数为arg。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>setAccessible(boolean b)</td>
      <td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取String的Class实例：String s=new Stirng();</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="c1">// 调用构造方法：</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">cls</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="c1">// 获取构造方法Integer(int)：Integer n1=new Integer(123);</span>
<span class="nc">Constructor</span> <span class="n">cons1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 调用构造方法：</span>
<span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">cons1</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="动态代理">动态代理</h2>
<p>  有没有可能不编写实现类，直接在运行期创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例呢？<br />
  这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例。<br />
  什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：<br />
  定义接口：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  编写实现类：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  创建实例，转型为接口并调用：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloWorld</span><span class="o">();</span>
<span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
</code></pre></div></div>
<p>  这种方式就是我们通常编写代码的方式。<br />
  还有一种方式是动态代码，我们仍然先定义了接口<code class="language-plaintext highlighter-rouge">Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建了一个<code class="language-plaintext highlighter-rouge">Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。<br />
  一个最简单的动态代理实现如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Hello</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
            <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="c1">// 传入ClassLoader</span>
            <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="c1">// 传入要实现的接口</span>
            <span class="n">handler</span><span class="o">);</span> <span class="c1">// 传入处理调用方法的InvocationHandler</span>
        <span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  在运行期动态创建一个<code class="language-plaintext highlighter-rouge">interface</code>实例的方法如下：</p>
<ul>
  <li>  定义一个<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
  <li>  通过<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建<code class="language-plaintext highlighter-rouge">interface</code>实例，它需要3个参数：
    <ol>
      <li>使用的<code class="language-plaintext highlighter-rouge">ClassLoader</code>，通常就是接口类的<code class="language-plaintext highlighter-rouge">ClassLoader</code>；</li>
      <li>需要实现的接口数组，至少需要传入一个接口进去；</li>
      <li>用来处理接口方法调用的<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例。</li>
    </ol>
  </li>
  <li>  将返回的<code class="language-plaintext highlighter-rouge">Object</code>强制转型为接口。</li>
</ul>

<p>  动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span><span class="n">a1</span><span class="o">();}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">a1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">HelloDynamicProxy</span> <span class="n">helloDynamicProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloDynamicProxy</span><span class="o">((</span><span class="n">proxy</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">args1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args1</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="n">helloDynamicProxy</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HelloDynamicProxy</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">HelloDynamicProxy</span><span class="o">(</span><span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="n">handler</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span>
                <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"morning"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
                <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">name</span><span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span><span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">;}</span>
</code></pre></div></div>
<p>  其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>
<h1 id="注解">注解</h1>
<p>  注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>

<h2 id="定义注解">定义注解</h2>
<p>  使用<code class="language-plaintext highlighter-rouge">@interface</code>语法来定义注解（<code class="language-plaintext highlighter-rouge">Annotation</code>），格式：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  定义一个注解，可以定义配置参数。配置参数可以是：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">所有基本类型</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">String</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">枚举类型</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">基本类型</code>、<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Class</code>以及<code class="language-plaintext highlighter-rouge">枚举</code>的<strong>数组</strong>。</li>
</ul>

<p>  配置参数<strong>必须</strong>是<code class="language-plaintext highlighter-rouge">常量</code>，注解配置参数可以用<code class="language-plaintext highlighter-rouge">default</code>设定一个默认值。<br />
  大部分注解存在名为<code class="language-plaintext highlighter-rouge">value</code>的配参数，对此参数赋值，可以<strong>只写</strong><code class="language-plaintext highlighter-rouge">常量</code>，相当于省略了<code class="language-plaintext highlighter-rouge">value</code>参数。即从<code class="language-plaintext highlighter-rouge">@Check(value=99)</code>省略为<code class="language-plaintext highlighter-rouge">@check(99)</code>，最常用的参数<strong>应当</strong>命名为<code class="language-plaintext highlighter-rouge">value</code>。<br />
  注解的参数类似无参数方法。</p>

<h2 id="元注解">元注解</h2>
<p>  有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h4 id="target">@Target</h4>
<p>  最常用的元注解是<code class="language-plaintext highlighter-rouge">@Target</code>。使用<code class="language-plaintext highlighter-rouge">@Target</code>可以定义<code class="language-plaintext highlighter-rouge">Annotation</code><strong>能够</strong>被应用于源码的哪些<strong>位置</strong>：</p>
<ul>
  <li>类或接口：<code class="language-plaintext highlighter-rouge">ElementType.TYPE</code>；</li>
  <li>字段：<code class="language-plaintext highlighter-rouge">ElementType.FIELD</code>；</li>
  <li>方法：<code class="language-plaintext highlighter-rouge">ElementType.METHOD</code>；</li>
  <li>构造方法：<code class="language-plaintext highlighter-rouge">ElementType.CONSTRUCTOR</code>；</li>
  <li>方法参数：<code class="language-plaintext highlighter-rouge">ElementType.PARAMETER</code>。</li>
</ul>

<p>  例如，定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在方法上，我们必须添加一个<code class="language-plaintext highlighter-rouge">@Target(ElementType.METHOD)</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{}</span>
</code></pre></div></div>
<p>  定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在<strong>方法或字段上</strong>，可以把<code class="language-plaintext highlighter-rouge">@Target</code>注解参数变为<strong>数组</strong><code class="language-plaintext highlighter-rouge">{ ElementType.METHOD, ElementType.FIELD }</code>：<br />
  实际上<code class="language-plaintext highlighter-rouge">@Target</code>定义的<code class="language-plaintext highlighter-rouge">value</code>是<code class="language-plaintext highlighter-rouge">ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>

<h4 id="retention">@Retention</h4>

<p>  Java的注解可以分为三类：<br />
  第一类是由编译器使用的注解，例如：<code class="language-plaintext highlighter-rouge">@Override</code>：让编译器检查该方法是否正确地实现了覆写；<code class="language-plaintext highlighter-rouge">@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。这类注解不会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，它们在编译后就被编译器扔掉了。 
  第二类是由工具处理<code class="language-plaintext highlighter-rouge">.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。<br />
  第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code class="language-plaintext highlighter-rouge">@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>

<hr />

<p>  元注解<code class="language-plaintext highlighter-rouge">@Retention</code>定义了<code class="language-plaintext highlighter-rouge">Annotation</code>的生命周期：</p>
<ul>
  <li>仅编译期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.SOURCE</code>；</li>
  <li>仅class文件：<code class="language-plaintext highlighter-rouge">RetentionPolicy.CLASS</code>；</li>
  <li>运行期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.RUNTIME</code>。</li>
</ul>

<p>  如果<code class="language-plaintext highlighter-rouge">@Retention</code>不存在，则该<code class="language-plaintext highlighter-rouge">Annotation</code>默认为<code class="language-plaintext highlighter-rouge">CLASS</code>。因为通常我们自定义的<code class="language-plaintext highlighter-rouge">Annotation</code>都是<code class="language-plaintext highlighter-rouge">RUNTIME</code>，所以，务必要加上<code class="language-plaintext highlighter-rouge">@Retention(RetentionPolicy.RUNTIME)</code>这个元注解。</p>

<h4 id="repeatable">@Repeatable</h4>
<p>  使用<code class="language-plaintext highlighter-rouge">@Repeatable</code>这个元注解可以定义<code class="language-plaintext highlighter-rouge">Annotation</code>是否可重复。这个注解应用不是特别广泛。<code class="language-plaintext highlighter-rouge">@Reports</code>是一个容器注解，用来包裹多个<code class="language-plaintext highlighter-rouge">@Report</code>注解。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repeatable</span><span class="o">(</span><span class="nc">Reports</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Reports</span> <span class="o">{</span>
    <span class="nc">Report</span><span class="o">[]</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>  经过<code class="language-plaintext highlighter-rouge">@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code class="language-plaintext highlighter-rouge">@Report</code>注解：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"debug"</span><span class="o">)</span>
<span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"warning"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{}</span>
</code></pre></div></div>
<h4 id="inherited">@Inherited</h4>
<p>  使用<code class="language-plaintext highlighter-rouge">@Inherited</code>定义子类是否可<strong>继承</strong>父类定义的<code class="language-plaintext highlighter-rouge">Annotation</code>。<code class="language-plaintext highlighter-rouge">@Inherited</code>仅针对<code class="language-plaintext highlighter-rouge">@Target(ElementType.TYPE)</code>类型的<code class="language-plaintext highlighter-rouge">annotation</code>有效，并且仅针对<code class="language-plaintext highlighter-rouge">class</code>的继承，对<code class="language-plaintext highlighter-rouge">interface</code>的继承无效。</p>
<h2 id="处理注解">处理注解</h2>
<p>  Java的注解本身对代码逻辑没有任何影响。根据<code class="language-plaintext highlighter-rouge">@Retention</code>的配置：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解在编译期就被丢掉了；</li>
  <li><code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
  <li><code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解会被加载进JVM，并且在运行期<strong>可以</strong>被程序读取。</li>
</ul>

<p>  如何使用注解完全由工具决定。<code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解不但要使用，还经常需要编写。<br />
  因此，我们只讨论如何读取<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解。</p>

<hr />

<p>  注解定义后也是一种<code class="language-plaintext highlighter-rouge">class</code>，所有的注解都继承自<code class="language-plaintext highlighter-rouge">java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。<br />
  Java提供的使用反射API读取<code class="language-plaintext highlighter-rouge">Annotation</code>的方法包括：<br />
  判断某个注解是否<strong>存在</strong>于<code class="language-plaintext highlighter-rouge">Class</code>、<code class="language-plaintext highlighter-rouge">Field</code>、<code class="language-plaintext highlighter-rouge">Method</code>或<code class="language-plaintext highlighter-rouge">Constructor</code>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Class.isAnnotationPresent(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Field.isAnnotationPresent(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Method.isAnnotationPresent(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Constructor.isAnnotationPresent(Class)</code></li>
</ul>

<p>  例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断@Report是否存在于Person类：</span>
<span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>
<p>  使用反射API<strong>读取</strong>Annotation：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Class.getAnnotation(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Field.getAnnotation(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Method.getAnnotation(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Constructor.getAnnotation(Class)</code></li>
</ul>

<p>  例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Person定义的@Report注解：</span>
<span class="nc">Report</span> <span class="n">report</span> <span class="o">=</span> <span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">type</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">level</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">level</span><span class="o">();</span>
</code></pre></div></div>
<hr />

<p>  读取方法、字段和构造方法的<code class="language-plaintext highlighter-rouge">Annotation</code>和Class类似。但要读取方法参数的<code class="language-plaintext highlighter-rouge">Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span><span class="o">=</span><span class="mi">5</span><span class="o">)</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nd">@NotNull</span> <span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>
<p>  要读取方法参数的注解，先用反射获取<code class="language-plaintext highlighter-rouge">Method</code>实例，然后读取方法参数的所有注解：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Method实例：</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 获取所有参数的Annotation：</span>
<span class="nc">Annotation</span><span class="o">[][]</span> <span class="n">annos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getParameterAnnotations</span><span class="o">();</span>
<span class="c1">// 第一个参数（索引为0）的所有Annotation：</span>
<span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annosOfName</span> <span class="o">=</span> <span class="n">annos</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">anno</span> <span class="o">:</span> <span class="n">annosOfName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">Range</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Range</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @Range注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="na">max</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">NotNull</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @NotNull注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已捕获NotNull"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="尝试在方法参数上实现-notnull-range">尝试在方法参数上实现 <strong>@NotNull @Range</strong></h1>

<p>  对于方法的形式参数，Java的反射机制并不能直接获取参数的值，毕竟只有在方法调用的时候才有值，因此失败了。如果需要在方法运行时对参数进行检查，可以使用面向切面编程（AOP）结合反射来实现。<br />
  不过对于对象的字段，可以直接通过反射获取字段的值，并进行判断。但要注意判断的时机需要另外的事件来触发。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="n">checkField</span><span class="o">(</span><span class="n">myClass</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkField</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredFields</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annotations</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotations</span><span class="o">();</span>
                <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">annotations</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="n">aClass</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">annotationType</span><span class="o">();</span>
                    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">NotNull</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">notNullDispose</span><span class="o">((</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">Range</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">rangeDispose</span><span class="o">(</span><span class="n">field</span><span class="o">,</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rangeDispose</span><span class="o">(</span><span class="nc">Field</span> <span class="n">field</span><span class="o">,</span> <span class="nc">Range</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span> <span class="nc">NotNull</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="c1">//              throw new IllegalArgumentException(text);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">NotNull</span> <span class="nf">notNullDispose</span><span class="o">(</span><span class="nc">NotNull</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">NotNull</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 不能为空"</span><span class="o">);</span>
<span class="c1">//          throw new IllegalArgumentException(n.value() + " 不能为空");</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"名称"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"地址"</span><span class="o">)</span>
    <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">address</span> <span class="o">=</span> <span class="s">"123456"</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">NotNull</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">Range</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">min</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">max</span><span class="o">()</span> <span class="k">default</span> <span class="mi">255</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Git推送到Github的一些设置</title><link href="https://acteds.github.io/2024/01/25/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/" rel="alternate" type="text/html" title="Git推送到Github的一些设置" /><published>2024-01-25T00:00:00+08:00</published><updated>2024-01-25T00:00:00+08:00</updated><id>https://acteds.github.io/2024/01/25/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE</id><content type="html" xml:base="https://acteds.github.io/2024/01/25/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/"><![CDATA[<h2 id="引言">引言</h2>
<p>  记录一些通常设置。</p>

<h2 id="详解">详解</h2>
<ul>
  <li>下载<a href="https://git-scm.com/downloads">Git</a></li>
  <li>设置Git环境变量</li>
  <li>配置SSH，完成GitHub身份验证<br />
  终端输入：<code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa -C 邮箱地址</code>，邮箱地址为GitHub的邮箱地址。<br />
  找到公钥文件(id_rsa.pub)，打开文件,复制内容<br />
  在GitHub上添加SSH keys(头像-Settings-SSH and GPG keys-New SSH key)，标题随便，key内填公钥内容。</li>
  <li>验证是否成功：<code class="language-plaintext highlighter-rouge">ssh -T git@github.com</code><br />
  若出现ssh: connect to host github.com port 22: Connection timed out<br />
  可以尝试修改SSH主机名：<br />
  在.ssh文件夹中新建config文件，无扩展名，并写入以下内容：
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host github.com
User 你的GitHub账号名称或邮箱地址
Hostname ssh.github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa
Port 443
</code></pre></div>    </div>
    <p>  重新验证是否成功：<code class="language-plaintext highlighter-rouge">ssh -T git@github.com</code><br />
  输入yes即可。</p>
  </li>
</ul>

<h2 id="额外操作">额外操作</h2>
<p>  在使用 Git 进行代码托管和版本控制的过程中，如果你想在提交代码时被正确的识别和归属，那么需要设置正确的 Git 邮箱地址。如果不设置邮箱，那么提交代码的作者将会是默认的 Git 用户，这会导致代码历史不可读，并且无法更好地识别谁提交的代码。<br />
  配置 git config：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config --global user.name github_name
git config --global user.email github_email
</code></pre></div></div>
<p>  显示带有颜色和图形的 Git 日志：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"
</code></pre></div></div>
<p>  参数解析：</p>
<ul>
  <li>–color： 启用彩色输出。</li>
  <li>–graph： 以图形的方式展示分支和合并历史。</li>
  <li>–pretty=format： 定制输出格式，使用一系列的占位符表示不同的信息。</li>
  <li>%Cred%h%Creset： 以红色显示短的提交哈希。</li>
  <li>-%C(yellow)%d%Creset： 显示分支和标签信息，并使用黄色。</li>
  <li>%s： 显示提交信息。</li>
  <li>%Cgreen(%cr)%Creset： 以绿色显示相对的提交时间。</li>
  <li>%C(bold blue)&lt;%an&gt;%Creset： 以粗体蓝色显示作者。</li>
</ul>

<p>  全局配置文件在用户根目录下的.gitconfig文件，也可直接修改这个文件进行配置<br />
  若只想作用于单个仓库，只需要去掉–global参数<br />
   单个仓库配置文件在.git/config文件。</p>
<h2 id="推送代码">推送代码</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git init
git add .
git commit -m "init"
git remote add github git@github.com:[id]/[库名].git
git push -u origin [远程分支名]
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Git" /><category term="GitHub" /><summary type="html"><![CDATA[Git推送到Github的一些设置]]></summary></entry><entry><title type="html">更新IDEA并保留所有兼容的设置</title><link href="https://acteds.github.io/2024/01/24/%E6%9B%B4%E6%96%B0IDEA%E5%B9%B6%E4%BF%9D%E7%95%99%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%9A%84%E8%AE%BE%E7%BD%AE/" rel="alternate" type="text/html" title="更新IDEA并保留所有兼容的设置" /><published>2024-01-24T00:00:00+08:00</published><updated>2024-01-24T00:00:00+08:00</updated><id>https://acteds.github.io/2024/01/24/%E6%9B%B4%E6%96%B0IDEA%E5%B9%B6%E4%BF%9D%E7%95%99%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%9A%84%E8%AE%BE%E7%BD%AE</id><content type="html" xml:base="https://acteds.github.io/2024/01/24/%E6%9B%B4%E6%96%B0IDEA%E5%B9%B6%E4%BF%9D%E7%95%99%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%9A%84%E8%AE%BE%E7%BD%AE/"><![CDATA[<h2 id="引言">引言</h2>
<p>  更新IDEA并不是一个好的想法，因为很容易出现兼容性问题，在此次更新到最新版中消耗我时间最多的是将不兼容的插件找一个平替插件。  <br />
  此次更新前版本为2019.3.3，更新后版本为2023.3.2。<br />
  也会说一下我的常用配置。</p>

<h2 id="详解">详解</h2>
<ol>
  <li>下载<a href="https://www.jetbrains.com/idea/download/">官方.zip</a></li>
  <li>解压到合适的文件夹(我这里是D:\ideaIU-2023.3.2\)</li>
  <li>修改配置文件：<code class="language-plaintext highlighter-rouge">D:\ideaIU-2023.3.2\bin\idea.properties</code>
    <ul>
      <li>此处设置将配置文件移入程序目录，若不设置则配置文件会出现在用户文件夹。
        <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">idea.config.path</span><span class="p">=</span><span class="s">${idea.home.path}/.IntelliJIdea2023.3.2/config</span>
<span class="py">idea.system.path</span><span class="p">=</span><span class="s">${idea.home.path}/.IntelliJIdea2023.3.2/system</span>
<span class="py">idea.plugins.path</span><span class="p">=</span><span class="s">${idea.config.path}/plugins</span>
<span class="py">idea.log.path</span><span class="p">=</span><span class="s">${idea.system.path}/log</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>修改VM文件：<code class="language-plaintext highlighter-rouge">D:\ideaIU-2023.3.2\bin\idea64.exe.vmoptions</code>
    <ul>
      <li>比如设置打开项目时的默认路径：
        <div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="py">-Duser.home</span><span class="p">=</span><span class="s">D:</span><span class="se">\i</span><span class="s">deaIU-2023.3.2</span><span class="se">\I</span><span class="s">deaProjects</span><span class="se">\
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>复制老项目到新项目文件</li>
  <li>打开新版<code class="language-plaintext highlighter-rouge">IDEA:D:\ideaIU-2023.3.2\bin\idea64.exe</code></li>
  <li>随便打开一个项目。</li>
  <li>导入设置：
    <ul>
      <li>文件-管理IDE设置-导入设置</li>
      <li>找到老的设置文件夹，例如：<code class="language-plaintext highlighter-rouge">C:\Users\{你的用户名}\.IntelliJIdea2019.3\config</code></li>
      <li>点击确认。</li>
    </ul>
  </li>
  <li>完成了。</li>
</ol>

<h2 id="注意">注意</h2>
<p>  在使用这个方法前我使用过在老版导出全部设置，然后在新版导入全部设置。但还是有大部分设置没有被导入，最致命的是配色方案没有被导入，配色方案还是单独备份一下比较好。<br />
  而使用我这个方法可以导入大部分的设置高亮以及插件，若插件不兼容则IDEA不会把插件导入新版。因为两个版本都在，因此可以对比插件找平替了，用不习惯或者出现问题也可以直接用老版。</p>
<h2 id="常用设置">常用设置</h2>
<ol>
  <li>字体没有成功导入，需要手动修改：设置-编辑器-字体-Consolas</li>
  <li>版本控制提交栏调出来：设置-版本控制-使用非模式提交界面</li>
</ol>

<h2 id="插件平替增强">插件平替增强</h2>
<ol>
  <li>设置背景图片现在不用插件<a href="https://plugins.jetbrains.com/plugin/8502-background-image-plus">Background Image Plus</a>了:设置-外观-UI选项-背景图片…</li>
  <li><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines">Alibaba Java Coding Guidelines</a> —- <a href="https://plugins.jetbrains.com/plugin/22381-alibaba-java-coding-guidelines-fix-some-bug-">Alibaba Java Coding Guidelines(Fix Some Bug)</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/7275-codeglance">CodeGlance</a> —- <a href="https://plugins.jetbrains.com/plugin/18824-codeglance-pro">CodeGlance Pro</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/8321-free-mybatis-plugin">Free MyBatis plugin</a> —- <a href="https://plugins.jetbrains.com/plugin/10119-mybatisx">MyBatisX</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/7654-gsonformat">GsonFormat</a> —- <a href="https://plugins.jetbrains.com/plugin/20094-gsonformat">Gsonformat</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/10465-highlightbracketpair">HighlightBracketPair</a> —- <a href="https://plugins.jetbrains.com/plugin/17320-highlightbracketpair">HighlightBracketPair</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/8554-ide-features-trainer">IDE Features Trainer</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/9792-key-promoter-x">Key Promoter X</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/6317-lombok">Lombok</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/7179-maven-helper">Maven Helper</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets">Rainbow Brackets</a> —- <a href="https://plugins.jetbrains.com/plugin/20710-rainbow-brackets-lite--free-and-opensource">Rainbow Brackets Lite-Free and OpenSource</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/8286-sequencediagram">SequenceDiagram</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/4509-statistic">Statistic</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/12798-tabnine-ai-code-completion--chat-in-java-js-ts-python--more">Tabnine: AI Code Completion &amp; Chat in Java JS/TS Python &amp; More</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/8579-translation">Translation</a> —- 插件正常兼容</li>
  <li><a href="https://plugins.jetbrains.com/plugin/9442-vue-js">Vue.js</a> —- 插件正常兼容</li>
</ol>

<p>  力荐插件:</p>
<ol>
  <li><a href="https://plugins.jetbrains.com/plugin/18553-show-comment">Show Comment</a></li>
  <li><a href="https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack----">Chinese(Simplified)Language Pack/中文语言包</a></li>
</ol>]]></content><author><name>acteds</name></author><category term="IDEA" /><summary type="html"><![CDATA[更新IDEA并保留所有兼容的设置]]></summary></entry><entry><title type="html">在高版本安卓系统上安装证书的办法</title><link href="https://acteds.github.io/2024/01/13/%E5%9C%A8%E9%AB%98%E7%89%88%E6%9C%AC%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6%E7%9A%84%E5%8A%9E%E6%B3%95/" rel="alternate" type="text/html" title="在高版本安卓系统上安装证书的办法" /><published>2024-01-13T00:00:00+08:00</published><updated>2024-01-13T00:00:00+08:00</updated><id>https://acteds.github.io/2024/01/13/%E5%9C%A8%E9%AB%98%E7%89%88%E6%9C%AC%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6%E7%9A%84%E5%8A%9E%E6%B3%95</id><content type="html" xml:base="https://acteds.github.io/2024/01/13/%E5%9C%A8%E9%AB%98%E7%89%88%E6%9C%AC%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85%E8%AF%81%E4%B9%A6%E7%9A%84%E5%8A%9E%E6%B3%95/"><![CDATA[<h2 id="引言">引言</h2>
<p>  若有抓包需求,则必须安装证书,但Android7.0之后默认不信任用户添加到系统的CA证书.</p>

<h2 id="详解">详解</h2>
<h3 id="导出证书">导出证书</h3>
<p>  就拿<a href="https://www.charlesproxy.com/">Charles</a>举例：导出pem证书:Help-SSL Proxying-Save Charles Root Certificate…,名称假定为<strong>name.pem</strong></p>

<h3 id="修改名称">修改名称</h3>
<p>  使用<a href="https://slproweb.com/products/Win32OpenSSL.html">openssl</a>.</p>
<ul>
  <li>若第一步没有取得.pem证书而是.cer证书,则可以使用以下代码转换:
    <pre><code class="language-Bash">openssl x509 -inform der -in name.cer -out name.pem
</code></pre>
  </li>
  <li>若已有pem文件,则输入以下代码:
    <pre><code class="language-Bash">openssl x509 -inform PEM -subject_hash_old -in name.pem
</code></pre>
    <p>会输出形如:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b3778315
-----BEGIN CERTIFICATE-----
省略
-----END CERTIFICATE-----
</code></pre></div>    </div>
    <p>记住第一行,我这里即<strong>b3778315</strong>.</p>
  </li>
  <li>将文件<strong>name.pem</strong>改成:<strong>b3778315.0</strong></li>
  <li>证书的准备工作就完成了.</li>
</ul>

<h3 id="其他准备工作">其他准备工作</h3>
<p>需要取得root权限,并取得系统盘写入权限. <br />
就拿<a href="https://mumu.163.com/update/">mumu模拟器12</a>举例,需要勾选:</p>
<ul>
  <li>设置中心-其他-开启手机Root权限.</li>
  <li>设置中心-磁盘-可写系统盘.</li>
</ul>

<h3 id="执行adb命令">执行ADB命令</h3>
<p>  连接,并获取root权限,端口举例为mumu模拟器12:</p>
<pre><code class="language-Bash">adb connect 127.0.0.1:7555
adb shell
su
</code></pre>
<p>  在手机上确认授权.退出shell</p>
<pre><code class="language-Bash">exit
</code></pre>
<p>  写入文件:</p>
<pre><code class="language-Bash">adb push b3778315.0 /etc/security/cacerts/
</code></pre>
<p>  控制台回应:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[100%] /etc/security/cacerts/b3778315.0
</code></pre></div></div>
<p>  更改权限:</p>
<pre><code class="language-Bash">adb shell chmod 644 /etc/security/cacerts/b3778315.0
</code></pre>
<p>  可通过ls命令查看文件是否存在.  <br />
  这样证书安装就完成了. <br />
  以上步骤也可通过各种有读写系统路径的管理器来操作,注意文件权限设置.</p>]]></content><author><name>acteds</name></author><category term="Android" /><summary type="html"><![CDATA[在高版本安卓系统上安装证书的办法]]></summary></entry><entry><title type="html">节流与去重的重要性</title><link href="https://acteds.github.io/2024/01/10/%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E9%87%8D%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/" rel="alternate" type="text/html" title="节流与去重的重要性" /><published>2024-01-10T00:00:00+08:00</published><updated>2024-01-10T00:00:00+08:00</updated><id>https://acteds.github.io/2024/01/10/%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E9%87%8D%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7</id><content type="html" xml:base="https://acteds.github.io/2024/01/10/%E8%8A%82%E6%B5%81%E4%B8%8E%E5%8E%BB%E9%87%8D%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"><![CDATA[<h2 id="引言">引言</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">MutationObserver</a>接口提供了侦听DOM数变化的功能,可以监听DOM中属性、内容和节点的修改。</p>

<p>  例如:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 只能调用一次,若多次调用该函数,且在执行过程中再次出发另一个实例则将产生死循环
 * dom修改事件,包括属性,内容,节点修改
 * @param document 侦听对象
 * @param func  执行函数
 */</span>
<span class="kd">function</span> <span class="nx">dom修改事件</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MozMutationObserver</span><span class="p">;</span><span class="c1">//浏览器兼容</span>
    <span class="kd">const</span> <span class="nx">config</span> <span class="o">=</span> <span class="p">{</span><span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span><span class="p">};</span><span class="c1">//配置对象</span>
    <span class="kd">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//进入后停止侦听</span>
        <span class="nx">observer</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">();</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="nx">func</span><span class="p">(</span><span class="nx">records</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">'</span><span class="s1">执行错误</span><span class="dl">'</span><span class="p">)}</span>
        <span class="c1">//结束后继续侦听</span>
        <span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span><span class="nb">document</span><span class="p">,</span> <span class="nx">config</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  这个函数的目的是在每次触发变化后，先停止监听,然后执行自定义函数，再重新启用监听器来继续监听变化。<br />
  停止监听的原因是自定义函数会涉及dom修改,然后再次触发该事件导致死循环。<br />
  而多次调用该函数也会导致死循环，原因同样式dom修改会触发同类事件，而同类事件并没有停止侦听。</p>

<h2 id="详解">详解</h2>
<h3 id="创建实例">创建实例</h3>
<p>  当使用 MutationObserver 创建观察器实例时，传递给构造函数的参数是一个回调函数。这个回调函数在观察到 DOM 发生变化时会被触发执行。</p>

<p>  这个回调函数接收两个参数：</p>

<ul>
  <li><strong>records</strong>：这是一个包含所有观察到的 DOM 变化的数组（MutationRecord 对象）。每个 MutationRecord 包含了有关单个 DOM 变化的信息，比如发生变化的节点、变化类型等。</li>
  <li>itself（可选）：这个参数是 MutationObserver 实例自身。它指向了触发这个回调函数的 MutationObserver 实例。</li>
</ul>

<p>  在 MutationObserver 的回调函数中，records 是一个 MutationRecord 对象的数组，代表了所有检测到的 DOM 变化。每个 MutationRecord 对象都包含了关于单个 DOM 变化的详细信息。</p>

<p>  <strong>MutationRecord</strong> 对象具有以下属性：<br />
  1. type: 表示发生的变化类型，可能的值有 attributes（属性变化）、childList（子节点变化）、characterData（节点内容变化）。<br />
  2. target: 发生变化的目标节点（DOM 节点）。<br />
  3. addedNodes: 在 childList 类型的变化中，表示新增的节点列表。<br />
  4. removedNodes: 在 childList 类型的变化中，表示移除的节点列表。<br />
  5. previousSibling: 变化前的同级前一个节点。<br />
  6. nextSibling: 变化后的同级后一个节点。 <br />
  7. attributeName: 在 attributes 类型的变化中，表示被修改的属性名称。<br />
  8. oldValue: 在某些情况下，表示被修改的节点的原始值。</p>

<h3 id="启动侦听">启动侦听</h3>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nx">mutationObserver</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span><span class="nx">target</span><span class="p">[,</span> <span class="nx">options</span><span class="p">])</span>
</code></pre></div></div>
<p>  创建完实例后即可使用实例的observe()函数启动侦听。</p>
<ul>
  <li>target:要观察变化的DOM。</li>
  <li>options（可选）:此对象的配置项描述了DOM的哪些变化应该报告给 MutationObserver的callback。当调用observe()时，childList、attributes和characterData中，必须有一个参数为 true。否则会抛出TypeError异常。</li>
</ul>

<p>  options 的属性如下：<br />
  1. subtree（可选）:当为 true 时，将会监听以 target 为根节点的整个子树。包括子树中所有节点的属性，而不仅仅是针对 target。默认值为 false。<br />
  2. childList（可选）:当为 true 时，监听 target 节点中发生的节点的新增与删除（同时，如果 subtree 为 true，会针对整个子树生效）。默认值为 false。<br />
  3. attributes（可选）:当为 true 时观察所有监听的节点属性值的变化。默认值为 true，当声明了 attributeFilter 或 attributeOldValue，默认值则为 false。<br />
  4. attributeFilter（可选）:一个用于声明哪些属性名会被监听的数组。如果不声明该属性，所有属性的变化都将触发通知。<br />
  5. attributeOldValue（可选）:当为 true 时，记录上一次被监听的节点的属性变化；可查阅监听属性值了解关于观察属性变化和属性值记录的详情。默认值为 false。<br />
  6. characterData（可选）:当为 true 时，监听声明的 target 节点上所有字符的变化。默认值为 true，如果声明了 characterDataOldValue，默认值则为 false<br />
  7. characterDataOldValue（可选）:当为 true 时，记录前一个被监听的节点中发生的文本变化。默认值为 false</p>

<p>  一旦调用 MutationObserver.observe()，指定的目标节点上发生的变化将会被捕捉到，并在回调函数中进行处理。当你不再需要观察这些变化时，可以调用 MutationObserver.disconnect() 来停止观察。</p>

<h2 id="优化">优化</h2>
<p>  对于开头给出的例子具有只能使用一次的弊端,可以通过以下方式优化:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">observerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="cm">/**
 * 修改后的函数,在触发事件后会对其他相同document的obs排队依次触发
 * dom修改事件,包括属性,内容,节点修改
 * @param document 侦听对象
 * @param func  执行函数,可选参数(records),表示更改的节点
 * @param config 侦听的配置
 */</span>
<span class="kd">function</span> <span class="nx">dom修改事件</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">func</span> <span class="p">,</span><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span><span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MozMutationObserver</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nb">document</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
        <span class="c1">// 在每次变化前暂停相同 document 的所有观察器实例</span>
        <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">()</span> <span class="p">);</span>
        <span class="c1">// 对拥有相同观察器实例的文档执行各自的函数</span>
        <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">try</span> <span class="p">{</span><span class="nx">obs</span><span class="p">.</span><span class="nx">func</span><span class="p">(</span><span class="nx">records</span><span class="p">);</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="nx">e</span> <span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span> <span class="dl">'</span><span class="s1">执行错误</span><span class="dl">'</span> <span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
        <span class="c1">// 在执行完毕后重新启用相同 document 的所有观察器实例</span>
        <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>
    <span class="c1">// 将观察器实例和对应的函数添加到对应 document 的数组中</span>
    <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nb">document</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="nx">observers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">{</span><span class="nx">observer</span><span class="p">,</span> <span class="nx">func</span> <span class="p">}</span> <span class="p">);</span>
    <span class="nx">observerMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">observers</span> <span class="p">);</span>
    <span class="c1">// 开启侦听</span>
    <span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  对于相同document的MutationObserver会集中进行处理,但弊端一样很明显,若为不相同的document,比如子文档,当发生重叠修改时一样会触发死循环.</p>

<p>  另外一种优化:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">observerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="cm">/**
 * 修改后的函数,在触发事件后会对其他相同config的obs排队依次触发
 * dom修改事件,包括属性,内容,节点修改
 * @param document 侦听对象
 * @param func  执行函数,可选参数(records),表示更改的节点
 * @param config 侦听的配置
 */</span>
<span class="kd">function</span> <span class="nx">dom修改事件</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">func</span> <span class="p">,</span><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span><span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MozMutationObserver</span><span class="p">;</span>
    <span class="c1">//将配置对象序列化为字符串,做为key.</span>
    <span class="kd">const</span> <span class="nx">serializedConfig</span><span class="o">=</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">).</span><span class="nx">sort</span><span class="p">());</span>
    <span class="kd">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nx">serializedConfig</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
        <span class="c1">// 在每次变化前暂停相同 config 的所有观察器实例</span>
        <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">()</span> <span class="p">);</span>

        <span class="c1">// 对拥有相同观察器实例的文档执行各自的函数</span>
        <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">try</span> <span class="p">{</span><span class="nx">obs</span><span class="p">.</span><span class="nx">func</span><span class="p">(</span><span class="nx">records</span><span class="p">);</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="nx">e</span> <span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span> <span class="dl">'</span><span class="s1">执行错误</span><span class="dl">'</span> <span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
        <span class="c1">// 在执行完毕后重新启用相同 config 的所有观察器实例</span>
        <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="c1">// 将观察器实例和对应的函数添加到对应 config 的数组中</span>
    <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nx">serializedConfig</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="nx">observers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">{</span><span class="nx">observer</span><span class="p">,</span> <span class="nx">func</span> <span class="p">}</span> <span class="p">);</span>
    <span class="nx">observerMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span> <span class="nx">serializedConfig</span><span class="p">,</span> <span class="nx">observers</span> <span class="p">);</span>

    <span class="c1">// 开启侦听</span>
    <span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">);</span>
<span class="p">}</span> 
</code></pre></div></div>
<p>  对于相同配置的MutationObserver会集中进行处理.<br />
  总的来说,使用MutationObserver需要注意无限触发的问题.</p>

<h2 id="优化与性能测试">优化与性能测试</h2>
<p>  MutationObserver的侦听范围太过宽泛,而且与dom绑定,当绑定的对象不存在后MutationObserver也就没有作用了,因此常常将MutationObserver绑定在基本不会变动的靠近根的dom上,因此会过于频繁的触发回调函数,若要检查修改发生变化的元素或文本,又需要频繁的开关MutationObserver,因此性能需要测试.</p>

<p>  下面给出使用MutationObserver对指定页面body进行侦听,并修改内容的耗时</p>

<p>  使用上方的函数,控制台:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:234691次
修改耗时:16818ms
</code></pre></div></div>
<h3 id="节流">节流</h3>
<p>  通过使用节流函数将小于指定触发时间间隔的修改对象累计起来,并在超时后集中处理,可以减轻开关MutationObserver实例带来的性能消耗.<br />
  具体优化代码为:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">observerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="cm">/**
 * 修改后的函数,在触发事件后会对其他相同config的obs排队依次触发,使用节流.
 * dom修改事件,包括属性,内容,节点修改
 * @param document 侦听对象
 * @param func  执行函数,可选参数(records),表示更改的节点
 * @param config 侦听的配置
 */</span>
<span class="kd">function</span> <span class="nx">dom修改事件</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">func</span> <span class="p">,</span><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span><span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MozMutationObserver</span><span class="p">;</span>
    <span class="c1">//将配置对象序列化为字符串,做为key.</span>
    <span class="kd">const</span> <span class="nx">serializedConfig</span><span class="o">=</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">).</span><span class="nx">sort</span><span class="p">());</span>
    <span class="kd">let</span> <span class="nx">throttleTimeout</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">recordsArr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">throttleTimeout</span><span class="p">);</span>
        <span class="c1">// 记录变化</span>
        <span class="nx">recordsArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">...</span><span class="nx">records</span> <span class="p">);</span>
        <span class="nx">throttleTimeout</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nx">serializedConfig</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
            <span class="c1">// 在每次变化前暂停相同 config 的所有观察器实例</span>
            <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">()</span> <span class="p">);</span>
            <span class="c1">// 对拥有相同观察器实例的文档执行各自的函数</span>
            <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">try</span> <span class="p">{</span><span class="nx">obs</span><span class="p">.</span><span class="nx">func</span><span class="p">(</span><span class="nx">recordsArr</span><span class="p">);</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="nx">e</span> <span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span> <span class="dl">'</span><span class="s1">执行错误</span><span class="dl">'</span> <span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
            <span class="c1">// 在执行完毕后重新启用相同 config 的所有观察器实例</span>
            <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">)</span> <span class="p">);</span>
            <span class="c1">// 清空记录的修改</span>
            <span class="nx">recordsArr</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="c1">// 将观察器实例和对应的函数添加到对应 config 的数组中</span>
    <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nx">serializedConfig</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="nx">observers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">{</span><span class="nx">observer</span><span class="p">,</span> <span class="nx">func</span> <span class="p">}</span> <span class="p">);</span>
    <span class="nx">observerMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span> <span class="nx">serializedConfig</span><span class="p">,</span> <span class="nx">observers</span> <span class="p">);</span>

    <span class="c1">// 开启侦听</span>
    <span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  当设置节流时间段为0ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:234691次
修改耗时:17276ms
</code></pre></div></div>
<p>  当设置节流时间段为10ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:234691次
修改耗时:17691ms
</code></pre></div></div>
<p>  当设置节流时间段为50ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:234691次
修改耗时:17671ms
</code></pre></div></div>
<p>  当设置节流时间段为100ms时,同上次比较,效果显著,修改次数大幅上升了:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:368441次
修改耗时:25427ms
</code></pre></div></div>
<p>  当设置节流时间段为1000ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:368441次
修改耗时:25732ms
</code></pre></div></div>
<p>  节流时间的设置会在某个时间点后让性能大幅下降,但应该和元素数量以及复杂度有关,且过长的节流时间会让页面修改不及时,从而影响用户体验,因此节流方面似乎并没有多大性能收益.</p>

<h3 id="减负">减负</h3>
<p>  MutationObserver的回调次数着实有些高,因此可以从合并相似MutationRecord对象着手提高性能.</p>

<p>  对于相似MutationRecord对象,可以只保留最后一个:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * 从后面开始去重,并保留靠后的元素.
     * @param arr
     * @returns {*}
     */</span>
    <span class="kd">function</span> <span class="nx">removeDuplicates</span><span class="p">(</span> <span class="nx">arr</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span> <span class="p">(</span> <span class="nx">unique</span><span class="p">,</span> <span class="nx">item</span> <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// 检查当前元素是否已存在于结果数组中，如果不存在，则将其添加到数组中</span>
            <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">unique</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span> <span class="nx">i</span> <span class="o">=&gt;</span> <span class="p">(</span>
                <span class="nx">i</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">type</span> <span class="o">&amp;&amp;</span>
                <span class="nx">i</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">target</span> <span class="o">&amp;&amp;</span>
                <span class="nx">i</span><span class="p">.</span><span class="nx">attributeName</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">attributeName</span>
            <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="nx">unique</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="nx">item</span> <span class="p">);</span> <span class="c1">// 将不重复的元素添加到结果数组中</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">unique</span><span class="p">;</span>
        <span class="p">},</span> <span class="p">[]</span> <span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>
<p>  使用 reduceRight方法遍历输入数组arr，从数组的最后一个元素开始,检查每个数组元素 item是否已经存在于unique数组中。<br />
  如果 unique 数组中没有相同type、target和attributeName属性的元素，则将当前元素 item添加到unique数组中并返回。<br />
  函数的结果是一个不包含重复元素的新数组，确保了没有重复的MutationRecord对象。</p>

<p>  结合节流后,得到代码:</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">observerMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
<span class="cm">/**
 * 修改后的函数,在触发事件后会对其他相同config的obs排队依次触发,节流10,去重.
 * dom修改事件,包括属性,内容,节点修改
 * @param document 侦听对象
 * @param func  执行函数,可选参数(records),表示更改的节点
 * @param config 侦听的配置
 */</span>
<span class="kd">function</span> <span class="nx">dom修改事件</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">func</span> <span class="p">,</span><span class="nx">config</span> <span class="o">=</span> <span class="p">{</span><span class="na">attributes</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">childList</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">characterData</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">subtree</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">MutationObserver</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">WebKitMutationObserver</span> <span class="o">||</span> <span class="nb">window</span><span class="p">.</span><span class="nx">MozMutationObserver</span><span class="p">;</span>
    <span class="c1">//将配置对象序列化为字符串,做为key.</span>
    <span class="kd">const</span> <span class="nx">serializedConfig</span><span class="o">=</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">).</span><span class="nx">sort</span><span class="p">());</span>
    <span class="kd">let</span> <span class="nx">throttleTimeout</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">recordsArr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">observer</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MutationObserver</span><span class="p">(</span> <span class="kd">function</span><span class="p">(</span><span class="nx">records</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">throttleTimeout</span><span class="p">);</span>
        <span class="c1">// 记录变化</span>
        <span class="nx">recordsArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">...</span><span class="nx">records</span> <span class="p">);</span>
        <span class="nx">throttleTimeout</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// 从recordedMutations数组中移除重复项</span>
            <span class="nx">recordsArr</span> <span class="o">=</span> <span class="nx">removeDuplicates</span><span class="p">(</span><span class="nx">recordsArr</span><span class="p">);</span>
            <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nx">serializedConfig</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
            <span class="c1">// 在每次变化前暂停相同 config 的所有观察器实例</span>
            <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">disconnect</span><span class="p">()</span> <span class="p">);</span>
            <span class="c1">// 对拥有相同观察器实例的文档执行各自的函数</span>
            <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">try</span> <span class="p">{</span><span class="nx">obs</span><span class="p">.</span><span class="nx">func</span><span class="p">(</span><span class="nx">recordsArr</span><span class="p">);</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="nx">e</span> <span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span> <span class="dl">'</span><span class="s1">执行错误</span><span class="dl">'</span> <span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
            <span class="c1">// 在执行完毕后重新启用相同 config 的所有观察器实例</span>
            <span class="nx">observers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span> <span class="nx">obs</span> <span class="o">=&gt;</span> <span class="nx">obs</span><span class="p">.</span><span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">)</span> <span class="p">);</span>
            <span class="c1">// 清空记录的修改</span>
            <span class="nx">recordsArr</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="p">},</span> <span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="c1">// 将观察器实例和对应的函数添加到对应 config 的数组中</span>
    <span class="kd">let</span> <span class="nx">observers</span> <span class="o">=</span> <span class="nx">observerMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span> <span class="nx">serializedConfig</span> <span class="p">)</span> <span class="o">||</span> <span class="p">[];</span>
    <span class="nx">observers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="p">{</span><span class="nx">observer</span><span class="p">,</span> <span class="nx">func</span> <span class="p">}</span> <span class="p">);</span>
    <span class="nx">observerMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span> <span class="nx">serializedConfig</span><span class="p">,</span> <span class="nx">observers</span> <span class="p">);</span>

    <span class="c1">// 开启侦听</span>
    <span class="nx">observer</span><span class="p">.</span><span class="nx">observe</span><span class="p">(</span> <span class="nb">document</span><span class="p">,</span> <span class="nx">config</span> <span class="p">);</span>
    <span class="cm">/**
     * 从后面开始去重,并保留靠后的元素.
     * @param arr
     * @returns {*}
     */</span>
    <span class="kd">function</span> <span class="nx">removeDuplicates</span><span class="p">(</span> <span class="nx">arr</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduceRight</span><span class="p">(</span> <span class="p">(</span> <span class="nx">unique</span><span class="p">,</span> <span class="nx">item</span> <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="c1">// 检查当前元素是否已存在于结果数组中，如果不存在，则将其添加到数组中</span>
            <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="nx">unique</span><span class="p">.</span><span class="nx">some</span><span class="p">(</span> <span class="nx">i</span> <span class="o">=&gt;</span> <span class="p">(</span>
                <span class="nx">i</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">type</span> <span class="o">&amp;&amp;</span>
                <span class="nx">i</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">target</span> <span class="o">&amp;&amp;</span>
                <span class="nx">i</span><span class="p">.</span><span class="nx">attributeName</span> <span class="o">===</span> <span class="nx">item</span><span class="p">.</span><span class="nx">attributeName</span>
            <span class="p">)</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
                <span class="nx">unique</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="nx">item</span> <span class="p">);</span> <span class="c1">// 将不重复的元素添加到结果数组中</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nx">unique</span><span class="p">;</span>
        <span class="p">},</span> <span class="p">[]</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>  当不设置节流单独使用去重时,效果如下,同上次比较,效果显著:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:33278次
修改耗时:2430ms
</code></pre></div></div>
<p>  当设置节流时间段为0ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:30005次
修改耗时:2264ms
</code></pre></div></div>
<p>  当设置节流时间段为10ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:26798次
修改耗时:2116ms
</code></pre></div></div>
<p>  当设置节流时间段为50ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:25894次
修改耗时:1965ms
</code></pre></div></div>
<p>  当设置节流时间段为100ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:21421次
修改耗时:1975ms
</code></pre></div></div>
<p>  当设置节流时间段为1000ms时,同上次比较,效果不明显:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>修改次数:20463次
修改耗时:1888ms
</code></pre></div></div>

<p>  去重结合节流可以有效的提示性能,节流主要起到收集作用,去重算法才是优化方向.</p>]]></content><author><name>acteds</name></author><category term="JavaScript" /><summary type="html"><![CDATA[关于MutationObserver对象的性能测试]]></summary></entry><entry><title type="html">MySQL的驱动版本更替后日期返回值的变化</title><link href="https://acteds.github.io/2023/05/17/MySQL%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%89%88%E6%9C%AC%E6%9B%B4%E6%9B%BF%E5%90%8E%E6%97%A5%E6%9C%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%8F%98%E5%8C%96/" rel="alternate" type="text/html" title="MySQL的驱动版本更替后日期返回值的变化" /><published>2023-05-17T00:00:00+08:00</published><updated>2023-05-17T00:00:00+08:00</updated><id>https://acteds.github.io/2023/05/17/MySQL%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%89%88%E6%9C%AC%E6%9B%B4%E6%9B%BF%E5%90%8E%E6%97%A5%E6%9C%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%8F%98%E5%8C%96</id><content type="html" xml:base="https://acteds.github.io/2023/05/17/MySQL%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%89%88%E6%9C%AC%E6%9B%B4%E6%9B%BF%E5%90%8E%E6%97%A5%E6%9C%9F%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%8F%98%E5%8C%96/"><![CDATA[<h2 id="引言">引言</h2>
<p>  MySQL的驱动版本从5.1.7升级到8.0.27后,对于数据库表字段类型为datetime的数据会封装为<strong>java.time.LocalDateTime</strong>类型,而不是旧的<strong>java.sql.Timestam</strong>类型。</p>

<h2 id="详解">详解</h2>
<p>  因此不能再使用<strong>fmt:formatDate</strong>转换了<br />
  例如:</p>
<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;fmt:formatDate </span><span class="na">pattern=</span><span class="s">"yyyy-MM-dd HH:mm:ss"</span><span class="na"> value=</span><span class="s">"</span><span class="si">${</span><span class="n">lastDate</span><span class="si">}</span><span class="s">"</span><span class="nt">/&gt;</span>
</code></pre></div></div>
<p>  不想改变其他代码的话,可以直接使用下面代码:</p>
<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>${lastDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))}
</code></pre></div></div>
<p>需要注意的是,还需要将<strong>DateTimeFormatter</strong>导入</p>
<div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%@ page </span><span class="na">import=</span><span class="s">"java.time.format.DateTimeFormatter"</span> <span class="nt">%&gt;</span>
</code></pre></div></div>

<p>  当然,如果不想更改前端代码,则可以将<strong>java.time.LocalDateTime</strong>类型转换回旧的<strong>java.sql.Timestam</strong>类型。通过设置<strong>TypeHandler</strong>,可以对mybatis返回的类型进行处理。</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[版本变更后返回值的变化]]></summary></entry><entry><title type="html">在浏览某些网站时字体很奇怪</title><link href="https://acteds.github.io/2023/04/26/%E5%9C%A8%E6%B5%8F%E8%A7%88%E6%9F%90%E4%BA%9B%E7%BD%91%E7%AB%99%E6%97%B6%E5%AD%97%E4%BD%93%E5%BE%88%E5%A5%87%E6%80%AA-copy/" rel="alternate" type="text/html" title="在浏览某些网站时字体很奇怪" /><published>2023-04-26T00:00:00+08:00</published><updated>2023-04-26T00:00:00+08:00</updated><id>https://acteds.github.io/2023/04/26/%E5%9C%A8%E6%B5%8F%E8%A7%88%E6%9F%90%E4%BA%9B%E7%BD%91%E7%AB%99%E6%97%B6%E5%AD%97%E4%BD%93%E5%BE%88%E5%A5%87%E6%80%AA%20copy</id><content type="html" xml:base="https://acteds.github.io/2023/04/26/%E5%9C%A8%E6%B5%8F%E8%A7%88%E6%9F%90%E4%BA%9B%E7%BD%91%E7%AB%99%E6%97%B6%E5%AD%97%E4%BD%93%E5%BE%88%E5%A5%87%E6%80%AA-copy/"><![CDATA[<h2 id="引言">引言</h2>
<p>  在浏览某些网站时网站的字体很奇怪.</p>

<h2 id="详解">详解</h2>
<p>  具体显示效果为:<br />
<img src="/images/posts/Chrome/奇怪的字体.png" alt="奇怪的字体" /><br />
  实际上，是因为网站设置了:</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">font-family</span><span class="nd">:BlinkMacSystemFont</span><span class="o">,</span><span class="s1">"Segoe UI"</span><span class="o">,</span><span class="s1">"Roboto"</span><span class="o">,</span><span class="s1">"Oxygen"</span><span class="o">,</span><span class="s1">"Ubuntu"</span><span class="o">,</span><span class="s1">"Cantarell"</span><span class="o">,</span><span class="s1">"Fira Sans"</span><span class="o">,</span><span class="s1">"Droid Sans"</span><span class="o">,</span><span class="s1">"Helvetica Neue"</span><span class="o">,</span><span class="nt">sans-serif</span>
</code></pre></div></div>
<p>  而你又恰好安装了”Droid Sans”字体,那么就会使用”Droid Sans”字体.<br />
  解决方法也很简单,卸载掉”Droid Sans”字体,或者通过css覆盖掉”font-family”.</p>]]></content><author><name>acteds</name></author><category term="Chrome" /><summary type="html"><![CDATA[Droid Sans字体的中文显示效果不佳]]></summary></entry></feed>