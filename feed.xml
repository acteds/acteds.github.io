<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-05-04T10:43:46+08:00</updated><id>/feed.xml</id><title type="html">个人博客</title><subtitle></subtitle><author><name>acteds</name></author><entry><title type="html">设计模式</title><link href="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="设计模式" /><published>2024-05-02T00:00:00+08:00</published><updated>2024-05-02T00:00:00+08:00</updated><id>/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><![CDATA[<h1 id="引言">引言</h1>
<p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>

<h1 id="设计模式">设计模式</h1>

<p>软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，23个常用模式分为创建型模式、结构型模式和行为型模式三类，基于以下几个原则：</p>

<p><strong>开闭原则</strong></p>

<p>软件应该对扩展开放，而对修改关闭。在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p>

<p><strong>单一职责原则</strong></p>

<p>一个类只负责一项职责。针对一个类，其承担的职责越多，被复用的可能性就越小。如果类承担的职责很多，就意味着这些职责耦合在了一起。</p>

<p><strong>里氏替换原则</strong></p>

<p>如果调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>

<p><strong>接口隔离原则</strong></p>

<ul>
  <li>客户需要什么样的接口，就提供什么样的接口，不需要的就删除掉；</li>
  <li>类之间的依赖关系应建立在最小的接口上。也就是说，接口中的方法要尽量的少，接口功能要尽量的细分。</li>
</ul>

<p><strong>依赖倒置原则</strong></p>

<p>依赖倒转原则就是要依赖于抽象，不要依赖于实现。高层模块不依赖于底层模块，二者都依赖其抽象；抽象不依赖于细节，细节应该依赖抽象。</p>

<p>也就是说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等，而不是用具体类。<strong>一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法</strong>。特例：对象的创建过程是违背“开—闭”原则以及依赖倒转原则的，但通过工厂模式，能很好地解决对象创建过程中的依赖倒转问题。</p>

<p><strong>迪米特原则</strong></p>

<p>又称为最少知识原则，<strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p>

<p>如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</p>

<p>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</p>

<p>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p>

<p><strong>组合/聚合复用原则</strong></p>

<p>简单的说是，尽量使用对象的组合/聚合，而不是继承来达到复用的目的。</p>

<p>组合和聚合都是对象建模中关联关系的一种。聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。</p>

<p>组合/聚合和继承是实现代码复用的两种基本途径，在设计过程中尽量使用组合/聚合，而不是继承。因为继承使得基类与子类有较强的耦合性，通常情况下基类的内部细节对子类来说是可见的，这样基类的实现细节会暴露给子类，破坏了系统的封装性。</p>

<p>开闭原则是所有面向对象原则的核心；里式替换原则是实现开闭原则的重要方式之一；依赖倒置原则是系统抽象化的具体实现，其是面向对象设计的主要实现机制之一；接口隔离原则要求接口的方法尽量少，接口尽量细化；迪米特原则降低系统的耦合度，其使得一个模块的修改尽量少的影响其他模块，扩展会相对容易；尽量使用组合/聚合而不是继承达到代码复用的目的。</p>

<h2 id="创建型模式">创建型模式</h2>

<p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>

<p>常见的创建型模式：</p>

<ul>
  <li><strong>工厂方法模式（Factory Method Pattern）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</li>
  <li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li>
  <li><strong>建造者模式（Builder Pattern）</strong>：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li>
  <li><strong>原型模式（Prototype Pattern）</strong>：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</li>
  <li><strong>单例模式（Singleton Pattern）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li>
</ul>

<h3 id="工厂方法">工厂方法</h3>

<blockquote>
  <p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
</blockquote>

<p>工厂方法即Factory Method，是一种对象创建型模式。</p>

<p>工厂方法的目的是使得<strong>创建对象</strong>和<strong>使用对象</strong>是<strong>分离</strong>的，并且客户端<strong>总是引用抽象工厂和抽象产品</strong>：</p>

<pre><code class="language-ascii">┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
</code></pre>

<p>实现一个解析<code class="language-plaintext highlighter-rouge">字符串</code>为<code class="language-plaintext highlighter-rouge">Number</code>的<code class="language-plaintext highlighter-rouge">Factory</code>，可以定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>有了工厂接口，再编写一个工厂的实现类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberFactoryImpl</span> <span class="kd">implements</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>产品接口是<code class="language-plaintext highlighter-rouge">Number</code>，<code class="language-plaintext highlighter-rouge">NumberFactoryImpl</code>返回的实际产品是<code class="language-plaintext highlighter-rouge">BigDecimal</code>。</p>

<p>通常会在接口<code class="language-plaintext highlighter-rouge">Factory</code>中再定义一个静态方法<code class="language-plaintext highlighter-rouge">getFactory()</code>来返回真正的子类（在 <strong>Java 8</strong> 中，接口可以包含静态方法）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="c1">// 创建方法:</span>
    <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
    <span class="c1">// 获取工厂实例:</span>
    <span class="kd">static</span> <span class="nc">NumberFactory</span> <span class="nf">getFactory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">impl</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">NumberFactory</span> <span class="n">impl</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberFactoryImpl</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在客户端中，只需要和工厂接口<code class="language-plaintext highlighter-rouge">NumberFactory</code>以及抽象产品<code class="language-plaintext highlighter-rouge">Number</code>打交道：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NumberFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">NumberFactory</span><span class="o">.</span><span class="na">getFactory</span><span class="o">();</span>
<span class="nc">Number</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"123.456"</span><span class="o">);</span>
</code></pre></div></div>

<p>调用方可以完全忽略真正的工厂<code class="language-plaintext highlighter-rouge">NumberFactoryImpl</code>和实际的产品<code class="language-plaintext highlighter-rouge">BigDecimal</code>，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。</p>

<hr />

<p>实际上，大多数情况下并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Integer</code>既是产品又是静态工厂。它提供了静态方法<code class="language-plaintext highlighter-rouge">valueOf()</code>来创建<code class="language-plaintext highlighter-rouge">Integer</code>。那么这种方式和直接写<code class="language-plaintext highlighter-rouge">new Integer(100)</code>有何区别呢？</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Integer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">low</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">high</span><span class="o">)</span>
            <span class="k">return</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">cache</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="o">(-</span><span class="nc">IntegerCache</span><span class="o">.</span><span class="na">low</span><span class="o">)];</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>它的好处在于，<code class="language-plaintext highlighter-rouge">valueOf()</code>内部可能会使用<code class="language-plaintext highlighter-rouge">new</code>创建一个新的<code class="language-plaintext highlighter-rouge">Integer</code>实例，但也可能直接返回一个缓存的<code class="language-plaintext highlighter-rouge">Integer</code>实例。对于调用方来说，没必要知道<code class="language-plaintext highlighter-rouge">Integer</code>创建的细节。</p>

<p>工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>

<p>如果调用方直接使用<code class="language-plaintext highlighter-rouge">Integer n = new Integer(100)</code>，那么就失去了使用缓存优化的可能性。</p>

<hr />

<p>经常使用的另一个静态工厂方法是<code class="language-plaintext highlighter-rouge">List.of()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">);</span>
</code></pre></div></div>

<p>这个静态工厂方法接收可变参数，然后返回<code class="language-plaintext highlighter-rouge">List</code>接口。需要注意的是，调用方获取的产品总是<code class="language-plaintext highlighter-rouge">List</code>接口，而且并不关心它的实际类型。</p>

<p>即使调用方知道<code class="language-plaintext highlighter-rouge">List</code>产品的实际类型是<code class="language-plaintext highlighter-rouge">java.util.ImmutableCollections$ListN</code>，也不要去强制转型为子类，因为静态工厂方法<code class="language-plaintext highlighter-rouge">List.of()</code>保证返回<code class="language-plaintext highlighter-rouge">List</code>，但也完全可以修改为返回<code class="language-plaintext highlighter-rouge">java.util.ArrayList</code>。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p>

<p>总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p>

<hr />

<p>和<code class="language-plaintext highlighter-rouge">List.of()</code>类似，使用<code class="language-plaintext highlighter-rouge">MessageDigest</code>时，为了创建某个摘要算法，总是使用静态工厂方法<code class="language-plaintext highlighter-rouge">getInstance(String)</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MessageDigest</span> <span class="n">md5</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"MD5"</span><span class="o">);</span>
<span class="nc">MessageDigest</span> <span class="n">sha1</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA-1"</span><span class="o">);</span>
</code></pre></div></div>

<p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是<code class="language-plaintext highlighter-rouge">MessageDigest</code>这个抽象类。</p>

<h3 id="抽象工厂">抽象工厂</h3>

<blockquote>
  <p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>

<p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p>

<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p>

<pre><code class="language-ascii">                                ┌────────┐
                             ─ &gt;│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─&gt;│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ &gt;│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│
               └─────────┘     └─────────┘
</code></pre>

<p>这种模式有点类似于多个供应商负责提供一系列类型的产品。</p>

<p>假设希望为用户提供一个可以买荤素菜的环境，定义接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>定义好了抽象工厂（<code class="language-plaintext highlighter-rouge">ImeatAndVegetarianFactory</code>）以及两个抽象产品（<code class="language-plaintext highlighter-rouge">IMeat</code>和<code class="language-plaintext highlighter-rouge">IVegetarian</code>）。假设环境可以是超市也可以是菜市场，先写菜市场：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*菜市场*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MarketFactoryImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>然后就可以使用了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span><span class="k">new</span> <span class="nc">MarketFactoryImpl</span><span class="o">();</span><span class="c1">//菜市场</span>
<span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span><span class="c1">//菜市场的荤菜</span>
<span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span><span class="c1">//菜市场的素菜</span>
</code></pre></div></div>

<p>看起来似乎也没什么作用。</p>

<p>再写超市：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MeatDishesFromTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SupermarketImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>要使用，则只需要改动一下初始化的工厂就行了：即把<code class="language-plaintext highlighter-rouge">new MarketFactoryImpl();</code>改成<code class="language-plaintext highlighter-rouge">new SupermarketImpl();</code>。这下作用比较明显了。</p>

<p>还可以把这行也隐藏起来，这样用户就完全不会接触到具体实现了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span> <span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"超市"</span><span class="o">);</span>
        <span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span>
        <span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
    <span class="kd">static</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="nf">createFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"超市"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SupermarketImpl</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">MarketFactoryImpl</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未定义"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；</p>

<p>抽象工厂模式实现的关键点是定义工厂接口和产品接口，但如何实现工厂与产品本身需要留给具体的子类实现，客户端只和抽象工厂与抽象产品打交道。</p>

<hr />

<p>完整代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span> <span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"超市"</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
        <span class="n">f</span><span class="o">=</span><span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span>
        <span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
    <span class="kd">static</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="nf">createFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"超市"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SupermarketImpl</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">MarketFactoryImpl</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未定义"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/*菜市场*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MarketFactoryImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*超市*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SupermarketImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="生成器">生成器</h3>

<blockquote>
  <p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>

<p>生成器模式/建造者模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>

<p>使用Builder是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>

<p>以Markdown转HTML为例，直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># this is a heading</span>
</code></pre></div></div>

<p>转换成HTML就很简单：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>this is a heading<span class="nt">&lt;/h1&gt;</span>
</code></pre></div></div>

<p>因此，把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p>

<ul>
  <li>如果以<code class="language-plaintext highlighter-rouge">#</code>开头，使用<code class="language-plaintext highlighter-rouge">HeadingBuilder</code>转换；</li>
  <li>如果以<code class="language-plaintext highlighter-rouge">&gt;</code>开头，使用<code class="language-plaintext highlighter-rouge">QuoteBuilder</code>转换；</li>
  <li>如果以<code class="language-plaintext highlighter-rouge">---</code>开头，使用<code class="language-plaintext highlighter-rouge">HrBuilder</code>转换；</li>
  <li>其余使用<code class="language-plaintext highlighter-rouge">ParagraphBuilder</code>转换。</li>
</ul>

<p>这个<code class="language-plaintext highlighter-rouge">HtmlBuilder</code>写出来如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HtmlBuilder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HeadingBuilder</span> <span class="n">headingBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HeadingBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">HrBuilder</span> <span class="n">hrBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HrBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">ParagraphBuilder</span> <span class="n">paragraphBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParagraphBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">QuoteBuilder</span> <span class="n">quoteBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QuoteBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toHtml</span><span class="o">(</span><span class="nc">String</span> <span class="n">markdown</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="nc">String</span> <span class="o">[]</span><span class="n">s</span><span class="o">=</span><span class="n">markdown</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">line</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"#"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">headingBuilder</span><span class="o">.</span><span class="na">buildHeading</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">quoteBuilder</span><span class="o">.</span><span class="na">buildQuote</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"---"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">hrBuilder</span><span class="o">.</span><span class="na">buildHr</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">paragraphBuilder</span><span class="o">.</span><span class="na">buildParagraph</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code class="language-plaintext highlighter-rouge">XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p>

<p>这样一来，只需要针对每一种类型编写不同的Builder。例如，针对以<code class="language-plaintext highlighter-rouge">#</code>开头的行，需要<code class="language-plaintext highlighter-rouge">HeadingBuilder</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HeadingBuilder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">buildHeading</span><span class="o">(</span><span class="nc">String</span> <span class="n">line</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">++;</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"&lt;h%d&gt;%s&lt;/h%d&gt;"</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">line</span><span class="o">.</span><span class="na">trim</span><span class="o">(),</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>

<p><code class="language-plaintext highlighter-rouge">JavaMail</code>的<code class="language-plaintext highlighter-rouge">MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code class="language-plaintext highlighter-rouge">MimeMessage</code>。</p>

<p>很多时候，可以简化Builder模式，以链式调用的方式来创建对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"123"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"456"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"789"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div>

<p>生成器模式旨在通过一步一步构建复杂对象来创建对象。在使用 <code class="language-plaintext highlighter-rouge">JavaBean</code> 的 <code class="language-plaintext highlighter-rouge">set</code> 方法构建 <code class="language-plaintext highlighter-rouge">JavaBean</code> 时，虽然没有明确的构建步骤，但通过设置各个属性来构建对象的过程与生成器模式中逐步构建对象的思想相似。因此，可以将使用 <code class="language-plaintext highlighter-rouge">JavaBean</code> 的 <code class="language-plaintext highlighter-rouge">set</code> 方法构建 <code class="language-plaintext highlighter-rouge">JavaBean</code> 视为一种类似生成器模式的实现方式。</p>

<p><code class="language-plaintext highlighter-rouge">lombok</code>有个<code class="language-plaintext highlighter-rouge">@Builder</code> 可以使对象实现 builder 功能:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">build</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">a</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">b</span><span class="o">(</span><span class="s">"2"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">build</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="nd">@ToString</span>
<span class="nd">@Builder</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>生成的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">b</span><span class="o">;</span>
    <span class="no">A</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ABuilder</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ABuilder</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"A(a="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ABuilder</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">a</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">b</span><span class="o">;</span>

        <span class="nc">ABuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">ABuilder</span> <span class="nf">a</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">ABuilder</span> <span class="nf">b</span><span class="o">(</span><span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="no">A</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"A.ABuilder(a="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>内部生成器的<code class="language-plaintext highlighter-rouge">toString</code>会自动生成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">.</span><span class="na">ABuilder</span> <span class="n">b</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">a</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">b</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span><span class="c1">//A.ABuilder(a=1, b=2)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Builder</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="原型">原型</h3>

<blockquote>
  <p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>

<p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p>

<p>我们举个例子：如果我们已经有了一个<code class="language-plaintext highlighter-rouge">String[]</code>数组，想再创建一个一模一样的<code class="language-plaintext highlighter-rouge">String[]</code>数组，怎么写？</p>

<p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 原型:</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">original</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">,</span> <span class="s">"Banana"</span> <span class="o">};</span>
<span class="c1">// 新对象:</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div>

<p>对于普通类，如何实现原型拷贝？Java的<code class="language-plaintext highlighter-rouge">Object</code>提供了一个<code class="language-plaintext highlighter-rouge">clone()</code>方法，它的意图就是复制一个新的对象出来，需要实现一个<code class="language-plaintext highlighter-rouge">Cloneable</code>接口来标识一个对象是“可复制”的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="c1">// 复制新对象并返回:</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">std</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">score</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用的时候，因为<code class="language-plaintext highlighter-rouge">clone()</code>的方法签名是定义在<code class="language-plaintext highlighter-rouge">Object</code>中，返回类型也是<code class="language-plaintext highlighter-rouge">Object</code>，所以要强制转型，比较麻烦。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
<span class="nc">Object</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">student</span><span class="o">);</span><span class="c1">//test.Student@6f4a47c7</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">clone</span><span class="o">);</span><span class="c1">//test.Student@ae13544</span>
</code></pre></div></div>

<p>实际上，使用原型模式更好的方式是定义一个<code class="language-plaintext highlighter-rouge">copy()</code>方法，返回明确的类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="c1">// 复制新对象并返回:</span>
    <span class="kd">public</span> <span class="nc">Student</span> <span class="nf">copy</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">std</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">score</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>

<h3 id="单例">单例</h3>

<blockquote>
  <p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>

<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>

<p>因为这个类只有一个实例，因此，自然不能让调用方使用<code class="language-plaintext highlighter-rouge">new ClassName()</code>来创建实例了。所以，单例的构造方法必须是<code class="language-plaintext highlighter-rouge">private</code>，这样就防止了调用方自己创建实例。然后可以对外提供一个静态方法，返回一个固定的实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="c1">// 静态字段引用唯一实例:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>

    <span class="c1">// 通过静态方法返回实例:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// private构造方法保证外部无法实例化:</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//相同实例</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//相同实例</span>
</code></pre></div></div>

<p>或者直接把静态变量设置为<code class="language-plaintext highlighter-rouge">public</code>。</p>

<p>单例模式的实现方式很简单：</p>

<ol>
  <li>只有<code class="language-plaintext highlighter-rouge">private</code>构造方法，确保外部无法实例化；</li>
  <li>通过<code class="language-plaintext highlighter-rouge">private static</code>变量持有唯一实例，保证全局唯一性；</li>
  <li>通过<code class="language-plaintext highlighter-rouge">public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>

<p>Java标准库有一些类就是单例，例如<code class="language-plaintext highlighter-rouge">Runtime</code>这个类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Runtime</span> <span class="n">runtime</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">();</span>
</code></pre></div></div>

<h4 id="延迟加载">延迟加载</h4>

<p>即在调用方第一次调用<code class="language-plaintext highlighter-rouge">getInstance()</code>时才初始化全局唯一实例，类似这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>但这种写法在多线程中是错误的，必须对整个方法进行加锁，但加锁会严重影响并发性能，得不偿失。</p>

<hr />

<h5 id="双重检查">双重检查</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上述描述似乎已经解决了我们面临的所有问题，但实际上，从 JVM 的角度讲，这些代码仍然可能发生错误。</p>

<p>对于 JVM 而言，它执行的是一个个 Java 指令。在 Java 指令中创建对象和赋值操作是分开进行的，也就是说<code class="language-plaintext highlighter-rouge">INSTANCE= new Singleton();</code>语句是分两步执行的。但是 JVM 并不保证这两个操作的先后顺序，即指令重排，也就是说有可能 JVM 会为新的 <code class="language-plaintext highlighter-rouge">Singleton</code> 实例分配空间，然后直接赋值给 <code class="language-plaintext highlighter-rouge">instance</code> 成员，然后再去初始化这个 <code class="language-plaintext highlighter-rouge">Singleton</code> 实例。这样就使出错成为了可能。</p>

<p>不过在<strong>JDK 5</strong>以及更高版本扩展了<code class="language-plaintext highlighter-rouge">volatile</code>的语义，以便系统将不允许<code class="language-plaintext highlighter-rouge">volatile</code>的写相对于任何之前的读或写重新排序，并且<code class="language-plaintext highlighter-rouge">volatile</code>的读也不能相对于任何后续的读或写重新排序。</p>

<p>因此，<strong>为<code class="language-plaintext highlighter-rouge">INSTANCE</code>变量添加<code class="language-plaintext highlighter-rouge">volatile</code>就修复了这个问题</strong>。</p>

<p>另外，如果<code class="language-plaintext highlighter-rouge">INSTANCE</code>变量是一个不可变对象，则也不用加<code class="language-plaintext highlighter-rouge">volatile</code>，就如同<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">float</code>一样，他们的赋值操作是原子的。（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">参见</a>）</p>

<hr />

<h5 id="通过内部类实现">通过内部类实现</h5>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonContainer</span><span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 静态内部类只有在被使用时才会装载，静态属性只会在第一次装载时初始化
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nc">SingletonContainer</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</p>

<p>这样第一次调用<code class="language-plaintext highlighter-rouge">getInstance</code>的时候，JVM能够保证<code class="language-plaintext highlighter-rouge">INSTANCE</code>只被创建一次，并且会保证把赋值给<code class="language-plaintext highlighter-rouge">INSTANCE</code>的内存初始化完毕。此外该方法也只会在第一次调用的时候使用互斥机制。</p>

<p><code class="language-plaintext highlighter-rouge">INSTANCE</code> 是在第一次加载 <code class="language-plaintext highlighter-rouge">SingletonContainer</code> 类时被创建的，而 <code class="language-plaintext highlighter-rouge">SingletonContainer</code> 类则在调用 <code class="language-plaintext highlighter-rouge">getInstance</code> 方法的时候才会被加载，因此也实现了延迟加载。</p>

<hr />

<p>要防止通过<strong>反射强行调用私有构造方法</strong>，可以在构造方法添加代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">SingletonContainer</span><span class="o">.</span><span class="na">INSTANCE</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>反射测试：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Singleton</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">();</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span><span class="c1">//java.lang.RuntimeException: !</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">singleton</span><span class="o">);</span>
</code></pre></div></div>

<p>正常调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//test.Singleton@ae13544</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//test.Singleton@ae13544</span>
</code></pre></div></div>

<hr />

<h4 id="序列化破坏单例">序列化破坏单例</h4>

<p>单例对象创建好之后，有时需要将对象序列化然后写入磁盘，在需要时从磁盘中读取对象并加载至内存，反序列化后的对象会重新分配内存，如果序列化的目标对象恰好是单例对象，就会破坏单例模式。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">Singleton</span> <span class="n">s2</span><span class="o">;</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="n">s2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//test.Singleton@7494f96a</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//test.Singleton@37883b97</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>添加一个<code class="language-plaintext highlighter-rouge">readResolve()</code>,就能保证反序列化是同一个实例了</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在 Java 的序列化中，当对象被序列化时，如果类中定义了 <code class="language-plaintext highlighter-rouge">readResolve</code> 方法，并且该方法返回一个对象，那么在反序列化时<strong>会调用该方法来获取对象</strong>，而<strong>不是通过从流中反序列化创建一个新的对象</strong>。</p>

<p>这意味着 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法可以用来控制反序列化过程中返回的对象，<strong>可以在方法中返回任何想要的对象，而不受反序列化的影响</strong>。如果一个类写了 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法，并且在方法中返回了特定的对象，那么反序列化过程<strong>就会返回这个方法中指定的对象</strong>，而<strong>不会</strong>从文件中重新构造对象。示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"序列化前"</span><span class="o">;</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//test.Singleton@561b6512</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s2</span><span class="o">;</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="n">s2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//test.Singleton@c86b9e3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//null</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>先运行<code class="language-plaintext highlighter-rouge">test1()</code>,然后等JVM关闭后重新运行<code class="language-plaintext highlighter-rouge">test2()</code>,模拟序列化的实际运用场景，这个场景下内存地址肯定不一样，但后设置的<code class="language-plaintext highlighter-rouge">name</code>值也丢了。</p>

<p>实际上，<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法的作用是控制对象的反序列化过程，可以用来确保反序列化后的对象符合特定的要求，或者实现单例模式等。</p>

<hr />

<p>那么我们保存的<code class="language-plaintext highlighter-rouge">s.obj</code>序列化文件就这么废了吗？也不一定，<strong>序列化仅涉及对象的状态（即实例变量）</strong>，不包括类的方法。序列化的主要目的是保存对象的状态，以便在稍后可以将其完全恢复为原始状态。把<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法注释掉不就好了。</p>

<p>示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"序列化前"</span><span class="o">;</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//Singleton{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Singleton{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>运行<code class="language-plaintext highlighter-rouge">test1()</code>生成<code class="language-plaintext highlighter-rouge">s.obj</code>。删除<code class="language-plaintext highlighter-rouge">readResolve</code>，<code class="language-plaintext highlighter-rouge">运行test2()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//Singleton{name='序列化前'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(((</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">x</span><span class="o">).</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Singleton{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>正常恢复，没有问题，那么试试删除<code class="language-plaintext highlighter-rouge">public String toString()</code>，提示：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.io.InvalidClassException: test.Singleton; local class incompatible: stream classdesc serialVersionUID = 5155019565252345970, local class serialVersionUID = -6864115338217441473
</code></pre></div></div>

<p>改动太大了，改变了<code class="language-plaintext highlighter-rouge">serialVersionUID</code>，那么显示的在类里指定：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">5155019565252345970L</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>再运行<code class="language-plaintext highlighter-rouge">test2()</code>,正常反序列化，只是这次<code class="language-plaintext highlighter-rouge">toString</code>没有了：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test.Singleton@79d8407f
序列化前
</code></pre></div></div>

<p>实际上，非重写的方法可以随便添加修改删除，而重写的方法不能动，动了就会导致<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号。（显示指定<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号就好了）</p>

<hr />

<h4 id="使用枚举">使用枚举</h4>

<p>Java保证枚举类的每个枚举都是单例，所以只需要编写一个只有一个枚举的类即可：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">World</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
	<span class="no">INSTANCE</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"world"</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code class="language-plaintext highlighter-rouge">World</code>类在调用方看来就可以这么用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</code></pre></div></div>

<p>使用枚举实现Singleton也避免了即序列化和反序列化会绕过普通类的<code class="language-plaintext highlighter-rouge">private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p>

<p>枚举在序列化和反序列化过程中<strong>会丢失枚举常量中的普通字段的值</strong>。这是因为枚举在序列化时只保留了枚举常量的名称，并没有保存其他字段的状态。在反序列化时，只会根据枚举常量的名称重新构建枚举常量，而普通字段的值需要在程序中重新设置。即：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"序列化前"</span><span class="o">);</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span><span class="c1">//World{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//序列化前</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">World</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">World</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//World{name='null'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//null</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">World</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
    <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"World{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>用有参构造器设置就好了，虽然并没有改变问题的根本，也是个曲线的好办法。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span><span class="c1">//World{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">World</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">World</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//World{name='null'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//null</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">World</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
    <span class="no">INSTANCE</span><span class="o">(</span><span class="s">"序列化前"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nc">World</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"World{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>而枚举天然就不能使用反射调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">World</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">World</span> <span class="n">world</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span><span class="c1">//java.lang.NoSuchMethodException: test.World.&lt;init&gt;(java.lang.String)</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">world</span><span class="o">);</span>
</code></pre></div></div>

<p>找不到指定类型的构造方法，看看<code class="language-plaintext highlighter-rouge">java.lang.Enum</code>的源码，只有：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="nf">Enum</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ordinal</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ordinal</span> <span class="o">=</span> <span class="n">ordinal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>唯一构造函数。程序员无法调用此构造函数。它供编译器发出的代码使用，以响应枚举类型声明。形参:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">name</code> – - 此枚举常量的名称，它是用于声明它的标识符。</li>
  <li><code class="language-plaintext highlighter-rouge">ordinal</code> – - 此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）</li>
</ul>

<p>那么改成这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">World</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">World</span> <span class="n">world</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">"枚举名"</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="s">"test"</span><span class="o">);</span><span class="c1">//java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">world</span><span class="o">);</span>
</code></pre></div></div>

<p>异常位置：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@CallerSensitive</span>
<span class="nd">@ForceInline</span> <span class="c1">// to ensure Reflection.getCallerClass optimization</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">newInstance</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">initargs</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InstantiationException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span><span class="o">,</span>
           <span class="nc">IllegalArgumentException</span><span class="o">,</span> <span class="nc">InvocationTargetException</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">override</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="nc">Reflection</span><span class="o">.</span><span class="na">getCallerClass</span><span class="o">();</span>
        <span class="n">checkAccess</span><span class="o">(</span><span class="n">caller</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">modifiers</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">clazz</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()</span> <span class="o">&amp;</span> <span class="nc">Modifier</span><span class="o">.</span><span class="na">ENUM</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Cannot reflectively create enum objects"</span><span class="o">);</span>
    <span class="nc">ConstructorAccessor</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">constructorAccessor</span><span class="o">;</span>   <span class="c1">// read volatile</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ca</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">acquireConstructorAccessor</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="no">T</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">ca</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">initargs</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">inst</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code class="language-plaintext highlighter-rouge">new</code>操作符：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span> <span class="c1">// 表示一个单例组件</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p>

<h2 id="结构型模式">结构型模式</h2>

<p>结构型模式主要关注如何组合不同的对象以获得更好、更灵活的结构。尽管面向对象的继承机制提供了基本的子类扩展父类功能的能力，但结构型模式不仅限于简单的继承，而更多地通过组合和运行时的动态组合来实现更灵活的功能。</p>

<p>主要关注如何组合类或对象以获得更大的结构，并且提供了一种方式来定义类之间的关系，以确保系统的某一部分变化不会影响其他部分。</p>

<p>结构型模式包括以下几种常见的模式：</p>

<ol>
  <li><strong>适配器模式（Adapter Pattern）</strong>：将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
  <li><strong>桥接模式（Bridge Pattern）</strong>：将抽象部分与它的实现部分<strong>分离</strong>，使它们可以独立地变化。</li>
  <li><strong>组合模式（Composite Pattern）</strong>：将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</li>
  <li><strong>装饰器模式（Decorator Pattern）</strong>：动态地给一个对象添加一些额外的职责，就<strong>增加功能</strong>来说，装饰模式比生成子类更为灵活。</li>
  <li><strong>外观模式（Facade Pattern）</strong>：为子系统中的一组接口提供一个统一的接口，外观模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</li>
  <li><strong>享元模式（Flyweight Pattern）</strong>：运用共享技术有效地支持大量细粒度的对象。</li>
  <li><strong>代理模式（Proxy Pattern）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li>
</ol>

<p>适配器就是转换兼容，桥接就是拆分可复用部分，组合就是树形结构，装饰器就是在不改变类的情况下增强类功能，外观就是封装，享元就是缓存不变类，代理模式就是控制限制类。</p>

<h3 id="适配器">适配器</h3>

<blockquote>
  <p>将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>

<p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，则中间需要一个适配器转换。将下面的类传入线程是不行的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">a</span><span class="o">);</span><span class="c1">//没有实现Runnable接口，所以不能向上转型为Runnable</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>办法一是改写<code class="language-plaintext highlighter-rouge">A</code>类，把实现的<code class="language-plaintext highlighter-rouge">Callable</code>改为<code class="language-plaintext highlighter-rouge">Runnable</code>，但这样做不好，因为<code class="language-plaintext highlighter-rouge">A</code>有可能在其他地方作为<code class="language-plaintext highlighter-rouge">Callable</code>被引用，改写<code class="language-plaintext highlighter-rouge">Task</code>的接口，会导致其他正常工作的代码无法编译。</p>

<p>另一个办法不用改写<code class="language-plaintext highlighter-rouge">A</code>类，而是用一个Adapter，把这个<code class="language-plaintext highlighter-rouge">Callable</code>接口“变成”<code class="language-plaintext highlighter-rouge">Runnable</code>接口，这样，就可以正常编译：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">CallableToRunnableAdapter</span><span class="o">(</span><span class="n">a</span><span class="o">));</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>

<p>这个<code class="language-plaintext highlighter-rouge">CallableToRunnableAdapter</code>类就是Adapter，它接收一个<code class="language-plaintext highlighter-rouge">Callable</code>，输出一个<code class="language-plaintext highlighter-rouge">Runnable</code>。实现非常简单：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CallableToRunnableAdapter</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CallableToRunnableAdapter</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>编写一个Adapter的步骤如下：</p>

<ol>
  <li>实现目标接口，这里是<code class="language-plaintext highlighter-rouge">Runnable</code>；</li>
  <li>内部持有一个待转换接口的引用，这里是通过字段持有<code class="language-plaintext highlighter-rouge">Callable</code>接口；</li>
  <li>在目标接口的实现方法内部，调用待转换接口的方法。</li>
</ol>

<p>这样一来，Thread就可以接收这个<code class="language-plaintext highlighter-rouge">RunnableAdapter</code>，因为它实现了<code class="language-plaintext highlighter-rouge">Runnable</code>接口。<code class="language-plaintext highlighter-rouge">Thread</code>作为调用方，它会调用<code class="language-plaintext highlighter-rouge">RunnableAdapter</code>的<code class="language-plaintext highlighter-rouge">run()</code>方法，在这个<code class="language-plaintext highlighter-rouge">run()</code>方法内部，又调用了<code class="language-plaintext highlighter-rouge">Callable</code>的<code class="language-plaintext highlighter-rouge">call()</code>方法，相当于<code class="language-plaintext highlighter-rouge">Thread</code>通过一层转换，间接调用了<code class="language-plaintext highlighter-rouge">Callable</code>的<code class="language-plaintext highlighter-rouge">call()</code>方法。</p>

<p>使用lambda也是可以的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">a</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从某种程度上说，这确实可以被看作是一种简单的转换器思想，通过实现 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口，将 <code class="language-plaintext highlighter-rouge">Callable</code> 接口的 <code class="language-plaintext highlighter-rouge">call</code> 方法转换成了 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口的 <code class="language-plaintext highlighter-rouge">run</code> 方法，使得原本的 <code class="language-plaintext highlighter-rouge">Callable</code> 对象 <code class="language-plaintext highlighter-rouge">a</code> 可以在 <code class="language-plaintext highlighter-rouge">Thread</code> 中被使用。</p>

<p>虽然这种用法不是传统意义上的转换器模式，但从某种程度上可以看作是一种类似的思想，即通过接口或类的适配来实现不同对象之间的协同工作。</p>

<p>如果不局限与接口或类的适配，那么实例化类也沾点转换器思想，因为将数据整合“转换“为了类实例。</p>

<p>向上转型和向下转型在某种程度上也可以被视为适配器思想的一种体现。向上转型是指将子类对象转换为父类对象的过程，这样做可以使得子类对象可以被当做父类对象对待，从而实现多态性。这种转型可以被看作是一种接口的适配，将子类对象适配成了父类对象。</p>

<p>向下转型是指将父类对象转换为子类对象的过程。这种转型可能涉及到类型检查和转换，以确保父类对象确实可以被转换为子类对象。向下转型也可以被视为一种适配器思想，将父类对象适配成了子类对象，以便对其进行特定的操作或方法调用。</p>

<hr />

<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code class="language-plaintext highlighter-rouge">String[]</code>，但是需要<code class="language-plaintext highlighter-rouge">List</code>接口时，可以用一个Adapter：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">exist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"Good"</span><span class="o">,</span> <span class="s">"morning"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"and"</span><span class="o">,</span> <span class="s">"Alice"</span><span class="o">};</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">exist</span><span class="o">));</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">List&lt;T&gt; Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code class="language-plaintext highlighter-rouge">List</code>。</p>

<p>假设有一个<code class="language-plaintext highlighter-rouge">InputStream</code>，但希望调用<code class="language-plaintext highlighter-rouge">readText(Reader)</code>这个方法，但它的参数类型是<code class="language-plaintext highlighter-rouge">Reader</code>而不是<code class="language-plaintext highlighter-rouge">InputStream</code>，怎么办？当然是使用适配器，把<code class="language-plaintext highlighter-rouge">InputStream</code>“变成”<code class="language-plaintext highlighter-rouge">Reader</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newInputStream</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"/path/to/file"</span><span class="o">));</span>
<span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="n">readText</span><span class="o">(</span><span class="n">reader</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">InputStreamReader</code>就是Java标准库提供的<code class="language-plaintext highlighter-rouge">Adapter</code>，它负责把一个<code class="language-plaintext highlighter-rouge">InputStream</code>适配为<code class="language-plaintext highlighter-rouge">Reader</code>。类似的还有<code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>。</p>

<p>除了前面提到的对象适配器和类适配器之外，适配器思想还可以体现在以下几个方面：</p>

<ol>
  <li><strong>接口适配器模式（Interface Adapter Pattern）</strong>：当一个接口中定义了许多方法，但只有部分方法需要被实现时，可以创建一个抽象类实现该接口，并为接口中的每个方法提供一个空实现。这样在需要使用该接口时，只需要继承这个抽象类，重写需要的方法即可，避免了在实现类中实现所有方法的繁琐性。</li>
  <li><strong>数据适配器</strong>：将一个数据格式转换为另一个数据格式的过程可以看作是一种适配器思想的应用。例如，将一个JSON格式的数据转换为XML格式的数据，或者将一个数据结构转换为另一个数据结构以适应不同的应用场景。</li>
  <li><strong>协议适配器</strong>：在网络通信中，不同的设备或系统可能使用不同的通信协议。协议适配器用于将一个通信协议转换为另一个通信协议，以实现不同设备或系统之间的通信。</li>
  <li><strong>电源适配器</strong>：在不同国家或地区，电源插头的形状和电压标准可能不同。电源适配器用于将一个电源插头转换为另一个电源插头，以适应不同地区的电源标准。</li>
</ol>

<h3 id="桥接">桥接</h3>

<blockquote>
  <p>将抽象部分与它的实现<strong>部分分离</strong>，使它们都可以独立地变化。</p>
</blockquote>

<p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p>

<pre><code class="language-ascii">                   ┌───────┐
                   │  Car  │
                   └───────┘
                       ▲
    ┌──────────────────┼───────────────────┐
    │                  │                   │
┌───────┐          ┌───────┐          ┌───────┐
│BigCar │          │TinyCar│          │BossCar│
└───────┘          └───────┘          └───────┘
    ▲                  ▲                  ▲
    │                  │                  │
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │
      └───────────────┘  └───────────────┘  └───────────────┘
</code></pre>

<p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p>

<p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p>

<p>在桥接模式中，首先把<code class="language-plaintext highlighter-rouge">Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。</p>

<p>首先定义抽象类<code class="language-plaintext highlighter-rouge">Car</code>，它引用一个<code class="language-plaintext highlighter-rouge">Engine</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="c1">// 引用Engine:</span>
    <span class="kd">protected</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>紧接着，在一个“修正”的抽象类<code class="language-plaintext highlighter-rouge">RefinedCar</code>中定义一些<strong>额外操作</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RefinedCar</span> <span class="kd">extends</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">RefinedCar</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"驾驶 "</span> <span class="o">+</span> <span class="n">getBrand</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 汽车..."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">getBrand</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这样一来，最终的不同品牌继承自<code class="language-plaintext highlighter-rouge">RefinedCar</code>，例如<code class="language-plaintext highlighter-rouge">BossCar</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">BossCar</span> <span class="kd">extends</span> <span class="nc">RefinedCar</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BossCar</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getBrand</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Boss"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>而针对每一种引擎，继承自<code class="language-plaintext highlighter-rouge">Engine</code>，例如<code class="language-plaintext highlighter-rouge">HybridEngine</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HybridEngine</span> <span class="kd">implements</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"启动混合引擎"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的<code class="language-plaintext highlighter-rouge">Car</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RefinedCar</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BossCar</span><span class="o">(</span><span class="k">new</span> <span class="nc">HybridEngine</span><span class="o">());</span>
<span class="n">car</span><span class="o">.</span><span class="na">drive</span><span class="o">();</span>
</code></pre></div></div>

<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code class="language-plaintext highlighter-rouge">Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code class="language-plaintext highlighter-rouge">RefinedCar</code>派生一个子类，任何<code class="language-plaintext highlighter-rouge">RefinedCar</code>的子类都可以和任何一种<code class="language-plaintext highlighter-rouge">Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>

<pre><code class="language-ascii">       ┌───────────┐
       │    Car    │
       └───────────┘
             ▲
             │
       ┌───────────┐       ┌─────────┐
       │RefinedCar │ ─ ─ ─&gt;│ Engine  │
       └───────────┘       └─────────┘
             ▲                  ▲
    ┌────────┼────────┐         │ ┌──────────────┐
    │        │        │         ├─│  FuelEngine  │
┌───────┐┌───────┐┌───────┐     │ └──────────────┘
│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐
└───────┘└───────┘└───────┘     ├─│ElectricEngine│
                                │ └──────────────┘
                                │ ┌──────────────┐
                                └─│ HybridEngine │
                                  └──────────────┘
</code></pre>

<p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>

<h3 id="组合">组合</h3>

<blockquote>
  <p>将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>

<p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p>

<p>在组合模式中，有两种主要的对象：叶子节点和容器节点。叶子节点表示树中的最终节点，它没有子节点；容器节点表示包含子节点的节点，它可以包含叶子节点和其他容器节点。</p>

<p>通过使用组合模式，可以将单个对象和组合对象都视为相同类型的对象，从而可以统一处理它们。例如，无论是操作单个文件还是操作整个文件夹（包含多个文件和文件夹），客户端都可以使用相同的方式来进行操作，这样就简化了客户端的代码逻辑。</p>

<p>总的来说，组合模式可以构建具有层次结构的对象，并且可以统一处理这些对象，提高代码的灵活性和可维护性。</p>

<p>在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。要以树的结构表示XML，先抽象出节点<code class="language-plaintext highlighter-rouge">Node</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">// 添加一个节点为子节点:</span>
    <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">);</span>
    <span class="c1">// 获取子节点:</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">();</span>
    <span class="c1">// 输出为XML:</span>
    <span class="nc">String</span> <span class="nf">toXml</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对于一个<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>这样的节点，称之为<code class="language-plaintext highlighter-rouge">ElementNode</code>，它可以作为容器包含多个子节点：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ElementNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nf">ElementNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">start</span> <span class="o">=</span> <span class="s">"&lt;"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"&gt;\n"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">end</span> <span class="o">=</span> <span class="s">"&lt;/"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"&gt;"</span><span class="o">;</span>
        <span class="nc">StringJoiner</span> <span class="n">sj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringJoiner</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">sj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">toXml</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">sj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对于普通文本，把它看作<code class="language-plaintext highlighter-rouge">TextNode</code>，它没有子节点：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TextNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">TextNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">text</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>此外，还可以有注释节点：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CommentNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CommentNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"&lt;!-- "</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s">" --&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>通过<code class="language-plaintext highlighter-rouge">ElementNode</code>、<code class="language-plaintext highlighter-rouge">TextNode</code>和<code class="language-plaintext highlighter-rouge">CommentNode</code>，就可以构造出一颗树：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"school"</span><span class="o">);</span>
<span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"classA"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Tom"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">)));</span>
<span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"classB"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Grace"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">CommentNode</span><span class="o">(</span><span class="s">"comment..."</span><span class="o">)));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">toXml</span><span class="o">());</span>
</code></pre></div></div>

<p>最后通过<code class="language-plaintext highlighter-rouge">root</code>节点输出的XML如下：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;school&gt;
&lt;classA&gt;
Tom
Alice
&lt;/classA&gt;
&lt;classB&gt;
Bob
Grace
&lt;!-- comment... --&gt;
&lt;/classB&gt;
&lt;/school&gt;
</code></pre></div></div>

<p>使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p>

<pre><code class="language-ascii">             ┌───────────┐
             │   Node    │
             └───────────┘
                   ▲
      ┌────────────┼────────────┐
      │            │            │
┌───────────┐┌───────────┐┌───────────┐
│ElementNode││ TextNode  ││CommentNode│
└───────────┘└───────────┘└───────────┘
</code></pre>

<p>作为容器节点的<code class="language-plaintext highlighter-rouge">ElementNode</code>又可以添加任意个<code class="language-plaintext highlighter-rouge">Node</code>，这样就可以构成层级结构。</p>

<p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p>

<p>文件形式的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 创建文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File1.txt"</span><span class="o">);</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File2.txt"</span><span class="o">);</span>

        <span class="c1">// 创建文件夹并添加文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">folder1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Folder1"</span><span class="o">);</span>
        <span class="n">folder1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file1</span><span class="o">);</span>
        <span class="n">folder1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file2</span><span class="o">);</span>

        <span class="c1">// 创建文件夹并添加文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">folder2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Folder2"</span><span class="o">);</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File3.txt"</span><span class="o">);</span>
        <span class="n">folder2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file3</span><span class="o">);</span>

        <span class="c1">// 将文件夹添加到根文件夹</span>
        <span class="nc">FileSystemComponent</span> <span class="n">rootFolder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Root"</span><span class="o">);</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder1</span><span class="o">);</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder2</span><span class="o">);</span>

        <span class="c1">// 打印整个文件系统</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">FileSystemComponent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">File</span> <span class="kd">extends</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">File</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"File: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Folder</span> <span class="kd">extends</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">FileSystemComponent</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">Folder</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"Folder: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span> <span class="o">:</span> <span class="n">children</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">component</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"\t"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="装饰器">装饰器</h3>

<blockquote>
  <p>动态地给一个对象<strong>添加一些额外的职责</strong>。就增加功能来说，相比生成子类更为灵活。</p>
</blockquote>

<p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p>

<p>在Java标准库中，<code class="language-plaintext highlighter-rouge">InputStream</code>是抽象类，<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">ServletInputStream</code>、<code class="language-plaintext highlighter-rouge">Socket.getInputStream()</code>这些<code class="language-plaintext highlighter-rouge">InputStream</code>都是最终数据源。</p>

<p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。</p>

<p>Decorator模式的目的就是一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得想要的功能。</p>

<p>例如：给<code class="language-plaintext highlighter-rouge">FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建原始的数据源:</span>
<span class="nc">InputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">);</span>
<span class="c1">// 增加缓冲功能:</span>
<span class="nc">InputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
<span class="c1">// 增加解压缩功能:</span>
<span class="nc">InputStream</span> <span class="n">gis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>
</code></pre></div></div>

<p>或者一次性写成这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span> <span class="c1">// 第二层装饰</span>
                        <span class="k">new</span> <span class="nf">BufferedInputStream</span><span class="o">(</span> <span class="c1">// 第一层装饰</span>
                            <span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">)</span> <span class="c1">// 核心功能</span>
                        <span class="o">));</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>和<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>实际上都是从<code class="language-plaintext highlighter-rouge">FilterInputStream</code>继承的，这个<code class="language-plaintext highlighter-rouge">FilterInputStream</code>就是一个抽象的Decorator。把Decorator模式画出来如下：</p>

<pre><code class="language-ascii">             ┌───────────┐
             │ Component │
             └───────────┘
                   ▲
      ┌────────────┼─────────────────┐
      │            │                 │
┌───────────┐┌───────────┐     ┌───────────┐
│ComponentA ││ComponentB │...  │ Decorator │
└───────────┘└───────────┘     └───────────┘
                                     ▲
                              ┌──────┴──────┐
                              │             │
                        ┌───────────┐ ┌───────────┐
                        │DecoratorA │ │DecoratorB │...
                        └───────────┘ └───────────┘
</code></pre>

<p>最顶层的<code class="language-plaintext highlighter-rouge">Component</code>是接口，对应到IO的就是<code class="language-plaintext highlighter-rouge">InputStream</code>这个抽象类。<code class="language-plaintext highlighter-rouge">ComponentA</code>、<code class="language-plaintext highlighter-rouge">ComponentB</code>是实际的子类，对应到IO的就是<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code class="language-plaintext highlighter-rouge">FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>、<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>等。</p>

<p>Decorator模式实际上把核心功能和附加功能给分开了。核心功能指<code class="language-plaintext highlighter-rouge">FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。</p>

<p>如果要新增核心功能，就增加Component的子类，例如<code class="language-plaintext highlighter-rouge">ByteInputStream</code>。如果要增加附加功能，就增加Decorator的子类，例如<code class="language-plaintext highlighter-rouge">CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>

<p>如果要设计完整的Decorator模式，应该如何设计？</p>

<p>假设需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p>

<p>首先，仍然需要定义顶层接口<code class="language-plaintext highlighter-rouge">TextNode</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="c1">// 设置text:</span>
    <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">);</span>
    <span class="c1">// 获取text:</span>
    <span class="nc">String</span> <span class="nf">getText</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对于核心节点，例如<code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>，它需要从<code class="language-plaintext highlighter-rouge">TextNode</code>直接继承：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpanNode</span> <span class="kd">implements</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"&lt;span&gt;"</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s">"&lt;/span&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为了实现Decorator模式，需要有一个抽象的Decorator类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">NodeDecorator</span> <span class="kd">implements</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="c1">//注意这里也实现了TextNode接口</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="nc">TextNode</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="nf">NodeDecorator</span><span class="o">(</span><span class="nc">TextNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个<code class="language-plaintext highlighter-rouge">NodeDecorator</code>类的核心是持有一个<code class="language-plaintext highlighter-rouge">TextNode</code>，即将要把功能附加到的<code class="language-plaintext highlighter-rouge">TextNode</code>实例。接下来就可以写一个加粗功能：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoldDecorator</span> <span class="kd">extends</span> <span class="nc">NodeDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BoldDecorator</span><span class="o">(</span><span class="nc">TextNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//重写加了内容</span>
        <span class="k">return</span> <span class="s">"&lt;b&gt;"</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span> <span class="o">+</span> <span class="s">"&lt;/b&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TextNode</span> <span class="n">n1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SpanNode</span><span class="o">();</span><span class="c1">//外层&lt;span&gt;</span>
<span class="n">n1</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span><span class="c1">//正常修改text</span>
<span class="nc">TextNode</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoldDecorator</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span><span class="c1">//getText时加一个&lt;b&gt;包围原内容</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n2</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//调用栈：n2.getText()-&gt;n1.getText()</span>

<span class="nc">TextNode</span> <span class="n">n3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoldDecorator</span><span class="o">(</span><span class="n">n2</span><span class="o">);</span><span class="c1">//getText时加一个&lt;b&gt;包围原内容</span>
<span class="c1">//调用栈：n3.getText()-&gt;n2.getText()-&gt;n1.getText()</span>
<span class="c1">// n1返回text内容，然后n2加&lt;b&gt;返回，然后n1加&lt;b&gt;返回</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n3</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//&lt;b&gt;&lt;b&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/b&gt;&lt;/b&gt;</span>
<span class="c1">//调用栈：n3.setText()-&gt;n2.setText()-&gt;n1.setText()-&gt;this.text = text;</span>
<span class="n">n3</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"HI"</span><span class="o">);</span><span class="c1">//只修改了text</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n3</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//&lt;b&gt;&lt;b&gt;&lt;span&gt;HI&lt;/span&gt;&lt;/b&gt;&lt;/b&gt;</span>
</code></pre></div></div>

<p>类似的，可以继续加<code class="language-plaintext highlighter-rouge">ItalicDecorator</code>、<code class="language-plaintext highlighter-rouge">UnderlineDecorator</code>等。</p>

<hr />

<p><strong>装饰器与桥接模式</strong></p>

<p>装饰器和桥接的目的都是降低继承中衍生的子类的数量。</p>

<p>桥接是通过把一个组件及其子类作为另一总体的字段引用实现功能组合，也可以用多个组件来拼合总体。桥接的子类是负责总体的局部功能，是构成性的，是必要的。</p>

<p>装饰器则在大类下创建一个装饰器的子族，不管是主要部件还是装饰器都隶属于这个大类，所以装饰器可以不断嵌套。装饰器则是对已经具有了完整功能的总体进行修饰，是附加性的，是可选的。</p>

<h3 id="外观">外观</h3>

<blockquote>
  <p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</p>
</blockquote>

<p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p>

<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>

<p>以注册公司为例，假设注册公司需要三步：</p>

<ol>
  <li>向工商局申请公司营业执照；</li>
  <li>在银行开设账户；</li>
  <li>在税务局开设纳税号。</li>
</ol>

<p>以下是三个系统的接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 工商注册:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdminOfIndustry</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Company</span> <span class="nf">register</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 银行开户:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bank</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">openAccount</span><span class="o">(</span><span class="nc">String</span> <span class="n">companyId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 纳税登记:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Taxation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">applyTaxCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">companyId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Facade</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Company</span> <span class="nf">openCompany</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Company</span> <span class="n">c</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">admin</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">bankAccount</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">bank</span><span class="o">.</span><span class="na">openAccount</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">c</span><span class="o">.</span><span class="na">setBankAccount</span><span class="o">(</span><span class="n">bankAccount</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">taxCode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">taxation</span><span class="o">.</span><span class="na">applyTaxCode</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">c</span><span class="o">.</span><span class="na">setTaxCode</span><span class="o">(</span><span class="n">taxCode</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Company</span> <span class="n">c</span> <span class="o">=</span> <span class="n">facade</span><span class="o">.</span><span class="na">openCompany</span><span class="o">(</span><span class="s">"Facade Software Ltd."</span><span class="o">);</span>
</code></pre></div></div>

<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code class="language-plaintext highlighter-rouge">RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>

<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p>

<p>也就是说，我如果需要实现一个功能，比如打印水仙花数，我可以直接在main里写，也可以封装打印水仙花数为一个函数，然后通过主函数调用这个函数。这就是一种简单的外观模式的应用。外观模式的核心思想就是封装复杂的逻辑，提供一个简单的接口给客户端使用，从而简化客户端的操作。</p>

<h3 id="享元">享元</h3>

<blockquote>
  <p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>

<p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就<strong>没有必要</strong>，直接向调用方返回一个<strong>共享的实例</strong>就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>

<p>享元模式在Java标准库中有很多应用。包装类型如<code class="language-plaintext highlighter-rouge">Byte</code>、<code class="language-plaintext highlighter-rouge">Integer</code>都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以<code class="language-plaintext highlighter-rouge">Integer</code>为例，如果我们通过<code class="language-plaintext highlighter-rouge">Integer.valueOf()</code>这个静态工厂方法创建<code class="language-plaintext highlighter-rouge">Integer</code>实例，当传入的<code class="language-plaintext highlighter-rouge">int</code>范围在<code class="language-plaintext highlighter-rouge">-128</code>~<code class="language-plaintext highlighter-rouge">+127</code>之间时，会直接返回缓存的<code class="language-plaintext highlighter-rouge">Integer</code>实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">n2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="o">);</span> <span class="c1">// true</span>
</code></pre></div></div>

<p>对于<code class="language-plaintext highlighter-rouge">Byte</code>来说，因为它一共只有256个状态，所以，通过<code class="language-plaintext highlighter-rouge">Byte.valueOf()</code>创建的<code class="language-plaintext highlighter-rouge">Byte</code>实例，全部都是缓存对象。</p>

<p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的<strong>复用</strong>。</p>

<p>总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p>

<p>在实际应用中，<strong>享元模式主要应用于缓存</strong>，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p>

<p>以<code class="language-plaintext highlighter-rouge">Student</code>为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="c1">// 持有缓存:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Student</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 静态工厂方法:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Student</span> <span class="nf">create</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
        <span class="c1">// 先查找缓存:</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">std</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 未找到,创建新对象:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"create new Student(%s, %s)"</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">));</span>
            <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
            <span class="c1">// 放入缓存:</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">std</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 缓存中存在:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"return cached Student(%s, %s)"</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="na">id</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="na">name</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在实际应用中，经常使用成熟的缓存库，例如<a href="https://github.com/google/guava">Guava</a>的<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java">Cache</a>，因为它提供了最大缓存数量限制、定时过期等实用功能。</p>

<p>享元模式的设计思想是尽量复用已创建的对象，常用于工厂方法内部的优化。</p>

<p>单例模式是不允许创建新实例，只能使用一个实例。</p>

<p>而享元要求<strong>实例不变</strong>，才能把“创建一个新实例”的操作给优化成“直接返回一个缓存的实例”。</p>

<h3 id="代理">代理</h3>

<blockquote>
  <p>为其他对象提供一种代理以<strong>控制</strong>对这个对象的访问。</p>
</blockquote>

<p>代理模式，即Proxy，它和Adapter模式很类似。Adapter模式，它用于把A接口转换为B接口，即做兼容：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BAdapter</span> <span class="kd">implements</span> <span class="no">B</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">BAdapter</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">AProxy</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这是原始的，可以加功能，比如权限判断来限制访问，打印日志：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">aProxy</span><span class="o">=</span><span class="k">new</span> <span class="nc">AProxy</span><span class="o">(</span><span class="k">new</span> <span class="nc">AImpl</span><span class="o">());</span>
        <span class="n">aProxy</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">a</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AImpl</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"原功能"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">AProxy</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用前"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用后"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为什么不把权限检查的功能直接写到目标实例的内部？因为编写代码的原则有：</p>

<ul>
  <li>职责清晰：一个类只负责一件事；</li>
  <li>易于测试：一次只测一个功能。</li>
</ul>

<p>用Proxy实现这个权限检查，可以获得更清晰、更简洁的代码：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">A</code>接口：只定义接口；</li>
  <li><code class="language-plaintext highlighter-rouge">AImpl</code>类：只实现A接口的业务逻辑；</li>
  <li><code class="language-plaintext highlighter-rouge">AProxy</code>类：只实现A接口的日志输出代理。</li>
</ul>

<p>如果希望编写其他类型的代理，可以继续增加，一个套一个。</p>

<p>实际上权限检查、打印日志只是代理模式的一种应用。Proxy还广泛应用在：</p>

<p><strong>远程代理</strong></p>

<p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>

<p><strong>虚代理</strong></p>

<p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>

<p><strong>保护代理</strong></p>

<p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>

<p><strong>智能引用</strong></p>

<p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>

<p>代理模式和装饰器模式有一些相似之处，但它们的目的和使用方式略有不同：</p>

<ul>
  <li>
    <p><strong>装饰器模式</strong>：装饰器模式旨在动态地给对象<strong>添加额外的职责</strong>，而不改变其接口。它通常通过创建一个包装对象来包裹真实的对象，并在保持真实对象接口不变的情况下，增加额外的功能或责任。</p>
  </li>
  <li>
    <p><strong>代理模式</strong>：代理模式为其他对象提供一种代理以<strong>控制对这个对象的访问</strong>。代理类通常在客户端和真实主题之间充当中介，可以用于控制对真实对象的访问权限、缓存对象的访问结果、延迟加载对象等。</p>
  </li>
</ul>

<p>虽然两者都涉及到包装一个对象以增强其功能，但装饰器模式注重于增加新的行为，而代理模式注重于控制对对象的访问。</p>

<p>Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>

<h2 id="行为型模式">行为型模式</h2>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">函数式编程</title><link href="/2024/04/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="alternate" type="text/html" title="函数式编程" /><published>2024-04-25T00:00:00+08:00</published><updated>2024-04-25T00:00:00+08:00</updated><id>/2024/04/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B</id><content type="html" xml:base="/2024/04/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"><![CDATA[<h1 id="引言">引言</h1>
<p>Lambda、方法引用、Stream。</p>

<h1 id="函数式编程">函数式编程</h1>

<p>函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。</p>

<p>Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带<code class="language-plaintext highlighter-rouge">this</code>参数的函数。函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数，函数式编程最早是数学家阿隆佐·邱奇研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。从<strong>Java 8</strong>开始，Java支持函数式编程。</p>

<h2 id="lambda表达式">Lambda表达式</h2>

<p>在Java程序中，经常遇到一大堆<strong>单方法接口</strong>，即一个接口只定义了一个方法：<code class="language-plaintext highlighter-rouge">Comparator</code>、<code class="language-plaintext highlighter-rouge">Runnable</code>、<code class="language-plaintext highlighter-rouge">Callable</code>。</p>

<p>以<code class="language-plaintext highlighter-rouge">Comparator</code>为例，调用<code class="language-plaintext highlighter-rouge">Arrays.sort()</code>时，可以传入一个<code class="language-plaintext highlighter-rouge">Comparator</code>实例，以匿名类方式编写如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">String</span> <span class="n">s1</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>

<p>从<strong>Java 8</strong>开始，可以用Lambda表达式替换<strong>单方法接口</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">s1</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>

<p>参数是<code class="language-plaintext highlighter-rouge">(s1, s2)</code>，参数类型可以省略，因为编译器可以自动推断出<code class="language-plaintext highlighter-rouge">String</code>类型。<code class="language-plaintext highlighter-rouge">-&gt; { ... }</code>表示方法体，所有代码写在内部即可。Lambda表达式没有<code class="language-plaintext highlighter-rouge">class</code>定义，因此写法非常简洁。</p>

<p>如果只有一行<code class="language-plaintext highlighter-rouge">return xxx</code>的代码，完全可以用更简单的写法：<code class="language-plaintext highlighter-rouge">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</code>。返回值的类型也是由编译器自动推断的，这里推断出的返回值是<code class="language-plaintext highlighter-rouge">int</code>，因此，只要返回<code class="language-plaintext highlighter-rouge">int</code>，编译器就不会报错。</p>

<h2 id="函数式接口">函数式接口</h2>

<p>函数式接口是Java中的一个概念，它是指<strong>只包含一个抽象方法的接口</strong>。函数式接口可以用作Lambda表达式的类型，从而支持函数式编程的特性。在Java中，函数式接口可以通过<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code>注解来<strong>标识</strong>，确保接口只包含一个抽象方法（同<code class="language-plaintext highlighter-rouge">@Override</code>注解只是用来让IDE检查的）。</p>

<p>如<code class="language-plaintext highlighter-rouge">Callable</code>接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">V</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Comparator</code>接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="no">T</span> <span class="n">o1</span><span class="o">,</span> <span class="no">T</span> <span class="n">o2</span><span class="o">);</span>

    <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">);</span>

    <span class="k">default</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">reversed</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">reverseOrder</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">default</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">thenComparing</span><span class="o">(</span><span class="nc">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>虽然<code class="language-plaintext highlighter-rouge">Comparator</code>接口有很多方法，但只有一个抽象方法<code class="language-plaintext highlighter-rouge">int compare(T o1, T o2)</code>，其他的方法都是<code class="language-plaintext highlighter-rouge">default</code>方法或<code class="language-plaintext highlighter-rouge">static</code>方法。<code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>是<code class="language-plaintext highlighter-rouge">Object</code>定义的方法，不算在接口方法内。因此，<code class="language-plaintext highlighter-rouge">Comparator</code>也是一个<code class="language-plaintext highlighter-rouge">FunctionalInterface</code>。</p>

<p>当使用函数式接口时，编译器会根据<strong>Lambda表达式</strong>或<strong>方法引用</strong>的上下文，将其<strong>转换为函数式接口的实例</strong>，并在需要时调用相应的方法。这些实例可以在运行时被JVM执行。</p>

<p>因此，函数式接口的调用是在运行时由<strong>JVM执行</strong>的，<strong>编译器</strong>负责将<strong>Lambda表达式</strong>或<strong>方法引用</strong>转换为<strong>函数式接口</strong>的实例，以便在程序运行时进行调用。</p>

<h2 id="柯里化">柯里化</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"静态方法:"</span><span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 柯里化（currying）的技巧，将一个多参数的方法转换为一系列单参数的方法。</span>
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">cr2</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">v1</span><span class="o">);</span>
        <span class="n">cr2</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">run</span><span class="o">();</span>
        
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;&gt;</span> <span class="n">cr3</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">);</span>
        <span class="n">cr3</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">apply</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">accept</span><span class="o">(</span><span class="s">"Consumer"</span><span class="o">);</span>
        
        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">cr</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">);</span>
        <span class="n">cr</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">随便</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">自定义接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="n">随便</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>柯里化是一种函数式编程的技术，通过这种技巧可以将<strong>多参数函数</strong>转换为一系列接受<strong>单个参数的函数</strong>。在柯里化中，每个函数只接受一个参数，并返回一个接受下一个参数的函数，直到接受完所有参数后返回最终结果。</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">cr2</code>是一个<code class="language-plaintext highlighter-rouge">Function&lt;Integer, Runnable&gt;</code>，它接受一个整数参数，并返回一个<code class="language-plaintext highlighter-rouge">Runnable</code>，这个<code class="language-plaintext highlighter-rouge">Runnable</code>调用了<code class="language-plaintext highlighter-rouge">Main.staticMethod</code>方法。</li>
  <li><code class="language-plaintext highlighter-rouge">cr3</code>是一个<code class="language-plaintext highlighter-rouge">Function&lt;Integer, Function&lt;Integer, Consumer&lt;String&gt;&gt;&gt;</code>，它接受两个整数参数，并返回一个<code class="language-plaintext highlighter-rouge">Consumer&lt;String&gt;</code>，这个<code class="language-plaintext highlighter-rouge">Consumer&lt;String&gt;</code>调用了<code class="language-plaintext highlighter-rouge">Main.staticMethod</code>方法。</li>
  <li><code class="language-plaintext highlighter-rouge">cr</code>是一个<code class="language-plaintext highlighter-rouge">Function&lt;Integer, 自定义接口&lt;Integer, Integer, Integer&gt;&gt;</code>，它接受一个整数参数，并返回一个自定义接口的实例，这个自定义接口接受三个整数参数，并调用了<code class="language-plaintext highlighter-rouge">Main.staticMethod</code>方法。</li>
</ol>

<p>通过柯里化，可以更灵活地使用多参数方法，将其转换为一系列单参数方法，使得代码更加模块化和易于理解。  也可以为多个参数。</p>

<p>拆解一个比较复杂的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"静态方法:"</span><span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">t0</span><span class="o">&lt;</span><span class="n">t1</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="n">t2</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span><span class="nc">String</span><span class="o">,</span> <span class="n">f3</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span><span class="nc">Float</span><span class="o">,</span><span class="nc">Person</span><span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">cr</span><span class="o">=</span>
            <span class="o">()-&gt;</span><span class="n">a</span><span class="o">-&gt;(</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">)-&gt;(</span><span class="n">d</span><span class="o">,</span><span class="n">e</span><span class="o">,</span><span class="n">f</span><span class="o">)-&gt;</span><span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">,</span><span class="n">e</span><span class="o">,</span><span class="n">f</span><span class="o">);</span>
        <span class="n">cr</span><span class="o">.</span><span class="na">f0</span><span class="o">().</span><span class="na">f1</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">f2</span><span class="o">(</span><span class="mf">2.3</span><span class="o">,</span><span class="s">"你好"</span><span class="o">).</span><span class="na">n3</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span><span class="mf">4.5f</span><span class="o">,</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小明"</span><span class="o">,</span><span class="mi">18</span><span class="o">));</span>
        <span class="c1">// 拆解：</span>
        <span class="n">t0</span><span class="o">&lt;</span><span class="n">t1</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="n">t2</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span><span class="nc">String</span><span class="o">,</span> <span class="n">f3</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span><span class="nc">Float</span><span class="o">,</span><span class="nc">Person</span><span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">cr2</span><span class="o">=</span>
            <span class="o">()-&gt;</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"无参数"</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一个参数"</span><span class="o">);</span>
                    <span class="k">return</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"两个参数"</span><span class="o">);</span>
                        <span class="k">return</span> <span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"三个参数"</span><span class="o">);</span>
                            <span class="nc">Main</span><span class="o">.</span><span class="na">staticMethod</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">f</span><span class="o">);</span>
                        <span class="o">};</span>
                    <span class="o">};</span>
                <span class="o">};</span>
            <span class="o">};</span>
        <span class="n">t1</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="n">t2</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span><span class="nc">String</span><span class="o">,</span> <span class="n">f3</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span><span class="nc">Float</span><span class="o">,</span><span class="nc">Person</span><span class="o">&gt;&gt;&gt;</span> <span class="n">t1</span><span class="o">=</span><span class="n">cr2</span><span class="o">.</span><span class="na">f0</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">,</span><span class="nc">String</span><span class="o">,</span> <span class="n">f3</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span><span class="nc">Float</span><span class="o">,</span><span class="nc">Person</span><span class="o">&gt;&gt;</span> <span class="n">t2</span><span class="o">=</span><span class="n">t1</span><span class="o">.</span><span class="na">f1</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">f3</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span><span class="nc">Float</span><span class="o">,</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">f3</span><span class="o">=</span><span class="n">t2</span><span class="o">.</span><span class="na">f2</span><span class="o">(</span><span class="mf">2.3</span><span class="o">,</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="n">f3</span><span class="o">.</span><span class="na">n3</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span><span class="mf">4.5f</span><span class="o">,</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小明"</span><span class="o">,</span><span class="mi">18</span><span class="o">));</span>
        <span class="c1">//当然，泛型参数也可以不按顺序来，可以把第一个泛型参数当返回值，可能会被打。</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">t0</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="no">T</span> <span class="nf">f0</span><span class="o">();</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">t1</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">U</span><span class="o">&gt;{</span>
    <span class="no">U</span> <span class="nf">f1</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">t2</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">U</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;{</span>
    <span class="no">V</span> <span class="nf">f2</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span><span class="no">U</span> <span class="n">u</span><span class="o">);</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">f3</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">n3</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">nane</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">nane</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">nane</span> <span class="o">=</span> <span class="n">nane</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"Person{nane='"</span> <span class="o">+</span> <span class="n">nane</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", age="</span> <span class="o">+</span> <span class="n">age</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>JavaScript实现无限递归调用比较麻烦，而Java则很简单：</p>

<p>JavaScript：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span> <span class="p">...</span><span class="nx">args</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">args</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">sum</span><span class="o">+=</span><span class="nx">args</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">fn</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span> <span class="p">...</span><span class="nx">args2</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">add</span><span class="p">(</span> <span class="nx">sum</span> <span class="p">,</span> <span class="p">...</span><span class="nx">args2</span> <span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fn</span><span class="p">.</span><span class="nx">toString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">sum</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fn</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">).</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">// 输出 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">).</span><span class="nx">toString</span><span class="p">());</span> <span class="c1">// 输出 15</span>
</code></pre></div></div>

<p>将上面的代码硬转为Java是这样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="no">T</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="no">T2</span> <span class="nf">f</span><span class="o">(</span><span class="nc">Integer</span><span class="o">...</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">var</span> <span class="n">o</span><span class="o">=</span><span class="k">new</span> <span class="nc">Object</span><span class="o">(){</span>
                    <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
                <span class="o">};</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span> <span class="o">:</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">o</span><span class="o">.</span><span class="na">sum</span> <span class="o">+=</span> <span class="n">integer</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="no">T</span> <span class="n">t</span><span class="o">=</span><span class="k">this</span><span class="o">;</span>
                <span class="no">T2</span> <span class="n">t2</span><span class="o">=</span><span class="k">new</span> <span class="no">T2</span><span class="o">()</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="no">T2</span> <span class="nf">f</span><span class="o">(</span><span class="nc">Integer</span><span class="o">...</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                        <span class="kt">int</span> <span class="n">sum2</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
                        <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span> <span class="o">:</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">sum2</span> <span class="o">+=</span> <span class="n">integer</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">sum</span><span class="o">,</span><span class="n">sum2</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
                        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">sum</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">};</span>
                <span class="k">return</span> <span class="n">t2</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">).</span><span class="na">f</span><span class="o">(</span><span class="mi">6</span><span class="o">));</span><span class="c1">//21</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">f</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">).</span><span class="na">f</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">));</span><span class="c1">//21</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">T</span><span class="o">{</span>
    <span class="no">T2</span> <span class="nf">f</span><span class="o">(</span><span class="nc">Integer</span> <span class="o">...</span><span class="na">i</span><span class="o">);</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">T2</span><span class="o">{</span>
    <span class="no">T2</span> <span class="nf">f</span><span class="o">(</span><span class="nc">Integer</span> <span class="o">...</span><span class="na">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>实际上完全不用这么麻烦：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">T</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="no">T</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="no">T</span> <span class="nf">f</span><span class="o">(</span><span class="nc">Integer</span><span class="o">...</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">integer</span> <span class="o">:</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">integer</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">sum</span><span class="o">;</span>
                <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
                <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">temp</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">).</span><span class="na">f</span><span class="o">(</span><span class="mi">6</span><span class="o">));</span><span class="c1">//21</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">f</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">f</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">).</span><span class="na">f</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">));</span><span class="c1">//21</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">T</span><span class="o">{</span>
    <span class="no">T</span> <span class="nf">f</span><span class="o">(</span><span class="nc">Integer</span> <span class="o">...</span><span class="na">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="方法引用">方法引用</h2>

<table>
  <thead>
    <tr>
      <th>引用类型</th>
      <th>方法引用示例</th>
      <th>对应调用示例</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>静态方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">Main::staticMethod</code></td>
      <td><code class="language-plaintext highlighter-rouge">Main.staticMethod(...)</code></td>
    </tr>
    <tr>
      <td>实例方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">main::instanceMethod</code></td>
      <td><code class="language-plaintext highlighter-rouge">main.instanceMethod(...)</code></td>
    </tr>
    <tr>
      <td>构造方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">Main::new</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main(...)</code></td>
    </tr>
    <tr>
      <td>数组构造方法引用</td>
      <td><code class="language-plaintext highlighter-rouge">Main[]::new</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main[?]</code></td>
    </tr>
  </tbody>
</table>

<p>方法引用，是指如果某个方法签名和单方法接口签名恰好一致，就可以直接传入方法引用。 在这里，方法签名只看参数类型和返回类型，<strong>不看方法名称</strong>，也不看类的继承关系。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span> <span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Orange"</span><span class="o">,</span> <span class="s">"Banana"</span><span class="o">,</span> <span class="s">"Lemon"</span> <span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="nl">String:</span><span class="o">:</span><span class="n">compareTo</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">array</span><span class="o">));</span>
</code></pre></div></div>

<p>对于<code class="language-plaintext highlighter-rouge">String.compareTo()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">String</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个方法的签名只有一个参数，为什么和<code class="language-plaintext highlighter-rouge">int compare(T t, T t)</code>能匹配呢？</p>

<p>因为使用<code class="language-plaintext highlighter-rouge">类名::实例方法</code>这样的方法引用，则会有一个<strong>隐含</strong>的<code class="language-plaintext highlighter-rouge">this</code>参数，<code class="language-plaintext highlighter-rouge">String</code>类的<code class="language-plaintext highlighter-rouge">compareTo()</code>方法在实际调用的时候，<strong>第一个隐含参数总是传入<code class="language-plaintext highlighter-rouge">this</code></strong>，相当于静态方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">String</span> <span class="k">this</span><span class="o">,</span> <span class="nc">String</span> <span class="n">o</span><span class="o">);</span>
</code></pre></div></div>

<p>所以，<code class="language-plaintext highlighter-rouge">String.compareTo()</code>方法也可作为方法引用传入。</p>

<p><code class="language-plaintext highlighter-rouge">类名::实例方法</code>这种方法引用形式，实际上是一种语法糖，它可以理解为对<code class="language-plaintext highlighter-rouge">实例::实例方法</code>的一种特殊情况。</p>

<p>使用<code class="language-plaintext highlighter-rouge">类名::实例方法</code>方法引用，实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">instanceMethod</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="o">}</span>
   <span class="kd">static</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">(</span><span class="no">I</span> <span class="n">i</span><span class="o">){</span>
        <span class="k">return</span>  <span class="n">i</span><span class="o">.</span><span class="na">func</span><span class="o">(</span><span class="k">new</span> <span class="nc">Main</span><span class="o">());</span>
   <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="nl">Main:</span><span class="o">:</span><span class="n">instanceMethod</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="nc">String</span> <span class="nf">func</span><span class="o">(</span><span class="nc">Main</span> <span class="n">a</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这种方法引用需要一个接收者参数，因此<code class="language-plaintext highlighter-rouge">I</code>接口的<code class="language-plaintext highlighter-rouge">func</code>方法需要接收一个<code class="language-plaintext highlighter-rouge">Main</code>类型的参数。</p>

<p>有点类似通过反射的形式调用方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">instanceMethod</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="nf">ref</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">c</span><span class="o">,</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">NoSuchMethodException</span><span class="o">,</span> <span class="nc">InvocationTargetException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">invoke</span><span class="o">(</span><span class="k">new</span> <span class="nc">Main</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">NoSuchMethodException</span><span class="o">,</span> <span class="nc">InvocationTargetException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">ref</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="s">"instanceMethod"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>使用<code class="language-plaintext highlighter-rouge">实例::实例方法</code>方法引用，则没有隐含参数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">instanceMethod</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="o">}</span>
   <span class="kd">static</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">(</span><span class="no">I</span> <span class="n">i</span><span class="o">){</span>
        <span class="k">return</span>  <span class="n">i</span><span class="o">.</span><span class="na">func</span><span class="o">();</span>
   <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Main</span> <span class="n">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="nl">main:</span><span class="o">:</span><span class="n">instanceMethod</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="nc">String</span> <span class="nf">func</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这种方法引用不需要接收者参数，因为实例本身已经确定了。</p>

<h3 id="无参引用调用">无参引用调用</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>常用接口</th>
      <th>代码</th>
      <th>等效调用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>静态方法</td>
      <td>Runnable</td>
      <td><code class="language-plaintext highlighter-rouge">Runnable r=Main::staticMethod;r.run();</code></td>
      <td><code class="language-plaintext highlighter-rouge">Main.staticMethod();</code></td>
    </tr>
    <tr>
      <td>实例方法</td>
      <td>Runnable</td>
      <td><code class="language-plaintext highlighter-rouge">Runnable r=main::instanceMethod;r.run();</code></td>
      <td><code class="language-plaintext highlighter-rouge">main.instanceMethod();</code></td>
    </tr>
    <tr>
      <td>构造方法</td>
      <td>Supplier</td>
      <td><code class="language-plaintext highlighter-rouge">Supplier&lt;Main&gt; s=Main::new;s.get();</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main();</code></td>
    </tr>
    <tr>
      <td>数组</td>
      <td>IntFunction</td>
      <td><code class="language-plaintext highlighter-rouge">IntFunction&lt;Main[]&gt; g=Main[]::new;g.apply(5);</code></td>
      <td><code class="language-plaintext highlighter-rouge">new Main[5];</code></td>
    </tr>
  </tbody>
</table>

<p>实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.IntFunction</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Supplier</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"静态方法"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">instanceMethod</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例方法"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">()</span> <span class="o">{</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"构造方法"</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 静态方法引用</span>
        <span class="nc">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="n">r1</span><span class="o">.</span><span class="na">run</span><span class="o">();</span><span class="c1">//Main.staticMethod()</span>
        <span class="c1">// 实例方法引用</span>
        <span class="nc">Main</span> <span class="n">main</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">();</span>
        <span class="nc">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="nl">main:</span><span class="o">:</span><span class="n">instanceMethod</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="n">r2</span><span class="o">.</span><span class="na">run</span><span class="o">();</span><span class="c1">//main.instanceMethod()</span>
        <span class="c1">// 构造方法引用</span>
        <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Main</span><span class="o">&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="nc">Main</span> <span class="n">main2</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span><span class="c1">//new Main()</span>
        <span class="c1">// 数组构造方法引用</span>
        <span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Main</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span><span class="c1">//只能调用无参</span>
        <span class="nc">Main</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span><span class="c1">//new Main[5]</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="带参引用调用无返回值">带参引用调用（无返回值）</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>接口</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>无参方法</td>
      <td>Runnable</td>
      <td><code class="language-plaintext highlighter-rouge">run()</code>调用</td>
    </tr>
    <tr>
      <td>一个参数</td>
      <td>Consumer<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code></td>
      <td><code class="language-plaintext highlighter-rouge">accept(T)</code>调用</td>
    </tr>
    <tr>
      <td>两个参数</td>
      <td>BiConsumer&lt;T,U&gt;</td>
      <td><code class="language-plaintext highlighter-rouge">accept(T,U)</code>调用</td>
    </tr>
    <tr>
      <td>更多个参数</td>
      <td>自定义函数式接口，并使用<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code></td>
      <td>调用随便</td>
    </tr>
  </tbody>
</table>

<p>实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.BiConsumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Consumer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.Function</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">staticMethod</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"静态方法:"</span><span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法引用</span>
        <span class="nc">Runnable</span> <span class="n">a</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">a</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        
        <span class="nc">Consumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">c</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        
        <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">b</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="s">"123"</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
        
        <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="n">staticMethod</span><span class="o">;</span>
        <span class="n">t</span><span class="o">.</span><span class="na">随便</span><span class="o">(</span><span class="s">"123"</span><span class="o">,</span><span class="s">"345"</span><span class="o">,</span><span class="s">"456"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">自定义接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="n">随便</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="带参引用调用构造方法有返回值">带参引用调用构造方法（有返回值）</h3>

<table>
  <thead>
    <tr>
      <th>类型</th>
      <th>接口</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>无参方法</td>
      <td>Supplier<类名></类名></td>
      <td><code class="language-plaintext highlighter-rouge">get()</code>调用</td>
    </tr>
    <tr>
      <td>一个参数</td>
      <td>Function&lt;T,类名&gt;</td>
      <td><code class="language-plaintext highlighter-rouge">apply(T)</code>调用</td>
    </tr>
    <tr>
      <td>两个参数</td>
      <td>BiFunction&lt;T,U,类名&gt;</td>
      <td><code class="language-plaintext highlighter-rouge">apply(T,U)</code>调用</td>
    </tr>
    <tr>
      <td>更多个参数</td>
      <td>自定义函数式接口，并使用<code class="language-plaintext highlighter-rouge">@FunctionalInterface</code></td>
      <td>调用随便</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.function.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span><span class="na">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"构造方法："</span><span class="o">+</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 构造方法引用</span>
        <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Main</span><span class="o">&gt;</span> <span class="n">supplier</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main1</span> <span class="o">=</span> <span class="n">supplier</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

        <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">constructor</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main2</span> <span class="o">=</span> <span class="n">constructor</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"你好"</span><span class="o">);</span>

        <span class="nc">BiFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">constructor2</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main3</span> <span class="o">=</span> <span class="n">constructor2</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">);</span>

        <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">constructor3</span> <span class="o">=</span> <span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="nc">Main</span> <span class="n">main4</span> <span class="o">=</span> <span class="n">constructor3</span><span class="o">.</span><span class="na">随便</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="c1">//柯里化</span>
        <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="n">自定义接口</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">,</span> <span class="nc">Boolean</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;&gt;</span> <span class="n">cr4</span> <span class="o">=</span>
                <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">,</span> <span class="n">v3</span><span class="o">,</span> <span class="n">v4</span><span class="o">,</span> <span class="n">v5</span><span class="o">,</span> <span class="n">v6</span><span class="o">);</span>
        <span class="nc">Main</span> <span class="n">main5</span> <span class="o">=</span> <span class="n">cr4</span><span class="o">.</span><span class="na">随便</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">,</span> <span class="kc">true</span><span class="o">).</span><span class="na">随便</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">自定义接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">U</span><span class="o">,</span> <span class="no">V</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="n">随便</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">U</span> <span class="n">u</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<h3 id="展开一个mainnew">展开一个<code class="language-plaintext highlighter-rouge">Main::new;</code></h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span><span class="na">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"构造方法："</span><span class="o">+</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法引用</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f1</span><span class="o">=</span><span class="nl">Main:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>
        <span class="c1">// Lambda</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">};</span>
        <span class="c1">// 匿名内部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="c1">// 普通内部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f4</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Main</span><span class="o">().</span><span class="na">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="c1">// 静态内部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f5</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Main</span><span class="o">.</span><span class="na">B</span><span class="o">();</span>
        <span class="c1">// 外部类</span>
        <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="n">f6</span> <span class="o">=</span><span class="k">new</span> <span class="no">C</span><span class="o">();</span>

        <span class="n">f1</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f2</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f2</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f3</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f3</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f4</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f4</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f5</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f5</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
        <span class="n">f6</span><span class="o">.</span><span class="na">方法</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">f6</span><span class="o">.</span><span class="na">getClass</span><span class="o">()));</span>
    <span class="o">}</span>
    <span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">B</span> <span class="kd">implements</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="n">接口</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Main</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Main</span> <span class="n">方法</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Main</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">接口</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="n">方法</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>控制台：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">构造方法</span><span class="err">：</span><span class="o">[]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="err">$</span><span class="n">$Lambda</span><span class="err">$</span><span class="mi">14</span><span class="o">/</span><span class="mh">0x00000008000c0b40</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="err">$</span><span class="n">$Lambda</span><span class="err">$</span><span class="mi">15</span><span class="o">/</span><span class="mh">0x00000008000c0d80</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="err">$</span><span class="mi">1</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="n">$A</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="n">$B</span><span class="o">]</span>
<span class="n">构造方法</span><span class="err">：</span><span class="o">[</span><span class="kd">class</span> <span class="nc">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">C</span><span class="o">]</span>
</code></pre></div></div>

<p>从上到下，越来越易懂。</p>

<h2 id="stream">Stream</h2>

<p>Java从8开始，不但引入了Lambda表达式，还引入了一个全新的<strong>流式</strong>API：Stream API。它位于<code class="language-plaintext highlighter-rouge">java.util.stream</code>包中。</p>

<p>这个<code class="language-plaintext highlighter-rouge">Stream</code>不同于<code class="language-plaintext highlighter-rouge">java.io</code>的<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>，它代表的是<strong>任意</strong>Java对象的序列。两者对比如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">java.io</code></th>
      <th><code class="language-plaintext highlighter-rouge">java.util.stream</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">存储</td>
      <td style="text-align: left">顺序读写的<code class="language-plaintext highlighter-rouge">byte</code>或<code class="language-plaintext highlighter-rouge">char</code></td>
      <td>顺序输出的任意Java对象实例</td>
    </tr>
    <tr>
      <td style="text-align: left">用途</td>
      <td style="text-align: left">序列化至文件或网络</td>
      <td>内存计算／业务逻辑</td>
    </tr>
  </tbody>
</table>

<p>这个<code class="language-plaintext highlighter-rouge">Stream</code>和<code class="language-plaintext highlighter-rouge">List</code>也不一样，<code class="language-plaintext highlighter-rouge">List</code>存储的每个元素都是已经存储在内存中的某个Java对象，而<code class="language-plaintext highlighter-rouge">Stream</code>输出的元素可能并没有预先存储在内存中，而是<strong>实时计算</strong>出来的。<code class="language-plaintext highlighter-rouge">List</code>的用途是操作一组已存在的Java对象，而<code class="language-plaintext highlighter-rouge">Stream</code>实现的是<strong>惰性计算</strong>，两者对比如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left"><code class="language-plaintext highlighter-rouge">java.util.List</code></th>
      <th><code class="language-plaintext highlighter-rouge">java.util.stream</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">元素</td>
      <td style="text-align: left">已分配并存储在内存</td>
      <td>可能未分配，实时计算</td>
    </tr>
    <tr>
      <td style="text-align: left">用途</td>
      <td style="text-align: left">操作一组已存在的Java对象</td>
      <td>惰性计算</td>
    </tr>
  </tbody>
</table>

<p>如果要表示一个全体自然数的集合，显然，用<code class="language-plaintext highlighter-rouge">List</code>是不可能写出来的，因为自然数是无限的，内存再大也没法放到<code class="language-plaintext highlighter-rouge">List</code>中。但是，用<code class="language-plaintext highlighter-rouge">Stream</code>可以做到：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">naturals</span> <span class="o">=</span> <span class="n">createNaturalStream</span><span class="o">();</span> <span class="c1">// 全体自然数</span>
</code></pre></div></div>

<p>先不考虑<code class="language-plaintext highlighter-rouge">createNaturalStream()</code>方法是如何实现。</p>

<p>可以对每个自然数做一个平方，这样就把这个<code class="language-plaintext highlighter-rouge">Stream</code>转换成了另一个<code class="language-plaintext highlighter-rouge">Stream</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">naturals</span> <span class="o">=</span> <span class="n">createNaturalStream</span><span class="o">();</span> <span class="c1">// 全体自然数</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">streamNxN</span> <span class="o">=</span> <span class="n">naturals</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">n</span><span class="o">));</span> <span class="c1">// 全体自然数的平方</span>
</code></pre></div></div>

<p>因为这个<code class="language-plaintext highlighter-rouge">streamNxN</code>也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用<code class="language-plaintext highlighter-rouge">limit()</code>方法截取前100个元素，最后用<code class="language-plaintext highlighter-rouge">forEach()</code>处理每个元素，这样，就打印出了前100个自然数的平方：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">naturals</span> <span class="o">=</span> <span class="n">createNaturalStream</span><span class="o">();</span>
<span class="n">naturals</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">n</span><span class="o">))</span> <span class="c1">// 1, 4, 9, 16, 25...</span>
        <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>

<p><code class="language-plaintext highlighter-rouge">Stream</code>的另一个特点是，一个<code class="language-plaintext highlighter-rouge">Stream</code>可以轻易地转换为另一个<code class="language-plaintext highlighter-rouge">Stream</code>，而不是修改原<code class="language-plaintext highlighter-rouge">Stream</code>本身。</p>

<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">naturals</span> <span class="o">=</span> <span class="n">createNaturalStream</span><span class="o">();</span> <span class="c1">// 不计算</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">naturals</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">BigInteger:</span><span class="o">:</span><span class="n">multiply</span><span class="o">);</span> <span class="c1">// 不计算</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="c1">// 不计算</span>
<span class="n">s3</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span> <span class="c1">// 计算</span>
</code></pre></div></div>

<p>惰性计算的特点是：一个<code class="language-plaintext highlighter-rouge">Stream</code>转换为另一个<code class="language-plaintext highlighter-rouge">Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p>

<p>例如，创建一个全体自然数的<code class="language-plaintext highlighter-rouge">Stream</code>，不会进行计算，把它转换为上述<code class="language-plaintext highlighter-rouge">s2</code>这个<code class="language-plaintext highlighter-rouge">Stream</code>，也不会进行计算。再把<code class="language-plaintext highlighter-rouge">s2</code>这个无限<code class="language-plaintext highlighter-rouge">Stream</code>转换为<code class="language-plaintext highlighter-rouge">s3</code>这个有限的<code class="language-plaintext highlighter-rouge">Stream</code>，也不会进行计算。只有最后，调用<code class="language-plaintext highlighter-rouge">forEach</code>确实需要<code class="language-plaintext highlighter-rouge">Stream</code>输出的元素时，才进行计算。</p>

<p>通常把<code class="language-plaintext highlighter-rouge">Stream</code>的操作写成链式操作，代码更简洁：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">createNaturalStream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">BigInteger:</span><span class="o">:</span><span class="n">multiply</span><span class="o">)</span>
    <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
    <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>因此，Stream API的基本用法就是：创建一个<code class="language-plaintext highlighter-rouge">Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">createNaturalStream</span><span class="o">()</span> <span class="c1">// 创建Stream</span>
             <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 任意个转换</span>
             <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span> <span class="c1">// 任意个转换</span>
             <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span> <span class="c1">// 任意个转换</span>
             <span class="o">.</span><span class="na">sum</span><span class="o">();</span> <span class="c1">// 最终计算结果</span>
</code></pre></div></div>

<h3 id="创建stream">创建<code class="language-plaintext highlighter-rouge">Stream</code></h3>

<p>要使用<code class="language-plaintext highlighter-rouge">Stream</code>，就必须先创建它，创建<code class="language-plaintext highlighter-rouge">Stream</code>有很多种方法。</p>

<h4 id="streamof"><code class="language-plaintext highlighter-rouge">Stream.of</code></h4>

<p>创建<code class="language-plaintext highlighter-rouge">Stream</code>最简单的方式是直接用<code class="language-plaintext highlighter-rouge">Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的<code class="language-plaintext highlighter-rouge">Stream</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">);</span>
<span class="c1">// forEach()方法相当于内部循环调用，</span>
<span class="c1">// 可传入符合Consumer接口的void accept(T t)的方法引用：</span>
<span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="基于数组或集合">基于数组或集合</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">};</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
<span class="n">stream1</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"X"</span><span class="o">,</span> <span class="s">"Y"</span><span class="o">,</span> <span class="s">"Z"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream2</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="n">stream2</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>把数组变成<code class="language-plaintext highlighter-rouge">Stream</code>使用<code class="language-plaintext highlighter-rouge">Arrays.stream()</code>方法。对于<code class="language-plaintext highlighter-rouge">Collection</code>（<code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Set</code>、<code class="language-plaintext highlighter-rouge">Queue</code>等），直接调用<code class="language-plaintext highlighter-rouge">stream()</code>方法就可以获得<code class="language-plaintext highlighter-rouge">Stream</code>。</p>

<p>上述创建<code class="language-plaintext highlighter-rouge">Stream</code>的方法都是把一个现有的序列变为<code class="language-plaintext highlighter-rouge">Stream</code>，它的元素是固定的。</p>

<h4 id="streamiterate"><code class="language-plaintext highlighter-rouge">Stream.iterate</code></h4>

<p>创建<code class="language-plaintext highlighter-rouge">Stream</code>还可以通过<code class="language-plaintext highlighter-rouge">Stream.generate()</code>方法，它需要传入一个<code class="language-plaintext highlighter-rouge">Supplier</code>接口对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">sp</span><span class="o">);</span>
</code></pre></div></div>

<p>基于<code class="language-plaintext highlighter-rouge">Supplier</code>创建的<code class="language-plaintext highlighter-rouge">Stream</code>会不断调用<code class="language-plaintext highlighter-rouge">Supplier.get()</code>方法来不断产生下一个元素，这种<code class="language-plaintext highlighter-rouge">Stream</code>保存的不是元素，而是算法，它可以用来表示<strong>无限序列</strong>。</p>

<p>例如，编写一个能不断生成自然数的<code class="language-plaintext highlighter-rouge">Supplier</code>，它的代码非常简单，每次调用<code class="language-plaintext highlighter-rouge">get()</code>方法，就生成下一个自然数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">natual</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Supplier</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="c1">// 注意：无限序列必须先变成有限序列再打印:</span>
<span class="n">natual</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>不过它并不能代表所有自然数，因为<code class="language-plaintext highlighter-rouge">long</code>是有极限的,最大<code class="language-plaintext highlighter-rouge">2^63-1</code>。如果用<code class="language-plaintext highlighter-rouge">List</code>表示，即便在<code class="language-plaintext highlighter-rouge">int</code>范围内，也会占用巨大的内存，而<code class="language-plaintext highlighter-rouge">Stream</code>几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>

<p>对于<strong>无限序列</strong>，如果直接调用<code class="language-plaintext highlighter-rouge">forEach()</code>或者<code class="language-plaintext highlighter-rouge">count()</code>这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用<strong><code class="language-plaintext highlighter-rouge">limit()</code></strong>方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用<code class="language-plaintext highlighter-rouge">forEach()</code>或者<code class="language-plaintext highlighter-rouge">count()</code>操作就没有问题。</p>

<p><code class="language-plaintext highlighter-rouge">BigInteger</code>虽然没有极限，但<code class="language-plaintext highlighter-rouge">limit</code>方法只能传入<code class="language-plaintext highlighter-rouge">long</code>型，因此改成<code class="language-plaintext highlighter-rouge">BigInteger</code>，也没用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">BigInteger</span><span class="o">&gt;</span> <span class="n">natual</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Supplier</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">BigInteger</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">BigInteger</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">BigInteger</span> <span class="n">result</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="na">ONE</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">natual</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="streamiterate-1"><code class="language-plaintext highlighter-rouge">Stream.iterate</code></h4>

<p><code class="language-plaintext highlighter-rouge">Stream.iterate()</code>方法的方法签名如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterate</span><span class="o">(</span><span class="no">T</span> <span class="n">seed</span><span class="o">,</span> <span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<p>其中：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">T</code>：流中元素的类型。</li>
  <li><code class="language-plaintext highlighter-rouge">seed</code>：初始值，即流的第一个元素。</li>
  <li><code class="language-plaintext highlighter-rouge">f</code>：生成流中后续元素的函数，它接受一个参数（前一个元素）并返回一个结果（下一个元素）。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Stream.iterate()</code>方法会生成一个无限长度的流，从初始值开始，根据指定的函数生成后续的元素。要使这种流变为有限流，通常需要使用<code class="language-plaintext highlighter-rouge">limit()</code>方法来限制流的长度。</p>

<p><code class="language-plaintext highlighter-rouge">UnaryOperator&lt;T&gt;</code>的方法签名如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">T</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>

<p>而<code class="language-plaintext highlighter-rouge">Function&lt;T, R&gt;</code>是这样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因此<code class="language-plaintext highlighter-rouge">UnaryOperator&lt;T&gt;</code>，实际上就是这这样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UnaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div>

<p>斐波那契：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="k">new</span> <span class="kt">long</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">},</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]{</span><span class="n">f</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">f</span><span class="o">[</span><span class="mi">1</span><span class="o">]})</span>
        <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
        <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">" "</span><span class="o">));</span>
</code></pre></div></div>

<h4 id="其他方法">其他方法</h4>

<p>创建<code class="language-plaintext highlighter-rouge">Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code class="language-plaintext highlighter-rouge">Stream</code>。</p>

<p>例如，<code class="language-plaintext highlighter-rouge">Files</code>类的<code class="language-plaintext highlighter-rouge">lines()</code>方法可以把一个文件变成一个<code class="language-plaintext highlighter-rouge">Stream</code>，每个元素代表文件的一行内容：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"1.xml"</span><span class="o">)))</span> <span class="o">{</span>
    <span class="n">lines</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>此方法对于按行遍历文本文件十分有用。</p>

<p>正则表达式的<code class="language-plaintext highlighter-rouge">Pattern</code>对象有一个<code class="language-plaintext highlighter-rouge">splitAsStream()</code>方法，可以直接把一个长字符串分割成<code class="language-plaintext highlighter-rouge">Stream</code>序列而不是数组：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pattern</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Pattern</span><span class="o">.</span><span class="na">compile</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">splitAsStream</span><span class="o">(</span><span class="s">"The quick brown fox jumps over the lazy dog"</span><span class="o">);</span>
<span class="n">s</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="基本类型">基本类型</h4>

<p>因为Java的泛型不支持基本类型，所以无法用<code class="language-plaintext highlighter-rouge">Stream&lt;int&gt;</code>这样的类型，会发生编译错误。为了保存<code class="language-plaintext highlighter-rouge">int</code>，只能使用<code class="language-plaintext highlighter-rouge">Stream&lt;Integer&gt;</code>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了<code class="language-plaintext highlighter-rouge">IntStream</code>、<code class="language-plaintext highlighter-rouge">LongStream</code>和<code class="language-plaintext highlighter-rouge">DoubleStream</code>这三种使用基本类型的<code class="language-plaintext highlighter-rouge">Stream</code>，它们的使用方法和泛型<code class="language-plaintext highlighter-rouge">Stream</code>没有大的区别，设计这三个<code class="language-plaintext highlighter-rouge">Stream</code>的目的是提高运行效率：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 将int[]数组变为IntStream:</span>
<span class="nc">IntStream</span> <span class="n">is</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">});</span>
<span class="c1">// 将Stream&lt;String&gt;转换为LongStream:</span>
<span class="nc">LongStream</span> <span class="n">ls</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">).</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToLong</span><span class="o">(</span><span class="nl">Long:</span><span class="o">:</span><span class="n">parseLong</span><span class="o">);</span>

<span class="n">is</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="n">ls</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="map方法"><code class="language-plaintext highlighter-rouge">map</code>方法</h3>

<p><code class="language-plaintext highlighter-rouge">Stream.map()</code>是<code class="language-plaintext highlighter-rouge">Stream</code>最常用的一个转换方法，它<strong>把一个<code class="language-plaintext highlighter-rouge">Stream</code>转换为另一个<code class="language-plaintext highlighter-rouge">Stream</code></strong>。</p>

<p><code class="language-plaintext highlighter-rouge">map</code>操作，就是把一种操作运算，映射到一个序列的<strong>每一个元素上</strong>。例如，对<code class="language-plaintext highlighter-rouge">x</code>计算它的平方，可以使用函数<code class="language-plaintext highlighter-rouge">f(x) = x * x</code>。我们把这个函数映射到一个序列1，2，3，4，5上，就得到了另一个序列1，4，9，16，25。传入的方法需符合<code class="language-plaintext highlighter-rouge">Function</code>接口</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">);</span>
<span class="n">s2</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Stream.map()</code> 方法还有有以下几种变种：</p>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code></strong>：对流中的每个元素执行指定的映射函数，将结果映射为一个 <code class="language-plaintext highlighter-rouge">IntStream</code>。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code>：对流中的每个元素执行指定的映射函数，将结果映射为一个 <code class="language-plaintext highlighter-rouge">LongStream</code>。</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>：对流中的每个元素执行指定的映射函数，将结果映射为一个 <code class="language-plaintext highlighter-rouge">DoubleStream</code>。</p>
  </li>
</ol>

<p>这些变种方法允许你根据需要将流中的元素映射为不同类型的流，例如，将流中的对象映射为整数流、长整型流或双精度浮点数流。</p>

<h3 id="filter方法"><code class="language-plaintext highlighter-rouge">Filter</code>方法</h3>

<p><code class="language-plaintext highlighter-rouge">Stream.filter()</code>是<code class="language-plaintext highlighter-rouge">Stream</code>的另一个常用<strong>转换</strong>方法。</p>

<p><code class="language-plaintext highlighter-rouge">filter()</code>操作，就是对一个<code class="language-plaintext highlighter-rouge">Stream</code>的所有元素进行判断，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的<code class="language-plaintext highlighter-rouge">Stream</code>。</p>

<p><code class="language-plaintext highlighter-rouge">filter()</code>方法接收的对象是<code class="language-plaintext highlighter-rouge">Predicate</code>接口对象，它定义了一个<code class="language-plaintext highlighter-rouge">test()</code>方法，负责判断元素是否符合条件：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 判断元素t是否符合条件:</span>
    <span class="kt">boolean</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="nl">Main:</span><span class="o">:</span><span class="n">singular</span><span class="o">)</span>
                <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">singular</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">){</span>
        <span class="k">return</span>  <span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>对对象操作：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小明"</span><span class="o">,</span> <span class="mi">88</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小黑"</span><span class="o">,</span> <span class="mi">62</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小白"</span><span class="o">,</span> <span class="mi">45</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小黄"</span><span class="o">,</span> <span class="mi">78</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小红"</span><span class="o">,</span> <span class="mi">99</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小林"</span><span class="o">,</span> <span class="mi">58</span><span class="o">));</span>
        <span class="n">persons</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
            <span class="o">.</span><span class="na">filter</span><span class="o">(</span>
                <span class="n">person</span> <span class="o">-&gt;</span> <span class="n">person</span><span class="o">.</span><span class="na">score</span> <span class="o">&gt;=</span> <span class="mi">60</span>
            <span class="o">).</span><span class="na">map</span><span class="o">(</span>
                <span class="n">person</span> <span class="o">-&gt;</span> <span class="n">person</span><span class="o">.</span><span class="na">name</span>
            <span class="o">).</span><span class="na">forEach</span><span class="o">(</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span>
            <span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="nc">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="n">score</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="reduce方法"><code class="language-plaintext highlighter-rouge">reduce</code>方法</h3>

<p><code class="language-plaintext highlighter-rouge">Stream.reduce()</code>是<code class="language-plaintext highlighter-rouge">Stream</code>的一个聚合方法，可以把一个<code class="language-plaintext highlighter-rouge">Stream</code>的所有元素按照聚合函数聚合成一个结果。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0</span><span class="o">,(</span><span class="n">acc</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span> <span class="c1">// 45</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">reduce</code>的参数<code class="language-plaintext highlighter-rouge">identity</code>表示初始值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">T</span> <span class="nf">reduce</span><span class="o">(</span><span class="no">T</span> <span class="n">identity</span><span class="o">,</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">BinaryOperator</code>接口，定义了一个<code class="language-plaintext highlighter-rouge">apply()</code>方法，负责把上次累加的结果和本次的元素 进行运算，并返回累加的结果：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BinaryOperator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// Bi操作：两个输入，一个输出</span>
    <span class="no">T</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">,</span> <span class="no">T</span> <span class="n">u</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>换成普通形式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">={</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
<span class="kt">int</span> <span class="n">acc</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">acc</span><span class="o">=</span><span class="n">acc</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
<span class="o">}</span>
<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="n">acc</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span> <span class="c1">// 45</span>
</code></pre></div></div>

<p>如果去掉初始值<code class="language-plaintext highlighter-rouge">identity</code>，会得到一个<code class="language-plaintext highlighter-rouge">Optional&lt;Integer&gt;</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
    <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">acc</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">sum</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因为<code class="language-plaintext highlighter-rouge">Stream</code>的元素有可能是0个，这样就没法调用<code class="language-plaintext highlighter-rouge">reduce()</code>的聚合函数了，因此会返回<code class="language-plaintext highlighter-rouge">Optional</code>对象，需要进一步判断结果是否存在。</p>

<p>注意：计算<strong>求积</strong>时，初始值必须设置为<code class="language-plaintext highlighter-rouge">1</code>。</p>

<hr />

<p>将配置文件的每一行配置通过<code class="language-plaintext highlighter-rouge">map()</code>和<code class="language-plaintext highlighter-rouge">reduce()</code>操作聚合成一个<code class="language-plaintext highlighter-rouge">Map&lt;String, String&gt;</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">props</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"profile=native"</span><span class="o">,</span> <span class="s">"debug=true"</span><span class="o">,</span> <span class="s">"logging=warn"</span><span class="o">,</span> <span class="s">"interval=500"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="c1">// 把k=v转换为Map[k]=v:</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">kv</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">kv</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"="</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
            <span class="k">return</span> <span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">ss</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span><span class="c1">//Java8 及以下版本:Collections.singletonMap(ss[0], ss[1]);</span>
        <span class="o">})</span>
        <span class="c1">// 把所有Map聚合到一个Map:</span>
        <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(),</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">kv</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">m</span><span class="o">.</span><span class="na">putAll</span><span class="o">(</span><span class="n">kv</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div>

<p>一些<code class="language-plaintext highlighter-rouge">reduce</code>的特例：</p>

<p><code class="language-plaintext highlighter-rouge">min(Comparator&lt;? super T&gt; comparator)</code>：返回流中的最小元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">minElement</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">min</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
</code></pre></div></div>

<p>等于：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minElement</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">compareTo</span><span class="o">);</span>
<span class="n">minElement</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerStream2</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">minElement2</span> <span class="o">=</span> <span class="n">integerStream2</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span>
        <span class="nc">BinaryOperator</span><span class="o">.</span><span class="na">minBy</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">compareTo</span><span class="o">)</span>
<span class="o">);</span>
<span class="n">minElement2</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">max(Comparator&lt;? super T&gt; comparator)</code>：返回流中的最大元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Optional</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">maxElement</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">max</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
</code></pre></div></div>

<p>等于：（把之前的代码里的<code class="language-plaintext highlighter-rouge">min</code>换成<code class="language-plaintext highlighter-rouge">max</code>就行了）</p>

<hr />

<p>针对<code class="language-plaintext highlighter-rouge">IntStream</code>、<code class="language-plaintext highlighter-rouge">LongStream</code>和<code class="language-plaintext highlighter-rouge">DoubleStream</code>，还额外提供了以下聚合方法：</p>

<p><code class="language-plaintext highlighter-rouge">sum()</code>：返回流中元素的和。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">intStream</span><span class="o">.</span><span class="na">sum</span><span class="o">();</span>
</code></pre></div></div>

<p>等于：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">sum</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum1</span><span class="o">);</span>

<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerStream2</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">sum2</span> <span class="o">=</span> <span class="n">integerStream2</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span>
        <span class="mi">0</span><span class="o">,</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum2</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">average()</code>：返回流中元素的平均值。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">OptionalDouble</span> <span class="n">average</span> <span class="o">=</span> <span class="n">doubleStream</span><span class="o">.</span><span class="na">average</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="collect方法"><code class="language-plaintext highlighter-rouge">collect</code>方法</h3>

<p>等于：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntStream</span> <span class="n">integerStream</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="nc">OptionalDouble</span> <span class="n">average1</span> <span class="o">=</span> <span class="n">integerStream</span><span class="o">.</span><span class="na">average</span><span class="o">();</span>
<span class="n">average1</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>

<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerStream2</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="kt">long</span><span class="o">[]</span> <span class="n">average</span> <span class="o">=</span> <span class="n">integerStream2</span><span class="o">.</span><span class="na">collect</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span>
        <span class="o">(</span><span class="n">ll</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">0</span><span class="o">]++;</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">},</span>
        <span class="o">(</span><span class="n">ll</span><span class="o">,</span> <span class="n">rr</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rr</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">average</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">/</span> <span class="n">average</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</code></pre></div></div>

<p>这段代码使用了 <code class="language-plaintext highlighter-rouge">collect</code> 方法来计算整数流的平均值。具体来说，它创建了一个 <code class="language-plaintext highlighter-rouge">long</code> 数组，数组的第一个元素用于存储流中的元素数量，第二个元素用于存储流中所有元素的总和。然后使用三个参数的 <code class="language-plaintext highlighter-rouge">collect</code> 方法来对流进行归约操作，将每个元素的值累加到总和中，并且每处理一个元素，计数器加1。最后，通过将总和除以元素数量得到平均值，并将结果转换为 <code class="language-plaintext highlighter-rouge">double</code> 类型进行打印。具体解释：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">() -&gt; new long[2]</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">long</code> 数组作为收集器的初始值，数组的第一个元素表示元素数量，第二个元素表示元素总和。</li>
  <li><code class="language-plaintext highlighter-rouge">(ll, i) -&gt; { ll[0]++; ll[1] += i; }</code>：累加器函数，用于处理流中的每个元素。对于每个元素，将计数器加1，并将元素的值累加到总和中。</li>
  <li><code class="language-plaintext highlighter-rouge">(ll, rr) -&gt; { ll[0] += rr[0]; ll[1] += rr[1]; }</code>：组合器函数，用于将两个部分结果合并为一个结果。在<strong>并行流</strong>的情况下，可能会有多个部分结果需要<strong>合并</strong>。</li>
  <li>最终得到的 <code class="language-plaintext highlighter-rouge">long[]</code> 数组中，第一个元素表示元素数量，第二个元素表示元素总和。通过将总和除以元素数量，得到平均值。</li>
</ol>

<p>定义：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="no">R</span> <span class="nf">collect</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">R</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
              <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="no">R</span><span class="o">,</span> <span class="o">?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">accumulator</span><span class="o">,</span>
              <span class="nc">BiConsumer</span><span class="o">&lt;</span><span class="no">R</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="n">combiner</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">collect</code>方法是一个终结操作，用于对流的元素执行可变的归约操作。可变的归约是指归约的结果是一个可变的结果容器，比如一个<code class="language-plaintext highlighter-rouge">ArrayList</code>，在归约过程中通过更新结果的状态来包含元素，而不是通过替换结果来包含元素。</p>

<p>在<strong>并行流</strong>的情况下，<code class="language-plaintext highlighter-rouge">collect</code>操作可以进行并行化，而不需要额外的同步。</p>

<p><code class="language-plaintext highlighter-rouge">collect</code>方法的参数包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">supplier</code>：一个函数，用于创建一个新的可变结果容器。对于并行执行，这个函数可能会被多次调用，并且必须每次返回一个新的值。</li>
  <li><code class="language-plaintext highlighter-rouge">accumulator</code>：一个关联的、无副作用、无状态的函数，用于将一个元素合并到结果容器中。</li>
  <li><code class="language-plaintext highlighter-rouge">combiner</code>：一个关联的、无副作用、无状态的函数，用于<strong>合并两个部分结果容器</strong>。这个函数必须与累加器函数兼容，它的作用是将第二个结果容器中的元素合并到第一个结果容器中。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">collect</code>方法的返回值是归约的结果。</p>

<p>JDK 中有许多现有类，其签名非常适合与方法引用一起用作的 <code class="language-plaintext highlighter-rouge">collect()</code>参数。例如，以下内容会将字符串累积成一个 <code class="language-plaintext highlighter-rouge">ArrayList</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">asList</span> <span class="o">=</span> <span class="n">stringStream</span>
     <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span> <span class="nl">ArrayList:</span><span class="o">:</span><span class="n">add</span><span class="o">,</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="n">addAll</span><span class="o">);</span>
</code></pre></div></div>

<p>以下将获取字符串流并将它们连接成一个字符串：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">concat</span> <span class="o">=</span> <span class="n">stringStream</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nl">StringBuilder:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span> 
             <span class="nl">StringBuilder:</span><span class="o">:</span><span class="n">append</span><span class="o">,</span>
             <span class="nl">StringBuilder:</span><span class="o">:</span><span class="n">append</span>
            <span class="o">).</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p>测试并行合并：无并行：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerStream2</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="kt">long</span><span class="o">[]</span> <span class="n">average</span> <span class="o">=</span> <span class="n">integerStream2</span><span class="o">.</span><span class="na">collect</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span>
        <span class="o">(</span><span class="n">ll</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">0</span><span class="o">]++;</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">},</span>
        <span class="o">(</span><span class="n">ll</span><span class="o">,</span> <span class="n">rr</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"合并操作"</span><span class="o">);</span><span class="c1">//无输出</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rr</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">average</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">/</span> <span class="n">average</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</code></pre></div></div>

<p>有并行：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerStream2</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">);</span>
<span class="kt">long</span><span class="o">[]</span> <span class="n">average</span> <span class="o">=</span> <span class="n">integerStream2</span><span class="o">.</span><span class="na">parallel</span><span class="o">().</span><span class="na">collect</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">2</span><span class="o">],</span>
        <span class="o">(</span><span class="n">ll</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">0</span><span class="o">]++;</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">},</span>
        <span class="o">(</span><span class="n">ll</span><span class="o">,</span> <span class="n">rr</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"合并操作"</span><span class="o">);</span><span class="c1">//输出八次</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">ll</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="n">rr</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="n">average</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">/</span> <span class="n">average</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
</code></pre></div></div>

<p>正常。</p>

<h3 id="区分转换与聚合">区分转换与聚合</h3>

<p><code class="language-plaintext highlighter-rouge">map()</code>、<code class="language-plaintext highlighter-rouge">filter()</code>、<code class="language-plaintext highlighter-rouge">reduce()</code>。这些操作对<code class="language-plaintext highlighter-rouge">Stream</code>来说可以分为两类，一类是转换操作，即把一个<code class="language-plaintext highlighter-rouge">Stream</code>转换为另一个<code class="language-plaintext highlighter-rouge">Stream</code>，例如<code class="language-plaintext highlighter-rouge">map()</code>和<code class="language-plaintext highlighter-rouge">filter()</code>，另一类是聚合操作，即对<code class="language-plaintext highlighter-rouge">Stream</code>的每个元素进行计算，得到一个确定的结果，例如<code class="language-plaintext highlighter-rouge">reduce()</code>。</p>

<p>区分这两种操作是非常重要的，因为对于<code class="language-plaintext highlighter-rouge">Stream</code>来说，对其进行转换操作并不会触发任何计算。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Supplier</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">++;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"得到参数："</span><span class="o">+</span><span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s4</span> <span class="o">=</span> <span class="n">s3</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s4</span><span class="o">);</span> <span class="c1">// 除此外，无其他输出</span>
</code></pre></div></div>

<p>转换操作只是保存了转换规则，无论对一个<code class="language-plaintext highlighter-rouge">Stream</code>转换多少次，都不会有任何实际计算发生。</p>

<p>而聚合操作则不一样，聚合操作会立刻促使<code class="language-plaintext highlighter-rouge">Stream</code>输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，对一个<code class="language-plaintext highlighter-rouge">Stream</code>进行聚合操作，会触发一系列连锁反应。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Supplier</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">++;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"得到参数："</span><span class="o">+</span><span class="n">n</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">s4</span> <span class="o">=</span> <span class="n">s3</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">s4</span><span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="mi">0L</span><span class="o">,</span> <span class="nl">Long:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
</code></pre></div></div>

<p>控制台：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>得到参数：1
得到参数：2
得到参数：3
得到参数：4
得到参数：5
得到参数：6
得到参数：7
得到参数：8
得到参数：9
得到参数：10
</code></pre></div></div>

<p>聚合操作是真正需要从<code class="language-plaintext highlighter-rouge">Stream</code>请求数据的，对一个<code class="language-plaintext highlighter-rouge">Stream</code>做聚合计算后，结果就不是一个<code class="language-plaintext highlighter-rouge">Stream</code>，而是一个其他的Java对象。</p>

<h3 id="转换为其他类型">转换为其他类型</h3>

<p><code class="language-plaintext highlighter-rouge">collect(Collectors.toList())</code>：将流中的元素收集到一个<code class="language-plaintext highlighter-rouge">List</code>中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">collect(Collectors.toSet())</code>：将流中的元素收集到一个<code class="language-plaintext highlighter-rouge">Set</code>中。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">collect(Collectors.joining(delimiter))</code>：将流中的元素拼接成一个字符串。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">", "</span><span class="o">));</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">toArray()</code> 是 <code class="language-plaintext highlighter-rouge">Stream</code> 类中的一个聚合方法，用于将流中的元素收集到一个数组中。该方法没有参数，返回一个包含流中所有元素的数组，语法如下：<code class="language-plaintext highlighter-rouge">Object[] toArray();</code>。</p>

<p>如果要将流中的元素收集到特定类型的数组中，可以使用带有 <code class="language-plaintext highlighter-rouge">IntFunction&lt;A[]&gt; generator</code> 参数的重载方法 <code class="language-plaintext highlighter-rouge">toArray(IntFunction&lt;A[]&gt; generator)</code>，其中 <code class="language-plaintext highlighter-rouge">generator</code> 是一个数组生成器函数，用于创建指定类型的数组。例如，如果要将流中的元素收集到一个 <code class="language-plaintext highlighter-rouge">String</code> 数组中，可以这样使用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">String</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">collect(Collectors.toMap(keyMapper, valueMapper))</code>：将流中的元素收集到一个<code class="language-plaintext highlighter-rouge">Map</code>中，可以指定key和value的映射关系。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"cherry"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">length</span><span class="o">,</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span><span class="c1">//{5=apple, 6=banana, 6=cherry}，注意到键的唯一性。</span>
</code></pre></div></div>

<hr />

<p>示例1：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>

<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">collect</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">collect</span><span class="o">);</span>
</code></pre></div></div>

<p>示例2：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">" 2019-12-31 "</span><span class="o">,</span> <span class="s">"2020 - 01-09 "</span><span class="o">,</span> <span class="s">"2020- 05 - 01 "</span><span class="o">,</span> <span class="s">"2022 - 02 - 01"</span><span class="o">,</span> <span class="s">" 2025-01 -01"</span><span class="o">};</span>
<span class="nc">LocalDate</span><span class="o">[]</span> <span class="n">array2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">array</span><span class="o">)</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">,</span> <span class="s">""</span><span class="o">))</span>
    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">LocalDate:</span><span class="o">:</span><span class="n">parse</span><span class="o">)</span>
    <span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">LocalDate</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">LocalDate</span> <span class="n">localDate</span> <span class="o">:</span> <span class="n">array2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">localDate</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="其他聚合方法">其他聚合方法</h3>

<p><code class="language-plaintext highlighter-rouge">collect(Collectors.groupingBy(classifier))</code>：根据指定的<strong>分类器</strong>对流中的元素进行<strong>分组</strong>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"cherry"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">groupedByLength</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">length</span><span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">groupedByLength</span><span class="o">);</span><span class="c1">//{5=[apple], 6=[banana, cherry]}</span>
</code></pre></div></div>

<p>还可以指定聚合的类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Banana"</span><span class="o">,</span> <span class="s">"Blackberry"</span><span class="o">,</span> <span class="s">"Coconut"</span><span class="o">,</span> <span class="s">"Avocado"</span><span class="o">,</span> <span class="s">"Cherry"</span><span class="o">,</span> <span class="s">"Apricots"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">groups</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
        <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> 
        <span class="nc">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">()</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">groups</span><span class="o">);</span><span class="c1">//{A=[Apple, Avocado, Apricots], B=[Banana, Blackberry], C=[Coconut, Cherry]}</span>
</code></pre></div></div>

<p>分组输出使用<code class="language-plaintext highlighter-rouge">Collectors.groupingBy()</code>，它需要提供两个函数：一个是分组的key，这里使用<code class="language-plaintext highlighter-rouge">s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code class="language-plaintext highlighter-rouge">String</code>分到一组，第二个是分组的value，这里直接使用<code class="language-plaintext highlighter-rouge">Collectors.toSet()</code>，表示输出为<code class="language-plaintext highlighter-rouge">Set</code>。</p>

<p>还支持嵌套分组：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Address</span><span class="o">[]</span> <span class="n">addresses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">[]{</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"湖南省"</span><span class="o">,</span> <span class="s">"长沙市"</span><span class="o">,</span> <span class="s">"岳麓区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"湖南省"</span><span class="o">,</span> <span class="s">"长沙市"</span><span class="o">,</span> <span class="s">"雨花区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"湖南省"</span><span class="o">,</span> <span class="s">"永州市"</span><span class="o">,</span> <span class="s">"零陵区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"湖南省"</span><span class="o">,</span> <span class="s">"永州市"</span><span class="o">,</span> <span class="s">"冷水滩区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"江苏省"</span><span class="o">,</span> <span class="s">"南京市"</span><span class="o">,</span> <span class="s">"建邺区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"江苏省"</span><span class="o">,</span> <span class="s">"南京市"</span><span class="o">,</span> <span class="s">"秦淮区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"江苏省"</span><span class="o">,</span> <span class="s">"苏州市"</span><span class="o">,</span> <span class="s">"吴江区"</span><span class="o">),</span>
                <span class="k">new</span> <span class="nf">Address</span><span class="o">(</span><span class="s">"江苏省"</span><span class="o">,</span> <span class="s">"苏州市"</span><span class="o">,</span> <span class="s">"姑苏区"</span><span class="o">),</span>
        <span class="o">};</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;&gt;&gt;</span> <span class="n">addressGrouping</span> <span class="o">=</span>
            <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">addresses</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span>
                <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
                    <span class="nl">Address:</span><span class="o">:</span><span class="n">province</span><span class="o">,</span>
                    <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
                        <span class="nl">Address:</span><span class="o">:</span><span class="n">city</span>
                    <span class="o">)</span>
                <span class="o">)</span>
            <span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">addressGrouping</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"="</span><span class="o">,</span><span class="s">":"</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">province</span><span class="o">,</span><span class="n">city</span><span class="o">,</span><span class="n">district</span><span class="o">;</span>

    <span class="nc">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">province</span><span class="o">,</span> <span class="nc">String</span> <span class="n">city</span><span class="o">,</span> <span class="nc">String</span> <span class="n">district</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">province</span> <span class="o">=</span> <span class="n">province</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="n">city</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">district</span> <span class="o">=</span> <span class="n">district</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">province</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">province</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">city</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">city</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">district</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">district</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"{province=\"%s\", city=\"%s\", district=\"%s\"}"</span><span class="o">,</span> <span class="n">province</span><span class="o">,</span> <span class="n">city</span><span class="o">,</span> <span class="n">district</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>控制台：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="err">江苏省:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">苏州市:</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"江苏省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"苏州市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"吴江区"</span><span class="p">},</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"江苏省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"苏州市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"姑苏区"</span><span class="p">}</span><span class="w">
        </span><span class="p">],</span><span class="w">
        </span><span class="err">南京市:</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"江苏省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"南京市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"建邺区"</span><span class="p">},</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"江苏省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"南京市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"秦淮区"</span><span class="p">}</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="err">湖南省:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="err">长沙市:</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"湖南省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"长沙市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"岳麓区"</span><span class="p">},</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"湖南省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"长沙市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"雨花区"</span><span class="p">}</span><span class="w">
        </span><span class="p">],</span><span class="w">
        </span><span class="err">永州市:</span><span class="w"> </span><span class="p">[</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"湖南省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"永州市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"零陵区"</span><span class="p">},</span><span class="w">
            </span><span class="p">{</span><span class="err">province:</span><span class="w"> </span><span class="s2">"湖南省"</span><span class="p">,</span><span class="w"> </span><span class="err">city:</span><span class="w"> </span><span class="s2">"永州市"</span><span class="p">,</span><span class="w"> </span><span class="err">district:</span><span class="w"> </span><span class="s2">"冷水滩区"</span><span class="p">}</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">collect(Collectors.partitioningBy(predicate))</code>：根据指定的<strong>条件</strong>对流中的元素进行<strong>分区</strong>，将满足条件的元素放入一个分区，不满足条件的放入另一个分区。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">,</span> <span class="s">"cherry"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Boolean</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">partitioned</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">partitioningBy</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"a"</span><span class="o">)));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">partitioned</span><span class="o">);</span><span class="c1">//{false=[banana, cherry], true=[apple]}</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">anyMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中<strong>是否存在</strong>满足指定条件的元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="n">anyMatch</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">anyMatch</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">anyMatch</span><span class="o">);</span><span class="c1">//true，因为流中有偶数元素。</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">allMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中的<strong>所有元素</strong>是否<strong>都满足</strong>指定条件。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="n">allMatch</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">allMatch</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">allMatch</span><span class="o">);</span><span class="c1">//true，因为流中所有元素都大于0。</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">noneMatch(Predicate&lt;? super T&gt; predicate)</code>：判断流中是否<strong>不存在</strong>满足指定条件的元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="kt">boolean</span> <span class="n">noneMatch</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">noneMatch</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">noneMatch</span><span class="o">);</span><span class="c1">//true，因为流中所有元素都不小于0。</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">forEach()</code>，可以循环处理<code class="language-plaintext highlighter-rouge">Stream</code>的每个元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">);</span>
<span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="其他转换操作">其他转换操作</h3>

<p>排序<code class="language-plaintext highlighter-rouge">sorted()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">,</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"Banana"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
</code></pre></div></div>

<p>此方法要求<code class="language-plaintext highlighter-rouge">Stream</code>的每个元素必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口。如果要自定义排序，传入指定的<code class="language-plaintext highlighter-rouge">Comparator</code>即可：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">,</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"Banana"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">sorted</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">compareToIgnoreCase</span><span class="o">)</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div>

<hr />

<p>去重，可以直接用<code class="language-plaintext highlighter-rouge">distinct()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"A"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">distinct</span><span class="o">()</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// [A, B, C, D]</span>
</code></pre></div></div>

<hr />

<p>截取操作常用于把一个无限的<code class="language-plaintext highlighter-rouge">Stream</code>转换成有限的<code class="language-plaintext highlighter-rouge">Stream</code>，<code class="language-plaintext highlighter-rouge">skip()</code>用于跳过当前<code class="language-plaintext highlighter-rouge">Stream</code>的前N个元素，<code class="language-plaintext highlighter-rouge">limit()</code>用于截取当前<code class="language-plaintext highlighter-rouge">Stream</code>最多前N个元素：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">,</span> <span class="s">"D"</span><span class="o">,</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"F"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">stream</span><span class="o">()</span>
    <span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// 跳过A, B</span>
    <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// 截取C, D, E</span>
    <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span> <span class="c1">// [C, D, E]</span>
</code></pre></div></div>

<hr />

<p>合并，将两个<code class="language-plaintext highlighter-rouge">Stream</code>合并为一个<code class="language-plaintext highlighter-rouge">Stream</code>可以使用<code class="language-plaintext highlighter-rouge">Stream</code>的静态方法<code class="language-plaintext highlighter-rouge">concat()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">).</span><span class="na">stream</span><span class="o">();</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"D"</span><span class="o">,</span> <span class="s">"E"</span><span class="o">).</span><span class="na">stream</span><span class="o">();</span>
<span class="c1">// 合并:</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">concat</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()));</span> <span class="c1">// [A, B, C, D, E]</span>
</code></pre></div></div>

<hr />

<p>如果<code class="language-plaintext highlighter-rouge">Stream</code>的元素是集合：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">));</span>
</code></pre></div></div>

<p>而我们希望把上述<code class="language-plaintext highlighter-rouge">Stream</code>转换为<code class="language-plaintext highlighter-rouge">Stream&lt;Integer&gt;</code>，就可以使用<code class="language-plaintext highlighter-rouge">flatMap()</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">list</span> <span class="o">-&gt;</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">());</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">flatMap()</code>，是指把<code class="language-plaintext highlighter-rouge">Stream</code>的每个元素（这里是<code class="language-plaintext highlighter-rouge">List</code>）映射为<code class="language-plaintext highlighter-rouge">Stream</code>，然后合并成一个新的<code class="language-plaintext highlighter-rouge">Stream</code>。</p>

<hr />

<p>并行，把一个普通<code class="language-plaintext highlighter-rouge">Stream</code>转换为可以并行处理的<code class="language-plaintext highlighter-rouge">Stream</code>非常简单，只需要用<code class="language-plaintext highlighter-rouge">parallel()</code>进行转换：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">parallel</span><span class="o">()</span> <span class="c1">// 变成一个可以并行处理的Stream</span>
                   <span class="o">.</span><span class="na">sorted</span><span class="o">()</span> <span class="c1">// 可以进行并行排序</span>
                   <span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">String</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div>

<p>经过<code class="language-plaintext highlighter-rouge">parallel()</code>转换后的<code class="language-plaintext highlighter-rouge">Stream</code>只要可能，就会对后续操作进行并行处理。不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升。</p>

<p>也可以通过<code class="language-plaintext highlighter-rouge">parallelStream()</code><strong>直接创建一个并行流</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">parallelStream</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">).</span><span class="na">parallelStream</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="特殊的方法">特殊的方法</h3>

<p>调试方法：<code class="language-plaintext highlighter-rouge">peek(Consumer&lt;? super T&gt; action)</code>：对流中的每个元素执行操作，并返回一个新的流。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
   <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">peeked</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                                <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<p>此方法需要在流真正计算的时候才会运行，即后面需要接聚合方法。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">findFirst()</code>：返回流中的第一个元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findFirst</span><span class="o">();</span>
<span class="n">first</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//1，因为流中的第一个元素是1。</span>
</code></pre></div></div>

<p>不会遍历流，只会取第一个：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">)</span><span class="c1">//1</span>
        <span class="o">.</span><span class="na">findFirst</span><span class="o">();</span>
<span class="n">first</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//1</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">findAny()</code>：返回流中的任意一个元素。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">any</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">findAny</span><span class="o">();</span>
<span class="n">any</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//输出结果为任意一个流中的元素。</span>
</code></pre></div></div>

<p>不会遍历流，只会取一个：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">any</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
        <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">)</span><span class="c1">//输出结果为任意一个流中的元素。</span>
        <span class="o">.</span><span class="na">findAny</span><span class="o">();</span>
<span class="n">any</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//与peek相同</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">count()</code>：返回流中元素的数量。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="na">count</span><span class="o">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">peek</code>可能无输出，即可能不会遍历流，但还是会消耗并关闭流</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">)</span><span class="c1">//无输出</span>
        <span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span><span class="c1">//5</span>
</code></pre></div></div>

<p>在调用 <code class="language-plaintext highlighter-rouge">count</code> 操作时。如果流源（如 <code class="language-plaintext highlighter-rouge">List</code>）已知其包含的元素数量，并且管道中的中间操作不改变元素数量（即它们是非破坏性的），则可以直接从源头计算数量，而无需实际遍历流或评估中间操作。</p>

<p><code class="language-plaintext highlighter-rouge">list</code> 的大小是已知的，而 <code class="language-plaintext highlighter-rouge">peek</code> 操作是非破坏性的（它只是简单地打印元素）。因此，流实现可以直接使用 <code class="language-plaintext highlighter-rouge">List</code> 的大小来确定计数，而无需实际打印元素或评估 <code class="language-plaintext highlighter-rouge">peek</code> 操作。</p>

<p>这种优化对于在不完全处理流的情况下确定计数很有用。然而，重要的是要注意，它依赖于特定的条件（已知大小，非破坏性的中间操作），并不总是适用。</p>

<p>依然会消耗流：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">)</span><span class="c1">//无输出</span>
        <span class="o">.</span><span class="na">count</span><span class="o">();</span>
<span class="n">stream</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span><span class="c1">//异常：流已关闭</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="collectors的方法"><code class="language-plaintext highlighter-rouge">Collectors</code>的方法</h3>

<p><code class="language-plaintext highlighter-rouge">Collectors</code> 类提供了许多静态工厂方法，用于创建各种收集器，可以用于将流中的元素收集到不同类型的集合中，或进行分组、分区等操作。</p>

<h4 id="基本收集器">基本收集器</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">toList()</code>：将流中的元素收集到一个 <code class="language-plaintext highlighter-rouge">List</code> 中。</li>
  <li><code class="language-plaintext highlighter-rouge">toSet()</code>：将流中的元素收集到一个 <code class="language-plaintext highlighter-rouge">Set</code> 中。</li>
  <li><code class="language-plaintext highlighter-rouge">toMap(keyMapper, valueMapper)</code>：将流中的元素收集到一个 <code class="language-plaintext highlighter-rouge">Map</code> 中，可以指定 <code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">value</code> 的映射关系。</li>
  <li><code class="language-plaintext highlighter-rouge">toMap(keyMapper, valueMapper, mergeFunction)</code>：将流中的元素收集到一个 <code class="language-plaintext highlighter-rouge">Map</code> 中，可以指定 <code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">value</code> 的映射关系，并使用指定的<strong>合并函数</strong>在收集过程中处理<strong>相同键</strong>的值。</li>
  <li><code class="language-plaintext highlighter-rouge">toConcurrentMap(keyMapper, valueMapper)</code>：将流中的元素收集到一个并发 <code class="language-plaintext highlighter-rouge">Map</code> 中，可以指定 <code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">value</code> 的映射关系。</li>
  <li><code class="language-plaintext highlighter-rouge">toConcurrentMap(keyMapper, valueMapper, mergeFunction)</code>：将流中的元素收集到一个并发 <code class="language-plaintext highlighter-rouge">Map</code> 中，可以指定 <code class="language-plaintext highlighter-rouge">key</code> 和 <code class="language-plaintext highlighter-rouge">value</code> 的映射关系，并使用指定的<strong>合并函数</strong>在收集过程中处理<strong>相同键</strong>的值。比如在合并函数中，如果遇到相同的键，则将旧值与新值用 <code class="language-plaintext highlighter-rouge">|</code> 连接起来。</li>
  <li><code class="language-plaintext highlighter-rouge">joining()</code>：将流中的元素连接成一个字符串。</li>
  <li><code class="language-plaintext highlighter-rouge">joining(delimiter)</code>：将流中的元素连接成一个字符串，使用指定的分隔符。</li>
  <li><code class="language-plaintext highlighter-rouge">joining(delimiter, prefix, suffix)</code>：将流中的元素连接成一个字符串，使用指定的分隔符、前缀和后缀。</li>
</ul>

<hr />

<h4 id="汇总统计收集器">汇总统计收集器</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">counting()</code>：计算流中元素的数量，返回一个 <code class="language-plaintext highlighter-rouge">long</code> 值。</li>
  <li><code class="language-plaintext highlighter-rouge">summarizingInt()</code>, <code class="language-plaintext highlighter-rouge">summarizingLong()</code>, <code class="language-plaintext highlighter-rouge">summarizingDouble()</code>：对流中的元素进行汇总统计，返回一个包含 <code class="language-plaintext highlighter-rouge">count</code>、<code class="language-plaintext highlighter-rouge">sum</code>、<code class="language-plaintext highlighter-rouge">min</code>、<code class="language-plaintext highlighter-rouge">average</code>、<code class="language-plaintext highlighter-rouge">max</code> 等统计信息的 <code class="language-plaintext highlighter-rouge">IntSummaryStatistics</code>、<code class="language-plaintext highlighter-rouge">LongSummaryStatistics</code> 或 <code class="language-plaintext highlighter-rouge">DoubleSummaryStatistics</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">averagingInt()</code>, <code class="language-plaintext highlighter-rouge">averagingLong()</code>, <code class="language-plaintext highlighter-rouge">averagingDouble()</code>：平均值，返回一个 <code class="language-plaintext highlighter-rouge">double</code> 值。</li>
  <li><code class="language-plaintext highlighter-rouge">summingInt()</code>，<code class="language-plaintext highlighter-rouge">summingLong()</code>，<code class="language-plaintext highlighter-rouge">summingDouble()</code>：求和。</li>
</ul>

<hr />

<h4 id="最大最小值收集器">最大最小值收集器</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">maxBy(comparator)</code>：根据指定的比较器找到流中的最大元素。</li>
  <li><code class="language-plaintext highlighter-rouge">minBy(comparator)</code>：根据指定的比较器找到流中的最小元素。</li>
</ul>

<hr />

<h4 id="分组和分区收集器">分组和分区收集器</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">groupingBy(classifier)</code>：根据指定的分类器对流中的元素进行分组。</li>
  <li><code class="language-plaintext highlighter-rouge">groupingBy(classifier, downstream)</code>：根据指定的分类器对流中的元素进行分组，并将结果传递给另一个收集器进行进一步的收集。</li>
  <li><code class="language-plaintext highlighter-rouge">groupingBy(classifier, supplier, downstream)</code>：根据指定的分类器对流中的元素进行分组，指定一个供应商（supplier），用于提供初始的 <code class="language-plaintext highlighter-rouge">Map</code> 容量大小，这在知道分组数量可能较大时可以提高性能，避免 <code class="language-plaintext highlighter-rouge">Map</code> 不断扩容，并将结果传递给另一个收集器进行进一步的收集。</li>
  <li><code class="language-plaintext highlighter-rouge">groupingByConcurrent(classifier)</code>：根据指定的分类器对流中的元素进行分组，并将结果放入一个并发 <code class="language-plaintext highlighter-rouge">Map</code> 中。</li>
  <li><code class="language-plaintext highlighter-rouge">groupingByConcurrent(classifier, downstream)</code>：根据指定的分类器对流中的元素进行分组，并将结果传递给另一个收集器进行进一步的收集，最终放入一个并发 <code class="language-plaintext highlighter-rouge">Map</code> 中。</li>
  <li><code class="language-plaintext highlighter-rouge">groupingByConcurrent(classifier, supplier, downstream)</code>：根据指定的分类器对流中的元素进行分组，并使用指定的供应商提供 Map 初始容量，并将结果传递给另一个收集器进行进一步的收集，最终放入一个并发 <code class="language-plaintext highlighter-rouge">Map</code> 中。</li>
  <li><code class="language-plaintext highlighter-rouge">partitioningBy(predicate)</code>：根据指定的条件对流中的元素进行分区。</li>
  <li><code class="language-plaintext highlighter-rouge">partitioningBy(predicate, downstream)</code>：根据指定的条件对流中的元素进行分区，并将结果传递给另一个收集器进行进一步的收集。</li>
</ul>

<hr />

<h4 id="其他收集器">其他收集器</h4>

<ul>
  <li><code class="language-plaintext highlighter-rouge">reducing(op)</code>：使用累加器函数递归地将流中的元素进行归约操作。</li>
  <li><code class="language-plaintext highlighter-rouge">reducing(identity, op)</code>：使用给定的初始值和累加器函数递归地将流中的元素进行归约操作。</li>
  <li><code class="language-plaintext highlighter-rouge">reducing(mapper, op)</code>：使用映射函数对流中的元素进行归约操作。</li>
  <li><code class="language-plaintext highlighter-rouge">mapping(mapper, downstream)</code>：对流中的元素进行映射，并将结果传递给另一个收集器进行进一步的收集。</li>
  <li><code class="language-plaintext highlighter-rouge">collectingAndThen(downstream, finisher)</code>：对收集器的结果应用一个转换函数。</li>
  <li><code class="language-plaintext highlighter-rouge">filtering(predicate, downstream)</code>：根据指定的条件对流中的元素进行过滤，并将结果传递给另一个收集器进行进一步的收集。</li>
  <li><code class="language-plaintext highlighter-rouge">flatMapping(mapper, downstream)</code>：对流中的元素进行扁平化映射，并将结果传递给另一个收集器进行进一步的收集。</li>
  <li><code class="language-plaintext highlighter-rouge">teeing(first, second, merger)</code>：对流中的元素应用两个收集器，然后使用提供的合并器对两个结果进行合并。</li>
</ul>

<p>这些方法提供了丰富的功能，可以灵活地处理流中的元素，进行分组、分区、汇总统计等操作，使得流式编程更加便捷和高效。</p>

<h4 id="示例">示例</h4>

<p>这里给出上述方法的一些示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>

<span class="c1">// counting()，'collect(counting())' 可被替换为 'count()'</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Count: "</span> <span class="o">+</span> <span class="n">count</span><span class="o">);</span>

<span class="c1">// summarizingInt()，count，sum，min，average，max</span>
<span class="nc">IntSummaryStatistics</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">summarizingInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Summarizing statistics: "</span> <span class="o">+</span> <span class="n">stats</span><span class="o">);</span>

<span class="c1">// averagingInt()，同average</span>
<span class="kt">double</span> <span class="n">average</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">averagingInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Average: "</span> <span class="o">+</span> <span class="n">average</span><span class="o">);</span>

<span class="c1">// groupingByConcurrent(classifier, supplier, downstream)</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Double</span><span class="o">&gt;</span> <span class="n">map1</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">%</span><span class="mi">3</span><span class="o">,</span>
        <span class="nl">HashMap:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span> <span class="c1">// 使用 HashMap 作为分组的初始容器</span>
        <span class="nc">Collectors</span><span class="o">.</span><span class="na">averagingDouble</span><span class="o">(</span><span class="n">x</span><span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="c1">// 统计每个分组的平均值</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="c1">//{0=6.0, 1=5.5, 2=5.0}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map1</span><span class="o">);</span>


<span class="c1">// reducing(),'collect(reducing())' 可被替换为 'reduce()'</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">reducing</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum: "</span> <span class="o">+</span> <span class="n">sum</span><span class="o">);</span>

<span class="c1">// collectingAndThen()，</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">valueOf</span><span class="o">).</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">collectingAndThen</span><span class="o">(</span>
        <span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">", "</span><span class="o">),</span>
        <span class="n">s</span> <span class="o">-&gt;</span> <span class="s">"["</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"]"</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="c1">//Result: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Result: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>


<span class="c1">// toMap(keyMapper, valueMapper, mergeFunction)</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map2</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">%</span><span class="mi">3</span><span class="o">,</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="s">"value"</span> <span class="o">+</span> <span class="n">num</span><span class="o">,</span>
        <span class="o">(</span><span class="n">existing</span><span class="o">,</span> <span class="n">replacement</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">existing</span> <span class="o">+</span> <span class="s">"|"</span> <span class="o">+</span> <span class="n">replacement</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="c1">// Map: {0=value3|value6|value9, 1=value1|value4|value7|value10, 2=value2|value5|value8}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Map: "</span> <span class="o">+</span> <span class="n">map2</span><span class="o">);</span>

<span class="c1">// toConcurrentMap(keyMapper, valueMapper)</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">concurrentMap1</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">toConcurrentMap</span><span class="o">(</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">,</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="s">"value"</span> <span class="o">+</span> <span class="n">num</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Concurrent map: "</span> <span class="o">+</span> <span class="n">concurrentMap1</span><span class="o">);</span>

<span class="c1">// toConcurrentMap(keyMapper, valueMapper, mergeFunction)</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">concurrentMap2</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">toConcurrentMap</span><span class="o">(</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="n">num</span><span class="o">%</span><span class="mi">5</span><span class="o">,</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="s">"value"</span> <span class="o">+</span> <span class="n">num</span><span class="o">,</span>
        <span class="c1">//在合并函数中，如果遇到相同的键，则将旧值与新值用 "|" 连接起来。</span>
        <span class="o">(</span><span class="n">existing</span><span class="o">,</span> <span class="n">replacement</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">existing</span> <span class="o">+</span> <span class="s">"|"</span> <span class="o">+</span> <span class="n">replacement</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Concurrent map: "</span> <span class="o">+</span> <span class="n">concurrentMap2</span><span class="o">);</span>

<span class="c1">// mapping(mapper, downstream)，'collect(mapping())' 可被替换为 'map().collect()'</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">mappedList</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">mapping</span><span class="o">(</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="s">"value"</span> <span class="o">+</span> <span class="n">num</span><span class="o">,</span>
        <span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="c1">//Mapped list: [value1, value2, value3, value4, value5, value6, value7, value8, value9, value10]</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Mapped list: "</span> <span class="o">+</span> <span class="n">mappedList</span><span class="o">);</span>

<span class="c1">// filtering(predicate, downstream)，同filter</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">filteredMap</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">filtering</span><span class="o">(</span>
        <span class="n">num</span> <span class="o">-&gt;</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">,</span>
        <span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="c1">//Filtered map: [2, 4, 6, 8, 10]</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Filtered map: "</span> <span class="o">+</span> <span class="n">filteredMap</span><span class="o">);</span>

<span class="c1">// flatMapping(mapper, downstream)，同flat</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">nestedList</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">),</span>
    <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">flattenedList</span> <span class="o">=</span> <span class="n">nestedList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
    <span class="nc">Collectors</span><span class="o">.</span><span class="na">flatMapping</span><span class="o">(</span>
        <span class="nl">List:</span><span class="o">:</span><span class="n">stream</span><span class="o">,</span>
        <span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">()</span>
    <span class="o">)</span>
<span class="o">);</span>
<span class="c1">//Flattened list: [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Flattened list: "</span> <span class="o">+</span> <span class="n">flattenedList</span><span class="o">);</span>
</code></pre></div></div>

<p>联合使用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.math.BigDecimal</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.Collectors</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>

        <span class="nc">Product</span> <span class="n">prod1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"15.5"</span><span class="o">),</span> <span class="s">"面包"</span><span class="o">,</span> <span class="s">"零食"</span><span class="o">);</span>
        <span class="nc">Product</span> <span class="n">prod2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">2L</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"20"</span><span class="o">),</span> <span class="s">"饼干"</span><span class="o">,</span> <span class="s">"零食"</span><span class="o">);</span>
        <span class="nc">Product</span> <span class="n">prod3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">3L</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"30"</span><span class="o">),</span> <span class="s">"月饼"</span><span class="o">,</span> <span class="s">"零食"</span><span class="o">);</span>
        <span class="nc">Product</span> <span class="n">prod4</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">4L</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"10"</span><span class="o">),</span> <span class="s">"青岛啤酒"</span><span class="o">,</span> <span class="s">"啤酒"</span><span class="o">);</span>
        <span class="nc">Product</span> <span class="n">prod5</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="mi">5L</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"15"</span><span class="o">),</span> <span class="s">"百威啤酒"</span><span class="o">,</span> <span class="s">"啤酒"</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">prodList</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">prod1</span><span class="o">,</span><span class="n">prod2</span><span class="o">,</span><span class="n">prod3</span><span class="o">,</span><span class="n">prod4</span><span class="o">,</span><span class="n">prod5</span><span class="o">);</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">prodMap</span> <span class="o">=</span> <span class="n">prodList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
                <span class="nl">Product:</span><span class="o">:</span><span class="n">getCategory</span><span class="o">,</span>
                <span class="c1">//求总数</span>
                <span class="nc">Collectors</span><span class="o">.</span><span class="na">counting</span><span class="o">()</span>
            <span class="o">)</span>
        <span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">prodMap</span><span class="o">);</span>

        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">prodMap2</span> <span class="o">=</span> <span class="n">prodList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
                <span class="nl">Product:</span><span class="o">:</span><span class="n">getCategory</span><span class="o">,</span>
                <span class="c1">//求和</span>
                <span class="nc">Collectors</span><span class="o">.</span><span class="na">summingInt</span><span class="o">(</span>
                    <span class="nl">Product:</span><span class="o">:</span><span class="n">getNum</span>
                <span class="o">)</span>
            <span class="o">)</span>
        <span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">prodMap2</span><span class="o">);</span>

        <span class="cm">/*把收集器的结果转换为另一种类型,String表示Category，
        Product表示每个分组中num属性最大的Product对象。*/</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">prodMap3</span> <span class="o">=</span> <span class="n">prodList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span><span class="c1">//按Category分组</span>
                <span class="nl">Product:</span><span class="o">:</span><span class="n">getCategory</span><span class="o">,</span>
                <span class="nc">Collectors</span><span class="o">.</span><span class="na">collectingAndThen</span><span class="o">(</span><span class="c1">//对结果进行转换</span>
                    <span class="c1">//对每个分组中的元素取num属性最大的Product对象。</span>
                    <span class="nc">Collectors</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span>
                        <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getNum</span><span class="o">)</span>
                    <span class="o">),</span>
                    <span class="c1">//这一步并没有直接得到最大的Product对象，而是得到了一个Optional&lt;Product&gt;对象</span>
                    <span class="c1">// ，因为有可能某个分组为空，所以需要用Optional来包装结果。</span>
                    <span class="nl">Optional:</span><span class="o">:</span><span class="n">get</span>
                <span class="o">)</span>
            <span class="o">)</span>
        <span class="o">);</span>
        <span class="c1">//{啤酒=Product{id=5, num=10, price=15, name='百威啤酒', category='啤酒'}, 零食=Product{id=3, num=3, price=30, name='月饼', category='零食'}}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">prodMap3</span><span class="o">);</span>
        <span class="cm">/*prodMap3可写为：*/</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">prodMap4</span> <span class="o">=</span> <span class="n">prodList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="nc">Collectors</span><span class="o">.</span><span class="na">toMap</span><span class="o">(</span>
                <span class="nl">Product:</span><span class="o">:</span><span class="n">getCategory</span><span class="o">,</span><span class="c1">//以Category为key</span>
                <span class="n">x</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">,</span><span class="c1">//value不变</span>
                <span class="nc">BinaryOperator</span><span class="o">.</span><span class="na">maxBy</span><span class="o">(</span><span class="c1">//对重复值取最大</span>
                    <span class="c1">//比较器</span>
                    <span class="nc">Comparator</span><span class="o">.</span><span class="na">comparingInt</span><span class="o">(</span><span class="nl">Product:</span><span class="o">:</span><span class="n">getNum</span><span class="o">)</span>
                <span class="o">)</span>
            <span class="o">)</span>
        <span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">prodMap4</span><span class="o">);</span>

        <span class="cm">/*联合其他收集器*/</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">prodMap5</span> <span class="o">=</span> <span class="n">prodList</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">collect</span><span class="o">(</span>
            <span class="nc">Collectors</span><span class="o">.</span><span class="na">groupingBy</span><span class="o">(</span>
                <span class="nl">Product:</span><span class="o">:</span><span class="n">getCategory</span><span class="o">,</span>
                <span class="nc">Collectors</span><span class="o">.</span><span class="na">mapping</span><span class="o">(</span>
                    <span class="cm">/*只取name，并放入set去重*/</span>
                    <span class="nl">Product:</span><span class="o">:</span><span class="n">getName</span><span class="o">,</span>
                    <span class="nc">Collectors</span><span class="o">.</span><span class="na">toSet</span><span class="o">()</span>
                <span class="o">)</span>
            <span class="o">)</span>
        <span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">prodMap5</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Product</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Integer</span> <span class="n">num</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BigDecimal</span> <span class="n">price</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">category</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">getNum</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">BigDecimal</span> <span class="nf">getPrice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCategory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">category</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">Product</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">num</span><span class="o">,</span> <span class="nc">BigDecimal</span> <span class="n">price</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">category</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">category</span> <span class="o">=</span> <span class="n">category</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Product{id=%d, num=%d, price=%s, name='%s', category='%s'}"</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">num</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">category</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>说明一下比较复杂的</p>

<p><code class="language-plaintext highlighter-rouge">prodMap3</code>：</p>

<p>按照<code class="language-plaintext highlighter-rouge">Product</code>对象的<code class="language-plaintext highlighter-rouge">Category</code>属性进行分组，并且对每个分组中的元素取<code class="language-plaintext highlighter-rouge">num</code>属性最大的<code class="language-plaintext highlighter-rouge">Product</code>对象。</p>

<p>具体来说，代码的执行步骤如下：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">prodList.stream()</code>：将<code class="language-plaintext highlighter-rouge">prodList</code>转换为一个<code class="language-plaintext highlighter-rouge">Stream</code>流。</li>
  <li><code class="language-plaintext highlighter-rouge">Collectors.groupingBy(Product::getCategory)</code>：使用<code class="language-plaintext highlighter-rouge">Collectors.groupingBy</code>方法按照<code class="language-plaintext highlighter-rouge">Product</code>对象的<code class="language-plaintext highlighter-rouge">Category</code>属性进行分组，得到一个<code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;Product&gt;&gt;</code>，其中<code class="language-plaintext highlighter-rouge">String</code>表示<code class="language-plaintext highlighter-rouge">Category</code>，<code class="language-plaintext highlighter-rouge">List&lt;Product&gt;</code>表示属于该<code class="language-plaintext highlighter-rouge">Category</code>的所有<code class="language-plaintext highlighter-rouge">Product</code>对象列表。</li>
  <li><code class="language-plaintext highlighter-rouge">Collectors.maxBy(Comparator.comparingInt(Product::getNum))</code>：使用<code class="language-plaintext highlighter-rouge">Collectors.maxBy</code>方法和<code class="language-plaintext highlighter-rouge">Comparator.comparingInt</code>方法找出每个分组中<code class="language-plaintext highlighter-rouge">num</code>属性最大的<code class="language-plaintext highlighter-rouge">Product</code>对象。这一步并没有直接得到最大的<code class="language-plaintext highlighter-rouge">Product</code>对象，而是得到了一个<code class="language-plaintext highlighter-rouge">Optional&lt;Product&gt;</code>对象，因为有可能某个分组为空，所以需要用<code class="language-plaintext highlighter-rouge">Optional</code>来包装结果。</li>
  <li><code class="language-plaintext highlighter-rouge">Collectors.collectingAndThen(..., Optional::get)</code>：使用<code class="language-plaintext highlighter-rouge">Collectors.collectingAndThen</code>方法对上一步得到的<code class="language-plaintext highlighter-rouge">Optional&lt;Product&gt;</code>对象进行处理，通过<code class="language-plaintext highlighter-rouge">Optional::get</code>方法获取其中的<code class="language-plaintext highlighter-rouge">Product</code>对象。这样就得到了每个分组中<code class="language-plaintext highlighter-rouge">num</code>属性最大的<code class="language-plaintext highlighter-rouge">Product</code>对象。</li>
  <li>最终，整个表达式将返回一个<code class="language-plaintext highlighter-rouge">Map&lt;String, Product&gt;</code>，其中<code class="language-plaintext highlighter-rouge">String</code>表示<code class="language-plaintext highlighter-rouge">Category</code>，<code class="language-plaintext highlighter-rouge">Product</code>表示每个分组中<code class="language-plaintext highlighter-rouge">num</code>属性最大的<code class="language-plaintext highlighter-rouge">Product</code>对象。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">prodMap5</code>：</p>

<p>按照 <code class="language-plaintext highlighter-rouge">Product</code> 对象的 <code class="language-plaintext highlighter-rouge">Category</code> 属性进行分组，并且将每个分组中的 <code class="language-plaintext highlighter-rouge">Product</code> 对象的 <code class="language-plaintext highlighter-rouge">Name</code> 属性收集到一个 <code class="language-plaintext highlighter-rouge">Set</code> 中。</p>

<p>具体来说，代码的执行步骤如下：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">prodList.stream()</code>：将 <code class="language-plaintext highlighter-rouge">prodList</code> 转换为一个 <code class="language-plaintext highlighter-rouge">Stream</code> 流。</li>
  <li><code class="language-plaintext highlighter-rouge">Collectors.groupingBy(Product::getCategory)</code>：使用 <code class="language-plaintext highlighter-rouge">Collectors.groupingBy</code> 方法按照 <code class="language-plaintext highlighter-rouge">Product</code> 对象的 <code class="language-plaintext highlighter-rouge">Category</code> 属性进行分组，得到一个 <code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;Product&gt;&gt;</code>，其中 <code class="language-plaintext highlighter-rouge">String</code> 表示 <code class="language-plaintext highlighter-rouge">Category</code>，<code class="language-plaintext highlighter-rouge">List&lt;Product&gt;</code> 表示属于该 <code class="language-plaintext highlighter-rouge">Category</code> 的所有 <code class="language-plaintext highlighter-rouge">Product</code> 对象列表。</li>
  <li><code class="language-plaintext highlighter-rouge">Collectors.mapping(Product::getName, Collectors.toSet())</code>：使用 <code class="language-plaintext highlighter-rouge">Collectors.mapping</code> 方法将每个分组中的 <code class="language-plaintext highlighter-rouge">Product</code> 对象转换为其 <code class="language-plaintext highlighter-rouge">Name</code> 属性，并将结果收集到一个 <code class="language-plaintext highlighter-rouge">Set</code> 中。这样就得到了一个 <code class="language-plaintext highlighter-rouge">Map&lt;String, Set&lt;String&gt;&gt;</code>，其中 <code class="language-plaintext highlighter-rouge">String</code> 表示 <code class="language-plaintext highlighter-rouge">Category</code>，<code class="language-plaintext highlighter-rouge">Set&lt;String&gt;</code> 表示每个分组中的 <code class="language-plaintext highlighter-rouge">Name</code> 属性集合。</li>
  <li>最终，整个表达式将返回一个 <code class="language-plaintext highlighter-rouge">Map&lt;String, Set&lt;String&gt;&gt;</code>，其中 <code class="language-plaintext highlighter-rouge">String</code> 表示 <code class="language-plaintext highlighter-rouge">Category</code>，<code class="language-plaintext highlighter-rouge">Set&lt;String&gt;</code> 表示每个分组中的 <code class="language-plaintext highlighter-rouge">Name</code> 属性集合。</li>
</ol>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">网络编程</title><link href="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="alternate" type="text/html" title="网络编程" /><published>2024-04-23T00:00:00+08:00</published><updated>2024-04-23T00:00:00+08:00</updated><id>/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B</id><content type="html" xml:base="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><![CDATA[<h1 id="引言">引言</h1>
<p>TCP、UDP、Email、HTTP、RMI。</p>

<h1 id="网络编程">网络编程</h1>

<p>网络编程是指编写能够在计算机网络上进行通信的程序的过程。网络编程涉及使用各种协议和技术来实现不同类型的网络通信，例如传输文件、发送电子邮件、浏览网页等。在网络编程中，通常涉及两个或多个计算机之间的数据交换，这些计算机通过网络连接在一起。</p>

<p>常见服务和对应端口号</p>

<table>
  <thead>
    <tr>
      <th>端口</th>
      <th>对应服务</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>7</td>
      <td>Echo服务器</td>
    </tr>
    <tr>
      <td>21</td>
      <td>Ftp</td>
    </tr>
    <tr>
      <td>23</td>
      <td>telnet</td>
    </tr>
    <tr>
      <td>25</td>
      <td>SMTP</td>
    </tr>
    <tr>
      <td>79</td>
      <td>Finger</td>
    </tr>
    <tr>
      <td>80</td>
      <td>HTTP</td>
    </tr>
    <tr>
      <td>110</td>
      <td>POP3</td>
    </tr>
    <tr>
      <td>143</td>
      <td>IMAP</td>
    </tr>
    <tr>
      <td>443</td>
      <td>HTTPS</td>
    </tr>
  </tbody>
</table>

<h2 id="tcp通信">TCP通信</h2>

<h3 id="socket概念">Socket概念</h3>

<p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<strong>特权端口</strong>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p>

<p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p>

<p>当Socket连接成功地在服务器端和客户端之间建立后：</p>

<ul>
  <li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li>
  <li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li>
</ul>

<p>Socket通常用来实现client-server连接。<code class="language-plaintext highlighter-rouge">java.net</code>包中定义的两个类<code class="language-plaintext highlighter-rouge">Socket</code>和<code class="language-plaintext highlighter-rouge">ServerSocket</code>,分别用来实现双向连接的<code class="language-plaintext highlighter-rouge">client</code>和<code class="language-plaintext highlighter-rouge">server</code>端.</p>

<p>创建<code class="language-plaintext highlighter-rouge">TCP Socket</code>需要的四个信息：</p>

<ul>
  <li>本地系统的<code class="language-plaintext highlighter-rouge">IP</code></li>
  <li>本地应用程序使用的<code class="language-plaintext highlighter-rouge">TCP</code>端口号</li>
  <li>远程系统的<code class="language-plaintext highlighter-rouge">IP</code></li>
  <li>远程应用程序相应的<code class="language-plaintext highlighter-rouge">TCP</code>端口号</li>
</ul>

<h3 id="inetaddress类">InetAddress类</h3>

<p><code class="language-plaintext highlighter-rouge">InetAddress</code> 类表示互联网协议 (IP) 地址。它提供了一种将 IP 地址和主机名之间进行转换的方法，以及创建原始套接字时所需的一些其他方法。<code class="language-plaintext highlighter-rouge">InetAddress</code> 类是用于网络编程的基础之一，可以用来确定主机的 IP 地址，或者将 IP 地址转换为主机名。</p>

<p>要获取<code class="language-plaintext highlighter-rouge">InetAddress</code> 类实例，可以使用其静态方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">InetAddress getByAddress(byte[] addr)</code>：根据原始 IP 地址获取 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">InetAddress getByAddress(String host, byte[] addr)</code>：根据主机名和原始 IP 地址获取 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">InetAddress getByName(String host)</code>：根据主机名获取 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">InetAddress[] getAllByName(String host)</code>：根据主机名获取所有与之关联的 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例数组。</li>
  <li><code class="language-plaintext highlighter-rouge">InetAddress getLocalHost()</code>：获取本地主机的 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li>
</ul>

<p>这些静态方法可用于创建 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例，以便与网络通信。</p>

<p><code class="language-plaintext highlighter-rouge">InetAddress</code> 类的常用方法包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getHostName()</code>：获取主机名。</li>
  <li><code class="language-plaintext highlighter-rouge">getCanonicalHostName()</code>：获取主机的全限定域名。</li>
  <li><code class="language-plaintext highlighter-rouge">getHostAddress()</code>：获取主机的 IP 地址字符串。</li>
  <li><code class="language-plaintext highlighter-rouge">isReachable(int timeout)</code>：测试是否可以达到该主机，在指定的超时时间内。</li>
  <li><code class="language-plaintext highlighter-rouge">isReachable(NetworkInterface netif, int ttl, int timeout)</code>：测试是否可以达到该主机，使用指定的网络接口和生存时间（TTL）。</li>
</ul>

<p>这些方法可用于获取主机名、IP 地址、测试主机的可达性等操作。</p>

<h3 id="socket类">Socket类</h3>

<p><code class="language-plaintext highlighter-rouge">Socket</code> 类在 Java 网络编程中扮演着重要的角色，它用于实现网络中的两个端点之间的通信。一个 <code class="language-plaintext highlighter-rouge">Socket</code> 实例表示一个网络中的端点，它可以用于发送和接收数据。<code class="language-plaintext highlighter-rouge">Socket</code> 可以连接到远程主机的某个端口，以便与之通信，也可以监听本地端口，等待其他程序的连接请求。</p>

<p>总的来说，<code class="language-plaintext highlighter-rouge">Socket</code> 的主要作用包括：</p>

<ul>
  <li><strong>建立连接：</strong> 客户端使用 <code class="language-plaintext highlighter-rouge">Socket</code> 来连接到服务器端的主机和端口，从而建立网络连接。</li>
  <li><strong>发送和接收数据：</strong> 通过 <code class="language-plaintext highlighter-rouge">Socket</code> 实例，可以发送数据到连接的另一端，并从另一端接收数据。</li>
  <li><strong>实现网络应用：</strong> <code class="language-plaintext highlighter-rouge">Socket</code> 是实现网络应用的基础，例如 Web 客户端、服务器、邮件客户端等。</li>
</ul>

<p>在 Java 中，<code class="language-plaintext highlighter-rouge">Socket</code> 类用于实现传输层的 TCP 协议，而 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 则用于在服务器端监听和接受客户端连接请求。</p>

<p><strong>Socket类构造器</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Socket()</code>: 创建一个未连接的Socket对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port, boolean stream)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，指定是否使用流模式。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，并绑定到指定的本地地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket(String host, int port)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket(String host, int port, boolean stream)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，指定是否使用流模式。</li>
  <li><code class="language-plaintext highlighter-rouge">Socket(String host, int port, InetAddress localAddr, int localPort)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，并绑定到指定的本地地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>: 创建一个<code class="language-plaintext highlighter-rouge">ServerSocket</code>对象，绑定到指定的端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int count)</code>: 创建一个<code class="language-plaintext highlighter-rouge">ServerSocket</code>对象，绑定到指定的端口号，并指定等待连接的队列长度。</li>
</ul>

<p><strong>Socket的常用方法</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">connect(SocketAddress endpoint)</code>: 连接到指定的远程端点。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getInputStream()</code>: 返回此套接字的输入流。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">getOutputStream()</code>: 返回此套接字的输出流。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">close()</code>: 关闭套接字连接。</li>
  <li><code class="language-plaintext highlighter-rouge">isConnected()</code>: 返回套接字连接的状态。</li>
  <li><code class="language-plaintext highlighter-rouge">isClosed()</code>: 返回套接字是否已关闭。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getInetAddress()</code>: 获取远程连接的IP地址。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">getLocalAddress()</code>: 获取本地连接的IP地址。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getPort()</code>: 获取远程连接的端口号。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">getLocalPort()</code>: 获取本地连接的端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">setSoTimeout(int timeout)</code>: 设置套接字的读取超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">setKeepAlive(boolean on)</code>: 设置套接字是否在空闲时保持连接。</li>
  <li><code class="language-plaintext highlighter-rouge">setTcpNoDelay(boolean on)</code>: 设置是否启用 Nagle 算法。</li>
</ul>

<h3 id="serversocket类">ServerSocket类</h3>

<p><code class="language-plaintext highlighter-rouge">ServerSocket</code> 类是 Java 网络编程中用于创建服务器端的类。通过 <code class="language-plaintext highlighter-rouge">ServerSocket</code>，可以监听指定的端口，等待客户端的连接请求，并在建立连接后与客户端进行通信。</p>

<p>一般来说，使用 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 的基本流程如下：</p>

<ol>
  <li>创建一个 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 实例，并指定服务器监听的端口。</li>
  <li>调用 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 的 <code class="language-plaintext highlighter-rouge">accept()</code> 方法，该方法会阻塞程序，直到有客户端连接请求到达。</li>
  <li>一旦有连接请求到达，<code class="language-plaintext highlighter-rouge">accept()</code> 方法会返回一个 <code class="language-plaintext highlighter-rouge">Socket</code> 实例，代表与客户端的连接。</li>
  <li>使用返回的 <code class="language-plaintext highlighter-rouge">Socket</code> 实例与客户端进行通信，可以发送和接收数据。</li>
  <li>当通信结束后，关闭 <code class="language-plaintext highlighter-rouge">Socket</code> 实例，并继续等待下一个连接请求。</li>
</ol>

<p><strong>构造器：</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>：用指定的端口<code class="language-plaintext highlighter-rouge">port</code>来创建一个侦听<code class="language-plaintext highlighter-rouge">Socket</code>。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int backlog)</code>：加上一个用来改变连接队列长度的参数<code class="language-plaintext highlighter-rouge">backlog</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int backlog, InetAddress localAddr)</code>：在机器存在多个<code class="language-plaintext highlighter-rouge">IP</code>地址的情况下，允许通过<code class="language-plaintext highlighter-rouge">localAddr</code>这个参数来指定侦听的<code class="language-plaintext highlighter-rouge">IP</code>地址。</li>
</ul>

<p><strong>常用方法：</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">accept()</code>: 监听并接受到此套接字的连接。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">bind(SocketAddress endpoint)</code>: 将套接字绑定到特定的本地地址和端口。</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code>: 关闭套接字。</li>
  <li><code class="language-plaintext highlighter-rouge">getInetAddress()</code>: 返回此套接字的本地地址。</li>
  <li><code class="language-plaintext highlighter-rouge">getLocalPort()</code>: 返回此套接字绑定的本地端口。</li>
  <li><code class="language-plaintext highlighter-rouge">setSoTimeout(int timeout)</code>: 设置通过<code class="language-plaintext highlighter-rouge">accept()</code>方法接受客户端连接的超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">getSoTimeout()</code>: 获取通过<code class="language-plaintext highlighter-rouge">accept()</code>方法接受客户端连接的超时时间。</li>
</ul>

<p>这些方法可用于管理<code class="language-plaintext highlighter-rouge">ServerSocket</code>的状态并与客户端进行通信。</p>

<h3 id="tcp使用实例">TCP使用实例</h3>

<p>服务端程序编写</p>

<ol>
  <li>调用<code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>创建一个服务端套接字，并绑定到指定端口上；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">accept()</code>监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">socket</code>类的<code class="language-plaintext highlighter-rouge">getOutputStream()</code>和<code class="language-plaintext highlighter-rouge">getlnputStream()</code>获取输入流和输出流</li>
  <li>关闭<code class="language-plaintext highlighter-rouge">socket</code>；</li>
</ol>

<p>客户端程序编写</p>

<ol>
  <li>调用<code class="language-plaintext highlighter-rouge">Socket()</code>创建流套接字，并链接到服务端；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">socket</code>类的<code class="language-plaintext highlighter-rouge">getOutputStream()</code>和<code class="language-plaintext highlighter-rouge">getInputStream()</code>获取输入流和输出流；</li>
  <li>关闭<code class="language-plaintext highlighter-rouge">socket</code>；</li>
</ol>

<p>客户端Socket的建立，链接服务器。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>服务器端Socket的建立</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"can not listen to :"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
        <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">socket</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>打开输入/出流</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintStream</span> <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>  
<span class="nc">DataInputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
</code></pre></div></div>

<p>关闭Socket</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<p>简单的<code class="language-plaintext highlighter-rouge">client</code>/<code class="language-plaintext highlighter-rouge">server</code>程序</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ConnectException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Server1</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"resource"</span><span class="o">)</span>  
            <span class="nc">ServerSocket</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8888</span><span class="o">);</span>  
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>  
                <span class="nc">Socket</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>  
                <span class="nc">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>  
                <span class="nc">DataOutputStream</span> <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="n">os</span><span class="o">);</span>  
                <span class="n">dos</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"Hello,"</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">getInetAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">"port#"</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">"bye-bye!"</span><span class="o">);</span>  
                <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
                <span class="n">s1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
                <span class="c1">// s.close();  </span>
            <span class="o">}</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Client1</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nc">Socket</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>  
            <span class="nc">InputStream</span> <span class="n">is</span> <span class="o">=</span><span class="n">s1</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>  
            <span class="nc">DataInputStream</span> <span class="n">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">is</span><span class="o">);</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dis</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>  
            <span class="n">dis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
            <span class="n">s1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ConnectException</span> <span class="n">connExc</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"服务器连接失败！"</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div>

<p>先运行服务器,然后运行客户端,会收到服务器发的信息.</p>

<p>例子二</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">1234</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Socket</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
                <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">()));</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好，端口"</span> <span class="o">+</span> <span class="n">sk</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，你成功连接了服务器："</span> <span class="o">+</span> <span class="n">server</span><span class="o">.</span><span class="na">getLocalPort</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">server</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Client1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">client</span><span class="o">;</span>
        <span class="nc">PrintStream</span> <span class="n">ps</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">1234</span><span class="o">);</span>
            <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>
            <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"哦，真好！"</span><span class="o">);</span>
            <span class="n">ps</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>例子三：</p>

<p>服务端：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServerSocket</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">6666</span><span class="o">);</span> <span class="c1">// 监听指定端口</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"服务器正在运行..."</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="nc">Socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span><span class="c1">//每有一个新客户端就返回一个Socket</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"connected from "</span> <span class="o">+</span> <span class="n">sock</span><span class="o">.</span><span class="na">getRemoteSocketAddress</span><span class="o">());</span>
            <span class="c1">// 用新线程处理</span>
            <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
                <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
                     <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">()</span>
                <span class="o">)</span> <span class="o">{</span>
                    <span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
                    <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好!\n"</span><span class="o">);</span><span class="c1">//注意加换行符，要不然客户端不会结束读取。</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span><span class="c1">//若没有新内容则阻塞。</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"再见"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"再见\n"</span><span class="o">);</span>
                            <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                            <span class="k">break</span><span class="o">;</span><span class="c1">//结束线程</span>
                        <span class="o">}</span>
                        <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"好的: "</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                        <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">sock</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ioe</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">}</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"客户端已断开连接."</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>代码<code class="language-plaintext highlighter-rouge">ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code class="language-plaintext highlighter-rouge">Socket</code>实例，这个<code class="language-plaintext highlighter-rouge">Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，就必须为每个新的<code class="language-plaintext highlighter-rouge">Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p>

<p>如果没有客户端连接进来，<code class="language-plaintext highlighter-rouge">accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code class="language-plaintext highlighter-rouge">ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code class="language-plaintext highlighter-rouge">accept()</code>就可以获取新的连接。</p>

<p>客户端：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">6666</span><span class="o">);</span> <span class="c1">// 连接指定服务器端口</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
             <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">var</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="kt">var</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[服务器] "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"&gt;&gt;&gt; "</span><span class="o">);</span> <span class="c1">// 打印提示</span>
                <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span> <span class="c1">// 读取一行输入</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span><span class="c1">//换行符</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="nc">String</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span><span class="c1">// 若没有新内容则阻塞。</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;&lt;&lt; "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"再见"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sock</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"断开连接."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当Socket连接创建成功后，无论是服务器端，还是客户端，都使用<code class="language-plaintext highlighter-rouge">Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>来封装Socket的数据流，这样使用Socket的流，和普通IO流类似：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用于读取网络数据:</span>
<span class="nc">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
<span class="c1">// 用于写入网络数据:</span>
<span class="nc">OutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
</code></pre></div></div>

<p>如果不调用<code class="language-plaintext highlighter-rouge">flush()</code>，很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而又想强制把这些数据发送到网络，就必须调用<code class="language-plaintext highlighter-rouge">flush()</code>强制把缓冲区数据发送出去。</p>

<p><strong>URL与Socket通信的区别</strong></p>

<p>利用<code class="language-plaintext highlighter-rouge">URL</code>进行通信与利用<code class="language-plaintext highlighter-rouge">socket</code>进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：</p>

<p>利用<code class="language-plaintext highlighter-rouge">socket</code>进行通信时，在服务器端运行一个<code class="language-plaintext highlighter-rouge">socket</code>通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在<code class="language-plaintext highlighter-rouge">socket</code>通信方式中，服务器是主动等待连接通信的到来。</p>

<p>利用<code class="language-plaintext highlighter-rouge">URL</code>进行通信时，在服务器端常驻一个<code class="language-plaintext highlighter-rouge">CGI</code>程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在<code class="language-plaintext highlighter-rouge">URL</code>通信方式中，服务器是被动等待连接通信的到来。</p>

<h2 id="udp通信">UDP通信</h2>

<p>在基于<code class="language-plaintext highlighter-rouge">TCP/IP</code>网络体系结构的网络中主要使用<code class="language-plaintext highlighter-rouge">TCP</code>和<code class="language-plaintext highlighter-rouge">UDP</code>（<code class="language-plaintext highlighter-rouge">UserDatagramProtocol</code>，用户数据报协议）来实现数据通信。<code class="language-plaintext highlighter-rouge">TCP</code>是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而<code class="language-plaintext highlighter-rouge">UDP</code>则是一种面向无连接的不可靠传输协议，它<strong>不能</strong>确保数据能正确到达目的端，但是它能<strong>提高网络通信的效率</strong>。</p>

<p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>

<p><strong>UDP Socket特性</strong></p>

<p>通过UDP的UDP端口来实现UDP协议的网络通信。</p>

<p>其工作过程如下：</p>

<ul>
  <li>创建一个适当的要发送且注明收发人地址数据报；</li>
  <li>为一个特定的应用程序建立一个传输端口来传送和接收数据包；</li>
  <li>将数据报插入一个传输端口中进行传输；</li>
  <li>等待接收来自于传输端口的一个数据报；</li>
  <li>解码数据报以解开消息、接收者和其它信息；</li>
</ul>

<h3 id="datagramsocket类">DatagramSocket类</h3>

<p><code class="language-plaintext highlighter-rouge">DatagramSocket</code> 类是用于实现 UDP 协议的套接字。</p>

<p>构造方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DatagramSocket()</code>：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）</li>
  <li><strong><code class="language-plaintext highlighter-rouge">DatagramSocket(int port)</code>：创建实例，并固定监听<code class="language-plaintext highlighter-rouge">Port</code>端口的报文。通常用于服务端</strong></li>
  <li><code class="language-plaintext highlighter-rouge">DatagramSocket(int port,InetAddress localAddr)</code>：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自<code class="language-plaintext highlighter-rouge">LocalAddr</code>的报文。</li>
</ul>

<p>方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">void bind(SocketAddress addr)</code>：将套接字绑定到指定的本地地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">void close()</code>：关闭套接字。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void connect(InetAddress address, int port)</code>：将套接字连接到指定的远程主机和端口号。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void disconnect()</code>：断开与远程主机的连接。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean getBroadcast()</code>：获取套接字的广播状态。</li>
  <li><code class="language-plaintext highlighter-rouge">Object getOption(int optID)</code>：获取套接字选项的当前值。</li>
  <li><code class="language-plaintext highlighter-rouge">int getPort()</code>：获取套接字绑定的本地端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">SocketAddress getLocalSocketAddress()</code>：获取套接字绑定的本地地址。</li>
  <li><code class="language-plaintext highlighter-rouge">InetAddress getLocalAddress()</code>：获取套接字绑定的本地 IP 地址。</li>
  <li><code class="language-plaintext highlighter-rouge">int getLocalPort()</code>：获取套接字绑定的本地端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">SocketAddress getRemoteSocketAddress()</code>：获取套接字连接的远程地址。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isBound()</code>：检查套接字是否绑定到本地地址。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isConnected()</code>：检查套接字是否连接到远程主机。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void receive(DatagramPacket p)</code>：接收一个数据包。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">void send(DatagramPacket p)</code>：发送一个数据包。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void setBroadcast(boolean on)</code>：设置套接字的广播状态。</li>
  <li><code class="language-plaintext highlighter-rouge">void setOption(int optID, Object value)</code>：设置套接字选项的值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setSoTimeout(int timeout)</code>：设置套接字的超时时间（接收数据时的超时时间）。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">int getSoTimeout()</code>：获取套接字的超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">String toString()</code>：返回套接字的字符串表示形式。</li>
</ul>

<hr />

<h3 id="datagrampacket类">DatagramPacket类</h3>

<p><code class="language-plaintext highlighter-rouge">DatagramPacket</code> 类表示数据报包，它包含了要发送或接收的数据以及目标地址和端口号等信息。</p>

<p>常用构造方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据，数据存储在 <code class="language-plaintext highlighter-rouge">buf</code> 中。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据到指定的地址和端口。</li>
  <li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据到指定的地址和端口。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, SocketAddress address)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据到指定的地址和端口。</li>
  <li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据到指定的地址和端口。</li>
</ul>

<p>这些构造方法可以用于创建不同类型的数据报包，以便发送或接收数据。</p>

<p>方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length)</code>：使用指定的缓冲区和长度创建一个 DatagramPacket，用于接收数据。</li>
  <li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>：使用指定的缓冲区、长度、远程主机地址和端口号创建一个 DatagramPacket，用于发送数据。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">byte[] getData()</code>：返回数据缓冲区。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setData(byte[] buf)</code>：设置数据缓冲区。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">int getLength()</code>：返回数据缓冲区的长度。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void setLength(int length)</code>：设置数据缓冲区的长度。</li>
  <li><code class="language-plaintext highlighter-rouge">InetAddress getAddress()</code>：返回远程主机的地址。</li>
  <li><code class="language-plaintext highlighter-rouge">void setAddress(InetAddress address)</code>：设置远程主机的地址。</li>
  <li><code class="language-plaintext highlighter-rouge">int getPort()</code>：返回远程主机的端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">void setPort(int port)</code>：设置远程主机的端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">SocketAddress getSocketAddress()</code>：返回远程主机的地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">void setSocketAddress(SocketAddress address)</code>：设置远程主机的地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">void setData(byte[] buf, int offset, int length)</code>：设置数据缓冲区的一部分。</li>
  <li><code class="language-plaintext highlighter-rouge">void setData(ByteBuffer buf)</code>：设置数据缓冲区。</li>
  <li><code class="language-plaintext highlighter-rouge">ByteBuffer getData()</code>：返回数据缓冲区。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">int getOffset()</code>：返回数据缓冲区的偏移量。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void setOffset(int offset)</code>：设置数据缓冲区的偏移量。</li>
  <li><code class="language-plaintext highlighter-rouge">void setLength(int length, InetAddress address, int port)</code>：设置数据缓冲区的长度、远程主机地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">void setAddress(InetAddress address, int port)</code>：设置远程主机的地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">void setAddress(SocketAddress address)</code>：设置远程主机的地址和端口号。</li>
  <li><code class="language-plaintext highlighter-rouge">SocketAddress getLocalSocketAddress()</code>：返回本地主机的地址和端口号。</li>
</ul>

<p>这些方法可以在数据报包中读取和设置数据，以及获取目标地址和端口号等信息。</p>

<hr />

<h3 id="udp使用实例">UDP使用实例</h3>

<p>在服务器端，使用UDP也需要监听指定的端口。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">(</span><span class="mi">6666</span><span class="o">);</span> <span class="c1">// 监听指定端口</span>
<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span> <span class="c1">// 无限循环</span>
    <span class="c1">// 数据缓冲区:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
    <span class="nc">DatagramPacket</span> <span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="n">ds</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span> <span class="c1">// 收取一个UDP数据包,阻塞</span>
    <span class="c1">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度，将其按UTF-8编码转换为String:</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getOffset</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getLength</span><span class="o">(),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="c1">// 发送数据:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"ACK"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
    <span class="n">packet</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">//设置数据包。</span>
    <span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">//发送</span>
<span class="o">}</span>
</code></pre></div></div>

<p>当服务器收到一个<code class="language-plaintext highlighter-rouge">DatagramPacket</code>后，通常必须立刻回复一个或多个UDP包，因为客户端地址在<code class="language-plaintext highlighter-rouge">DatagramPacket</code>中，每次收到的<code class="language-plaintext highlighter-rouge">DatagramPacket</code>可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。UDP 是无连接的协议，服务器在接收到 UDP 数据报后，通常需要<strong>立即</strong>给客户端发送响应，以确保通信的连续性和可靠性。没有响应的话，客户端<strong>可能会超时或者认为连接失败</strong>。</p>

<p>客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">();</span>
<span class="n">ds</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">//设置超时时间</span>
<span class="n">ds</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="nc">InetAddress</span><span class="o">.</span><span class="na">getByName</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">),</span> <span class="mi">6666</span><span class="o">);</span> <span class="c1">// 连接指定服务器和端口</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="nc">DatagramPacket</span> <span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">// 发送</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">// 收取一个UDP数据包,阻塞,超过超时时间则异常</span>
<span class="nc">String</span> <span class="n">resp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getOffset</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resp</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span><span class="c1">// 关闭</span>
<span class="n">ds</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<p>客户端创建<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code class="language-plaintext highlighter-rouge">setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p>

<p>客户端的<code class="language-plaintext highlighter-rouge">DatagramSocket</code>还调用了一个<code class="language-plaintext highlighter-rouge">connect()</code>方法“连接”到指定的服务器端。</p>

<p>这个<code class="language-plaintext highlighter-rouge">connect()</code>方法不是真连接，它是为了在客户端的<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p>

<p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p>

<p>如果客户端认为通信结束，就可以调用<code class="language-plaintext highlighter-rouge">disconnect()</code>断开连接：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ds</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例就可以连接另一个服务器端。</p>

<p>如果客户端希望向两个不同的服务器发送UDP包，有两种方法：</p>

<ol>
  <li>客户端可以创建两个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例，用<code class="language-plaintext highlighter-rouge">connect()</code>连接到不同的服务器；</li>
  <li>客户端也可以不调用<code class="language-plaintext highlighter-rouge">connect()</code>方法，而是在创建<code class="language-plaintext highlighter-rouge">DatagramPacket</code>的时候指定服务器地址，这样可以用一个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例发送<code class="language-plaintext highlighter-rouge">DatagramPacket</code>到不同的服务器。</li>
</ol>

<p>不调用<code class="language-plaintext highlighter-rouge">connect()</code>方法的代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">();</span>
<span class="n">ds</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
<span class="nc">InetAddress</span> <span class="n">localhost</span> <span class="o">=</span> <span class="nc">InetAddress</span><span class="o">.</span><span class="na">getByName</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="c1">// 发送到localhost:6666:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">packet1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data1</span><span class="o">,</span> <span class="n">data1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">localhost</span><span class="o">,</span> <span class="mi">6666</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet1</span><span class="o">);</span>
<span class="c1">// 发送到localhost:8888:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data2</span> <span class="o">=</span> <span class="s">"Hi"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">packet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data2</span><span class="o">,</span> <span class="n">data2</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">localhost</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet2</span><span class="o">);</span>
<span class="c1">// 关闭:</span>
<span class="n">ds</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="发送email">发送Email</h2>

<p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code class="language-plaintext highlighter-rouge">abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p>

<p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p>

<p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p>

<pre><code class="language-ascii">           ┌──────────┐    ┌──────────┐
           │PostOffice│    │PostOffice│     .───.
┌─────┐    ├──────────┤    ├──────────┤    (   ( )
│═══ ░│──▶│ ┌─┐ ┌┐┌┐  │──▶│ ┌─┐ ┌┐┌┐ │──▶ `─┬─'
└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
           └─┴─┴──────┘    └─┴─┴──────┘       │
</code></pre>

<p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p>

<pre><code class="language-ascii">             ┌─────────┐    ┌─────────┐    ┌─────────┐
             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
│       │──▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀──│       │
└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
   MUA           MTA            MTA            MDA           MUA
</code></pre>

<p>类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；</p>

<p>邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；</p>

<p>最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。</p>

<p>电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p>

<p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p>

<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p>

<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，无需关心SMTP协议的底层原理，只需要使用<code class="language-plaintext highlighter-rouge">JavaMail</code>这个标准API就可以直接发送邮件。</p>

<p>注：若在web邮箱中设置了“保存到已发送”，使用客户端SMTP服务发信时，已发邮件也会自动同步到网页端“已发送”文件夹内。</p>

<hr />

<p>假设准备使用自己的邮件地址<code class="language-plaintext highlighter-rouge">me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code class="language-plaintext highlighter-rouge">xiaoming@somewhere.com</code>，发送邮件前，首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code class="language-plaintext highlighter-rouge">smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p>

<ul>
  <li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；</li>
  <li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li>
  <li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。</li>
</ul>

<p>有了SMTP服务器的域名和端口号，还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p>

<p>使用<code class="language-plaintext highlighter-rouge">JavaMail</code>发送邮件，需要把<code class="language-plaintext highlighter-rouge">JavaMail</code>相关的两个依赖加入进来，注意版本号相同：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/jakarta.mail/jakarta.mail-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>jakarta.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jakarta.mail-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.sun.mail/jakarta.mail --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.sun.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jakarta.mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.mail-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.sun.mail/javax.mail --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.sun.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>

<p>并且代码引用的<code class="language-plaintext highlighter-rouge">jakarta.mail</code>需替换为<code class="language-plaintext highlighter-rouge">javax.mail</code>。</p>

<hr />

<h3 id="验证发送方信息">验证发送方信息</h3>

<p><code class="language-plaintext highlighter-rouge">Session</code>类是<code class="language-plaintext highlighter-rouge">JavaMail</code> API中表示邮件会话的类，它包含了创建和管理邮件的相关方法。以下是<code class="language-plaintext highlighter-rouge">Session</code>类的一些常用方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">getSession(Properties props, Authenticator authenticator)</code>：静态方法，用于获取<code class="language-plaintext highlighter-rouge">Session</code>实例。需要传入<code class="language-plaintext highlighter-rouge">Properties</code>对象和<code class="language-plaintext highlighter-rouge">Authenticator</code>对象来配置会话属性和认证信息。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">getTransport(String protocol)</code>：获取指定协议的<code class="language-plaintext highlighter-rouge">Transport</code>对象，用于发送邮件。</li>
  <li><code class="language-plaintext highlighter-rouge">getStore(String protocol)</code>：获取指定协议的<code class="language-plaintext highlighter-rouge">Store</code>对象，用于接收邮件。</li>
  <li><code class="language-plaintext highlighter-rouge">getDebug()</code>：获取调试模式的状态。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setDebug(boolean debug)</code>：设置调试模式的状态。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setProtocolForAddress(String type, String protocol)</code>：设置指定地址类型对应的协议。</li>
  <li><code class="language-plaintext highlighter-rouge">setProvider(Provider provider)</code>：设置指定协议的提供者。</li>
  <li><code class="language-plaintext highlighter-rouge">getProperty(String name)</code>：获取指定属性名的属性值。</li>
  <li><code class="language-plaintext highlighter-rouge">setProperty(String name, String value)</code>：设置指定属性名的属性值。</li>
  <li><code class="language-plaintext highlighter-rouge">getDefaultInstance(Properties props, Authenticator authenticator)</code>：静态方法，获取默认的<code class="language-plaintext highlighter-rouge">Session</code>实例。</li>
</ul>

<p>这些方法可以帮配置和管理邮件会话，以及创建<code class="language-plaintext highlighter-rouge">Transport</code>和<code class="language-plaintext highlighter-rouge">Store</code>对象来发送和接收邮件。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">Session</code> 可以配置的一些常见属性包括：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.host</code>: SMTP 服务器主机名。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.port</code>: SMTP 服务器端口号。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.auth</code>: 指定是否需要进行用户认证，通常为 <code class="language-plaintext highlighter-rouge">"true"</code>。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.starttls.enable</code>: 指定是否启用 STARTTLS 加密，通常为 <code class="language-plaintext highlighter-rouge">"true"</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.fallback</code>: 指定是否在连接失败时回退到普通套接字，通常为 <code class="language-plaintext highlighter-rouge">"false"</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.port</code>: 指定用于创建 SMTP 套接字的端口号，通常与 <code class="language-plaintext highlighter-rouge">mail.smtp.port</code> 相同。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.connectiontimeout</code>: 设置连接超时时间，以毫秒为单位。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.timeout</code>: 设置读取超时时间，以毫秒为单位。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.writetimeout</code>: 设置写入超时时间，以毫秒为单位。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.from</code>：设置发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.user</code>：设置 SMTP 认证的用户名。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.password</code>：设置 SMTP 认证的密码。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.class</code>: 指定用于创建 SMTP 套接字的 <code class="language-plaintext highlighter-rouge">SocketFactory</code> 类的名称， 可以设置为 <code class="language-plaintext highlighter-rouge">javax.net.ssl.SSLSocketFactory</code>，用于创建 SSL 套接字。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.enable</code>：指定是否启用 SSL 安全连接。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.trust</code>：指定信任的 SSL 服务器主机名列表。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.protocols</code>：指定使用的 SSL 协议列表。</li>
  <li><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.ciphersuites</code>：指定使用的 SSL 加密套件列表。</li>
</ul>

<p>中间的协议名改成对应的协议。这些属性可以用于配置 <code class="language-plaintext highlighter-rouge">Session</code> 实例，以控制邮件发送的行为和连接设置。</p>

<hr />

<p>通过<code class="language-plaintext highlighter-rouge">JavaMail</code> API连接到SMTP服务器上：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.Authenticator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.PasswordAuthentication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="o">...</span>
<span class="c1">// 服务器地址:</span>
<span class="nc">String</span> <span class="n">smtp</span> <span class="o">=</span> <span class="s">"smtp.163.com"</span><span class="o">;</span>
<span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"XXX@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"********"</span><span class="o">;</span>
<span class="c1">// 连接到SMTP服务器587端口:</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.host"</span><span class="o">,</span> <span class="s">"smtp.163.com"</span><span class="o">);</span> <span class="c1">// SMTP主机名</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"587"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用TLS加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
<span class="c1">// 获取Session实例:</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Authenticator</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">PasswordAuthentication</span> <span class="nf">getPasswordAuthentication</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PasswordAuthentication</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="c1">// 设置debug模式便于调试:</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div></div>

<p>以587端口为例，连接SMTP服务器时，需要准备一个<code class="language-plaintext highlighter-rouge">Properties</code>对象，填入相关信息。获取<code class="language-plaintext highlighter-rouge">Session</code>实例时，如果服务器需要认证，还需要传入一个<code class="language-plaintext highlighter-rouge">Authenticator</code>对象，用于提供用户名和密码进行身份验证。获取到<code class="language-plaintext highlighter-rouge">Session</code>实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p>

<p>SSL加密协议就用587端口，并改成以下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"587"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用TLS加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
</code></pre></div></div>

<p>TLS就用25端口（非SSL协议，看服务器传回的消息里表示会判断这个）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"25"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用TLS加密</span>
</code></pre></div></div>

<h3 id="发送邮件">发送邮件</h3>

<p><code class="language-plaintext highlighter-rouge">MimeMessage</code>是<code class="language-plaintext highlighter-rouge">Message</code>的实现类，用于创建多部分邮件消息。<code class="language-plaintext highlighter-rouge">MimeMessage</code>类提供了多个构造方法，主要用于创建不同类型的消息。以下是<code class="language-plaintext highlighter-rouge">MimeMessage</code>类的一些常用构造方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">MimeMessage(Session session)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, InputStream is)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象和输入流创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，从输入流中读取消息内容。</li>
  <li><code class="language-plaintext highlighter-rouge">MimeMessage(MimeMessage source)</code>：使用另一个<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例创建新的<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，复制源消息的内容。</li>
  <li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, byte[] content)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象和字节数组创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，字节数组包含消息的原始内容。</li>
  <li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, InputStream is, InternetHeaders headers)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象、输入流和邮件头信息创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，用于处理邮件头和消息内容分开的情况。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">MimeMessage</code>类提供了许多方法，用于<strong>设置和获取邮件消息的各种属性和内容</strong>。以下是<code class="language-plaintext highlighter-rouge">MimeMessage</code>类的一些常用方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">setSubject(String subject)</code>：设置邮件的主题为指定的字符串。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setSubject(String subject, String charset)</code>：设置邮件的主题为指定的字符串，并指定字符集。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setSubject(MimeMessage.RecipientType type, String subject)</code>：设置邮件的特定类型（如收件人、抄送人、密送人）的主题。</li>
  <li><code class="language-plaintext highlighter-rouge">setSubject(String subject, String charset, String encoding)</code>：设置邮件的主题为指定的字符串，并指定字符集和编码方式。</li>
  <li><code class="language-plaintext highlighter-rouge">setSubject(String subject, String charset, String encoding, MimeUtility.EncodedWord.Encoder encoder)</code>：设置邮件的主题为指定的字符串，并指定字符集、编码方式和编码器。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setFrom(Address address)</code>：设置发件人地址。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">setRecipient(Message.RecipientType type, Address address)</code>：设置收件人、抄送人或密送人地址。</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Message.RecipientType.TO</code>：主要收件人（”To”）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。</li>
      <li><code class="language-plaintext highlighter-rouge">Message.RecipientType.CC</code>：抄送（”Cc”），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。</li>
      <li><code class="language-plaintext highlighter-rouge">Message.RecipientType.BCC</code>：秘密抄送（”Bcc”），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">setContent(Object content, String contentType)</code>：设置邮件内容和内容类型。内容可以是字符串、字节数组或<code class="language-plaintext highlighter-rouge">Multipart</code>对象。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置纯文本邮件的内容。可以指定第二个参数文字编码，还可以指定第三个参数设置消息的子类型html或plain：</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setSentDate(Date date)</code>：设置邮件的发送日期。</li>
  <li><code class="language-plaintext highlighter-rouge">addHeader(String name, String value)</code>：添加邮件头。</li>
  <li><code class="language-plaintext highlighter-rouge">saveChanges()</code>：保存对邮件的更改。</li>
  <li><code class="language-plaintext highlighter-rouge">getSubject()</code>：获取邮件主题。</li>
  <li><code class="language-plaintext highlighter-rouge">getFrom()</code>：获取发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">getRecipients(Message.RecipientType type)</code>：获取指定类型的收件人、抄送人或密送人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">getContent()</code>：获取邮件内容。</li>
  <li><code class="language-plaintext highlighter-rouge">getSentDate()</code>：获取邮件发送日期。</li>
  <li><code class="language-plaintext highlighter-rouge">getAllHeaders()</code>：获取所有邮件头。</li>
  <li><code class="language-plaintext highlighter-rouge">getHeader(String name)</code>：根据名称获取邮件头的值。</li>
  <li><code class="language-plaintext highlighter-rouge">removeHeader(String name)</code>：移除指定名称的邮件头。</li>
  <li><code class="language-plaintext highlighter-rouge">getContentType()</code>：获取邮件内容类型。</li>
</ul>

<p>这些方法可以对邮件消息进行各种操作，包括设置和获取邮件的属性、内容，以及添加和移除邮件头等。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类用于表示<strong>电子邮件地址</strong>。它有几种不同的构造方法，可以根据需要选择使用：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, boolean strict)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例，并指定是否启用严格模式。</li>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal)</code>：使用给定的电子邮件地址字符串和个人名称创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset)</code>：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset, boolean strict)</code>：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类还提供了一些常用的方法，用于处理电子邮件地址的操作，例如：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String getAddress()</code>：获取电子邮件地址的地址部分（不包括个人名称）。</li>
  <li><code class="language-plaintext highlighter-rouge">String getPersonal()</code>：获取电子邮件地址的个人名称部分。</li>
  <li><code class="language-plaintext highlighter-rouge">void setAddress(String address)</code>：设置电子邮件地址的地址部分。</li>
  <li><code class="language-plaintext highlighter-rouge">void setPersonal(String personal)</code>：设置电子邮件地址的个人名称部分。</li>
  <li><code class="language-plaintext highlighter-rouge">String getType()</code>：获取电子邮件地址的类型。</li>
  <li><code class="language-plaintext highlighter-rouge">void setType(String type)</code>：设置电子邮件地址的类型。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isGroup()</code>：检查该地址是否表示一个邮件组。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isUnicodeSupported()</code>：检查是否支持 Unicode 编码。</li>
  <li><code class="language-plaintext highlighter-rouge">String toString()</code>：将 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 对象转换为字符串表示形式。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">Transport</code> 类用于<strong>发送邮件消息</strong>。以下是 <code class="language-plaintext highlighter-rouge">Transport</code> 类的一些常用方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">send(Message message)</code>：发送邮件消息。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">connect()</code>：连接到邮件服务器。</li>
  <li><code class="language-plaintext highlighter-rouge">connect(String host, String user, String password)</code>：连接到指定主机的邮件服务器。</li>
  <li><code class="language-plaintext highlighter-rouge">close()</code>：关闭连接。</li>
  <li><code class="language-plaintext highlighter-rouge">addConnectionListener(ConnectionListener listener)</code>：添加连接监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">removeConnectionListener(ConnectionListener listener)</code>：移除连接监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">addTransportListener(TransportListener listener)</code>：添加传输监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">removeTransportListener(TransportListener listener)</code>：移除传输监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">isConnected()</code>：检查是否已连接到邮件服务器。</li>
  <li><code class="language-plaintext highlighter-rouge">isSSL()</code>：检查是否使用 SSL 连接。</li>
  <li><code class="language-plaintext highlighter-rouge">getURLName()</code>：获取连接的 URL 名称。</li>
  <li><code class="language-plaintext highlighter-rouge">setURLName(URLName urlname)</code>：设置连接的 URL 名称。</li>
  <li><code class="language-plaintext highlighter-rouge">setDebug(boolean debug)</code>：设置调试模式，用于输出调试信息。</li>
</ul>

<p>这些方法可以连接到邮件服务器并发送邮件消息。</p>

<hr />

<p>发送邮件时，需要构造一个<code class="language-plaintext highlighter-rouge">Message</code>对象，然后调用<code class="language-plaintext highlighter-rouge">Transport.send(Message)</code>即可完成发送：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.internet.InternetAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MimeMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Transport</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"xiaoming@somewhere.com"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"这是一幅邮件"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div>

<p>绝大多数邮件服务器要求<strong>发送方地址和登录用户名必须一致</strong>，否则发送将失败。</p>

<p>填入真实的地址，运行上述代码，可以在控制台看到<code class="language-plaintext highlighter-rouge">JavaMail</code>打印的调试信息：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这是JavaMail打印的调试信息:
DEBUG: setDebug: Jakarta Mail version 2.0.1
DEBUG: getProvider() returning jakarta.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]
DEBUG SMTP: need username and password for authentication
DEBUG SMTP: protocolConnect returning false, host=smtp.163.com, user=XXX, password=&lt;null&gt;
DEBUG SMTP: useEhlo true, useAuth true
DEBUG SMTP: trying to connect to host "smtp.163.com", port 587, isSSL true
220 163.com Anti-spam GT for Coremail System (163com[20141201])
开始尝试连接smtp.163.comm:
DEBUG SMTP: connected to host "smtp.163.com", port: 587, ...
发送命令EHLO:
EHLO localhost
SMTP服务器响应250:
...
发送命令STARTTLS:
STARTTLS
SMTP服务器响应250:
...
尝试登录:
DEBUG SMTP: protocolConnect login, host=smtp.163.com, user=XXX@163.com, password=&lt;non-null&gt;
DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 
DEBUG SMTP: Using mechanism LOGIN
DEBUG SMTP: AUTH LOGIN command trace suppressed
登录成功:
DEBUG SMTP: AUTH LOGIN succeeded
DEBUG SMTP: use8bit false
开发发送邮件，设置FROM:
MAIL FROM:发件人
250 2.1.0 Sender OK
设置TO:
RCPT TO:收件人
250 2.1.5 Recipient OK
发送邮件数据:
DATA
服务器响应354:
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
真正的邮件数据:
Date: 时间
From: 发送方
To: 收件方
Message-ID: &lt;283383329.0.1713860754302@localhost&gt;
邮件主题是编码后的文本:
Subject: =?UTF-8?B?5L2g5aW9IQ==?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

邮件正文是Base64编码的文本:
5oiR5Y+R5LqG5LiA5Lu96YKu5Lu2
发送成功:
DEBUG SMTP: message successfully delivered to mail server
发送QUIT命令:
QUIT
服务器响应221结束TCP连接:
221 Bye
</code></pre></div></div>

<p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a href="https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p>

<p><strong>发送HTML邮件</strong></p>

<p>发送HTML邮件和文本邮件是类似的，只需要把：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"这是一幅邮件"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div>

<p>改为：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一幅邮件&lt;/h1&gt;"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">,</span> <span class="s">"html"</span><span class="o">);</span>
</code></pre></div></div>

<p>传入的<code class="language-plaintext highlighter-rouge">body</code>是类似<code class="language-plaintext highlighter-rouge">&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p>

<h3 id="发送附件">发送附件</h3>

<p><code class="language-plaintext highlighter-rouge">MimeMultipart</code> 是 <code class="language-plaintext highlighter-rouge">JavaMail</code> 中用于处理多部分 MIME 消息的类，<code class="language-plaintext highlighter-rouge">MimeMultipart</code> 类有多个构造方法，用于创建不同类型的多部分消息。以下是一些常用的构造方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">MimeMultipart()</code>：创建一个空的多部分消息，默认使用混合 (<code class="language-plaintext highlighter-rouge">mixed</code>) 类型。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">MimeMultipart(String subtype)</code>：根据指定的子类型创建一个空的多部分消息。常用的子类型包括 <code class="language-plaintext highlighter-rouge">related</code>（相关）、<code class="language-plaintext highlighter-rouge">alternative</code>（备选）、<code class="language-plaintext highlighter-rouge">mixed</code>（混合）等。例如：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">MimeMultipart("related")</code>：创建一个相关类型的多部分消息。</li>
      <li><code class="language-plaintext highlighter-rouge">MimeMultipart("alternative")</code>：创建一个备选类型的多部分消息。</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">MimeMultipart(javax.mail.internet.ContentType contentType)</code>：根据指定的 <code class="language-plaintext highlighter-rouge">ContentType</code> 对象创建一个空的多部分消息。ContentType 对象可以包含主类型、子类型、参数等信息。</li>
  <li><code class="language-plaintext highlighter-rouge">MimeMultipart(InputStream is)</code>：从输入流中读取内容，并根据读取的内容创建一个多部分消息。</li>
</ul>

<p>这些构造方法提供了不同的方式来创建 <code class="language-plaintext highlighter-rouge">MimeMultipart</code> 对象，以满足不同场景下的需求。</p>

<p><strong>常用方法包括：</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">addBodyPart(BodyPart part)</code>：将一个 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象添加到多部分消息中。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">removeBodyPart(int index)</code>：从多部分消息中移除指定索引位置的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">getBodyPart(int index)</code>：获取多部分消息中指定索引位置的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">getBodyPart(String CID)</code>：根据 Content-ID（CID）获取多部分消息中对应的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">getBodyPartCount()</code>：获取多部分消息中 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象的数量。</li>
  <li><code class="language-plaintext highlighter-rouge">setSubType(String subtype)</code>：设置多部分消息的子类型（subtype），例如 “mixed”、”alternative” 等。</li>
  <li><code class="language-plaintext highlighter-rouge">setPreamble(String preamble)</code>：设置消息的开头部分（preamble）。</li>
  <li><code class="language-plaintext highlighter-rouge">setEpilogue(String epilogue)</code>：设置消息的结尾部分（epilogue）。</li>
  <li><code class="language-plaintext highlighter-rouge">writeTo(OutputStream os)</code>：将多部分消息写入输出流中。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 类用于表示邮件的各个部分，包括正文、附件等。它的构造方法相对简单，通常使用默认构造方法创建对象，然后使用 <code class="language-plaintext highlighter-rouge">setContent</code> 等方法设置内容。以下是 <code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 的构造方法：</p>

<ul>
  <li><strong>默认构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart()</code></strong></li>
  <li>使用输入流构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart(InputStream is)</code></li>
  <li>使用 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart(DataSource ds)</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 类的方法如下：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">addHeader(String name, String value)</code>：添加指定名称和值的头信息。</li>
  <li><code class="language-plaintext highlighter-rouge">addHeaderLine(String line)</code>：添加包含完整头信息行的字符串。</li>
  <li><code class="language-plaintext highlighter-rouge">setContentID(String cid)</code>：设置内容 ID。</li>
  <li><code class="language-plaintext highlighter-rouge">setContentLanguage(String[] languages)</code>：设置内容语言。</li>
  <li><code class="language-plaintext highlighter-rouge">setContentTransferEncoding(String encoding)</code>：设置内容传输编码。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setDataHandler(DataHandler dh)</code>：设置数据处理程序。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setDescription(String description)</code>：设置描述信息。</li>
  <li><code class="language-plaintext highlighter-rouge">setDisposition(String disposition)</code>：设置附件描述。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setFileName(String filename)</code>：设置文件名。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setHeader(String name, String value)</code>：设置指定名称的头信息值。</li>
  <li><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置文本内容。</li>
  <li><code class="language-plaintext highlighter-rouge">updateHeaders()</code>：更新所有头信息。</li>
  <li><code class="language-plaintext highlighter-rouge">addRecipient(Message.RecipientType type, Address address)</code>：添加接收者地址。</li>
  <li><code class="language-plaintext highlighter-rouge">getAllHeaders()</code>：获取所有头信息。</li>
  <li><code class="language-plaintext highlighter-rouge">getContentType()</code>：获取内容类型。</li>
  <li><code class="language-plaintext highlighter-rouge">getDataHandler()</code>：获取数据处理程序。</li>
  <li><code class="language-plaintext highlighter-rouge">getDescription()</code>：获取描述信息。</li>
  <li><code class="language-plaintext highlighter-rouge">getDisposition()</code>：获取附件描述。</li>
  <li><code class="language-plaintext highlighter-rouge">getFileName()</code>：获取文件名。</li>
  <li><code class="language-plaintext highlighter-rouge">getHeader(String name)</code>：根据名称获取头信息值。</li>
  <li><code class="language-plaintext highlighter-rouge">getInputStream()</code>：获取输入流。</li>
  <li><code class="language-plaintext highlighter-rouge">getLineCount()</code>：获取行数。</li>
  <li><code class="language-plaintext highlighter-rouge">getSize()</code>：获取大小。</li>
  <li><code class="language-plaintext highlighter-rouge">getText()</code>：获取文本内容。</li>
  <li><code class="language-plaintext highlighter-rouge">isMimeType(String mimeType)</code>：检查是否与指定的 MIME 类型匹配。</li>
  <li><code class="language-plaintext highlighter-rouge">removeHeader(String name)</code>：移除指定名称的头信息。</li>
  <li><code class="language-plaintext highlighter-rouge">setContent(Multipart mp)</code>：设置内容为多部分。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setContent(Object obj, String type)</code>：设置内容对象和类型。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setContent(Multipart mp)</code>：设置内容为多部分。</li>
  <li><code class="language-plaintext highlighter-rouge">setContentID(String cid)</code>：设置内容 ID。</li>
  <li><code class="language-plaintext highlighter-rouge">setContentLanguage(String[] languages)</code>：设置内容语言。</li>
  <li><code class="language-plaintext highlighter-rouge">setDataHandler(DataHandler dh)</code>：设置数据处理程序。</li>
  <li><code class="language-plaintext highlighter-rouge">setDisposition(String disposition)</code>：设置附件描述。</li>
  <li><code class="language-plaintext highlighter-rouge">setFileName(String filename)</code>：设置文件名。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">setHeader(String name, String value)</code>：设置指定名称的头信息值。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置文本内容。</li>
  <li><code class="language-plaintext highlighter-rouge">setText(String text, String charset)</code>：设置文本内容和字符集。</li>
</ul>

<p>这些方法可以用于配置和操作 <code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 对象的各种属性和内容。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">DataHandler</code> 的构造方法通常用于创建一个处理特定数据类型的数据处理程序对象。它有以下几个常用的构造方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">DataHandler(Object obj, String mimeType)</code>：使用给定的对象和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于将 Java 对象转换为数据处理程序。</li>
  <li><code class="language-plaintext highlighter-rouge">DataHandler(URL url)</code>：使用给定的 URL 创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于处理指向外部资源的 URL。</li>
  <li><code class="language-plaintext highlighter-rouge">DataHandler(DataSource dataSource)</code>：使用给定的数据源创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于处理数据源对象。</li>
</ul>

<p>这些构造方法根据不同的数据类型和来源创建适当的数据处理程序对象，以便于在应用程序中处理和传输数据。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 的构造方法通常用于创建一个包含字节数组数据的数据源对象。它有以下两个常用的构造方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ByteArrayDataSource(byte[] data, String type)</code>：使用给定的字节数组和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">ByteArrayDataSource(InputStream is, String type)</code>：使用给定的输入流和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 对象。</li>
</ul>

<p>这些构造方法将字节数组或输入流与 MIME 类型关联起来，以便于处理和传输数据。</p>

<hr />

<p>常用文件的 MIME 类型如下：</p>

<ul>
  <li>文本文件：<code class="language-plaintext highlighter-rouge">text/plain</code></li>
  <li>HTML 文件：<code class="language-plaintext highlighter-rouge">text/html</code></li>
  <li>XML 文件：<code class="language-plaintext highlighter-rouge">application/xml</code></li>
  <li>JSON 文件：<code class="language-plaintext highlighter-rouge">application/json</code></li>
  <li>图片文件：<code class="language-plaintext highlighter-rouge">image/jpeg</code>、<code class="language-plaintext highlighter-rouge">image/png</code>、<code class="language-plaintext highlighter-rouge">image/gif</code>、<code class="language-plaintext highlighter-rouge">image/webp</code></li>
  <li>视频文件：<code class="language-plaintext highlighter-rouge">video/mp4</code>、<code class="language-plaintext highlighter-rouge">video/quicktime</code></li>
  <li>音频文件：<code class="language-plaintext highlighter-rouge">audio/mpeg</code>、<code class="language-plaintext highlighter-rouge">audio/wav</code></li>
  <li>PDF 文件：<code class="language-plaintext highlighter-rouge">application/pdf</code></li>
  <li>Word 文档：<code class="language-plaintext highlighter-rouge">application/msword</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.wordprocessingml.document</code></li>
  <li>Excel 表格：<code class="language-plaintext highlighter-rouge">application/vnd.ms-excel</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code></li>
  <li>PowerPoint 演示文稿：<code class="language-plaintext highlighter-rouge">application/vnd.ms-powerpoint</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.presentationml.presentation</code></li>
  <li>压缩文件：<code class="language-plaintext highlighter-rouge">application/zip</code></li>
  <li>二进制文件的 MIME 类型通常是 <code class="language-plaintext highlighter-rouge">application/octet-stream</code>。这个 MIME 类型通常用于表示未知的二进制数据类型，或者不属于其他已知 MIME 类型的二进制数据。</li>
</ul>

<p>这些 MIME 类型可以帮助浏览器和其他应用程序识别文件的类型并采取相应的处理方式。</p>

<hr />

<p>要在电子邮件中携带附件，就不能直接调用<code class="language-plaintext highlighter-rouge">message.setText()</code>方法，而是要构造一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeBodyPart</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeMultipart</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.util.ByteArrayDataSource</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"XXX"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMultipart</span><span class="o">();</span>
<span class="c1">// 添加text:</span>
<span class="nc">BodyPart</span> <span class="n">textpart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">textpart</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一幅邮件&lt;/h1&gt;"</span><span class="o">,</span> <span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">textpart</span><span class="o">);</span>
<span class="c1">// 添加附件:</span>
<span class="nc">BodyPart</span> <span class="n">annex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setFileName</span><span class="o">(</span><span class="s">"附件1.7z"</span><span class="o">);</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayDataSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"Maven.7z"</span><span class="o">),</span> <span class="s">"application/octet-stream"</span><span class="o">)));</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">annex</span><span class="o">);</span>
<span class="c1">// 设置邮件内容为multipart:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">multipart</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div>

<p>一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象可以添加若干个<code class="language-plaintext highlighter-rouge">BodyPart</code>，其中<strong>第一个</strong><code class="language-plaintext highlighter-rouge">BodyPart</code>是文本，即邮件正文，后面的<code class="language-plaintext highlighter-rouge">BodyPart</code>是附件。</p>

<p><code class="language-plaintext highlighter-rouge">BodyPart</code>依靠<code class="language-plaintext highlighter-rouge">setContent()</code>决定添加的内容。</p>

<p>如果添加文本，用<code class="language-plaintext highlighter-rouge">setContent("...", "text/plain;charset=utf-8")</code>添加纯文本，或者用<code class="language-plaintext highlighter-rouge">setContent("...", "text/html;charset=utf-8")</code>添加HTML文本。</p>

<p>如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code class="language-plaintext highlighter-rouge">DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code class="language-plaintext highlighter-rouge">application/octet-stream</code>，Word文档则是<code class="language-plaintext highlighter-rouge">application/msword</code>。</p>

<p>最后，通过<code class="language-plaintext highlighter-rouge">setContent()</code>把<code class="language-plaintext highlighter-rouge">Multipart</code>添加到<code class="language-plaintext highlighter-rouge">Message</code>中，即可发送。</p>

<p><code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 是 <code class="language-plaintext highlighter-rouge">javax.mail.util.ByteArrayDataSource</code> 类的一个子类，用于从字节数组中创建数据源对象。在这个特定的代码片段中，它的作用是将 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 对象中的数据转换为字节数组，并将其作为数据源传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法。</p>

<p><code class="language-plaintext highlighter-rouge">DataHandler</code> 用于将数据封装为一种适合传输的格式，它可以处理各种类型的数据，如字节数组、文件、URL 等。在这里，<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 负责将文件中的数据读取到字节数组中，然后 <code class="language-plaintext highlighter-rouge">DataHandler</code> 将这个字节数组封装为一个数据处理程序，以便于传输和处理。</p>

<p>如果去掉<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code>，会报错：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"3.png"</span><span class="o">),</span> <span class="s">"image/png"</span><span class="o">));</span>
</code></pre></div></div>

<p>报错是因为 <code class="language-plaintext highlighter-rouge">DataHandler</code> 的构造方法不接受 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 对象作为参数，而是需要一个 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象。<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 实现了 <code class="language-plaintext highlighter-rouge">DataSource</code> 接口，因此可以作为参数传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法。如果直接将 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法，它将无法识别并处理文件流，从而导致错误。因此，需要使用 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 将文件流转换为 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象，以便 <code class="language-plaintext highlighter-rouge">DataHandler</code> 可以正确处理图像数据。</p>

<h3 id="发送内嵌图片的html邮件">发送内嵌图片的HTML邮件</h3>

<p><code class="language-plaintext highlighter-rouge">setHeader</code> 方法用于设置邮件头的值，其参数为邮件头的名称和对应的值。常用的邮件头包括但不限于：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">From</code>：发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">To</code>：收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">Cc</code>：抄送地址。</li>
  <li><code class="language-plaintext highlighter-rouge">Bcc</code>：密送地址。</li>
  <li><code class="language-plaintext highlighter-rouge">Subject</code>：邮件主题。</li>
  <li><code class="language-plaintext highlighter-rouge">Date</code>：邮件发送时间。</li>
  <li><code class="language-plaintext highlighter-rouge">Content-Type</code>：内容类型。</li>
  <li><code class="language-plaintext highlighter-rouge">Content-Disposition</code>：内容描述。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Content-ID</code>：内容 ID。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">MIME-Version</code>：MIME 版本。</li>
  <li><code class="language-plaintext highlighter-rouge">Reply-To</code>：回复地址。</li>
  <li><code class="language-plaintext highlighter-rouge">Return-Path</code>：返回路径。</li>
  <li><code class="language-plaintext highlighter-rouge">Message-ID</code>：消息 ID。</li>
</ul>

<p>这些参数的设置可以根据邮件的需求和格式进行配置，以满足邮件发送的要求和格式规范。</p>

<hr />

<p>HTML邮件中可以内嵌图片。如果给一个<code class="language-plaintext highlighter-rouge">&lt;img src="http://example.com/test.jpg"&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p>

<p>内嵌图片实际上也是一个附件，即邮件本身也是<code class="language-plaintext highlighter-rouge">Multipart</code>，但需要做一点额外的处理：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"XXX"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMultipart</span><span class="o">();</span>
<span class="c1">// 添加text:</span>
<span class="nc">BodyPart</span> <span class="n">textpart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">textpart</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一个带图片的邮件&lt;/h1&gt;&lt;p&gt;&lt;img src='cid:img01'"</span><span class="o">,</span> <span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">textpart</span><span class="o">);</span>
<span class="c1">// 添加附件:</span>
<span class="nc">BodyPart</span> <span class="n">annex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setFileName</span><span class="o">(</span><span class="s">"图片1.png"</span><span class="o">);</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayDataSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"3.png"</span><span class="o">),</span> <span class="s">"image/png"</span><span class="o">)));</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Content-ID"</span><span class="o">,</span><span class="s">"&lt;img01&gt;"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">annex</span><span class="o">);</span>
<span class="c1">// 设置邮件内容为multipart:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">multipart</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div>

<p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code class="language-plaintext highlighter-rouge">&lt;img src='cid:img01'"&gt;</code>引用，然后，在添加图片作为<code class="language-plaintext highlighter-rouge">BodyPart</code>时，除了要正确设置MIME类型（根据图片类型使用<code class="language-plaintext highlighter-rouge">image/jpeg</code>或<code class="language-plaintext highlighter-rouge">image/png</code>），还需要设置一个Header：<code class="language-plaintext highlighter-rouge">imagepart.setHeader("Content-ID", "&lt;img01&gt;");</code>。</p>

<h3 id="发送给多个收件人">发送给多个收件人</h3>

<p><strong>设置收件人和发件人：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">addFrom(Address[] addresses)</code>: 添加发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">addFrom(String addresses)</code>: 添加发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">addRecipient(Message.RecipientType type, Address address)</code>: 添加指定类型的收件人地址。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">addRecipients(Message.RecipientType type, Address[] addresses)</code>: 添加指定类型的收件人地址。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">addRecipients(Message.RecipientType type, String addresses)</code>: 添加指定类型的收件人地址。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">addRecipient(String type, String address)</code>: 添加指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">addRecipients(String type, String addresses)</code>: 添加指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setFrom(Address address)</code>: 设置发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setFrom(String address)</code>: 设置发件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setRecipient(Message.RecipientType type, Address address)</code>: 设置指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setRecipients(Message.RecipientType type, Address[] addresses)</code>: 设置指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setRecipients(Message.RecipientType type, String addresses)</code>: 设置指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setRecipient(String type, Address address)</code>: 设置指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setRecipients(String type, String addresses)</code>: 设置指定类型的收件人地址。</li>
  <li><code class="language-plaintext highlighter-rouge">setReplyTo(Address[] addresses)</code>: 设置回复地址。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Message.RecipientType</code>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Message.RecipientType.TO</code>：主要收件人（”To”）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。</li>
  <li><code class="language-plaintext highlighter-rouge">Message.RecipientType.CC</code>：抄送（”Cc”），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。</li>
  <li><code class="language-plaintext highlighter-rouge">Message.RecipientType.BCC</code>：秘密抄送（”Bcc”），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。</li>
</ul>

<hr />

<p>要设置多个收件人，可以使用<code class="language-plaintext highlighter-rouge">addRecipients</code>方法或<code class="language-plaintext highlighter-rouge">setRecipients</code>方法。这些方法允许为消息的不同类型（如TO、CC、BCC）添加多个收件人。以下是使用这些方法设置多个收件人的示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 添加多个收件人</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="s">"recipient1@example.com, recipient2@example.com"</span><span class="o">);</span>
<span class="c1">// 或者使用数组</span>
<span class="nc">Address</span><span class="o">[]</span> <span class="n">recipients</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">InternetAddress</span><span class="o">(</span><span class="s">"recipient1@example.com"</span><span class="o">),</span>
    <span class="k">new</span> <span class="nf">InternetAddress</span><span class="o">(</span><span class="s">"recipient2@example.com"</span><span class="o">)</span>
<span class="o">};</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="n">recipients</span><span class="o">);</span>
</code></pre></div></div>

<p>注意，在使用<code class="language-plaintext highlighter-rouge">addRecipients</code>方法时，<strong>多个收件人应使用逗号分隔</strong>。还可以使用类似的方法设置CC和BCC收件人。</p>

<p><code class="language-plaintext highlighter-rouge">addRecipient</code>方法可以多次调用以添加多个收件人，而<code class="language-plaintext highlighter-rouge">setRecipient</code>方法会覆盖之前设置的收件人。因此，如果需要设置多个收件人，应该使用<code class="language-plaintext highlighter-rouge">addRecipient</code>方法。</p>

<p>如果需要设置收件人、抄送（CC）和密送（BCC）等多个收件人，应该使用<code class="language-plaintext highlighter-rouge">addRecipient</code>方法多次调用来添加不同类型的收件人。例如，可以按照以下方式设置多个收件人：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient1@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient2@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">CC</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"cc@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">BCC</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"bcc@example.com"</span><span class="o">));</span>
</code></pre></div></div>

<p>而对于多个发件人，SMTP 协议规定邮件的 <code class="language-plaintext highlighter-rouge">From</code> 字段只能有一个发件人。如果需要发送给多个人，但每个人看到的发件人应该不同，可以考虑使用群发邮件的方式，即将所有收件人放在收件人列表中，但在邮件内容中区分不同的收件人。如果需要在邮件内容中显示不同的发件人，可以在邮件内容中自定义发件人的显示方式，例如在邮件正文中注明发件人姓名或其他标识。</p>

<h3 id="设置别名">设置别名</h3>

<p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类用于表示<strong>电子邮件地址</strong>。它有几种不同的构造方法，可以根据需要选择使用：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, boolean strict)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例，并指定是否启用严格模式。</li>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal)</code>：使用给定的电子邮件地址字符串和个人名称创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset)</code>：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset, boolean strict)</code>：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li>
</ul>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">InternetAddress</code>可以很方便的设置别名</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
</code></pre></div></div>

<p><strong>在字符串里，也可以设置别名</strong>：</p>

<p>在字符串里给收件人设置别名的方法是使用 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;</code> 包裹完整的邮件地址，并在地址后面添加别名，格式如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"别名1 &lt;recipient1@example.com&gt;, 别名2 &lt;recipient2@example.com&gt;"</span>
</code></pre></div></div>

<p>例如，如果要将 “Alice” 和 “Bob” 添加到密送列表，可以这样做：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">BCC</span><span class="o">,</span> <span class="s">"Alice &lt;alice@example.com&gt;, Bob &lt;bob@example.com&gt;"</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">InternetAddress</code>里也可以这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"别名 &lt;recipient@example.com&gt;"</span><span class="o">);</span>
</code></pre></div></div>

<p>但是不能同时设置字符集，那中文可能出问题，所以还是得这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient@example.com&gt;"</span><span class="o">,</span><span class="s">"别名"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div>

<p>或者这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient@example.com"</span><span class="o">);</span>
<span class="n">address</span><span class="o">.</span><span class="na">setPersonal</span><span class="o">(</span><span class="s">"别名"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="常见问题">常见问题</h3>

<p>如果用户名或口令错误，会导致<code class="language-plaintext highlighter-rouge">535</code>登录失败：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: AUTH LOGIN failed
Exception in thread "main" javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
</code></pre></div></div>

<p>如果<strong>登录用户和发件人不一致</strong>，会导致<code class="language-plaintext highlighter-rouge">554</code>拒绝发送错误：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
</code></pre></div></div>

<p>有些时候，如果邮件主题和正文过于简单，会导致<code class="language-plaintext highlighter-rouge">554</code>被识别为垃圾邮件的错误：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
</code></pre></div></div>

<p>使用<code class="language-plaintext highlighter-rouge">JavaMail</code> API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；</p>

<p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p>

<h2 id="接收email">接收Email</h2>

<p>发送Email，客户端总是通过SMTP协议把邮件发送给MTA。</p>

<p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p>

<p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p>

<p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p>

<p>以下是 QQ 邮箱、163 邮箱和 Gmail 邮箱的 POP3 和 IMAP 服务器信息：</p>

<ol>
  <li>QQ 邮箱：
    <ul>
      <li>POP3 服务器：pop.qq.com</li>
      <li>IMAP 服务器：imap.qq.com</li>
    </ul>
  </li>
  <li>163 邮箱：
    <ul>
      <li>POP3 服务器：pop.163.com 或 pop3.163.com</li>
      <li>IMAP 服务器：imap.163.com</li>
    </ul>
  </li>
  <li>Gmail 邮箱：
    <ul>
      <li>POP3 服务器：pop.gmail.com（默认端口号：995）</li>
      <li>IMAP 服务器：imap.gmail.com（默认端口号：993）</li>
    </ul>
  </li>
</ol>

<p>对于 Gmail 邮箱，还需要启用“Less secure app access”或生成应用密码。Gmail 强制使用加密连接，请确保使用正确的端口号以及启用 SSL/TLS 加密连接。</p>

<p><strong>POP3与IMAP</strong></p>

<p>POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。</p>

<p>而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p>

<p>同时，<strong>IMAP</strong>像<strong>POP3</strong>那样提供了方便的邮件下载服务，让用户能进行离线阅读。<strong>IMAP</strong>提供的摘要浏览功能可以让你在阅读完所有的邮件到达时间、主题、发件人、大小等信息后才作出是否下载的决定。此外，<strong>IMAP</strong> 更好地支持了从多个不同设备中随时访问新邮件。</p>

<p>总之，<strong>IMAP</strong> 整体上为用户带来更为便捷和可靠的体验。<strong>POP3</strong> 更易丢失邮件或多次下载相同的邮件，而 <strong>IMAP</strong> 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。</p>

<h3 id="登录邮箱">登录邮箱</h3>

<p><code class="language-plaintext highlighter-rouge">URLName</code> 类构造方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">public URLName()</code>: 默认构造方法，创建一个空的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">public URLName(String url)</code>: 使用给定的 URL 字符串创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。该 URL 字符串应包含完整的 URL 信息，例如：”protocol://host:port/file”。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">public URLName(String protocol, String host, int port, String file, String username, String password)</code>: 使用指定的协议、主机、端口、文件路径、用户名和密码创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。用于表示需要身份验证的 URL。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">public URLName(String protocol, String host, int port, String file)</code>: 使用指定的协议、主机、端口和文件路径创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，用户名和密码为空。通常用于表示不需要身份验证的 URL。</li>
  <li><code class="language-plaintext highlighter-rouge">public URLName(URLName url)</code>: 复制构造方法，创建一个新的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，其内容与给定的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象相同。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">URLName</code> 类中除了构造方法外还有一些常用的方法，例如：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">public String getProtocol()</code>: 返回 URL 的协议部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public String getHost()</code>: 返回 URL 的主机部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public int getPort()</code>: 返回 URL 的端口部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public String getFile()</code>: 返回 URL 的文件路径部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public String getUsername()</code>: 返回 URL 的用户名部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public String getPassword()</code>: 返回 URL 的密码部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public void setProtocol(String protocol)</code>: 设置 URL 的协议部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public void setHost(String host)</code>: 设置 URL 的主机部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public void setPort(int port)</code>: 设置 URL 的端口部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public void setFile(String file)</code>: 设置 URL 的文件路径部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public void setUsername(String username)</code>: 设置 URL 的用户名部分。</li>
  <li><code class="language-plaintext highlighter-rouge">public void setPassword(String password)</code>: 设置 URL 的密码部分。</li>
</ul>

<hr />

<h4 id="pop3">POP3</h4>

<p>使用POP3收取Email时，无需关心POP3协议底层，因为<code class="language-plaintext highlighter-rouge">JavaMail</code>提供了高层接口。首先需要连接到Store对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.mail.pop3.POP3SSLStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MessagingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Store</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.URLName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">MessagingException</span> <span class="o">{</span>
        <span class="c1">// 登录用户名:</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
        <span class="c1">// 登录口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
        <span class="c1">// 主机端口号</span>
        <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"995"</span><span class="o">;</span>
        <span class="c1">// pop3主机：</span>
        <span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"pop3.163.com"</span><span class="o">;</span>
        <span class="c1">// 连接到pop3服务器995端口:</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="n">getProperties</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="c1">// 获取Session实例:</span>
        <span class="c1">// 连接到Store:</span>
        <span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3s"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3SSLStore</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Properties</span> <span class="nf">getProperties</span><span class="o">(</span><span class="nc">String</span> <span class="n">host</span><span class="o">,</span> <span class="nc">String</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.host"</span><span class="o">,</span> <span class="n">host</span><span class="o">);</span> <span class="c1">// pop3主机名</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 关闭TLS加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.socketFactory.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">props</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 是 <code class="language-plaintext highlighter-rouge">POP3Store</code> 的 SSL 安全版本。它们的构造方法应该是类似的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span>
</code></pre></div></div>

<p>这个构造方法接受一个 <code class="language-plaintext highlighter-rouge">Session</code> 对象和一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象作为参数，用于初始化 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象。<code class="language-plaintext highlighter-rouge">Session</code> 对象包含邮件会话的配置信息，而 <code class="language-plaintext highlighter-rouge">URLName</code> 对象包含用于连接到邮件服务器的 URL 信息。</p>

<p>实际上，<code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 的构造方法内部调用了父类 <code class="language-plaintext highlighter-rouge">POP3Store</code> 的带有四个参数的构造方法，其中第一个参数是 <code class="language-plaintext highlighter-rouge">Session</code> 对象，第二个参数是 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，第三个参数是字符串 <code class="language-plaintext highlighter-rouge">"pop3s"</code>，表示使用 POP3 协议的 SSL 安全版本，第四个参数是 <code class="language-plaintext highlighter-rouge">true</code>，表示要使用 SSL 连接。源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3SSLStore</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这样就可以使用 SSL 安全连接到 POP3 邮件服务器。</p>

<p>对于代码中的<code class="language-plaintext highlighter-rouge">pop3s</code>都可以改成<code class="language-plaintext highlighter-rouge">pop3</code>，因为使用<code class="language-plaintext highlighter-rouge">POP3SSLStore</code>已经定义了<code class="language-plaintext highlighter-rouge">pop3s</code>，即<code class="language-plaintext highlighter-rouge">pop3</code>的SSL安全版本：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3s"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
</code></pre></div></div>

<p>实际上整个<code class="language-plaintext highlighter-rouge">getProperties</code>方法都是多余的，协议也是多余的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="c1">// 主机端口号</span>
<span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"995"</span><span class="o">;</span>
<span class="c1">// imap主机：</span>
<span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"pop3.163.com"</span><span class="o">;</span>
<span class="c1">// 连接到pop3服务器995端口:</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="c1">// 获取Session实例:</span>
<span class="c1">// 连接到Store:</span>
<span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3SSLStore</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span><span class="c1">//调用就会自动设置pop3s</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p>如果不需要使用 SSL 安全连接，可以使用 <code class="language-plaintext highlighter-rouge">POP3Store</code> 类而不是 <code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 类。<code class="language-plaintext highlighter-rouge">POP3Store</code> 类用于表示普通的、非加密的 POP3 连接。在创建 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象时，可以直接指定协议为 <code class="language-plaintext highlighter-rouge">"pop3"</code>，而不是 <code class="language-plaintext highlighter-rouge">"pop3s"</code>，这样就可以使用非加密的方式连接到 POP3 邮件服务器。示例代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"mail.pop3.host"</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">);</span><span class="c1">//多余的操作</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"mail.pop3.port"</span><span class="o">,</span> <span class="s">"110"</span><span class="o">);</span><span class="c1">//多余的操作</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.ssl.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用SSL加密，这个也是多余的操作</span>

<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3Store</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3"</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">,</span> <span class="mi">110</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"username"</span><span class="o">,</span> <span class="s">"password"</span><span class="o">));</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div>

<p>在这个示例中，创建了一个 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象，并指定了 POP3 邮件服务器的主机、端口、用户名和密码。连接时不需要指定使用 SSL，因为默认情况下 <code class="language-plaintext highlighter-rouge">POP3Store</code> 使用的是非加密的方式。</p>

<p>实际上<code class="language-plaintext highlighter-rouge">POP3Store</code>的构造方法定义如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="s">"pop3"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">,</span>
                 <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isSSL</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">url</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MailLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="s">"DEBUG POP3"</span><span class="o">,</span>
                            <span class="n">session</span><span class="o">.</span><span class="na">getDebug</span><span class="o">(),</span> <span class="n">session</span><span class="o">.</span><span class="na">getDebugOut</span><span class="o">());</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">isSSL</span><span class="o">)</span>
        <span class="n">isSSL</span> <span class="o">=</span> <span class="nc">PropUtil</span><span class="o">.</span><span class="na">getBooleanProperty</span><span class="o">(</span><span class="n">session</span><span class="o">.</span><span class="na">getProperties</span><span class="o">(),</span>
                                            <span class="s">"mail."</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">".ssl.enable"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isSSL</span><span class="o">)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">defaultPort</span> <span class="o">=</span> <span class="mi">995</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">this</span><span class="o">.</span><span class="na">defaultPort</span> <span class="o">=</span> <span class="mi">110</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">isSSL</span> <span class="o">=</span> <span class="n">isSSL</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因此，只需要写主机地址和用户名及密码，但由于<code class="language-plaintext highlighter-rouge">URLName</code>这个构造方法要指定端口号，还是指定了<code class="language-plaintext highlighter-rouge">110</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3Store</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">,</span> <span class="mi">110</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">));</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<h4 id="imap">IMAP</h4>

<p>使用IMAP协议的SSL安全连接方式（还是写规范点）：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.mail.pop3.POP3SSLStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MessagingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Store</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.URLName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">MessagingException</span> <span class="o">{</span>
        <span class="c1">// 登录用户名:</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
        <span class="c1">// 登录口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
        <span class="c1">// 主机端口号</span>
        <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"993"</span><span class="o">;</span>
        <span class="c1">// imap主机：</span>
        <span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"imap.163.com"</span><span class="o">;</span>
        <span class="c1">// 连接到imap服务器993端口:</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="n">getProperties</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="c1">// 获取Session实例:</span>
        <span class="c1">// 连接到Store:</span>
        <span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"imaps"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getStore</span><span class="o">(</span><span class="n">url</span><span class="o">);</span><span class="c1">//获取指定协议的`Store`对象，用于接收邮件。</span>
        <span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Properties</span> <span class="nf">getProperties</span><span class="o">(</span><span class="nc">String</span> <span class="n">host</span><span class="o">,</span> <span class="nc">String</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"imaps"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.host"</span><span class="o">,</span> <span class="n">host</span><span class="o">);</span> <span class="c1">// imap主机名</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 关闭TLS加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.socketFactory.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">props</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>修改的地方也就几处：<code class="language-plaintext highlighter-rouge">port</code>为<code class="language-plaintext highlighter-rouge">993</code>，<code class="language-plaintext highlighter-rouge">host</code>为<code class="language-plaintext highlighter-rouge">imap.163.com</code>，<code class="language-plaintext highlighter-rouge">Store</code>的获取方式改为：<code class="language-plaintext highlighter-rouge">session.getStore(url);</code>，注意协议都改为了：<code class="language-plaintext highlighter-rouge">imaps</code>，这里不能像前面<code class="language-plaintext highlighter-rouge">pop3</code>一样不加<code class="language-plaintext highlighter-rouge">s</code>一样能SSL安全连接。</p>

<p>同样的，<code class="language-plaintext highlighter-rouge">getProperties</code>方法也是多余的，<code class="language-plaintext highlighter-rouge">new URLName("imaps"...</code>里的<code class="language-plaintext highlighter-rouge">imaps</code>这次不是多余的了，因为调用的是<code class="language-plaintext highlighter-rouge">session.getStore(url);</code>这个一般方法。</p>

<p><strong>也可以改成<code class="language-plaintext highlighter-rouge">Store store = new IMAPSSLStore(session,url);</code></strong></p>

<hr />

<p>要改为非SSL安全连接的：只需要改<code class="language-plaintext highlighter-rouge">port</code>为<code class="language-plaintext highlighter-rouge">143</code>，协议改为：<code class="language-plaintext highlighter-rouge">imap</code>，<code class="language-plaintext highlighter-rouge">ssl</code>指定为<code class="language-plaintext highlighter-rouge">false</code>或者不写。即：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"143"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"imap.163.com"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"imap"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getStore</span><span class="o">(</span><span class="n">url</span><span class="o">);</span><span class="c1">//获取指定协议的`Store`对象，用于接收邮件。</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div>

<p><strong>也可以改成<code class="language-plaintext highlighter-rouge">Store store = new IMAPStore(session,url);</code></strong></p>

<h3 id="查看邮箱">查看邮箱</h3>

<p><code class="language-plaintext highlighter-rouge">Store</code> 类表示邮件存储的抽象类，它提供了一组方法用于连接到邮件服务器并访问邮件。下面是一些常用的 <code class="language-plaintext highlighter-rouge">Store</code> 类的方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">void connect(String host, String user, String password)</code>：连接到指定主机的邮件服务器，使用指定的用户名和密码进行身份验证。</li>
  <li><code class="language-plaintext highlighter-rouge">void connect()</code>：连接到之前设置的邮件服务器，使用之前设置的用户名和密码进行身份验证。</li>
  <li><code class="language-plaintext highlighter-rouge">Folder getDefaultFolder()</code>：获取默认文件夹，通常是收件箱。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Folder getFolder(String name)</code>：根据给定的文件夹名称获取文件夹对象。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">Folder[] getPersonalNamespaces()</code>：获取个人文件夹命名空间。</li>
  <li><code class="language-plaintext highlighter-rouge">Folder[] getUserNamespaces(String user)</code>：获取给定用户的文件夹命名空间。</li>
  <li><code class="language-plaintext highlighter-rouge">void close()</code>：关闭与邮件服务器的连接。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isConnected()</code>：检查是否已连接到邮件服务器。</li>
  <li><code class="language-plaintext highlighter-rouge">void addConnectionListener(ConnectionListener listener)</code>：添加连接监听器，以便在连接状态发生变化时接收通知。</li>
  <li><code class="language-plaintext highlighter-rouge">void removeConnectionListener(ConnectionListener listener)</code>：移除连接监听器。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">Folder</code> 类表示邮件文件夹，它提供了一组方法用于管理和操作邮件文件夹中的邮件。下面是一些常用的 <code class="language-plaintext highlighter-rouge">Folder</code> 类的方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String getFullName()</code>：获取邮件文件夹的完整名称。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean exists()</code>：检查邮件文件夹是否存在。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void open(int mode)</code>：打开邮件文件夹，并指定打开模式（只读、读写等）。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">boolean isOpen()</code>：检查邮件文件夹是否已打开。</li>
  <li><code class="language-plaintext highlighter-rouge">void appendMessages(Message[] msgs)</code>：向邮件文件夹中追加邮件。</li>
  <li><code class="language-plaintext highlighter-rouge">void delete(boolean recurse)</code>：删除邮件文件夹，可选择是否递归删除子文件夹。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">int getMessageCount()</code>：获取邮件文件夹中的邮件数量。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">int getNewMessageCount()</code>：获取邮件文件夹中的新邮件数量。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">int getUnreadMessageCount()</code>：获取邮件文件夹中的未读邮件数量。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">int getDeletedMessageCount()</code>：获取邮件文件夹中已标记为删除的邮件数量。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">Message[] getMessages()</code>：获取邮件文件夹中的所有邮件。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">Message getMessage(int msgnum)</code>：根据邮件序号获取邮件对象。</li>
  <li><code class="language-plaintext highlighter-rouge">Message getMessage(int start,int end)</code>：根据邮件序号获取邮件对象。</li>
  <li><code class="language-plaintext highlighter-rouge">Message[] search(SearchTerm term)</code>：根据指定的搜索条件搜索邮件。</li>
  <li><code class="language-plaintext highlighter-rouge">void setFlags(Message[] msgs, Flags flag, boolean value)</code>：设置邮件的标志（例如，已读、已删除等）。</li>
  <li><code class="language-plaintext highlighter-rouge">Message[] expunge()</code>：清除标记为已删除的邮件，并返回已删除的邮件数组。</li>
  <li><code class="language-plaintext highlighter-rouge">void close(boolean expunge)</code>：关闭邮件文件夹，可选择是否删除已删除的邮件。</li>
  <li><code class="language-plaintext highlighter-rouge">void addMessageChangedListener(MessageChangedListener listener)</code>：添加邮件变化监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">void removeMessageChangedListener(MessageChangedListener listener)</code>：移除邮件变化监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">void addFolderListener(FolderListener listener)</code>：添加文件夹监听器。</li>
  <li><code class="language-plaintext highlighter-rouge">void removeFolderListener(FolderListener listener)</code>：移除文件夹监听器。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">MimeUtility</code> 类是 JavaMail API 中用于处理 MIME（Multipurpose Internet Mail Extensions）消息的实用工具类。它提供了一些方法来编码和解码 MIME 消息的各个部分，以及处理文本和二进制数据的方法。</p>

<p>以下是 <code class="language-plaintext highlighter-rouge">MimeUtility</code> 类的一些常用方法：</p>

<ol>
  <li><strong>编码方法</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">encodeText(String text) throws UnsupportedEncodingException</code>：对文本进行 MIME 编码。</li>
      <li><code class="language-plaintext highlighter-rouge">encodeWord(String word) throws UnsupportedEncodingException</code>：对单词进行 MIME 编码。</li>
    </ul>
  </li>
  <li><strong>解码方法</strong>：
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">decodeText(String text) throws UnsupportedEncodingException</code>：解码 MIME 编码的文本。</strong></li>
    </ul>
  </li>
  <li><strong>其他方法</strong>：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">fold(int used, String s)</code>：根据 RFC 2822 规范折叠长行。</li>
      <li><code class="language-plaintext highlighter-rouge">unfold(String s)</code>：从折叠的行中还原原始行。</li>
      <li><code class="language-plaintext highlighter-rouge">encodeWord(String word, String charset, String encoding) throws UnsupportedEncodingException</code>：使用指定的字符集和编码对单词进行编码。</li>
      <li><code class="language-plaintext highlighter-rouge">decodeWord(String eword)</code> throws ParseException：解码 MIME 编码的单词。</li>
      <li><code class="language-plaintext highlighter-rouge">quote(String s, String specials)</code>：对字符串中的特殊字符进行引用。</li>
      <li><code class="language-plaintext highlighter-rouge">quote(String s)</code>：对字符串中的特殊字符进行引用，默认引用所有非 ASCII 字符。</li>
    </ul>
  </li>
</ol>

<p>这些方法可能会抛出 <code class="language-plaintext highlighter-rouge">UnsupportedEncodingException</code> 或 <code class="language-plaintext highlighter-rouge">ParseException</code> 异常，因此在使用时需要处理这些异常。</p>

<hr />

<p>一个<code class="language-plaintext highlighter-rouge">Store</code>对象表示整个邮箱的存储，要收取邮件，需要通过<code class="language-plaintext highlighter-rouge">Store</code>访问指定的<code class="language-plaintext highlighter-rouge">Folder</code>（文件夹），<strong>通常是<code class="language-plaintext highlighter-rouge">INBOX</code>表示收件箱</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取收件箱:</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="c1">// 以读写方式打开:</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">);</span>
<span class="c1">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getNewMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unread messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getUnreadMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getDeletedMessageCount</span><span class="o">());</span>
<span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Message</span> <span class="n">message</span> <span class="o">:</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 打印每一封邮件:</span>
    <span class="n">printMessage</span><span class="o">((</span><span class="nc">MimeMessage</span><span class="o">)</span> <span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span>
<span class="n">store</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<p>获取到一个<code class="language-plaintext highlighter-rouge">Message</code>对象时，可以强制转型为<code class="language-plaintext highlighter-rouge">MimeMessage</code>，然后打印出邮件主题、发件人、收件人等信息：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMessage</span><span class="o">(</span><span class="nc">MimeMessage</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">MessagingException</span> <span class="o">{</span>
    <span class="c1">// 邮件主题:</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Subject: "</span> <span class="o">+</span> <span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getSubject</span><span class="o">()));</span>
    <span class="c1">// 发件人:</span>
    <span class="nc">Address</span><span class="o">[]</span> <span class="n">froms</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">getFrom</span><span class="o">();</span>
    <span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InternetAddress</span><span class="o">)</span> <span class="n">froms</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"From: "</span> <span class="o">+</span> <span class="n">getAddressInfo</span><span class="o">(</span><span class="n">address</span><span class="o">));</span>
    <span class="c1">// 收件人（可以有多个）:</span>
    <span class="nc">InternetAddress</span><span class="o">[]</span> <span class="n">recipients</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InternetAddress</span><span class="o">[])</span> <span class="n">msg</span><span class="o">.</span><span class="na">getAllRecipients</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">InternetAddress</span> <span class="n">recipient</span> <span class="o">:</span> <span class="n">recipients</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Recipient: "</span> <span class="o">+</span> <span class="n">getAddressInfo</span><span class="o">(</span><span class="n">recipient</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">// 打印邮件内容</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
 * 获取InternetAddress的字符串形式
 * @param address 地址
 * @return 字符串
 * @throws UnsupportedEncodingException 字符编码不支持。
 */</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">getAddressInfo</span><span class="o">(</span><span class="nc">InternetAddress</span> <span class="n">address</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">personal</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">getPersonal</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">personal</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">address</span><span class="o">.</span><span class="na">getAddress</span><span class="o">()</span> <span class="o">:</span> <span class="o">(</span><span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">personal</span><span class="o">)</span> <span class="o">+</span> <span class="s">" &lt;"</span> <span class="o">+</span> <span class="n">address</span><span class="o">.</span><span class="na">getAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">"&gt;"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>获取邮件的正文，一个<code class="language-plaintext highlighter-rouge">MimeMessage</code>对象也是一个<code class="language-plaintext highlighter-rouge">Part</code>对象，它可能只包含一个文本，也可能是一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象，即由几个<code class="language-plaintext highlighter-rouge">Part</code>构成，因此，需要递归地解析出完整的正文：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 邮件内容
 * @param part 邮件部分内容
 * @return 字符串
 * @throws MessagingException
 * @throws IOException
 */</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">getBody</span><span class="o">(</span><span class="nc">Part</span> <span class="n">part</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是文本:</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"multipart/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是一个Multipart对象:</span>
        <span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Multipart</span><span class="o">)</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
        <span class="c1">// 循环解析每个子Part:</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">BodyPart</span> <span class="n">bodyPart</span> <span class="o">=</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getBodyPart</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">body</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p><strong>注意！网易邮箱对于IMAP协议收信有额外要求</strong>：<a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2eda07326646e6eb0">imap连接提示Unsafe Login，被阻止的收信行为</a></p>

<p>在<code class="language-plaintext highlighter-rouge">store.connect();</code>后面加上以下代码即可：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">IAM</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="s">"myname"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"version"</span><span class="o">,</span><span class="s">"1.0.0"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"vendor"</span><span class="o">,</span><span class="s">"myclient"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"support-email"</span><span class="o">,</span><span class="s">"testmail@test.com"</span><span class="o">);</span>
<span class="o">((</span><span class="nc">IMAPStore</span><span class="o">)</span><span class="n">store</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="no">IAM</span><span class="o">);</span>
</code></pre></div></div>

<p>发送IMAP ID命令（如果服务器支持）并从服务器返回结果。 ID命令向服务器标识客户端并将有关服务器的信息返回给客户端。</p>

<hr />

<p><strong>获取最近的10封邮件：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取邮件文件夹</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_ONLY</span><span class="o">);</span>
<span class="c1">// 获取邮件总数</span>
<span class="kt">int</span> <span class="n">totalMessages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">();</span>
<span class="c1">// 计算要获取的起始邮件号和结束邮件号</span>
<span class="kt">int</span> <span class="n">startMessage</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">totalMessages</span> <span class="o">-</span> <span class="mi">9</span><span class="o">);</span> <span class="c1">// 最近的第一封邮件</span>
<span class="kt">int</span> <span class="n">endMessage</span> <span class="o">=</span> <span class="n">totalMessages</span><span class="o">;</span> <span class="c1">// 最近的最后一封邮件</span>
<span class="c1">// 获取最近的 10 封邮件</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">(</span><span class="n">startMessage</span><span class="o">,</span> <span class="n">endMessage</span><span class="o">);</span>
<span class="c1">// 关闭邮件文件夹</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="保存附件">保存附件</h3>

<p>加个判断就行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">getBody</span><span class="o">(</span><span class="nc">Part</span> <span class="n">part</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是文本:</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"multipart/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是一个Multipart对象:</span>
        <span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Multipart</span><span class="o">)</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
        <span class="c1">// 循环解析每个子Part:</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">BodyPart</span> <span class="n">bodyPart</span> <span class="o">=</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getBodyPart</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">body</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 保存非文本类型的部分为文件</span>
            <span class="n">saveAttachment</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">saveAttachment</span><span class="o">(</span><span class="nc">BodyPart</span> <span class="n">bodyPart</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">bodyPart</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">bodyPart</span><span class="o">.</span><span class="na">getFileName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fileName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fileName</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="n">bodyPart</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
            <span class="nc">FileOutputStream</span> <span class="n">outputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bytesRead</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">outputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">outputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">inputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n已保存的附件: "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">fileName</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="删除邮件">删除邮件</h3>

<p><code class="language-plaintext highlighter-rouge">Folder</code> 类的删除方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">void open(int mode)</code>：打开邮件文件夹，并指定打开模式（只读、读写等）。</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Folder.READ_ONLY</code>（值为 1）：只读模式，用于读取邮件但不能修改或删除邮件。</li>
      <li><code class="language-plaintext highlighter-rouge">Folder.READ_WRITE</code>（值为 2）：读写模式，用于读取、修改和删除邮件。</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setFlags(Message[] msgs, Flags flag, boolean value)</code>：设置邮件的标志（例如，已读、已删除等）。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">Message[] expunge()</code>：清除标记为已删除的邮件，并返回已删除的邮件数组。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void close(boolean expunge)</code>：关闭邮件文件夹，可选择是否删除已删除的邮件。</li>
</ul>

<hr />

<p>在 JavaMail API 中，<code class="language-plaintext highlighter-rouge">Flags</code> 类表示邮件的标志。<code class="language-plaintext highlighter-rouge">Flags</code> 类提供了一些常量来表示不同的标志，可以使用这些常量来设置或检查邮件的标志。</p>

<p>构造方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags();</code>：创建一个空的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Flags flags = new Flags(Flags.Flag flag);</code>：创建一个包含指定标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags(Flags flags);</code>：创建一个包含另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中所有标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li>
</ul>

<p>常用的方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">void add(Flags.Flag flag)</code>：添加指定的标志。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void add(Flags flags)</code>：添加另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean contains(Flags.Flag flag)</code>：检查是否存在指定的标志。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean containsAll(Flags flags)</code>：检查是否存在另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>：比较两个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象是否相等。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag[] getSystemFlags()</code>：返回系统定义的所有标志。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag[] getUserFlags()</code>：返回用户定义的所有标志。</li>
  <li><code class="language-plaintext highlighter-rouge">int hashCode()</code>：返回 <code class="language-plaintext highlighter-rouge">Flags</code> 对象的哈希码值。</li>
  <li><code class="language-plaintext highlighter-rouge">void remove(Flags.Flag flag)</code>：移除指定的标志。</li>
  <li><code class="language-plaintext highlighter-rouge">void remove(Flags flags)</code>：移除另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li>
  <li><code class="language-plaintext highlighter-rouge">void set(Flags.Flag flag, boolean value)</code>：设置指定标志的状态。</li>
  <li><code class="language-plaintext highlighter-rouge">void setFlags(Flags.Flag[] flags, boolean value)</code>：设置指定一组标志的状态。</li>
  <li><code class="language-plaintext highlighter-rouge">void setUserFlags(Flags flags)</code>：设置用户定义的标志。</li>
</ul>

<p>以下是 <code class="language-plaintext highlighter-rouge">Flags</code> 类中定义的一些常量：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag.ANSWERED</code>：已回复标志，表示邮件已被回复。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Flags.Flag.DELETED</code>：已删除标志，表示邮件已被标记为删除。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag.DRAFT</code>：草稿标志，表示邮件是草稿。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag.FLAGGED</code>：已标记标志，表示邮件已被标记。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag.RECENT</code>：最近标志，表示邮件是最近收到的。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag.SEEN</code>：已读标志，表示邮件已被阅读。</li>
  <li><code class="language-plaintext highlighter-rouge">Flags.Flag.USER</code>：用户标志，表示用户定义的标志。</li>
</ul>

<p>可以使用这些常量来创建 <code class="language-plaintext highlighter-rouge">Flags</code> 对象，并将其传递给 <code class="language-plaintext highlighter-rouge">Folder.setFlags()</code> 方法来设置邮件的标志。例如，要创建一个包含已读和已回复标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象，可以使用以下代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">();</span>
<span class="n">flags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">SEEN</span><span class="o">);</span>
<span class="n">flags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">ANSWERED</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<p><strong>批量删除邮件：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取收件箱:</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="c1">// 以读写方式打开:</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">);</span>
<span class="c1">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getNewMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unread messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getUnreadMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getDeletedMessageCount</span><span class="o">());</span>
<span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">setFlags</span><span class="o">(</span><span class="n">messages</span><span class="o">,</span><span class="n">flags</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 关闭邮件文件夹并删除标记为删除的邮件</span>
</code></pre></div></div>

<p>实际上<code class="language-plaintext highlighter-rouge">Folder</code>的<code class="language-plaintext highlighter-rouge">setFlags</code>方法内部是这样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msgs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
    <span class="n">msgs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">setFlags</span><span class="o">(</span><span class="n">flag</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">MessageRemovedException</span> <span class="n">me</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This message is expunged, skip </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因此可以直接在单个<code class="language-plaintext highlighter-rouge">Message</code>上调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">);</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlags</span><span class="o">(</span><span class="n">flags</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="c1">//...</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 关闭邮件文件夹并删除标记为删除的邮件</span>
</code></pre></div></div>

<p>加<code class="language-plaintext highlighter-rouge">s</code>的表示可以设置多个，后面的<code class="language-plaintext highlighter-rouge">Boolean</code>值表示是设置还是取消，还可以通过<code class="language-plaintext highlighter-rouge">expunge()</code>方法删除。</p>

<p>试试用<code class="language-plaintext highlighter-rouge">folder.expunge();</code>删除标记为删除的邮件：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">expunge</span><span class="o">();</span><span class="c1">//删除标记为删除的邮件</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭邮件文件夹</span>
</code></pre></div></div>

<p>提示：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> jakarta.mail.MethodNotSupportedException: Expunge not supported
</code></pre></div></div>

<p>在使用 POP3 协议时，<code class="language-plaintext highlighter-rouge">POP3Folder</code> 不支持 <code class="language-plaintext highlighter-rouge">expunge()</code> 方法，因此会抛出 <code class="language-plaintext highlighter-rouge">MethodNotSupportedException</code> 异常。因为 POP3 协议不支持在服务器上直接删除邮件，而是通过将邮件标记为删除，然后在下次会话中关闭连接时执行实际的删除操作。</p>

<p>如果需要在使用 POP3 协议时删除邮件，可以考虑以下方法：</p>

<ul>
  <li>在读取邮件时，将要删除的邮件标记为删除，但不执行 <code class="language-plaintext highlighter-rouge">expunge()</code> 操作。最后调用 <code class="language-plaintext highlighter-rouge">close(true)</code> 方法来执行实际的删除操作。</li>
  <li>使用其他支持邮件删除的协议，如 IMAP。IMAP 协议支持在服务器上直接删除邮件。</li>
</ul>

<p><strong>使用IMAP协议执行同样的代码：</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">expunge</span><span class="o">();</span><span class="c1">//删除标记为删除的邮件</span>
<span class="c1">//...</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭邮件文件夹</span>
</code></pre></div></div>

<p>正常删除。</p>

<h2 id="http协议">HTTP协议</h2>

<p>HTTP是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p>

<p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>

<p>当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code class="language-plaintext highlighter-rouge">80</code>端口和加密端口<code class="language-plaintext highlighter-rouge">443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。</p>

<p>HTTP请求的格式是固定的，由HTTP Header和HTTP Body两部分构成。第一行总是请求方法 路径 HTTP版本，例如，<code class="language-plaintext highlighter-rouge">GET / HTTP/1.1</code>表示使用<code class="language-plaintext highlighter-rouge">GET</code>请求，路径是<code class="language-plaintext highlighter-rouge">/</code>，版本是<code class="language-plaintext highlighter-rouge">HTTP/1.1</code>。</p>

<p>后续的每一行都是固定的<code class="language-plaintext highlighter-rouge">Header: Value</code>格式，即HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p>

<ul>
  <li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li>
  <li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li>
  <li>Accept：表示客户端能处理的HTTP响应格式，<code class="language-plaintext highlighter-rouge">*/*</code>表示任意格式，<code class="language-plaintext highlighter-rouge">text/*</code>表示任意文本，<code class="language-plaintext highlighter-rouge">image/png</code>表示PNG格式的图片；</li>
  <li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li>
</ul>

<p>如果是<code class="language-plaintext highlighter-rouge">GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code class="language-plaintext highlighter-rouge">POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

username=hello&amp;password=123456
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">POST</code>请求通常要设置<code class="language-plaintext highlighter-rouge">Content-Type</code>表示Body的类型，<code class="language-plaintext highlighter-rouge">Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p>

<p>此外，<code class="language-plaintext highlighter-rouge">GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code class="language-plaintext highlighter-rouge">http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code class="language-plaintext highlighter-rouge">a=1</code>和<code class="language-plaintext highlighter-rouge">b=K&amp;R</code>。因为URL的长度限制，<code class="language-plaintext highlighter-rouge">GET</code>请求的参数不能太多，而<code class="language-plaintext highlighter-rouge">POST</code>请求的参数就没有长度限制，因为<code class="language-plaintext highlighter-rouge">POST</code>请求的参数必须放到Body中。并且，<code class="language-plaintext highlighter-rouge">POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code class="language-plaintext highlighter-rouge">Content-Type</code>中正确设置即可。常见的发送JSON的<code class="language-plaintext highlighter-rouge">POST</code>请求如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /login HTTP/1.1
Content-Type: application/json
Content-Length: 38

{"username":"bob","password":"123456"}
</code></pre></div></div>

<p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 133251

&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
...
</code></pre></div></div>

<p>响应的第一行总是<code class="language-plaintext highlighter-rouge">HTTP版本 响应代码 响应说明</code>，例如，<code class="language-plaintext highlighter-rouge">HTTP/1.1 200 OK</code>表示版本是<code class="language-plaintext highlighter-rouge">HTTP/1.1</code>，响应代码是<code class="language-plaintext highlighter-rouge">200</code>，响应说明是<code class="language-plaintext highlighter-rouge">OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p>

<ul>
  <li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于<code class="language-plaintext highlighter-rouge">WebSocket</code>连接；</li>
  <li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li>
  <li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li>
  <li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li>
  <li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li>
</ul>

<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code class="language-plaintext highlighter-rouge">GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 18391

????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)
</code></pre></div></div>

<p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p>

<p>对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率。</p>

<p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p>

<p>所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收。因此HTTP/2.0进一步提高了效率。</p>

<hr />

<p>URL（统一资源定位符）用于标识互联网上的资源位置，是 Web 中最常用的概念之一。它指定了资源的位置和访问方式。通常包含以下几个部分：</p>

<ol>
  <li><strong>协议（Protocol）</strong>：指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。</li>
  <li><strong>主机名（Host）</strong>：指定了资源所在的主机或服务器的域名或 IP 地址。</li>
  <li><strong>端口（Port）</strong>：指定了访问服务器的端口号。如果未指定，默认为协议的默认端口。</li>
  <li><strong>路径（Path）</strong>：指定了服务器上资源的路径。</li>
  <li><strong>查询字符串（Query String）</strong>：包含了向服务器传递的参数信息。</li>
  <li><strong>片段标识符（Fragment Identifier）</strong>：指定了资源中的特定部分。</li>
</ol>

<p>例如，对于 URL <code class="language-plaintext highlighter-rouge">https://www.example.com:8080/index.html?query=example#section1</code>，协议为 HTTPS，主机名为 <code class="language-plaintext highlighter-rouge">www.example.com</code>，端口号为 <code class="language-plaintext highlighter-rouge">8080</code>，路径为 <code class="language-plaintext highlighter-rouge">/index.html</code>，查询字符串为 <code class="language-plaintext highlighter-rouge">query=example</code>，片段标识符为 <code class="language-plaintext highlighter-rouge">section1</code>。</p>

<p>URL 在 Web 开发中广泛用于定位和访问 Web 页面、图像、视频等各种资源。</p>

<p><strong>URL类构造方法</strong></p>

<p><code class="language-plaintext highlighter-rouge">public URL(String spec);</code>：通过指定的字符串创建一个 URL 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http://home.netscape.com/home/"</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">public URL(URL context, String spec);</code>：通过基于上下文 URL 和相对 URL 字符串创建一个 URL 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http://home.netscape.com/home/"</span><span class="o">);</span>
<span class="no">URL</span> <span class="n">u2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="n">u1</span><span class="o">,</span> <span class="s">"welcome.html"</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">public URL(String protocol, String host, String file);</code>：通过指定协议、主机和文件路径创建一个 URL 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u3</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http"</span><span class="o">,</span> <span class="s">"www.sun.com"</span><span class="o">,</span> <span class="s">"developers/index.html"</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">public URL(String protocol, String host, int port, String file);</code>：通过指定协议、主机、端口和文件路径创建一个 URL 对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u4</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http"</span><span class="o">,</span> <span class="s">"www.sun.com"</span><span class="o">,</span> <span class="mi">80</span><span class="o">,</span> <span class="s">"developers/index.html"</span><span class="o">);</span>
</code></pre></div></div>

<p>常用方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">String getProtocol()</code>: 获取 URL 的协议部分，例如 <code class="language-plaintext highlighter-rouge">http</code>、<code class="language-plaintext highlighter-rouge">https</code> 等。</li>
  <li><code class="language-plaintext highlighter-rouge">String getHost()</code>: 获取 URL 的主机名部分。</li>
  <li><code class="language-plaintext highlighter-rouge">int getPort()</code>: 获取 URL 的端口号部分。</li>
  <li><code class="language-plaintext highlighter-rouge">String getPath()</code>: 获取 URL 的路径部分。</li>
  <li><code class="language-plaintext highlighter-rouge">String getQuery()</code>: 获取 URL 的查询部分。</li>
  <li><code class="language-plaintext highlighter-rouge">String getFile()</code>: 获取 URL 的文件名部分。</li>
  <li><code class="language-plaintext highlighter-rouge">URLConnection openConnection()</code>: 打开与此 URL 的连接，并返回一个 <code class="language-plaintext highlighter-rouge">URLConnection</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">InputStream openStream()</code>: 打开与此 URL 的连接，并返回一个 <code class="language-plaintext highlighter-rouge">InputStream</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>: 比较此 URL 与指定对象是否相等。</li>
  <li><code class="language-plaintext highlighter-rouge">String toString()</code>: 返回 URL 的字符串表示形式。</li>
</ul>

<hr />

<p><strong><code class="language-plaintext highlighter-rouge">URLConnection</code>抽象类</strong></p>

<p><code class="language-plaintext highlighter-rouge">Uonnection</code>类支持<code class="language-plaintext highlighter-rouge">URL</code>连接的输入/输出流方式的通信,并可以获得<code class="language-plaintext highlighter-rouge">URL</code>对象资源的相关信息。它是所有应用程序和<code class="language-plaintext highlighter-rouge">URL</code>连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。</p>

<p>常用的方法：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">void connect()</code>: 打开与 URL 引用的资源的通信链接。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">Object getContent()</code>: 获取此 URLConnection 的内容。</li>
  <li><code class="language-plaintext highlighter-rouge">String getHeaderField(int n)</code>: 返回与此 URLConnection 的给定字段相关联的值。</li>
  <li><code class="language-plaintext highlighter-rouge">long getLastModified()</code>: 获取指定资源的最后修改日期。</li>
  <li><code class="language-plaintext highlighter-rouge">int getContentLength()</code>: 获取指定资源的内容长度。</li>
  <li><code class="language-plaintext highlighter-rouge">String getContentType()</code>: 获取指定资源的内容类型。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">InputStream getInputStream()</code>: 返回一个输入流，用于从连接到 URL 的资源读取数据。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">OutputStream getOutputStream()</code>: 返回一个输出流，用于将数据写入到与 URLConnection 关联的资源。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setDoOutput(boolean dooutput)</code>: 将 doOutput 字段的值设置为指定值。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void setDoInput(boolean doinput)</code>: 将 doInput 字段的值设置为指定值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setRequestMethod(String method)</code>: 设置请求方法。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setRequestProperty(String key, String value)</code>: 设置指定的请求头字段的值。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void addRequestProperty(String key, String value)</code>: 添加一个请求属性。</li>
  <li><code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;String&gt;&gt; getHeaderFields()</code>: 返回与此 URLConnection 关联的请求头字段的映射。</li>
  <li><code class="language-plaintext highlighter-rouge">String getContentEncoding()</code>: 返回指定资源的内容编码。</li>
  <li><code class="language-plaintext highlighter-rouge">int getConnectTimeout()</code>: 返回与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。</li>
  <li><code class="language-plaintext highlighter-rouge">int getReadTimeout()</code>: 返回从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setConnectTimeout(int timeout)</code>: 设置与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">void setReadTimeout(int timeout)</code>: 设置从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">void setUseCaches(boolean usecaches)</code>: 如果连接上的 <code class="language-plaintext highlighter-rouge">UseCaches</code> 标志为 true，则允许该连接使用它可以使用的任何缓存。如果为 false，则忽略缓存。默认为true。</strong></li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpURLConnection</code> 是 <code class="language-plaintext highlighter-rouge">URLConnection</code> 的子类，提供了一些额外的方法，用于处理 HTTP 请求和响应。以下是 <code class="language-plaintext highlighter-rouge">HttpURLConnection</code> 比 <code class="language-plaintext highlighter-rouge">URLConnection</code> 多出的一些方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getHeaderFieldKey(int n)</code>：返回指定索引处的响应头字段名称。</li>
  <li><code class="language-plaintext highlighter-rouge">getHeaderField(int n)</code>：返回指定索引处的响应头字段的值。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getHeaderFields()</code>：返回一个包含所有响应头字段的映射。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">getRequestMethod()</code>：返回此连接的请求方法。</li>
  <li><code class="language-plaintext highlighter-rouge">setRequestMethod(String method)</code>：设置请求方法（如 GET、POST 等）。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">getResponseCode()</code>：获取 HTTP 响应代码。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">getResponseMessage()</code>：获取 HTTP 响应消息。</li>
  <li><code class="language-plaintext highlighter-rouge">usingProxy()</code>：返回一个布尔值，指示是否通过代理进行连接。</li>
  <li><code class="language-plaintext highlighter-rouge">disconnect()</code>：关闭连接并释放与该连接关联的所有系统资源。</li>
</ul>

<p>这些方法使得 <code class="language-plaintext highlighter-rouge">HttpURLConnection</code> 更适合处理 HTTP 请求和响应，而 <code class="language-plaintext highlighter-rouge">URLConnection</code> 则是更通用的类，可以处理不仅限于 HTTP 的多种协议。</p>

<hr />

<p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而使用Java进行HTTP客户端编程仅限于获得响应内容。</p>

<p>示例：将<code class="language-plaintext highlighter-rouge">baidu</code>内容重定向到<code class="language-plaintext highlighter-rouge">Demo.txt</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"Demo.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">)));</span>
<span class="no">URL</span> <span class="n">url2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">);</span>
<span class="nc">URLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">url2</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setDoOutput</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">nextLine</span><span class="o">;</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
<span class="k">while</span> <span class="o">((</span><span class="n">nextLine</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">nextLine</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<p>详细点的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">);</span>
<span class="nc">HttpURLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpURLConnection</span><span class="o">)</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestMethod</span><span class="o">(</span><span class="s">"GET"</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setUseCaches</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setConnectTimeout</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span> <span class="c1">// 请求超时5秒</span>
<span class="c1">// 设置HTTP头:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestProperty</span><span class="o">(</span><span class="s">"Accept"</span><span class="o">,</span> <span class="s">"*/*"</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestProperty</span><span class="o">(</span><span class="s">"User-Agent"</span><span class="o">,</span> <span class="s">"Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)"</span><span class="o">);</span>
<span class="c1">// 连接并发送HTTP请求:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="c1">// 判断HTTP响应是否200:</span>
<span class="k">if</span> <span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getResponseCode</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">200</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"bad response"</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 获取所有响应Header:</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">getHeaderFields</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
<span class="o">}</span>
<span class="c1">// 获取响应内容:</span>
<span class="nc">String</span> <span class="n">nextLine</span><span class="o">;</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
<span class="k">while</span> <span class="o">((</span><span class="n">nextLine</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">nextLine</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">);</span>
<span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p>从<strong>Java 11</strong>开始，引入了新的<code class="language-plaintext highlighter-rouge">HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。首先需要创建一个全局<code class="language-plaintext highlighter-rouge">HttpClient</code>实例，因为<code class="language-plaintext highlighter-rouge">HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">HttpClient</span> <span class="n">httpClient</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">HttpClient</span> <span class="n">httpClient</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">URISyntaxException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">HttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"User-Agent"</span><span class="o">,</span><span class="s">"Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Accept"</span><span class="o">,</span><span class="s">"*/*"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
            <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_2</span><span class="o">)</span>
            <span class="o">.</span><span class="na">GET</span><span class="o">()</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>

    <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">httpClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()!=</span><span class="mi">200</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"bad response"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 获取所有响应Header:</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">body</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果要获取图片这样的二进制内容，只需要把<code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers.ofString()</code>换成<code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code class="language-plaintext highlighter-rouge">HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code class="language-plaintext highlighter-rouge">InputStream</code>流。</p>

<p>如果要使用<code class="language-plaintext highlighter-rouge">POST</code>请求，需要准备好发送的Body数据并正确设置<code class="language-plaintext highlighter-rouge">Content-Type</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"http://www.example.com/login"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="s">"username=bob&amp;password=123456"</span><span class="o">;</span>
<span class="nc">HttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="n">url</span><span class="o">))</span>
    <span class="c1">// 设置Header:</span>
    <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Accept"</span><span class="o">,</span> <span class="s">"*/*"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/x-www-form-urlencoded"</span><span class="o">)</span>
    <span class="c1">// 设置超时:</span>
    <span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
    <span class="c1">// 设置版本:</span>
    <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_2</span><span class="o">)</span>
    <span class="c1">// 使用POST并设置Body:</span>
    <span class="o">.</span><span class="na">POST</span><span class="o">(</span><span class="nc">BodyPublishers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)).</span><span class="na">build</span><span class="o">();</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">httpClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">());</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">body</span><span class="o">();</span>
</code></pre></div></div>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpRequest</code> 类是 Java 11 中引入的，用于表示 HTTP 请求的类。以下是一些常用的 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">builder(URI uri)</code>: 静态方法，返回一个新的 <code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 对象，用于构建 HTTP 请求。</li>
  <li><code class="language-plaintext highlighter-rouge">method()</code>: 返回 HTTP 请求方法，如 GET、POST、PUT 等。</li>
  <li><code class="language-plaintext highlighter-rouge">uri()</code>: 返回请求的 URI。</li>
  <li><code class="language-plaintext highlighter-rouge">headers()</code>: 返回请求头信息，以 <code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;String&gt;&gt;</code> 的形式表示。</li>
  <li><code class="language-plaintext highlighter-rouge">bodyPublisher()</code>: 返回请求体的发布器（<code class="language-plaintext highlighter-rouge">BodyPublisher</code>），用于发送请求体数据。</li>
  <li><code class="language-plaintext highlighter-rouge">version()</code>: 返回 HTTP 协议版本。</li>
  <li><code class="language-plaintext highlighter-rouge">expectContinue()</code>: 返回一个布尔值，指示是否期望服务器在发送响应之前先发送一个 100 Continue 响应。</li>
  <li><code class="language-plaintext highlighter-rouge">timeout()</code>: 返回超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">copy()</code>: 复制当前请求的副本。</li>
  <li><code class="language-plaintext highlighter-rouge">toString()</code>: 将请求对象转换为字符串表示。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpRequest</code> 类中的静态方法通常用于创建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 实例或处理 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 请求。以下是一些常用的静态方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">static HttpRequest.Builder newBuilder()</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 实例，用于构建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">static HttpRequest.Builder newBuilder(URI uri)</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 实例，并传入URI用于构建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofByteArray(byte[] body)</code>：创建一个发布指定字节数组作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofInputStream(Supplier&lt;InputStream&gt; bodySupplier)</code>：创建一个发布从提供的 <code class="language-plaintext highlighter-rouge">InputStream</code> 读取数据作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofString(String body)</code>：创建一个发布指定字符串作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li>
  <li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofFile(Path file)</code>：创建一个发布指定文件内容作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 类用于构建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。以下是该类的方法：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">GET()</code>：设置请求方法为 GET。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">POST(BodyPublisher bodyPublisher)</code>：设置请求方法为 POST，并指定请求体的发布器。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">PUT(BodyPublisher bodyPublisher)</code>：设置请求方法为 PUT，并指定请求体的发布器。</li>
  <li><code class="language-plaintext highlighter-rouge">DELETE()</code>：设置请求方法为 DELETE。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">header(String name, String value)</code>：添加请求头。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">headers(Map&lt;String, List&lt;String&gt;&gt; headers)</code>：添加多个请求头。</li>
  <li><code class="language-plaintext highlighter-rouge">method(String method)</code>：设置请求方法。</li>
  <li><code class="language-plaintext highlighter-rouge">uri(URI uri)</code>：设置请求的 URI。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">version(HttpClient.Version version)</code>：设置 HTTP 协议版本。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">timeout(Duration duration)</code>：设置超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">expectContinue(boolean enable)</code>：设置是否期望服务器在发送响应之前先发送一个 100 Continue 响应。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">build()</code>：构建并返回 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。</strong></li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">URI</code> 类的构造方法如下：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">URI(String uri)</code>：根据给定的 URI 字符串创建 <code class="language-plaintext highlighter-rouge">URI</code> 对象。该字符串必须符合 URI 的语法规则。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">URI(String scheme, String ssp, String fragment)</code></strong>：使用指定的方案、特定部分和片段创建 <code class="language-plaintext highlighter-rouge">URI</code> 对象。方案和特定部分之间用冒号分隔。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)</code></strong>：使用指定的参数创建 <code class="language-plaintext highlighter-rouge">URI</code> 对象。参数包括方案、用户信息、主机、端口、路径、查询和片段。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">Duration</code> 类表示一段时间的持续时间，它提供了用于处理持续时间的方法。以下是 <code class="language-plaintext highlighter-rouge">Duration</code> 类的一些主要方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">static Duration between(Temporal startInclusive, Temporal endExclusive)</code>：返回两个时间点之间的持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">static Duration ofDays(long days)</code>：创建指定天数的持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">static Duration ofHours(long hours)</code>：创建指定小时数的持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">static Duration ofMinutes(long minutes)</code>：创建指定分钟数的持续时间。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">static Duration ofSeconds(long seconds)</code>：创建指定秒数的持续时间。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">static Duration ofMillis(long millis)</code>：创建指定毫秒数的持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">static Duration ofNanos(long nanos)</code>：创建指定纳秒数的持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">long toDays()</code>：获取持续时间的天数部分。</li>
  <li><code class="language-plaintext highlighter-rouge">long toHours()</code>：获取持续时间的小时数部分。</li>
  <li><code class="language-plaintext highlighter-rouge">long toMinutes()</code>：获取持续时间的分钟数部分。</li>
  <li><code class="language-plaintext highlighter-rouge">long toSeconds()</code>：获取持续时间的秒数部分。</li>
  <li><code class="language-plaintext highlighter-rouge">long toMillis()</code>：获取持续时间的毫秒数部分。</li>
  <li><code class="language-plaintext highlighter-rouge">long toNanos()</code>：获取持续时间的纳秒数部分。</li>
  <li><code class="language-plaintext highlighter-rouge">Duration plus(Duration duration)</code>：将另一个持续时间添加到此持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">Duration minus(Duration duration)</code>：从此持续时间中减去另一个持续时间。</li>
  <li><code class="language-plaintext highlighter-rouge">Duration multipliedBy(long multiplicand)</code>：将此持续时间乘以指定的数量。</li>
  <li><code class="language-plaintext highlighter-rouge">Duration dividedBy(long divisor)</code>：将此持续时间除以指定的数量。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isNegative()</code>：检查持续时间是否为负数。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isZero()</code>：检查持续时间是否为零。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpClient.Version</code> 是一个枚举类，表示 HTTP 客户端支持的协议版本。它包含以下字段：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HTTP_1_1</code>：表示 HTTP/1.1 协议版本。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">HTTP_2</code>：表示 HTTP/2 协议版本。</strong></li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">BodyPublishers</code> 类提供了以下静态方法来创建不同类型的 <code class="language-plaintext highlighter-rouge">BodyPublisher</code> 实例：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ofByteArray(byte[] body)</code>：将指定的字节数组作为请求主体发送。</li>
  <li><code class="language-plaintext highlighter-rouge">ofByteArrays(Iterable&lt;byte[]&gt; bodies)</code>：按顺序将多个字节数组作为请求主体发送。</li>
  <li><code class="language-plaintext highlighter-rouge">ofFile(Path file)</code>：将指定文件的内容作为请求主体发送。</li>
  <li><code class="language-plaintext highlighter-rouge">ofInputStream(Supplier&lt;? extends InputStream&gt; streamSupplier)</code>：从提供的 <code class="language-plaintext highlighter-rouge">InputStream</code> 中发送请求主体。</li>
  <li><code class="language-plaintext highlighter-rouge">ofString(String body)</code>：将指定的字符串作为请求主体发送。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">ofString(String body, Charset charset)</code>：将指定的字符串以指定的字符集编码作为请求主体发送。</strong></li>
</ul>

<p>这些方法提供了灵活的方式来创建不同类型的请求主体，并使其适应于不同的请求场景。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpClient</code> 类提供了执行 HTTP 请求和处理 HTTP 响应的方法。以下是一些常用的方法：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">send(HttpRequest request, BodyHandler&lt;T&gt; responseBodyHandler)</code>：发送 HTTP 请求并返回响</strong>应。<code class="language-plaintext highlighter-rouge">request</code> 参数是要发送的请求，<code class="language-plaintext highlighter-rouge">responseBodyHandler</code> 参数指定如何处理响应主体。</li>
  <li><code class="language-plaintext highlighter-rouge">sendAsync(HttpRequest request, BodyHandler&lt;T&gt; responseBodyHandler)</code>：异步发送 HTTP 请求并返回 <code class="language-plaintext highlighter-rouge">CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;</code>，可以在未来的某个时间点获取响应。</li>
  <li><code class="language-plaintext highlighter-rouge">newBuilder()</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">HttpClient.Builder</code> 实例，用于构建 <code class="language-plaintext highlighter-rouge">HttpClient</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">followRedirects()</code>：启用重定向（默认情况下启用）。</li>
  <li><code class="language-plaintext highlighter-rouge">version()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的协议版本。</li>
  <li><code class="language-plaintext highlighter-rouge">sslContext()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的 SSL 上下文。</li>
  <li><code class="language-plaintext highlighter-rouge">proxy()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的代理。</li>
  <li><code class="language-plaintext highlighter-rouge">authenticator()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的身份验证器。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpResponse</code> 类表示 HTTP 响应，并提供了访问响应状态、头信息和主体的方法。以下是一些常用的方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">statusCode()</code>：返回响应的状态码。</li>
  <li><code class="language-plaintext highlighter-rouge">body()</code>：返回响应的主体作为 <code class="language-plaintext highlighter-rouge">HttpResponse.BodySubscriber</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">headers()</code>：返回包含响应头信息的 <code class="language-plaintext highlighter-rouge">Map</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">bodyHandler()</code>：返回用于处理响应主体的 <code class="language-plaintext highlighter-rouge">BodyHandler</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">version()</code>：返回 HTTP 版本。</li>
  <li><code class="language-plaintext highlighter-rouge">uri()</code>：返回请求的 URI。</li>
  <li><code class="language-plaintext highlighter-rouge">request()</code>：返回生成此响应的请求。</li>
  <li><code class="language-plaintext highlighter-rouge">previousResponse()</code>：如果重定向发生，则返回之前的响应。</li>
  <li><code class="language-plaintext highlighter-rouge">sslSession()</code>：返回 SSL 会话。</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers</code> 类是一个工具类，提供了一些静态方法用于创建不同类型的 <code class="language-plaintext highlighter-rouge">BodyHandler</code> 实例，以便处理 HTTP 响应主体。以下是一些常用的静态方法：</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ofString()</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体作为字符串处理。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">ofByteArray()</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体作为字节数组处理。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">ofInputStream()</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体作为输入流处理。</li>
  <li><code class="language-plaintext highlighter-rouge">ofFile(Path file)</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体保存到指定文件。</li>
</ul>

<h2 id="rmi远程调用">RMI远程调用</h2>

<p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p>

<p>提供服务的一方称之为服务器，而实现远程调用的一方称之为客户端。</p>

<p>服务器会提供一个<code class="language-plaintext highlighter-rouge">WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LocalDateTime</span> <span class="nf">getLocalDateTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">zoneId</span><span class="o">);</span>
</code></pre></div></div>

<p>要实现RMI，服务器和客户端必须共享同一个接口。定义一个<code class="language-plaintext highlighter-rouge">WorldClock</code>接口，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">WorldClock</span> <span class="kd">extends</span> <span class="nc">Remote</span> <span class="o">{</span>
    <span class="nc">LocalDateTime</span> <span class="nf">getLocalDateTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">zoneId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Java的RMI规定此接口<strong>必须派生自<code class="language-plaintext highlighter-rouge">java.rmi.Remote</code></strong>，并在每个方法声明抛出<code class="language-plaintext highlighter-rouge">RemoteException</code>，因为远程方法调用缺乏本地调用的可靠性，远程调用总是存在失败的可能。</p>

<p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code class="language-plaintext highlighter-rouge">getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code class="language-plaintext highlighter-rouge">WorldClockService</code>代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WorldClockService</span> <span class="kd">implements</span> <span class="nc">WorldClock</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">LocalDateTime</span> <span class="nf">getLocalDateTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">zoneId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">(</span><span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">zoneId</span><span class="o">)).</span><span class="na">withNano</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>现在，服务器端的服务相关代码就编写完毕。需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"create World clock remote service..."</span><span class="o">);</span>
        <span class="c1">// 实例化一个WorldClock:</span>
        <span class="nc">WorldClock</span> <span class="n">worldClock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WorldClockService</span><span class="o">();</span>
        <span class="c1">// 将此服务转换为远程服务接口:</span>
        <span class="nc">WorldClock</span> <span class="n">skeleton</span> <span class="o">=</span> <span class="o">(</span><span class="nc">WorldClock</span><span class="o">)</span> <span class="nc">UnicastRemoteObject</span><span class="o">.</span><span class="na">exportObject</span><span class="o">(</span><span class="n">worldClock</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span><span class="c1">// 第二个参数为0，表明任何合适的端口都可用来监听客户连接。</span>
        <span class="c1">// 将RMI服务注册到1099端口:</span>
        <span class="nc">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="nc">LocateRegistry</span><span class="o">.</span><span class="na">createRegistry</span><span class="o">(</span><span class="mi">1099</span><span class="o">);</span>
        <span class="c1">// 注册此服务，服务名为"WorldClock":</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">rebind</span><span class="o">(</span><span class="s">"WorldClock"</span><span class="o">,</span> <span class="n">skeleton</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code class="language-plaintext highlighter-rouge">WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code class="language-plaintext highlighter-rouge">1099</code>，最后一步注册服务时通过<code class="language-plaintext highlighter-rouge">rebind()</code>指定服务名称为<code class="language-plaintext highlighter-rouge">"WorldClock"</code>。</p>

<p>下一步就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此要把<code class="language-plaintext highlighter-rouge">WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span><span class="o">,</span> <span class="nc">NotBoundException</span> <span class="o">{</span>
        <span class="c1">// 连接到服务器localhost，端口1099:</span>
        <span class="nc">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="nc">LocateRegistry</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">1099</span><span class="o">);</span>
        <span class="c1">// 查找名称为"WorldClock"的服务并强制转型为WorldClock接口:</span>
        <span class="nc">WorldClock</span> <span class="n">worldClock</span> <span class="o">=</span> <span class="o">(</span><span class="nc">WorldClock</span><span class="o">)</span> <span class="n">registry</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"WorldClock"</span><span class="o">);</span>
        <span class="c1">// 正常调用接口方法:</span>
        <span class="nc">LocalDateTime</span> <span class="n">now</span> <span class="o">=</span> <span class="n">worldClock</span><span class="o">.</span><span class="na">getLocalDateTime</span><span class="o">(</span><span class="s">"Asia/Shanghai"</span><span class="o">);</span>
        <span class="c1">// 打印调用结果:</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。</p>

<p>对客户端来说，客户端持有的<code class="language-plaintext highlighter-rouge">WorldClock</code>接口实际上对应了一个“实现类”，它是由<code class="language-plaintext highlighter-rouge">Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code class="language-plaintext highlighter-rouge">WorldClockService</code>，而是<code class="language-plaintext highlighter-rouge">Registry</code>自动生成的代码。</p>

<p>把客户端的“实现类”称为<code class="language-plaintext highlighter-rouge">stub</code>，而服务器端的网络服务类称为<code class="language-plaintext highlighter-rouge">skeleton</code>，它会真正调用服务器端的<code class="language-plaintext highlighter-rouge">WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p>

<pre><code class="language-ascii">┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
  ┌─────────────┐                                 ┌─────────────┐
│ │   Service   │ │         │                     │   Service   │ │
  └─────────────┘                                 └─────────────┘
│        ▲        │         │                            ▲        │
         │                                               │
│        │        │         │                            │        │
  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐
│ │ Client Stub ├─┼─────────┼&gt;│Server Skeleton│──&gt;│Service Impl │ │
  └─────────────┘             └───────────────┘   └─────────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
</code></pre>

<p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>

<p>Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a href="https://grpc.io/">gRPC</a>。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">Remote</code>接口，用于标识那些方法可以从非本地虚拟机调用的接口。任何作为远程对象的对象必须直接或间接实现这个接口。</p>

<p><code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类是用于导出远程对象的抽象类。它提供了导出远程对象所需的基本功能。在Java RMI中，远程对象必须继承自 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类或调用 <code class="language-plaintext highlighter-rouge">exportObject</code> 方法来导出对象，以便能够被远程客户端访问。</p>

<p>实现类可以实现任意数量的远程接口，并且可以扩展其他远程实现类。RMI提供了一些便利类，远程对象实现可以扩展这些类以方便远程对象的创建。这些类包括<code class="language-plaintext highlighter-rouge">java.rmi.server.UnicastRemoteObject</code>和<code class="language-plaintext highlighter-rouge">java.rmi.activation.Activatable</code>。</p>

<p><code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类的作用包括：</p>

<ul>
  <li>导出远程对象：通过继承 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类或调用 <code class="language-plaintext highlighter-rouge">exportObject</code> 方法，可以将一个普通的Java对象转换为远程对象，使其能够接收远程调用。</li>
  <li>远程对象的生命周期管理：<code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类提供了一些方法用于管理远程对象的生命周期，如 <code class="language-plaintext highlighter-rouge">unexportObject</code> 方法用于取消导出远程对象。</li>
  <li>RMI通信的基础支持：<code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类提供了与RMI通信相关的基础支持，如实现了 <code class="language-plaintext highlighter-rouge">Remote</code> 接口以标识远程对象，同时提供了一些内部实现用于处理远程调用。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类包含以下重要的方法：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">UnicastRemoteObject()</code>：构造一个新的 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">UnicastRemoteObject(int port)</code>：在指定端口上创建一个新的 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</code>：在指定端口上创建一个新的 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 对象，使用指定的客户端和服务器端套接字工厂。</li>
  <li><code class="language-plaintext highlighter-rouge">static RemoteStub exportObject(Remote obj)</code>：导出远程对象并返回其 stub。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">static RemoteStub exportObject(Remote obj, int port)</code>：导出远程对象并返回其 stub，在指定端口上监听。参数 <code class="language-plaintext highlighter-rouge">obj</code> 是要导出的远程对象，参数 <code class="language-plaintext highlighter-rouge">port</code> 是要监听的端口号。如果端口号为 0，则系统会自动选择一个可用的端口。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">static boolean unexportObject(Remote obj, boolean force)</code>：取消导出远程对象。</li>
  <li><code class="language-plaintext highlighter-rouge">static Object toStub(Remote obj)</code>：返回远程对象的 stub。</li>
</ol>

<p>这些方法用于导出和管理远程对象，使其能够被远程客户端访问。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">LocateRegistry</code> 类是 Java RMI 中用于定位远程注册表的工具类。它提供了一组静态方法，用于获取远程注册表的引用。<code class="language-plaintext highlighter-rouge">LocateRegistry</code> 类的方法包括：</p>

<p><code class="language-plaintext highlighter-rouge">LocateRegistry</code> 类的方法包括：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">static Registry getRegistry(String host, int port)</code>：返回指定主机和端口上的远程注册表引用。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">static Registry getRegistry(String host, int port, RMIClientSocketFactory csf)</code>：返回指定主机和端口上的远程注册表引用，并使用指定的客户端套接字工厂创建套接字连接。</li>
  <li><code class="language-plaintext highlighter-rouge">static Registry getRegistry(String host, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</code>：返回指定主机和端口上的远程注册表引用，并使用指定的客户端套接字工厂和服务器套接字工厂创建套接字连接。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">static Registry createRegistry(int port)</code>：在本地主机上的指定端口上创建并返回远程注册表引用。</strong></li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">Registry</code> 类是 Java RMI 中的一个类，用于提供远程对象的注册和查找服务。它允许远程客户端查找和访问在远程主机上注册的远程对象。</p>

<p><code class="language-plaintext highlighter-rouge">Registry</code> 类的主要方法包括：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">void bind(String name, Remote obj)</code>：将指定的远程对象与指定的名称在此注册表中进行绑定。</li>
  <li><code class="language-plaintext highlighter-rouge">void unbind(String name)</code>：从此注册表中移除指定名称的绑定。</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Remote lookup(String name)</code>：返回指定名称绑定的远程对象的引用。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">void rebind(String name, Remote obj)</code>：将指定的远程对象与指定的名称在此注册表中进行重新绑定。</strong></li>
  <li><code class="language-plaintext highlighter-rouge">String[] list()</code>：返回此注册表中的所有绑定名称的数组。</li>
</ul>

<p>这些方法允许远程对象在注册表中注册、查找和解绑，从而实现了远程对象之间的通信和访问。</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">多线程</title><link href="/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="alternate" type="text/html" title="多线程" /><published>2024-04-16T00:00:00+08:00</published><updated>2024-04-16T00:00:00+08:00</updated><id>/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B</id><content type="html" xml:base="/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><![CDATA[<h1 id="引言">引言</h1>
<p>多线程笔记，包括线程、中断、同步、死锁、等待、唤醒、ReentrantLock、ReadWriteLock、 StampedLock、Semaphore、线程池、 CompletableFuture异步执行、ForkJoin、ThreadLocal、虚拟线程。</p>

<h1 id="多线程">多线程</h1>
<p>操作系统（Windows，macOS，Linux）都可以执行多任务,多任务就是同时运行多个任务。</p>

<p><strong>进程</strong></p>

<p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>

<p>某些进程内部还需要同时执行多个子任务。例如，在使用Word时，可以一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>

<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>

<pre><code class="language-ascii">                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
</code></pre>
<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，<strong>如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</strong></p>

<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p>

<p>多进程模式（每个进程只有一个线程）：</p>

<pre><code class="language-ascii">┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
</code></pre>
<p>多线程模式（一个进程有多个线程）：</p>
<pre><code class="language-ascii">┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
</code></pre>
<p>多进程＋多线程模式（复杂度最高）：</p>
<pre><code class="language-ascii">┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
</code></pre>
<p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。具体采用哪种方式，要考虑到进程和线程的特点。</p>

<p>和多线程相比，多进程的缺点在于：</p>

<ul>
  <li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
  <li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>
</ul>

<p>而多进程的优点在于：</p>

<p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>

<p><strong>多线程</strong></p>

<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code class="language-plaintext highlighter-rouge">main()</code>方法，在<code class="language-plaintext highlighter-rouge">main()</code>方法内部，又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>

<p>因此，对于大多数Java程序来说，说多任务，实际上是说如何使用多线程实现多任务。</p>

<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>

<p>Java多线程编程的特点又在于：</p>

<ul>
  <li>多线程模型是Java程序最基本的并发模型；</li>
  <li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>

<hr />

<p><strong>线程类<code class="language-plaintext highlighter-rouge">Thread</code>常用的方法</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">start()</code>：启动线程，使其处于可运行状态。</li>
  <li><code class="language-plaintext highlighter-rouge">run()</code>：线程的执行体，包含了线程要执行的代码。</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.setDaemon(boolean on)</code>：设置线程为守护线程或用户线程。守护线程不会阻止程序的终止，当所有的用户线程结束时，守护线程会自动结束。</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.isDaemon()</code>：判断线程是否为守护线程。</li>
  <li><code class="language-plaintext highlighter-rouge">sleep(long millis)</code>：使当前线程休眠指定的时间，以毫秒为单位。在休眠期间，线程状态不会改变，不会释放已经持有的锁。</li>
  <li><code class="language-plaintext highlighter-rouge">join()</code>：等待线程终止。调用此方法的线程将会被阻塞，直到目标线程执行完成。</li>
  <li><code class="language-plaintext highlighter-rouge">interrupt()</code>：中断线程。通知目标线程应该中断，但实际中断操作由目标线程自行处理。</li>
  <li><code class="language-plaintext highlighter-rouge">isInterrupted()</code>：判断线程是否已经被中断。</li>
  <li><code class="language-plaintext highlighter-rouge">interrupted()</code>：判断当前线程是否已经被中断，并清除中断状态。</li>
  <li><code class="language-plaintext highlighter-rouge">yield()</code>：让出当前线程的执行权，使得其他具有相同优先级的线程有机会执行。</li>
  <li><code class="language-plaintext highlighter-rouge">setName(String name)</code>：设置线程的名称。</li>
  <li><code class="language-plaintext highlighter-rouge">getName()</code>：获取线程的名称。</li>
  <li><code class="language-plaintext highlighter-rouge">isAlive()</code>：判断线程是否处于活动状态（已启动但尚未终止）。</li>
  <li><code class="language-plaintext highlighter-rouge">setPriority(int priority)</code>：设置线程的优先级。优先级范围为1（最低）到10（最高）。</li>
  <li><code class="language-plaintext highlighter-rouge">getPriority()</code>：获取线程的优先级。</li>
</ul>

<p>这些方法可以帮助我们管理和控制线程的执行，使得多线程编程更加灵活和高效。</p>

<hr />

<p>锁的方法通常与<code class="language-plaintext highlighter-rouge">synchronized</code>关键字和<code class="language-plaintext highlighter-rouge">java.util.concurrent.locks</code>包中的锁对象相关联。以下是一些常用的<strong>锁方法</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">synchronized</code>关键字：用于同步方法或同步块，可以实现对代码块的互斥访问。</li>
  <li><code class="language-plaintext highlighter-rouge">wait()</code>：在锁对象上等待，直到其他线程调用该对象的<code class="language-plaintext highlighter-rouge">notify()</code>或<code class="language-plaintext highlighter-rouge">notifyAll()</code>方法唤醒该线程。</li>
  <li><code class="language-plaintext highlighter-rouge">void wait(long timeout)</code>：同<code class="language-plaintext highlighter-rouge">wait()</code>，但如果在指定时间内未收到通知，则当前线程会自动唤醒。</li>
  <li><code class="language-plaintext highlighter-rouge">void wait(long timeout, int nanos)</code>：类似于<code class="language-plaintext highlighter-rouge">wait(long timeout)</code>方法，但还可以指定纳秒级别的超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">notify()</code>：唤醒在锁对象上等待的单个线程。</li>
  <li><code class="language-plaintext highlighter-rouge">notifyAll()</code>：唤醒在锁对象上等待的所有线程。</li>
  <li><code class="language-plaintext highlighter-rouge">ReentrantLock</code>类：可重入锁，提供了更灵活的锁定机制，可以替代<code class="language-plaintext highlighter-rouge">synchronized</code>关键字。常用方法包括<code class="language-plaintext highlighter-rouge">lock()</code>、<code class="language-plaintext highlighter-rouge">unlock()</code>、<code class="language-plaintext highlighter-rouge">tryLock()</code>等。</li>
  <li><code class="language-plaintext highlighter-rouge">Condition</code>接口：配合<code class="language-plaintext highlighter-rouge">ReentrantLock</code>使用，提供了类似<code class="language-plaintext highlighter-rouge">wait()</code>和<code class="language-plaintext highlighter-rouge">notify()</code>的功能，但更加灵活。</li>
  <li><code class="language-plaintext highlighter-rouge">ReadWriteLock</code>接口：读写锁，提供了读锁和写锁，可以提高读操作的并发性能。</li>
  <li><code class="language-plaintext highlighter-rouge">StampedLock</code>类：提供了一种乐观读锁的机制，适用于读多写少的场景。</li>
</ul>

<p>这些方法和类可以帮助我们在多线程环境中实现对共享资源的安全访问和控制。</p>

<hr />

<p>以下是一些<code class="language-plaintext highlighter-rouge">Thread</code>类中的常用<strong>静态方法</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Thread.currentThread()</code>：返回当前正在执行的线程对象。</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.sleep(long millis)</code>：使当前线程休眠指定的毫秒数。</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.yield()</code>：提示调度器当前线程愿意放弃当前对处理器的使用。</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.interrupted()</code>：测试当前线程是否已经中断，并清除该线程的中断状态。</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.interrupt()</code>：中断当前线程。</li>
</ul>

<p>这些静态方法在多线程编程中经常被使用，用于控制线程的行为和状态。</p>
<h2 id="创建新线程">创建新线程</h2>
<p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code class="language-plaintext highlighter-rouge">main()</code>方法。在<code class="language-plaintext highlighter-rouge">main()</code>方法中，又可以启动其他线程。</p>

<p>要创建一个新线程非常容易，实例化一个<code class="language-plaintext highlighter-rouge">Thread</code>实例，然后调用它的<code class="language-plaintext highlighter-rouge">start()</code>方法。</p>

<p>但是这个线程启动后实际上什么也不做就立刻结束了。如果希望新线程能执行指定的代码，有以下几种方法：</p>

<p>方法一：从<code class="language-plaintext highlighter-rouge">Thread</code>派生一个自定义类，然后覆写<code class="language-plaintext highlighter-rouge">run()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"匿名子类"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">start()</code>方法会在内部自动调用实例的<code class="language-plaintext highlighter-rouge">run()</code>方法。</p>

<p>方法二：创建<code class="language-plaintext highlighter-rouge">Thread</code>实例时，传入一个<code class="language-plaintext highlighter-rouge">Runnable</code>实例，这种内部类会取不到当前<code class="language-plaintext highlighter-rouge">Thread</code>匿名子类对象，可以通过<code class="language-plaintext highlighter-rouge">Thread.currentThread()</code>得到当前线程对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Runnable接口匿名类"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div>
<p>若外部<code class="language-plaintext highlighter-rouge">Thread</code>不是匿名的，则也可以在匿名内部类内通过<code class="language-plaintext highlighter-rouge">外部类名.this</code>来引用外部类的实例。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div>
<p>注意不能使用<code class="language-plaintext highlighter-rouge">t</code>，因为<code class="language-plaintext highlighter-rouge">t</code>现在还没有初始化（其实内部类代码运行的时候已经实例化了），但对编译器来说无法确定在这个时候<code class="language-plaintext highlighter-rouge">t</code>是否已经被正确初始化。因此，即使在实际运行时<code class="language-plaintext highlighter-rouge">t</code>已经被实例化了，编译器也会在编译时会认为<code class="language-plaintext highlighter-rouge">t</code>是一个未被初始化的变量，从而导致编译错误。</p>

<p>可以使用lambda简化：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Runnable接口匿名类"</span><span class="o">));</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div>
<p>创建线程后的代码执行顺序：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法开始"</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程开始"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程结束"</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法结束"</span><span class="o">);</span>
</code></pre></div></div>
<p>只能肯定<code class="language-plaintext highlighter-rouge">main</code>线程先打印<code class="language-plaintext highlighter-rouge">main方法开始</code>，然后创建并启动了新线程，然后再打印。而新线程会在启动后与<code class="language-plaintext highlighter-rouge">main</code>线程并发运行，因此对于新线程启用后的打印语句顺序是<strong>不可预知</strong>的，调度由操作系统控制，<strong>程序本身无法确定线程的调度顺序</strong>。</p>

<p>要特别注意：直接调用<code class="language-plaintext highlighter-rouge">Thread</code>实例的<code class="language-plaintext highlighter-rouge">run()</code>方法是<strong>无效</strong>的。直接调用<code class="language-plaintext highlighter-rouge">run()</code>方法，相当于调用了一个<strong>普通</strong>的Java方法，当前线程并没有任何改变，也不会启动新线程。</p>

<p><strong>必须</strong>调用<code class="language-plaintext highlighter-rouge">Thread</code>实例的<code class="language-plaintext highlighter-rouge">start()</code>方法才能<strong>启动新线程</strong>，如果查看<code class="language-plaintext highlighter-rouge">Thread</code>类的源代码，会看到<code class="language-plaintext highlighter-rouge">start()</code>方法内部调用了一个<code class="language-plaintext highlighter-rouge">private native void start0()</code>方法，<code class="language-plaintext highlighter-rouge">native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>

<p>可以通过<code class="language-plaintext highlighter-rouge">setPriority(int n)</code>对线程设定优先级，n的值范围是1~10, 默认值为5。</p>

<p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但<strong>决不能</strong>通过设置优先级来<strong>确保</strong>高优先级的线程<strong>一定会先执行</strong>。</p>

<h2 id="线程的状态">线程的状态</h2>
<p>在Java程序中，<strong>一个线程对象只能调用一次<code class="language-plaintext highlighter-rouge">start()</code>方法启动新线程</strong>，并在新线程中执行<code class="language-plaintext highlighter-rouge">run()</code>方法。一旦<code class="language-plaintext highlighter-rouge">run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p>
<ul>
  <li>New：新创建的线程，尚未执行；</li>
  <li>Runnable：运行中的线程，正在<strong>执行</strong><code class="language-plaintext highlighter-rouge">run()</code>方法的Java代码；</li>
  <li>Blocked：运行中的线程，因为某些操作被<strong>阻塞</strong>而挂起；</li>
  <li>Waiting：运行中的线程，因为某些操作在<strong>等待</strong>中；</li>
  <li>Timed Waiting：运行中的线程，因为执行<code class="language-plaintext highlighter-rouge">sleep()</code>方法正在计时<strong>等待</strong>；</li>
  <li>Terminated：线程已<strong>终止</strong>，因为<code class="language-plaintext highlighter-rouge">run()</code>方法执行完毕。</li>
</ul>

<p>用一个状态转移图表示如下：</p>
<pre><code class="language-ascii">         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
</code></pre>
<p>当线程启动后，它可以在<code class="language-plaintext highlighter-rouge">Runnable</code>、<code class="language-plaintext highlighter-rouge">Blocked</code>、<code class="language-plaintext highlighter-rouge">Waiting</code>和<code class="language-plaintext highlighter-rouge">Timed Waiting</code>这几个状态之间切换，直到最后变成<code class="language-plaintext highlighter-rouge">Terminated</code>状态，线程终止。<br />
线程终止的原因有：</p>
<ul>
  <li>线程正常终止：<code class="language-plaintext highlighter-rouge">run()</code>方法执行到<code class="language-plaintext highlighter-rouge">return</code>语句返回；</li>
  <li>线程意外终止：<code class="language-plaintext highlighter-rouge">run()</code>方法因为未捕获的异常导致线程终止；</li>
  <li>对某个线程的<code class="language-plaintext highlighter-rouge">Thread</code>实例调用<code class="language-plaintext highlighter-rouge">stop()</code>方法强制终止（强烈不推荐使用）。</li>
</ul>

<hr />

<p><strong>等待其他线程执行完毕</strong></p>

<p>一个线程还可以<strong>等待</strong>另一个线程直到其运行结束。</p>

<p>例如，<code class="language-plaintext highlighter-rouge">main</code>线程在启动<code class="language-plaintext highlighter-rouge">t</code>线程后，可以通过<code class="language-plaintext highlighter-rouge">t.join()</code>等待<code class="language-plaintext highlighter-rouge">t</code>线程结束后再继续运行：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法开始"</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程开始"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程结束"</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
<span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">//等待t线程结束</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法结束"</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main方法开始
线程开始
线程结束
main方法结束
</code></pre></div></div>
<p>如果<code class="language-plaintext highlighter-rouge">t</code>线程已经结束，对实例<code class="language-plaintext highlighter-rouge">t</code>调用<code class="language-plaintext highlighter-rouge">join()</code>会立刻返回。此外，<code class="language-plaintext highlighter-rouge">join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>

<hr />

<p>在 Java 中，<strong>多线程中的阻塞状态和等待状态是两种不同的状态</strong>，它们之间有一些区别：</p>

<ol>
  <li><strong>阻塞状态（Blocked）</strong>：
    <ul>
      <li>当一个线程在获取锁时，如果该锁已经被其他线程持有，那么这个线程会进入阻塞状态，直到该锁被释放并且它能够获取到锁为止。</li>
      <li>当一个线程已经持有锁时，线程进入阻塞状态是因为正在等待某个条件的发生，一旦条件满足，线程将会被唤醒并切换到就绪状态。</li>
      <li>阻塞状态的线程<strong>仍然持有已经获得的锁</strong>，不会释放锁。</li>
    </ul>
  </li>
  <li><strong>等待状态（Waiting）</strong>：
    <ul>
      <li>当线程调用 <code class="language-plaintext highlighter-rouge">Object.wait()</code>、<code class="language-plaintext highlighter-rouge">Thread.join()</code> 或 <code class="language-plaintext highlighter-rouge">LockSupport.park()</code> 等方法进入等待状态时，线程会进入等待状态。</li>
      <li>等待状态下的线程会<strong>释放持有的锁</strong>，等待其他线程调用 <code class="language-plaintext highlighter-rouge">notify()</code>、<code class="language-plaintext highlighter-rouge">notifyAll()</code> 或被中断时才能被唤醒，并尝试重新获得之前持有的锁，如果获取成功，则可以继续执行。</li>
      <li>等待状态通常用于线程间的协调和通信，等待特定条件满足后再继续执行。</li>
    </ul>
  </li>
</ol>

<p>总的来说，阻塞状态是因为线程被其他原因无法继续执行所产生的状态，而等待状态则是线程主动等待某些条件满足才能继续执行的状态。在编写多线程程序时，理解和正确处理线程的阻塞和等待状态是非常重要的。</p>

<hr />

<p><strong>注意：<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>不会释放持有的锁。</strong></p>

<p>Timed Waiting（计时等待）和Waiting（等待）是两种不同的线程状态。</p>

<ul>
  <li>Timed Waiting（计时等待）是指线程在等待一段时间后自动恢复，例如通过调用<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>或调用了<strong><code class="language-plaintext highlighter-rouge">Object.wait(long timeout)</code></strong>方法。在这种状态下，线程是<strong>持有锁</strong>的。</li>
  <li>Waiting（等待）是指线程在等待某个条件满足后被唤醒，例如通过调用<strong><code class="language-plaintext highlighter-rouge">Object.wait()</code></strong>方法。在这种状态下，线程是<strong>释放了持有的锁</strong>的。</li>
</ul>

<p>这两种状态的区别在于<strong>是否指定了等待的时间</strong>。Timed Waiting是有一个<strong>固定的等待时间</strong>，而Waiting是等待某个条件的发生，<strong>时间不确定</strong>。</p>
<h2 id="中断线程">中断线程</h2>
<p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是<strong>其他线程</strong>给该线程发一个信号，该线程收到信号后应结束执行<code class="language-plaintext highlighter-rouge">run()</code>方法，使得自身线程能<strong>立刻结束运行</strong>。</p>

<p>假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p>

<p>中断一个线程非常简单，只需要在<strong>其他线程</strong>中<strong>对目标线程</strong>调用<code class="language-plaintext highlighter-rouge">interrupt()</code>方法，<strong>目标线程需要反复检测自身状态</strong>是否是interrupted状态，如果是，就立刻结束运行。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">isInterrupted</span><span class="o">()){</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                <span class="n">n</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程被中断，结束执行"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"中断了，n="</span><span class="o">+</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始"</span><span class="o">);</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
<span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
</code></pre></div></div>
<p>这段代码大概率会一直运行，虽然调用<code class="language-plaintext highlighter-rouge">t.interrupt();</code>时，会改变<code class="language-plaintext highlighter-rouge">interrupted</code>的状态，使得<code class="language-plaintext highlighter-rouge">!isInterrupted()</code>为假。</p>

<p>但主线程请求<code class="language-plaintext highlighter-rouge">t</code>线程中断时，<code class="language-plaintext highlighter-rouge">t</code>线程<strong>大概率</strong>是在运行<code class="language-plaintext highlighter-rouge">sleep(10)</code>，而<strong><code class="language-plaintext highlighter-rouge">sleep()</code>方法会检测线程是否出现中断请求</strong>，如果检测到了，则会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>异常，并<strong>清除线程的中断状态</strong>，而异常又被捕获了，因此<code class="language-plaintext highlighter-rouge">while</code>循环不会结束。</p>

<p>也有极小概率会正常终止，当主线程请求<code class="language-plaintext highlighter-rouge">t</code>线程中断时，如果<code class="language-plaintext highlighter-rouge">t</code>线程已经运行完<code class="language-plaintext highlighter-rouge">sleep()</code>,在运行之后的<code class="language-plaintext highlighter-rouge">n++;</code>则会在下次循环通过<code class="language-plaintext highlighter-rouge">!isInterrupted()</code>为假后结束循环。</p>

<p>要让之前的代码正常退出，只需要在<code class="language-plaintext highlighter-rouge">catch</code>块中添加<code class="language-plaintext highlighter-rouge">break;</code>。结果如下：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>开始
线程被中断，结束执行
中断了，n=9
结束
</code></pre></div></div>

<hr />

<p>调用<code class="language-plaintext highlighter-rouge">interrupt()</code>方法<strong>只是向目标线程发出中断请求</strong>，目标线程<strong>可以选择</strong>是否<strong>响应</strong>这个请求。目标线程可以通过<strong>检查中断状态</strong>并<strong>采取</strong>适当的<strong>措施</strong>来响应中断请求，也可以选择<strong>忽略</strong>中断请求继续执行。</p>

<p>在处理<code class="language-plaintext highlighter-rouge">InterruptedException</code>时，也可以选择继续等待，或处理中断请求提前结束线程的执行，具体取决于应用程序的需求。</p>

<p><strong><code class="language-plaintext highlighter-rouge">InterruptedException</code>通常在以下情况下抛出</strong>：</p>

<ol>
  <li>当一个线程处于计时等待状态（如调用<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>）时，另一个线程调用了该线程的<code class="language-plaintext highlighter-rouge">interrupt()</code>方法，这会导致该线程抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>，并且<strong>清除该线程的中断状态</strong>。或者在调用<code class="language-plaintext highlighter-rouge">Thread.sleep()</code><strong>之前</strong>，另一个线程调用了该线程的<code class="language-plaintext highlighter-rouge">interrupt()</code>方法，则在执行<code class="language-plaintext highlighter-rouge">Thread.sleep()</code><strong>时</strong>会<strong>检测</strong>到中断请求，并抛出异常，清除中断状态。</li>
  <li>如果一个线程在调用<code class="language-plaintext highlighter-rouge">Object.wait()</code>、<code class="language-plaintext highlighter-rouge">Thread.join()</code>、<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>时被中断，则会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>，并且<strong>清除该线程的中断状态</strong>。这样线程在等待某些条件时，如果被中断就会提早终止。如果<strong>调用前</strong>被中断请求，则<strong>调用时</strong>也会检测到中断请求，并抛出异常，清除中断状态。</li>
</ol>

<p>也就是说：当线程处于等待、计时等待状态或以其他方式被占用时，线程在活动之前或期间出现中断时会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>。</p>

<p>还可以通过<code class="language-plaintext highlighter-rouge">Thread.currentThread().interrupt()</code>方法来<strong>重新设置当前线程的中断状态</strong>。这种方式可以在捕获<code class="language-plaintext highlighter-rouge">InterruptedException</code>异常后，手动设置线程的中断状态为<code class="language-plaintext highlighter-rouge">true</code>，以便在后续的循环条件中能够正确地退出循环。</p>

<p>因此<strong>正在跑的线程不会响应别的线程发出的中断</strong>。<strong>只有<code class="language-plaintext highlighter-rouge">sleep/wait</code>状态的线程会响应<code class="language-plaintext highlighter-rouge">interrupt</code>。</strong>如果一个线程正在跑，别的线程给他发中断请求，如果没有显示的处理中断请求，它要继续跑到自己调用<code class="language-plaintext highlighter-rouge">sleep/wait</code>的时候，才响应中断请求，抛出异常。</p>

<p>如果你写了一个计算密集型任务，跑一次要10分钟，为了能及时响应别的线程发的<code class="language-plaintext highlighter-rouge">interrupt</code>，可以每跑几秒钟就<code class="language-plaintext highlighter-rouge">sleep(1)</code>一下，确保能及时被<code class="language-plaintext highlighter-rouge">interrupt</code>。</p>

<p><strong>实际上<code class="language-plaintext highlighter-rouge">interrupt()</code>是这么说的</strong>：</p>

<p><code class="language-plaintext highlighter-rouge">interrupt()</code> 方法用于中断线程。除非当前线程是在中断自己，这种情况总是被允许的，否则会调用此线程的 <code class="language-plaintext highlighter-rouge">checkAccess</code> 方法，可能会导致抛出 <code class="language-plaintext highlighter-rouge">SecurityException</code>。</p>

<p>如果线程被阻塞在 <code class="language-plaintext highlighter-rouge">Object</code> 类的 <code class="language-plaintext highlighter-rouge">wait()</code>、<code class="language-plaintext highlighter-rouge">wait(long)</code>、<code class="language-plaintext highlighter-rouge">wait(long, int)</code> 方法，或者 <code class="language-plaintext highlighter-rouge">Thread</code> 类的 <code class="language-plaintext highlighter-rouge">join()</code>、<code class="language-plaintext highlighter-rouge">join(long)</code>、<code class="language-plaintext highlighter-rouge">join(long, int)</code>、<code class="language-plaintext highlighter-rouge">sleep(long)</code>、<code class="language-plaintext highlighter-rouge">sleep(long, int)</code> 方法中，那么它的<strong>中断状态将被清除</strong>，并且会收到一个 <code class="language-plaintext highlighter-rouge">InterruptedException</code>。</p>

<p>如果线程被阻塞在一个 <code class="language-plaintext highlighter-rouge">InterruptibleChannel</code> 的 I/O 操作上，那么该通道将被关闭，线程的<strong>中断状态将被设置</strong>，并且线程将收到一个 <code class="language-plaintext highlighter-rouge">java.nio.channels.ClosedByInterruptException</code>。</p>

<p>如果线程被阻塞在一个 <code class="language-plaintext highlighter-rouge">Selector</code> 上，那么线程的<strong>中断状态将被设置</strong>，并且它将立即从选择操作中返回，可能返回一个非零值，就像调用了选择器的 <code class="language-plaintext highlighter-rouge">wakeup</code> 方法一样。</p>

<p>如果以上情况<strong>都不适用</strong>，那么线程的<strong>中断状态将被设置</strong>。</p>

<p>对一个非存活的线程进行中断操作可能没有任何效果。</p>

<p>此外，文档还指出，在 JDK 参考实现中，对于一个非存活的线程进行中断操作仍然<strong>会记录中断请求</strong>，并通过 <code class="language-plaintext highlighter-rouge">interrupted()</code> 和 <code class="language-plaintext highlighter-rouge">isInterrupted()</code> 方法报告它。</p>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>  <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">//判断中断状态</span>
                <span class="k">while</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">n</span><span class="o">++;</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：休眠时检测到中断请求"</span><span class="o">);</span>
                        <span class="k">try</span> <span class="o">{</span><span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span><span class="c1">//收拾东西</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：走了！"</span><span class="o">);</span>
                        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：别催了，马上走！"</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：运行时检测到中断请求"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：走了！"</span><span class="o">);</span>
            <span class="o">});</span>
            <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span><span class="c1">// 启动新线程t2</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> <span class="c1">// 等待t2线程结束</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：Main通知关门了!"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：t2，关门了，快走！"</span><span class="o">);</span>
                <span class="n">t2</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span><span class="c1">// 通知t2，中断请求</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等待t2线程结束</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：又被Main通知关门了!t2怎么还不走？"</span><span class="o">);</span>
                    <span class="c1">//t2.join();</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：算了我不等了，我先走了"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程t1</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main：t1，关门了，快走！"</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span><span class="c1">// 通知t1，中断请求</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">// 等1ms</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main：t1，快点！"</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span><span class="c1">// 再次通知t1，中断请求</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等待t1，中断完成</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main：已确认t1走了"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 hello!
2 hello!
3 hello!
4 hello!
5 hello!
6 hello!
7 hello!
8 hello!
9 hello!
10 hello!
Main：t1，关门了，快走！
t1：Main通知关门了!
t1：t2，关门了，快走！
t2：休眠时检测到中断请求
Main：t1，快点！
t1：又被Main通知关门了!t2怎么还不走？
t1：算了我不等了，我先走了
Main：已确认t1走了
t2：走了！
</code></pre></div></div>
<p>假设一般代码执行没有消耗时间，<code class="language-plaintext highlighter-rouge">XXXXms</code>表示程序运行后的时间。<br />
0~1000ms：<code class="language-plaintext highlighter-rouge">t2</code>持续输出。</p>

<p>1000ms：<code class="language-plaintext highlighter-rouge">main</code>线程通过调用<code class="language-plaintext highlighter-rouge">t1.interrupt()</code>从而通知<code class="language-plaintext highlighter-rouge">t1</code>线程中断，并等待<code class="language-plaintext highlighter-rouge">t1</code>。</p>

<p>1000ms：而此时<code class="language-plaintext highlighter-rouge">t1</code>线程正在等待<code class="language-plaintext highlighter-rouge">t2</code>线程，收到中断请求后，抛出异常，捕获异常后<code class="language-plaintext highlighter-rouge">t1</code>也对<code class="language-plaintext highlighter-rouge">t2</code>发出中断请求，并等待<code class="language-plaintext highlighter-rouge">t2</code>。</p>

<p>1000ms：<code class="language-plaintext highlighter-rouge">t2</code>大概率在休眠时收到中断请求，然后抛出异常，磨蹭10ms后才真正走人。</p>

<p>1001ms：而<code class="language-plaintext highlighter-rouge">main</code>线程在第一次请求<code class="language-plaintext highlighter-rouge">t1</code>中断后，间隔1ms，再次催促<code class="language-plaintext highlighter-rouge">t1</code>中断请求。</p>

<p>1001ms：而此时<code class="language-plaintext highlighter-rouge">t1</code>线程还在等待<code class="language-plaintext highlighter-rouge">t2</code>线程，收到中断请求后，不再等待<code class="language-plaintext highlighter-rouge">t2</code>，也没有继续通知<code class="language-plaintext highlighter-rouge">t2</code>,直接结束了运行。</p>

<p>1001ms：<code class="language-plaintext highlighter-rouge">main</code>线程已经得到<code class="language-plaintext highlighter-rouge">t1</code>线程执行完毕，结束了执行。</p>

<p>1010ms：<code class="language-plaintext highlighter-rouge">t2</code>磨蹭10ms后才真正走人。</p>

<hr />

<p>另一个常用的中断线程的方法是设置标志位。通常会用一个<code class="language-plaintext highlighter-rouge">running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code class="language-plaintext highlighter-rouge">HelloThread.running</code>置为<code class="language-plaintext highlighter-rouge">false</code>，就可以让线程结束。其实和<code class="language-plaintext highlighter-rouge">interrupt()</code>方法是一样的，只是<code class="language-plaintext highlighter-rouge">interrupted</code>字段也会被其他方法检测到状态，比如<code class="language-plaintext highlighter-rouge">join()</code>、<code class="language-plaintext highlighter-rouge">sleep()</code>。如果使用自定义的标志位表示中断线程，则其他方法不会响应。</p>

<p>错误写法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
    <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">running</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span> <span class="o">++;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程t1</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">t1</span><span class="o">.</span><span class="na">running</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span><span class="c1">// 通知t1，中断请求</span>
<span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等</span>
</code></pre></div></div>
<p>因为向上转型的原因，<code class="language-plaintext highlighter-rouge">Thread</code>不存在<code class="language-plaintext highlighter-rouge">running</code>这个字段，好的，我强转回去可以吗，也不行，因为是匿名类。把<code class="language-plaintext highlighter-rouge">Thread</code>改成<code class="language-plaintext highlighter-rouge">var</code>倒是可以，<code class="language-plaintext highlighter-rouge">var t1 = new Thread(){...}</code>，不过不建议。</p>

<p>同样的，如果是实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口传入<code class="language-plaintext highlighter-rouge">Thread</code>构造方法，<code class="language-plaintext highlighter-rouge">Thread</code>当然不知道你定义了<code class="language-plaintext highlighter-rouge">running</code>这个字段，因为<code class="language-plaintext highlighter-rouge">Runnable</code>接口只规定了你有<code class="language-plaintext highlighter-rouge">run()</code>方法。因此只能写正常继承的类了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>  <span class="o">{</span>
        <span class="no">T1</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T1</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程t1</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">running</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span><span class="c1">// 通知t1，中断请求</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">T1</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">running</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">n</span> <span class="o">++;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 hello!
end!
</code></pre></div></div>
<h2 id="volatile">volatile</h2>
<p>注意到<code class="language-plaintext highlighter-rouge">T1</code>的标志位<code class="language-plaintext highlighter-rouge">boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code class="language-plaintext highlighter-rouge">volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>

<p>为什么要对线程间共享的变量用关键字<code class="language-plaintext highlighter-rouge">volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，<strong>当线程访问变量时</strong>，它会先获取一个副本，并保存在自己的工作内存中。如果<strong>线程修改了变量的值</strong>，虚拟机会在<strong>某个时刻</strong>把修改后的值回写到主内存，但是，这个时间是<strong>不确定</strong>的！</p>

<pre><code class="language-ascii">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
</code></pre>
<p>这会导致如果一个线程更新了某个变量，另一个线程读取的值<strong>可能</strong>还是<strong>更新前</strong>的。例如，主内存的变量<code class="language-plaintext highlighter-rouge">a = true</code>，线程1对主线程的<code class="language-plaintext highlighter-rouge">a</code>执行<code class="language-plaintext highlighter-rouge">a = false</code>时，它在此刻仅仅是把变量<code class="language-plaintext highlighter-rouge">a</code>的副本变成了<code class="language-plaintext highlighter-rouge">false</code>，主内存的变量<code class="language-plaintext highlighter-rouge">a</code>还是<code class="language-plaintext highlighter-rouge">true</code>，在JVM把修改后的<code class="language-plaintext highlighter-rouge">a</code>回写到主内存之前，其他线程读取到的<code class="language-plaintext highlighter-rouge">a</code>的值仍然是<code class="language-plaintext highlighter-rouge">true</code>，这就造成了多线程之间共享的变量不一致。</p>

<p>而<code class="language-plaintext highlighter-rouge">volatile</code>关键字的目的是告诉虚拟机：</p>

<ul>
  <li>每次访问变量时，总是获取主内存的<strong>最新值</strong>；</li>
  <li>每次修改变量后，<strong>立刻回写</strong>到主内存。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">volatile</code>关键字解决的是可见性问题：当一个<strong>线程</strong>修改了某个<strong>共享变量</strong>的值，其他线程能够<strong>立刻看到</strong>修改后的值。确保多个线程能够正确地读取和修改该变量。</p>

<p>如果去掉<code class="language-plaintext highlighter-rouge">volatile</code>关键字，运行上述程序，发现效果和带<code class="language-plaintext highlighter-rouge">volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p>

<p><strong>ABA问题</strong></p>

<p><code class="language-plaintext highlighter-rouge">volatile</code>关键字不能解决ABA问题，但不使用<code class="language-plaintext highlighter-rouge">volatile</code>关键字更会导致ABA问题。  ABA问题是指在多线程环境下，一个值从A变成了B，然后又变回A。</p>

<p>例如，线程1读取一个<code class="language-plaintext highlighter-rouge">volatile</code>变量的值为A，然后线程2将其修改为B，最后线程2又将其修改回A，这个过程中线程1可能并不知道变量的值曾经变成过B，因为<code class="language-plaintext highlighter-rouge">volatile</code>只保证了可见性，并没有解决ABA问题。</p>

<p>要解决ABA问题，可以使用<code class="language-plaintext highlighter-rouge">AtomicStampedReference</code>类或<code class="language-plaintext highlighter-rouge">AtomicMarkableReference</code>类，它们可以在引用的同时记录一个标记（stamp或mark），当引用发生变化时，标记也会相应地发生变化，从而避免了ABA问题。</p>

<h2 id="守护线程">守护线程</h2>
<p>Java程序入口就是由JVM启动<code class="language-plaintext highlighter-rouge">main</code>线程，<code class="language-plaintext highlighter-rouge">main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。  只要有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>

<p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>
<p>如果这个线程不结束，JVM进程就无法结束。<strong>这类线程</strong>经常没有负责人来负责结束它们。但是，当<strong>其他线程</strong>结束时，JVM进程又必须要结束。</p>

<p>使用守护线程（Daemon Thread）是一个好办法，守护线程是指<strong>为其他线程提供服务的线程</strong>。在调用<code class="language-plaintext highlighter-rouge">start()</code>方法前，调用<code class="language-plaintext highlighter-rouge">setDaemon(true)</code>就能把该线程标记为守护线程。</p>

<p>在JVM中，所有<strong>非守护线程</strong>都执行完毕后，无论有没有守护线程，虚拟机<strong>都会</strong>自动退出。因为所有的非守护线程都结束了，守护线程也就没有存在的必要了。</p>

<p>因此守护线程<strong>不能持有</strong>任何需要关闭的资源，例如打开文件等，因为<strong>虚拟机退出</strong>时，可不管守护线程在干什么，守护线程<strong>没有任何机会来关闭文件</strong>，这会导致数据丢失。</p>

<hr />

<p>父子线程只是谁创建了谁的关系，并没有先后或从属之分，只要创建并运行后，这个所谓的子线程其实和父线程是相互独立的，它的生命周期不受父线程的生命周期影响。</p>

<p>如果想要实现父线程结束时，子线程也结束的效果，可以在子线程中判断父线程是否存活。 <code class="language-plaintext highlighter-rouge">while (fatherThread.isAlive())</code>，示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">fatherThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span> <span class="c1">// 获取当前线程，即对于t的父线程</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fatherThread</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main还活着"</span> <span class="o">+</span> <span class="n">n</span><span class="o">++);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main已关闭了"</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span><span class="c1">//设置守护线程，JVM无视其运行状态</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已关闭"</span><span class="o">);</span>
</code></pre></div></div>
<p>守护进程会在父线程结束后结束。</p>

<p>可以通过<code class="language-plaintext highlighter-rouge">System.exit(0);</code>显示的控制JVM关闭。如果在最后一行调用<code class="language-plaintext highlighter-rouge">System.exit(0);</code>，<code class="language-plaintext highlighter-rouge">t</code>线程就算不是守护线程JVM也会立即终止。</p>

<h2 id="线程同步">线程同步</h2>
<p><strong>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定</strong>。因此，任何一个线程都有可能在<strong>任何指令处被操作系统暂停</strong>，然后在某个时间段后继续执行。</p>

<p>这个时候，有个单线程模型下不存在的问题就来了：如果<strong>多个线程同时读写共享变量</strong>，会出现<strong>数据不一致</strong>的问题。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>上面的代码很简单，两个线程同时对一个<code class="language-plaintext highlighter-rouge">int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p>

<p>这是因为对变量进行读取和写入时，如果想得到预期的结果，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>

<p>对于语句：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</code></pre></div></div>
<p>看上去是一行语句，实际上对应了3条指令：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ILOAD</span>
<span class="no">IADD</span>
<span class="no">ISTORE</span>
</code></pre></div></div>
<p>假设<code class="language-plaintext highlighter-rouge">n</code>的值是<code class="language-plaintext highlighter-rouge">100</code>，如果两个线程同时执行<code class="language-plaintext highlighter-rouge">n = n + 1</code>，得到的结果很可能不是<code class="language-plaintext highlighter-rouge">102</code>，而是<code class="language-plaintext highlighter-rouge">101</code>，原因在于：</p>
<pre><code class="language-ascii">┌───────┐    ┌───────┐
│Thread1│    │Thread2│
└───┬───┘    └───┬───┘
    │            │
    │ILOAD (100) │
    │            │ILOAD (100)
    │            │IADD
    │            │ISTORE (101)
    │IADD        │
    │ISTORE (101)│
    ▼            ▼
</code></pre>
<p>如果线程1在执行<code class="language-plaintext highlighter-rouge">ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code class="language-plaintext highlighter-rouge">ILOAD</code>后获取的值仍然是<code class="language-plaintext highlighter-rouge">100</code>，最终结果被两个线程的<code class="language-plaintext highlighter-rouge">ISTORE</code>写入后变成了<code class="language-plaintext highlighter-rouge">101</code>，而不是期待的<code class="language-plaintext highlighter-rouge">102</code>。</p>

<p>这说明多线程模型下，如果要<strong>保证逻辑正确</strong>，则对<strong>共享变量</strong>进行读写时，必须保证<strong>一组指令</strong>以<strong>原子</strong>方式执行：即某一个线程执行这组指令时，其他想执行这组指令的线程必须等待：</p>

<pre><code class="language-ascii">┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
</code></pre>
<p>通过加锁和解锁的操作，就能保证这3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。</p>

<p>即使在执行期线程<strong>被操作系统中断</strong>执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。</p>

<p>这种加锁和解锁之间的代码块称之为<strong>临界区</strong>（Critical Section），任何时候临界区最多只有一个线程能执行。</p>

<h3 id="synchronized">synchronized</h3>
<p>保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字对一个对象进行加锁，<code class="language-plaintext highlighter-rouge">synchronized</code>保证了<strong>代码块</strong>在任意时刻最多只有一个线程能执行。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>修改后：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>注意到代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">synchronized</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 获取锁</span>
    <span class="o">...</span>
<span class="o">}</span> <span class="c1">// 释放锁</span>
</code></pre></div></div>
<p>它表示用<code class="language-plaintext highlighter-rouge">Main.lock</code>实例作为锁，即<code class="language-plaintext highlighter-rouge">new Object();</code>这个实例，因为是静态的，所以两个线程通过获得<code class="language-plaintext highlighter-rouge">Main.lock</code>的是同一个实例。</p>

<p>两个线程在执行各自的<code class="language-plaintext highlighter-rouge">synchronized(Main.lock) { ... }</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code class="language-plaintext highlighter-rouge">synchronized</code>语句块结束会自动释放锁。这样一来，对<code class="language-plaintext highlighter-rouge">Main.count</code>变量进行读写就不可能同时进行。</p>

<hr />

<p>使用<code class="language-plaintext highlighter-rouge">synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了<strong>性能下降</strong>。因为<code class="language-plaintext highlighter-rouge">synchronized</code>代码块无法并发执行，且加锁和解锁需要消耗一定的时间，所以，<code class="language-plaintext highlighter-rouge">synchronized</code>会降低程序的执行效率。</p>

<p>如何使用<code class="language-plaintext highlighter-rouge">synchronized</code>：</p>

<ol>
  <li>找出修改<strong>共享变量</strong>的线程代码块；</li>
  <li>选择一个<strong>共享实例</strong>作为锁；</li>
  <li>使用<code class="language-plaintext highlighter-rouge">synchronized(lockObject) { ... }</code>。</li>
</ol>

<p>在使用<code class="language-plaintext highlighter-rouge">synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code class="language-plaintext highlighter-rouge">synchronized</code>结束处正确释放锁。</p>

<hr />

<p><strong>不需要锁的原子操作，JVM规范定义了几种原子操作</strong>：</p>
<ul>
  <li>基本类型（<code class="language-plaintext highlighter-rouge">long</code>和<code class="language-plaintext highlighter-rouge">double</code><strong>除外</strong>）<strong>赋值</strong>，例如：<code class="language-plaintext highlighter-rouge">int n = m</code>；</li>
  <li>引用类型<strong>赋值</strong>，例如：<code class="language-plaintext highlighter-rouge">List&lt;String&gt; list = anotherList</code>。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">long</code>和<code class="language-plaintext highlighter-rouge">double</code>是64位数据，JVM<strong>没有明确规定</strong>64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code class="language-plaintext highlighter-rouge">long</code>和<code class="language-plaintext highlighter-rouge">double</code>的赋值作为原子操作实现的。</p>

<p>单条原子操作不需要锁，如果是多条原子操作，则需要锁。多线程连续读写多个变量时，同步的目的是为了<strong>保证程序逻辑正确</strong>。</p>

<p>不但写需要同步，读也需要同步：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>假定当前坐标是<code class="language-plaintext highlighter-rouge">(100, 200)</code>，那么当设置新坐标为<code class="language-plaintext highlighter-rouge">(110, 220)</code>时，上述未同步的多线程<code class="language-plaintext highlighter-rouge">get()</code><strong>读到</strong>的值可能有：</p>
<ul>
  <li>(100, 200)：x，y更新前；</li>
  <li>(110, 200)：x更新后，y更新前；</li>
  <li>(110, 220)：x，y更新后。</li>
</ul>

<p>如果读取到<code class="language-plaintext highlighter-rouge">(110, 200)</code>，即读到了更新后的x，更新前的y，那么可能会造成程序的逻辑错误，无法保证读取的<strong>多个变量状态保持一致</strong>。</p>

<p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">this.ps = ps;</code>是原子操作。而<code class="language-plaintext highlighter-rouge">int[] ps = new int[] { x, y };</code>不是，不过没有关系，因为<code class="language-plaintext highlighter-rouge">x</code>与<code class="language-plaintext highlighter-rouge">y</code>不是共享变量，它们的值只在当前线程中可见，所以在这种情况下，不需要担心原子性问题。重要的是<code class="language-plaintext highlighter-rouge">ps</code>，原子操作保证了<code class="language-plaintext highlighter-rouge">ps</code><strong>要么是赋值前的值，要么是赋值后的值</strong>。</p>

<p>不过<code class="language-plaintext highlighter-rouge">get()</code>读取还是有可能存在<code class="language-plaintext highlighter-rouge">x</code>更新后，<code class="language-plaintext highlighter-rouge">y</code>更新前的情况，这个问题并没有解决。</p>

<hr />

<h3 id="测试同步问题">测试同步问题</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 超出出后停止</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="o">;</span><span class="n">x</span><span class="o">++,</span><span class="n">y</span><span class="o">++){</span>
                <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 线程thread执行完后关闭</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">isAlive</span><span class="o">()){</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span><span class="o">;</span>
                <span class="n">ints</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]-</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">]!=-</span><span class="mi">1</span><span class="o">){</span>
                    <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"x="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">",y="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringIntegerEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="n">count</span><span class="o">+=</span><span class="n">value</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">",count:"</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一共"</span><span class="o">+</span><span class="n">count</span><span class="o">+</span><span class="s">"条同步问题"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台提示有同步问题，<strong>1000条左右的量级</strong>。</p>

<p>那么把<code class="language-plaintext highlighter-rouge">set</code>，<strong>加锁</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台提示有同步问题，<strong>100w条左右的量级</strong>，为什么同步问题更多了呢？因为加锁后性能变低了。</p>

<p>那么把<code class="language-plaintext highlighter-rouge">get</code>也<strong>加相同锁</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>肯定没问题，一次只能有一个线程进入<code class="language-plaintext highlighter-rouge">synchronized (this) {}</code>,因此<code class="language-plaintext highlighter-rouge">set</code>和<code class="language-plaintext highlighter-rouge">get</code>互斥了，这时就不存在同时访问的问题了。</p>

<p>那么把<code class="language-plaintext highlighter-rouge">get</code>改成<strong>不同锁</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">new Object()</code>这样的写法让<code class="language-plaintext highlighter-rouge">synchronized</code>完全失去了作用，控制台提示有同步问题，<strong>100w条左右的量级</strong></p>

<p>那么把<code class="language-plaintext highlighter-rouge">Point</code>的<code class="language-plaintext highlighter-rouge">set</code>改写成线程安全的形式：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>但<code class="language-plaintext highlighter-rouge">get</code>还有线程安全问题，控制台提示有同步问题，<strong>大概100条左右的量级</strong>。</p>

<p>那么把<code class="language-plaintext highlighter-rouge">get</code>改写成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
    <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>当然有问题，不是原子性的语句，控制台提示有同步问题，<strong>大概100条左右的量级</strong>。</p>

<p>那么都简化为一条语句：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
<span class="o">}</span>
</code></pre></div></div>
<p>还是一样的问题，控制台提示有同步问题，<strong>大概100条作用的量级</strong>。</p>

<p>那么把<code class="language-plaintext highlighter-rouge">get</code>改成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">return</span> <span class="n">ps</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>问题解决</strong>，一共0条同步问题。</p>

<hr />

<p>胡乱分析：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div>
<p>对于 <code class="language-plaintext highlighter-rouge">this.ps = new int[] { x, y };</code>来说，它实际上解决的是同时将<code class="language-plaintext highlighter-rouge">x</code>，<code class="language-plaintext highlighter-rouge">y</code>赋值到<code class="language-plaintext highlighter-rouge">ps</code>的问题，因为对于引用类型变量来说赋值是原子的，所以问题解决了。但是获取<code class="language-plaintext highlighter-rouge">x</code>，<code class="language-plaintext highlighter-rouge">y</code>的值可不是原子的，为什么这里没有问题呢？因为<code class="language-plaintext highlighter-rouge">x</code>与<code class="language-plaintext highlighter-rouge">y</code>都是局部变量，不会有变量共享问题。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
<span class="o">}</span>
</code></pre></div></div>
<p>而对于<code class="language-plaintext highlighter-rouge">get</code>来说，<code class="language-plaintext highlighter-rouge">ps[0]</code>,<code class="language-plaintext highlighter-rouge">ps[1]</code>有变量共享问题，因为<code class="language-plaintext highlighter-rouge">ps</code>是共享变量。</p>

<p>总的来说，在这段测试代码中，只要<code class="language-plaintext highlighter-rouge">set</code>和<code class="language-plaintext highlighter-rouge">get</code>方法有一个有同步问题就会导致测试代码出问题。</p>

<hr />

<p><strong>不可变对象无需同步</strong></p>

<p>如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Data</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">names</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">names</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">set()</code>方法内部创建了一个不可变<code class="language-plaintext highlighter-rouge">List</code>，这个<code class="language-plaintext highlighter-rouge">List</code>包含的对象也是不可变对象<code class="language-plaintext highlighter-rouge">String</code>，因此，整个<code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p>

<hr />

<p>分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Status</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">names</span> <span class="o">=</span> <span class="n">ns</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">StatusRecord</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StatusRecord</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">names</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>如果有A、B两个线程，同时执行是指：</p>
<ul>
  <li>可能同时执行set()；</li>
  <li>可能同时执行get()；</li>
  <li>可能A执行set()，同时B执行get()。</li>
</ul>

<p>对象的成员变量<code class="language-plaintext highlighter-rouge">names</code>、<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量<code class="language-plaintext highlighter-rouge">step</code>也仅在<code class="language-plaintext highlighter-rouge">set()</code>方法内部使用，因此每个线程同时执行<code class="language-plaintext highlighter-rouge">set</code>时都有一份独立的<code class="language-plaintext highlighter-rouge">step</code>存储在线程的栈上，互不影响，但是局部变量<code class="language-plaintext highlighter-rouge">ns</code>虽然每个线程也各有一份，但<strong>后续赋值后</strong>对其他线程就变成可见了。对<code class="language-plaintext highlighter-rouge">set()</code>方法同步时，如果要最小化<code class="language-plaintext highlighter-rouge">synchronized</code>代码块，可以改写如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 局部变量其他线程不可见:</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">names</span> <span class="o">=</span> <span class="n">ns</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p>

<hr />

<p>例子：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>
        <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">110</span><span class="o">,</span> <span class="mi">220</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">point</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">//停1毫秒</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">point</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">s</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Point{x=\{x}, y=\{y}\{'}'}"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>最后一条<code class="language-plaintext highlighter-rouge">System.out.println(point);</code>会等待<code class="language-plaintext highlighter-rouge">point.set(110, 220);</code>执行完释放锁后打印<code class="language-plaintext highlighter-rouge">Point{x=110, y=220}</code>，当然，如果1ms过去了<code class="language-plaintext highlighter-rouge">t1</code>线程还没执行<code class="language-plaintext highlighter-rouge">point.set()</code>拿到锁，则会直接打印<code class="language-plaintext highlighter-rouge">Point{x=110, y=200}</code>。</p>

<p>如果去掉<code class="language-plaintext highlighter-rouge">toString()</code>的锁，则最后一条<code class="language-plaintext highlighter-rouge">System.out.println(point);</code>打印的内容是不可确定的。</p>

<p>可能是<code class="language-plaintext highlighter-rouge">Point{x=100, y=200}</code>（<code class="language-plaintext highlighter-rouge">set</code>执行开始的时间大于1ms）。</p>

<p>可能是<code class="language-plaintext highlighter-rouge">Point{x=110, y=200}</code>（<code class="language-plaintext highlighter-rouge">set</code>执行开始的时间小于1ms，执行到一半，在计时等待）。</p>

<p>不太可能是<code class="language-plaintext highlighter-rouge">Point{x=110, y=220}</code>（<code class="language-plaintext highlighter-rouge">set</code>执行完了，<code class="language-plaintext highlighter-rouge">println</code>才执行，也就是说受到神秘力量干涉，<code class="language-plaintext highlighter-rouge">println</code>延迟了至少999ms才执行）。</p>

<hr />

<h3 id="volatile与synchronized">volatile与synchronized</h3>

<p>程安全问题主要包括原子性问题、有序性问题、可见性问题。  为了应对这些问题，Java构建了内存模型JMM（Java Memory Model），并提供了一些解决方案：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">volatile</code>关键字解决可见性和有序性问题：<code class="language-plaintext highlighter-rouge">volatile</code>关键字用于修饰变量，保证了每个线程读到的数据是最新值，并且禁止了指令重排序。但是，<code class="language-plaintext highlighter-rouge">volatile</code>不能保证<strong>多个线程对同一个变量的操作</strong>的原子性。</li>
  <li><code class="language-plaintext highlighter-rouge">synchronized</code>关键字解决原子性、可见性和有序性问题：<code class="language-plaintext highlighter-rouge">synchronized</code>关键字用于创建同步代码块或同步方法，确保同步代码块内的代码在<strong>同一时刻</strong>只能有一个线程访问，从而保证了线程安全。此外，<code class="language-plaintext highlighter-rouge">synchronized</code>关键字还具有内存屏障的功能，解决可见性和有序性问题。</li>
  <li><code class="language-plaintext highlighter-rouge">CAS</code>（Compare and Swap）解决原子性问题：<code class="language-plaintext highlighter-rouge">CAS</code>是一种无锁算法，通过比较内存中的值和预期值来决定是否更新内存中的值。<code class="language-plaintext highlighter-rouge">CAS</code>操作是原子的，可以解决原子性问题。在Java中，<code class="language-plaintext highlighter-rouge">AtomicInteger</code>、<code class="language-plaintext highlighter-rouge">AtomicLong</code>等原子类使用了<code class="language-plaintext highlighter-rouge">CAS</code>操作来实现线程安全的原子操作。</li>
</ol>

<p>原子性问题解决思路本质是<strong>互斥</strong>。</p>

<h3 id="内存屏障">内存屏障</h3>

<p>内存屏障（Memory Barrier），也称为内存栅栏或内存栅障，是一种硬件或软件的屏障，用于控制特定指令序列的执行顺序以及对内存访问的顺序和方式。内存屏障在多核处理器和多线程环境下发挥重要作用，确保线程间的内存可见性和有序性，从而保证并发程序的正确性。</p>

<p>内存屏障可以分为以下几种类型：</p>

<ol>
  <li>
    <p><strong>读屏障（Read Barrier）</strong>：读屏障用于确保在读取操作之前，所有之前的读取和写入操作都已经完成。它可以防止处理器乱序执行指令或缓存数据不一致的情况。</p>
  </li>
  <li>
    <p><strong>写屏障（Write Barrier）</strong>：写屏障用于确保在写入操作之后，所有之前的写入和读取操作都已经完成。它可以防止处理器将写入操作提前执行，保证写入的值对其他线程可见。</p>
  </li>
  <li>
    <p><strong>全屏障（Full Barrier）</strong>：全屏障用于同时提供读屏障和写屏障的功能，即在执行全屏障之前，所有之前的读取和写入操作都已经完成；在执行全屏障之后，所有之前的写入和读取操作都已经完成。</p>
  </li>
</ol>

<p>内存屏障在Java中的应用：</p>

<ul>
  <li>在<code class="language-plaintext highlighter-rouge">volatile</code>关键字的实现中，编译器会在读取和写入<code class="language-plaintext highlighter-rouge">volatile</code>变量时插入对应的读屏障和写屏障，保证了<code class="language-plaintext highlighter-rouge">volatile</code>变量的可见性和有序性。</li>
  <li>在<code class="language-plaintext highlighter-rouge">synchronized</code>关键字的实现中，<code class="language-plaintext highlighter-rouge">synchronized</code>块的进入和退出分别对应了全屏障的插入，<strong>保证了同步代码块内的指令按照预期顺序执行，同时也保证了线程间的内存可见性。</strong></li>
</ul>

<p>内存屏障是确保多线程程序正确性的重要机制，它能够控制指令的执行顺序和内存访问的顺序，保证了线程间的通信和协调。</p>

<h3 id="同步方法">同步方法</h3>
<p>使用<code class="language-plaintext highlighter-rouge">synchronized</code>的时候，锁住的是哪个对象非常重要。让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code class="language-plaintext highlighter-rouge">synchronized</code>逻辑封装起来。比如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dec</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这样一来，线程调用<code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">dec()</code>方法时，不必关心同步逻辑，因为<code class="language-plaintext highlighter-rouge">synchronized</code>代码块在<code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">dec()</code>方法内部。并且<code class="language-plaintext highlighter-rouge">synchronized</code>锁住的对象是<code class="language-plaintext highlighter-rouge">this</code>，即<strong>当前实例</strong>，这又使得创建<strong>多个</strong><code class="language-plaintext highlighter-rouge">Counter</code>实例的时候，它们之间<strong>互不影响</strong>，可以并发执行。</p>

<hr />

<p>如果一个类被设计为允许多线程正确访问，这个类就是“线程安全”的（thread-safe），上面的<code class="language-plaintext highlighter-rouge">Counter</code>类就是线程安全的。Java标准库的<code class="language-plaintext highlighter-rouge">java.lang.StringBuffer</code>也是线程安全的。</p>

<p>还有一些不变类，例如<code class="language-plaintext highlighter-rouge">String</code>，<code class="language-plaintext highlighter-rouge">Integer</code>，<code class="language-plaintext highlighter-rouge">LocalDate</code>，它们的所有成员变量都是<code class="language-plaintext highlighter-rouge">final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>

<p>最后，类似<code class="language-plaintext highlighter-rouge">Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>

<p>除了上述几种少数情况，大部分类，例如<code class="language-plaintext highlighter-rouge">ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code class="language-plaintext highlighter-rouge">ArrayList</code>是可以安全地在线程间共享的。</p>

<p><strong>没有特殊说明时，一个类默认是非线程安全的</strong>。</p>

<hr />

<p>当锁住的是<code class="language-plaintext highlighter-rouge">this</code>实例时，实际上可以用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字修饰这个<strong>方法</strong>。它表示整个方法都用<code class="language-plaintext highlighter-rouge">this</code>实例加锁。</p>

<p>而对于<code class="language-plaintext highlighter-rouge">static</code>方法，是没有<code class="language-plaintext highlighter-rouge">this</code>实例的，因为<code class="language-plaintext highlighter-rouge">static</code>方法是针对类而不是实例。但是任何一个类都有一个由JVM自动创建的<code class="language-plaintext highlighter-rouge">Class</code>实例，因此，对<code class="language-plaintext highlighter-rouge">static</code>方法添加<code class="language-plaintext highlighter-rouge">synchronized</code>，锁住的是该类的<code class="language-plaintext highlighter-rouge">Class</code>实例。即类似：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>如果在<strong>方法</strong>上使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，则表示整个方法都会被加锁，只有获取到锁的线程才能执行该方法。其他线程在获取到锁之前会被阻塞，直到锁被释放后，开始竞争锁。这样确保了在同一时间只有一个线程可以进入该方法的代码块执行。</p>

<p>如果对相同类的两个方法<strong>同时</strong>使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，那么这两个方法将会使用<strong>同一把锁</strong>，即<code class="language-plaintext highlighter-rouge">this</code>。这种情况下，如果一个线程已经获取了锁在执行其中一个方法，那其他线程就不能同时执行这两个方法中的任意一个。</p>

<p>如果希望两个方法<strong>不使用同一把锁</strong>，则<strong>不能在方法上</strong>使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字。</p>

<p>对于单条赋值语句：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>不需要同步，因为读取一个 <code class="language-plaintext highlighter-rouge">int</code> 变量是原子操作，不会出现线程安全问题。<br />
但是如果是两条赋值语句：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">Pair</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">get</code>方法返回一个包含两个<code class="language-plaintext highlighter-rouge">int</code>值的对象<code class="language-plaintext highlighter-rouge">Pair</code>。如果在调用<code class="language-plaintext highlighter-rouge">get</code>方法的过程中，另一个线程修改了<code class="language-plaintext highlighter-rouge">first</code>或<code class="language-plaintext highlighter-rouge">last</code>的值，就可能导致返回的<code class="language-plaintext highlighter-rouge">Pair</code>对象中的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>不是<strong>原子性地对应的</strong>。</p>

<p>为了确保返回的<code class="language-plaintext highlighter-rouge">Pair</code>对象中的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>是<strong>原子性地对应的</strong>，需要在<code class="language-plaintext highlighter-rouge">get</code>方法和修改<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>值的<code class="language-plaintext highlighter-rouge">set</code>方法内部使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字。</p>

<p>这样既确保在同一时刻只有一个线程能够修改或者获取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的值，保证了获取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的过程是原子的。</p>

<p>如果只在<code class="language-plaintext highlighter-rouge">get</code>方法内加锁，只能保证在<strong>同一时刻</strong>只有一个线程能够<strong>通过<code class="language-plaintext highlighter-rouge">get</code>方法</strong>获取到<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的值，我们不需要这个特性，这个特性反而是负面的。还不能保证获取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的过程是原子的。</p>

<p>原子性指的是一个操作是不可分割的整体，要么全部执行成功，要么全部不执行，不会出现中间状态。在这里，原子性是指保证在读取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>时，它们的值是一致的，不存在读到<code class="language-plaintext highlighter-rouge">first</code>更新后、<code class="language-plaintext highlighter-rouge">last</code>更新前的情况。</p>

<p>使用<code class="language-plaintext highlighter-rouge">synchronized</code>确保了这种一致性，但并没有保证是<strong>同时获取了</strong>这两个值，因此把其他的对<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>写入操作的也锁了才能保证一致性。</p>

<p>如果不需要保证<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的<strong>一致性</strong>，即<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>没有什么关系，那么不需要对这两个变量进行同步操作。同步的目的是为了<strong>保证程序逻辑正确</strong>。</p>

<h2 id="死锁">死锁</h2>

<p>Java的线程锁是可重入的锁。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dec</span><span class="o">(-</span><span class="n">n</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">dec</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>一旦线程执行到<code class="language-plaintext highlighter-rouge">add()</code>方法内部，说明它已经获取了当前实例的<code class="language-plaintext highlighter-rouge">this</code>锁。如果传入的<code class="language-plaintext highlighter-rouge">n &lt; 0</code>，将在<code class="language-plaintext highlighter-rouge">add()</code>方法内部调用<code class="language-plaintext highlighter-rouge">dec()</code>方法。由于<code class="language-plaintext highlighter-rouge">dec()</code>方法也需要获取<code class="language-plaintext highlighter-rouge">this</code>锁，那么对同一个线程，能否在获取到锁以后继续获取同一个锁？</p>

<p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p>

<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code class="language-plaintext highlighter-rouge">synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>

<p><strong>死锁</strong></p>

<p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="n">lockA</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 获得lockA的锁</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">+=</span> <span class="n">m</span><span class="o">;</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">lockB</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 获得lockB的锁</span>
            <span class="k">this</span><span class="o">.</span><span class="na">another</span> <span class="o">+=</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span> <span class="c1">// 释放lockB的锁</span>
    <span class="o">}</span> <span class="c1">// 释放lockA的锁</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">dec</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="n">lockB</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 获得lockB的锁</span>
        <span class="k">this</span><span class="o">.</span><span class="na">another</span> <span class="o">-=</span> <span class="n">m</span><span class="o">;</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="n">lockA</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 获得lockA的锁</span>
            <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">-=</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span> <span class="c1">// 释放lockA的锁</span>
    <span class="o">}</span> <span class="c1">// 释放lockB的锁</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在获取多个锁的时候，不同线程获取多个不同对象的锁<strong>可能</strong>导致死锁。对于上述代码，线程1和线程2如果分别执行<code class="language-plaintext highlighter-rouge">add()</code>和<code class="language-plaintext highlighter-rouge">dec()</code>方法时：</p>
<ul>
  <li>线程1：进入<code class="language-plaintext highlighter-rouge">add()</code>，获得<code class="language-plaintext highlighter-rouge">lockA</code>；</li>
  <li>线程2：进入<code class="language-plaintext highlighter-rouge">dec()</code>，获得<code class="language-plaintext highlighter-rouge">lockB</code>。</li>
</ul>

<p>随后：</p>
<ul>
  <li>线程1：准备获得<code class="language-plaintext highlighter-rouge">lockB</code>，失败，等待锁释放中；</li>
  <li>线程2：准备获得<code class="language-plaintext highlighter-rouge">lockA</code>，失败，等待锁释放中。</li>
</ul>

<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>

<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。如何避免死锁呢？答案是：线程获取锁的顺序要一致。<strong>所有</strong>使用一组相同的锁的<strong>线程</strong>，获取锁的顺序要保持一致。</p>

<p>避免死锁的一个有效策略是保持线程获取锁的顺序一致。这样可以避免循环等待条件，从而减少死锁的发生。还有其他一些避免死锁的策略，比如尽量减少锁的持有时间、使用超时机制来获取锁、以及使用锁的层次结构等。</p>

<p>死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种僵局，若无外力作用，这些线程都将无法继续执行下去。死锁发生必须同时满足以下四个条件，称为死锁的必要条件：</p>

<ol>
  <li><strong>互斥条件（Mutual Exclusion）</strong>：一个资源每次只能被一个线程使用，即在一段时间内某资源只能被一个线程占用。如果此时有其他线程请求该资源，请求线程只能等待。</li>
  <li><strong>请求与保持条件（Hold and Wait）</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
  <li><strong>不可抢占条件（No Preemption）</strong>：已获得的资源在未使用完之前，不能被强行剥夺，只能由持有资源的线程自行释放。</li>
  <li><strong>循环等待条件（Circular Wait）</strong>：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>

<p>当以上四个条件同时满足时，就会导致死锁的发生。为了避免死锁，可以采用破坏这些条件的方法，如破坏循环等待条件、引入超时机制等。</p>
<h2 id="wait和notify">wait和notify</h2>
<p>在Java程序中，<code class="language-plaintext highlighter-rouge">synchronized</code>解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用<code class="language-plaintext highlighter-rouge">synchronized</code>加锁：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addTask</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">String</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>但是<code class="language-plaintext highlighter-rouge">synchronized</code>并没有解决多线程协调的问题。</p>

<p><code class="language-plaintext highlighter-rouge">getTask()</code>的<code class="language-plaintext highlighter-rouge">while()</code>循环永远不会退出，因为锁没有释放，其他线程根本无法调用<code class="language-plaintext highlighter-rouge">addTask()</code>。实际上代码应该实现以下效果：</p>

<ul>
  <li>线程1可以调用<code class="language-plaintext highlighter-rouge">addTask()</code>不断往队列中添加任务；</li>
  <li>线程2可以调用<code class="language-plaintext highlighter-rouge">getTask()</code>从队列中获取任务。如果队列为空，则<code class="language-plaintext highlighter-rouge">getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li>
</ul>

<p>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>

<p>可以通过调用<code class="language-plaintext highlighter-rouge">wait()</code>方法让线程进入等待状态，调用<code class="language-plaintext highlighter-rouge">wait()</code>方法会一直等待到被其他线程唤醒后才会返回。必须在<code class="language-plaintext highlighter-rouge">synchronized</code>块中才能调用<code class="language-plaintext highlighter-rouge">wait()</code>方法，也只能在锁对象上调用<code class="language-plaintext highlighter-rouge">wait()</code>方法，因为<code class="language-plaintext highlighter-rouge">wait()</code>方法调用时，会<strong>释放线程获得的锁</strong>，<code class="language-plaintext highlighter-rouge">wait()</code>方法返回后，线程又会重新<strong>试图获得之前放弃的锁</strong>。</p>

<p>如何让等待的线程被重新唤醒，然后从<code class="language-plaintext highlighter-rouge">wait()</code>方法返回？答案是在<strong>相同</strong>的锁对象上调用<code class="language-plaintext highlighter-rouge">notify()</code>方法。那么代码修改如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TaskQueue</span><span class="o">();</span>
        <span class="c1">//启动5个获取任务</span>
        <span class="kt">var</span> <span class="n">ts</span> <span class="o">=</span> <span class="n">getThreads</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
        <span class="c1">//添加10个任务，每隔100ms</span>
        <span class="kt">var</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"添加任务: "</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
                <span class="n">q</span><span class="o">.</span><span class="na">addTask</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
                <span class="k">try</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="c1">//中断</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">t</span> <span class="o">:</span> <span class="n">ts</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Thread</span><span class="o">&gt;</span> <span class="nf">getThreads</span><span class="o">(</span><span class="nc">TaskQueue</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">var</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Thread</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">getTask</span><span class="o">();</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"，线程："</span><span class="o">+</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()+</span><span class="s">"，执行任务: "</span> <span class="o">+</span> <span class="n">s</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addTask</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">String</span> <span class="nf">getTask</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用<code class="language-plaintext highlighter-rouge">notifyAll()</code>会唤醒<strong>所有</strong>等待该锁的线程，而<code class="language-plaintext highlighter-rouge">notify()</code>只会唤醒其中<strong>一个</strong>线程。在使用<code class="language-plaintext highlighter-rouge">notify()</code>时，如果唤醒的线程不是所期望的线程，那么其他线程可能会一直等待下去，造成资源的浪费和程序性能的下降。因此，通常情况下推荐使用<code class="language-plaintext highlighter-rouge">notifyAll()</code>来确保所有等待线程都有机会被唤醒。</p>

<p><code class="language-plaintext highlighter-rouge">wait()</code>方法返回时需要重新获得<code class="language-plaintext highlighter-rouge">this</code>锁。假设有3个线程被唤醒，唤醒后，首先等待执行<code class="language-plaintext highlighter-rouge">addTask()</code>的线程结束此方法后，才能释放<code class="language-plaintext highlighter-rouge">this</code>锁，随后，这3个线程中只能有一个获取到<code class="language-plaintext highlighter-rouge">this</code>锁，<strong>剩下两个将等待锁释放后继续竞争锁</strong>，竞争成功后开始运行。</p>

<p>如果在<code class="language-plaintext highlighter-rouge">getTask()</code>不是使用<code class="language-plaintext highlighter-rouge">while</code>而是使用<code class="language-plaintext highlighter-rouge">if</code>，则剩下的两个将依次得到锁后直接执行<code class="language-plaintext highlighter-rouge">queue.remove();</code>，而此时队列中已经没有东西了，则会抛出异常，终止此线程。</p>

<p>是<code class="language-plaintext highlighter-rouge">while</code>的话,则剩下的两个依次得到锁后后会再次判断<code class="language-plaintext highlighter-rouge">queue.isEmpty()</code>，如果是则会继续等待。</p>

<p>当然，如果改用<code class="language-plaintext highlighter-rouge">notify()</code>+<code class="language-plaintext highlighter-rouge">if</code>则不会出现问题,因为一次只唤醒一个线程:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">addTask</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">String</span> <span class="nf">getTask</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>方法：</strong></p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">wait()</code>：在锁对象上等待，直到其他线程调用该对象的<code class="language-plaintext highlighter-rouge">notify()</code>或<code class="language-plaintext highlighter-rouge">notifyAll()</code>方法唤醒该线程。</li>
  <li><code class="language-plaintext highlighter-rouge">void wait(long timeout)</code>：同<code class="language-plaintext highlighter-rouge">wait()</code>，但如果在指定时间内未收到通知，则当前线程会自动唤醒。</li>
  <li><code class="language-plaintext highlighter-rouge">void wait(long timeout, int nanos)</code>：类似于<code class="language-plaintext highlighter-rouge">wait(long timeout)</code>方法，但还可以指定纳秒级别的超时时间。</li>
  <li><code class="language-plaintext highlighter-rouge">notify()</code>：唤醒在锁对象上等待的单个线程。</li>
  <li><code class="language-plaintext highlighter-rouge">notifyAll()</code>：唤醒在锁对象上等待的所有线程。</li>
</ol>

<h2 id="reentrantlock">ReentrantLock</h2>
<p>从<strong>Java 5</strong>开始，引入了一个高级的处理并发的<code class="language-plaintext highlighter-rouge">java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>

<p>Java提供了<code class="language-plaintext highlighter-rouge">synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p>

<p><code class="language-plaintext highlighter-rouge">java.util.concurrent.locks</code>包提供的<code class="language-plaintext highlighter-rouge">ReentrantLock</code>用于替代<code class="language-plaintext highlighter-rouge">synchronized</code>加锁。对比：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>如果用<code class="language-plaintext highlighter-rouge">ReentrantLock</code>替代，可以把代码改造为：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">synchronized</code>是Java语言层面提供的语法，所以不需要考虑异常。而<code class="language-plaintext highlighter-rouge">ReentrantLock</code>是Java代码实现的锁，<strong>就必须先获取锁，然后在<code class="language-plaintext highlighter-rouge">finally</code>中正确释放锁</strong>。</p>

<p>顾名思义，<code class="language-plaintext highlighter-rouge">ReentrantLock</code>是可重入锁，它和<code class="language-plaintext highlighter-rouge">synchronized</code>一样，一个线程可以多次获取同一个锁。</p>

<p>和<code class="language-plaintext highlighter-rouge">synchronized</code>不同的是，<code class="language-plaintext highlighter-rouge">ReentrantLock</code>可以<strong>尝试获取锁</strong>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code class="language-plaintext highlighter-rouge">tryLock()</code>返回<code class="language-plaintext highlighter-rouge">false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>

<p>所以，使用<code class="language-plaintext highlighter-rouge">ReentrantLock</code>比直接使用<code class="language-plaintext highlighter-rouge">synchronized</code>更安全，线程在<code class="language-plaintext highlighter-rouge">tryLock()</code>失败的时候不会导致死锁。</p>

<p><code class="language-plaintext highlighter-rouge">tryLock()</code>:尝试获取锁，如果锁当前是空闲的，则获取锁并立即返回<code class="language-plaintext highlighter-rouge">true</code>；如果锁不可用，则立即返回<code class="language-plaintext highlighter-rouge">false</code>，而不会等待。下面是一个典型的使用示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="o">...;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">lock</span><span class="o">.</span><span class="na">tryLock</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 操作受保护的状态</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// 执行备选操作</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这种用法确保如果成功获取了锁，则在最后释放锁，如果没有获取到锁，则不会尝试释放锁。<code class="language-plaintext highlighter-rouge">tryLock()</code>方法的返回值为<code class="language-plaintext highlighter-rouge">true</code>表示成功获取锁，为<code class="language-plaintext highlighter-rouge">false</code>表示未能获取锁。</p>

<p><code class="language-plaintext highlighter-rouge">tryLock(long time, TimeUnit unit)</code>这个方法尝试在给定的等待时间内获取锁，如果锁当前是空闲的，则获取锁并立即返回<code class="language-plaintext highlighter-rouge">true</code>；如果锁不可用，则当前线程将被禁用以进行线程调度，并且处于计时等待状态，直到以下三种情况发生之一：</p>

<ol>
  <li>当前线程成功获取了锁；</li>
  <li>其他某个线程中断了当前线程，且支持锁获取时中断；</li>
  <li>指定的等待时间过去了。</li>
</ol>

<p>如果成功获取了锁，则返回<code class="language-plaintext highlighter-rouge">true</code>。</p>

<p>如果在方法调用前当前线程的中断状态被设置，或者在获取锁的过程中被中断，且支持锁获取时中断，则会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>异常，并且会清除当前线程的中断状态。</p>

<p>如果指定的等待时间过去了但没有获取到锁，则返回<code class="language-plaintext highlighter-rouge">false</code>。如果指定的等待时间小于或等于零，则方法不会等待。</p>

<p>实现注意事项：</p>

<ol>
  <li>在某些情况下，锁的获取可能无法被中断，或者中断锁获取可能是一项昂贵的操作。这提醒开发者在使用锁时要注意这一点，避免过度依赖锁的中断操作。</li>
  <li>会优先响应中断，而不是正常方法返回，或者报告超时。</li>
  <li>锁的实现可能会检测到一些错误使用情况，比如可能导致死锁的调用，这种情况下锁可能会抛出异常。开发者需要了解这些情况并遵循实现的文档说明，以避免出现异常情况。</li>
</ol>

<p>参数：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">time</code> - 等待获取锁的最长时间</li>
  <li><code class="language-plaintext highlighter-rouge">unit</code> - <code class="language-plaintext highlighter-rouge">time</code> 参数的时间单位</li>
</ul>

<p>返回值：</p>
<ul>
  <li>如果获取了锁则返回<code class="language-plaintext highlighter-rouge">true</code>，如果等待时间过去了但没有获取到锁则返回<code class="language-plaintext highlighter-rouge">false</code></li>
</ul>

<p>抛出：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">InterruptedException</code> - 如果当前线程在获取锁时被中断（且支持锁获取时中断）</li>
</ul>

<hr />

<p><strong>方法：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">lock()</code>: 获取锁。如果锁不可用，当前线程将被阻塞，直到获取到锁为止。</li>
  <li><code class="language-plaintext highlighter-rouge">lockInterruptibly()</code>: 获取锁，但是可以响应中断。如果锁不可用，当前线程将被阻塞，直到获取到锁或者被中断为止。</li>
  <li><code class="language-plaintext highlighter-rouge">tryLock()</code>: 尝试获取锁，如果锁可用立即返回<code class="language-plaintext highlighter-rouge">true</code>，否则返回<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">tryLock(long timeout, TimeUnit unit)</code>: 在指定的时间内尝试获取锁。如果在指定时间内获取到了锁，返回<code class="language-plaintext highlighter-rouge">true</code>，否则返回<code class="language-plaintext highlighter-rouge">false</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">unlock()</code>: 释放锁。</li>
  <li><code class="language-plaintext highlighter-rouge">getHoldCount()</code>: 返回当前线程持有此锁的次数。</li>
  <li><code class="language-plaintext highlighter-rouge">getQueueLength()</code>: 返回等待获取此锁的线程估计数。</li>
  <li><code class="language-plaintext highlighter-rouge">hasQueuedThreads()</code>: 查询是否有线程正在等待获取此锁。</li>
  <li><code class="language-plaintext highlighter-rouge">isFair()</code>: 查询是否是公平锁。</li>
  <li><code class="language-plaintext highlighter-rouge">isHeldByCurrentThread()</code>: 查询当前线程是否持有此锁。</li>
  <li><code class="language-plaintext highlighter-rouge">isLocked()</code>: 查询此锁是否被任意线程持有。</li>
  <li><code class="language-plaintext highlighter-rouge">Condition newCondition()</code>：创建一个绑定到此锁实例的新<code class="language-plaintext highlighter-rouge">Condition</code>实例，用于线程间通信。</li>
</ul>

<h2 id="condition">Condition</h2>
<p>使用<code class="language-plaintext highlighter-rouge">ReentrantLock</code>比直接使用<code class="language-plaintext highlighter-rouge">synchronized</code>更安全，可以替代<code class="language-plaintext highlighter-rouge">synchronized</code>进行线程同步。</p>

<p>但是<code class="language-plaintext highlighter-rouge">synchronized</code>可以配合<code class="language-plaintext highlighter-rouge">wait</code>和<code class="language-plaintext highlighter-rouge">notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用<code class="language-plaintext highlighter-rouge">ReentrantLock</code>怎么编写<code class="language-plaintext highlighter-rouge">wait</code>和<code class="language-plaintext highlighter-rouge">notify</code>的功能呢？</p>

<p>答案是使用<code class="language-plaintext highlighter-rouge">Condition</code>对象来实现<code class="language-plaintext highlighter-rouge">wait</code>和<code class="language-plaintext highlighter-rouge">notify</code>的功能。</p>

<p>仍然以<code class="language-plaintext highlighter-rouge">TaskQueue</code>为例，把前面用<code class="language-plaintext highlighter-rouge">synchronized</code>实现的功能通过<code class="language-plaintext highlighter-rouge">ReentrantLock</code>和<code class="language-plaintext highlighter-rouge">Condition</code>来实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addTask</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="c1">// 可以替换为LockSupport.unpark(Thread.currentThread());</span>
            <span class="n">condition</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span><span class="c1">//唤醒一个</span>
            <span class="n">condition</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span><span class="c1">//唤醒全部</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getTask</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 可以替换为LockSupport.park()</span>
                <span class="n">condition</span><span class="o">.</span><span class="na">await</span><span class="o">();</span><span class="c1">//等待</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用<code class="language-plaintext highlighter-rouge">Condition</code>时，引用的<code class="language-plaintext highlighter-rouge">Condition</code>对象必须从<code class="language-plaintext highlighter-rouge">Lock</code>实例的<code class="language-plaintext highlighter-rouge">newCondition()</code>返回，这样才能获得一个绑定了<code class="language-plaintext highlighter-rouge">Lock</code>实例的<code class="language-plaintext highlighter-rouge">Condition</code>实例。</p>

<p><code class="language-plaintext highlighter-rouge">Condition</code>提供的<code class="language-plaintext highlighter-rouge">await()</code>、<code class="language-plaintext highlighter-rouge">signal()</code>、<code class="language-plaintext highlighter-rouge">signalAll()</code>原理和<code class="language-plaintext highlighter-rouge">synchronized</code>锁对象的<code class="language-plaintext highlighter-rouge">wait()</code>、<code class="language-plaintext highlighter-rouge">notify()</code>、<code class="language-plaintext highlighter-rouge">notifyAll()</code>是一致的，并且其行为也是一样的：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">await()</code>会释放当前锁，进入等待状态；</li>
  <li><code class="language-plaintext highlighter-rouge">awaitUninterruptibly()</code>: 与<code class="language-plaintext highlighter-rouge">await()</code>类似，但不会响应中断。</li>
  <li><code class="language-plaintext highlighter-rouge">long awaitNanos(long nanosTimeout)</code>：类似于<code class="language-plaintext highlighter-rouge">await()</code>，但最多等待指定的纳秒数。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean await(long time, TimeUnit unit)</code>：类似于<code class="language-plaintext highlighter-rouge">await()</code>，但最多等待指定的时间。</li>
  <li><code class="language-plaintext highlighter-rouge">signal()</code>会唤醒某个等待线程；</li>
  <li><code class="language-plaintext highlighter-rouge">signalAll()</code>会唤醒所有等待线程；</li>
  <li>唤醒线程从<code class="language-plaintext highlighter-rouge">await()</code>返回一样需要重新获得之前放弃的锁。</li>
</ul>

<p>和<code class="language-plaintext highlighter-rouge">tryLock()</code>类似，<code class="language-plaintext highlighter-rouge">await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code class="language-plaintext highlighter-rouge">signal()</code>或<code class="language-plaintext highlighter-rouge">signalAll()</code>唤醒，可以自己醒来：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">condition</span><span class="o">.</span><span class="na">await</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECOND</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 被其他线程唤醒</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// 指定时间内没有被其他线程唤醒</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可见，使用<code class="language-plaintext highlighter-rouge">Condition</code>配合<code class="language-plaintext highlighter-rouge">Lock</code>，可以实现更灵活的线程同步。</p>

<p><strong>注意<code class="language-plaintext highlighter-rouge">lock.newCondition();</code>每次都返回一个新的<code class="language-plaintext highlighter-rouge">Condition</code></strong>，这样写就不在一个频道了，肯定无法唤醒：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Condition</span> <span class="n">condition2</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addTask</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="n">condition</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span><span class="c1">//唤醒一个</span>
            <span class="n">condition</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span><span class="c1">//唤醒全部</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getTask</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">condition2</span><span class="o">.</span><span class="na">await</span><span class="o">();</span><span class="c1">//等待</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">condition</code>和<code class="language-plaintext highlighter-rouge">condition2</code>是两个独立的条件对象，它们可以分别用于不同的线程等待和唤醒操作。这样可以<strong>更精细地控制线程的等待和唤醒逻辑</strong>，确保线程在正确的条件下被唤醒。通过使用不同的<code class="language-plaintext highlighter-rouge">Condition</code>对象，可以更好地组织和管理线程的等待和唤醒操作，提高多线程程序的效率和可维护性。</p>
<h2 id="readwritelock">ReadWriteLock</h2>
<p><code class="language-plaintext highlighter-rouge">ReentrantLock</code>保证了只有一个线程可以执行临界区代码。</p>

<p>但是有些时候，这种保护有点过头。任何时刻，只允许一个线程修改，但是读取也被限制为一个线程了。</p>

<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待。</p>

<p>使用<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>可以解决这个问题，它保证：</p>

<ul>
  <li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
  <li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">ReadWriteLock</code>并不是写优先于读，它只是提供了更灵活的读写锁机制，允许多个线程同时读取数据，但只允许一个线程写入数据。</p>

<ol>
  <li>多个线程可以同时获取读锁（共享锁），以便同时读取共享资源，这样可以提高并发性能。</li>
  <li>写锁是排它的，即只有一个线程可以获取写锁，当有线程持有写锁时，<strong>其他线程无法获取读锁或写锁</strong>。</li>
</ol>

<hr />

<p>当有多个读线程持有读锁时，写线程必须等待<strong>所有的线程释放弃读锁</strong>后才能获取写锁。这保证了在写操作进行时，不会有任何其他线程持有读锁，从而确保了写操作的<strong>独占性</strong>，避免了写操作和读操作的并发冲突，从而保证了数据的一致性和正确性。</p>

<p>当<strong>申请写锁</strong>的时候，如果当前有若干取得读锁正在读的线程，那么就<strong>不允许后续准备申请读锁的线程去拿读锁了</strong>，这时会等到当前读锁全部释放后，拿到写锁。这么做是防止如果写锁没有高优先级，在大量线程不停读的情况下，写不进去。</p>

<p>一般来说<strong>写锁</strong>的优先级要<strong>高于读锁</strong>，假定读很多几乎不会间断，如果突然来个写锁，那么只需等当前正在读的释放读锁后，写就立刻获得写锁，其它后续读都得等，不然你想，在一直都有读的情况下，永远写不了。</p>

<p>通过读写锁的机制，写锁在请求时会阻塞后续的读锁请求，直到写锁被获取并完成写操作。这种机制确保了写操作的优先级，避免了写锁长时间等待的情况，从而防止了写锁被饿死的情况发生。</p>

<hr />

<p>用<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>实现这个功能十分容易。需要创建一个<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ReadWriteLock</span> <span class="n">rwlock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantReadWriteLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">rlock</span> <span class="o">=</span> <span class="n">rwlock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">wlock</span> <span class="o">=</span> <span class="n">rwlock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">counts</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inc</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">wlock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 加写锁</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">counts</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">wlock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// 释放写锁</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">rlock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 加读锁</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">counts</span><span class="o">,</span> <span class="n">counts</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">rlock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// 释放读锁</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p>

<p>使用<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>

<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>。</p>

<p>测试一下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReadWriteLock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.ReentrantReadWriteLock</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 超出出后停止</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="o">;</span><span class="n">x</span><span class="o">++,</span><span class="n">y</span><span class="o">++){</span>
                <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 线程thread执行完后关闭</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">isAlive</span><span class="o">()){</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span><span class="o">;</span>
                <span class="n">ints</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]-</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">]!=-</span><span class="mi">1</span><span class="o">){</span>
                    <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"x="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">",y="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringIntegerEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="n">count</span><span class="o">+=</span><span class="n">value</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">",count:"</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一共"</span><span class="o">+</span><span class="n">count</span><span class="o">+</span><span class="s">"条同步问题"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"耗时："</span><span class="o">+(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()-</span><span class="n">start</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ReadWriteLock</span> <span class="n">reentrantLock</span><span class="o">=</span><span class="k">new</span> <span class="nc">ReentrantReadWriteLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">w</span><span class="o">=</span><span class="n">reentrantLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">r</span><span class="o">=</span><span class="n">reentrantLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">w</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">r</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">r</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>耗时7000ms，不使用锁：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">ps</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>耗时1600ms。</p>

<hr />

<p><strong>构造方法</strong>：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock()</code>：创建一个新的<code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>实例。这个实例包含一个读锁和一个写锁。</li>
  <li><code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock(boolean fair)</code>：创建一个新的<code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>实例，可以选择是否公平地管理获取锁的顺序。如果<code class="language-plaintext highlighter-rouge">fair</code>为<code class="language-plaintext highlighter-rouge">true</code>，则表示使用公平的策略；如果<code class="language-plaintext highlighter-rouge">fair</code>为<code class="language-plaintext highlighter-rouge">false</code>，则表示使用非公平的策略。</li>
</ol>

<p><strong><code class="language-plaintext highlighter-rouge">ReentrantReadWriteLock</code>是一个支持类似于<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的语义的<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>实现。它具有以下特性：</strong></p>

<ul>
  <li><strong>获取顺序</strong>：该类不强制要求读取器或写入器优先顺序。但是，它支持一个可选的公平性策略。
    <ul>
      <li><strong>非公平模式（默认）</strong>：当以非公平模式（默认）构造时，对读锁和写锁的进入顺序是未指定的，但受到重入约束的限制。一个连续争用的非公平锁可能会无限期地延迟一个或多个读取器或写入器线程，但通常具有比公平锁更高的吞吐量。</li>
      <li><strong>公平模式</strong>：当以公平模式构造时，线程按照近似到达顺序的策略竞争进入。当当前持有锁被释放时，要么最长等待的单个写入器线程将被分配写入锁，要么如果有一组读取器线程等待时间比所有等待的写入器线程都长，则该组将被分配读取锁。</li>
    </ul>
  </li>
  <li><strong>重入性</strong>：此锁允许读取器和写入器以类似于<code class="language-plaintext highlighter-rouge">ReentrantLock</code>的方式重新获取读取或写入锁。直到写入线程持有的所有写入锁都被释放前，都不允许其他线程获取读锁。</li>
  <li><strong>锁降级</strong>：通过获取写锁，然后获取读锁，然后释放写锁，可以将写锁降级为读锁。但是，不能从读锁升级为写锁。</li>
  <li><strong>锁获取中断</strong>：读锁和写锁都支持在获取锁时中断。</li>
  <li><strong>条件支持</strong>：写锁提供了一个<code class="language-plaintext highlighter-rouge">Condition</code>实现，行为与<code class="language-plaintext highlighter-rouge">ReentrantLock</code>提供的<code class="language-plaintext highlighter-rouge">Condition</code>实现对于<code class="language-plaintext highlighter-rouge">ReentrantLock</code>一样。当然，这个<code class="language-plaintext highlighter-rouge">Condition</code><strong>只能与写锁一起使用</strong>。读锁不支持<code class="language-plaintext highlighter-rouge">Condition</code>，<code class="language-plaintext highlighter-rouge">readLock().newCondition()</code>会抛出<code class="language-plaintext highlighter-rouge">UnsupportedOperationException</code>异常。</li>
  <li><strong>仪表化</strong>：这个类支持用于确定锁是否被持有或争用的方法。这些方法设计用于监视系统状态，而不是用于同步控制。</li>
</ul>

<h2 id="stampedlock">StampedLock</h2>
<p><code class="language-plaintext highlighter-rouge">ReadWriteLock</code>可以解决多线程同时读，但只有一个线程能写的问题。</p>

<p><code class="language-plaintext highlighter-rouge">ReadWriteLock</code>有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种<strong>悲观的读锁</strong>。</p>

<p>要进一步提升并发执行效率，<strong>Java 8</strong>引入了新的读写锁：<code class="language-plaintext highlighter-rouge">StampedLock</code>。</p>

<p><code class="language-plaintext highlighter-rouge">StampedLock</code>和<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种<strong>乐观锁</strong>。</p>

<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>

<p><strong>乐观锁不会上锁</strong>，在获得乐观锁时会得到一个版本号，然后在读数据操作完毕后，再次检查版本号，如果不匹配，则表示数据已经被其他线程修改过，需要进行相应的处理（例如回滚或重新尝试更新）。乐观锁省去了加锁的步骤，减少了锁竞争，但需要额外的代码，处理数据冲突的情况。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StampedLock</span> <span class="n">stampedLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StampedLock</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">stampedLock</span><span class="o">.</span><span class="na">unlockWrite</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="c1">// 获得一个乐观读锁</span>
        <span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">tryOptimisticRead</span><span class="o">();</span> 
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="c1">// 验证</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">stampedLock</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">stamp</span><span class="o">)){</span>
            <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">readLock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">stampedLock</span><span class="o">.</span><span class="na">unlockRead</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>和<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。</p>

<p>首先通过<code class="language-plaintext highlighter-rouge">tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。</p>

<p>接着进行读取，读取完成后，通过<code class="language-plaintext highlighter-rouge">validate()</code>去验证版本号，如果在读取过程中<strong>没有写入</strong>，版本号不变，<strong>验证成功</strong>，就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，<strong>验证失败</strong>。在失败的时候，再通过获取悲观读锁再次读取。</p>

<p><code class="language-plaintext highlighter-rouge">StampedLock</code>每次读写会记录时间戳， 尝试乐观读<code class="language-plaintext highlighter-rouge">tryOptimisticRead</code>后，通过<code class="language-plaintext highlighter-rouge">validate</code>确认是否有更新的<strong>写操作时间戳</strong>，有则加普通读锁重读。而<code class="language-plaintext highlighter-rouge">ReadWriteLock</code> 相比<code class="language-plaintext highlighter-rouge">StampedLock</code>，少了一个尝试读的过程和记录、比较时间戳的操作。</p>

<p>在<code class="language-plaintext highlighter-rouge">StampedLock</code>中，<code class="language-plaintext highlighter-rouge">unlock</code>方法用于释放读锁或写锁。如果持有的是读锁，应该使用<code class="language-plaintext highlighter-rouge">unlockRead</code>方法释放；如果持有的是写锁，应该使用<code class="language-plaintext highlighter-rouge">unlockWrite</code>方法释放。这两个方法都需要传入获取锁时返回的<code class="language-plaintext highlighter-rouge">stamp</code>作为参数。</p>

<p>另外，如果尝试获取乐观读锁（<code class="language-plaintext highlighter-rouge">tryOptimisticRead</code>）成功，后续需要使用<code class="language-plaintext highlighter-rouge">validate</code>方法验证乐观读锁的<code class="language-plaintext highlighter-rouge">stamp</code>是否仍然有效，如果无效则需要重新尝试获取乐观读锁或者进行其他处理，但并<strong>不需要显式释放</strong>乐观读锁。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是<code class="language-plaintext highlighter-rouge">StampedLock</code>中的<strong>写锁（write lock）是不可重入的</strong>，这意味着如果一个线程已经持有写锁，再次尝试获取写锁会导致死锁。</p>

<p>读锁（read lock）是<strong>可重入</strong>的，同一个线程可以多次获取读锁而不会导致死锁。这种设计在一定程度上降低了使用<code class="language-plaintext highlighter-rouge">StampedLock</code>时出现死锁的可能性。</p>

<p>Java 对于 <code class="language-plaintext highlighter-rouge">ReadWriteLock</code> 的读锁的抢锁的策略做了限制，当阻塞队列中第一个线程是一个写线程的时候，那读锁就不会参与抢锁，而是直接阻塞，这在一定程度上解决了写锁饿死的问题，JDK8 中的 <code class="language-plaintext highlighter-rouge">StampedLock</code> 进一步解决了写锁被读锁阻塞的问题，在乐观锁的读锁状态下，写锁可以直接进行获取锁，不用进行抢锁，而且 <code class="language-plaintext highlighter-rouge">StampLock</code> 对于抢锁失败阻塞造成频繁的上下文切换也进行了优化，线程在抢锁时（底层使用 CAS 实现）如果失败不会直接阻塞，而是通过自旋不断尝试获取锁，直到尝试次数达到上限（单核CPU为0，多核为2^16）才会进行阻塞，等待被唤醒，唤醒后依旧进行自旋，如果依旧无法获得锁，那么再阻塞等待被唤醒。</p>

<p><code class="language-plaintext highlighter-rouge">StampedLock</code>还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>

<p><code class="language-plaintext highlighter-rouge">StampedLock</code> 支持在三种模式之间有条件地提供转换的方法。</p>

<p>例如，方法<code class="language-plaintext highlighter-rouge">tryConvertToWriteLock(long)</code>尝试“升级”模式，如果已在写入模式中或在读取模式中且没有其他读取者或在乐观模式中且锁可用，则返回有效的写标记。</p>

<p><code class="language-plaintext highlighter-rouge">StampedLocks</code> 是可序列化的，<strong>但反序列化始终为初始解锁状态</strong>，因此对于远程锁定而言并不实用。</p>

<p><strong><code class="language-plaintext highlighter-rouge">StampedLock</code>与<code class="language-plaintext highlighter-rouge">ReadWriteLock</code>不同的方法主要包括以下几种：</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">tryOptimisticRead()</code>：尝试获取乐观读锁，如果当前没有写锁被持有，则返回一个非零的标记，否则返回零。</li>
  <li><code class="language-plaintext highlighter-rouge">validate(long)</code>：验证乐观读锁的标记是否仍然有效，即是否有写操作发生。如果在获取乐观读锁后没有写操作，则返回true，否则返回false。</li>
  <li><code class="language-plaintext highlighter-rouge">tryConvertToWriteLock(long)</code>：尝试将乐观读锁转换为写锁。如果当前没有其他线程持有写锁，并且没有其他读锁存在，则可以成功转换，返回一个有效的写锁标记，否则返回零。</li>
  <li><code class="language-plaintext highlighter-rouge">tryConvertToReadLock(long)</code>：尝试将写锁转换为读锁。如果当前没有其他线程持有写锁，并且没有其他读锁存在，则可以成功转换，返回一个有效的读锁标记，否则返回零。</li>
  <li><code class="language-plaintext highlighter-rouge">tryConvertToOptimisticRead(long)</code>：尝试将写锁或读锁转换为乐观读锁。如果当前没有其他线程持有写锁，则可以成功转换，返回一个有效的乐观读锁标记，否则返回零。</li>
</ol>

<p><strong>测试：</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.locks.StampedLock</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 超出出后停止</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="o">;</span><span class="n">x</span><span class="o">++,</span><span class="n">y</span><span class="o">++){</span>
                <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 线程thread执行完后关闭</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">isAlive</span><span class="o">()){</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span><span class="o">;</span>
                <span class="n">ints</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]-</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">]!=-</span><span class="mi">1</span><span class="o">){</span>
                    <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"x="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">",y="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringIntegerEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="n">count</span><span class="o">+=</span><span class="n">value</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">",count:"</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一共"</span><span class="o">+</span><span class="n">count</span><span class="o">+</span><span class="s">"条同步问题"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"耗时："</span><span class="o">+(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()-</span><span class="n">start</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"乐观：%d,悲观转换写：%d,悲观写：%d,乐观占比：%s%n"</span><span class="o">,</span> <span class="n">point</span><span class="o">.</span><span class="na">he</span><span class="o">,</span> <span class="n">point</span><span class="o">.</span><span class="na">be1</span><span class="o">,</span> <span class="n">point</span><span class="o">.</span><span class="na">be2</span><span class="o">,</span> <span class="n">point</span><span class="o">.</span><span class="na">he</span> <span class="o">/</span> <span class="o">(</span><span class="n">point</span><span class="o">.</span><span class="na">be1</span> <span class="o">+</span> <span class="n">point</span><span class="o">.</span><span class="na">be2</span> <span class="o">+</span> <span class="n">point</span><span class="o">.</span><span class="na">he</span> <span class="o">+</span> <span class="mf">0.0</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StampedLock</span> <span class="n">stampedLock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StampedLock</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">he</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">be1</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">be2</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">stampedLock</span><span class="o">.</span><span class="na">unlockWrite</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="kt">long</span> <span class="n">stamp</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">tryOptimisticRead</span><span class="o">();</span> <span class="c1">// 获得一个乐观读锁</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">stampedLock</span><span class="o">.</span><span class="na">validate</span><span class="o">(</span><span class="n">stamp</span><span class="o">)){</span>
            <span class="c1">// 如果不一致，则回写为旧数据，尝试转换为写锁</span>
            <span class="kt">long</span> <span class="n">l</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">tryConvertToWriteLock</span><span class="o">(</span><span class="n">stamp</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">l</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
                <span class="n">be1</span><span class="o">++;</span>
                <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">=</span><span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">=</span><span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                <span class="n">stampedLock</span><span class="o">.</span><span class="na">unlockWrite</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
            <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                <span class="c1">//转换失败，获取写锁</span>
                <span class="kt">long</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">stampedLock</span><span class="o">.</span><span class="na">writeLock</span><span class="o">();</span>
                <span class="n">be2</span><span class="o">++;</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    <span class="n">stampedLock</span><span class="o">.</span><span class="na">unlockWrite</span><span class="o">(</span><span class="n">l1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">he</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>一共0条同步问题
耗时：7238
乐观：594759493,悲观转换写：0,悲观写：8128226,乐观占比：0.986517844461184
</code></pre></div></div>
<p>挺有用的。</p>
<h2 id="semaphore">Semaphore</h2>
<p>各种锁的实现，本质上锁的目的是保护一种受限资源，保证同一时刻只有一个线程能访问（ReentrantLock），或者只有一个线程能写入（ReadWriteLock）。</p>

<p>还有一种受限资源，它需要保证同一时刻最多有N个线程能访问，比如同一时刻最多创建100个数据库连接，最多允许10个用户下载等。</p>

<p>这种限制数量的锁，如果用Lock数组来实现，就太麻烦了。</p>

<p>这种情况就可以使用<code class="language-plaintext highlighter-rouge">Semaphore</code>，例如，最多允许3个线程同时访问：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AccessLimitControl</span> <span class="o">{</span>
    <span class="c1">// 任意时刻仅允许最多3个线程获取许可:</span>
    <span class="kd">final</span> <span class="nc">Semaphore</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Semaphore</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">access</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 如果超过了许可数量,其他线程将在此等待:</span>
        <span class="n">semaphore</span><span class="o">.</span><span class="na">acquire</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// TODO:</span>
            <span class="k">return</span> <span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用<code class="language-plaintext highlighter-rouge">Semaphore</code>先调用<code class="language-plaintext highlighter-rouge">acquire()</code>获取，然后通过<code class="language-plaintext highlighter-rouge">try ... finally</code>保证在<code class="language-plaintext highlighter-rouge">finally</code>中使用<code class="language-plaintext highlighter-rouge">release()</code>释放。</p>

<p>调用<code class="language-plaintext highlighter-rouge">acquire()</code>可能会进入等待，直到满足条件为止。也可以使用<code class="language-plaintext highlighter-rouge">tryAcquire()</code>指定等待时间：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">semaphore</span><span class="o">.</span><span class="na">tryAcquire</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 指定等待时间3秒内获取到许可:</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// TODO:</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">semaphore</span><span class="o">.</span><span class="na">release</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Semaphore</code>本质上就是一个信号计数器，用于限制同一时间的最大访问数量。</p>

<hr />

<p><code class="language-plaintext highlighter-rouge">Semaphore</code>类提供了以下几个常用的方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">acquire()</code>: 获取一个许可，如果没有许可可用，则阻塞直到有许可可用为止。</li>
  <li><code class="language-plaintext highlighter-rouge">release()</code>: 释放一个许可，将其返回给信号量。</li>
  <li><code class="language-plaintext highlighter-rouge">tryAcquire()</code>: 尝试获取一个许可，如果成功则返回<code class="language-plaintext highlighter-rouge">true</code>，否则立即返回<code class="language-plaintext highlighter-rouge">false</code>，不会阻塞。</li>
  <li><code class="language-plaintext highlighter-rouge">tryAcquire(long timeout, TimeUnit unit)</code>: 尝试获取一个许可，如果在指定的时间内成功获取许可则返回<code class="language-plaintext highlighter-rouge">true</code>，否则返回<code class="language-plaintext highlighter-rouge">false</code>，不会阻塞超过指定时间。</li>
  <li><code class="language-plaintext highlighter-rouge">availablePermits()</code>: 返回当前可用的许可数。</li>
  <li><code class="language-plaintext highlighter-rouge">drainPermits()</code>: 获取并返回立即可用的所有许可，并将可用许可数归零。</li>
  <li><code class="language-plaintext highlighter-rouge">reducePermits(int reduction)</code>: 减少许可数，可能导致信号量内部状态的变化。</li>
</ul>

<p>除了这些方法，<code class="language-plaintext highlighter-rouge">Semaphore</code>还提供了一些构造方法用于初始化许可数量，以及一些其他辅助方法用于查询状态等。<code class="language-plaintext highlighter-rouge">Semaphore</code>的用法通常是在需要控制并发访问数量的地方，使用<code class="language-plaintext highlighter-rouge">acquire()</code>方法获取许可，在任务完成后使用<code class="language-plaintext highlighter-rouge">release()</code>方法释放许可。</p>

<p><code class="language-plaintext highlighter-rouge">Semaphore</code>类提供了以下几种构造方法：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Semaphore(int permits)</code>: 创建一个具有给定许可数的<code class="language-plaintext highlighter-rouge">Semaphore</code>实例。这个许可数表示同时可以访问某一资源的线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">Semaphore(int permits, boolean fair)</code>: 创建一个具有给定许可数和公平性设置的<code class="language-plaintext highlighter-rouge">Semaphore</code>实例。如果<code class="language-plaintext highlighter-rouge">fair</code>为<code class="language-plaintext highlighter-rouge">true</code>，则使用公平的许可获取顺序；否则，使用非公平的许可获取顺序。</li>
</ol>

<p>公平的许可获取顺序指的是当有多个线程在等待获取许可时，<code class="language-plaintext highlighter-rouge">Semaphore</code>会按照它们等待获取许可的先后顺序来分配许可。也就是说，等待时间最长的线程会最先获得许可，而等待时间最短的线程会最后获得许可。这种方式可以确保所有线程都有公平的机会获取许可，避免了某些线程长期被阻塞的情况。</p>
<h2 id="concurrent集合">Concurrent集合</h2>
<p>在前面已经通过<code class="language-plaintext highlighter-rouge">ReentrantLock</code>和<code class="language-plaintext highlighter-rouge">Condition</code>实现了一个<code class="language-plaintext highlighter-rouge">BlockingQueue</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TaskQueue</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Condition</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addTask</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="n">condition</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">condition</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">BlockingQueue</code>的意思就是说，当一个线程调用这个<code class="language-plaintext highlighter-rouge">TaskQueue</code>的<code class="language-plaintext highlighter-rouge">getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code class="language-plaintext highlighter-rouge">getTask()</code>方法才会返回。<br />
因为<code class="language-plaintext highlighter-rouge">BlockingQueue</code>非常有用，所以不必自己编写，可以直接使用Java标准库的<code class="language-plaintext highlighter-rouge">java.util.concurrent</code>包提供的线程安全的集合：<code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>。<br />
除了<code class="language-plaintext highlighter-rouge">BlockingQueue</code>外，针对<code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Map</code>、<code class="language-plaintext highlighter-rouge">Set</code>、<code class="language-plaintext highlighter-rouge">Deque</code>等，<code class="language-plaintext highlighter-rouge">java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">interface</th>
      <th style="text-align: left">non-thread-safe</th>
      <th style="text-align: left">thread-safe</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">List</td>
      <td style="text-align: left">ArrayList</td>
      <td style="text-align: left">CopyOnWriteArrayList</td>
    </tr>
    <tr>
      <td style="text-align: left">Map</td>
      <td style="text-align: left">HashMap</td>
      <td style="text-align: left">ConcurrentHashMap</td>
    </tr>
    <tr>
      <td style="text-align: left">Set</td>
      <td style="text-align: left">HashSet / TreeSet</td>
      <td style="text-align: left">CopyOnWriteArraySet</td>
    </tr>
    <tr>
      <td style="text-align: left">Queue</td>
      <td style="text-align: left">ArrayDeque / LinkedList</td>
      <td style="text-align: left">ArrayBlockingQueue / LinkedBlockingQueue</td>
    </tr>
    <tr>
      <td style="text-align: left">Deque</td>
      <td style="text-align: left">ArrayDeque / LinkedList</td>
      <td style="text-align: left">LinkedBlockingDeque</td>
    </tr>
  </tbody>
</table>

<p>使用这些并发集合与使用非线程安全的集合类完全相同。以<code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>为例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 在不同的线程读写:</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"B"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span>
</code></pre></div></div>
<p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>改为：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>就可以了。</p>

<p><code class="language-plaintext highlighter-rouge">java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span> <span class="n">unsafeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
<span class="nc">Map</span> <span class="n">threadSafeMap</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="n">unsafeMap</span><span class="o">);</span>
</code></pre></div></div>
<p>但是它实际上是用一个包装类包装了非线程安全的<code class="language-plaintext highlighter-rouge">Map</code>，然后对所有读写方法都用<code class="language-plaintext highlighter-rouge">synchronized</code>加锁，这样获得的线程安全集合的性能比<code class="language-plaintext highlighter-rouge">java.util.concurrent</code>集合要低很多，所以不推荐使用。</p>
<h2 id="atomic">Atomic</h2>
<p>Java的<code class="language-plaintext highlighter-rouge">java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code class="language-plaintext highlighter-rouge">java.util.concurrent.atomic</code>包。</p>

<p>以<code class="language-plaintext highlighter-rouge">AtomicInteger</code>为例，它提供的主要操作有：</p>

<ul>
  <li>增加值并返回新值：<code class="language-plaintext highlighter-rouge">int addAndGet(int delta)</code></li>
  <li>加1后返回新值：<code class="language-plaintext highlighter-rouge">int incrementAndGet()</code></li>
  <li>获取当前值：<code class="language-plaintext highlighter-rouge">int get()</code></li>
  <li>用CAS方式设置：<code class="language-plaintext highlighter-rouge">int compareAndSet(int expect, int update)</code></li>
</ul>

<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>

<p>CAS原子操作属于处理器汇编指令集，值相同则写入，否则跳转，所以是lock-free不需要额外加锁。<br />
在CAS基础上的Atomic，先暂存原值并操作，后根据CAS比较的结果判断<strong>操作的独立有效性，值相同则有效，反之无效。</strong><br />
如果我们自己通过CAS编写<code class="language-plaintext highlighter-rouge">incrementAndGet()</code>，它大概长这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">incrementAndGet</span><span class="o">(</span><span class="nc">AtomicInteger</span> <span class="kt">var</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">;</span>
    <span class="k">do</span> <span class="o">{</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kt">var</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">while</span> <span class="o">(</span> <span class="o">!</span> <span class="kt">var</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">prev</span><span class="o">,</span> <span class="n">next</span><span class="o">));</span>
    <span class="k">return</span> <span class="n">next</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在这个操作中CAS是指<code class="language-plaintext highlighter-rouge">var.compareAndSet(prev, next)</code>，如果<code class="language-plaintext highlighter-rouge">var</code>的当前值是<code class="language-plaintext highlighter-rouge">prev</code>，那么就更新为<code class="language-plaintext highlighter-rouge">next</code>，返回<code class="language-plaintext highlighter-rouge">true</code>。如果<code class="language-plaintext highlighter-rouge">var</code>的当前值不是<code class="language-plaintext highlighter-rouge">prev</code>，就什么也不干，返回<code class="language-plaintext highlighter-rouge">false</code>。通过CAS操作并配合<code class="language-plaintext highlighter-rouge">do ... while</code>循环，即使其他线程修改了<code class="language-plaintext highlighter-rouge">AtomicInteger</code>的值，最终的结果也是正确的。</p>

<p>CAS是原子操作，但多核CPU下多个线程同时执行CAS操作为什么依旧是线程安全的呢？因为计算机底层实现保证了V（即上面的变量Var）指向内存的互斥性和立即可见性，可以理解为<strong>CAS操作是底层保证的线程安全。</strong></p>

<p>利用<code class="language-plaintext highlighter-rouge">AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">IdGenerator</span> <span class="o">{</span>
    <span class="nc">AtomicLong</span> <span class="kt">var</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicLong</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getNextId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kt">var</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>通常情况下，我们并不需要直接用<code class="language-plaintext highlighter-rouge">do ... while</code>循环调用<code class="language-plaintext highlighter-rouge">compareAndSet</code>实现复杂的并发操作，而是用<code class="language-plaintext highlighter-rouge">incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p>

<p>在高度竞争的情况下，还可以使用<strong>Java 8</strong>提供的<code class="language-plaintext highlighter-rouge">LongAdder</code>和<code class="language-plaintext highlighter-rouge">LongAccumulator</code>。</p>

<p><code class="language-plaintext highlighter-rouge">LongAdder</code>和<code class="language-plaintext highlighter-rouge">LongAccumulator</code>都是用来累加长整型值的工具类，但它们的使用场景和实现略有不同。</p>

<p><strong>LongAdder</strong>：适用于高并发情况下的累加操作。它采用了分段锁（Cell数组）的方式来减小锁的竞争，从而提高了并发性能。使用<code class="language-plaintext highlighter-rouge">LongAdder</code>时，通常不需要担心多线程竞争导致的性能问题，适用于计数器等需要频繁增加的场景。</p>

<p>示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LongAdder</span> <span class="n">adder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LongAdder</span><span class="o">();</span>
<span class="n">adder</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span> <span class="c1">// 增加值</span>
<span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">adder</span><span class="o">.</span><span class="na">sum</span><span class="o">();</span> <span class="c1">// 获取总和</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span><span class="c1">// 1</span>
</code></pre></div></div>
<p><strong>LongAccumulator</strong>：适用于需要自定义累加规则的情况。它提供了一个函数和一个初始值，可以根据自定义的函数对输入的值进行累加。使用<code class="language-plaintext highlighter-rouge">LongAccumulator</code>时，可以定义一个累加函数，该函数接受两个参数（当前值和新值），并返回一个新值。</p>

<p>示例代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LongBinaryOperator</span> <span class="n">accumulatorFunction</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">;</span> <span class="c1">// 定义累加函数</span>
<span class="kt">long</span> <span class="n">identity</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 初始值</span>
<span class="nc">LongAccumulator</span> <span class="n">accumulator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LongAccumulator</span><span class="o">(</span><span class="n">accumulatorFunction</span><span class="o">,</span> <span class="n">identity</span><span class="o">);</span>
<span class="n">accumulator</span><span class="o">.</span><span class="na">accumulate</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span> <span class="c1">// 累加新值</span>
<span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">accumulator</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 获取结果</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span><span class="c1">//3</span>
</code></pre></div></div>
<p>总的来说，<code class="language-plaintext highlighter-rouge">LongAdder</code>适用于高并发下的累加操作，而<code class="language-plaintext highlighter-rouge">LongAccumulator</code>适用于需要自定义累加规则的情况。</p>
<h2 id="线程池">线程池</h2>
<p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>

<p>如果可以复用一组线程：</p>

<pre><code class="language-ascii">┌─────┐ execute  ┌──────────────────┐
│Task1│─────────&gt;│ThreadPool        │
├─────┤          │┌───────┐┌───────┐│
│Task2│          ││Thread1││Thread2││
├─────┤          │└───────┘└───────┘│
│Task3│          │┌───────┐┌───────┐│
├─────┤          ││Thread3││Thread4││
│Task4│          │└───────┘└───────┘│
├─────┤          └──────────────────┘
│Task5│
├─────┤
│Task6│
└─────┘
  ...
</code></pre>
<p>那么就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p>

<p>简单地说，线程池内部<strong>维护了若干个线程</strong>，没有任务的时候，这些线程都处于等待状态。如果有<strong>新任务</strong>，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>

<p>Java标准库提供了<code class="language-plaintext highlighter-rouge">ExecutorService</code>接口表示线程池，它的典型用法如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建固定大小的线程池:</span>
<span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="c1">// 提交任务:</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task1</span><span class="o">);</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task2</span><span class="o">);</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task3</span><span class="o">);</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task4</span><span class="o">);</span>
<span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task5</span><span class="o">);</span>
</code></pre></div></div>
<p>因为<code class="language-plaintext highlighter-rouge">ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">FixedThreadPool</code>：线程数固定的线程池；</li>
  <li><code class="language-plaintext highlighter-rouge">CachedThreadPool</code>：线程数根据任务动态调整的线程池；</li>
  <li><code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code>：仅单线程执行的线程池。</li>
</ul>

<h3 id="fixedthreadpool">FixedThreadPool</h3>
<p>创建这些线程池的方法都被封装到<code class="language-plaintext highlighter-rouge">Executors</code>这个类中。以<code class="language-plaintext highlighter-rouge">FixedThreadPool</code>为例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个固定大小的线程池:</span>
<span class="nc">ExecutorService</span> <span class="n">es</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">finalI</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="n">es</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">finalI</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"线程 %s 开始任务: %s%n"</span><span class="o">,</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span><span class="n">name</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"线程 %s 结束任务: %s%n"</span><span class="o">,</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span> <span class="n">name</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">});</span>
<span class="o">}</span>
<span class="c1">// 关闭线程池:</span>
<span class="n">es</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>线程 pool-1-thread-4 开始任务: 4
线程 pool-1-thread-2 开始任务: 2
线程 pool-1-thread-3 开始任务: 3
线程 pool-1-thread-1 开始任务: 1
线程 pool-1-thread-4 结束任务: 4
线程 pool-1-thread-4 开始任务: 5
线程 pool-1-thread-1 结束任务: 1
线程 pool-1-thread-1 开始任务: 6
线程 pool-1-thread-3 结束任务: 3
线程 pool-1-thread-2 结束任务: 2
线程 pool-1-thread-1 结束任务: 6
线程 pool-1-thread-4 结束任务: 5
</code></pre></div></div>
<p>一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p>

<p>线程池在程序结束的时候要关闭。使用<code class="language-plaintext highlighter-rouge">shutdown()</code>方法关闭线程池的时候，会等待<strong>正在执行</strong>的任务先完成，然后再关闭。<code class="language-plaintext highlighter-rouge">shutdownNow()</code>则会立刻停止正在执行的任务，<code class="language-plaintext highlighter-rouge">awaitTermination()</code>则会等待指定的时间让线程池关闭。</p>

<hr />

<h3 id="cachedthreadpool">CachedThreadPool</h3>
<p>如果把线程池改为<code class="language-plaintext highlighter-rouge">CachedThreadPool</code>，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。</p>

<p>如果想把线程池的大小限制在4～10个之间动态调整怎么办？我们查看<code class="language-plaintext highlighter-rouge">Executors.newCachedThreadPool()</code>方法的源码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
                                    <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                                    <span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
<span class="o">}</span>
</code></pre></div></div>
<p>因此，想创建指定动态范围的线程池，可以这么写：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="nc">ExecutorService</span> <span class="n">es</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">,</span>
        <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
</code></pre></div></div>
<h3 id="singlethreadexecutor">SingleThreadExecutor</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">es</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
<span class="nc">Runnable</span> <span class="n">callable</span><span class="o">=()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
<span class="o">};</span>
<span class="n">es</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">callable</span><span class="o">);</span>
<span class="c1">// 关闭线程池:</span>
<span class="n">es</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>
<h3 id="threadpoolexecutor">ThreadPoolExecutor</h3>
<p><code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>类是Java中用于管理线程池的一个重要类，它实现了<code class="language-plaintext highlighter-rouge">ExecutorService</code>接口。以下是<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>类的一些常用方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">execute(Runnable command)</code>: 提交一个不需要返回值的任务给线程池执行。</li>
  <li><code class="language-plaintext highlighter-rouge">submit(Callable&lt;T&gt; task)</code>: 提交一个有返回值的任务给线程池执行，并返回一个表示任务的未来结果的 <code class="language-plaintext highlighter-rouge">Future</code> 对象。</li>
  <li><code class="language-plaintext highlighter-rouge">shutdown()</code>: 启动有序关闭，在该关闭中先前提交的任务将被执行，但不会接受新任务。如果已经关闭，则调用没有其他影响。</li>
  <li><code class="language-plaintext highlighter-rouge">shutdownNow()</code>: 尝试停止所有正在执行的活动任务，暂停等待任务的处理，并返回等待执行的任务列表。此方法不保证能够停止正在处理的活动执行任务，但是会尽最大努力。</li>
  <li><code class="language-plaintext highlighter-rouge">isShutdown()</code>: 如果此执行程序已关闭，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">isTerminating()</code>: 如果此执行程序已经启动关闭过程，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">isTerminated()</code>: 如果所有任务在关闭后都已完成，则返回 <code class="language-plaintext highlighter-rouge">true</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">awaitTermination(long timeout, TimeUnit unit)</code>: 请求关闭，并阻塞直到所有任务完成执行，或发生超时，或当前线程被中断，以先发生者为准。</li>
  <li><code class="language-plaintext highlighter-rouge">setCorePoolSize(int corePoolSize)</code>: 设置核心线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">getCorePoolSize()</code>: 获取核心线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">setMaximumPoolSize(int maximumPoolSize)</code>: 设置最大线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">getMaximumPoolSize()</code>: 获取最大线程数。</li>
  <li><code class="language-plaintext highlighter-rouge">getPoolSize()</code>: 获取当前线程池中的线程数量。</li>
  <li><code class="language-plaintext highlighter-rouge">getActiveCount()</code>: 获取当前线程池中正在执行任务的线程数量。</li>
  <li><code class="language-plaintext highlighter-rouge">getQueue()</code>: 获取用于保存等待执行任务的队列。</li>
  <li><code class="language-plaintext highlighter-rouge">getRejectedExecutionHandler()</code>: 获取用于处理无法执行的任务的处理程序。</li>
  <li><code class="language-plaintext highlighter-rouge">setRejectedExecutionHandler(RejectedExecutionHandler handler)</code>: 设置用于处理无法执行的任务的处理程序。</li>
  <li><code class="language-plaintext highlighter-rouge">prestartCoreThread()</code>: 预启动一个核心线程，不等待任务。</li>
  <li><code class="language-plaintext highlighter-rouge">prestartAllCoreThreads()</code>: 预启动所有核心线程，不等待任务。</li>
  <li><code class="language-plaintext highlighter-rouge">allowsCoreThreadTimeOut()</code>: 判断核心线程在执行完当前任务后是否允许超时。如果允许超时，则核心线程在空闲一定时间后会被回收；如果不允许超时，则核心线程会一直保持存活状态，即使空闲也不会被回收。。</li>
  <li><code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut(boolean value)</code>:设置核心线程是否在执行完当前任务后允许超时。如果设置为<code class="language-plaintext highlighter-rouge">true</code>，则核心线程在空闲一定时间后会被回收；如果设置为<code class="language-plaintext highlighter-rouge">false</code>，则核心线程会一直保持存活状态，即使空闲也不会被回收。</li>
  <li><code class="language-plaintext highlighter-rouge">remove(Runnable task)</code>: 从工作队列中删除指定的任务。</li>
  <li><code class="language-plaintext highlighter-rouge">purge()</code>: 从工作队列中删除所有已经取消的任务。</li>
</ul>

<p>这些方法使得我们可以方便地管理线程池的行为，如调整线程数、查看线程池状态等。<br />
实际上前面的<code class="language-plaintext highlighter-rouge">FixedThreadPool</code>、<code class="language-plaintext highlighter-rouge">CachedThreadPool</code>、<code class="language-plaintext highlighter-rouge">SingleThreadExecutor</code>，实例化的都是<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">es0</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="nc">ExecutorService</span> <span class="n">es1</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
<span class="nc">ExecutorService</span> <span class="n">es2</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newSingleThreadExecutor</span><span class="o">();</span>
</code></pre></div></div>
<p>相当于:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个固定大小为10个线程的线程池</span>
<span class="nc">ThreadPoolExecutor</span> <span class="n">es0</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
<span class="c1">// 创建一个根据需要创建新线程的线程池</span>
<span class="nc">ThreadPoolExecutor</span> <span class="n">es1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span> <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
<span class="c1">// 创建一个只有一个工作线程的线程池</span>
<span class="nc">ThreadPoolExecutor</span> <span class="n">es2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
</code></pre></div></div>
<h3 id="scheduledthreadpool">ScheduledThreadPool</h3>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>。放入<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>的任务可以定期反复执行。创建一个<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>仍然是通过<code class="language-plaintext highlighter-rouge">Executors</code>类：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ScheduledExecutorService</span> <span class="n">ses</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
</code></pre></div></div>
<p>可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1秒后执行一次性任务:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="k">new</span> <span class="nc">Task</span><span class="o">(</span><span class="s">"one-time"</span><span class="o">),</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</code></pre></div></div>
<p>如果任务以固定的<strong>每3秒</strong>执行，我们可以这样写：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2秒后开始执行定时任务，每3秒执行:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(</span><span class="k">new</span> <span class="nc">Task</span><span class="o">(</span><span class="s">"fixed-rate"</span><span class="o">),</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</code></pre></div></div>
<p>如果任务以固定的3秒为<strong>间隔</strong>执行，我们可以这样写：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 2秒后开始执行定时任务，以3秒为间隔执行:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">scheduleWithFixedDelay</span><span class="o">(</span><span class="k">new</span> <span class="nc">Task</span><span class="o">(</span><span class="s">"fixed-delay"</span><span class="o">),</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">);</span>
</code></pre></div></div>
<p>注意<code class="language-plaintext highlighter-rouge">FixedRate</code>和<code class="language-plaintext highlighter-rouge">FixedDelay</code>的区别。<code class="language-plaintext highlighter-rouge">FixedRate</code>是指任务总是以固定时间间隔触发，<strong>不管任务执行多长时间</strong>：</p>
<pre><code class="language-ascii">│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  
├───────┼───────┼───────┼───────┼────&gt;
│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│
</code></pre>
<p>而<code class="language-plaintext highlighter-rouge">FixedDelay</code>是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p>
<pre><code class="language-ascii">│░░░│       │░░░░░│       │░░│       │░
└───┼───────┼─────┼───────┼──┼───────┼──&gt;
    │&lt;─────&gt;│     │&lt;─────&gt;│  │&lt;─────&gt;│
</code></pre>
<p>因此，使用<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>时，我们要根据需要选择执行一次、<code class="language-plaintext highlighter-rouge">FixedRate</code>执行还是<code class="language-plaintext highlighter-rouge">FixedDelay</code>执行。</p>

<p>在<code class="language-plaintext highlighter-rouge">scheduleAtFixedRate</code>方法中，如果某次任务<strong>执行时间超过</strong>了指定的<strong>周期</strong>，如果任务的任何执行时间超过其周期，则后续执行会延迟启动，不会同时执行。后续任务会在上个任务执行完毕后立即执行以持续补时差，直到回归正常(时间-&gt;任务)一一对应的序列。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ScheduledExecutorService</span> <span class="n">ses</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">ses</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始"</span><span class="o">+</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
<span class="o">},</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</code></pre></div></div>
<p>这个例子本来是间隔0.1s执行的，但任务至少需要1s才能执行完，因此每次任务都会贴着执行 即后续输出都是输出：<code class="language-plaintext highlighter-rouge">结束</code>后马上输出<code class="language-plaintext highlighter-rouge">开始...</code>。</p>

<p>对于<code class="language-plaintext highlighter-rouge">scheduleAtFixedRate</code>和<code class="language-plaintext highlighter-rouge">scheduleWithFixedDelay</code>方法，如果任务<strong>抛出异常</strong>，后续任务<strong>会停止执行</strong>，且异常不会抛出到控制台，线程将被迫停止并由RUNNABLE状态进入 WAITING 状态。如果希望任务出现异常后仍然继续执行后续任务，可以在任务内部捕获异常，并处理异常后继续执行。</p>

<p>使用 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法关闭线程池时，会等待已提交的任务（包括正在执行的任务和还未开始执行的任务）全部执行完成，然后关闭线程池。</p>

<p>如果某个定时任务的第一次执行时间点尚未到达，而在此之前调用了 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法，那么这个定时任务<strong>将不会被执行</strong>。这是因为 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法会等待正在执行的任务完成，而尚未开始执行的任务会被取消。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ScheduledExecutorService</span> <span class="n">ses</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">ses</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始"</span><span class="o">+</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
<span class="o">},</span> <span class="mi">1000</span><span class="o">,</span> <span class="mi">1000</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">999</span><span class="o">);</span>
<span class="c1">// 关闭线程池:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>
<p>如果 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法调用的时机在定时任务执行时，则定时任务会在执行完本次任务后关闭。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ScheduledExecutorService</span> <span class="n">ses</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">ses</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始"</span><span class="o">+</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
<span class="o">},</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">499</span><span class="o">);</span>
<span class="c1">// 关闭线程池:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>
<p>如果 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法调用的时机在定时任务间隔时（非第一次运行前的延迟），则定时任务会在间隔结束后再执行一次后关闭。这是因为 <code class="language-plaintext highlighter-rouge">shutdown()</code> 方法不会取消已经计划的下一次任务。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ScheduledExecutorService</span> <span class="n">ses</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newScheduledThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">ses</span><span class="o">.</span><span class="na">scheduleAtFixedRate</span><span class="o">(()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始"</span><span class="o">+</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
<span class="o">},</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1499</span><span class="o">);</span>
<span class="c1">// 关闭线程池:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>
<hr />

<p>除了继承自<code class="language-plaintext highlighter-rouge">ThreadPoolExecutor</code>的方法外，<code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code>还添加了以下方法：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code>：延迟执行<code class="language-plaintext highlighter-rouge">Callable</code>任务，并在任务完成后返回结果。返回一个<code class="language-plaintext highlighter-rouge">ScheduledFuture</code>表示该任务的未来结果。</li>
  <li><code class="language-plaintext highlighter-rouge">schedule(Runnable command, long delay, TimeUnit unit)</code>：延迟执行<code class="language-plaintext highlighter-rouge">Runnable</code>任务。返回一个<code class="language-plaintext highlighter-rouge">ScheduledFuture</code>表示该任务的未来结果。</li>
  <li><code class="language-plaintext highlighter-rouge">scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>：在每次执行结束后等待固定的延迟时间后再执行任务，即任务开始后，等待<code class="language-plaintext highlighter-rouge">initialDelay</code>后开始执行第一次任务，之后每次任务执行结束后再等待<code class="language-plaintext highlighter-rouge">delay</code>后执行下一次任务。返回一个<code class="language-plaintext highlighter-rouge">ScheduledFuture</code>表示该任务的未来结果。</li>
  <li><code class="language-plaintext highlighter-rouge">scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code>：按固定的频率执行任务，即任务开始后，等待<code class="language-plaintext highlighter-rouge">initialDelay</code>后开始执行第一次任务，之后每隔<code class="language-plaintext highlighter-rouge">period</code>执行一次。如果任务的执行时间超过<code class="language-plaintext highlighter-rouge">period</code>，则后续任务会立即执行，不会等待。返回一个<code class="language-plaintext highlighter-rouge">ScheduledFuture</code>表示该任务的未来结果。</li>
</ol>

<p>这些方法都是用于实现定时任务的调度。</p>
<h3 id="timer">Timer</h3>
<p>Java标准库还提供了一个<code class="language-plaintext highlighter-rouge">java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code class="language-plaintext highlighter-rouge">Timer</code>会对应一个<code class="language-plaintext highlighter-rouge">Thread</code>，所以，一个<code class="language-plaintext highlighter-rouge">Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code class="language-plaintext highlighter-rouge">Timer</code>，而一个<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>就可以调度多个定时任务，所以，完全可以用<code class="language-plaintext highlighter-rouge">ScheduledThreadPool</code>取代旧的<code class="language-plaintext highlighter-rouge">Timer</code>。</p>

<p><code class="language-plaintext highlighter-rouge">java.util.Timer</code>类也可以用于定期执行任务，但与<code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code>相比，<code class="language-plaintext highlighter-rouge">Timer</code>存在一些局限性和缺点。</p>

<p><strong><code class="language-plaintext highlighter-rouge">Timer</code>的特点：</strong></p>

<ol>
  <li><strong>单线程执行</strong>：<code class="language-plaintext highlighter-rouge">Timer</code>内部维护了一个线程，用于执行所有任务。如果某个任务执行时间过长，会影响后续任务的执行。</li>
  <li><strong>异常处理</strong>：<code class="language-plaintext highlighter-rouge">Timer</code>在执行任务时，如果任务抛出未捕获的异常，会导致<code class="language-plaintext highlighter-rouge">Timer</code>线程终止，影响后续任务的执行。</li>
  <li><strong>灵活性差</strong>：<code class="language-plaintext highlighter-rouge">Timer</code>的调度方式比较简单，无法灵活控制任务的执行方式。</li>
  <li><strong>不适合长期运行</strong>：由于<code class="language-plaintext highlighter-rouge">Timer</code>是单线程执行任务，长期运行的任务可能会影响其他任务的执行。</li>
</ol>

<p>示例代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Timer</span> <span class="n">timer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Timer</span><span class="o">();</span>
<span class="c1">// 1秒后执行一次性任务:</span>
<span class="n">timer</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimerTask</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一次性任务"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="mi">1000</span><span class="o">);</span>
<span class="c1">// 每隔3秒执行一次任务，任务开始后2秒再次执行：</span>
<span class="n">timer</span><span class="o">.</span><span class="na">schedule</span><span class="o">(</span><span class="k">new</span> <span class="nc">TimerTask</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"定时任务"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="mi">2000</span><span class="o">,</span> <span class="mi">3000</span><span class="o">);</span>
<span class="c1">// 10秒后终止</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
<span class="n">timer</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
</code></pre></div></div>
<p><strong>注意事项：</strong></p>
<ol>
  <li>使用<code class="language-plaintext highlighter-rouge">Timer</code>时要注意处理任务抛出的异常，避免影响<code class="language-plaintext highlighter-rouge">Timer</code>线程的执行。</li>
  <li>不适合需要高并发、长期运行的任务，建议使用<code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code>。</li>
</ol>

<p>总的来说，如果需要更灵活、可靠的任务调度机制，推荐使用<code class="language-plaintext highlighter-rouge">ScheduledThreadPoolExecutor</code>，而不是<code class="language-plaintext highlighter-rouge">Timer</code>类。</p>
<h2 id="future">Future</h2>
<p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口，就可以让线程池去执行：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Task</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">result</span> <span class="o">=</span> <span class="n">longTimeCalculation</span><span class="o">();</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个<code class="language-plaintext highlighter-rouge">Callable</code>接口，和<code class="language-plaintext highlighter-rouge">Runnable</code>接口比，它多了一个返回值：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Task</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">longTimeCalculation</span><span class="o">();</span> 
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>并且<code class="language-plaintext highlighter-rouge">Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>

<p>现在的问题是，如何获得异步执行的结果？</p>

<p>如果仔细看<code class="language-plaintext highlighter-rouge">ExecutorService.submit()</code>方法，可以看到，它返回了一个<code class="language-plaintext highlighter-rouge">Future</code>类型，一个<code class="language-plaintext highlighter-rouge">Future</code>类型的实例代表一个<strong>未来能获取结果</strong>的对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> 
<span class="c1">// 定义任务:</span>
<span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Task</span><span class="o">();</span>
<span class="c1">// 提交任务并获得Future:</span>
<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="c1">// 从Future获取异步执行返回的结果:</span>
<span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="c1">// 可能阻塞</span>
</code></pre></div></div>
<p>当提交一个<code class="language-plaintext highlighter-rouge">Callable</code>任务后，会同时获得一个<code class="language-plaintext highlighter-rouge">Future</code>对象，然后，在主线程某个时刻调用<code class="language-plaintext highlighter-rouge">Future</code>对象的<code class="language-plaintext highlighter-rouge">get()</code>方法，就可以获得异步执行的结果。在调用<code class="language-plaintext highlighter-rouge">get()</code>时，如果异步任务已经完成，就直接获得结果。如果异步任务还没有完成，那么<code class="language-plaintext highlighter-rouge">get()</code>会<strong>阻塞</strong>，直到任务完成后才返回结果。</p>

<p>示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ExecutorService</span> <span class="n">ses</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>
<span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=()-&gt;{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"你好"</span><span class="o">;</span>
<span class="o">};</span>
<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">=</span><span class="n">ses</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="c1">// 关闭线程池:</span>
<span class="n">ses</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</code></pre></div></div>
<hr />

<p>一个<code class="language-plaintext highlighter-rouge">Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，即表示一个异步计算的结果。它定义了以下方法：</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">boolean cancel(boolean mayInterruptIfRunning)</code>：尝试取消任务的执行。如果任务已经完成、已经被取消或者由于某些原因不能取消，则此尝试将失败，返回 <code class="language-plaintext highlighter-rouge">false</code>。如果取消成功，并且任务尚未开始执行，则任务不应该运行。如果任务已经开始执行，则应该中断任务的执行。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isCancelled()</code>：如果任务已经被取消，则返回 true。</li>
  <li><code class="language-plaintext highlighter-rouge">boolean isDone()</code>：如果任务已经完成（无论是正常完成、取消还是由于执行过程中出现异常），则返回 true。</li>
  <li><code class="language-plaintext highlighter-rouge">V get()</code>：等待计算完成，然后返回其结果。</li>
  <li><code class="language-plaintext highlighter-rouge">V get(long timeout, TimeUnit unit)</code>：等待计算完成，最多等待给定的时间。如果在超时时间内计算完成，则返回结果；如果超时，则抛出 <code class="language-plaintext highlighter-rouge">TimeoutException</code>。</li>
</ol>

<hr />

<p><strong>单独使用：</strong></p>

<p>步骤：</p>

<ol>
  <li>创建一个实现<code class="language-plaintext highlighter-rouge">Callable</code>的实现类</li>
  <li>实现<code class="language-plaintext highlighter-rouge">call</code>方法，将此线程需要执行的操作声明在call()中</li>
  <li>创建<code class="language-plaintext highlighter-rouge">Callable</code>接口实现类的对象</li>
  <li>将此<code class="language-plaintext highlighter-rouge">Callable</code>接口实现类的对象作为传递到<code class="language-plaintext highlighter-rouge">FutureTask</code>构造器中，创建<code class="language-plaintext highlighter-rouge">FutureTask</code>的对象</li>
  <li>将<code class="language-plaintext highlighter-rouge">FutureTask</code>的对象作为参数传递到<code class="language-plaintext highlighter-rouge">Thread</code>类的构造器中，创建<code class="language-plaintext highlighter-rouge">Thread</code>对象，并调用<code class="language-plaintext highlighter-rouge">start()</code></li>
  <li>获取<code class="language-plaintext highlighter-rouge">Callable</code>中<code class="language-plaintext highlighter-rouge">call</code>方法的返回值</li>
</ol>

<p>即：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=()-&gt;{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"你好"</span><span class="o">;</span>
<span class="o">};</span>
<span class="nc">FutureTask</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">futureTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FutureTask</span><span class="o">&lt;&gt;(</span><span class="n">task</span><span class="o">);</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">futureTask</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">futureTask</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>
<h2 id="completablefuture">CompletableFuture</h2>
<p>使用<code class="language-plaintext highlighter-rouge">Future</code>获得异步执行结果时，要么调用阻塞方法<code class="language-plaintext highlighter-rouge">get()</code>，要么轮询看<code class="language-plaintext highlighter-rouge">isDone()</code>是否为<code class="language-plaintext highlighter-rouge">true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p>

<p>从<strong>Java 8</strong>开始引入了<code class="language-plaintext highlighter-rouge">CompletableFuture</code>，它针对<code class="language-plaintext highlighter-rouge">Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>

<p>以获取股票价格为例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 创建异步执行任务:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">cf</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(</span><span class="nl">Main:</span><span class="o">:</span><span class="n">fetchPrice</span><span class="o">);</span>
        <span class="c1">// 如果执行成功:</span>
        <span class="n">cf</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">((</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"price: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 如果执行异常:</span>
        <span class="n">cf</span><span class="o">.</span><span class="na">exceptionally</span><span class="o">((</span><span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="c1">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">200</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">Double</span> <span class="nf">fetchPrice</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mf">0.3</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"fetch price failed!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">5</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">20</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>创建一个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>是通过<code class="language-plaintext highlighter-rouge">CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code class="language-plaintext highlighter-rouge">Supplier</code>接口的对象：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这里用lambda语法简化了一下，直接传入<code class="language-plaintext highlighter-rouge">Main::fetchPrice</code>，因为<code class="language-plaintext highlighter-rouge">Main.fetchPrice()</code>静态方法的签名符合<code class="language-plaintext highlighter-rouge">Supplier</code>接口的定义（除了方法名外）。</p>

<p>紧接着，<code class="language-plaintext highlighter-rouge">CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code class="language-plaintext highlighter-rouge">CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code class="language-plaintext highlighter-rouge">CompletableFuture</code>会调用<code class="language-plaintext highlighter-rouge">Consumer</code>对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">accept</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>异常时，<code class="language-plaintext highlighter-rouge">CompletableFuture</code>会调用<code class="language-plaintext highlighter-rouge">Function</code>对象：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">R</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这里都用lambda语法简化了代码。</p>

<p>可见<code class="language-plaintext highlighter-rouge">CompletableFuture</code>的优点是：</p>

<ul>
  <li>异步任务结束时，会自动回调某个对象的方法；</li>
  <li>异步任务出错时，会自动回调某个对象的方法；</li>
  <li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>

<p>如果只是实现了异步回调机制，还看不出<code class="language-plaintext highlighter-rouge">CompletableFuture</code>相比<code class="language-plaintext highlighter-rouge">Future</code>的优势。<code class="language-plaintext highlighter-rouge">CompletableFuture</code>更强大的功能是，多个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>可以串行执行，例如，定义两个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>，第一个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>根据证券名称查询证券代码，第二个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>根据证券代码查询证券价格，这两个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>实现串行操作如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 第一个任务:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">cfQuery</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">queryCode</span><span class="o">(</span><span class="s">"中国石油"</span><span class="o">));</span>
        <span class="c1">// cfQuery成功后继续执行下一个任务:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">cfFetch</span> <span class="o">=</span> <span class="n">cfQuery</span><span class="o">.</span><span class="na">thenApplyAsync</span><span class="o">((</span><span class="n">code</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">fetchPrice</span><span class="o">(</span><span class="n">code</span><span class="o">));</span>
        <span class="c1">// cfFetch成功后打印结果:</span>
        <span class="n">cfFetch</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">((</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"price: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="nf">queryCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">"601857"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">Double</span> <span class="nf">fetchPrice</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">5</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">20</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>除了串行执行外，多个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p>

<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 两个CompletableFuture执行异步查询:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">cfQueryFromSina</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">queryCode</span><span class="o">(</span><span class="s">"中国石油"</span><span class="o">,</span> <span class="s">"https://finance.sina.com.cn/code/"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">cfQueryFrom163</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">queryCode</span><span class="o">(</span><span class="s">"中国石油"</span><span class="o">,</span> <span class="s">"https://money.163.com/code/"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 用anyOf合并为一个新的CompletableFuture:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">cfQuery</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span><span class="n">cfQueryFromSina</span><span class="o">,</span> <span class="n">cfQueryFrom163</span><span class="o">);</span>
        <span class="c1">// 两个CompletableFuture执行异步查询:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">cfFetchFromSina</span> <span class="o">=</span> <span class="n">cfQuery</span><span class="o">.</span><span class="na">thenApplyAsync</span><span class="o">((</span><span class="n">code</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">fetchPrice</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">code</span><span class="o">,</span> <span class="s">"https://finance.sina.com.cn/price/"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">cfFetchFrom163</span> <span class="o">=</span> <span class="n">cfQuery</span><span class="o">.</span><span class="na">thenApplyAsync</span><span class="o">((</span><span class="n">code</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">return</span> <span class="nf">fetchPrice</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">code</span><span class="o">,</span> <span class="s">"https://money.163.com/price/"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 用anyOf合并为一个新的CompletableFuture:</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">cfFetch</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span><span class="n">cfFetchFromSina</span><span class="o">,</span> <span class="n">cfFetchFrom163</span><span class="o">);</span>
        <span class="c1">// 最终结果:</span>
        <span class="n">cfFetch</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">((</span><span class="n">result</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"price: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="c1">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">200</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">String</span> <span class="nf">queryCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"query code from "</span> <span class="o">+</span> <span class="n">url</span> <span class="o">+</span> <span class="s">"..."</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">"601857"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">Double</span> <span class="nf">fetchPrice</span><span class="o">(</span><span class="nc">String</span> <span class="n">code</span><span class="o">,</span> <span class="nc">String</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"query price from "</span> <span class="o">+</span> <span class="n">url</span> <span class="o">+</span> <span class="s">"..."</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">((</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">100</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">5</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()</span> <span class="o">*</span> <span class="mi">20</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>除了<code class="language-plaintext highlighter-rouge">anyOf()</code>可以实现“任意个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>只要一个成功”，<code class="language-plaintext highlighter-rouge">allOf()</code>可以实现“所有<code class="language-plaintext highlighter-rouge">CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>

<p><code class="language-plaintext highlighter-rouge">CompletableFuture</code>类提供了许多方法来处理异步计算的结果或执行其他操作。以下是一些常用方法：</p>

<h3 id="异步执行指定的任务">异步执行指定的任务</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)</code>：在默认的 <code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code> 中<strong>异步执行</strong>指定的<code class="language-plaintext highlighter-rouge">Runnable</code>任务。</li>
  <li><code class="language-plaintext highlighter-rouge">static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)</code>：在<strong>指定</strong>的<code class="language-plaintext highlighter-rouge">Executor</code>线程池上异步执行<code class="language-plaintext highlighter-rouge">Runnable</code>任务。</li>
  <li><code class="language-plaintext highlighter-rouge">static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)</code>：异步执行指定的<code class="language-plaintext highlighter-rouge">Supplier</code>任务，<code class="language-plaintext highlighter-rouge">Supplier</code>任务需返回一个<strong>结果</strong>，该方法会<strong>返回一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>对象</strong>，该对象在<strong>计算完成时</strong>将<strong>返回</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code>：在<strong>指定</strong>的<code class="language-plaintext highlighter-rouge">Executor</code>线程池上异步执行<code class="language-plaintext highlighter-rouge">Supplier</code>任务，<code class="language-plaintext highlighter-rouge">Supplier</code>任务需返回一个结果，该方法会返回一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>对象，该对象在计算完成时将返回结果。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="执行完成">执行完成</h3>
<p><strong>上个任务执行完成时，再执行给定的方法</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenRun(Runnable action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，执行给定的方法。如果有多个<code class="language-plaintext highlighter-rouge">thenRun()</code>,则一个一个执行。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>地执行给定的方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法。</li>
</ul>

<p>示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span><span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);}</span>
        <span class="k">return</span> <span class="mi">10</span><span class="o">;</span>
    <span class="o">});</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRunAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRunAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="nc">ExecutorService</span> <span class="n">e</span><span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRunAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()),</span><span class="n">e</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">hi</span><span class="o">(</span><span class="nc">String</span> <span class="n">i</span><span class="o">){</span>
    <span class="k">try</span> <span class="o">{</span><span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"你好:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>你好:ForkJoinPool.commonPool-worker-1
你好:ForkJoinPool.commonPool-worker-2
你好:ForkJoinPool.commonPool-worker-3
你好:pool-1-thread-1
你好:ForkJoinPool.commonPool-worker-1
</code></pre></div></div>
<p>打印间隔为：1234行瞬间显示，行间隔1秒后5行显示。如果同时定义了同步和异步，则异步不管同步，而同步排队运行。<code class="language-plaintext highlighter-rouge">thenRun()</code>定义的匿名类实例方法始终在一个线程<code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool-worker-1</code>上执行。</p>

<p><strong>回调执行时机</strong></p>

<p><code class="language-plaintext highlighter-rouge">thenRun</code>执行的时候，如果任务<strong>没执行完</strong>就注册回调，则<strong>等待任务执行完</strong>再执行回调，如果任务已经执行完了就<strong>直接执行回调</strong>，后续的所有等待<code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时都是这个逻辑。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我是主线程"</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRunAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="n">stage</span><span class="o">.</span><span class="na">thenRunAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">hi</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getName</span><span class="o">()));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"我是主线程"</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="kt">void</span> <span class="nf">hi</span><span class="o">(</span><span class="nc">String</span> <span class="n">i</span><span class="o">){</span>
    <span class="k">try</span> <span class="o">{</span><span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"你好:"</span><span class="o">+</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">你好:</span><span class="n">main</span>
<span class="nl">你好:</span><span class="n">main</span>
<span class="n">我是主线程</span>
<span class="n">我是主线程</span>
<span class="nl">你好:</span><span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">1</span>
<span class="nl">你好:</span><span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">-</span><span class="n">worker</span><span class="o">-</span><span class="mi">2</span>
</code></pre></div></div>
<p>打印间隔为1先显示，间隔1秒之后2、3、4行瞬间显示，隔1秒之后5、6行瞬间显示。</p>

<p>因定义<code class="language-plaintext highlighter-rouge">thenRun()</code>时<code class="language-plaintext highlighter-rouge">supplyAsync()</code>已经执行完了，所以直接执行<code class="language-plaintext highlighter-rouge">thenRun()</code>内的方法了，<strong>而且</strong>执行的线程是主线程，并阻塞了主线程，在执行到<code class="language-plaintext highlighter-rouge">thenRunAsync()</code>后正常开线程异步执行。</p>

<p>将其<strong>结果</strong>传入给定的方法执行：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将其结果传入到给定的方法执行。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>执行给定的方法，并将结果传入该方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将结果传入该方法。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="n">stage</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
</code></pre></div></div>
<p>还<strong>返回结果</strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将其结果传入到给定的方法执行，给定的方法还需返回一个值。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>执行给定的方法，并将结果传入该方法，给定的方法还需返回一个值。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将结果传入该方法，给定的方法还需返回一个值。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">);</span>
<span class="n">stage2</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<p>还<strong>返回新的<code class="language-plaintext highlighter-rouge">CompletableFuture</code></strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将其结果传入到给定的方法执行，给定的方法还需<strong>返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code></strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>执行给定的方法，并将结果传入该方法，给定的方法还需返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将结果传入该方法，给定的方法还需返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="o">));</span>
<span class="n">stage2</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="执行异常">执行异常</h3>
<p><strong>上个任务执行异常时，再执行给定的操作</strong></p>

<p>对于异常，不存在类似<code class="language-plaintext highlighter-rouge">thenRun()</code>的不传参的方法，也不存在类似<code class="language-plaintext highlighter-rouge">thenAccept()</code>的无返回值的方法。这是因为在处理异常时，需要访问异常信息（Throwable）。</p>

<p>将其<strong>异常</strong>传入给定的方法执行：</p>

<p>还<strong>返回结果</strong>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)</code>：当 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 遇到<strong>异常</strong>时，将异常传入到给定的方法执行，给定的方法还需<strong>返回一个值</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; exceptionallyAsync(Function&lt;Throwable,? extends T&gt; fn)</code>：当 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 遇到异常时，<strong>异步</strong>执行给定的方法，并将异常传入该方法，给定的方法还需返回一个值。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; exceptionallyAsync(Function&lt;Throwable,? extends T&gt; fn, Executor executor)</code>：当 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 遇到异常时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将异常传入该方法，给定的方法还需返回一个值。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextFloat</span><span class="o">()&lt;</span><span class="mf">0.99</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"异常"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">});</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">exc</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">throwable</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">throwable</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">});</span>
<span class="n">exc</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<p>还<strong>返回新的<code class="language-plaintext highlighter-rouge">CompletableFuture</code></strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; exceptionallyCompose(Function&lt;Throwable,? extends CompletionStage&lt;T&gt;&gt; fn)</code>：当 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 遇到异常时，将异常传入到给定的方法执行，给定的方法还需<strong>返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code></strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; exceptionallyComposeAsync(Function&lt;Throwable,? extends CompletionStage&lt;T&gt;&gt; fn)</code>：当 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 遇到异常时，<strong>异步</strong>执行给定的方法，并将异常传入该方法，给定的方法还需返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; exceptionallyComposeAsync(Function&lt;Throwable,? extends CompletionStage&lt;T&gt;&gt; fn,Executor executor)</code>：当 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 遇到异常时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将异常传入该方法，给定的方法还需返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextFloat</span><span class="o">()&lt;</span><span class="mf">0.99</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"异常"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">});</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">exc</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">exceptionallyCompose</span><span class="o">(</span><span class="n">throwable</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">throwable</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="k">return</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()-&gt;</span> <span class="mi">2</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">exc</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>

<hr />

<h3 id="执行完成或异常">执行完成或异常</h3>
<p><strong>上个任务执行完成或异常时，再执行给定的操作</strong></p>

<p>同样的对于异常，不存在类似<code class="language-plaintext highlighter-rouge">thenRun()</code>的不传参的方法，但是存在类似<code class="language-plaintext highlighter-rouge">thenAccept()</code>的无返回值的方法，即<code class="language-plaintext highlighter-rouge">whenComplete()</code>。</p>

<p>将其<strong>异常</strong>与<strong>结果</strong>传入给定的方法执行：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将<strong>结果和异常</strong>传入到给定的方法执行。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>执行给定的方法，并将结果和异常传入该方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将结果和异常传入该方法。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextFloat</span><span class="o">()&lt;</span><span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"异常"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">});</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">integer</span><span class="o">,</span> <span class="n">throwable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">throwable</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有异常"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integer</span><span class="o">);</span>
    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
        <span class="n">throwable</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div>
<p>这里返回值不是<code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt;</code>，是<code class="language-plaintext highlighter-rouge">CompletableFuture&lt;T&gt;</code>，其结果和 <code class="language-plaintext highlighter-rouge">stage1</code> 的结果相同，不是同一个对象。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextFloat</span><span class="o">()&lt;</span><span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"异常"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">stage1</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integerCompletionStage</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">integer</span><span class="o">,</span> <span class="n">throwable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">throwable</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有异常"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integer</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">throwable</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integerCompletionStage</span><span class="o">);</span>
<span class="n">integerCompletionStage</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">integerCompletionStage</span><span class="o">.</span><span class="na">exceptionally</span><span class="o">(</span><span class="n">e</span><span class="o">-&gt;{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">});</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.util.concurrent.CompletableFuture@7cd84586[Not completed]
没有异常  
10
java.util.concurrent.CompletableFuture@1e80bfe8[Completed normally]
10
</code></pre></div></div>
<p>还<strong>返回结果</strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将<strong>结果和异常</strong>传入到给定的方法执行，给定的方法还需<strong>返回一个值</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>执行给定的方法，并将结果和异常传入该方法，给定的方法还需返回一个值。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T,Throwable,? extends U&gt; fn, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池，异步执行给定的方法，并将结果和异常传入该方法，给定的方法还需返回一个值。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Random</span><span class="o">().</span><span class="na">nextFloat</span><span class="o">()&lt;</span><span class="mf">0.5</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"异常"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">});</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">handle</span><span class="o">((</span><span class="n">integer</span><span class="o">,</span> <span class="n">throwable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">throwable</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"没有异常"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">integer</span><span class="o">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">throwable</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">handle</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="与操作">与操作</h3>
<p>两个任务都执行完成时，再执行给定的方法。</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other, Runnable action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，执行给定的方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，异步地执行给定的方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">runAfterBoth</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>
<p>还将其的<strong>两个结果</strong>传入到给定的方法执行：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，将<strong>两个结果</strong>传入到给定的方法执行。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，<strong>异步</strong>地执行给定的方法，并将两个结果传入该方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法，并将两个结果传入该方法。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">thenAcceptBoth</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">));</span>
<span class="o">});</span>
</code></pre></div></div>
<p><strong>还返回结果：</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U,? extends V&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> <strong>和</strong>另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> <strong>都</strong>完成时，将<strong>两个结果</strong>传入到给定的方法执行，给定的方法还需<strong>返回一个值</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U,? extends V&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，<strong>异步</strong>地执行给定的方法，并将两个结果传入该方法，给定的方法还需<strong>返回一个值</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U,? extends V&gt; action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 和另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法，并将两个结果传入该方法，给定的方法还需<strong>返回一个值</strong>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage3</span> <span class="o">=</span> <span class="n">stage1</span><span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span> <span class="nl">Integer:</span><span class="o">:</span><span class="n">sum</span><span class="o">);</span>
<span class="n">stage3</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="或操作">或操作</h3>
<p>两个任务中有一个执行完成时，就执行给定的方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other, Runnable action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，执行给定的方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，异步地执行给定的方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other, Runnable action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">runAfterEither</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"执行"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>
<p>也将<strong>结果</strong>传入方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> <strong>或</strong>另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将结果传入到给定的方法执行。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>地执行给定的方法，并将结果传入到给定的方法。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法，并将结果传入到给定的方法。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">acceptEither</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>
<p><strong>还返回结果</strong>：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> <strong>或</strong>另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，将结果传入到给定的方法执行，给定的方法还需<strong>返回一个值</strong>。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，<strong>异步</strong>地执行给定的方法，并将结果传入到给定的方法，给定的方法还需返回一个值。</li>
  <li><code class="language-plaintext highlighter-rouge">CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor)</code>：当此 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 或另一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，使用<strong>指定</strong>的 <code class="language-plaintext highlighter-rouge">Executor</code> 线程池异步地运行给定的方法，并将结果传入到给定的方法，给定的方法还需返回一个值。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletionStage</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">applyToEither</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">);</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="合并操作">合并操作</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</code>：返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，当所有传入的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 都完成时，它也会完成。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">allOf</span><span class="o">(</span><span class="n">stage1</span><span class="o">,</span> <span class="n">stage2</span><span class="o">);</span>
<span class="n">all</span><span class="o">.</span><span class="na">thenRun</span><span class="o">(()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"两个都执行完了"</span><span class="o">);</span>
<span class="o">});</span>
<span class="c1">// 相当于：</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">runAfterBoth</span><span class="o">(</span><span class="n">stage2</span><span class="o">,()-&gt;{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"两个都执行完了"</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</code>：返回一个新的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，当<strong>任意</strong>一个传入的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 完成时，它也会完成，并<strong>返回</strong>完成的 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 的<strong>结果</strong>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage1</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stage2</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">20</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">all</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">anyOf</span><span class="o">(</span><span class="n">stage1</span><span class="o">,</span> <span class="n">stage2</span><span class="o">);</span>
<span class="n">all</span><span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
<span class="c1">// 相当于：</span>
<span class="n">stage1</span><span class="o">.</span><span class="na">acceptEither</span><span class="o">(</span><span class="n">stage2</span><span class="o">,</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="总结">总结</h3>
<p><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的方法命名规律如下：</p>
<ol>
  <li>方法名以<code class="language-plaintext highlighter-rouge">then</code>开头，表示该方法会在当前<code class="language-plaintext highlighter-rouge">CompletableFuture</code><strong>完成后</strong>执行。</li>
  <li>方法名以<code class="language-plaintext highlighter-rouge">Run</code>开头，表示该方法会<strong>执行</strong>一个<code class="language-plaintext highlighter-rouge">Runnable</code>而<strong>不返回</strong>结果。</li>
  <li>方法名以<code class="language-plaintext highlighter-rouge">Accept</code>开头，表示该方法会<strong>接受</strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<strong>结果</strong>，传入回调，但回调<strong>不返回</strong>结果。</li>
  <li>方法名以<code class="language-plaintext highlighter-rouge">Apply</code>开头，表示该方法会<strong>接受</strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<strong>结果</strong>，传入回调，回调需返回一个<strong>结果</strong>，该方法会返回一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Compose</code>，表示该方法会<strong>接受</strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<strong>结果</strong>，传入回调，回调需返回一个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Async</code>，表示该方法会<strong>异步执行</strong>。</li>
  <li>方法名以<code class="language-plaintext highlighter-rouge">exceptionally</code>开头，表示该方法会<strong>接受</strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<strong>异常</strong>，并<strong>返回</strong>一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Complete</code>，表示该方法会<strong>接受</strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<strong>异常和结果</strong>，传入回调执行，但回调<strong>不返回</strong>结果。</li>
  <li>方法名以<code class="language-plaintext highlighter-rouge">handle</code>开头，表示该方法会<strong>接受</strong><code class="language-plaintext highlighter-rouge">CompletableFuture</code>的<strong>异常和结果</strong>，传入回调执行，回调需返回一个结果，该方法会返回一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Both</code>，表示该方法会等待两个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>都完成才执行回调。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Combine</code>，表示该方法会等待两个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>都完成才执行回调，并接收它们两个的结果，传入回调，回调需返回一个结果，该方法会返回一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Either</code>，表示该方法会等待两个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>任意一个完成就执行回调。</li>
  <li>方法名以<code class="language-plaintext highlighter-rouge">applyToEither</code>开头，表示该方法会等待两个<code class="language-plaintext highlighter-rouge">CompletableFuture</code>任意一个完成就执行回调，并将那一个结果，传入回调，回调需返回一个结果，该方法会返回一个包含结果的<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
  <li>方法名包含<code class="language-plaintext highlighter-rouge">Of</code>，表示该方法是一个静态工厂方法，用于创建<code class="language-plaintext highlighter-rouge">CompletableFuture</code>。</li>
</ol>

<h2 id="forkjoin">ForkJoin</h2>
<p><strong>Java 7</strong>开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>

<p>如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p>

<pre><code class="language-ascii">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
</code></pre>
<p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p>
<pre><code class="language-ascii">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
</code></pre>
<p>如果拆成两部分还是很大，还可以继续拆，用4个线程并行执行：</p>
<pre><code class="language-ascii">┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
</code></pre>
<p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>

<p>使用Fork/Join对大数据进行并行求和：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.concurrent.*</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 创建2000个随机数组成的数组:</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">2000</span><span class="o">];</span>
        <span class="kt">long</span> <span class="n">expectedSum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">();</span>
            <span class="n">expectedSum</span> <span class="o">+=</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Expected sum: "</span> <span class="o">+</span> <span class="n">expectedSum</span><span class="o">);</span>
        <span class="c1">// fork/join:</span>
        <span class="nc">ForkJoinTask</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">Long</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">().</span><span class="na">invoke</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Fork/join sum: "</span> <span class="o">+</span> <span class="n">result</span> <span class="o">+</span> <span class="s">" in "</span> <span class="o">+</span> <span class="o">(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="o">)</span> <span class="o">+</span> <span class="s">" ms."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kt">long</span> <span class="nf">random</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SumTask</span> <span class="kd">extends</span> <span class="nc">RecursiveTask</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THRESHOLD</span> <span class="o">=</span> <span class="mi">500</span><span class="o">;</span>
    <span class="kt">long</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
    <span class="nc">SumTask</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="nc">Long</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="no">THRESHOLD</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 如果任务足够小,直接计算:</span>
            <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="k">this</span><span class="o">.</span><span class="na">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="c1">// 故意放慢计算速度:</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 任务太大,一分为二:</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="o">(</span><span class="n">end</span> <span class="o">+</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"split %d~%d ==&gt; %d~%d, %d~%d"</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">middle</span><span class="o">,</span> <span class="n">middle</span><span class="o">,</span> <span class="n">end</span><span class="o">));</span>
        <span class="nc">SumTask</span> <span class="n">subtask1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">array</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">middle</span><span class="o">);</span>
        <span class="nc">SumTask</span> <span class="n">subtask2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">array</span><span class="o">,</span> <span class="n">middle</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="n">invokeAll</span><span class="o">(</span><span class="n">subtask1</span><span class="o">,</span> <span class="n">subtask2</span><span class="o">);</span>
        <span class="nc">Long</span> <span class="n">subresult1</span> <span class="o">=</span> <span class="n">subtask1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">Long</span> <span class="n">subresult2</span> <span class="o">=</span> <span class="n">subtask2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">Long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">subresult1</span> <span class="o">+</span> <span class="n">subresult2</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"result = "</span> <span class="o">+</span> <span class="n">subresult1</span> <span class="o">+</span> <span class="s">" + "</span> <span class="o">+</span> <span class="n">subresult2</span> <span class="o">+</span> <span class="s">" ==&gt; "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Expected sum: 9788366
split 0~2000 ==&gt; 0~1000, 1000~2000
split 0~1000 ==&gt; 0~500, 500~1000
split 1000~2000 ==&gt; 1000~1500, 1500~2000
result = 2485485 + 2491717 ==&gt; 4977202
result = 2391591 + 2419573 ==&gt; 4811164
result = 4811164 + 4977202 ==&gt; 9788366
Fork/join sum: 9788366 in 1035 ms.
</code></pre></div></div>
<p>一个大的计算任务0~2000首先分裂为两个小任务0~1000和1000~2000，这两个小任务仍然太大，继续分裂为更小的0~500，500~1000，1000~1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>

<p>核心代码<code class="language-plaintext highlighter-rouge">SumTask</code>继承自<code class="language-plaintext highlighter-rouge">RecursiveTask</code>，在<code class="language-plaintext highlighter-rouge">compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SumTask</span> <span class="kd">extends</span> <span class="nc">RecursiveTask</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">Long</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// “分裂”子任务:</span>
        <span class="nc">SumTask</span> <span class="n">subtask1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(...);</span>
        <span class="nc">SumTask</span> <span class="n">subtask2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SumTask</span><span class="o">(...);</span>
        <span class="c1">// invokeAll会并行运行两个子任务:</span>
        <span class="n">invokeAll</span><span class="o">(</span><span class="n">subtask1</span><span class="o">,</span> <span class="n">subtask2</span><span class="o">);</span>
        <span class="c1">// 获得子任务的结果:</span>
        <span class="nc">Long</span> <span class="n">subresult1</span> <span class="o">=</span> <span class="n">subtask1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">Long</span> <span class="n">subresult2</span> <span class="o">=</span> <span class="n">subtask2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="c1">// 汇总结果:</span>
        <span class="k">return</span> <span class="n">subresult1</span> <span class="o">+</span> <span class="n">subresult2</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的<code class="language-plaintext highlighter-rouge">java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>

<p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</p>

<p><code class="language-plaintext highlighter-rouge">ForkJoinPool</code>线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自<code class="language-plaintext highlighter-rouge">RecursiveTask</code>或<code class="language-plaintext highlighter-rouge">RecursiveAction</code>。使用Fork/Join模式可以进行并行计算以提高效率。</p>

<p><code class="language-plaintext highlighter-rouge">commonPool()</code>方法的线程数量，实际上是CPU的核数减1，如果自己创建就是自己指定的值；</p>

<p><code class="language-plaintext highlighter-rouge">ForkJoinPool</code>在单核机器上会挂起，通过设置属性可以临时解决：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-Djava</span>.util.concurrent.ForkJoinPool.common.parallelism<span class="o">=</span>1
</code></pre></div></div>
<p>或者在<code class="language-plaintext highlighter-rouge">main()</code>的第一行开始写</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">availableProcessors</span><span class="o">()&lt;=</span><span class="mi">1</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"java.util.concurrent.ForkJoinPool.common.parallelism"</span><span class="o">,</span><span class="s">"1"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<hr />

<p><strong>常用的方法：</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code>：返回一个共享的 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> 实例，用于执行并行任务。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool.submit(ForkJoinTask&lt;?&gt; task)</code>：提交一个 <code class="language-plaintext highlighter-rouge">ForkJoinTask</code> 任务给线程池执行，并返回一个 <code class="language-plaintext highlighter-rouge">Future</code> 对象，用于获取任务的结果或取消任务。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool.execute(ForkJoinTask&lt;?&gt; task)</code>：立即执行给定的 <code class="language-plaintext highlighter-rouge">ForkJoinTask</code>，不返回任何结果。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.join()</code>：阻塞当前线程直到任务完成，并返回任务的结果。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.fork()</code>：将任务放入工作队列，允许它在另一个线程上执行。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.invoke()</code>：同步执行任务，并返回任务的结果。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.invokeAll(Collection&lt;? extends ForkJoinTask&lt;T&gt;&gt; tasks)</code>：同步执行给定的任务集合，并返回包含所有任务结果的列表。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.isDone()</code>：检查任务是否已经完成。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.isCancelled()</code>：检查任务是否已经被取消。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinTask.cancel(boolean mayInterruptIfRunning)</code>：尝试取消任务的执行。</li>
</ul>

<p><strong>常用的构造方法：</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool()</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code>，使用默认的线程数和参数。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool(int parallelism)</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code>，指定并行度（即线程数）。通常，线程数等于处理器的数量。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool(int parallelism, ForkJoinPool.ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode)</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code>，允许指定线程数、线程工厂、异常处理器和是否使用异步模式。</li>
  <li><code class="language-plaintext highlighter-rouge">ForkJoinPool(int parallelism, ForkJoinPool.ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode, int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, ForkJoinPool.ForkJoinWorkerThreadFactory hook, boolean system, int mode)</code>：更加灵活的构造方法，允许指定线程数、线程工厂、异常处理器、异步模式、核心池大小、最大池大小、线程保持活跃时间、时间单位、钩子、是否为系统线程以及模式。</li>
</ol>

<h2 id="threadlocal">ThreadLocal</h2>
<p><code class="language-plaintext highlighter-rouge">Thread</code>对象代表一个线程，可以在代码中调用<code class="language-plaintext highlighter-rouge">Thread.currentThread()</code>获取当前线程。<br />
对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">checkPermission</span><span class="o">();</span>
    <span class="n">doWork</span><span class="o">();</span>
    <span class="n">saveStatus</span><span class="o">();</span>
    <span class="n">sendResponse</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>然后，通过线程池去执行这些任务。<code class="language-plaintext highlighter-rouge">process()</code>方法，内部需要调用若干其他方法，如何在一个线程内传递状态？</p>

<p><code class="language-plaintext highlighter-rouge">process()</code>方法需要传递的状态就是<code class="language-plaintext highlighter-rouge">User</code>实例。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">process</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">checkPermission</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="n">doWork</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="n">saveStatus</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="n">sendResponse</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>但是往往一个方法又会调用其他很多方法，这样会导致<code class="language-plaintext highlighter-rouge">User</code>传递到所有地方：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">doWork</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">queryStatus</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="n">checkStatus</span><span class="o">();</span>
    <span class="n">setNewStatus</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="n">log</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这种在一个线程中，横跨若干方法调用，需要传递的对象，通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</p>

<p>给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，<code class="language-plaintext highlighter-rouge">User</code>对象就传不进去了。</p>

<p>Java标准库提供了一个特殊的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>，它可以在一个线程中传递同<strong>一个</strong>对象。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadLocal</code>实例通常总是以静态字段初始化如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">threadLocalUser</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>它的典型使用方式如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">processUser</span><span class="o">(</span><span class="n">user</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
        <span class="n">step1</span><span class="o">();</span>
        <span class="n">step2</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>通过设置一个<code class="language-plaintext highlighter-rouge">User</code>实例关联到<code class="language-plaintext highlighter-rouge">ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code class="language-plaintext highlighter-rouge">User</code>实例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">step1</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">u</span> <span class="o">=</span> <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="n">log</span><span class="o">();</span>
    <span class="n">printUser</span><span class="o">();</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">log</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">u</span> <span class="o">=</span> <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="n">println</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">step2</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">User</span> <span class="n">u</span> <span class="o">=</span> <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="n">checkUser</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="na">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>普通的方法调用一定是同一个线程执行的，所以，<code class="language-plaintext highlighter-rouge">step1()</code>、<code class="language-plaintext highlighter-rouge">step2()</code>以及<code class="language-plaintext highlighter-rouge">log()</code>方法内，<code class="language-plaintext highlighter-rouge">threadLocalUser.get()</code>获取的<code class="language-plaintext highlighter-rouge">User</code>对象是同一个实例。</p>

<p>实际上，可以把<code class="language-plaintext highlighter-rouge">ThreadLocal</code>看成一个全局<code class="language-plaintext highlighter-rouge">Map&lt;Thread, Object&gt;</code>：每个线程获取<code class="language-plaintext highlighter-rouge">ThreadLocal</code>变量时，总是使用<code class="language-plaintext highlighter-rouge">Thread</code>自身作为key：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">threadLocalValue</span> <span class="o">=</span> <span class="n">threadLocalMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
</code></pre></div></div>
<p>因此，<code class="language-plaintext highlighter-rouge">ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>关联的实例互不干扰。</p>

<p>最后，特别注意<code class="language-plaintext highlighter-rouge">ThreadLocal</code>一定要在<code class="language-plaintext highlighter-rouge">finally</code>中清除：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">...</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">threadLocalUser</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code class="language-plaintext highlighter-rouge">ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>

<p>为了保证能释放<code class="language-plaintext highlighter-rouge">ThreadLocal</code>关联的实例，可以通过<code class="language-plaintext highlighter-rouge">AutoCloseable</code>接口配合<code class="language-plaintext highlighter-rouge">try (resource) {...}</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>可以封装为一个<code class="language-plaintext highlighter-rouge">UserContext</code>对象：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserContext</span> <span class="kd">implements</span> <span class="nc">AutoCloseable</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadLocal</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nf">UserContext</span><span class="o">(</span><span class="nc">String</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">currentUser</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">ctx</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用的时候，借助<code class="language-plaintext highlighter-rouge">try (resource) {...}</code>结构，可以这么写：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">(</span><span class="kt">var</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UserContext</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">))</span> <span class="o">{</span>
    <span class="c1">// 可任意调用UserContext.currentUser():</span>
    <span class="nc">String</span> <span class="n">currentUser</span> <span class="o">=</span> <span class="nc">UserContext</span><span class="o">.</span><span class="na">currentUser</span><span class="o">();</span>
<span class="o">}</span> <span class="c1">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span>
</code></pre></div></div>
<p>这样就在<code class="language-plaintext highlighter-rouge">UserContext</code>中完全封装了<code class="language-plaintext highlighter-rouge">ThreadLocal</code>，外部代码在<code class="language-plaintext highlighter-rouge">try (resource) {...}</code>内部可以随时调用<code class="language-plaintext highlighter-rouge">UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>

<p><code class="language-plaintext highlighter-rouge">ThreadLocal</code>表示线程的“局部变量”，它确保每个线程的<code class="language-plaintext highlighter-rouge">ThreadLocal</code>变量都是各自独立的；</p>

<p><code class="language-plaintext highlighter-rouge">ThreadLocal</code>适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p>

<p>使用<code class="language-plaintext highlighter-rouge">ThreadLocal</code>要用<code class="language-plaintext highlighter-rouge">try ... finally</code>结构，并在<code class="language-plaintext highlighter-rouge">finally</code>中清除。</p>

<p>实际上<code class="language-plaintext highlighter-rouge">ThreadLocal</code>本身不会存储任何数据，<code class="language-plaintext highlighter-rouge">ThreadLocal.set</code>方法是将值存储到<code class="language-plaintext highlighter-rouge">Thread</code>线程本身的<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>里面了。如果线程执行完毕就死亡了，实时上是不需要调用<code class="language-plaintext highlighter-rouge">ThreadLocal</code>的<code class="language-plaintext highlighter-rouge">remove</code>方法的。因为<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>是属于线程对象的，线程都死亡了，<code class="language-plaintext highlighter-rouge">ThreadLocalMap</code>里面存的值自然就不存在了。但是，真正的项目开发中基本上都是从线程池里面获取线程的，所以线程执行完<strong>并不会死亡</strong>，而是会被线程池复用。</p>

<h2 id="虚拟线程">虚拟线程</h2>
<p>虚拟线程（Virtual Thread）是<strong>Java 19</strong>引入的一种轻量级线程，它在很多其他语言中被称为协程、纤程、绿色线程、用户态线程等。</p>

<p>在理解虚拟线程前，先回顾一下线程的特点：</p>

<ul>
  <li>线程是由操作系统创建并调度的资源；</li>
  <li>线程切换会耗费大量CPU时间；</li>
  <li>一个系统能同时调度的线程数量是有限的，通常在几百至几千级别。</li>
</ul>

<p>因此，说线程是一种重量级资源。在服务器端，对用户请求，通常都实现为一个线程处理一个请求。由于用户的请求数往往远超操作系统能同时调度的线程数量，所以通常使用线程池来尽量减少频繁创建和销毁线程的成本。</p>

<p>对于需要处理大量IO请求的任务来说，使用线程是低效的，因为一旦读写IO，线程就必须进入等待状态，直到IO数据返回。常见的IO操作包括：</p>

<ul>
  <li>读写文件；</li>
  <li>读写网络，例如HTTP请求；</li>
  <li>读写数据库，本质上是通过JDBC实现网络调用。</li>
</ul>

<p>一个处理HTTP请求的线程，它在读写网络、文件的时候就会进入等待状态：</p>
<pre><code class="language-ascii">Begin
────────
Blocking ──▶ Read HTTP Request
Wait...
Wait...
Wait...
────────
Running
────────
Blocking ──▶ Read Config File
Wait...
────────
Running
────────
Blocking ──▶ Read Database
Wait...
Wait...
Wait...
────────
Running
────────
Blocking ──▶ Send HTTP Response
Wait...
Wait...
────────
End
</code></pre>
<p>真正由CPU执行的代码消耗的时间非常少，线程的大部分时间都在等待IO。我们把这类任务称为IO密集型任务。</p>

<p>为了能高效执行IO密集型任务，Java从<strong>19</strong>开始引入了虚拟线程。虚拟线程的接口和普通线程是一样的，但是执行方式不一样。虚拟线程不是由操作系统调度，而是由普通线程调度，即成百上千个虚拟线程可以由一个普通线程调度。任何时刻，只能执行一个虚拟线程，但是，一旦该虚拟线程执行一个IO操作进入等待时，它会被立刻“挂起”，然后执行下一个虚拟线程。什么时候IO数据返回了，这个挂起的虚拟线程才会被再次调度。因此，若干个虚拟线程可以在一个普通线程中交替运行：</p>

<pre><code class="language-ascii">Begin
───────────
V1 Runing
V1 Blocking ──▶ Read HTTP Request
───────────
V2 Runing
V2 Blocking ──▶ Read HTTP Request
───────────
V3 Runing
V3 Blocking ──▶ Read HTTP Request
───────────
V1 Runing
V1 Blocking ──▶ Read Config File
───────────
V2 Runing
V2 Blocking ──▶ Read Database
───────────
V1 Runing
V1 Blocking ──▶ Read Database
───────────
V3 Runing
V3 Blocking ──▶ Read Database
───────────
V2 Runing
V2 Blocking ──▶ Send HTTP Response
───────────
V1 Runing
V1 Blocking ──▶ Send HTTP Response
───────────
V3 Runing
V3 Blocking ──▶ Send HTTP Response
───────────
End
</code></pre>
<p>如果单独看一个虚拟线程的代码，在一个方法中：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">register</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">readConfigFile</span><span class="o">(</span><span class="s">"./config.json"</span><span class="o">);</span> <span class="c1">// #1</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">useFullName</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="na">firstName</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">req</span><span class="o">.</span><span class="na">lastName</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">insertInto</span><span class="o">(</span><span class="n">db</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span> <span class="c1">// #2</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">cache</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">redis</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span> <span class="c1">// #3</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>涉及到IO读写的#1、#2、#3处，执行到这些地方的时候（进入相关的JNI方法内部时）会自动挂起，并切换到其他虚拟线程执行。等到数据返回后，当前虚拟线程会再次调度并执行，因此，代码看起来是同步执行，但实际上是异步执行的。</p>

<p><strong>使用虚拟线程</strong>
虚拟线程的接口和普通线程一样，唯一区别在于创建虚拟线程只能通过特定方法。</p>

<p>方法一：直接创建虚拟线程并运行：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 传入Runnable实例并立刻运行:</span>
<span class="nc">Thread</span> <span class="n">vt</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">startVirtualThread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Start virtual thread..."</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"End virtual thread."</span><span class="o">);</span>
<span class="o">});</span>
</code></pre></div></div>
<p>方法二：创建虚拟线程但不自动运行，而是手动调用<code class="language-plaintext highlighter-rouge">start()</code>开始运行：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建VirtualThread:</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">().</span><span class="na">unstarted</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Start virtual thread..."</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"End virtual thread."</span><span class="o">);</span>
<span class="o">});</span>
<span class="c1">// 运行:</span>
<span class="n">vt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>
<p>方法三：通过虚拟线程的<code class="language-plaintext highlighter-rouge">ThreadFactory</code>创建虚拟线程，然后手动调用<code class="language-plaintext highlighter-rouge">start()</code>开始运行：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建ThreadFactory:</span>
<span class="nc">ThreadFactory</span> <span class="n">tf</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">().</span><span class="na">factory</span><span class="o">();</span>
<span class="c1">// 创建VirtualThread:</span>
<span class="nc">Thread</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="na">newThread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Start virtual thread..."</span><span class="o">);</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"End virtual thread."</span><span class="o">);</span>
<span class="o">});</span>
<span class="c1">// 运行:</span>
<span class="n">vt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div>
<p>直接调用<code class="language-plaintext highlighter-rouge">start()</code>实际上是由<code class="language-plaintext highlighter-rouge">ForkJoinPool</code>的线程来调度的。也可以自己创建调度线程，然后运行虚拟线程：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建调度器:</span>
<span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newVirtualThreadPerTaskExecutor</span><span class="o">();</span>
<span class="c1">// 创建大量虚拟线程并调度:</span>
<span class="nc">ThreadFactory</span> <span class="n">tf</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">ofVirtual</span><span class="o">().</span><span class="na">factory</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">Thread</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="na">newThread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">});</span>
    <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">vt</span><span class="o">);</span>
    <span class="c1">// 也可以直接传入Runnable或Callable:</span>
    <span class="n">executor</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Start virtual thread..."</span><span class="o">);</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"End virtual thread."</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由于虚拟线程属于非常轻量级的资源，因此，用时创建，用完就扔，不要池化虚拟线程。</p>

<p>最后注意，虚拟线程在<strong>Java 21</strong>正式发布，在<strong>Java 19/20</strong>是预览功能，默认关闭，需要添加参数<code class="language-plaintext highlighter-rouge">--enable-preview</code>启用：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">--source</span> 19 <span class="nt">--enable-preview</span> Main.java
</code></pre></div></div>
<p><strong>使用限制</strong></p>

<p>只有以虚拟线程方式运行的代码，才会在执行IO操作时自动被挂起并切换到其他虚拟线程。普通线程的IO操作仍然会等待，例如，我们在<code class="language-plaintext highlighter-rouge">main()</code>方法中读写文件，是不会有调度和自动挂起的。</p>

<p>可以自动引发调度切换的操作包括：</p>

<ul>
  <li>文件IO；</li>
  <li>网络IO；</li>
  <li>使用<code class="language-plaintext highlighter-rouge">Concurrent</code>库引发等待；</li>
  <li><code class="language-plaintext highlighter-rouge">Thread.sleep()</code>操作。</li>
</ul>

<p>这是因为JDK为了实现虚拟线程，已经对底层相关操作进行了修改，这样应用层的Java代码无需修改即可使用虚拟线程。无法自动切换的JavaScript语言需要用户手动调用<code class="language-plaintext highlighter-rouge">await</code>来实现异步操作：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">doWork</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">readFile</span><span class="p">();</span>
    <span class="k">await</span> <span class="nx">sendNetworkData</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在虚拟线程中，如果绕过JDK的IO接口，直接通过JNI读写文件或网络是无法实现调度的。此外，在<code class="language-plaintext highlighter-rouge">synchronized</code>块内部也无法调度。</p>

<p><strong>Java 19</strong>引入的虚拟线程是为了解决IO密集型任务的吞吐量，它可以高效通过少数线程去调度大量虚拟线程；</p>

<p>虚拟线程在执行到IO操作或Blocking操作时，会自动切换到其他虚拟线程执行，从而避免当前线程等待，能最大化线程的执行效率；</p>

<p>虚拟线程使用普通线程相同的接口，最大的好处是无需修改任何代码，就可以将现有的IO操作异步化获得更大的吞吐能力。</p>

<p>计算密集型任务不应使用虚拟线程，只能通过增加CPU核心解决，或者利用分布式计算资源。</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">加密与安全</title><link href="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/" rel="alternate" type="text/html" title="加密与安全" /><published>2024-04-14T00:00:00+08:00</published><updated>2024-04-14T00:00:00+08:00</updated><id>/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8</id><content type="html" xml:base="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"><![CDATA[<h1 id="引言">引言</h1>
<p>Base64编码、URL编码、哈希算法、对称加密算法、口令加密算法、 密钥交换算法、 非对称加密算法、签名算法、数字证书。</p>

<h1 id="加密与安全">加密与安全</h1>

<h2 id="编码">编码</h2>

<p>ASCII码就是一种编码，字母<code class="language-plaintext highlighter-rouge">A</code>的编码是十六进制的<code class="language-plaintext highlighter-rouge">0x41</code>，字母<code class="language-plaintext highlighter-rouge">B</code>是<code class="language-plaintext highlighter-rouge">0x42</code>，以此类推。因为ASCII编码最多只能有128个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code class="language-plaintext highlighter-rouge">0x4e2d</code>，使用UTF-8则需要3个字节编码。因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p>

<p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p>

<h3 id="url编码">URL编码</h3>

<p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分</p>

<p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p>

<ul>
  <li>如果字符是<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>，<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>，<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>以及<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">_</code>、<code class="language-plaintext highlighter-rouge">.</code>、<code class="language-plaintext highlighter-rouge">*</code>，则保持不变；</li>
  <li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code class="language-plaintext highlighter-rouge">%XX</code>表示。</li>
</ul>

<p>例如：字符<code class="language-plaintext highlighter-rouge">中</code>的UTF-8编码是<code class="language-plaintext highlighter-rouge">0xe4b8ad</code>，因此，它的URL编码是<code class="language-plaintext highlighter-rouge">%E4%B8%AD</code>。URL编码总是大写。</p>

<p>Java标准库提供了一个<code class="language-plaintext highlighter-rouge">URLEncoder</code>类来对任意字符串进行URL编码，而<code class="language-plaintext highlighter-rouge">URLDecoder则</code>可以解码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">URLEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="s">"中 文!"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span><span class="c1">//%E4%B8%AD+%E6%96%87%21</span>
<span class="nc">String</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nc">URLDecoder</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">encoded</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">decoded</span><span class="o">);</span><span class="c1">//中 文!</span>
</code></pre></div></div>

<p><strong>和标准的URL编码稍有不同，<code class="language-plaintext highlighter-rouge">URLEncoder</code>把空格字符编码成<code class="language-plaintext highlighter-rouge">+</code></strong>，而现在的URL编码标准要求空格被编码为<code class="language-plaintext highlighter-rouge">%20</code>，不过，服务器都可以处理这两种情况。</p>

<h3 id="base64编码">Base64编码</h3>

<p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>、<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>、<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>、<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个<code class="language-plaintext highlighter-rouge">int</code>整数表示，然后查表，把<code class="language-plaintext highlighter-rouge">int</code>整数用索引对应到字符，得到编码后的字符串。</p>

<p>举个例子：3个byte数据分别是<code class="language-plaintext highlighter-rouge">ff</code>、<code class="language-plaintext highlighter-rouge">e0</code>、<code class="language-plaintext highlighter-rouge">1</code>，按6bit分组得到<code class="language-plaintext highlighter-rouge">39</code>、<code class="language-plaintext highlighter-rouge">0b</code>、<code class="language-plaintext highlighter-rouge">22</code>和<code class="language-plaintext highlighter-rouge">2d</code>：</p>

<pre><code class="language-ascii">┌───────────────┬───────────────┬───────────────┐
│      ff       │      e0       │       1       │
└───────────────┴───────────────┴───────────────┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│1│1│1│1│1│1│1│1│1│0│0│0│0│0│0│0│0│0│0│0│0│1│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌───────────┬───────────┬───────────┬───────────┐
│    63     │    62     │     0     │     1     │
└───────────┴───────────┴───────────┴───────────┘
</code></pre>

<p>因为6位整数的范围总是<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">63</code>，所以，能用64个字符表示：字符<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>对应索引<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">25</code>，字符<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>对应索引<code class="language-plaintext highlighter-rouge">26</code>~<code class="language-plaintext highlighter-rouge">51</code>，字符<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>对应索引<code class="language-plaintext highlighter-rouge">52</code>~<code class="language-plaintext highlighter-rouge">61</code>，最后两个索引<code class="language-plaintext highlighter-rouge">62</code>、<code class="language-plaintext highlighter-rouge">63</code>分别用字符<code class="language-plaintext highlighter-rouge">+</code>和<code class="language-plaintext highlighter-rouge">/</code>表示。</p>

<p>所以对于<code class="language-plaintext highlighter-rouge">ff</code>、<code class="language-plaintext highlighter-rouge">e0</code>、<code class="language-plaintext highlighter-rouge">1</code>，首先变成：<code class="language-plaintext highlighter-rouge">63</code>、<code class="language-plaintext highlighter-rouge">62</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">1</code>，再根据表转换为：<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>。</p>

<p>如果输入的<code class="language-plaintext highlighter-rouge">byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code class="language-plaintext highlighter-rouge">0x00</code>，编码后，在结尾加一个<code class="language-plaintext highlighter-rouge">=</code>表示补充了1个<code class="language-plaintext highlighter-rouge">0x00</code>，加两个<code class="language-plaintext highlighter-rouge">=</code>表示补充了2个<code class="language-plaintext highlighter-rouge">0x00</code>，解码的时候，去掉末尾补充的一个或两个<code class="language-plaintext highlighter-rouge">0x00</code>即可。</p>

<p>实际上，因为编码后的长度加上<code class="language-plaintext highlighter-rouge">=</code>总是4的倍数，所以即使不加<code class="language-plaintext highlighter-rouge">=</code>也可以计算出原始输入的<code class="language-plaintext highlighter-rouge">byte[]</code>。Base64编码的时候<strong>可以</strong>用<code class="language-plaintext highlighter-rouge">withoutPadding()</code>去掉<code class="language-plaintext highlighter-rouge">=</code>，解码出来的结果是一样的。</p>

<p>在Java中，二进制数据就是<code class="language-plaintext highlighter-rouge">byte[]</code>数组。Java标准库提供了<code class="language-plaintext highlighter-rouge">Base64</code>来对<code class="language-plaintext highlighter-rouge">byte[]</code>数组进行编解码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"中 文!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">b64encoded</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span><span class="c1">//5LitIOaWhyE=</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span><span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">output</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span><span class="c1">//中 文!</span>
</code></pre></div></div>

<p>因为标准的Base64编码会出现<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">/</code>和<code class="language-plaintext highlighter-rouge">=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code class="language-plaintext highlighter-rouge">+</code>变成<code class="language-plaintext highlighter-rouge">-</code>，<code class="language-plaintext highlighter-rouge">/</code>变成<code class="language-plaintext highlighter-rouge">_</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xFF</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xE0</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0x1</span><span class="o">};</span>

<span class="nc">String</span> <span class="n">b64encoded</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span><span class="c1">///+AB</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//[-1, -32, 1]</span>

<span class="nc">String</span> <span class="n">b64encoded2</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getUrlEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded2</span><span class="o">);</span><span class="c1">//_-AB</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getUrlDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded2</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//[-1, -32, 1]</span>
</code></pre></div></div>

<p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p>

<p>Base64 编码将每 6 位原始数据编码为 8 位字符（即 1 字节），因此会使数据长度增加约 1/3。这是因为 每 3 个字节原始数据编码后变为 4 个字节的 Base64 字符串。</p>

<h2 id="哈希算法">哈希算法</h2>

<p>哈希算法（Hash）又称<strong>摘要算法</strong>（Digest），它的作用是：对任意一组输入数据进行计算，得到一个<strong>固定长度</strong>的输出<strong>摘要</strong>。</p>

<p>哈希算法最重要的特点就是：</p>

<ul>
  <li>相同的输入<strong>一定</strong>得到相同的输出；</li>
  <li>不同的输入<strong>大概率</strong>得到不同的输出。</li>
</ul>

<p>哈希算法的目的就是为了验证原始数据是否被篡改。</p>

<p>Java字符串的<code class="language-plaintext highlighter-rouge">hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节<code class="language-plaintext highlighter-rouge">int</code>整数。</p>

<h3 id="哈希碰撞">哈希碰撞</h3>

<p>哈希碰撞是指，两个不同的输入得到了相同的输出。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%X\n"</span><span class="o">,</span><span class="s">"AaAaAa"</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 0x7460E8C0</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%X\n"</span><span class="o">,</span><span class="s">"BBAaBB"</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 0x7460E8C0</span>
</code></pre></div></div>

<p>碰撞是一定会出现的，因为输出的字节长度是固定的，<code class="language-plaintext highlighter-rouge">String</code>的<code class="language-plaintext highlighter-rouge">hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p>

<p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p>

<ul>
  <li>碰撞概率低；</li>
  <li>不能猜测输出。</li>
</ul>

<p>常用的哈希算法有：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">算法</th>
      <th style="text-align: left">输出长度（位）</th>
      <th style="text-align: left">输出长度（字节）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">MD5</td>
      <td style="text-align: left">128 bits</td>
      <td style="text-align: left">16 bytes</td>
    </tr>
    <tr>
      <td style="text-align: left">SHA-1</td>
      <td style="text-align: left">160 bits</td>
      <td style="text-align: left">20 bytes</td>
    </tr>
    <tr>
      <td style="text-align: left">RipeMD-160</td>
      <td style="text-align: left">160 bits</td>
      <td style="text-align: left">20 bytes</td>
    </tr>
    <tr>
      <td style="text-align: left">SHA-256</td>
      <td style="text-align: left">256 bits</td>
      <td style="text-align: left">32 bytes</td>
    </tr>
    <tr>
      <td style="text-align: left">SHA-512</td>
      <td style="text-align: left">512 bits</td>
      <td style="text-align: left">64 bytes</td>
    </tr>
  </tbody>
</table>

<p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。以MD5算法为例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个MessageDigest实例:</span>
<span class="nc">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"MD5"</span><span class="o">);</span>
<span class="c1">// 反复调用update,输入数据:</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"World"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">();</span> <span class="c1">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">result</span><span class="o">).</span><span class="na">toString</span><span class="o">(</span><span class="mi">16</span><span class="o">));</span>
</code></pre></div></div>

<p>首先根据哈希算法获取一个<code class="language-plaintext highlighter-rouge">MessageDigest</code>实例，然后，反复调用<code class="language-plaintext highlighter-rouge">update(byte[])</code>输入数据。当输入结束后，调用<code class="language-plaintext highlighter-rouge">digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p>

<h3 id="biginteger的坑"><code class="language-plaintext highlighter-rouge">BigInteger</code>的坑</h3>

<p><strong>注意：如果<code class="language-plaintext highlighter-rouge">result</code>前面有0会在转换为<code class="language-plaintext highlighter-rouge">BigInteger</code>时丢失</strong>，因为<code class="language-plaintext highlighter-rouge">BigInteger</code>类在处理字符串时会忽略前导零，因为在数值上它们没有意义。</p>

<p>如果需要保留前导零，可以使用其他方法，如使用<code class="language-plaintext highlighter-rouge">printf</code>格式化补0到指定位数输出，或者直接使用字节数组。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.math.BigInteger</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">hexString</span> <span class="o">=</span> <span class="s">"000005bd4639f848dd8ed27f1b3f6b0d"</span><span class="o">;</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span><span class="o">=</span><span class="n">hexStringToByteArray</span><span class="o">(</span><span class="n">hexString</span><span class="o">);</span>
        <span class="c1">//5bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">result</span><span class="o">).</span><span class="na">toString</span><span class="o">(</span><span class="mi">16</span><span class="o">));</span>
        <span class="c1">//如果知道输出的位数，可以使用printf：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%032x\n"</span><span class="o">,</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">result</span><span class="o">));</span>
        <span class="c1">//还可以这样直接传入16进制字符串：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%032x\n"</span><span class="o">,</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="n">hexString</span><span class="o">,</span><span class="mi">16</span><span class="o">));</span>
        <span class="c1">//如果不知道，就直接用字节数组吧：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 16进制字符串转换为字节数组。
     * @param hexString 16进制字符串
     * @return 字节数组
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">hexStringToByteArray</span><span class="o">(</span><span class="nc">String</span> <span class="n">hexString</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">hexString</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">byteArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">byteArray</span><span class="o">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span>
                    <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">digit</span><span class="o">(</span><span class="n">hexString</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">16</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">)</span>
                    <span class="o">+</span> <span class="nc">Character</span><span class="o">.</span><span class="na">digit</span><span class="o">(</span><span class="n">hexString</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">),</span> <span class="mi">16</span><span class="o">)</span>
            <span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">byteArray</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="用途">用途</h3>

<p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p>

<p>在网站上下载软件的时候，经常看到下载页显示的哈希，如何判断下载到本地的软件是原始的、未经篡改的文件？只需要自己计算一下下载到本地的文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p>

<p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：数据库管理员能够看到用户明文口令；数据库数据一旦泄漏，黑客即可获取用户明文口令。</p>

<p>不存储用户的原始口令，那么如何对用户进行认证？方法是存储用户口令的哈希，例如，MD5。在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p>

<p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p>

<p>使用哈希口令时，还要注意防止彩虹表攻击。如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的<strong>常用口令</strong>和它们的MD5的对照表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令。因此不要使用弱密码，也不要使用生日等个人信息作为密码的原因，在社工面前找到账号对应的人是很容易的。</p>

<p>即使用户使用了常用口令，也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">md5</span><span class="o">(</span><span class="n">salt</span><span class="o">+</span><span class="n">inputPassword</span><span class="o">)</span>
</code></pre></div></div>

<p>经过加盐处理的数据库表，内容如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">username</th>
      <th style="text-align: left">salt</th>
      <th style="text-align: left">password</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">bob</td>
      <td style="text-align: left">H1r0a</td>
      <td style="text-align: left">a5022319ff4c56955e22a74abcc2c210</td>
    </tr>
    <tr>
      <td style="text-align: left">alice</td>
      <td style="text-align: left">7$p2w</td>
      <td style="text-align: left">e5de688c99e961ed6e560b972dab8b6a</td>
    </tr>
    <tr>
      <td style="text-align: left">tim</td>
      <td style="text-align: left">z5Sk9</td>
      <td style="text-align: left">1eee304b92dc0d105904e7ab58fd2f64</td>
    </tr>
  </tbody>
</table>

<p>加盐的目的在于使黑客的<strong>彩虹表失效</strong>，即使用户使用常用口令，也无法从MD5反推原始口令。这样，就算黑客拿到了数据库和源代码，也要对每个<code class="language-plaintext highlighter-rouge">salt</code>重新计算彩虹表。这已经不能叫彩虹表了，这就是暴力破解。</p>

<p>就算破解出与<strong>加盐哈希前的密码</strong>一样<strong>加盐哈希的密码</strong>，也不一定能保证就是<strong>原始的密码</strong>，而<strong>只要不是原始的密码</strong>，就算账号所有者的所有网站都设置同一个密码，也只破解了这一家网站的密码，因为每家网站的盐不一样。但是，如果某家网站没有加盐，被破解，那么意味着<strong>原始密码</strong>就被泄露了。</p>

<p>因此不建议所有网站都设置同一个密码，或者按网站的信任程度和重要性使用不同的密码，并且这些密码之间要像哈希生成的特征码一样，不具有通过几个密码推测出规律的可能。</p>

<p>盐的生成可以使用随机数：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
<span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">bs</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">HexFormat</span><span class="o">.</span><span class="na">of</span><span class="o">().</span><span class="na">formatHex</span><span class="o">(</span><span class="n">bs</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="sha-1">SHA-1</h3>

<p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p>

<p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code class="language-plaintext highlighter-rouge">"SHA-1"</code>。类似的，计算SHA-256，我们需要传入名称<code class="language-plaintext highlighter-rouge">"SHA-256"</code>，计算SHA-512，我们需要传入名称<code class="language-plaintext highlighter-rouge">"SHA-512"</code>。</p>

<p>MD5因为输出长度较短，短时间内破解是可能的，目前已经<strong>不推荐使用</strong>。</p>

<h2 id="bouncycastle">BouncyCastle</h2>

<p>Java标准库提供了一系列常用的哈希算法。</p>

<p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p>

<p>方法一：自己写一个，难度很大；</p>

<p>方法二：找一个现成的第三方库，直接使用。</p>

<p><a href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p>

<p>首先，把BouncyCastle提供的jar包放到classpath中。这个jar包就是<code class="language-plaintext highlighter-rouge">bcprov-jdk18on-xxx.jar</code>，可以从<a href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p>

<p>Java标准库的<code class="language-plaintext highlighter-rouge">java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注册BouncyCastle:</span>
<span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
<span class="c1">// 按名称正常调用:</span>
<span class="nc">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RipeMD160"</span><span class="o">);</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>其中，注册BouncyCastle是通过下面的语句实现的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
</code></pre></div></div>

<p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p>

<h2 id="hmac算法">Hmac算法</h2>

<p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p>

<p>我们回顾一下哈希算法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">input</span><span class="o">)</span>
</code></pre></div></div>

<p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">salt</span> <span class="o">+</span> <span class="n">input</span><span class="o">)</span>
</code></pre></div></div>

<p>这个<code class="language-plaintext highlighter-rouge">salt</code>可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p>

<p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p>

<p>Hmac算法<strong>总是和某种哈希算法配合起来用的</strong>。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HmacMD5 ≈ md5(secure_random_key, input)
</code></pre></div></div>

<p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加<code class="language-plaintext highlighter-rouge">salt</code>，有如下好处：</p>

<ul>
  <li>HmacMD5使用的<code class="language-plaintext highlighter-rouge">key</code>长度是64字节，更安全；</li>
  <li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li>
  <li>Hmac输出和原有的哈希算法长度一致。</li>
</ul>

<p>可见，Hmac本质上就是把<code class="language-plaintext highlighter-rouge">key</code>混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供<code class="language-plaintext highlighter-rouge">key</code>。</p>

<p>为了保证安全，我们不会自己指定<code class="language-plaintext highlighter-rouge">key</code>，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">KeyGenerator</span> <span class="n">keyGen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
    <span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyGen</span><span class="o">.</span><span class="na">generateKey</span><span class="o">();</span>
    <span class="c1">// 打印随机生成的key:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="n">out</span><span class="o">(</span><span class="n">skey</span><span class="o">);</span>
    <span class="nc">Mac</span> <span class="n">mac</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
    <span class="n">mac</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">key</span><span class="o">);</span><span class="c1">//传入key</span>
    <span class="n">mac</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span><span class="c1">//添加数据</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mac</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span><span class="c1">//调用</span>
    <span class="n">out</span><span class="o">(</span><span class="n">result</span><span class="o">);</span><span class="c1">//a7f9bf40c2929734...</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>和MD5相比，使用HmacMD5的步骤是：</p>

<ol>
  <li>通过名称<code class="language-plaintext highlighter-rouge">HmacMD5</code>获取<code class="language-plaintext highlighter-rouge">KeyGenerator</code>实例；</li>
  <li>通过<code class="language-plaintext highlighter-rouge">KeyGenerator</code>创建一个<code class="language-plaintext highlighter-rouge">SecretKey</code>实例；</li>
  <li>通过名称<code class="language-plaintext highlighter-rouge">HmacMD5</code>获取<code class="language-plaintext highlighter-rouge">Mac</code>实例；</li>
  <li>用<code class="language-plaintext highlighter-rouge">SecretKey</code>初始化<code class="language-plaintext highlighter-rouge">Mac</code>实例；</li>
  <li>对<code class="language-plaintext highlighter-rouge">Mac</code>实例反复调用<code class="language-plaintext highlighter-rouge">update(byte[])</code>输入数据；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">Mac</code>实例的<code class="language-plaintext highlighter-rouge">doFinal()</code>获取最终的哈希值。</li>
</ol>

<p>可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">username</th>
      <th style="text-align: left">secret_key (64 bytes)</th>
      <th style="text-align: left">password</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">bob</td>
      <td style="text-align: left">a8c06e05f92e…5e16</td>
      <td style="text-align: left">7e0387872a57c85ef6dddbaa12f376de</td>
    </tr>
    <tr>
      <td style="text-align: left">alice</td>
      <td style="text-align: left">e6a343693985…f4be</td>
      <td style="text-align: left">c1f929ac2552642b302e739bc0cdbaac</td>
    </tr>
    <tr>
      <td style="text-align: left">tim</td>
      <td style="text-align: left">f27a973dfdc0…6003</td>
      <td style="text-align: left">af57651c3a8a73303515804d4af43790</td>
    </tr>
  </tbody>
</table>

<p>有了Hmac计算的哈希和<code class="language-plaintext highlighter-rouge">SecretKey</code>，我们想要验证怎么办？这时，<code class="language-plaintext highlighter-rouge">SecretKey</code>不能从<code class="language-plaintext highlighter-rouge">KeyGenerator</code>生成，而是从一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组恢复：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.KeyGenerator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.Mac</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">KeyGenerator</span> <span class="n">keyGen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyGen</span><span class="o">.</span><span class="na">generateKey</span><span class="o">();</span>
        <span class="c1">// 打印随机生成的key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
        <span class="n">out</span><span class="o">(</span><span class="n">skey</span><span class="o">);</span>
        <span class="nc">Mac</span> <span class="n">mac</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="n">mac</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">key</span><span class="o">);</span><span class="c1">//传入key</span>
        <span class="n">mac</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span><span class="c1">//添加数据</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mac</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span><span class="c1">//调用</span>
        <span class="n">out</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
        <span class="c1">// 通过字节数组恢复key。</span>
        <span class="nc">SecretKey</span> <span class="n">restoreTheKey</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">skey</span><span class="o">,</span> <span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="nc">Mac</span> <span class="n">mac2</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="n">mac2</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">restoreTheKey</span><span class="o">);</span>
        <span class="n">mac2</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">mac2</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span>
        <span class="n">out</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>恢复<code class="language-plaintext highlighter-rouge">SecretKey</code>的语句就是<code class="language-plaintext highlighter-rouge">new SecretKeySpec(hkey, "HmacMD5")</code>。</p>

<h2 id="对称加密算法">对称加密算法</h2>

<p>对称加密算法就是传统的用一个密码进行加密和解密。</p>

<p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>secret = encrypt(key, message);
</code></pre></div></div>

<p>而解密则相反，它接收密码和密文，然后输出明文：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plain = decrypt(key, secret);
</code></pre></div></div>

<p>在软件开发中，常用的对称加密算法有：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">算法</th>
      <th style="text-align: left">密钥长度</th>
      <th style="text-align: left">工作模式</th>
      <th style="text-align: left">填充模式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">DES</td>
      <td style="text-align: left">56/64</td>
      <td style="text-align: left">ECB/CBC/PCBC/CTR/…</td>
      <td style="text-align: left">NoPadding/PKCS5Padding/…</td>
    </tr>
    <tr>
      <td style="text-align: left">AES</td>
      <td style="text-align: left">128/192/256</td>
      <td style="text-align: left">ECB/CBC/PCBC/CTR/…</td>
      <td style="text-align: left">NoPadding/PKCS5Padding/PKCS7Padding/…</td>
    </tr>
    <tr>
      <td style="text-align: left">IDEA</td>
      <td style="text-align: left">128</td>
      <td style="text-align: left">ECB</td>
      <td style="text-align: left">PKCS5Padding/PKCS7Padding/…</td>
    </tr>
  </tbody>
</table>

<p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p>

<p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p>

<h3 id="ecb模式">ECB模式</h3>

<p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 128位密钥 = 16 bytes Key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"1234567890abcdef"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>
        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>

    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>控制台：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原文: Hello, world!，16进制：48656c6c6f2c20776f726c6421
密文: ��D�E����\�，16进制：db188644e9450610b9edbec41aee5cde
解密: Hello, world!，16进制：48656c6c6f2c20776f726c6421
</code></pre></div></div>

<p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p>

<ol>
  <li>根据算法名称/工作模式/填充模式获取<code class="language-plaintext highlighter-rouge">Cipher</code>实例；</li>
  <li>根据算法名称初始化一个<code class="language-plaintext highlighter-rouge">SecretKey</code>实例，密钥必须是指定长度；</li>
  <li>使用<code class="language-plaintext highlighter-rouge">SecretKey</code>初始化<code class="language-plaintext highlighter-rouge">Cipher</code>实例，并设置加密或解密模式；</li>
  <li>传入明文或密文，获得密文或明文。</li>
</ol>

<p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低。</p>

<p>对于AES加密算法，<strong>不论使用哪种模式</strong>（如ECB、CBC等），<strong>密钥长度必须</strong>为16字节（128位）、24字节（192位）或32字节（256位）。这是由AES算法的规范确定的，以确保加密过程的安全性和正确性。如果密钥长度不符合这些要求，将无法正确使用AES算法进行加密。</p>

<hr />

<h3 id="cbc模式">CBC模式</h3>

<p>更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.IvParameterSpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 256位密钥 = 32 bytes Key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"1234567890abcdef1234567890abcdef"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>
        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>


    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="c1">// CBC模式需要生成一个16 bytes的initialization vector:</span>
        <span class="nc">SecureRandom</span> <span class="n">sr</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstanceStrong</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">sr</span><span class="o">.</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
        <span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">,</span> <span class="n">ivps</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="c1">// IV不需要保密，把IV和密文拼一起返回:</span>
        <span class="k">return</span> <span class="nf">join</span><span class="o">(</span><span class="n">iv</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 把input分割成IV和密文:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">input</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">16</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">iv</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="c1">// 解密:</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">,</span> <span class="n">ivps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">join</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs1</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">bs2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">bs1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">bs2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bs1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bs1</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bs2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">bs1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">bs2</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>CBC（Cipher Block Chaining）模式还需要一个16字节的初始向量（IV）。对于IV（Initialization Vector，初始化向量）参数，在AES算法中，它的长度<strong>是固定的</strong>，<strong>为16字节</strong>（128位）。无论使用哪种模式（如CBC、CTR等），IV参数的长度都应为16字节。IV的作用是为了在每次加密操作时引入随机性，即使是在使用相同密钥加密相同数据的情况下也能产生不同的密文。</p>

<p><strong>为保证安全，随机数必须使用<code class="language-plaintext highlighter-rouge">SecureRandom</code>生成</strong>，虽然也管不到你用<code class="language-plaintext highlighter-rouge">Random</code>。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span><span class="o">=</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
<span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
<span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
</code></pre></div></div>

<p>因为多了一个<code class="language-plaintext highlighter-rouge">IvParameterSpec</code>实例，因此，初始化方法需要调用<code class="language-plaintext highlighter-rouge">Cipher</code>的一个重载方法并传入<code class="language-plaintext highlighter-rouge">IvParameterSpec</code>。</p>

<p>其实也就多了个随机数变量而已，<strong>注意随机数必须16字节，key必须为16/24/32字节</strong>。</p>

<h2 id="口令加密算法">口令加密算法</h2>

<p>AES加密，密钥长度是固定的128/192/256位。这是因为对称加密算法决定了口令<strong>必须是固定长度</strong>，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p>

<p>用户输入的口令并不能<strong>直接</strong>作为AES的密钥进行加密（<strong>除非长度恰好</strong>是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p>

<p>PBE就是Password Based Encryption的缩写，它的作用如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="n">generate</span><span class="o">(</span><span class="n">userPassword</span><span class="o">,</span> <span class="n">secureRandomPassword</span><span class="o">);</span>
</code></pre></div></div>

<p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.bouncycastle.jce.provider.BouncyCastleProvider</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKeyFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.PBEKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.PBEParameterSpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.Security</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 把BouncyCastle作为Provider添加到java.security:</span>
        <span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
        <span class="c1">// 16 bytes随机Salt:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">salt</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstanceStrong</span><span class="o">().</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
        <span class="c1">// 加密口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"hello12345"</span><span class="o">;</span>
        <span class="c1">// 数据</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>

        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">password</span><span class="o">,</span><span class="n">salt</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">password</span><span class="o">,</span><span class="n">salt</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>


    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">salt</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 通过password生成key</span>
        <span class="nc">PBEKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEKeySpec</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
        <span class="nc">SecretKeyFactory</span> <span class="n">skeyFactory</span> <span class="o">=</span> <span class="nc">SecretKeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">skeyFactory</span><span class="o">.</span><span class="na">generateSecret</span><span class="o">(</span><span class="n">keySpec</span><span class="o">);</span>
        <span class="c1">// 盐</span>
        <span class="nc">PBEParameterSpec</span> <span class="n">pbeps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEParameterSpec</span><span class="o">(</span><span class="n">salt</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="c1">// 加密</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">skey</span><span class="o">,</span> <span class="n">pbeps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">salt</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 通过password生成key</span>
        <span class="nc">PBEKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEKeySpec</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
        <span class="nc">SecretKeyFactory</span> <span class="n">skeyFactory</span> <span class="o">=</span> <span class="nc">SecretKeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">skeyFactory</span><span class="o">.</span><span class="na">generateSecret</span><span class="o">(</span><span class="n">keySpec</span><span class="o">);</span>
        <span class="c1">// 盐</span>
        <span class="nc">PBEParameterSpec</span> <span class="n">pbeps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEParameterSpec</span><span class="o">(</span><span class="n">salt</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="c1">// 解密</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">skey</span><span class="o">,</span> <span class="n">pbeps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>



</code></pre></div></div>

<p>使用PBE时，还需要引入BouncyCastle，并指定算法是<code class="language-plaintext highlighter-rouge">PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用<code class="language-plaintext highlighter-rouge">Cipher</code>的<code class="language-plaintext highlighter-rouge">init()</code>方法时同时传入<code class="language-plaintext highlighter-rouge">SecretKey</code>和<code class="language-plaintext highlighter-rouge">PBEParameterSpec</code>实现的。在创建<code class="language-plaintext highlighter-rouge">PBEParameterSpec</code>的时候，我们还指定了循环次数<code class="language-plaintext highlighter-rouge">1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p>

<p>如果把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p>

<h2 id="密钥交换算法">密钥交换算法</h2>

<p>对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p>

<p>现在问题来了：如何传递密钥？</p>

<p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p>

<p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p>

<p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p>

<p>假设甲乙双方需要传递密钥，他们之间可以这么做：</p>

<ol>
  <li>甲首先选择一个素数<code class="language-plaintext highlighter-rouge">p</code>，例如97，底数<code class="language-plaintext highlighter-rouge">g</code>是<code class="language-plaintext highlighter-rouge">p</code>的一个本原根，例如5，随机数<code class="language-plaintext highlighter-rouge">a</code>，例如123，然后计算<code class="language-plaintext highlighter-rouge">A=g^a mod p</code>，结果是34，然后，甲发送<code class="language-plaintext highlighter-rouge">p＝97</code>，<code class="language-plaintext highlighter-rouge">g=5</code>，<code class="language-plaintext highlighter-rouge">A=34</code>给乙；</li>
  <li>乙方收到后，也选择一个随机数<code class="language-plaintext highlighter-rouge">b</code>，例如，456，然后计算<code class="language-plaintext highlighter-rouge">B = g^b mod p</code>，结果是75，乙再同时计算<code class="language-plaintext highlighter-rouge">s = A^b mod p</code>，结果是22；</li>
  <li>乙把计算的<code class="language-plaintext highlighter-rouge">B=75</code>发给甲，甲计算<code class="language-plaintext highlighter-rouge">s ＝ B^a mod p</code>，计算结果与乙算出的结果一样，都是22。</li>
</ol>

<p>所以最终双方协商出的密钥<code class="language-plaintext highlighter-rouge">s</code>是22。注意到这个密钥<code class="language-plaintext highlighter-rouge">s</code>并没有在网络上传输。而通过网络传输的<code class="language-plaintext highlighter-rouge">p</code>，<code class="language-plaintext highlighter-rouge">g</code>，<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>是无法推算出<code class="language-plaintext highlighter-rouge">s</code>的，因为实际算法选择的素数是非常大的。</p>

<p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>

<p>如果我们把<code class="language-plaintext highlighter-rouge">a</code>看成甲的私钥，<code class="language-plaintext highlighter-rouge">A</code>看成甲的公钥，<code class="language-plaintext highlighter-rouge">b</code>看成乙的私钥，<code class="language-plaintext highlighter-rouge">B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥<code class="language-plaintext highlighter-rouge">secretKey</code>，DH算法通过数学定律保证了双方各自计算出的<code class="language-plaintext highlighter-rouge">secretKey</code>是相同的。</p>

<p>使用Java实现DH算法的代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.KeyAgreement</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.X509EncodedKeySpec</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Bob和Alice:</span>
        <span class="nc">Person</span> <span class="n">bob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
        <span class="nc">Person</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">);</span>

        <span class="c1">// 各自生成KeyPair:</span>
        <span class="n">bob</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>

        <span class="c1">// 双方交换各自的PublicKey:</span>
        <span class="c1">// Bob根据Alice的PublicKey生成自己的本地密钥:</span>
        <span class="n">bob</span><span class="o">.</span><span class="na">generateSecretKey</span><span class="o">(</span><span class="n">alice</span><span class="o">.</span><span class="na">publicKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="c1">// Alice根据Bob的PublicKey生成自己的本地密钥:</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">generateSecretKey</span><span class="o">(</span><span class="n">bob</span><span class="o">.</span><span class="na">publicKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>

        <span class="c1">// 检查双方的本地密钥是否相同:注意公key私key后面一部分不一样。</span>
        <span class="n">bob</span><span class="o">.</span><span class="na">printKeys</span><span class="o">();</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">printKeys</span><span class="o">();</span>
        <span class="c1">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">PublicKey</span> <span class="n">publicKey</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">PrivateKey</span> <span class="n">privateKey</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">secretKey</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 生成本地KeyPair:</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateKeyPair</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DH"</span><span class="o">);</span>
            <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">512</span><span class="o">);</span>
            <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">privateKey</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">publicKey</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">GeneralSecurityException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateSecretKey</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">receivedPubKeyBytes</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 从byte[]恢复PublicKey:</span>
            <span class="nc">X509EncodedKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">receivedPubKeyBytes</span><span class="o">);</span>
            <span class="nc">KeyFactory</span> <span class="n">kf</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DH"</span><span class="o">);</span>
            <span class="nc">PublicKey</span> <span class="n">receivedPublicKey</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">keySpec</span><span class="o">);</span>
            <span class="c1">// 生成本地密钥:</span>
            <span class="nc">KeyAgreement</span> <span class="n">keyAgreement</span> <span class="o">=</span> <span class="nc">KeyAgreement</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DH"</span><span class="o">);</span>
            <span class="n">keyAgreement</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">privateKey</span><span class="o">);</span> <span class="c1">// 自己的PrivateKey</span>
            <span class="n">keyAgreement</span><span class="o">.</span><span class="na">doPhase</span><span class="o">(</span><span class="n">receivedPublicKey</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// 对方的PublicKey</span>
            <span class="c1">// 生成SecretKey密钥:</span>
            <span class="k">this</span><span class="o">.</span><span class="na">secretKey</span> <span class="o">=</span> <span class="n">keyAgreement</span><span class="o">.</span><span class="na">generateSecret</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">GeneralSecurityException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printKeys</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Private key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">privateKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Public key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">publicKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Secret key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">secretKey</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p>

<p>假设甲乙在交换公钥时被丙截获，丙把自己的公钥分别发送给甲乙两人，就变成了，甲丙通信，丙乙通信。所以使用对称加密不能防止中间人攻击</p>

<p>Diffie-Hellman密钥交换算法的最低和最高密钥长度取决于使用的具体实现和协议要求。一般来说，DH密钥的长度必须是64的倍数，并且范围在512到8192之间（包括512和8192）。</p>

<p>本原根是一个数学概念，在数论中使用。简单来说，对于一个素数$p$，如果有一个数$g$，满足$g$的不同次幂对$p$取模的结果能够覆盖从$1$到$p-1$的所有可能的余数，而且没有重复，那么$g$就是模$p$的本原根。</p>

<p>举个例子，考虑素数$p=7$。我们要找到一个数$g$，满足$g$的不同次幂对$7$取模的结果覆盖了$1$到$6$的所有余数。对于$p=7$，数$3$就是一个本原根，因为$3^1 \equiv 3 \pmod{7}$，$3^2 \equiv 2 \pmod{7}$，$3^3 \equiv 6 \pmod{7}$，$3^4 \equiv 4 \pmod{7}$，$3^5 \equiv 5 \pmod{7}$，$3^6 \equiv 1 \pmod{7}$。这里$3$的不同次幂依次覆盖了$1$到$6$的所有余数，且没有重复。</p>

<h2 id="非对称加密算法">非对称加密算法</h2>

<p>从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p>

<p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p>

<p>因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p>

<p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p>

<p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code class="language-plaintext highlighter-rouge">N*(N-1)/2</code>个密钥，因此每个人需要管理<code class="language-plaintext highlighter-rouge">N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>

<p>既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p>

<p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p>

<ol>
  <li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li>
  <li>小红用自己的RSA私钥解密得到AES口令；</li>
  <li>双方使用这个共享的AES口令用AES加密通信。</li>
</ol>

<p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p>

<p>Java标准库提供了RSA算法的实现，示例代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.UnsupportedEncodingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
        <span class="c1">// 明文:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">plain</span> <span class="o">=</span> <span class="s">"Hello, encrypt use RSA"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="c1">// 创建公钥／私钥对:</span>
        <span class="nc">Person</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">);</span>

        <span class="kt">byte</span><span class="o">[]</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">getPublicKey</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"public key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">pk</span><span class="o">);</span>

        <span class="c1">// 用Alice的公钥加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">encrypt</span><span class="o">(</span><span class="n">plain</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"encrypted: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">//密文</span>


        <span class="kt">byte</span><span class="o">[]</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">getPrivateKey</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"private key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">sk</span><span class="o">);</span>

        <span class="c1">// Alice用自己的私钥解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">decrypt</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 私钥:</span>
    <span class="nc">PrivateKey</span> <span class="n">sk</span><span class="o">;</span>
    <span class="c1">// 公钥:</span>
    <span class="nc">PublicKey</span> <span class="n">pk</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="c1">// 生成公钥／私钥对:</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 把私钥导出为字节</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getPrivateKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">sk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 把公钥导出为字节</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getPublicKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">pk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 用公钥加密:</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">pk</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 用私钥解密:</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">sk</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>RSA的公钥和私钥都可以通过<code class="language-plaintext highlighter-rouge">getEncoded()</code>方法获得以<code class="language-plaintext highlighter-rouge">byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从<code class="language-plaintext highlighter-rouge">byte[]</code>数组恢复公钥或私钥，可以这么写：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">pkData</span> <span class="o">=</span> <span class="o">...</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">skData</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">KeyFactory</span> <span class="n">kf</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
<span class="c1">// 恢复公钥:</span>
<span class="nc">X509EncodedKeySpec</span> <span class="n">pkSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">pkData</span><span class="o">);</span>
<span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">pkSpec</span><span class="o">);</span>
<span class="c1">// 恢复私钥:</span>
<span class="nc">PKCS8EncodedKeySpec</span> <span class="n">skSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PKCS8EncodedKeySpec</span><span class="o">(</span><span class="n">skData</span><span class="o">);</span>
<span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePrivate</span><span class="o">(</span><span class="n">skSpec</span><span class="o">);</span>
</code></pre></div></div>

<p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p>

<p>如果修改待加密的<code class="language-plaintext highlighter-rouge">byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。此外，只使用非对称加密算法不能防止中间人攻击。</p>

<p>对称加密只需记住别人的密码，就可以了，识别到是小红发的邮件，用小红的密码密码打开就可以了，发邮件，用自己的密码加密，发出去就可以了。这个问题是，有多少人就需要记多少人的密码，太麻烦了。
非对称加密，你只要记住自己的密码（秘钥），别人发给你的邮件，你也别管是谁的了，用你秘钥就可以打开。解邮件是很爽，但是，发邮件，就有问题了，你得记住每个人的公钥，然后，进行加密，这和记私钥有啥区别呢？</p>

<p>不过，好消息是，公钥之所以叫公钥，就是他不需要进行保密，你可以把你的公钥放在信封上和加密信，一起发给别人，别人也可以，把公钥放在信封上面，把邮件发给你，你就可以拿到别人的公钥了，然后就可以用别人的公钥加密文件一起发给别人了。所以，不需要记住别人的公钥，因为别人会告诉你。</p>

<p>中间人攻击是指：小红给你的发的邮件，被小明，拦截了，然后把信封上面的小红的公钥，换成了，小明的公钥。</p>

<h2 id="签名算法">签名算法</h2>

<p>使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p>

<p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p>

<p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p>

<p>这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如<code class="language-plaintext highlighter-rouge">小明喜欢小红</code>，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认<code class="language-plaintext highlighter-rouge">小明喜欢小红</code>这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。</p>

<p>因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p>

<p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">signature</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">privateKey</span><span class="o">,</span> <span class="n">sha256</span><span class="o">(</span><span class="n">message</span><span class="o">))</span>
</code></pre></div></div>

<p>对签名进行验证实际上就是用公钥解密：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hash</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">publicKey</span><span class="o">,</span> <span class="n">signature</span><span class="o">)</span>
</code></pre></div></div>

<p>然后把解密后的哈希与原始消息的哈希进行对比。</p>

<p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p>

<p>常用数字签名算法有：</p>

<ul>
  <li>MD5withRSA</li>
  <li>SHA1withRSA</li>
  <li>SHA256withRSA</li>
</ul>

<p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p>

<h3 id="sha1withrsa">SHA1withRSA</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.UnsupportedEncodingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
        <span class="c1">// 生成RSA公钥/私钥:</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>

        <span class="c1">// 待签名的消息或摘要:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, I am Bob!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>

        <span class="c1">// 用自己的私钥签名:</span>
        <span class="nc">Signature</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">sk</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">signed</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>
        <span class="c1">// 将消息与签名公开，签名用来验证消息没有被篡改</span>
        <span class="n">out</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">signed</span><span class="o">);</span>

        <span class="c1">// 用某人公开的公钥验证，解析公开的签名和消息，是否是对应人的。</span>
        <span class="nc">Signature</span> <span class="n">v</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">pk</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
        <span class="c1">// 消息被篡改：</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message2</span> <span class="o">=</span> <span class="s">"Hello, I am Gay"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message2</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
        <span class="c1">// 用其他人的key，公钥对不上：</span>
        <span class="nc">PublicKey</span> <span class="n">pk2</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">().</span><span class="na">getPublic</span><span class="o">();</span>
        <span class="n">v</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">pk2</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>控制台：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48656c6c6f2c204920616d20426f6221
3aa37bb696a9c9e808cf42e45e17a79d24139972ba409cce9be475fd00d97968e68a110f667e0cca5a5ed177919c5c20b2a3720bbfc0caa5ae128887da7312ab1be5b3ac409d3917853212a3a14eb96899054db49152fd57299922f3794e874325be498f824044f763753b2eb2c855e06d823c3f1fbaf8240eaf65a25cdac0fd
Hello, I am Bob!这消息保真吗? true
Hello, I am Gay这消息保真吗? false
Hello, I am Bob!这消息保真吗? false
</code></pre></div></div>

<p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p>

<h3 id="使用signedobject">使用<code class="language-plaintext highlighter-rouge">SignedObject</code></h3>

<p>实际上可以用<code class="language-plaintext highlighter-rouge">SignedObject</code>携带消息数据，它还会记录签名和签名的算法名称。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 生成RSA密钥对</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">keyPairGenerator</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">keyPairGenerator</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">keyPair</span> <span class="o">=</span> <span class="n">keyPairGenerator</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">privateKey</span> <span class="o">=</span> <span class="n">keyPair</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="nc">PublicKey</span> <span class="n">publicKey</span> <span class="o">=</span> <span class="n">keyPair</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>

        <span class="c1">// 创建消息</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">;</span>
        <span class="nc">Signature</span> <span class="n">signature</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA256withRSA"</span><span class="o">);</span>
        <span class="c1">// 使用私钥对消息进行签名，创建含消息数据和签名的对象，SignedObject也会记录签名算法名称。</span>
        <span class="nc">SignedObject</span> <span class="n">signedObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SignedObject</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">privateKey</span><span class="o">,</span> <span class="n">signature</span><span class="o">);</span>

        <span class="c1">// 数据的字节数组表示</span>
        <span class="nc">ByteArrayOutputStream</span> <span class="n">byteArrayOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span><span class="c1">//内存模拟</span>
        <span class="nc">ObjectOutputStream</span> <span class="n">objectOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">byteArrayOutputStream</span><span class="o">);</span>
        <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">signedObject</span><span class="o">);</span><span class="c1">//序列化</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">p7Data</span> <span class="o">=</span> <span class="n">byteArrayOutputStream</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span><span class="c1">//读取字节</span>

        <span class="c1">// 数据保存到文件或发送给其他方</span>
        <span class="n">out</span><span class="o">(</span><span class="n">p7Data</span><span class="o">);</span>


        <span class="nc">ByteArrayInputStream</span> <span class="n">byteArrayInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">p7Data</span><span class="o">);</span><span class="c1">//内存模拟</span>
        <span class="nc">ObjectInputStream</span> <span class="n">objectInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">byteArrayInputStream</span><span class="o">);</span>

        <span class="nc">SignedObject</span> <span class="n">signedObjectReceived</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SignedObject</span><span class="o">)</span> <span class="n">objectInputStream</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span><span class="c1">//反序列化</span>
        <span class="c1">// 在接收方，可以使用公钥来验证消息，签名已经在对象里了</span>
        <span class="kt">boolean</span> <span class="n">verified</span> <span class="o">=</span> <span class="n">signedObjectReceived</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">publicKey</span><span class="o">,</span> <span class="n">signature</span><span class="o">);</span>
        <span class="c1">// 拿到消息</span>
        <span class="nc">String</span> <span class="n">verifiedMessage</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">signedObjectReceived</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">verifiedMessage</span><span class="o">+</span><span class="s">"，保真吗？"</span><span class="o">+</span><span class="n">verified</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>控制台：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aced00057372001a6a6176612e73656375726974792e5369676e65644f626a65637409ffbd682a3cd5ff0200035b0007636f6e74656e747400025b425b00097369676e617475726571007e00014c000c746865616c676f726974686d7400124c6a6176612f6c616e672f537472696e673b7870757200025b42acf317f8060854e0020000787000000014aced000574000d48656c6c6f2c20776f726c64217571007e000400000080ad39f5b20d2178c282f04fd90a50ad55a4c444fea270919d61ce8813d7c74ffb6275357c25a1025890db1e78fbae9910f943c2955e6e0734b1ef9cdd83f6ddfa0d2d5d680999146dd3b5021d8c546e1b6e45c587d935a57cfbd32232188bfbe3ea0308a0ae7bc4036dfe0a9d3e495f713297bc33236c7f7981b8637bbc69de5574000d53484132353677697468525341
Hello, world!，保真吗？true
</code></pre></div></div>

<p>自建一个也非常容易，<code class="language-plaintext highlighter-rouge">SignedObject</code>是一个支持序列化，内部并封装了消息数据、签名信息和签名算法，实例化时要求传入消息数据，私钥，签名算法，内部不会保留私钥。还有验证方法<code class="language-plaintext highlighter-rouge">verify</code>，因为内部保存了签名信息，因此只需要传入公钥和签名算法即可。以及返回消息数据的<code class="language-plaintext highlighter-rouge">getObject</code>方法。<strong>注意！传入的消息数据如果是对象需要实现序列化。</strong></p>

<p><strong>DSA签名</strong></p>

<p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>

<p>DSA只能配合SHA使用，常用的算法有：</p>

<ul>
  <li>SHA1withDSA</li>
  <li>SHA256withDSA</li>
  <li>SHA512withDSA</li>
</ul>

<p>和RSA数字签名相比，DSA的优点是更快。</p>

<p><strong>ECDSA签名</strong></p>

<p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p>

<p>P1格式和P7格式是数字证书的编码格式，通常用于存储和传输证书及其相关信息。</p>

<p><strong>P1格式</strong></p>

<p>P1格式是一种简单的ASCII文本格式，通常用于存储私钥。P1格式的私钥文件以”—–BEGIN PRIVATE KEY—–“开头，以”—–END PRIVATE KEY—–“结尾，中间包含私钥的内容。</p>

<p>P1只是一种秘钥文件的规范，指明了文件中包含的内容是私钥或公钥，以及如何编码这些内容。在处理P1格式的秘钥文件时，需要注意文件中包含的标记（例如<code class="language-plaintext highlighter-rouge">-----BEGIN PRIVATE KEY-----</code>和<code class="language-plaintext highlighter-rouge">-----END PRIVATE KEY-----</code>）以及可能的Base64编码。根据具体的规范和编码，需要适当地处理文件内容以提取秘钥的原始数据，并使用相应的类和方法来解析和恢复秘钥对象。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.InvalidKeySpecException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.PKCS8EncodedKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.X509EncodedKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Base64</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//生成P1格式公钥私钥文件</span>
        <span class="n">newP1</span><span class="o">();</span>

        <span class="c1">//读取P1格式公钥私钥文件</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">object</span> <span class="o">=</span> <span class="n">loadP1</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span><span class="o">=</span> <span class="o">(</span><span class="nc">PrivateKey</span><span class="o">)</span> <span class="n">object</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span><span class="o">=</span> <span class="o">(</span><span class="nc">PublicKey</span><span class="o">)</span> <span class="n">object</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// 待签名的消息或摘要:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, I am Bob!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>

        <span class="c1">// 用自己的私钥签名:</span>
        <span class="nc">Signature</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">sk</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">signed</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>
        <span class="c1">// 将消息与签名公开，签名用来验证消息没有被篡改</span>
        <span class="n">out</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">signed</span><span class="o">);</span>

        <span class="c1">// 用某人公开的公钥验证，解析公开的签名和消息，是否是对应人的。</span>
        <span class="nc">Signature</span> <span class="n">v</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">pk</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">newP1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">NoSuchAlgorithmException</span> <span class="o">{</span>
        <span class="c1">// 生成RSA公钥/私钥:</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>

        <span class="c1">// P1格式公钥</span>
        <span class="nc">String</span> <span class="n">base64EncodedPublicKey</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">pk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">p1FormattedPublicKey</span> <span class="o">=</span> <span class="s">"-----BEGIN PUBLIC KEY-----\n"</span> <span class="o">+</span>
                <span class="n">base64EncodedPublicKey</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span>
                <span class="s">"-----END PUBLIC KEY-----\n"</span><span class="o">;</span>
        <span class="c1">// 将P1格式的公钥保存到文件</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"publicKey.p1"</span><span class="o">);</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">p1FormattedPublicKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">// P1格式私钥</span>
        <span class="nc">String</span> <span class="n">base64EncodedPrivateKey</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">p1FormattedPrivateKey</span> <span class="o">=</span> <span class="s">"-----BEGIN PRIVATE KEY-----\n"</span> <span class="o">+</span>
                <span class="n">base64EncodedPrivateKey</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span>
                <span class="s">"-----END PRIVATE KEY-----\n"</span><span class="o">;</span>

        <span class="c1">// 将P1格式的私钥保存到文件</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"privateKey.p1"</span><span class="o">);</span>
        <span class="n">fos2</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">p1FormattedPrivateKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="n">fos2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">loadP1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InvalidKeySpecException</span><span class="o">,</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">NoSuchAlgorithmException</span> <span class="o">{</span>
        <span class="c1">// 加载P1格式的私钥</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"privateKey.p1"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">privateKeyBytes</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">();</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">// 移除文本标记</span>
        <span class="nc">String</span> <span class="n">s1</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">privateKeyBytes</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----BEGIN PRIVATE KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----END PRIVATE KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        <span class="n">privateKeyBytes</span><span class="o">=</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="nc">KeyFactory</span> <span class="n">kf</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>

        <span class="c1">// 恢复私钥:</span>
        <span class="nc">PKCS8EncodedKeySpec</span> <span class="n">skSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PKCS8EncodedKeySpec</span><span class="o">(</span><span class="n">privateKeyBytes</span><span class="o">);</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePrivate</span><span class="o">(</span><span class="n">skSpec</span><span class="o">);</span>

        <span class="c1">// 加载P1格式的公钥</span>
        <span class="nc">FileInputStream</span> <span class="n">fis2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"publicKey.p1"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">publicKeyBytes</span> <span class="o">=</span> <span class="n">fis2</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">();</span>
        <span class="n">fis2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">// 移除文本标记</span>
        <span class="nc">String</span> <span class="n">s2</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">publicKeyBytes</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----BEGIN PUBLIC KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----END PUBLIC KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        <span class="n">publicKeyBytes</span> <span class="o">=</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="nc">X509EncodedKeySpec</span> <span class="n">pkSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">publicKeyBytes</span><span class="o">);</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">pkSpec</span><span class="o">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">sk</span><span class="o">,</span><span class="n">pk</span><span class="o">};</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>P7格式是一种用于存储加密数据和证书链的格式。P7格式的文件以”—–BEGIN PKCS7—–“开头，以”—–END PKCS7—–“结尾，中间包含加密数据和证书链的信息。</p>

<p>当第三方接口要求使用P7格式签名时，是要求将加密数据和证书链一起打包成P7格式的数据，用于传输或存储。</p>

<p><strong>SM2算法</strong>是一种基于椭圆曲线的非对称加密算法，是中国制定的国家密码算法标准之一。SM2算法提供了数字签名、密钥交换、公钥加密等功能，被广泛应用于各种安全领域，如电子认证、数字签名、信息传输加密等。由于SM2算法是非对称加密算法，因此在使用时需要生成一对公钥和私钥，公钥用于加密或验证签名，私钥用于解密或生成签名。</p>

<h2 id="数字证书">数字证书</h2>

<p>摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>

<p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>

<p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p>

<p>上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。</p>

<p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用<strong>自签名</strong>的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p>

<p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。用下面的命令创建一个key store，并设定口令123456：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-storepass</span> 123456 <span class="nt">-genkeypair</span> <span class="nt">-keyalg</span> RSA <span class="nt">-keysize</span> 1024 <span class="nt">-sigalg</span> SHA1withRSA <span class="nt">-validity</span> 3650 <span class="nt">-alias</span> mycert <span class="nt">-keystore</span> my.keystore <span class="nt">-dname</span> <span class="s2">"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</span>
</code></pre></div></div>

<p>几个主要的参数是：</p>

<ul>
  <li>keyalg：指定RSA加密算法；</li>
  <li>sigalg：指定SHA1withRSA签名算法；</li>
  <li>validity：指定证书有效期3650天；</li>
  <li>alias：指定证书在程序中引用的名称；</li>
  <li>dname：最重要的<code class="language-plaintext highlighter-rouge">CN=www.sample.com</code>指定了<code class="language-plaintext highlighter-rouge">Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li>
</ul>

<p>执行上述命令，JDK会在当前目录创建一个<code class="language-plaintext highlighter-rouge">my.keystore</code>文件，并存<strong>储创建成功的一个私钥和一个证书</strong>，它的别名是<code class="language-plaintext highlighter-rouge">mycert</code>。可以使用以下命令列出密钥库的内容：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-list</span> <span class="nt">-v</span> <span class="nt">-keystore</span> my.keystore <span class="nt">-storepass</span> 123456
</code></pre></div></div>

<p>请注意，虽然这个密钥库包含私钥，但这只是一个自签名证书，不会被浏览器等受信任的 CA 所信任，因此在实际生产环境中，您需要从受信任的 CA 获取证书以及相应的私钥，而不是使用自签名证书。</p>

<p>使用 Java KeyStore (JKS) 工具生成密钥库（keystore），默认情况下，生成的密钥库将包含证书以及相应的私钥。这是因为在实际使用中，密钥库通常用于存储证书和私钥对，以便安全地管理和使用它们。</p>

<p>还可以使用 <code class="language-plaintext highlighter-rouge">-storetype pkcs12</code> 选项来生成 PKCS12 格式的密钥库：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-storepass</span> 123456 <span class="nt">-genkeypair</span> <span class="nt">-keyalg</span> RSA <span class="nt">-keysize</span> 1024 <span class="nt">-sigalg</span> SHA1withRSA <span class="nt">-validity</span> 3650 <span class="nt">-alias</span> mycert <span class="nt">-keystore</span> my.p12 <span class="nt">-storetype</span> PKCS12 <span class="nt">-dname</span> <span class="s2">"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</span>
</code></pre></div></div>

<p>这个命令使用 <code class="language-plaintext highlighter-rouge">keytool</code> 工具生成了一个包含 RSA 密钥对的 PKCS12 格式的密钥库文件 <code class="language-plaintext highlighter-rouge">my.p12</code>。具体参数的含义如下：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-storepass 123456</code>: 设置密钥库的密码为 <code class="language-plaintext highlighter-rouge">123456</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">-genkeypair</code>: 生成密钥对。</li>
  <li><code class="language-plaintext highlighter-rouge">-keyalg RSA</code>: 使用 RSA 算法生成密钥对。</li>
  <li><code class="language-plaintext highlighter-rouge">-keysize 1024</code>: 设置密钥大小为 1024 位。</li>
  <li><code class="language-plaintext highlighter-rouge">-sigalg SHA1withRSA</code>: 使用 SHA1withRSA 签名算法。</li>
  <li><code class="language-plaintext highlighter-rouge">-validity 3650</code>: 设置证书的有效期为 3650 天。</li>
  <li><code class="language-plaintext highlighter-rouge">-alias mycert</code>: 设置别名为 <code class="language-plaintext highlighter-rouge">mycert</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">-keystore my.p12</code>: 指定生成的密钥库文件名为 <code class="language-plaintext highlighter-rouge">my.p12</code>。</li>
  <li><code class="language-plaintext highlighter-rouge">-storetype PKCS12</code>: 指定密钥库类型为 PKCS12。</li>
  <li><code class="language-plaintext highlighter-rouge">-dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</code>: 设置证书主题信息，包括通用名称 (CN)、组织单位 (OU)、组织 (O)、城市 (L)、州/省 (ST) 和国家代码 (C)。</li>
</ul>

<p>这条命令的作用是生成一个包含指定 RSA 密钥对和证书信息的 PKCS12 格式的密钥库文件 <code class="language-plaintext highlighter-rouge">my.p12</code>。</p>

<p>有了key store存储的证书，就可以通过数字证书进行加解密和签名：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.KeyStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.PrivateKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.Signature</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.cert.X509Certificate</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>  <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, use X.509 cert!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="c1">// 读取KeyStore:</span>
        <span class="nc">KeyStore</span> <span class="n">ks</span> <span class="o">=</span> <span class="n">loadKeyStore</span><span class="o">(</span><span class="s">"my.p12"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">);</span>
        <span class="c1">// 读取私钥:,用alias指定的名字</span>
        <span class="nc">PrivateKey</span> <span class="n">privateKey</span> <span class="o">=</span> <span class="o">(</span><span class="nc">PrivateKey</span><span class="o">)</span> <span class="n">ks</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="s">"mycert"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
        <span class="c1">// 读取证书:</span>
        <span class="nc">X509Certificate</span> <span class="n">certificate</span> <span class="o">=</span> <span class="o">(</span><span class="nc">X509Certificate</span><span class="o">)</span> <span class="n">ks</span><span class="o">.</span><span class="na">getCertificate</span><span class="o">(</span><span class="s">"mycert"</span><span class="o">);</span>
        <span class="c1">// 公钥加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">certificate</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span>
        <span class="c1">// 私钥解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">privateKey</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"decrypted: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="c1">// 用私钥签名:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="o">(</span><span class="n">privateKey</span><span class="o">,</span> <span class="n">certificate</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">sign</span><span class="o">);</span>
        <span class="c1">// 用公钥验证签名:</span>
        <span class="kt">boolean</span> <span class="n">verified</span> <span class="o">=</span> <span class="n">verify</span><span class="o">(</span><span class="n">certificate</span><span class="o">,</span> <span class="n">message</span><span class="o">,</span> <span class="n">sign</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"verify: "</span> <span class="o">+</span> <span class="n">verified</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">KeyStore</span> <span class="nf">loadKeyStore</span><span class="o">(</span><span class="nc">String</span> <span class="n">keyStoreFile</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">keyStoreFile</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">input</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"file not found in classpath: "</span> <span class="o">+</span> <span class="n">keyStoreFile</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">KeyStore</span> <span class="n">ks</span> <span class="o">=</span> <span class="nc">KeyStore</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="nc">KeyStore</span><span class="o">.</span><span class="na">getDefaultType</span><span class="o">());</span>
            <span class="n">ks</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">ks</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="nc">X509Certificate</span> <span class="n">certificate</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">certificate</span><span class="o">.</span><span class="na">getPublicKey</span><span class="o">().</span><span class="na">getAlgorithm</span><span class="o">());</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">certificate</span><span class="o">.</span><span class="na">getPublicKey</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="nc">PrivateKey</span> <span class="n">privateKey</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">privateKey</span><span class="o">.</span><span class="na">getAlgorithm</span><span class="o">());</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">privateKey</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">sign</span><span class="o">(</span><span class="nc">PrivateKey</span> <span class="n">privateKey</span><span class="o">,</span> <span class="nc">X509Certificate</span> <span class="n">certificate</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Signature</span> <span class="n">signature</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">certificate</span><span class="o">.</span><span class="na">getSigAlgName</span><span class="o">());</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">privateKey</span><span class="o">);</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">signature</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="nc">X509Certificate</span> <span class="n">certificate</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">sig</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Signature</span> <span class="n">signature</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">certificate</span><span class="o">.</span><span class="na">getSigAlgName</span><span class="o">());</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">certificate</span><span class="o">);</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">signature</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">sig</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>从key store直接读取了私钥-公钥对，私钥以<code class="language-plaintext highlighter-rouge">PrivateKey</code>实例表示，公钥以<code class="language-plaintext highlighter-rouge">X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p>

<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>

<ol>
  <li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>
  <li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>
  <li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>
</ol>

<p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>

<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">简单实现HashMap</title><link href="/2024/04/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0HashMap/" rel="alternate" type="text/html" title="简单实现HashMap" /><published>2024-04-08T00:00:00+08:00</published><updated>2024-04-08T00:00:00+08:00</updated><id>/2024/04/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0HashMap</id><content type="html" xml:base="/2024/04/08/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0HashMap/"><![CDATA[<h1 id="引言">引言</h1>
<p>简单实现HashMap，包括哈希冲突处理，扩容处理，可设置默认大小与负载因子，默认大小会自动提高到最近的2的幂，扩容时容量翻倍。</p>

<h1 id="简单实现hashmap">简单实现HashMap</h1>

<p>实现的方法：</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V put(K key, V value)</td>
      <td>把<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>做映射并放入<code class="language-plaintext highlighter-rouge">Map</code>。如果放入的<code class="language-plaintext highlighter-rouge">key</code><strong>已经存在</strong>，则会更新<code class="language-plaintext highlighter-rouge">value</code>并返回被删除的旧的<code class="language-plaintext highlighter-rouge">value</code>，否则，返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>V get(K key)</td>
      <td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>Set<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code> keySet()</td>
      <td>返回<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">Set</code>集合。</td>
    </tr>
    <tr>
      <td>V remove(K key)</td>
      <td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的键值对删除，并弹出<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
  </tbody>
</table>

<p>包括哈希冲突处理，扩容处理，可设置默认大小与负载因子，默认大小会自动提高到最近的2的幂，扩容时容量翻倍。</p>

<p>扩容操作包括以下步骤：</p>

<ol>
  <li>创建一个新的数组，大小是原数组的两倍。</li>
  <li>将原数组中的元素<strong>重新计算哈希值</strong>，并根据新数组的大小<strong>重新分配位置</strong>。</li>
  <li>将重新计算位置后的元素放入新数组中。</li>
  <li>将新数组设置为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的数组，替换原数组。</li>
</ol>

<p>与重新生成一个HashMap相比，扩容不需要重新建立键值对，也不需要判断<code class="language-plaintext highlighter-rouge">key</code>覆盖，但在哈希冲突后依然要重新建立链表。</p>

<p>链表为空时没有销毁，而是保留，以备下次使用，提高性能。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyHashMap</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">0.75</span><span class="no">F</span><span class="o">);</span>
<span class="c1">//        Map&lt;String, String&gt; map = new HashMap&lt;&gt;(1, 0.75F);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"游泳"</span><span class="o">,</span> <span class="s">"小红"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"跑步"</span><span class="o">,</span> <span class="s">"小刚"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美~"</span><span class="o">)+</span><span class="s">"已弹出"</span><span class="o">);</span><span class="c1">//弹出被覆盖Value</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"画画"</span><span class="o">,</span> <span class="s">"小强"</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"编程"</span><span class="o">,</span> <span class="s">"小明"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span><span class="c1">//删除key为篮球的键值对</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱、跳、rap、篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">devOut</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"key="</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="s">",value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * 自定义hashMap
 * @param &lt;K&gt; key
 * @param &lt;V&gt; value
 */</span>
<span class="kd">class</span> <span class="nc">MyHashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;{</span>
    <span class="kd">private</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="cm">/** 数组大小*/</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="o">;</span>
    <span class="cm">/** 填充因子 */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">actualSize</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="cm">/** 负载因子 */</span>
    <span class="kd">private</span> <span class="kt">float</span> <span class="n">loadFactor</span><span class="o">=</span><span class="mf">0.75f</span><span class="o">;</span>

    <span class="cm">/**
     *
     * @param initialCapacity 数组初始长度
     * @param loadFactor 负载因子
     */</span>
    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">(</span><span class="kt">int</span> <span class="n">initialCapacity</span><span class="o">,</span><span class="kt">float</span> <span class="n">loadFactor</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"非法初始容量: "</span> <span class="o">+</span> <span class="n">initialCapacity</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="nc">Float</span><span class="o">.</span><span class="na">isNaN</span><span class="o">(</span><span class="n">loadFactor</span><span class="o">)||</span><span class="n">loadFactor</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="no">F</span> <span class="o">||</span> <span class="n">loadFactor</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"非法负载因子: "</span> <span class="o">+</span> <span class="n">loadFactor</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">initialCapacity</span> <span class="o">&gt;</span> <span class="mi">1073741824</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">initialCapacity</span> <span class="o">=</span> <span class="mi">1073741824</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 提升到2的整数幂</span>
        <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">nextPowerOfTwo</span><span class="o">(</span><span class="n">initialCapacity</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loadFactor</span><span class="o">=</span><span class="n">loadFactor</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">MyHashMap</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 如果capacity不是2的整数幂，则增加到大于capacity的最近的2的整数幂
     * @param capacity 待提升数字
     * @return 2的整数幂
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">nextPowerOfTwo</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">capacity</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">capacity</span><span class="o">;</span> <span class="c1">// 如果a已经是2的整数幂，则直接返回a</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">power</span> <span class="o">&lt;</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">power</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 不断左移，直到找到大于a的最近的2的整数幂</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">power</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">get</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]==</span><span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">key</span><span class="o">)){</span>
                    <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 获取key哈希值。
     * @param key 键
     * @return key的哈希值
     */</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">getKeyHash</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">hash</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">hash</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">%</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">hash</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="no">V</span> <span class="nf">put</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">,</span> <span class="no">V</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">//哈希桶是空的</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">);</span>
            <span class="n">actualSize</span><span class="o">++;</span>
            <span class="n">expansion</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 哈希桶已占用,哈希冲突</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
            <span class="c1">//覆盖检测</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">)){</span>
                <span class="no">V</span> <span class="n">v</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                <span class="n">item</span><span class="o">.</span><span class="na">setV</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                <span class="c1">//如果覆盖，则弹出旧值</span>
                <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//无覆盖则生成链表,并添加</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="c1">//旧元素</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
            <span class="c1">//新元素</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">));</span>
            <span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="n">list</span><span class="o">;</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="c1">//是否为空链表</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">));</span>
                <span class="n">actualSize</span><span class="o">++;</span>
                <span class="n">expansion</span><span class="o">();</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//覆盖检测</span>
            <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">)){</span>
                    <span class="no">V</span> <span class="n">v</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                    <span class="n">item</span><span class="o">.</span><span class="na">setV</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
                    <span class="c1">//如果覆盖，则弹出旧值</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="c1">//无覆盖则添加</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="no">KV</span><span class="o">&lt;&gt;(</span><span class="n">key</span><span class="o">,</span><span class="n">value</span><span class="o">));</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 删除指定key的键值对
     * @param key key
     * @return value
     */</span>
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">remove</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 是一个元素,则删除,并弹出value</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="kc">null</span><span class="o">;</span>
            <span class="n">actualSize</span><span class="o">--;</span>
            <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// 是链表,则遍历,找到key相等的删除并弹出</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
            <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">array</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
            <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">key</span><span class="o">)){</span>
                    <span class="no">V</span> <span class="n">v</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                    <span class="c1">// 如果链表为空则降低填充因子</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
                        <span class="n">actualSize</span><span class="o">--;</span>
                    <span class="o">}</span>
                    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 返回所有key
     * @return Set&lt;K&gt;
     */</span>
    <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="nf">keySet</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="n">keySet</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">traverse</span><span class="o">((</span><span class="n">t</span><span class="o">)-&gt;{</span>
                <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">keySet</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">());</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">keySet</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 遍历MyHashMap,每个元素调用都调用一次callback
     * @param callback 回调函数,每个元素调用一次
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">traverse</span><span class="o">(</span><span class="nc">Callback</span> <span class="n">callback</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span><span class="k">continue</span><span class="o">;}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
                <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">o</span><span class="o">;</span>
                <span class="n">callback</span><span class="o">.</span><span class="na">onCallback</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
                <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">o</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">callback</span><span class="o">.</span><span class="na">onCallback</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 扩容
     */</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">expansion</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">((</span><span class="kt">float</span><span class="o">)</span> <span class="n">actualSize</span> <span class="o">/</span><span class="n">size</span><span class="o">&gt;=</span><span class="n">loadFactor</span><span class="o">){</span>
            <span class="c1">// 创建一个新的数组，大小是原数组的两倍。</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"扩容前："</span><span class="o">+</span><span class="n">devOut</span><span class="o">());</span>
            <span class="nc">Object</span><span class="o">[]</span> <span class="n">newArray</span><span class="o">=</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">size</span><span class="o">*</span><span class="mi">2</span><span class="o">];</span>
            <span class="c1">//重新设置哈希算法,容量翻倍</span>
            <span class="k">this</span><span class="o">.</span><span class="na">size</span><span class="o">*=</span><span class="mi">2</span><span class="o">;</span>
            <span class="c1">// 重新计算填充因子</span>
            <span class="kt">var</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">()</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">actualSize</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="o">};</span>
            <span class="c1">// 将原数组中的元素重新计算哈希值，并根据新数组的大小重新分配位置。</span>
            <span class="c1">// 将重新计算位置后的元素放入新数组中。</span>

            <span class="n">traverse</span><span class="o">((</span><span class="n">t</span><span class="o">)-&gt;{</span>
                <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">t0</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
                <span class="no">K</span> <span class="n">key</span><span class="o">=</span><span class="n">t0</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                <span class="no">V</span> <span class="n">value</span><span class="o">=</span><span class="n">t0</span><span class="o">.</span><span class="na">getV</span><span class="o">();</span>
                <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">getKeyHash</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
                <span class="c1">// 哈希桶是空的</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
                    <span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="n">t0</span><span class="o">;</span>
                    <span class="n">ref</span><span class="o">.</span><span class="na">actualSize</span><span class="o">++;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="c1">// 哈希桶已占用,哈希冲突</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="no">KV</span><span class="o">)</span>  <span class="o">{</span>
                    <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
                    <span class="no">K</span> <span class="n">k</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="na">getK</span><span class="o">();</span>
                    <span class="c1">//覆盖检测（添加前就检测了，不会有重复的key）</span>
                    <span class="c1">//无覆盖则生成链表,并添加</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
                    <span class="c1">//旧元素</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
                    <span class="c1">//新元素</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t0</span><span class="o">);</span>
                    <span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]=</span><span class="n">list</span><span class="o">;</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">]</span> <span class="k">instanceof</span> <span class="nc">List</span><span class="o">){</span>
                    <span class="nc">List</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">=(</span><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;&gt;)</span><span class="n">newArray</span><span class="o">[</span><span class="n">hash</span><span class="o">];</span>
                    <span class="c1">//是否为空链表（也不用检测了，因为扩容不会执行remove）</span>
                    <span class="c1">//覆盖检测（添加前就检测了，不会有重复的key）</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t0</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="c1">// 将新数组设置为 `HashMap` 的数组，替换原数组。</span>
            <span class="k">this</span><span class="o">.</span><span class="na">array</span><span class="o">=</span><span class="n">newArray</span><span class="o">;</span>
            <span class="c1">// 重设填充因子</span>
            <span class="k">this</span><span class="o">.</span><span class="na">actualSize</span><span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="na">actualSize</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"扩容后："</span><span class="o">+</span><span class="n">devOut</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 定义一个回调接口</span>
    <span class="kd">interface</span> <span class="nc">Callback</span><span class="o">{</span>
         <span class="kt">void</span> <span class="nf">onCallback</span><span class="o">(</span><span class="nc">Object</span><span class="o">...</span><span class="na">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">StringBuffer</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuffer</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">()).</span><span class="na">append</span><span class="o">(</span><span class="s">"{"</span><span class="o">);</span>
        <span class="kt">var</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">};</span>
        <span class="n">traverse</span><span class="o">((</span><span class="n">t</span><span class="o">)-&gt;{</span>
            <span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">item</span><span class="o">=(</span><span class="no">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;)</span><span class="n">t</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
            <span class="n">ref</span><span class="o">.</span><span class="na">flag</span> <span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ref</span><span class="o">.</span><span class="na">flag</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"}"</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">devOut</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"当前已用%d个哈希桶，哈希桶总数量：%d，结构：%s"</span><span class="o">,</span> <span class="n">actualSize</span><span class="o">,</span><span class="n">size</span><span class="o">,</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">class</span> <span class="nc">KV</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;{</span>
        <span class="kd">private</span> <span class="no">K</span> <span class="n">k</span><span class="o">;</span><span class="kd">private</span> <span class="no">V</span> <span class="n">v</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">KV</span><span class="o">(</span><span class="no">K</span> <span class="n">k</span><span class="o">,</span> <span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span><span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;}</span>
        <span class="kd">public</span> <span class="no">K</span> <span class="nf">getK</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">k</span><span class="o">;}</span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setK</span><span class="o">(</span><span class="no">K</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">k</span> <span class="o">=</span> <span class="n">k</span><span class="o">;}</span><span class="kd">public</span> <span class="no">V</span> <span class="nf">getV</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">v</span><span class="o">;}</span><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setV</span><span class="o">(</span><span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">;}</span>
        <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">v</span><span class="o">;</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>控制台输出：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>扩容前：当前已用1个哈希桶，哈希桶总数量：1，结构：[null=123]
扩容后：当前已用1个哈希桶，哈希桶总数量：2，结构：[null=123, null]
com.aotmd.MyHashMap{null=123}
com.aotmd.MyHashMap{}
不存在
不存在
扩容前：当前已用2个哈希桶，哈希桶总数量：2，结构：[跑步=小刚, [篮球=小蔡, 游泳=小红]]
扩容后：当前已用3个哈希桶，哈希桶总数量：4，结构：[跑步=小刚, 篮球=小蔡, null, 游泳=小红]
小美已弹出
已删除
当前已用3个哈希桶，哈希桶总数量：4，结构：[[跑步=小刚, 画画=小强], [编程=小明], null, [游泳=小红, 唱歌=小美~, 唱、跳、rap、篮球=小蔡]]
key=唱歌,value = 小美~
key=跑步,value = 小刚
key=游泳,value = 小红
key=编程,value = 小明
key=唱、跳、rap、篮球,value = 小蔡
key=画画,value = 小强
com.aotmd.MyHashMap{跑步=小刚,画画=小强,编程=小明,游泳=小红,唱歌=小美~,唱、跳、rap、篮球=小蔡}
</code></pre></div></div>
<p>修改一下,使用系统的HashMap,测试一下是否一致:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//MyHashMap&lt;String, String&gt; map = new MyHashMap&lt;&gt;(1, 0.75F);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mf">0.75</span><span class="no">F</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"你好"</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"你好"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"游泳"</span><span class="o">,</span> <span class="s">"小红"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"跑步"</span><span class="o">,</span> <span class="s">"小刚"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱歌"</span><span class="o">,</span> <span class="s">"小美~"</span><span class="o">)+</span><span class="s">"已弹出"</span><span class="o">);</span><span class="c1">//弹出被覆盖Value</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"画画"</span><span class="o">,</span> <span class="s">"小强"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"编程"</span><span class="o">,</span> <span class="s">"小明"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"篮球"</span><span class="o">)==</span><span class="kc">null</span><span class="o">?</span><span class="s">"不存在"</span><span class="o">:</span><span class="s">"已删除"</span><span class="o">);</span><span class="c1">//删除key为篮球的键值对</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"唱、跳、rap、篮球"</span><span class="o">,</span> <span class="s">"小蔡"</span><span class="o">);</span>
<span class="c1">//System.out.println(map.devOut());</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"key="</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="s">",value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
</code></pre></div></div>
<p>控制台输出：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{null=123}
{}
不存在
不存在
小美已弹出
已删除
key=唱歌,value = 小美~
key=编程,value = 小明
key=唱、跳、rap、篮球,value = 小蔡
key=跑步,value = 小刚
key=游泳,value = 小红
key=画画,value = 小强
{唱歌=小美~, 编程=小明, 唱、跳、rap、篮球=小蔡, 跑步=小刚, 游泳=小红, 画画=小强}
</code></pre></div></div>
<p>没有问题</p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Java集合-常用实现类</title><link href="/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/" rel="alternate" type="text/html" title="Java集合-常用实现类" /><published>2024-04-07T00:00:00+08:00</published><updated>2024-04-07T00:00:00+08:00</updated><id>/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB</id><content type="html" xml:base="/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/"><![CDATA[<h1 id="引言">引言</h1>
<p>java集合常用实现类，ArrayList、HashMap、EnumMap、TreeMap、Properties、Set、Queue、PriorityQueue、Deque、Stack、Iterator。</p>

<h1 id="集合">集合</h1>
<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <span class="c1">// 可以持有10个String对象</span>
<span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span> <span class="c1">// 可以放入String对象</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 可以获取String对象</span>
</code></pre></div></div>
<p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>
<ul>
  <li>数组初始化后大小不可变；</li>
  <li>数组只能按索引顺序存取。</li>
</ul>

<p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>
<ul>
  <li>可变大小的顺序链表；</li>
  <li>保证无重复元素的集合；</li>
</ul>

<h1 id="collection">Collection</h1>
<p>Java标准库自带的<code class="language-plaintext highlighter-rouge">java.util</code>包提供了集合类：<code class="language-plaintext highlighter-rouge">Collection</code>，它是除<code class="language-plaintext highlighter-rouge">Map</code>外所有其他集合类的根接口。Java的<code class="language-plaintext highlighter-rouge">java.util</code>包主要提供了以下三种类型的集合：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">List</code>：一种有序列表的集合，例如，按索引排列的<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">List</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">Set</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">name</code>查找对应<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">Map</code>。</li>
</ul>

<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code class="language-plaintext highlighter-rouge">List</code>，具体的实现类有<code class="language-plaintext highlighter-rouge">ArrayList</code>，<code class="language-plaintext highlighter-rouge">LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 只能放入String类型
</code></pre></div></div>
<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>

<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Hashtable</code>：一种线程安全的<code class="language-plaintext highlighter-rouge">Map</code>实现；</li>
  <li><code class="language-plaintext highlighter-rouge">Vector</code>：一种线程安全的<code class="language-plaintext highlighter-rouge">List</code>实现；</li>
  <li><code class="language-plaintext highlighter-rouge">Stack</code>：基于<code class="language-plaintext highlighter-rouge">Vector</code>实现的<code class="language-plaintext highlighter-rouge">LIFO</code>的栈。</li>
</ul>

<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Enumeration&lt;E&gt;</code>：已被<code class="language-plaintext highlighter-rouge">Iterator&lt;E&gt;</code>取代。</li>
</ul>

<h1 id="list">List</h1>
<p><strong><code class="language-plaintext highlighter-rouge">List</code>的子接口</strong>除了<code class="language-plaintext highlighter-rouge">List</code>接口外，还有<code class="language-plaintext highlighter-rouge">Deque</code>（双端队列）和<code class="language-plaintext highlighter-rouge">Queue</code>（队列）等接口，它们分别代表具有不同特性的列表。<code class="language-plaintext highlighter-rouge">Deque</code>支持在两端添加和删除元素，而<code class="language-plaintext highlighter-rouge">Queue</code>通常采用先进先出（FIFO）的方式管理元素。</p>

<p>在Java 8中，集合框架引入了一些新的特性，如<code class="language-plaintext highlighter-rouge">forEach()</code>方法、<code class="language-plaintext highlighter-rouge">stream</code>流操作、函数式接口等，可以更方便地对集合进行操作和处理。</p>

<p>在实际应用中，需要增删元素的有序列表，我们使用最多的是<code class="language-plaintext highlighter-rouge">ArrayList</code>。</p>

<p><code class="language-plaintext highlighter-rouge">ArrayList</code>把添加和删除的操作封装起来，让我们操作<code class="language-plaintext highlighter-rouge">List</code>类似于操作数组，却不用关心内部元素如何移动。</p>

<p><code class="language-plaintext highlighter-rouge">List&lt;E&gt;</code>接口有几个主要的接口方法：</p>

<ul>
  <li>在末尾添加一个元素：<code class="language-plaintext highlighter-rouge">boolean add(E e)</code></li>
  <li>在指定索引添加一个元素：<code class="language-plaintext highlighter-rouge">boolean add(int index, E e)</code></li>
  <li>删除指定索引的元素：<code class="language-plaintext highlighter-rouge">E remove(int index)</code></li>
  <li>删除某个元素：<code class="language-plaintext highlighter-rouge">boolean remove(Object e)</code></li>
  <li>获取指定索引的元素：<code class="language-plaintext highlighter-rouge">E get(int index)</code></li>
  <li>获取链表大小（包含元素的个数）：<code class="language-plaintext highlighter-rouge">int size()</code></li>
</ul>

<p>实现<code class="language-plaintext highlighter-rouge">List</code>接口并非只能通过数组（即<code class="language-plaintext highlighter-rouge">ArrayList</code>的实现方式）来实现，另一种<code class="language-plaintext highlighter-rouge">LinkedList</code>通过“链表”也实现了List接口。在<code class="language-plaintext highlighter-rouge">LinkedList</code>中，它的内部每个元素都指向在<code class="language-plaintext highlighter-rouge">LinkedList</code>中，它的内部每个元素都指向下一个元素：</p>
<pre><code class="language-ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐
HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │
        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘
</code></pre>

<p>我们来比较一下<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">ArrayList</th>
      <th style="text-align: left">LinkedList</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">获取指定元素</td>
      <td style="text-align: left">速度很快</td>
      <td style="text-align: left">需要从头开始查找元素</td>
    </tr>
    <tr>
      <td style="text-align: left">添加元素到末尾</td>
      <td style="text-align: left">速度很快</td>
      <td style="text-align: left">速度很快</td>
    </tr>
    <tr>
      <td style="text-align: left">在指定位置添加/删除</td>
      <td style="text-align: left">需要移动元素</td>
      <td style="text-align: left">不需要移动元素</td>
    </tr>
    <tr>
      <td style="text-align: left">内存占用</td>
      <td style="text-align: left">少</td>
      <td style="text-align: left">较大</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">ArrayList</code>适合随机访问，而<code class="language-plaintext highlighter-rouge">LinkedList</code>适合插入和删除操作频繁的场景。</p>

<p>通常情况下，我们总是优先使用<code class="language-plaintext highlighter-rouge">ArrayList</code>。<code class="language-plaintext highlighter-rouge">List</code>接口<strong>允许</strong>添加<strong>重复</strong>的元素，<code class="language-plaintext highlighter-rouge">List</code>还<strong>允许添加</strong><code class="language-plaintext highlighter-rouge">null</code>。</p>

<p>除了使用<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>，我们还可以通过<code class="language-plaintext highlighter-rouge">List</code>接口提供的<code class="language-plaintext highlighter-rouge">of()</code>方法，根据给定元素快速创建<code class="language-plaintext highlighter-rouge">List</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</code></pre></div></div>
<p>但是<code class="language-plaintext highlighter-rouge">List.of()</code>方法不接受<code class="language-plaintext highlighter-rouge">null</code>值，如果传入<code class="language-plaintext highlighter-rouge">null</code>，会抛出<code class="language-plaintext highlighter-rouge">NullPointerException</code>异常。</p>
<h2 id="遍历list">遍历List</h2>
<p>可以用<code class="language-plaintext highlighter-rouge">for</code>循环根据索引配合<code class="language-plaintext highlighter-rouge">get(int)</code>方法遍历，但这种方式并不推荐，一是代码复杂，二是因为<code class="language-plaintext highlighter-rouge">get(int)</code>方法只有<code class="language-plaintext highlighter-rouge">ArrayList</code>的实现是高效的，换成<code class="language-plaintext highlighter-rouge">LinkedList</code>后，索引越大，访问速度越慢。</p>

<p>迭代器<code class="language-plaintext highlighter-rouge">Iterator</code>本身也是一个对象，但它是由<code class="language-plaintext highlighter-rouge">List</code>的<strong>实例</strong>调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法的时候创建的。<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何遍历一个<code class="language-plaintext highlighter-rouge">List</code>，并且不同的<code class="language-plaintext highlighter-rouge">List</code>类型，返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象实现也是不同的，但<strong>总是</strong>具有<strong>最高</strong>的访问效率。</p>

<p><code class="language-plaintext highlighter-rouge">Iterator</code>对象有两个方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">boolean hasNext()</code>判断是否有下一个元素</li>
  <li><code class="language-plaintext highlighter-rouge">E next()</code>返回下一个元素。</li>
</ul>

<p>使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历<code class="language-plaintext highlighter-rouge">List</code>代码如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
    <span class="nc">Integer</span> <span class="n">next</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>由于<code class="language-plaintext highlighter-rouge">Iterator</code>遍历是如此常用，所以，Java的<code class="language-plaintext highlighter-rouge">for each</code>循环本身就可以帮我们使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">next</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>只要实现了<code class="language-plaintext highlighter-rouge">Iterable</code>接口的集合类都可以直接用<code class="language-plaintext highlighter-rouge">for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code class="language-plaintext highlighter-rouge">for each</code>循环变成<code class="language-plaintext highlighter-rouge">Iterator</code>的调用，原因就在于<code class="language-plaintext highlighter-rouge">Iterable</code>接口定义了一个<code class="language-plaintext highlighter-rouge">Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>实例。</p>

<p>在使用迭代器遍历集合时，如果在遍历过程中<strong>修改</strong>了集合的结构（例如添加或删除元素），会导致<code class="language-plaintext highlighter-rouge">ConcurrentModificationException</code>异常。为了避免这种情况，可以使用迭代器的<code class="language-plaintext highlighter-rouge">remove()</code>方法来删除元素，而不是直接调用集合的删除方法。</p>

<h2 id="list和array转换">List和Array转换</h2>
<p>把<code class="language-plaintext highlighter-rouge">List</code>变为<code class="language-plaintext highlighter-rouge">Array</code>有三种方法：</p>

<p><strong>1.</strong>调用<code class="language-plaintext highlighter-rouge">toArray()</code>方法直接返回一个<code class="language-plaintext highlighter-rouge">Object[]</code>数组，这种方法会丢失类型信息，所以实际应用很少。</p>

<p><strong>2.</strong>给<code class="language-plaintext highlighter-rouge">toArray(T[])</code>传入一个类型相同的<code class="language-plaintext highlighter-rouge">Array</code>，<code class="language-plaintext highlighter-rouge">List</code>内部自动把元素复制到传入的<code class="language-plaintext highlighter-rouge">Array</code>中：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">56</span><span class="o">);</span>
    <span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">n</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">toArray(T[])</code>是泛型方法，因此<code class="language-plaintext highlighter-rouge">T</code>是<strong>独立</strong>的，可以传入其他类型的数组，比如<code class="language-plaintext highlighter-rouge">Number</code>类型，如果传入不兼容类型的数组，则会抛出<code class="language-plaintext highlighter-rouge">ArrayStoreException</code>，如果传入的数组长度小了，则会自动创建一个刚好够大的数组，如果多了则对多的部分填<code class="language-plaintext highlighter-rouge">null</code>。</p>

<p>最常用的是传入一个“恰好”大小的数组：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
</code></pre></div></div>
<p><strong>3.</strong>更简洁的写法是使用<code class="language-plaintext highlighter-rouge">List</code>接口定义的<code class="language-plaintext highlighter-rouge">T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div>
<p>当使用 <code class="language-plaintext highlighter-rouge">toArray(IntFunction&lt;A[]&gt; generator)</code> 方法时，它会使用传入的 <code class="language-plaintext highlighter-rouge">generator</code> 函数来创建一个新的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，数组的大小通常为列表的大小。<code class="language-plaintext highlighter-rouge">IntFunction&lt;A[]&gt; generator</code> 是一个函数式接口，接受一个整数参数并返回一个泛型数组。可以通过方法引用 <code class="language-plaintext highlighter-rouge">Integer[]::new</code> 来指定生成的数组类型。<a href="#方法引用">详细解释请看这里</a>。</p>

<p>反过来，把<code class="language-plaintext highlighter-rouge">Array</code>变为<code class="language-plaintext highlighter-rouge">List</code>就简单多了，通过<code class="language-plaintext highlighter-rouge">List.of(T...)</code>方法最简单：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">};</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
</code></pre></div></div>
<p>对于JDK 11之前的版本，可以使用<code class="language-plaintext highlighter-rouge">Arrays.asList(T...)</code>方法把数组转换成<code class="language-plaintext highlighter-rouge">List</code>。</p>

<p>因为返回的<code class="language-plaintext highlighter-rouge">List</code>不一定就是<code class="language-plaintext highlighter-rouge">ArrayList</code>或者<code class="language-plaintext highlighter-rouge">LinkedList</code>，因此转换后返回的是一个<strong>只读</strong><code class="language-plaintext highlighter-rouge">List</code>。</p>

<h2 id="equals方法">equals()方法</h2>
<p><code class="language-plaintext highlighter-rouge">boolean contains(Object o)</code>方法判断<code class="language-plaintext highlighter-rouge">List</code>是否包含某个指定元素。</p>

<p><code class="language-plaintext highlighter-rouge">int indexOf(Object o)</code>方法返回某个元素的索引，如果元素不存在，就返回<code class="language-plaintext highlighter-rouge">-1</code>。</p>

<p>实际上<code class="language-plaintext highlighter-rouge">contains()</code>内部也是调用的<code class="language-plaintext highlighter-rouge">indexOf()</code>,<code class="language-plaintext highlighter-rouge">indexOf()</code>内部<strong>会使用</strong><code class="language-plaintext highlighter-rouge">equals()</code><strong>判断是否相等</strong>而不是使用<code class="language-plaintext highlighter-rouge">==</code>判断。<code class="language-plaintext highlighter-rouge">ArrayList&lt;&gt;</code>的<code class="language-plaintext highlighter-rouge">indexOf()</code>的源码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">E</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>因此如果<strong>要使用</strong><code class="language-plaintext highlighter-rouge">List</code>的<code class="language-plaintext highlighter-rouge">contains()</code>、<code class="language-plaintext highlighter-rouge">indexOf()</code>方法，<strong>必须</strong>正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>方法，否则，放进去的实例的<code class="language-plaintext highlighter-rouge">equals()</code>方法就是继承自<code class="language-plaintext highlighter-rouge">Object</code>的<code class="language-plaintext highlighter-rouge">equals()</code>，也就是<code class="language-plaintext highlighter-rouge">==</code>，因此永远不相等。</p>

<hr />

<p><strong>编写equals</strong></p>

<p><code class="language-plaintext highlighter-rouge">equals()</code>方法必须满足以下条件：</p>

<ul>
  <li>自反性（Reflexive）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>来说，<code class="language-plaintext highlighter-rouge">x.equals(x)</code>必须返回<code class="language-plaintext highlighter-rouge">true</code>；</li>
  <li>对称性（Symmetric）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>来说，如果<code class="language-plaintext highlighter-rouge">x.equals(y)</code>为<code class="language-plaintext highlighter-rouge">true</code>，则<code class="language-plaintext highlighter-rouge">y.equals(x)</code>也必须为<code class="language-plaintext highlighter-rouge">true</code>；</li>
  <li>传递性（Transitive）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>和<code class="language-plaintext highlighter-rouge">z</code>来说，如果<code class="language-plaintext highlighter-rouge">x.equals(y)</code>为<code class="language-plaintext highlighter-rouge">true</code>，<code class="language-plaintext highlighter-rouge">y.equals(z)</code>也为<code class="language-plaintext highlighter-rouge">true</code>，那么<code class="language-plaintext highlighter-rouge">x.equals(z)</code>也必须为<code class="language-plaintext highlighter-rouge">true</code>；</li>
  <li>一致性（Consistent）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>来说，只要<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>状态不变，则<code class="language-plaintext highlighter-rouge">x.equals(y)</code>总是一致地返回<code class="language-plaintext highlighter-rouge">true</code>或者<code class="language-plaintext highlighter-rouge">false</code>；</li>
  <li>对<code class="language-plaintext highlighter-rouge">null</code>的比较：即<code class="language-plaintext highlighter-rouge">x.equals(null)</code>永远返回<code class="language-plaintext highlighter-rouge">false</code>。</li>
</ul>

<p>以<code class="language-plaintext highlighter-rouge">Person</code>类为例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>首先，定义“相等”的逻辑含义。对于<code class="language-plaintext highlighter-rouge">Person</code>类，如果<code class="language-plaintext highlighter-rouge">name</code>相等，并且<code class="language-plaintext highlighter-rouge">age</code>相等，我们就认为两个<code class="language-plaintext highlighter-rouge">Person</code>实例相等。对于<strong>引用字段</strong>比较，使用<code class="language-plaintext highlighter-rouge">equals()</code>，对于<strong>基本类型字段</strong>的比较，使用<code class="language-plaintext highlighter-rouge">==</code>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">nameEquals</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//如果都是null则相等</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nameEquals</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//如果this.name不是null则调用它的equals</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nameEquals</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nameEquals</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>如果<code class="language-plaintext highlighter-rouge">Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code class="language-plaintext highlighter-rouge">Objects.equals()</code>静态方法，注意不是<code class="language-plaintext highlighter-rouge">Object</code>而是<code class="language-plaintext highlighter-rouge">Objects</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Objects.equals()</code>静态方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</code></pre></div></div>
<p>是同一个对象或都是<code class="language-plaintext highlighter-rouge">null</code>，<code class="language-plaintext highlighter-rouge">a</code>不是<code class="language-plaintext highlighter-rouge">null</code>则调用<code class="language-plaintext highlighter-rouge">a</code>的<code class="language-plaintext highlighter-rouge">equals</code></p>

<p>要求是同一个类的写法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="map">Map</h1>
<p>通过一个键去查询对应的值。使用<code class="language-plaintext highlighter-rouge">List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code class="language-plaintext highlighter-rouge">Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code class="language-plaintext highlighter-rouge">key</code>快速查找<code class="language-plaintext highlighter-rouge">value</code>（元素）。</p>

<p><code class="language-plaintext highlighter-rouge">Map</code>也是一个接口，最常用的实现类是<code class="language-plaintext highlighter-rouge">HashMap</code>。除了<code class="language-plaintext highlighter-rouge">HashMap</code>外，还有<code class="language-plaintext highlighter-rouge">TreeMap</code>（基于红黑树实现）和<code class="language-plaintext highlighter-rouge">LinkedHashMap</code>（保持插入顺序或访问顺序）等<code class="language-plaintext highlighter-rouge">Map</code>的实现类，它们可以根据具体的需求选择合适的实现类。</p>

<p><code class="language-plaintext highlighter-rouge">HashMap</code>之所以能根据<code class="language-plaintext highlighter-rouge">key</code>直接拿到<code class="language-plaintext highlighter-rouge">value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code class="language-plaintext highlighter-rouge">value</code>，并根据key直接计算出<code class="language-plaintext highlighter-rouge">value</code>应该存储在哪个索引。</p>

<p><code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">key</code>不能重复，<code class="language-plaintext highlighter-rouge">value</code>可以重复。<code class="language-plaintext highlighter-rouge">Map</code><strong>不保证顺序</strong>。</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>V put(K key, V value)</td>
      <td>把<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>做了映射并放入<code class="language-plaintext highlighter-rouge">Map</code>。如果放入的<code class="language-plaintext highlighter-rouge">key</code><strong>已经存在</strong>，则会更新<code class="language-plaintext highlighter-rouge">value</code>并返回被删除的旧的<code class="language-plaintext highlighter-rouge">value</code>，否则，返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>V get(K key)</td>
      <td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>boolean containsKey(K key)</td>
      <td>查询某个<code class="language-plaintext highlighter-rouge">key</code>是否存在。</td>
    </tr>
    <tr>
      <td>boolean containsValue(V value)</td>
      <td>查询某个<code class="language-plaintext highlighter-rouge">value</code>是否存在。</td>
    </tr>
    <tr>
      <td>keySet()</td>
      <td>返回<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">Set</code>集合。</td>
    </tr>
    <tr>
      <td>entrySet()</td>
      <td>返回此地图中包含的映射的<code class="language-plaintext highlighter-rouge">Set</code>视图。</td>
    </tr>
  </tbody>
</table>

<p><strong>遍历</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k1"</span><span class="o">,</span><span class="s">"v1"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k2"</span><span class="o">,</span><span class="s">"v2"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k3"</span><span class="o">,</span><span class="s">"v3"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStringEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringStringEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringStringEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value = "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>使用<code class="language-plaintext highlighter-rouge">key</code>存取<code class="language-plaintext highlighter-rouge">value</code>的时候，就会引出一个问题：</p>

<p>获取<code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">value</code>时，传入的<code class="language-plaintext highlighter-rouge">key</code>不一定就是放入的那个<code class="language-plaintext highlighter-rouge">key</code>对象。而<code class="language-plaintext highlighter-rouge">Map</code>依然能够正常读取。换句话讲，取<code class="language-plaintext highlighter-rouge">value</code>时，两个<code class="language-plaintext highlighter-rouge">key</code>应该内容相同，但不一定是同一个对象。</p>

<p>因为在<code class="language-plaintext highlighter-rouge">Map</code>的内部，对<code class="language-plaintext highlighter-rouge">key</code>做比较是通过<code class="language-plaintext highlighter-rouge">equals()</code>实现的，这一点和<code class="language-plaintext highlighter-rouge">List</code>查找元素需要正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>是一样的，即正确使用<code class="language-plaintext highlighter-rouge">Map</code><strong>必须保证</strong>：作为<code class="language-plaintext highlighter-rouge">key</code>的对象必须<strong>正确覆写</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法。</p>

<p>通过<code class="language-plaintext highlighter-rouge">key</code>计算索引的方式就是调用<code class="language-plaintext highlighter-rouge">key</code>对象的<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，它返回一个<code class="language-plaintext highlighter-rouge">int</code>整数。<code class="language-plaintext highlighter-rouge">HashMap</code>正是通过这个方法直接定位<code class="language-plaintext highlighter-rouge">key</code>对应的<code class="language-plaintext highlighter-rouge">value</code>的索引，继而直接返回<code class="language-plaintext highlighter-rouge">value</code>。</p>

<p><code class="language-plaintext highlighter-rouge">hashCode()</code>方法要严格遵循以下规范：</p>

<ol>
  <li>如果两个对象<strong>相等</strong>，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code><strong>必须</strong>相等；</li>
  <li>如果两个对象<strong>不相等</strong>，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code><strong>尽量</strong>不要相等。</li>
  <li><code class="language-plaintext highlighter-rouge">equals()</code>用到的用于比较的每一个字段，都必须在<code class="language-plaintext highlighter-rouge">hashCode()</code>中用于计算；<code class="language-plaintext highlighter-rouge">equals()</code>中没有使用到的字段，绝不可放在<code class="language-plaintext highlighter-rouge">hashCode()</code>中计算。</li>
</ol>

<p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code class="language-plaintext highlighter-rouge">hashCode()</code>，会造成<code class="language-plaintext highlighter-rouge">Map</code>内部存储冲突，即<strong>哈希冲突</strong>，使存取的效率下降。</p>

<p>示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">firstName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">firstName</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">lastName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lastName</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="n">age</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>也可以直接使用<code class="language-plaintext highlighter-rouge">Objects.hash()</code></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span><span class="n">lastName</span><span class="o">,</span><span class="n">age</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>对于放入<code class="language-plaintext highlighter-rouge">HashMap</code>的<code class="language-plaintext highlighter-rouge">value</code>对象，没有任何要求。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">));</span>
</code></pre></div></div>
<p>在<code class="language-plaintext highlighter-rouge"> HashMap</code> 中使用 <code class="language-plaintext highlighter-rouge">null</code> 作为键是可以编译通过的，因为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的实现允许键为 <code class="language-plaintext highlighter-rouge">null</code>。在这种情况下，<code class="language-plaintext highlighter-rouge">null</code> 的哈希码会被计算为 0，并存储在哈希表的第一个位置。因此，当你调用 <code class="language-plaintext highlighter-rouge">map.get(null)</code> 时，会返回键为 <code class="language-plaintext highlighter-rouge">null</code> 对应的值 “123”。但需要注意的是，在使用 <code class="language-plaintext highlighter-rouge">null </code>作为键时要格外小心，因为它可能会导致混淆和错误。</p>
<h2 id="哈希冲突">哈希冲突</h2>
<p>如果不同的两个<code class="language-plaintext highlighter-rouge">key</code>，例如<code class="language-plaintext highlighter-rouge">"a"</code>和<code class="language-plaintext highlighter-rouge">"b"</code>，它们的<code class="language-plaintext highlighter-rouge">hashCode()</code>恰好是相同的，就会造成<strong>哈希冲突</strong>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">));</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Hong"</span><span class="o">));</span>
</code></pre></div></div>
<p>假设<code class="language-plaintext highlighter-rouge">"a"</code>和<code class="language-plaintext highlighter-rouge">"b"</code>这两个<code class="language-plaintext highlighter-rouge">key</code>最终计算出的索引都是5，造成哈希冲突，那么在<code class="language-plaintext highlighter-rouge">HashMap</code>的数组中，实际存储的不是一个<code class="language-plaintext highlighter-rouge">Person</code>实例，而是一个<code class="language-plaintext highlighter-rouge">List</code>，它包含两个<code class="language-plaintext highlighter-rouge">Entry</code>，一个是<code class="language-plaintext highlighter-rouge">"a"</code>的映射，一个是<code class="language-plaintext highlighter-rouge">"b"</code>的映射：</p>
<pre><code class="language-ascii">  ┌───┐
0 │   │
  ├───┤
1 │   │
  ├───┤
2 │   │
  ├───┤
3 │   │
  ├───┤
4 │   │
  ├───┤
5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;
  ├───┤
6 │   │
  ├───┤
7 │   │
  └───┘
</code></pre>
<p>在查找的时候，例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
</code></pre></div></div>
<p>HashMap内部通过<code class="language-plaintext highlighter-rouge">"a"</code>找到的实际上是<code class="language-plaintext highlighter-rouge">List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个<code class="language-plaintext highlighter-rouge">List</code>，并找到一个<code class="language-plaintext highlighter-rouge">Entry</code>，它的<code class="language-plaintext highlighter-rouge">key</code>字段是<code class="language-plaintext highlighter-rouge">"a"</code>，才能返回对应的<code class="language-plaintext highlighter-rouge">Person</code>实例。</p>

<p>我们把不同的<code class="language-plaintext highlighter-rouge">key</code>具有相同的<code class="language-plaintext highlighter-rouge">hashCode()</code>的情况称之为<strong>哈希冲突</strong>。在冲突的时候，一种最简单的解决办法是用<code class="language-plaintext highlighter-rouge">List</code>存储<code class="language-plaintext highlighter-rouge">hashCode()</code>相同的<code class="language-plaintext highlighter-rouge">key-value</code>。显然，如果冲突的概率越大，这个<code class="language-plaintext highlighter-rouge">List</code>就越长，<code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">get()</code>方法效率就越低，这就是为什么要尽量满足条件二：如果两个对象不相等，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code>尽量不要相等。</p>

<p>HashMap中依据<code class="language-plaintext highlighter-rouge">key</code>的hash值来确定<code class="language-plaintext highlighter-rouge">value</code>存储位置，所以<strong>一定</strong>要重写<code class="language-plaintext highlighter-rouge">hashCode</code>方法，而重写<code class="language-plaintext highlighter-rouge">equals</code>方法，是为了解决<code class="language-plaintext highlighter-rouge">hash</code><strong>冲突</strong>，如果两个<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">hash</code>值相同，就会调用<code class="language-plaintext highlighter-rouge">equals</code>方法，比较<code class="language-plaintext highlighter-rouge">key</code>值是否相同。</p>

<p>在存储时：如果<code class="language-plaintext highlighter-rouge">hash</code>值相同，且<code class="language-plaintext highlighter-rouge">equals</code>结果相同就覆盖更新<code class="language-plaintext highlighter-rouge">value</code>值，如果<code class="language-plaintext highlighter-rouge">equals</code>结果不同，即不是同一个<code class="language-plaintext highlighter-rouge">key</code>，<code class="language-plaintext highlighter-rouge">HashMap</code>会将这两个<code class="language-plaintext highlighter-rouge">key-value</code>对以链表或红黑树的形式存储在同一个位置上。</p>

<p>在取值时：如果计算的<code class="language-plaintext highlighter-rouge">hash</code>值所指的索引位置有多个值，则根据<code class="language-plaintext highlighter-rouge">equals</code>方法找到对应的<code class="language-plaintext highlighter-rouge">key-value</code>对。如果<code class="language-plaintext highlighter-rouge">equals</code>结果相同就返回当前<code class="language-plaintext highlighter-rouge">value</code>值，如果不同就遍历<code class="language-plaintext highlighter-rouge">List</code>中下一个元素。即要<code class="language-plaintext highlighter-rouge">key</code>与<code class="language-plaintext highlighter-rouge">hash</code>同时匹配才会认为是同一个<code class="language-plaintext highlighter-rouge">key</code>。</p>

<p>JDK中源码:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))){</span><span class="n">ops</span><span class="o">;}</span>
</code></pre></div></div>
<h2 id="扩容">扩容</h2>
<p><code class="language-plaintext highlighter-rouge">HashMap</code>初始化时<strong>默认</strong>的<strong>数组大小</strong>为16，任何<code class="language-plaintext highlighter-rouge">key</code>，无论它的<code class="language-plaintext highlighter-rouge">hashCode()</code>有多大，都可以简单地通过：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="o">;</span> <span class="c1">// 0xf = 15</span>
</code></pre></div></div>
<p>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p>

<p>这里的<strong>数组大小指哈希桶的数量</strong>，<strong>不等于</strong>键值对的数量，而是指的是可以容纳的哈希桶的数量。每个哈希桶可以存储<strong>多个键值对</strong>（链表，红黑树），因此即使存储了大量的键值对，如果它们的<strong>哈希值冲突</strong>导致它们应该存储在同一个哈希桶中，实际上只会占用一个哈希桶的空间。<code class="language-plaintext highlighter-rouge">HashMap</code>会根据键值对的数量动态调整数组的大小，以保持较低的<strong>填充因子</strong>，从而保证较好的性能。</p>

<p><code class="language-plaintext highlighter-rouge">HashMap</code>的<strong>填充因子</strong>超过一定阈值时，<code class="language-plaintext highlighter-rouge">HashMap</code>会在内部自动扩容，每次<strong>扩容一倍</strong>。</p>

<p>阈值根据<strong>负载因子</strong>确定,默认为<strong>0.75f</strong>。</p>

<p>如果初始容量为 1024，那么当 <code class="language-plaintext highlighter-rouge">HashMap</code> 的 size 超过 1024 * 负载因子（默认是 0.75f）= 768 时，就会触发扩容操作，此时新的数组大小将是原来的两倍，即 2048。</p>

<p>扩容操作包括以下步骤：</p>

<ol>
  <li>创建一个新的数组，大小是原数组的两倍。</li>
  <li>将原数组中的元素<strong>重新计算哈希值</strong>，并根据新数组的大小<strong>重新分配位置</strong>。</li>
  <li>将重新计算位置后的元素放入新数组中。</li>
  <li>将新数组设置为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的数组，替换原数组。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">HashMap</code> 的扩容操作是一个比较<strong>耗时</strong>的操作，因为需要重新计算哈希值并重新分配位置。因此，尽量在初始化时指定 <code class="language-plaintext highlighter-rouge">HashMap</code> 的<strong>初始容量</strong>和<strong>负载因子</strong>，避免频繁扩容，提高性能。</p>

<p>在 <strong>HashMap</strong> 中，每个数组元素（哈希桶）可以存储一个链表或红黑树头节点。当<strong>链表</strong>的元素数量<strong>超过</strong>一定阈值（<strong>默认为 8</strong>）时，链表会转换为红黑树，以提高查找效率。当<strong>红黑树</strong>中的节点数量<strong>少于</strong>一个阈值（<strong>默认为6</strong>）时，红黑树会转换回链表结构。这种转换是为了避免在红黑树中维护的额外开销，因为当节点数量较少时，链表可能比红黑树更有效率。</p>

<p>红黑树在<code class="language-plaintext highlighter-rouge">HashMap</code>中是从<strong>JDK 8</strong>开始引入的。<strong>在JDK 8之前</strong>，<code class="language-plaintext highlighter-rouge">HashMap</code>使用的是<strong>数组+链表</strong>的方式来处理哈希冲突。</p>

<p>通常<strong>建议将容量设置为 2 的幂次方</strong>，如果设置的容量不是 2 的幂次方，<code class="language-plaintext highlighter-rouge">HashMap</code> 会自动向上取最接近的 2 的幂次方作为实际的容量。负载因子应该是一个大于0且小于1的浮点数，注意加f。</p>

<p>只能在初始化时设置容量和扩容因子</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">16</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="线程安全问题">线程安全问题</h2>
<p><code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">HashMap</code>等集合类是非线程安全的，这意味着如果多个线程同时访问这些集合并且至少一个线程修改了集合，就可能导致不确定的结果，比如数据丢失、数据不一致等问题。为了在多线程环境中安全地使用集合，可以使用<code class="language-plaintext highlighter-rouge">Collections</code>工具类提供的<code class="language-plaintext highlighter-rouge">SynchronizedList</code>和<code class="language-plaintext highlighter-rouge">SynchronizedMap</code>方法来获取线程安全的集合：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">synchronizedList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">synchronizedMap</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;());</span>
</code></pre></div></div>
<p>这样就可以确保在多线程环境中对集合的操作是安全的。需要注意的是，虽然这些方法提供了线程安全的集合，但在高并发的情况下仍然需要谨慎处理，以避免出现性能问题。</p>

<h1 id="enummap">EnumMap</h1>
<p><code class="language-plaintext highlighter-rouge">HashMap</code>是一种通过对key计算<code class="language-plaintext highlighter-rouge">hashCode()</code>，通过空间换时间的方式，直接定位到<code class="language-plaintext highlighter-rouge">value</code>所在的内部数组的索引，因此，查找效率非常高。</p>

<p>如果作为<code class="language-plaintext highlighter-rouge">key</code>的对象是<code class="language-plaintext highlighter-rouge">enum</code>类型，还可以使用<code class="language-plaintext highlighter-rouge">EnumMap</code>，它在内部以一个非常紧凑的数组存储<code class="language-plaintext highlighter-rouge">value</code>，并且根据<code class="language-plaintext highlighter-rouge">enum</code>类型的<code class="language-plaintext highlighter-rouge">key</code><strong>直接定位</strong>到内部数组的索引，并<strong>不需要计算</strong><code class="language-plaintext highlighter-rouge">hashCode()</code>，不但效率最高，而且没有额外的空间浪费。实例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">DayOfWeek</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EnumMap</span><span class="o">&lt;&gt;(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">MONDAY</span><span class="o">,</span> <span class="s">"星期一"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">TUESDAY</span><span class="o">,</span> <span class="s">"星期二"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">WEDNESDAY</span><span class="o">,</span> <span class="s">"星期三"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">THURSDAY</span><span class="o">,</span> <span class="s">"星期四"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">FRIDAY</span><span class="o">,</span> <span class="s">"星期五"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SATURDAY</span><span class="o">,</span> <span class="s">"星期六"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">,</span> <span class="s">"星期日"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">MONDAY</span><span class="o">));</span>
</code></pre></div></div>
<p>注意实例化时，需要将枚举的<strong>class</strong>传入构造方法。</p>

<p>使用<code class="language-plaintext highlighter-rouge">EnumMap</code>的时候，我们总是用<code class="language-plaintext highlighter-rouge">Map</code>接口来引用它，因此，实际上把<code class="language-plaintext highlighter-rouge">HashMap</code>和<code class="language-plaintext highlighter-rouge">EnumMap</code>互换，在客户端看来没有任何区别。<code class="language-plaintext highlighter-rouge">EnumMap</code>内部就存一个数组，数组大小需要根据<code class="language-plaintext highlighter-rouge">Enum</code>类型的<code class="language-plaintext highlighter-rouge">values.length</code>确定，每个<code class="language-plaintext highlighter-rouge">Enum</code>的实例都有一个唯一索引<code class="language-plaintext highlighter-rouge">ordinal()</code>。</p>

<p>由于<code class="language-plaintext highlighter-rouge">Enum</code>的<code class="language-plaintext highlighter-rouge">ordinal</code>方法提供了一个稳定的顺序，<code class="language-plaintext highlighter-rouge">EnumMap</code>可以直接使用数组来存储<code class="language-plaintext highlighter-rouge">value</code>，而<strong>不需要</strong>进行<code class="language-plaintext highlighter-rouge">hash</code>计算或者<code class="language-plaintext highlighter-rouge">equals</code>比较，因此在效率上有很大的优势。</p>

<p><code class="language-plaintext highlighter-rouge">EnumMap</code>是有序的，它的顺序和<code class="language-plaintext highlighter-rouge">Enum</code>中<code class="language-plaintext highlighter-rouge">enum</code>常量的顺序一致。这一特性在需要按照<code class="language-plaintext highlighter-rouge">Enum</code>定义的顺序进行操作时非常有用。</p>

<h1 id="treemap">TreeMap</h1>
<p>还有一种<code class="language-plaintext highlighter-rouge">Map</code>，它在内部会对Key进行排序，这种<code class="language-plaintext highlighter-rouge">Map</code>就是<code class="language-plaintext highlighter-rouge">SortedMap</code>。<code class="language-plaintext highlighter-rouge">SortedMap</code>是接口，它的实现类是<code class="language-plaintext highlighter-rouge">TreeMap</code>。</p>
<pre><code class="language-ascii">       ┌───┐
       │Map│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashMap│ │SortedMap│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeMap │
          └─────────┘
</code></pre>
<p><code class="language-plaintext highlighter-rouge">SortedMap</code><strong>保证</strong>遍历时以Key的<strong>顺序</strong>来进行<strong>排序</strong>。例如，放入的Key是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>、<code class="language-plaintext highlighter-rouge">"orange"</code>，遍历的顺序一定是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"orange"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>，因为<code class="language-plaintext highlighter-rouge">String</code>默认按字母排序。</p>

<p>使用<code class="language-plaintext highlighter-rouge">TreeMap</code>时，放入的Key<strong>必须实现</strong><code class="language-plaintext highlighter-rouge">Comparable</code>接口。<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Integer</code>这些类已经实现了<code class="language-plaintext highlighter-rouge">Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。<code class="language-plaintext highlighter-rouge">TreeMap</code><strong>不使用</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>。</p>

<p>如果作为Key的class没有实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，那么，<strong>必须</strong>在<strong>创建</strong><code class="language-plaintext highlighter-rouge">TreeMap</code>时同时<strong>指定</strong>一个自定义排序算法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Person</span> <span class="n">p1</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Tom"</span><span class="o">),</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">),</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lily"</span><span class="o">),</span> <span class="mi">3</span><span class="o">);</span>
        <span class="c1">//{Person: Bob}{Person: Lily}{Person: Tom}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">)));</span> <span class="c1">// 2</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span> <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nc">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"{Person: "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"}"</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>，如果<code class="language-plaintext highlighter-rouge">a&lt;b</code>，则返回负数，通常是<code class="language-plaintext highlighter-rouge">-1</code>，如果<code class="language-plaintext highlighter-rouge">a==b</code>，则返回<code class="language-plaintext highlighter-rouge">0</code>，如果<code class="language-plaintext highlighter-rouge">a&gt;b</code>，则返回正数，通常是<code class="language-plaintext highlighter-rouge">1</code>。<code class="language-plaintext highlighter-rouge">TreeMap</code>内部根据比较结果对Key进行排序。</p>
<h1 id="properties">Properties</h1>
<p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 上次最后打开的文件:</span>
<span class="n">last_open_file</span><span class="o">=</span><span class="sr">/data/</span><span class="n">hello</span><span class="p">.</span><span class="nf">txt</span>
<span class="c1"># 自动保存文件的时间间隔:</span>
<span class="n">auto_save_interval</span><span class="o">=</span><span class="mi">60</span>
</code></pre></div></div>
<p>配置文件的特点是，它的Key-Value一般都是<code class="language-plaintext highlighter-rouge">String</code>-<code class="language-plaintext highlighter-rouge">String</code>类型的，因此我们完全可以用<code class="language-plaintext highlighter-rouge">Map&lt;String, String&gt;</code>来表示它。</p>

<p>因为配置文件非常常用，所以Java集合库提供了一个<code class="language-plaintext highlighter-rouge">Properties</code>来表示一组“配置”。由于历史遗留原因，<code class="language-plaintext highlighter-rouge">Properties</code>内部本质上是一个<code class="language-plaintext highlighter-rouge">Hashtable</code>，但我们只需要用到<code class="language-plaintext highlighter-rouge">Properties</code>自身关于读写配置的接口。</p>

<p><strong>读取配置文件</strong></p>

<p>用<code class="language-plaintext highlighter-rouge">Properties</code>读取配置文件非常简单。Java默认配置文件以<code class="language-plaintext highlighter-rouge">.properties</code>为扩展名，每行以<code class="language-plaintext highlighter-rouge">key=value</code>表示，以<code class="language-plaintext highlighter-rouge">#</code>号开头的是注释。以下是一个典型的配置文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># setting.properties</span>

<span class="n">last_open_file</span><span class="o">=</span><span class="sr">/data/</span><span class="n">hello</span><span class="p">.</span><span class="nf">txt</span>
<span class="n">auto_save_interval</span><span class="o">=</span><span class="mi">60</span>
</code></pre></div></div>
<p>可以从文件系统读取这个<code class="language-plaintext highlighter-rouge">.properties</code>文件：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">f</span> <span class="o">=</span> <span class="s">"src/com/aotmd/text.properties"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">FileInputStream</span> <span class="n">fileInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fileInputStream</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">filepath</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"last_open_file"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"auto_save_interval"</span><span class="o">,</span> <span class="s">"120"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interval = "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"filepath = "</span> <span class="o">+</span> <span class="n">filepath</span><span class="o">);</span>
</code></pre></div></div>
<p>用<code class="language-plaintext highlighter-rouge">Properties</code>读取配置文件，一共有三步：</p>
<ol>
  <li>创建<code class="language-plaintext highlighter-rouge">Properties</code>实例；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">load()</code>读取文件；</li>
  <li>调用<code class="language-plaintext highlighter-rouge">getProperty()</code>获取配置。</li>
</ol>

<table>
  <thead>
    <tr>
      <th>返回值类型</th>
      <th>方法</th>
      <th>解释</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>String</td>
      <td>getProperty(String key)</td>
      <td>根据指定的键在此属性列表中搜索属性，如果<code class="language-plaintext highlighter-rouge">key</code>不存在，将返回<code class="language-plaintext highlighter-rouge">null</code>。</td>
    </tr>
    <tr>
      <td>String</td>
      <td>getProperty(String key, String defaultValue)</td>
      <td>获取指定键的属性值，如果该键不存在，则返回<code class="language-plaintext highlighter-rouge">defaultValue</code>。</td>
    </tr>
    <tr>
      <td>Object</td>
      <td>setProperty(String key, String value)</td>
      <td>设置指定键的值。如果键已经存在，则更新其值。</td>
    </tr>
    <tr>
      <td>Set<code class="language-plaintext highlighter-rouge">&lt;String&gt;</code></td>
      <td>stringPropertyNames()</td>
      <td>返回属性列表中的键集，其中该键及其对应的值是字符串。</td>
    </tr>
    <tr>
      <td>Enumeration&lt;?&gt;</td>
      <td>propertyNames()</td>
      <td>返回此属性列表中的键集，其中键及其对应的值不一定是字符串。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>list(PrintStream out)</td>
      <td>将属性列表输出到指定的输出流。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>list(PrintWriter out)</td>
      <td>将属性列表输出到指定的输出流。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>load(InputStream inStream)</td>
      <td>从输入流中读取属性列表（键和元素对）。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>store(OutputStream out, String comments)</td>
      <td>将此属性列表（键和元素对）以适合使用<code class="language-plaintext highlighter-rouge">load(InputStream)</code>方法加载的格式写入<code class="language-plaintext highlighter-rouge">out</code>。<code class="language-plaintext highlighter-rouge">comments</code>写入的注释</td>
    </tr>
  </tbody>
</table>

<p>也可以从<code class="language-plaintext highlighter-rouge">classpath</code>读取<code class="language-plaintext highlighter-rouge">.properties</code>文件，因为<code class="language-plaintext highlighter-rouge">load(InputStream)</code>方法接收一个<code class="language-plaintext highlighter-rouge">InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props1</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"./text.properties"</span><span class="o">));</span>
<span class="nc">String</span> <span class="n">filepath1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"last_open_file"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">interval1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"auto_save_interval"</span><span class="o">,</span> <span class="s">"120"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interval = "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"filepath = "</span> <span class="o">+</span> <span class="n">filepath</span><span class="o">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Main.class.getResourceAsStream("./text.properties")</code>用于获取位于与<code class="language-plaintext highlighter-rouge">Main.class</code>相同目录下的<code class="language-plaintext highlighter-rouge">text.properties</code>文件的输入流。</p>

<p><code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>是一个用于获取资源的方法，它会返回一个<code class="language-plaintext highlighter-rouge">InputStream</code>对象，可以用于读取资源文件的内容。</p>

<p><code class="language-plaintext highlighter-rouge">"./text.properties"</code>表示相对于<code class="language-plaintext highlighter-rouge">Main.class</code>所在目录的路径，即在<code class="language-plaintext highlighter-rouge">Main.class</code>所在目录下寻找名为<code class="language-plaintext highlighter-rouge">text.properties</code>的文件。</p>

<p>如果有多个<code class="language-plaintext highlighter-rouge">.properties</code>文件，可以反复调用<code class="language-plaintext highlighter-rouge">load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/common/setting.properties"</span><span class="o">));</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"C:\\conf\\setting.properties"</span><span class="o">));</span>
</code></pre></div></div>
<p>上面的代码演示了<code class="language-plaintext highlighter-rouge">Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p>

<p><code class="language-plaintext highlighter-rouge">Properties</code>设计的目的是存储<code class="language-plaintext highlighter-rouge">String</code>类型的key－value，但<code class="language-plaintext highlighter-rouge">Properties</code>实际上是从<code class="language-plaintext highlighter-rouge">Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了<code class="language-plaintext highlighter-rouge">getProperty()</code>和<code class="language-plaintext highlighter-rouge">setProperty()</code>方法外，还有从<code class="language-plaintext highlighter-rouge">Hashtable</code>继承下来的<code class="language-plaintext highlighter-rouge">get()</code>和<code class="language-plaintext highlighter-rouge">put()</code>方法，这些方法的参数签名是<code class="language-plaintext highlighter-rouge">Object</code>，我们在使用<code class="language-plaintext highlighter-rouge">Properties</code>的时候，不要去调用这些从<code class="language-plaintext highlighter-rouge">Hashtable</code>继承下来的方法。</p>

<p><strong>写入配置文件</strong>
如果通过<code class="language-plaintext highlighter-rouge">setProperty()</code>修改了<code class="language-plaintext highlighter-rouge">Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code class="language-plaintext highlighter-rouge">store()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">f</span> <span class="o">=</span> <span class="s">"src/com/aotmd/text.properties"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"language"</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">);</span>
<span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">fos</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">),</span> <span class="s">"这是写入的properties注释"</span><span class="o">);</span>

<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">fis</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">String</span> <span class="n">language</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"language"</span> <span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"language = "</span> <span class="o">+</span> <span class="n">language</span><span class="o">);</span>
</code></pre></div></div>
<p>早期版本的Java规定<code class="language-plaintext highlighter-rouge">.properties</code>文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code class="language-plaintext highlighter-rouge">name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code class="language-plaintext highlighter-rouge">.properties</code>文件可以使用UTF-8编码了。</p>
<h1 id="set">Set</h1>
<p><code class="language-plaintext highlighter-rouge">Map</code>用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但<strong>需要</strong>正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>方法，还要<strong>正确覆写</strong><code class="language-plaintext highlighter-rouge">hashCode()</code>方法。</p>

<p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用<code class="language-plaintext highlighter-rouge">Set</code>。</p>

<p><code class="language-plaintext highlighter-rouge">Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>

<ul>
  <li>将元素添加进<code class="language-plaintext highlighter-rouge">Set&lt;E&gt;</code>：<code class="language-plaintext highlighter-rouge">boolean add(E e)</code></li>
  <li>将元素从<code class="language-plaintext highlighter-rouge">Set&lt;E&gt;</code>删除：<code class="language-plaintext highlighter-rouge">boolean remove(Object e)</code></li>
  <li>判断是否包含元素：<code class="language-plaintext highlighter-rouge">boolean contains(Object e)</code>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"abc"</span><span class="o">));</span> <span class="c1">// true</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// true</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// false，添加失败，因为元素已存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// true，元素存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"XYZ"</span><span class="o">));</span> <span class="c1">// false，元素不存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"hello"</span><span class="o">));</span> <span class="c1">// false，删除失败，因为元素不存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span> <span class="c1">// 2，一共两个元素</span>
</code></pre></div>    </div>
    <p><code class="language-plaintext highlighter-rouge">Set</code>实际上<strong>相当于</strong>只存储key、不存储value的<code class="language-plaintext highlighter-rouge">Map</code>。经常用<code class="language-plaintext highlighter-rouge">Set</code>去除重复元素。</p>
  </li>
</ul>

<p>放入<code class="language-plaintext highlighter-rouge">Set</code>的元素和<code class="language-plaintext highlighter-rouge">Map</code>的key类似，都要<strong>正确实现</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，否则该元素无法正确地放入<code class="language-plaintext highlighter-rouge">Set</code>。</p>

<p>最常用的<code class="language-plaintext highlighter-rouge">Set</code>实现类是<code class="language-plaintext highlighter-rouge">HashSet</code>，实际上，<code class="language-plaintext highlighter-rouge">HashSet</code>仅仅是对<code class="language-plaintext highlighter-rouge">HashMap</code>的一个简单封装，它的核心代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 持有一个HashMap:</span>
    <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">E</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 放入HashMap的value:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="no">PRESENT</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">PRESENT</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">o</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">==</span> <span class="no">PRESENT</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Set</code>接口并不保证有序，而<code class="language-plaintext highlighter-rouge">SortedSet</code>接口则保证元素是有序的：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">HashSet</code>是<strong>无序</strong>的，因为它实现了<code class="language-plaintext highlighter-rouge">Set</code>接口，并没有实现<code class="language-plaintext highlighter-rouge">SortedSet</code>接口；</li>
  <li><code class="language-plaintext highlighter-rouge">TreeSet</code>是<strong>有序</strong>的，因为它实现了<code class="language-plaintext highlighter-rouge">SortedSet</code>接口。</li>
</ul>

<p>用一张图表示：</p>
<pre><code class="language-ascii">       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
</code></pre>
<p>使用<code class="language-plaintext highlighter-rouge">TreeSet</code>和使用<code class="language-plaintext highlighter-rouge">TreeMap</code>的要求一样，添加的元素必须正确实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，如果没有实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，那么创建<code class="language-plaintext highlighter-rouge">TreeSet</code>时必须传入一个<code class="language-plaintext highlighter-rouge">Comparator</code>对象。</p>

<p><code class="language-plaintext highlighter-rouge">Set</code>用于存储不重复的元素集合：</p>

<ul>
  <li>放入<code class="language-plaintext highlighter-rouge">HashSet</code>的元素与作为<code class="language-plaintext highlighter-rouge">HashMap</code>的key要求相同；</li>
  <li>放入<code class="language-plaintext highlighter-rouge">TreeSet</code>的元素与作为<code class="language-plaintext highlighter-rouge">TreeMap</code>的Key要求相同；</li>
</ul>

<p>利用<code class="language-plaintext highlighter-rouge">Set</code>可以去除重复元素；</p>

<p>遍历<code class="language-plaintext highlighter-rouge">SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p>

<h1 id="queue">Queue</h1>
<p>队列（<code class="language-plaintext highlighter-rouge">Queue</code>）是一种经常使用的集合。<code class="language-plaintext highlighter-rouge">Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code class="language-plaintext highlighter-rouge">List</code>的区别在于，<code class="language-plaintext highlighter-rouge">List</code>可以在任意位置添加和删除元素，而<code class="language-plaintext highlighter-rouge">Queue</code>只有两个操作：</p>
<ul>
  <li>把元素添加到队列末尾；</li>
  <li>从队列头部取出元素。</li>
</ul>

<p>在Java的标准库中，队列接口<code class="language-plaintext highlighter-rouge">Queue</code>定义了以下几个方法：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">int size()</code>：获取队列长度；</li>
  <li><code class="language-plaintext highlighter-rouge">boolean add(E)</code>/<code class="language-plaintext highlighter-rouge">boolean offer(E)</code>：添加元素到队尾；</li>
  <li><code class="language-plaintext highlighter-rouge">E remove()</code>/<code class="language-plaintext highlighter-rouge">E poll()</code>：获取队首元素并从队列中删除；</li>
  <li><code class="language-plaintext highlighter-rouge">E element()</code>/<code class="language-plaintext highlighter-rouge">E peek()</code>：获取队首元素但并不从队列中删除。</li>
</ul>

<p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。</p>

<p>注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素<strong>失败</strong>时，这两个方法的<strong>行为</strong>是<strong>不同</strong>的。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">throw Exception</th>
      <th style="text-align: left">返回false或null</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">添加元素到队尾</td>
      <td style="text-align: left">add(E e)</td>
      <td style="text-align: left">boolean offer(E e)，添加失败返回false</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素并删除</td>
      <td style="text-align: left">E remove()</td>
      <td style="text-align: left">E poll()，失败返回null</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素但不删除</td>
      <td style="text-align: left">E element()</td>
      <td style="text-align: left">E peek()，失败返回null</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"remove"</span><span class="o">);</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"element"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">element</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

<span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"poll"</span><span class="o">);</span>
<span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"peek"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</code></pre></div></div>

<p><strong>不要</strong>把<code class="language-plaintext highlighter-rouge">null</code>添加到队列中，否则<code class="language-plaintext highlighter-rouge">poll()</code>方法返回<code class="language-plaintext highlighter-rouge">null</code>时，很难确定是取到了<code class="language-plaintext highlighter-rouge">null</code>元素还是队列为空。</p>

<p><code class="language-plaintext highlighter-rouge">LinkedList</code>即实现了<code class="language-plaintext highlighter-rouge">List</code>接口，又实现了<code class="language-plaintext highlighter-rouge">Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这是一个List:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 这是一个Queue:</span>
<span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<h1 id="priorityqueue">PriorityQueue</h1>

<p><code class="language-plaintext highlighter-rouge">Queue</code>是一个先进先出（FIFO）的队列。<code class="language-plaintext highlighter-rouge">PriorityQueue</code>和<code class="language-plaintext highlighter-rouge">Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code class="language-plaintext highlighter-rouge">PriorityQueue</code>调用<code class="language-plaintext highlighter-rouge">remove()</code>或<code class="language-plaintext highlighter-rouge">poll()</code>方法，返回的总是优先级最高的元素。</p>

<p>要使用<code class="language-plaintext highlighter-rouge">PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 添加3个元素到队列:</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"apple"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"pear"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// apple</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// banana</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// pear</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// null,因为队列为空</span>
</code></pre></div></div>

<p>放入的顺序是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>、<code class="language-plaintext highlighter-rouge">"banana"</code>，但是取出的顺序却是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"banana"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>，这是因为从字符串的排序看，<code class="language-plaintext highlighter-rouge">"apple"</code>排在最前面，<code class="language-plaintext highlighter-rouge">"pear"</code>排在最后面。</p>

<p>放入<code class="language-plaintext highlighter-rouge">PriorityQueue</code>的元素，必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，<code class="language-plaintext highlighter-rouge">PriorityQueue</code>会根据元素的<strong>排序顺序</strong>决定出队的优先级。</p>

<p><code class="language-plaintext highlighter-rouge">PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口），也可以通过<code class="language-plaintext highlighter-rouge">Comparator</code>自定义排序算法（元素就不必实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口）。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">u1</span><span class="o">,</span><span class="n">u2</span><span class="o">)-&gt;{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">u2</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span>
                <span class="kt">int</span> <span class="n">no1</span><span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
                <span class="kt">int</span> <span class="n">no2</span><span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">u2</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
                <span class="k">return</span> <span class="n">no1</span><span class="o">-</span><span class="n">no2</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'V'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// u1的号码是V开头,优先级高:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="c1">// 添加3个元素到队列:</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"A1"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"A2"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Boss"</span><span class="o">,</span> <span class="s">"V1"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Boss"</span><span class="o">,</span> <span class="s">"V10"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Boss/V1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Boss/V10</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Bob/A1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Alice/A2</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span><span class="n">number</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span><span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"User{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", number='"</span> <span class="o">+</span> <span class="n">number</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h1 id="deque">Deque</h1>

<p><code class="language-plaintext highlighter-rouge">Queue</code>是队列，只能一头进，另一头出。</p>

<p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code class="language-plaintext highlighter-rouge">Deque</code>。</p>

<p>Java集合提供了接口<code class="language-plaintext highlighter-rouge">Deque</code>来实现一个双端队列，它的功能是：</p>

<ul>
  <li>既可以添加到队尾，也可以添加到队首；</li>
  <li>既可以从队首获取，又可以从队尾获取。</li>
</ul>

<p>比较<code class="language-plaintext highlighter-rouge">Queue</code>和<code class="language-plaintext highlighter-rouge">Deque</code>出队和入队的方法：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">Queue</th>
      <th style="text-align: left">Deque</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">添加元素到队尾</td>
      <td style="text-align: left">add(E e) / offer(E e)</td>
      <td style="text-align: left">addLast(E e) / offerLast(E e)</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素并删除</td>
      <td style="text-align: left">E remove() / E poll()</td>
      <td style="text-align: left">E removeFirst() / E pollFirst()</td>
    </tr>
    <tr>
      <td style="text-align: left">取队首元素但不删除</td>
      <td style="text-align: left">E element() / E peek()</td>
      <td style="text-align: left">E getFirst() / E peekFirst()</td>
    </tr>
    <tr>
      <td style="text-align: left">添加元素到队首</td>
      <td style="text-align: left">无</td>
      <td style="text-align: left">addFirst(E e) / offerFirst(E e)</td>
    </tr>
    <tr>
      <td style="text-align: left">取队尾元素并删除</td>
      <td style="text-align: left">无</td>
      <td style="text-align: left">E removeLast() / E pollLast()</td>
    </tr>
    <tr>
      <td style="text-align: left">取队尾元素但不删除</td>
      <td style="text-align: left">无</td>
      <td style="text-align: left">E getLast() / E peekLast()</td>
    </tr>
  </tbody>
</table>

<p>对于添加元素到队尾的操作，<code class="language-plaintext highlighter-rouge">Queue</code>提供了<code class="language-plaintext highlighter-rouge">add()</code>/<code class="language-plaintext highlighter-rouge">offer()</code>方法，而<code class="language-plaintext highlighter-rouge">Deque</code>提供了<code class="language-plaintext highlighter-rouge">addLast()</code>/<code class="language-plaintext highlighter-rouge">offerLast()</code>方法。添加元素到队首、取队尾元素的操作在<code class="language-plaintext highlighter-rouge">Queue</code>中不存在，在<code class="language-plaintext highlighter-rouge">Deque</code>中由<code class="language-plaintext highlighter-rouge">addFirst()</code>/<code class="language-plaintext highlighter-rouge">removeLast()</code>等方法提供。</p>

<p><code class="language-plaintext highlighter-rouge">Deque</code>接口实际上扩展自<code class="language-plaintext highlighter-rouge">Queue</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>
<p>因此，<code class="language-plaintext highlighter-rouge">Queue</code>提供的<code class="language-plaintext highlighter-rouge">add()</code>/<code class="language-plaintext highlighter-rouge">offer()</code>方法在<code class="language-plaintext highlighter-rouge">Deque</code>中也可以使用，但是，使用<code class="language-plaintext highlighter-rouge">Deque</code>，最好不要调用<code class="language-plaintext highlighter-rouge">offer()</code>，而是调用<code class="language-plaintext highlighter-rouge">offerLast()</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span> <span class="c1">// A</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"B"</span><span class="o">);</span> <span class="c1">// A &lt;- B</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="s">"C"</span><span class="o">);</span> <span class="c1">// C &lt;- A &lt;- B</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// C, 剩下A &lt;- B</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span> <span class="c1">// B, 剩下A</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// A</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// null</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>如果直接写<code class="language-plaintext highlighter-rouge">deque.offer()</code>，我们就需要思考，<code class="language-plaintext highlighter-rouge">offer()</code>实际上是<code class="language-plaintext highlighter-rouge">offerLast()</code>，我们明确地写上<code class="language-plaintext highlighter-rouge">offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p>

<p>因此，使用<code class="language-plaintext highlighter-rouge">Deque</code>，推荐总是明确调用<code class="language-plaintext highlighter-rouge">offerLast()</code>/<code class="language-plaintext highlighter-rouge">offerFirst()</code>或者<code class="language-plaintext highlighter-rouge">pollFirst()</code>/<code class="language-plaintext highlighter-rouge">pollLast()</code>方法。</p>

<p><code class="language-plaintext highlighter-rouge">Deque</code>是一个接口，它的实现类有<code class="language-plaintext highlighter-rouge">ArrayDeque</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>。</p>

<p>我们发现<code class="language-plaintext highlighter-rouge">LinkedList</code>真是一个全能选手，它即是<code class="language-plaintext highlighter-rouge">List</code>，又是<code class="language-plaintext highlighter-rouge">Queue</code>，还是<code class="language-plaintext highlighter-rouge">Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不推荐的写法:</span>
<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">d1</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span>
<span class="c1">// 推荐的写法：</span>
<span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">d2</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span>
</code></pre></div></div>
<p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>
<h1 id="stack">Stack</h1>
<p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>

<p><code class="language-plaintext highlighter-rouge">Queue</code>的特点FIFO：所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进<code class="language-plaintext highlighter-rouge">Stack</code>的元素一定最早出<code class="language-plaintext highlighter-rouge">Stack</code>的。因此，<code class="language-plaintext highlighter-rouge">Stack</code>是这样一种数据结构：只能不断地往<code class="language-plaintext highlighter-rouge">Stack</code>中压入（push）元素，最后进去的必须最早弹出（pop）来。</p>

<p>在Java中，我们用<code class="language-plaintext highlighter-rouge">Deque</code>可以实现<code class="language-plaintext highlighter-rouge">Stack</code>的功能：</p>

<ul>
  <li>把元素压栈：<code class="language-plaintext highlighter-rouge">push(E)</code>/<code class="language-plaintext highlighter-rouge">addFirst(E)</code>；</li>
  <li>把栈顶的元素“弹出”：<code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">removeFirst()</code>；</li>
  <li>取栈顶元素但不弹出：<code class="language-plaintext highlighter-rouge">peek()</code>/<code class="language-plaintext highlighter-rouge">peekFirst()</code>。</li>
</ul>

<p>为什么Java的集合类没有单独的<code class="language-plaintext highlighter-rouge">Stack</code>接口呢？因为有个遗留类名字就叫<code class="language-plaintext highlighter-rouge">Stack</code>，出于兼容性考虑，所以没办法创建<code class="language-plaintext highlighter-rouge">Stack</code>接口，只能用<code class="language-plaintext highlighter-rouge">Deque</code>接口来“模拟”一个<code class="language-plaintext highlighter-rouge">Stack</code>了。</p>

<p>当我们把<code class="language-plaintext highlighter-rouge">Deque</code>作为<code class="language-plaintext highlighter-rouge">Stack</code>使用时，注意只调用<code class="language-plaintext highlighter-rouge">push()</code>/<code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">peek()</code>方法，不要调用<code class="language-plaintext highlighter-rouge">addFirst()</code>/<code class="language-plaintext highlighter-rouge">removeFirst()</code>/<code class="language-plaintext highlighter-rouge">peekFirst()</code>方法，这样代码更加清晰。</p>

<p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发<code class="language-plaintext highlighter-rouge">StackOverflowError</code>。</p>

<p>除基取余倒排列：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">toHex</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">s</span> <span class="o">={</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"4"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"7"</span><span class="o">,</span><span class="s">"8"</span><span class="o">,</span><span class="s">"9"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"C"</span><span class="o">,</span><span class="s">"D"</span><span class="o">,</span><span class="s">"E"</span><span class="o">,</span><span class="s">"F"</span><span class="o">};</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">n</span><span class="o">%</span><span class="mi">16</span><span class="o">]);</span>
        <span class="n">n</span><span class="o">/=</span><span class="mi">16</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="iterator">Iterator</h1>
<p>Java的集合类都可以使用<code class="language-plaintext highlighter-rouge">for each</code>循环，<code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Set</code>和<code class="language-plaintext highlighter-rouge">Queue</code>会迭代每个元素，<code class="language-plaintext highlighter-rouge">Map</code>会迭代每个key。以<code class="language-plaintext highlighter-rouge">List</code>为例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Orange"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>实际上，Java编译器并不知道如何遍历<code class="language-plaintext highlighter-rouge">List</code>。上述代码能够编译通过，只是因为编译器把<code class="language-plaintext highlighter-rouge">for each</code>循环通过<code class="language-plaintext highlighter-rouge">Iterator</code>改写为了普通的<code class="language-plaintext highlighter-rouge">for</code>循环：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
     <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这种通过<code class="language-plaintext highlighter-rouge">Iterator</code>对象遍历集合的模式称为迭代器。</p>

<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关心它们内部的存储结构。</p>

<p>例如，我们虽然知道<code class="language-plaintext highlighter-rouge">ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code class="language-plaintext highlighter-rouge">get(int)</code>方法。虽然我们可以用<code class="language-plaintext highlighter-rouge">for</code>循环遍历：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code class="language-plaintext highlighter-rouge">ArrayList</code>换成<code class="language-plaintext highlighter-rouge">LinkedList</code>，<code class="language-plaintext highlighter-rouge">get(int)</code>方法耗时会随着<code class="language-plaintext highlighter-rouge">index</code>的增加而增加。如果把<code class="language-plaintext highlighter-rouge">ArrayList</code>换成<code class="language-plaintext highlighter-rouge">Set</code>，上述代码就无法编译，因为<code class="language-plaintext highlighter-rouge">Set</code>内部没有索引。</p>

<p>用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历就没有上述问题，因为<code class="language-plaintext highlighter-rouge">Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的<code class="language-plaintext highlighter-rouge">for each</code>循环自动转换为<code class="language-plaintext highlighter-rouge">Iterator</code>遍历。</p>

<p>如果我们自己编写了一个集合类，想要使用<code class="language-plaintext highlighter-rouge">for each</code>循环，只需满足以下条件：</p>

<ul>
  <li>集合类实现<code class="language-plaintext highlighter-rouge">Iterable</code>接口，该接口要求返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象；</li>
  <li>用<code class="language-plaintext highlighter-rouge">Iterator</code>对象迭代集合内部数据。</li>
</ul>

<p>这里的关键在于，集合类通过调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法，返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p>

<p>一个简单的<code class="language-plaintext highlighter-rouge">Iterator</code>示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">rlist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReverseList</span><span class="o">&lt;&gt;();</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Pear"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">rlist</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="no">T</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">ReverseList</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">++);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>虽然实现类稍微比较复杂，但这是底层集合库，只需编写一次。而调用方则完全按<code class="language-plaintext highlighter-rouge">for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p>

<p>在编写<code class="language-plaintext highlighter-rouge">Iterator</code>的时候，通常可以用一个内部类来实现<code class="language-plaintext highlighter-rouge">Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类可以用<code class="language-plaintext highlighter-rouge">ReverseList.this</code>获得当前外部类的<code class="language-plaintext highlighter-rouge">this</code>引用，然后，通过这个<code class="language-plaintext highlighter-rouge">this</code>引用就可以访问<code class="language-plaintext highlighter-rouge">ReverseList</code>的所有字段和方法。</p>

<p><code class="language-plaintext highlighter-rouge">Iterator</code>是一种抽象的数据访问模型。使用<code class="language-plaintext highlighter-rouge">Iterator</code>模式进行迭代的好处有：</p>

<ul>
  <li>对任何集合都采用同一种访问模型；</li>
  <li>调用者对集合内部结构一无所知；</li>
  <li>集合类返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何迭代。</li>
</ul>

<p>Java提供了标准的迭代器模型，即集合类实现<code class="language-plaintext highlighter-rouge">java.util.Iterable</code>接口，返回<code class="language-plaintext highlighter-rouge">java.util.Iterator</code>实例。</p>
<h1 id="collections">Collections</h1>
<p><code class="language-plaintext highlighter-rouge">Collections</code>是JDK提供的工具类，同样位于<code class="language-plaintext highlighter-rouge">java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。 注意<strong>Collections</strong>结尾多了一个s，不是<strong>Collection</strong>！</p>

<p><code class="language-plaintext highlighter-rouge">addAll()</code>方法可以给一个<code class="language-plaintext highlighter-rouge">Collection</code>类型的集合添加若干元素。因为方法签名是<code class="language-plaintext highlighter-rouge">Collection</code>，所以我们可以传入<code class="language-plaintext highlighter-rouge">List</code>，<code class="language-plaintext highlighter-rouge">Set</code>等各种集合类型。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="no">T</span><span class="o">...</span> <span class="n">elements</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">List&lt;T&gt; emptyList()</code></td>
      <td>创建空List，返回的空集合是<strong>不可变集合</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; emptyMap()</code></td>
      <td>创建空Map，返回的空集合是<strong>不可变集合</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Set&lt;T&gt; emptySet()</code></td>
      <td>创建空Set，返回的空集合是<strong>不可变集合</strong>。</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">List&lt;T&gt; singletonList(T o)</code></td>
      <td>创建一个元素的List，也是<strong>不可变集合</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; singletonMap(K key, V value)</code></td>
      <td>创建一个元素的Map，也是<strong>不可变集合</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Set&lt;T&gt; singleton(T o)</code></td>
      <td>创建一个元素的Set，也是<strong>不可变集合</strong></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">sort(list)</code></td>
      <td>对List排序</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">shuffle(list)</code></td>
      <td>对List洗牌，打乱顺序</td>
    </tr>
  </tbody>
</table>

<p>也可以用各个集合接口提供的<code class="language-plaintext highlighter-rouge">of(T...)</code>方法，它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合。</p>

<p><strong>不可变集合</strong></p>

<p><code class="language-plaintext highlighter-rouge">Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>
<ul>
  <li>封装成不可变List：<code class="language-plaintext highlighter-rouge">List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
  <li>封装成不可变Set：<code class="language-plaintext highlighter-rouge">Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
  <li>封装成不可变Map：<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>

<p>这种封装实际上是通过<strong>创建</strong>一个<strong>代理对象</strong>，<strong>拦截</strong>掉所有修改方法实现的。然而，继续对原始的可变<code class="language-plaintext highlighter-rouge">List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code class="language-plaintext highlighter-rouge">List</code>。因此，如果我们希望把一个可变<code class="language-plaintext highlighter-rouge">List</code>封装成不可变<code class="language-plaintext highlighter-rouge">List</code>，那么，返回不可变<code class="language-plaintext highlighter-rouge">List</code>后，最好立刻扔掉可变<code class="language-plaintext highlighter-rouge">List</code>的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code class="language-plaintext highlighter-rouge">List</code>变化了。</p>

<p><strong>线程安全集合</strong></p>

<p><code class="language-plaintext highlighter-rouge">Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>
<ul>
  <li>变为线程安全的List：<code class="language-plaintext highlighter-rouge">List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>
  <li>变为线程安全的Set：<code class="language-plaintext highlighter-rouge">Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>
  <li>变为线程安全的Map：<code class="language-plaintext highlighter-rouge">Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>
</ul>

<p>从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>

<h1 id="其他">其他</h1>

<h2 id="方法引用">方法引用</h2>

<p>展开<code class="language-plaintext highlighter-rouge">Integer[]::new</code>后：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div>

<p>在这里，<code class="language-plaintext highlighter-rouge">IntFunction&lt;Integer[]&gt;</code> 是一个函数式接口，它定义了一个<code class="language-plaintext highlighter-rouge">IntFunction&lt;Integer[]&gt;</code>的匿名实现，实现了<code class="language-plaintext highlighter-rouge">apply</code>方法来创建一个指定大小的<code class="language-plaintext highlighter-rouge">Integer</code>数组。然后，通过<code class="language-plaintext highlighter-rouge">toArray</code>方法将列表转换为该数组。</p>

<p>通过lambda 表达式简化后变成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div>

<p>这个 lambda 表达式接受一个整数参数 <code class="language-plaintext highlighter-rouge">size</code>，并返回一个新的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，长度为 <code class="language-plaintext highlighter-rouge">size</code>。</p>

<p>通过方法引用再次简化后变成：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Integer[]::new</code> 表示一个构造函数引用，它接受一个整数参数（数组的长度）并返回一个 <code class="language-plaintext highlighter-rouge">Integer</code> 数组。这样，<code class="language-plaintext highlighter-rouge">toArray(Integer[]::new)</code> 将生成一个与 <code class="language-plaintext highlighter-rouge">list</code> 大小相同的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，并将 <code class="language-plaintext highlighter-rouge">list</code> 中的元素复制到这个数组中。</p>

<p>详情参见：<a href="/2024/04/25/函数式编程/">函数式编程</a></p>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">泛型</title><link href="/2024/03/21/%E6%B3%9B%E5%9E%8B/" rel="alternate" type="text/html" title="泛型" /><published>2024-03-21T00:00:00+08:00</published><updated>2024-03-21T00:00:00+08:00</updated><id>/2024/03/21/%E6%B3%9B%E5%9E%8B</id><content type="html" xml:base="/2024/03/21/%E6%B3%9B%E5%9E%8B/"><![CDATA[<h1 id="引言">引言</h1>
<p>泛型类、泛型方法、擦拭法、<code class="language-plaintext highlighter-rouge">entends</code>通配符、<code class="language-plaintext highlighter-rouge">super</code>通配符、无限定通配符、<code class="language-plaintext highlighter-rouge">Void</code>。</p>

<h1 id="泛型">泛型</h1>

<p>泛型就是编写模板代码来适应任意类型；</p>

<p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p>

<p>泛型的继承关系<strong>可以</strong>把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！），但<strong>不能</strong>把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！<code class="language-plaintext highlighter-rouge">T</code>也不能变成父类）。</p>

<p>如果实例化时<strong>不定义泛型类型</strong>时，那么默认会使用<code class="language-plaintext highlighter-rouge">Object</code>作为泛型类型参数。如<code class="language-plaintext highlighter-rouge">MyClass myClass = new MyClass();</code>，那么<code class="language-plaintext highlighter-rouge">T</code>会被擦除为<code class="language-plaintext highlighter-rouge">Object</code>，相当于<code class="language-plaintext highlighter-rouge">MyClass&lt;Object&gt; myClass = new MyClass&lt;Object&gt;();</code>。</p>

<p>编译器如果能自动推断出泛型类型，可以省略后面的泛型类型。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
</code></pre></div></div>
<p>编译器看到泛型类型<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>就<strong>可以</strong>自动推断出后面的<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>的泛型类型<strong>必须</strong>是<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>除了<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code class="language-plaintext highlighter-rouge">Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>这个泛型接口。</p>
<h2 id="泛型类">泛型类</h2>
<p>泛型类写法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>定义泛型类时，在类名后面定义<code class="language-plaintext highlighter-rouge">泛型类型参数</code>。</p>

<p><strong>在泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</strong></p>

<p>初始化：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span><span class="c1">//或new Pair&lt;String&gt;("1","2");</span>
</code></pre></div></div>
<h2 id="泛型方法">泛型方法</h2>
<h3 id="泛型方法的定义">泛型方法的定义</h3>

<p>泛型方法写法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在Java中，泛型方法的定义通常如下所示：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">返回类型</span> <span class="n">方法名</span><span class="o">(</span><span class="n">参数列表</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 方法体</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：泛型类型参数声明，放在<strong>返回类型之前</strong>，表示该方法是一个泛型方法，并且可以接受类型为<code class="language-plaintext highlighter-rouge">T</code>的参数或返回类型为<code class="language-plaintext highlighter-rouge">T</code>的值。</li>
  <li>返回类型：方法的返回类型，可以是泛型类型<code class="language-plaintext highlighter-rouge">T</code>或其他类型。</li>
  <li>方法名：方法的名称。</li>
  <li>参数列表：方法的参数列表，可以包含泛型类型<code class="language-plaintext highlighter-rouge">T</code>。</li>
  <li>方法体：方法的具体实现。</li>
</ul>

<p>在泛型方法中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是用来声明泛型类型参数的。当调用泛型方法时，可以根据实际情况传入不同的类型参数。例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="nc">Integer</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它可以接受任意类型的参数并返回相同类型的值。在调用<code class="language-plaintext highlighter-rouge">myMethod</code>时，根据传入的参数类型确定返回类型，从而实现了泛型方法的灵活性。</p>

<p>在泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p>

<p><strong>而在方法中定义的泛型类型参数只适用于该方法</strong>。</p>

<h3 id="同时定义泛型类与泛型方法">同时定义泛型类与泛型方法</h3>
<p>如果在类名后面定义了泛型类型参数，在类的方法中仍然<strong>可以</strong>使用独立的泛型类型参数。这两者是独立的，例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在这个例子中，<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>是一个泛型类，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>表示类的泛型类型参数。<code class="language-plaintext highlighter-rouge">printValue</code>是泛型方法，<code class="language-plaintext highlighter-rouge">printValue</code>中的<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code>是方法级别的泛型类型参数，泛型方法的<code class="language-plaintext highlighter-rouge">K</code>与类的<code class="language-plaintext highlighter-rouge">T</code>是相互独立的。</p>

<p><strong>在泛型方法中可以使用泛型类的标识符</strong>。泛型类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>中的泛型方法也可以使用类的泛型标识符<code class="language-plaintext highlighter-rouge">T</code>以下是一个示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">U</span> <span class="n">u</span><span class="o">,</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyClass value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">u</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Main</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="n">myClass</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">,</span><span class="s">"haha"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>
<p>在这个例子中，<code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它使用了泛型方法类型参数<code class="language-plaintext highlighter-rouge">U</code>，这个类型参数与泛型类<code class="language-plaintext highlighter-rouge">MyClass</code>中的类型参数<code class="language-plaintext highlighter-rouge">T</code>是不同的，它也使用了泛型类方法类型参数<code class="language-plaintext highlighter-rouge">T</code>。在<code class="language-plaintext highlighter-rouge">myMethod&lt;Integer&gt;(123, "haha")</code>这个调用中，类型参数<code class="language-plaintext highlighter-rouge">U</code>被指定为<code class="language-plaintext highlighter-rouge">Integer</code>，类型参数<code class="language-plaintext highlighter-rouge">T</code>在类实例化时被推断为<code class="language-plaintext highlighter-rouge">String</code>。因此，<code class="language-plaintext highlighter-rouge">myMethod</code>方法的第一个参数<code class="language-plaintext highlighter-rouge">u</code>是<code class="language-plaintext highlighter-rouge">Integer</code>类型，第二个参数<code class="language-plaintext highlighter-rouge">t</code>是<code class="language-plaintext highlighter-rouge">String</code>类型。</p>

<h3 id="泛型类与泛型方法使用相同的泛型类型参数名">泛型类与泛型方法使用相同的泛型类型参数名</h3>

<p>如果在类名后面定义了泛型类型参数，并且在方法中使用了<strong>相同的泛型类型参数名</strong>，这并不会产生冲突，因为它们在不同的作用域中。类的泛型类型参数适用于整个类，而方法的泛型类型参数只适用于该方法。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">T</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在这个例子中，类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示类的类型参数。泛型方法<code class="language-plaintext highlighter-rouge">printValue</code>中也有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示方法级别的类型参数。这两个<code class="language-plaintext highlighter-rouge">T</code>是不同的，在方法中使用的<code class="language-plaintext highlighter-rouge">T</code>只在方法范围内有效，不会与类的泛型类型参数产生冲突。</p>

<p>但这样写会在泛型方法中隐藏类的同名泛型类型参数，在泛型方法中就<strong>用不了</strong>类的同名泛型类型参数了，因为它已经被方法中定义的泛型类型参数隐藏了，而并不存在一个<code class="language-plaintext highlighter-rouge">this.</code>来调用泛型类的泛型类型参数。</p>

<p>因此<strong>不建议这么做</strong>，因为这样也很容易让人误解。<strong>更不建议将</strong><code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">Stirng</code>之类的，别人看了会打人，而且同样会隐藏<code class="language-plaintext highlighter-rouge">Stirng</code>，从而导致你要通过<code class="language-plaintext highlighter-rouge">java.lang.String</code>使用<code class="language-plaintext highlighter-rouge">String</code>。</p>

<h3 id="静态泛型方法">静态泛型方法</h3>

<p>编写泛型类时，要特别注意，<strong>泛型类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。</strong></p>

<p>因为泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p>

<p>在静态方法中，同样可以变成泛型方法，使用泛型类型参数，就是之前泛型方法的写法加个<code class="language-plaintext highlighter-rouge">static</code>，语法一模一样。</p>

<p>例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myStaticMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Static method: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">myStaticMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在这个例子中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是在静态泛型方法<code class="language-plaintext highlighter-rouge">myStaticMethod</code>的返回类型<code class="language-plaintext highlighter-rouge">void</code>之前声明的，用于定义该方法的泛型类型参数。在调用静态方法时，需要使用<strong><code class="language-plaintext highlighter-rouge">MyClass.&lt;String&gt;</code></strong>来指定类型参数。</p>
<ul>
  <li>泛型类的泛型类型参数是在实例化对象时确定的，而静态方法是在类加载时就可以直接调用的，无需创建对象实例。所以静态方法中的返回值、参数等不能使用泛型类的泛型类型参数。因此静态方法如果需要使用泛型，必须定义自己的泛型类型参数。</li>
  <li><strong>必须</strong>将静态方法的泛型类型参数和泛型类的泛型类型参数<strong>区分开</strong>。<strong>其实相同也没关系</strong>，就是容易让人误解，也不存在覆盖泛型类类型参数的问题，因为本来静态方法就不能用类的非静态的东西，但在静态泛型方法内还是存在同名隐藏问题，比如之前说的将<code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">String</code>。</li>
</ul>

<h2 id="多个泛型类型">多个泛型类型</h2>

<p>泛型还可以定义多种类型。例如，我们希望<code class="language-plaintext highlighter-rouge">Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">K</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">K</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用的时候，需要指出两种类型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"test"</span><span class="o">,</span> <span class="mi">123</span><span class="o">);</span>
</code></pre></div></div>
<p>Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对<code class="language-plaintext highlighter-rouge">Key</code>使用一种类型，对<code class="language-plaintext highlighter-rouge">Value</code>使用另一种类型。</p>

<h2 id="擦拭法">擦拭法</h2>

<p>所谓擦拭法是指，<strong>虚拟机</strong>对泛型其实一无所知，所有的工作都是<strong>编译器</strong>做的。因此<strong>编译器</strong>把类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>视为<code class="language-plaintext highlighter-rouge">Object</code>；<strong>编译器</strong>根据<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>实现<strong>安全的强制转型</strong>。</p>

<p>例如，我们编写了一个泛型类<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>，这是<strong>编译器</strong>看到的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>而<strong>虚拟机</strong>根本不知道泛型。这是虚拟机执行的代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Object</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用泛型的时候，我们编写的代码也是如此，<strong>编译器</strong>看到的代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div>
<p>而<strong>虚拟机</strong>执行的代码并没有泛型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div>
<p>Java的泛型是由<strong>编译器</strong>在<strong>编译时</strong>实行的，<strong>编译器</strong>内部<strong>永远</strong>把所有类型<code class="language-plaintext highlighter-rouge">T</code>视为<code class="language-plaintext highlighter-rouge">Object</code>处理，但是，在需要<strong>转型</strong>的时候，<strong>编译器</strong>会根据<code class="language-plaintext highlighter-rouge">T</code>的类型<strong>自动</strong>为我们实行安全地强制转型。</p>

<p><strong>局限一</strong>：<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能是基本类型，例如<code class="language-plaintext highlighter-rouge">int</code>，因为实际类型是<code class="language-plaintext highlighter-rouge">Object</code>，<code class="language-plaintext highlighter-rouge">Object</code>类型无法持有基本类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="c1">// compile error!</span>
</code></pre></div></div>
<p><strong>局限二</strong>：无法取得带泛型的<code class="language-plaintext highlighter-rouge">Class</code>。观察以下代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Class</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>因为<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Object</code>，我们对<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;</code>和<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型获取<code class="language-plaintext highlighter-rouge">Class</code>时，获取到的是同一个<code class="language-plaintext highlighter-rouge">Class</code>，也就是<code class="language-plaintext highlighter-rouge">Pair</code>类的<code class="language-plaintext highlighter-rouge">Class</code>。</p>

<p>换句话说，所有泛型实例，<strong>无论</strong><code class="language-plaintext highlighter-rouge">T</code>的类型是什么，<code class="language-plaintext highlighter-rouge">getClass()</code>都返回<strong>同一个</strong><code class="language-plaintext highlighter-rouge">Class</code>实例，因为编译后它们全部都是<code class="language-plaintext highlighter-rouge">Pair</code>类，使用<code class="language-plaintext highlighter-rouge">Object</code>替换<code class="language-plaintext highlighter-rouge">T</code>。</p>

<p><strong>局限三</strong>：无法判断带泛型的类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
<span class="c1">// Compile error：</span>
<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="o">{}</span>
</code></pre></div></div>
<p>原因和前面一样，并不存在<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>，而是只有唯一的<code class="language-plaintext highlighter-rouge">Pair.class</code>。</p>

<p><strong>局限四</strong>：不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Compile error：</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>上述代码无法通过编译，因为构造方法的两行语句：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
</code></pre></div></div>
<p><strong>擦拭后</strong>实际上变成了：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div>
<p>这样一来，创建<code class="language-plaintext highlighter-rouge">new Pair&lt;String&gt;()</code>和创建<code class="language-plaintext highlighter-rouge">new Pair&lt;Integer&gt;()</code>，内部的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>全部成了<code class="language-plaintext highlighter-rouge">Object</code>类型，显然编译器要阻止这种类型不对的代码，为了<strong>防止</strong>可能的错误出现<strong>编译器</strong>直接<strong>一刀切</strong>这个操作。</p>

<p>而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了一个抽象类：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>
<p>上面的<code class="language-plaintext highlighter-rouge">Number</code>是不能直接实例化的，所以编译器要阻止这种行为。</p>

<p>顺便提一下，如果改成了利用反射实例化：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>借助<code class="language-plaintext highlighter-rouge">class.newInstance()</code>创建实例时编译器要求强制处理可能出现的异常，相当于做了兼容。直接<code class="language-plaintext highlighter-rouge">new</code>的话如果泛型类型为抽象类，则会出错。</p>

<p>上述代码借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>参数并通过反射来实例化<code class="language-plaintext highlighter-rouge">T</code>类型，使用的时候，也必须传入<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>。例如：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="不恰当的覆写方法">不恰当的覆写方法</h3>
<p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在 Java 中，泛型类型在编译时会被擦除，<strong>编译器</strong>会把泛型类型的信息擦除掉，将其替换为其上限类型（如果有指定上限类型的话），或者替换为 <code class="language-plaintext highlighter-rouge">Object</code> 类型。这是为了与 Java 的运行时类型擦除机制相适配</p>

<p>定义的<code class="language-plaintext highlighter-rouge">equals(T t)</code>方法实际上会被擦拭成<code class="language-plaintext highlighter-rouge">equals(Object t)</code>，而这个方法是继承自<code class="language-plaintext highlighter-rouge">Object</code>的，而<strong>编译器</strong>会阻止一个实际上会变成覆写的泛型方法定义。</p>

<p>因为仅仅通过泛型代码的定义，<strong>编译器</strong>是<strong>无法确定</strong>泛型<strong>是否覆写</strong>了此方法。</p>

<p>在泛型类型擦除后，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code>与 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法的签名相同。因此，从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法。</p>

<p>但是，由于 Java 泛型的设计，<strong>编译器</strong>会在编译时对泛型类型进行额外的类型检查，以确保类型安全。在这种情况下，<strong>编译器</strong>会注意到 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法<strong>使用了泛型类型</strong> <code class="language-plaintext highlighter-rouge">T</code>，而 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法使用了原始的 <code class="language-plaintext highlighter-rouge">Object</code> 类型，在编译时这会被认为是<strong>不同</strong>的方法。<br />
因此，编译器会认为 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法<strong>不是重写</strong>，而是一个<strong>新定义的方法</strong>。</p>

<p>这也是为了确保子类重写父类方法时不会改变方法的行为，避免在子类中意外修改了父类的行为。</p>

<p>综上所述，虽然从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法，但在编译器的类型检查中，它们会被认为是<strong>不同</strong>的方法，因为泛型类型 <code class="language-plaintext highlighter-rouge">T</code> 在编译时会被认为是不同的参数类型。</p>

<hr />

<p>虽然擦除后不是覆写，但编译器装作有泛型的行为，导致在调用<code class="language-plaintext highlighter-rouge">test()</code>时编译器不知道调用哪个<code class="language-plaintext highlighter-rouge">test()</code>，非预期效果，编译器报错：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Test</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">t1</span><span class="o">=</span><span class="k">new</span> <span class="nc">Test</span><span class="o">&lt;&gt;();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"test"</span><span class="o">)){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="c1">//        t1.test((Number)124);//错误:java: 对test的引用不明确com.aotmd.SuperTest 中的方法 test(java.lang.Number) 和 com.aotmd.Test 中的方法 test(T) 都匹配</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SuperTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">test</span><span class="o">((</span><span class="nc">Number</span><span class="o">)</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SuperTest</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">Number</span> <span class="n">o</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>结果：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class com.aotmd.Test
public void com.aotmd.Test.test(java.lang.Object)
public void com.aotmd.SuperTest.test(java.lang.Number)
</code></pre></div></div>

<h3 id="泛型继承">泛型继承</h3>
<p>一个类可以继承自一个泛型类。例如：父类是<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>，子类是<code class="language-plaintext highlighter-rouge">IntPair</code>，可以这么继承：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>
<p>使用的时候，因为子类<code class="language-plaintext highlighter-rouge">IntPair</code>并没有泛型，所以正常使用即可：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntPair</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntPair</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div>
<p>前面讲了，我们无法获取<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的<code class="language-plaintext highlighter-rouge">T</code>类型，即给定一个变量<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt; p</code>，也无法从<code class="language-plaintext highlighter-rouge">p</code>中获取到<code class="language-plaintext highlighter-rouge">Integer</code>类型。</p>

<p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code class="language-plaintext highlighter-rouge">T</code>（对<code class="language-plaintext highlighter-rouge">IntPair</code>来说，也就是<code class="language-plaintext highlighter-rouge">Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code class="language-plaintext highlighter-rouge">IntPair</code>只能存取<code class="language-plaintext highlighter-rouge">Integer</code>这种类型。</p>

<p>在继承了泛型类型的情况下，子类<strong>可以</strong>获取父类的泛型类型。例如：<code class="language-plaintext highlighter-rouge">IntPair</code>可以获取到父类的泛型类型<code class="language-plaintext highlighter-rouge">Integer</code>。获取父类的泛型类型代码比较复杂：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.ParameterizedType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">IntPair</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">IntPair</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="nc">Type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getGenericSuperclass</span><span class="o">();</span><span class="c1">//获取泛型父类的class</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="nc">ParameterizedType</span><span class="o">)</span> <span class="o">{</span><span class="c1">//判断是否为ParameterizedType，如果是，则表示泛型父类有实际类型参数。</span>
            <span class="nc">ParameterizedType</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ParameterizedType</span><span class="o">)</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">Type</span><span class="o">[]</span> <span class="n">types</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">();</span> <span class="c1">// 获取实际类型参数的数组，本例中数组长度为1。</span>
            <span class="nc">Type</span> <span class="n">firstType</span> <span class="o">=</span> <span class="n">types</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 获取第一个实际类型参数</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">firstType</span><span class="o">);</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">typeClass</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">firstType</span><span class="o">;</span><span class="c1">//将其转换为 Class 对象，若还是泛型K则转换失败。</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">typeClass</span><span class="o">);</span> <span class="c1">// Integer</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>修改<code class="language-plaintext highlighter-rouge">IntPair</code>，然后重新运行，类型转换会出错:</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">IntPair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="no">K</span> <span class="n">o1</span><span class="o">,</span><span class="no">K</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span><span class="n">o2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>因为Java引入了泛型，所以，只用<code class="language-plaintext highlighter-rouge">Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p>
<pre><code class="language-ascii">                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
</code></pre>
<h3 id="小结">小结</h3>

<p>Java的泛型是采用擦拭法实现的；</p>

<p>擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p>

<ul>
  <li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li>
  <li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li>
  <li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li>
  <li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li>
</ul>

<p>泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>；</p>

<p>子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p>

<h2 id="extends通配符在形式参数的作用">extends通配符在形式参数的作用</h2>
<p>之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，他们之前没有什么关系。</p>

<p>假设我们定义了<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>然后对<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>上述代码是可以正常编译的。使用的时候，我们传入：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div>
<p>注意：传入的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，实际参数类型是<code class="language-plaintext highlighter-rouge">(Integer, Integer)</code>。</p>

<p>既然实际参数是<code class="language-plaintext highlighter-rouge">Integer</code>类型，试试传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div>
<p>直接运行，会得到一个编译错误：</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: Pair&lt;Integer&gt;无法转换为Pair&lt;Number&gt;
</code></pre></div></div>
<p>原因很明显，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，它们之间没什么关系，因此，<code class="language-plaintext highlighter-rouge">add(Pair&lt;Number&gt; p)</code>方法，不接受参数类型<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>。</p>

<p>方法里的代码逻辑是没有问题，<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">Integer</code>的父类。问题在于方法参数类型定死了只能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>。</p>

<hr />

<p>有没有办法使得方法参数接受<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>使得方法能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。我们把代码改写如下：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>这样一来，给方法传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型时，它符合参数<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型。这种使用<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code class="language-plaintext highlighter-rouge">T</code>的上界限定在<code class="language-plaintext highlighter-rouge">Number</code>了。</p>

<p>这样写除了可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型，还可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型，<code class="language-plaintext highlighter-rouge">Pair&lt;BigDecimal&gt;</code>类型等等，因为<code class="language-plaintext highlighter-rouge">Double</code>和<code class="language-plaintext highlighter-rouge">BigDecimal</code>都是<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p>

<p>对<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型调用<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，实际的方法签名变成了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>即返回值是<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>的子类，因为 <code class="language-plaintext highlighter-rouge">Number</code> 是 <code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code> 的上界，所以返回值可以安全地赋值给 <code class="language-plaintext highlighter-rouge">Number</code> 类型的变量 <code class="language-plaintext highlighter-rouge">first</code>(向上提升)：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>不能赋值给<code class="language-plaintext highlighter-rouge">Integer</code>，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物，也即可能的向下转型是不安全的：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span><span class="c1">//错误</span>
</code></pre></div></div>
<p>这是因为实际的返回类型可能是<code class="language-plaintext highlighter-rouge">Integer</code>，也可能是<code class="language-plaintext highlighter-rouge">Double</code>或者其他类型，编译器只能确定类型一定是<code class="language-plaintext highlighter-rouge">Number</code>的子类（包括<code class="language-plaintext highlighter-rouge">Number</code>类型本身），但具体类型无法确定。</p>

<hr />

<p>尝试写操作：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: java.lang.Integer无法转换为capture#1, 共 ? extends java.lang.Number
</code></pre></div></div>
<p>编译错误发生在<code class="language-plaintext highlighter-rouge">p.setFirst()</code>，我们对<code class="language-plaintext highlighter-rouge">add(Pair&lt;? extends Number&gt; p)</code>传入了<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，对于<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>为什么不能传入<code class="language-plaintext highlighter-rouge">Integer</code>呢？</p>

<p>因为我们还能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，而传入<code class="language-plaintext highlighter-rouge">setFirst</code>的代码类型并不会变成<code class="language-plaintext highlighter-rouge">Double</code>类型，代码是固定的，形式参数类型为<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>当然是无法接受<code class="language-plaintext highlighter-rouge">Integer</code>类型的。</p>

<p>为了避免产生安全问题，编译器一刀切，直接<strong>不接受任何写行为</strong>。</p>

<p>唯一的例外是可以给方法参数传入<code class="language-plaintext highlighter-rouge">null</code>，因为泛型只接受引用类型，也即对象，因为擦除法都擦成<code class="language-plaintext highlighter-rouge">Object</code>了，而所有的对象都可以赋值<code class="language-plaintext highlighter-rouge">null</code>，所以这是安全的行为。</p>

<p>总的来说，调用：<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读，则需要用上界接收。写则因为可能向下转型的原因被切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。</p>

<h3 id="extends通配符形式参数实例">extends通配符形式参数实例</h3>

<p>Java标准库的<code class="language-plaintext highlighter-rouge">java.util.List&lt;T&gt;</code>接口实现的是一个类似“可变数组”的列表，主要功能包括：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span> <span class="c1">// 获取个数</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span> <span class="c1">// 根据索引获取指定元素</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 添加一个新元素</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 删除一个已有元素</span>
<span class="o">}</span>
</code></pre></div></div>
<p>定义一个方法来处理列表的每个元素：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sumOfList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用<code class="language-plaintext highlighter-rouge">? extends Integer</code>限制了只读，只能调用<code class="language-plaintext highlighter-rouge">size()</code>，<code class="language-plaintext highlighter-rouge">get()</code>，不能调用<code class="language-plaintext highlighter-rouge">add()</code>，<code class="language-plaintext highlighter-rouge">remove()</code>。</p>

<h3 id="使用extends在类限定t类型">使用extends在类限定T类型</h3>
<p>在定义<strong>泛型类型</strong><code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的时候，也可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div>
<p>现在，我们只能定义：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">p3</span><span class="o">;</span>
</code></pre></div></div>
<p>因为<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">Integer</code>和<code class="language-plaintext highlighter-rouge">Double</code>都符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>。<br />
非<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类类型将无法通过编译：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span> <span class="c1">// compile error!</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span> <span class="c1">// compile error!</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Object</code>都不符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>，它们不是<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p>

<h3 id="小结-1">小结</h3>
<p>  <font color="red"><b>使用类似`&lt;? extends Number&gt;`通配符参与方法的形式参数时表示：</b></font></p>

<ul>
  <li><strong>调用：<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读，则必须至少用上界<code class="language-plaintext highlighter-rouge">Number</code>接收，也可以用<code class="language-plaintext highlighter-rouge">Number</code>的父类接收，比如<code class="language-plaintext highlighter-rouge">Object</code>，避免可能的向下转型。</strong></li>
  <li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? extends Number&gt; o)</code>写则，因为可能向下转型的原因被一刀切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。(如果有下界倒是可以赋值下界或下界的子类，避免向下转型了)</strong></li>
  <li><strong>方法被修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的泛型类型。</strong></li>
</ul>

<p>  <font color="red"><b>`&lt;? extends 上界&gt;`：传参类型&lt;=上界，只能写`null`，读&gt;=上界。</b></font></p>

<p>其实<strong>不在方法参数</strong>也能用<code class="language-plaintext highlighter-rouge">&lt;? extends 上界&gt;</code>，效果是相同的。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>使用类似<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示：</p>
<ul>
  <li><strong>泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</strong></li>
</ul>

<h2 id="super通配符在形式参数的作用">super通配符在形式参数的作用</h2>
<p>之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，他们之前没有什么关系。<br />
考察下面的<code class="language-plaintext highlighter-rouge">set</code>方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是允许的，而传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>是不允许的。</p>

<p>和<code class="language-plaintext highlighter-rouge">extends</code>通配符相反，这次，我们希望接受泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。还是向上提升的问题，父类可以指向子类，所以写操作是安全的。同样的，向下转型不安全，因此禁止读取。</p>

<p>使用<code class="language-plaintext highlighter-rouge">super</code>通配符来改写这个方法：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。</p>

<p>下面的代码可以被正常编译：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mf">12.3</span><span class="o">,</span> <span class="mf">4.56</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p2</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setSame</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>方法签名实际上是：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">);</span>
</code></pre></div></div>
<p>因此，可以安全地传入<code class="language-plaintext highlighter-rouge">Integer</code>类型。如果你传<code class="language-plaintext highlighter-rouge">Number</code>类型，不好意思，因为泛型有可能是<code class="language-plaintext highlighter-rouge">Integer</code>所以不可以，即：有可能造成<code class="language-plaintext highlighter-rouge">Number</code>转<code class="language-plaintext highlighter-rouge">Integer</code>了，即向下转型。所以你想写入，则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入，也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能的向下转型。</p>

<p>而<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，它的方法签名实际上是：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span> <span class="kd">super</span> <span class="nc">Integer</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>无法使用<code class="language-plaintext highlighter-rouge">Integer</code>类型来接收<code class="language-plaintext highlighter-rouge">getFirst()</code>的返回值，还是老样子，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物，也即可能的向下转型是不安全的：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>
<p>因为如果传入的实际类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，在上面的代码中编译器无法将<code class="language-plaintext highlighter-rouge">Number</code>类型转型为<code class="language-plaintext highlighter-rouge">Integer</code>，即向下转型。</p>

<p>唯一可以接收<code class="language-plaintext highlighter-rouge">getFirst()</code>方法返回值的是<code class="language-plaintext highlighter-rouge">Object</code>类型，因为它是所有类的父类，它能包容一切，除它自己外，所有对它的赋值都是向上提升，因此是安全的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>  <font color="red"><b>使用类似`&lt;? super Integer&gt;`通配符参与方法的形式参数时表示：</b></font></p>
<ul>
  <li><strong>调用：<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt; getFirst();</code>读，因为没有限定上界，那只能用<code class="language-plaintext highlighter-rouge">Object</code>接收，避免可能的向下转型。</strong></li>
  <li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? super Integer&gt; o)</code>写则，则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入，也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能向下转型。</strong></li>
  <li><strong>方法修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的泛型类型。</strong></li>
</ul>

<p>  <font color="red"><b>`&lt;? super 下界&gt;`：传参类型&gt;=下界，写&lt;=下界，读只能`Object`。</b></font></p>

<p>其实不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? super 下界&gt;</code>。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="对比extends和super通配符在形式参数的作用">对比extends和super通配符在形式参数的作用</h3>
<p>对比<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>，作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型的区别在于：</p>
<ul>
  <li>
    <font color="red"><b>`&lt;? extends T&gt;`：传参类型&lt;=`T`，只能写`null`，读&gt;=`T`。</b></font>
  </li>
  <li>
    <font color="red"><b>`&lt;? super T&gt;`：  传参类型&gt;=`T`，写&lt;=`T`，读只能`Object`。</b></font>
  </li>
</ul>

<p>一个是允许读不允许写，另一个是允许写不允许读。</p>

<p>Java标准库的<code class="language-plaintext highlighter-rouge">Collections</code>类定义的<code class="language-plaintext highlighter-rouge">copy()</code>方法：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="c1">// 把src的每个元素复制到dest中：</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>它的作用是把一个<code class="language-plaintext highlighter-rouge">List</code>的每个元素依次添加到另一个<code class="language-plaintext highlighter-rouge">List</code>中。它的第一个参数是<code class="language-plaintext highlighter-rouge">List&lt;? super T&gt;</code>，表示目标<code class="language-plaintext highlighter-rouge">List</code>，第二个参数<code class="language-plaintext highlighter-rouge">List&lt;? extends T&gt;</code>，表示要复制的<code class="language-plaintext highlighter-rouge">List</code>。我们可以简单地用<code class="language-plaintext highlighter-rouge">for</code>循环实现复制。在<code class="language-plaintext highlighter-rouge">for</code>循环中，对于类型<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">src</code>可以安全的读，而对于类型<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">dest</code>可以安全的写。</p>

<p>这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的定义就完美地展示了<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>的意图：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部不会读取<code class="language-plaintext highlighter-rouge">dest</code>，因为不能调用<code class="language-plaintext highlighter-rouge">dest.get()</code>来获取<code class="language-plaintext highlighter-rouge">T</code>的引用；</li>
  <li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部也不会修改<code class="language-plaintext highlighter-rouge">src</code>，因为不能调用<code class="language-plaintext highlighter-rouge">src.add(T)</code>。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok：</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">numList</span><span class="o">,</span> <span class="n">intList</span><span class="o">);</span>
</code></pre></div></div>
<p>这两个 <code class="language-plaintext highlighter-rouge">T</code> 是<strong>同一个类型</strong>。在方法签名中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> 定义了方法级别的泛型类型参数，表示 <code class="language-plaintext highlighter-rouge">copy</code> 方法是一个泛型方法，它接受一个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的参数。类型参数的推断是基于传入参数的类型来确定的，编译器会尝试推断出最具体的类型，然后将其用作所有相关类型参数的类型。如果无法推断出一个具体的类型，编译器将无法确定如何匹配类型参数，从而导致编译错误。</p>

<p>使用前面的结论：</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>：<code class="language-plaintext highlighter-rouge">Integer</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>，只能写<code class="language-plaintext highlighter-rouge">null</code>，读&gt;=<code class="language-plaintext highlighter-rouge">T</code>。</strong></li>
  <li><strong><code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>：  <code class="language-plaintext highlighter-rouge">Number</code>&gt;=<code class="language-plaintext highlighter-rouge">T</code>，写&lt;=<code class="language-plaintext highlighter-rouge">T</code>，读只能<code class="language-plaintext highlighter-rouge">Object</code>。</strong></li>
</ul>

<p>可以得出：<code class="language-plaintext highlighter-rouge">Integer</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>&lt;=<code class="language-plaintext highlighter-rouge">Number</code>。</p>

<p>在在这次调用中<code class="language-plaintext highlighter-rouge">T</code>的类型确定需要满足两个条件，即：</p>

<ul>
  <li>因为<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>，所以<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">T</code>或<code class="language-plaintext highlighter-rouge">T</code>的父类，也就是说<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Number</code>或其子类</li>
  <li>因为<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>，所以<code class="language-plaintext highlighter-rouge">Integer</code>是<code class="language-plaintext highlighter-rouge">T</code>或<code class="language-plaintext highlighter-rouge">T</code>的子类，也就是说<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Integer</code>或其父类</li>
</ul>

<p>因此，<code class="language-plaintext highlighter-rouge">T</code> 可以被推断为 <code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Integer</code>，从而实现了将 <code class="language-plaintext highlighter-rouge">Integer</code> 类型的列表复制到 <code class="language-plaintext highlighter-rouge">Number</code> 类型的列表的操作。这种根据实际类型推断泛型类型参数的过程称为类型推断。</p>

<p>这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的另一个好处是可以安全地把一个<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>添加到<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>，但是无法反过来添加：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">intList</span><span class="o">,</span> <span class="n">numList</span><span class="o">);</span>
</code></pre></div></div>
<p>因为不存在<code class="language-plaintext highlighter-rouge">Number</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>&lt;=<code class="language-plaintext highlighter-rouge">Integer</code>这样的类型。</p>

<p>而这些都是通过<code class="language-plaintext highlighter-rouge">super</code>和<code class="language-plaintext highlighter-rouge">extends</code>通配符，并由编译器强制检查来实现的。</p>

<h3 id="使用super在类限定t类型">使用super在类限定T类型</h3>

<p>前面说了可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div>
<p>将T限制为<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p>

<p>那么有没有<code class="language-plaintext highlighter-rouge">super</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型呢?我想到这样的代码：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">super</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div>
<p>将T限制为<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的父类。</p>

<p><strong>不，java中没有实现在类中对下界进行限定</strong>。</p>

<h3 id="无限定通配符">无限定通配符</h3>

<p>Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code class="language-plaintext highlighter-rouge">?</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sample</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>
<p>因为<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符既没有<code class="language-plaintext highlighter-rouge">extends</code>，也没有<code class="language-plaintext highlighter-rouge">super</code>，因此：</p>
<ul>
  <li>不允许调用<code class="language-plaintext highlighter-rouge">set(T)</code>方法并传入引用（<code class="language-plaintext highlighter-rouge">null</code>除外）；</li>
  <li>不允许调用<code class="language-plaintext highlighter-rouge">T get()</code>方法并获取<code class="language-plaintext highlighter-rouge">T</code>引用（只能获取<code class="language-plaintext highlighter-rouge">Object</code>引用）。</li>
</ul>

<p>也就是说：<font color="red"><b>`&lt;?&gt;`传参类型随便，只能写`null`(因为无上界)，读只能`Object`(因为无下界)。</b></font></p>

<p>换句话说，既不能读，也不能写，那只能做一些<code class="language-plaintext highlighter-rouge">null</code>判断：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符有一个独特的特点，就是：<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>是所有<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的超类(抢了OBject的工作)：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// 安全地向上转型</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>上述代码是可以正常编译运行的，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p>

<p><strong>实际上<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</strong></p>

<p>那么有没有一个等同于<code class="language-plaintext highlighter-rouge">&lt;? super 最下子类</code>&gt;答案是没有的，因为这个最下子类并不是一个具体的东西，如果有，那么他也可以匹配任何类型，只能写null和最下子类，只能用Object读。功能基本和<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>重复了</p>

<h3 id="void">Void</h3>
<p>在泛型中，<code class="language-plaintext highlighter-rouge">Void</code> 是一个表示“无”或“空”的特殊类型。它类似于 <code class="language-plaintext highlighter-rouge">void</code> 关键字，但 <code class="language-plaintext highlighter-rouge">void</code> 只能用于方法的返回类型，而 <code class="language-plaintext highlighter-rouge">Void</code> 可以在泛型中使用，表示一个没有具体值的占位符。
<code class="language-plaintext highlighter-rouge">Void</code> 类是 Java 中的一个特殊类，位于 <code class="language-plaintext highlighter-rouge">java.lang</code> 包中。它的定义非常简单，如下所示：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Void</span> <span class="o">{</span>
    <span class="c1">// private构造方法，防止实例化</span>
    <span class="kd">private</span> <span class="nf">Void</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>可以看到，<code class="language-plaintext highlighter-rouge">Void</code> 类是一个 <code class="language-plaintext highlighter-rouge">final</code> 类，它有一个私有的无参构造方法，这意味着无法实例化 <code class="language-plaintext highlighter-rouge">Void</code> 类。实际上，<code class="language-plaintext highlighter-rouge">Void</code> 类没有任何实质性的内容，它只是作为一个标记类存在，用于表示没有具体值的情况。</p>

<p>在泛型中，<code class="language-plaintext highlighter-rouge">Void</code> 类通常用作一个占位符，用于表示不返回任何值的情况。例如，<code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt;</code> 表示一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，该 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 表示一个异步操作的完成状态，但不提供任何实际的结果。</p>

<p>总的来说，<code class="language-plaintext highlighter-rouge">Void</code> 类在 Java 中起着表示“无”或“空”的作用，用于表示不需要具体值的情况。</p>

<h1 id="总结">总结</h1>

<h2 id="说明">说明</h2>

<p>泛型的继承关系<strong>可以</strong>把类向上转型，而泛型参数<strong>不能产生变化</strong>。</p>

<p>如果实例化时<strong>不定义泛型类型参数</strong>时，那么默认会使用<code class="language-plaintext highlighter-rouge">Object</code>作为泛型类型参数。</p>

<p>编译器如果能自动推断出泛型类型，可以省略定义后面的泛型类型。</p>

<h2 id="定义">定义</h2>

<p>定义泛型类时，在类名后面定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，定义泛型方法时，在<strong>返回类型前面</strong>定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p>

<p>泛型类定义的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><strong>只能用于整个类的实例</strong>，而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p>

<p>泛型方法定义的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><strong>只适用于该方法</strong>，在泛型类中的方法仍然可以设置为泛型方法，也可以使用泛型类的标识符。</p>

<p>如果泛型类是<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，泛型方法也是<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，这两个<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是不同的，在泛型方法中会隐藏泛型类的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。<strong>不建议这么做</strong>，因为这样也很容易让人误解。<strong>更不建议将</strong><code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">Stirng</code>之类的，别人看了会打人，而且同样会隐藏<code class="language-plaintext highlighter-rouge">Stirng</code>，从而导致你要通过<code class="language-plaintext highlighter-rouge">java.lang.String</code>使用<code class="language-plaintext highlighter-rouge">String</code>。</p>

<p>泛型类的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。静态方法同样可以变成泛型方法，使用同样的方法，在<strong>返回类型前面</strong>定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p>

<p>泛型还可以定义多种类型。如类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>，Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。</p>

<h2 id="擦拭法-1">擦拭法</h2>

<p>擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p>
<ul>
  <li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li>
  <li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li>
  <li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li>
  <li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li>
</ul>

<p>泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>。</p>

<p>一个类可以继承自一个泛型类，子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p>

<h2 id="extendssuper">extends、super、？</h2>

<p>作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>的区别在于：</p>
<ul>
  <li>
    <font color="red"><b>`&lt;? extends T&gt;`：传参类型&lt;=`T`，只能写`null`，读&gt;=`T`。</b></font>
  </li>
  <li>
    <font color="red"><b>`&lt;? super T&gt;`：  传参类型&gt;=`T`，写&lt;=`T`，读只能`Object`。</b></font>
  </li>
  <li>
    <font color="red"><b>`&lt;?&gt;`传参类型随便，只能写`null`(因为无上界)，读只能`Object`(因为无下界)。</b></font>
  </li>
</ul>

<p><code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</p>

<p>大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符。</p>

<p><strong>不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>。</strong></p>

<p>用<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示<strong>使用时泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</strong></p>

<p><code class="language-plaintext highlighter-rouge">Myclass&lt;Void&gt;</code>,表示泛型参数为空。</p>

<p>其实就是因为java<strong>向上提升安全，而向下转型不安全</strong>。</p>

<h1 id="泛型和反射">泛型和反射</h1>

<p>Java的部分反射API也是泛型。例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>就是泛型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile warning:</span>
<span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// no warning:</span>
<span class="nc">Class</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</code></pre></div></div>
<p>调用<code class="language-plaintext highlighter-rouge">Class</code>的<code class="language-plaintext highlighter-rouge">getSuperclass()</code>方法返回的<code class="language-plaintext highlighter-rouge">Class</code>类型是<code class="language-plaintext highlighter-rouge">Class&lt;? super T&gt;</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">sup</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
</code></pre></div></div>
<p>构造方法<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>也是泛型：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
</code></pre></div></div>
<h3 id="泛型数组">泛型数组</h3>
<p>我们可以声明带泛型的数组，但不能用<code class="language-plaintext highlighter-rouge">new</code>操作符创建带泛型的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ok</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// compile error!</span>
</code></pre></div></div>
<p>必须通过强制转型实现带泛型的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div>
<p>使用泛型数组要特别小心，因为数组实际上在运行期<strong>没有</strong>泛型，编译器可以强制检查变量<code class="language-plaintext highlighter-rouge">ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code class="language-plaintext highlighter-rouge">arr</code>，因为它<strong>不是</strong>泛型数组。因为这两个变量实际上指向<strong>同一个</strong>数组，所以，操作<code class="language-plaintext highlighter-rouge">arr</code>可能导致从<code class="language-plaintext highlighter-rouge">ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span><span class="c1">//指向了不是String的内容</span>
<span class="c1">// ClassCastException:</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span><span class="c1">//类型转换错误</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div>

<p>要安全地使用泛型数组，必须扔掉<code class="language-plaintext highlighter-rouge">arr</code>的引用：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div>
<p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code class="language-plaintext highlighter-rouge">ps</code>进行操作，这种操作就是安全的。</p>

<p>带泛型的数组实际上是编译器的类型擦除：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</code></pre></div></div>
<p>所以我们<strong>不能</strong>直接创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>，因为擦拭后代码变为<code class="language-plaintext highlighter-rouge">Object[]</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile error:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>显然编译器要阻止这种类型不对的代码，为了防止可能的错误出现编译器直接一刀切这个操作。</p>

<p>而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了抽象类：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[]</span> <span class="n">pair</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Abc</span><span class="o">().</span><span class="na">createArray</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>上面的<code class="language-plaintext highlighter-rouge">Number</code>是不能直接实例化的，所以编译器要阻止这种行为。</p>

<p><strong>必须</strong>借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>来创建泛型数组：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">().</span><span class="na">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">first</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>泛型方法写法，<code class="language-plaintext highlighter-rouge">&lt;Pair&gt;</code>可省略：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">().&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span><span class="n">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">K</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>静态泛型方法写法，<code class="language-plaintext highlighter-rouge">&lt;Pair&gt;</code>可省略：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="nc">Pair</span><span class="o">.&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span><span class="n">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">K</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数</h3>

<p>还可以利用<strong>可变参数</strong>创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayHelper</span> <span class="o">{</span>
    <span class="nd">@SafeVarargs</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div>
<p>在上面的例子中，我们看到，通过：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>似乎</strong>可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>直接调用<code class="language-plaintext highlighter-rouge">asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code class="language-plaintext highlighter-rouge">ClassCastException</code>，原因还是因为擦拭法，在<code class="language-plaintext highlighter-rouge">pickTwo()</code>方法内部，编译器无法检测<code class="language-plaintext highlighter-rouge">K[]</code>的正确类型，因此返回了<code class="language-plaintext highlighter-rouge">Object[]</code>。</p>

<p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code class="language-plaintext highlighter-rouge">@SafeVarargs</code>消除警告。</p>

<p>如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p>

<p>更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p>

<p>泛型是通过类型擦除来实现的，而可变参数<strong>只是</strong>一个传递数组变量的语法糖，本质上还是<strong>创建</strong>一个数组然后传入。</p>

<p>所以泛型可变参数实际上就是 <code class="language-plaintext highlighter-rouge">Object</code> 数组，这样代码就可以等价为：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span> <span class="n">asArray</span><span class="o">(</span><span class="n">ss</span><span class="o">);</span> <span class="c1">// asArray 返回的就是 ss 只不过声明为 Object[]，实际上还是 String[],子类赋值给父类,然后转回子类</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span> <span class="c1">// pickTwo 返回的是一个新创建的 Object[]，只不过里面的元素实际上是字符串</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">k1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k2</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">};</span><span class="c1">//语法糖</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">objs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * asArray 本质上没有做任何处理，只是把传入的数据返回了而已。
     */</span>
    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<hr />

<p>以下是用jad反编译的，jad反编译后的是被擦拭后的，而使用cfr、jdgui反编译都是接近于源码的便于阅读的。(<a href="http://java-decompiler.github.io/">jd-gui工具</a>，<a href="https://github.com/iloveeclipse/plugins">Bytecode Outline</a>插件，不但可以看字节码，还可以看如何生成字节码。）</p>

<p>反编译后的代码中出现的<code class="language-plaintext highlighter-rouge">transient</code>关键字，这是由于反编译工具对代码进行了简化和优化。transient关键字通常用于修饰成员变量，表示这些变量不会被序列化，与我们讨论的问题无关。</p>

<p>源代码：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">toS2</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">toS</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    
    <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="c1">// ClassCastException:</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">toS</span><span class="o">(</span><span class="no">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">toS2</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">toS2</span><span class="o">(</span><span class="no">T</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>反编译后：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">toS2</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">toS</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span><span class="n">asArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span>
        <span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span>
    <span class="o">});</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="nc">String</span> <span class="n">firstTwo</span><span class="o">[]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span><span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">k1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k2</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k3</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[]</span> <span class="o">{</span>
        <span class="n">k1</span><span class="o">,</span> <span class="n">k2</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">transient</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="nc">Object</span> <span class="n">objs</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">toS</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">toS2</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">toS2</span><span class="o">(</span><span class="nc">Object</span> <span class="n">objs</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>可变参数的方法，实际接收的是一个数组</strong>，所以调用可变参数的方法时，会把参数封装成一个数组。如果在泛型方法里，调用泛型可变参数的方法，那么入参会被擦拭成<code class="language-plaintext highlighter-rouge">Object</code>数组。</p>

<p>报错解释：<code class="language-plaintext highlighter-rouge">main</code>直接调用<code class="language-plaintext highlighter-rouge">asArray</code>时，编译器知道<code class="language-plaintext highlighter-rouge">asArray</code>的入参是<code class="language-plaintext highlighter-rouge">String</code>，但是在调用<code class="language-plaintext highlighter-rouge">pickTwo</code>中编译器不知道<code class="language-plaintext highlighter-rouge">K</code>的类型将会是什么，所以调用<code class="language-plaintext highlighter-rouge">asArray</code>时入参封装（擦拭）成了<code class="language-plaintext highlighter-rouge">Object[]</code>，main中得到返回值强转为<code class="language-plaintext highlighter-rouge">String[]</code>时，就会报错。而在<code class="language-plaintext highlighter-rouge">toS</code>、<code class="language-plaintext highlighter-rouge">toS2</code>中尽管也会被擦拭成<code class="language-plaintext highlighter-rouge">Object</code>，但只是用<code class="language-plaintext highlighter-rouge">Object</code>持有对象引用，对象类型并没有改变，所以在<code class="language-plaintext highlighter-rouge">main</code>中强转时不会报错。</p>

<p>可变参数改成反射则没有问题：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">K</span><span class="o">[]</span> <span class="n">ks</span><span class="o">=</span><span class="n">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">,</span><span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pickTwo:"</span><span class="o">+</span><span class="n">ks</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ks</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span><span class="no">T</span> <span class="n">t2</span><span class="o">,</span><span class="no">T</span> <span class="n">t3</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"asArray:"</span><span class="o">+</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="no">T</span><span class="o">[]</span> <span class="n">ts</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="mi">3</span><span class="o">);</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">t1</span><span class="o">;</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="n">t2</span><span class="o">;</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="n">t3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ts</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">反射、注解</title><link href="/2024/03/13/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/" rel="alternate" type="text/html" title="反射、注解" /><published>2024-03-13T00:00:00+08:00</published><updated>2024-03-13T00:00:00+08:00</updated><id>/2024/03/13/%E5%8F%8D%E5%B0%84%E3%80%81%E6%B3%A8%E8%A7%A3</id><content type="html" xml:base="/2024/03/13/%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3/"><![CDATA[<h1 id="引言">引言</h1>
<p>java反射和注解的笔记。</p>

<h1 id="反射">反射</h1>
<p>获取<strong>class</strong>的<strong>Class</strong>实例：</p>

<p>直接通过<strong>class</strong>的静态变量<strong>class</strong>获取：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
</code></pre></div></div>
<p>通过实例变量提供的<code class="language-plaintext highlighter-rouge">getClass()</code>方法获取：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</code></pre></div></div>
<p>通过静态方法<code class="language-plaintext highlighter-rouge">Class.forName()</code>获取：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"java.lang.String"</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="class实例基本信息">Class实例基本信息：</h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>String</td>
      <td>getName()</td>
      <td>返回类的完全限定名。</td>
    </tr>
    <tr>
      <td>String</td>
      <td>getSimpleName()</td>
      <td>返回类的简单名称，不包含包名部分。</td>
    </tr>
    <tr>
      <td>String</td>
      <td>getPackage().getName()</td>
      <td>返回类所在包的名称。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isInterface()</td>
      <td>判断是否为接口。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isEnum()</td>
      <td>判断是否为枚举类型。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isArray()</td>
      <td>判断是否为数组类型。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isPrimitive()</td>
      <td>判断是否为基本数据类型。</td>
    </tr>
    <tr>
      <td>Class</td>
      <td>getSuperclass()</td>
      <td>返回表示该类的父类的 Class 对象。</td>
    </tr>
    <tr>
      <td>int</td>
      <td>getModifiers()</td>
      <td>返回表示类或接口的 Java 语言修饰符的整数。例如，public、static 等修饰符。</td>
    </tr>
    <tr>
      <td>Class[]</td>
      <td>getInterfaces()</td>
      <td>返回一个包含表示<strong>该类</strong>实现的接口的 Class 对象的数组。(接口同理)</td>
    </tr>
    <tr>
      <td>ClassLoader</td>
      <td>getClassLoader()</td>
      <td>返回该类的类加载器。</td>
    </tr>
    <tr>
      <td>boolean</td>
      <td>isAssignableFrom(Class)</td>
      <td>判断当前 <code class="language-plaintext highlighter-rouge">Class</code> 对象所表示的类或接口与指定 <code class="language-plaintext highlighter-rouge">Class</code> 参数表示的类或接口是否相同，或是否是其超类或超接口。</td>
    </tr>
    <tr>
      <td>Class</td>
      <td>getGenericSuperclass()</td>
      <td>获取泛型父类的<code class="language-plaintext highlighter-rouge">class</code>。</td>
    </tr>
  </tbody>
</table>

<h2 id="访问字段的方法">访问字段的方法</h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Field</td>
      <td>getField(String name)</td>
      <td>根据字段名获取某个public的field（包括父类继承）。</td>
    </tr>
    <tr>
      <td>Field</td>
      <td>getDeclaredField(String name)</td>
      <td>根据字段名获取当前类的某个field（不包括父类继承）。</td>
    </tr>
    <tr>
      <td>Field[]</td>
      <td>getFields()</td>
      <td>获取所有public的field（包括父类继承）。</td>
    </tr>
    <tr>
      <td>Field[]</td>
      <td>getDeclaredFields()</td>
      <td>获取当前类的所有field（不包括父类继承）。</td>
    </tr>
  </tbody>
</table>

<p>一个<code class="language-plaintext highlighter-rouge">Field</code>对象包含了一个字段的所有信息：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getName()</code>：返回字段名称，例如，<code class="language-plaintext highlighter-rouge">"name"</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getType()</code>：返回字段类型，也是一个<code class="language-plaintext highlighter-rouge">Class</code>实例，例如，<code class="language-plaintext highlighter-rouge">String.class</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回字段的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li>
</ul>

<p><strong>Field的方法</strong></p>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>void</td>
      <td>set(Object o,Object v)</td>
      <td>设置指定对象o上此 Field 表示的字段的值为v。</td>
    </tr>
    <tr>
      <td>Object</td>
      <td>get(Object o)</td>
      <td>返回指定对象o上此 Field 表示的字段的值。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>setAccessible(boolean)</td>
      <td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有字段)</td>
    </tr>
  </tbody>
</table>

<p>通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">get(实例变量)</code>可以得到该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值。</p>

<p>通过使用<code class="language-plaintext highlighter-rouge">Field</code>对象的<code class="language-plaintext highlighter-rouge">set(实例变量,新值)</code>可以设置该<code class="language-plaintext highlighter-rouge">Fileld</code>对应的字段在指定实例变量的值。</p>

<p>默认是不允许访问<code class="language-plaintext highlighter-rouge">private</code>字段的，可以通过调用<code class="language-plaintext highlighter-rouge">Field</code>的<code class="language-plaintext highlighter-rouge">setAccessible(true)</code>实现访问。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Object</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Field</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"name"</span><span class="o">);</span>
        <span class="n">f</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span> <span class="c1">// "Xiao Ming"</span>
        <span class="n">f</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">p</span><span class="o">,</span><span class="s">"你好"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h2 id="访问方法的方法">访问方法的方法</h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Method</td>
      <td>getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
      <td>获取某个<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>。（包括父类继承）name：方法名,parameterTypes：形式参数的Class。</td>
    </tr>
    <tr>
      <td>Method</td>
      <td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
      <td>获取当前类的某个<code class="language-plaintext highlighter-rouge">Method</code>。（不包括父类继承）name：方法名,parameterTypes：形式参数的Class。</td>
    </tr>
    <tr>
      <td>Method[]</td>
      <td>getMethods()</td>
      <td>获取所有<code class="language-plaintext highlighter-rouge">public</code>的<code class="language-plaintext highlighter-rouge">Method</code>。（包括父类继承）</td>
    </tr>
    <tr>
      <td>Method[]</td>
      <td>getDeclaredMethods()</td>
      <td>获取当前类的所有<code class="language-plaintext highlighter-rouge">Method</code>。（不包括父类继承）</td>
    </tr>
  </tbody>
</table>

<p>一个<code class="language-plaintext highlighter-rouge">Method</code>对象包含一个方法的所有信息：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">getName()</code>：返回方法名称，例如：<code class="language-plaintext highlighter-rouge">"getScore"</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code class="language-plaintext highlighter-rouge">String.class</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code class="language-plaintext highlighter-rouge">{String.class, int.class}</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">getModifiers()</code>：返回方法的修饰符，它是一个<code class="language-plaintext highlighter-rouge">int</code>，不同的bit表示不同的含义。</li>
</ul>

<p><strong>Method的方法</strong></p>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>invoke(Object o,Object …arg)</td>
      <td>调用指定对象o上此 Method表示的方法，方法的形式参数为arg。若为静态方法，则o设置为null。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>setAccessible(boolean b)</td>
      <td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// String对象：</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Hello world"</span><span class="o">;</span>
<span class="c1">// 获取String substring(int)方法，参数为int：</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"substring"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 在s对象上调用该方法并获取结果：</span>
<span class="nc">String</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">m</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">6</span><span class="o">);</span>
<span class="c1">// 打印调用结果：</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="访问构造方法的方法">访问构造方法的方法</h2>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Object</td>
      <td>newInstance()</td>
      <td>只能调用公有的无参数构造方法。(已废弃，应写    getDeclaredConstructor().newInstance())。</td>
    </tr>
    <tr>
      <td>Constructor</td>
      <td>getConstructor(Class … arg)</td>
      <td>获取指定类的指定<strong>公有</strong>构造方法，arg为形式参数。</td>
    </tr>
    <tr>
      <td>Constructor</td>
      <td>getDeclaredConstructor(Class… arg)</td>
      <td>获取指定类的构造方法，arg为形式参数。</td>
    </tr>
    <tr>
      <td>Constructor[]</td>
      <td>getConstructors()</td>
      <td>返回该类的所有<strong>公有</strong>构造方法。</td>
    </tr>
    <tr>
      <td>Constructor[]</td>
      <td>getDeclaredConstructors()</td>
      <td>返回该类的所有构造方法。</td>
    </tr>
  </tbody>
</table>

<p><strong>Constructor 的方法</strong></p>

<table>
  <thead>
    <tr>
      <th>返回值</th>
      <th>方法名</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Object</td>
      <td>newInstance(Object …arg)</td>
      <td>调用构造方法，参数为arg。</td>
    </tr>
    <tr>
      <td>void</td>
      <td>setAccessible(boolean b)</td>
      <td>将此对象的 accessible 标志设置为指示的布尔值。(设置true强行访问非公有方法)</td>
    </tr>
  </tbody>
</table>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取String的Class实例：String s=new Stirng();</span>
<span class="nc">Class</span> <span class="n">cls</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="c1">// 调用构造方法：</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">cls</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="c1">// 获取构造方法Integer(int)：Integer n1=new Integer(123);</span>
<span class="nc">Constructor</span> <span class="n">cons1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 调用构造方法：</span>
<span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">cons1</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span>
</code></pre></div></div>
<h2 id="动态代理">动态代理</h2>
<p>有没有可能不编写实现类，直接在运行期创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例呢？</p>

<p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code class="language-plaintext highlighter-rouge">interface</code>的实例。</p>

<p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p>

<p>定义接口：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>编写实现类：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>创建实例，转型为接口并调用：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloWorld</span><span class="o">();</span>
<span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
</code></pre></div></div>
<p>这种方式就是我们通常编写代码的方式。</p>

<p>还有一种方式是动态代码，我们仍然先定义了接口<code class="language-plaintext highlighter-rouge">Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建了一个<code class="language-plaintext highlighter-rouge">Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>

<p>一个最简单的动态代理实现如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InvocationHandler</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="nc">Method</span> <span class="n">method</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Hello</span> <span class="n">hello</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Hello</span><span class="o">)</span> <span class="nc">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>
            <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="c1">// 传入ClassLoader</span>
            <span class="k">new</span> <span class="nc">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="nc">Hello</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span> <span class="c1">// 传入要实现的接口</span>
            <span class="n">handler</span><span class="o">);</span> <span class="c1">// 传入处理调用方法的InvocationHandler</span>
        <span class="n">hello</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>在运行期动态创建一个<code class="language-plaintext highlighter-rouge">interface</code>实例的方法如下：</p>
<ul>
  <li>定义一个<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例，它负责实现接口的方法调用；</li>
  <li>通过<code class="language-plaintext highlighter-rouge">Proxy.newProxyInstance()</code>创建<code class="language-plaintext highlighter-rouge">interface</code>实例，它需要3个参数：
    <ol>
      <li>使用的<code class="language-plaintext highlighter-rouge">ClassLoader</code>，通常就是接口类的<code class="language-plaintext highlighter-rouge">ClassLoader</code>；</li>
      <li>需要实现的接口数组，至少需要传入一个接口进去；</li>
      <li>用来处理接口方法调用的<code class="language-plaintext highlighter-rouge">InvocationHandler</code>实例。</li>
    </ol>
  </li>
  <li>将返回的<code class="language-plaintext highlighter-rouge">Object</code>强制转型为接口。</li>
</ul>

<p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span><span class="n">a1</span><span class="o">();}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">a1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">HelloDynamicProxy</span> <span class="n">helloDynamicProxy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HelloDynamicProxy</span><span class="o">((</span><span class="n">proxy</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">args1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"morning"</span><span class="o">))</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Good morning, "</span> <span class="o">+</span> <span class="n">args1</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">});</span>
        <span class="n">helloDynamicProxy</span><span class="o">.</span><span class="na">morning</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">HelloDynamicProxy</span> <span class="kd">implements</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">HelloDynamicProxy</span><span class="o">(</span><span class="nc">InvocationHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">handler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="n">handler</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span>
                <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"morning"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">),</span>
                <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">name</span><span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Hello</span> <span class="o">{</span><span class="kt">void</span> <span class="nf">morning</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span><span class="o">;}</span>
</code></pre></div></div>
<p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>
<h1 id="注解">注解</h1>
<p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>

<h2 id="定义注解">定义注解</h2>
<p>使用<code class="language-plaintext highlighter-rouge">@interface</code>语法来定义注解（<code class="language-plaintext highlighter-rouge">Annotation</code>），格式：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>定义一个注解，可以定义配置参数。配置参数可以是：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">所有基本类型</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">String</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">枚举类型</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">基本类型</code>、<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Class</code>以及<code class="language-plaintext highlighter-rouge">枚举</code>的<strong>数组</strong>。</li>
</ul>

<p>配置参数<strong>必须</strong>是<code class="language-plaintext highlighter-rouge">常量</code>，注解配置参数可以用<code class="language-plaintext highlighter-rouge">default</code>设定一个默认值。</p>

<p>大部分注解存在名为<code class="language-plaintext highlighter-rouge">value</code>的配参数，对此参数赋值，可以<strong>只写</strong><code class="language-plaintext highlighter-rouge">常量</code>，相当于省略了<code class="language-plaintext highlighter-rouge">value</code>参数。即从<code class="language-plaintext highlighter-rouge">@Check(value=99)</code>省略为<code class="language-plaintext highlighter-rouge">@check(99)</code>，最常用的参数<strong>应当</strong>命名为<code class="language-plaintext highlighter-rouge">value</code>。</p>

<p>注解的参数类似无参数方法。</p>

<h2 id="元注解">元注解</h2>
<p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<h4 id="target">@Target</h4>
<p>最常用的元注解是<code class="language-plaintext highlighter-rouge">@Target</code>。使用<code class="language-plaintext highlighter-rouge">@Target</code>可以定义<code class="language-plaintext highlighter-rouge">Annotation</code><strong>能够</strong>被应用于源码的哪些<strong>位置</strong>：</p>
<ul>
  <li>类或接口：<code class="language-plaintext highlighter-rouge">ElementType.TYPE</code>；</li>
  <li>字段：<code class="language-plaintext highlighter-rouge">ElementType.FIELD</code>；</li>
  <li>方法：<code class="language-plaintext highlighter-rouge">ElementType.METHOD</code>；</li>
  <li>构造方法：<code class="language-plaintext highlighter-rouge">ElementType.CONSTRUCTOR</code>；</li>
  <li>方法参数：<code class="language-plaintext highlighter-rouge">ElementType.PARAMETER</code>。</li>
</ul>

<p>例如，定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在方法上，我们必须添加一个<code class="language-plaintext highlighter-rouge">@Target(ElementType.METHOD)</code>：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{}</span>
</code></pre></div></div>
<p>定义注解<code class="language-plaintext highlighter-rouge">@Report</code>可用在<strong>方法或字段上</strong>，可以把<code class="language-plaintext highlighter-rouge">@Target</code>注解参数变为<strong>数组</strong><code class="language-plaintext highlighter-rouge">{ ElementType.METHOD, ElementType.FIELD }</code>：</p>

<p>实际上<code class="language-plaintext highlighter-rouge">@Target</code>定义的<code class="language-plaintext highlighter-rouge">value</code>是<code class="language-plaintext highlighter-rouge">ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>

<h4 id="retention">@Retention</h4>

<p>Java的注解可以分为三类：</p>

<p>第一类是由编译器使用的注解，例如：<code class="language-plaintext highlighter-rouge">@Override</code>：让编译器检查该方法是否正确地实现了覆写；<code class="language-plaintext highlighter-rouge">@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。这类注解不会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，它们在编译后就被编译器扔掉了。</p>

<p>第二类是由工具处理<code class="language-plaintext highlighter-rouge">.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code class="language-plaintext highlighter-rouge">.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>

<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code class="language-plaintext highlighter-rouge">@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>

<hr />

<p>元注解<code class="language-plaintext highlighter-rouge">@Retention</code>定义了<code class="language-plaintext highlighter-rouge">Annotation</code>的生命周期：</p>
<ul>
  <li>仅编译期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.SOURCE</code>；</li>
  <li>仅class文件：<code class="language-plaintext highlighter-rouge">RetentionPolicy.CLASS</code>；</li>
  <li>运行期：<code class="language-plaintext highlighter-rouge">RetentionPolicy.RUNTIME</code>。</li>
</ul>

<p>如果<code class="language-plaintext highlighter-rouge">@Retention</code>不存在，则该<code class="language-plaintext highlighter-rouge">Annotation</code>默认为<code class="language-plaintext highlighter-rouge">CLASS</code>。因为通常我们自定义的<code class="language-plaintext highlighter-rouge">Annotation</code>都是<code class="language-plaintext highlighter-rouge">RUNTIME</code>，所以，务必要加上<code class="language-plaintext highlighter-rouge">@Retention(RetentionPolicy.RUNTIME)</code>这个元注解。</p>

<h4 id="repeatable">@Repeatable</h4>
<p>使用<code class="language-plaintext highlighter-rouge">@Repeatable</code>这个元注解可以定义<code class="language-plaintext highlighter-rouge">Annotation</code>是否可重复。这个注解应用不是特别广泛。<code class="language-plaintext highlighter-rouge">@Reports</code>是一个容器注解，用来包裹多个<code class="language-plaintext highlighter-rouge">@Report</code>注解。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repeatable</span><span class="o">(</span><span class="nc">Reports</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Report</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">type</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">level</span><span class="o">()</span> <span class="k">default</span> <span class="s">"info"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">Reports</span> <span class="o">{</span>
    <span class="nc">Report</span><span class="o">[]</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p>经过<code class="language-plaintext highlighter-rouge">@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code class="language-plaintext highlighter-rouge">@Report</code>注解：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"debug"</span><span class="o">)</span>
<span class="nd">@Report</span><span class="o">(</span><span class="n">type</span><span class="o">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">level</span><span class="o">=</span><span class="s">"warning"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{}</span>
</code></pre></div></div>
<h4 id="inherited">@Inherited</h4>
<p>使用<code class="language-plaintext highlighter-rouge">@Inherited</code>定义子类是否可<strong>继承</strong>父类定义的<code class="language-plaintext highlighter-rouge">Annotation</code>。<code class="language-plaintext highlighter-rouge">@Inherited</code>仅针对<code class="language-plaintext highlighter-rouge">@Target(ElementType.TYPE)</code>类型的<code class="language-plaintext highlighter-rouge">annotation</code>有效，并且仅针对<code class="language-plaintext highlighter-rouge">class</code>的继承，对<code class="language-plaintext highlighter-rouge">interface</code>的继承无效。</p>
<h2 id="处理注解">处理注解</h2>
<p>Java的注解本身对代码逻辑没有任何影响。根据<code class="language-plaintext highlighter-rouge">@Retention</code>的配置：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解在编译期就被丢掉了；</li>
  <li><code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
  <li><code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解会被加载进JVM，并且在运行期<strong>可以</strong>被程序读取。</li>
</ul>

<p>如何使用注解完全由工具决定。<code class="language-plaintext highlighter-rouge">SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code class="language-plaintext highlighter-rouge">CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>

<p>因此，我们只讨论如何读取<code class="language-plaintext highlighter-rouge">RUNTIME</code>类型的注解。</p>

<hr />

<p>注解定义后也是一种<code class="language-plaintext highlighter-rouge">class</code>，所有的注解都继承自<code class="language-plaintext highlighter-rouge">java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>

<p>Java提供的使用反射API读取<code class="language-plaintext highlighter-rouge">Annotation</code>的方法包括：</p>

<p>判断某个注解是否<strong>存在</strong>于<code class="language-plaintext highlighter-rouge">Class</code>、<code class="language-plaintext highlighter-rouge">Field</code>、<code class="language-plaintext highlighter-rouge">Method</code>或<code class="language-plaintext highlighter-rouge">Constructor</code>：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Class.isAnnotationPresent(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Field.isAnnotationPresent(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Method.isAnnotationPresent(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Constructor.isAnnotationPresent(Class)</code></li>
</ul>

<p>例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 判断@Report是否存在于Person类：</span>
<span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>
<p>使用反射API<strong>读取</strong>Annotation：</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Class.getAnnotation(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Field.getAnnotation(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Method.getAnnotation(Class)</code></li>
  <li><code class="language-plaintext highlighter-rouge">Constructor.getAnnotation(Class)</code></li>
</ul>

<p>例如：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Person定义的@Report注解：</span>
<span class="nc">Report</span> <span class="n">report</span> <span class="o">=</span> <span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">Report</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">type</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">level</span> <span class="o">=</span> <span class="n">report</span><span class="o">.</span><span class="na">level</span><span class="o">();</span>
</code></pre></div></div>
<hr />

<p>读取方法、字段和构造方法的<code class="language-plaintext highlighter-rouge">Annotation</code>和Class类似。但要读取方法参数的<code class="language-plaintext highlighter-rouge">Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span><span class="o">=</span><span class="mi">5</span><span class="o">)</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nd">@NotNull</span> <span class="nc">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div>
<p>要读取方法参数的注解，先用反射获取<code class="language-plaintext highlighter-rouge">Method</code>实例，然后读取方法参数的所有注解：</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取Method实例：</span>
<span class="nc">Method</span> <span class="n">m</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// 获取所有参数的Annotation：</span>
<span class="nc">Annotation</span><span class="o">[][]</span> <span class="n">annos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">getParameterAnnotations</span><span class="o">();</span>
<span class="c1">// 第一个参数（索引为0）的所有Annotation：</span>
<span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annosOfName</span> <span class="o">=</span> <span class="n">annos</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">anno</span> <span class="o">:</span> <span class="n">annosOfName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">Range</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Range</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @Range注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%d"</span><span class="o">,</span> <span class="n">r</span><span class="o">.</span><span class="na">max</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">anno</span> <span class="k">instanceof</span> <span class="nc">NotNull</span><span class="o">)</span> <span class="o">{</span>
         <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">anno</span><span class="o">;</span> <span class="c1">// @NotNull注解</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已捕获NotNull"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<h1 id="尝试在方法参数上实现-notnull-range">尝试在方法参数上实现 @NotNull @Range</h1>

<p>对于方法的形式参数，Java的反射机制并不能直接获取参数的值，毕竟只有在方法调用的时候才有值，因此失败了。如果需要在方法运行时对参数进行检查，可以使用面向切面编程（AOP）结合反射来实现。</p>

<p>不过对于对象的字段，可以直接通过反射获取字段的值，并进行判断。但要注意判断的时机需要另外的事件来触发。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Field</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="n">checkField</span><span class="o">(</span><span class="n">myClass</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkField</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getDeclaredFields</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Annotation</span><span class="o">[]</span> <span class="n">annotations</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotations</span><span class="o">();</span>
                <span class="nc">NotNull</span> <span class="n">n</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">Annotation</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">annotations</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Annotation</span><span class="o">&gt;</span> <span class="n">aClass</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">annotationType</span><span class="o">();</span>
                    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>

                    <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">NotNull</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">n</span> <span class="o">=</span> <span class="n">notNullDispose</span><span class="o">((</span><span class="nc">NotNull</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">aClass</span> <span class="o">==</span> <span class="nc">Range</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">rangeDispose</span><span class="o">(</span><span class="n">field</span><span class="o">,</span> <span class="o">(</span><span class="nc">Range</span><span class="o">)</span> <span class="n">annotation</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">rangeDispose</span><span class="o">(</span><span class="nc">Field</span> <span class="n">field</span><span class="o">,</span> <span class="nc">Range</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">,</span> <span class="nc">NotNull</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">value</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">())</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"="</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" 无效,长度必须不小于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">min</span><span class="o">()</span> <span class="o">+</span> <span class="s">",不大于："</span> <span class="o">+</span> <span class="n">annotation</span><span class="o">.</span><span class="na">max</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
<span class="c1">//              throw new IllegalArgumentException(text);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">NotNull</span> <span class="nf">notNullDispose</span><span class="o">(</span><span class="nc">NotNull</span> <span class="n">annotation</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">NotNull</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 不能为空"</span><span class="o">);</span>
<span class="c1">//          throw new IllegalArgumentException(n.value() + " 不能为空");</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"名称"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nd">@NotNull</span><span class="o">(</span><span class="s">"地址"</span><span class="o">)</span>
    <span class="nd">@Range</span><span class="o">(</span><span class="n">max</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">address</span> <span class="o">=</span> <span class="s">"123456"</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">NotNull</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">()</span> <span class="k">default</span> <span class="s">""</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">({</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">})</span>
<span class="nd">@interface</span> <span class="nc">Range</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">min</span><span class="o">()</span> <span class="k">default</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="nf">max</span><span class="o">()</span> <span class="k">default</span> <span class="mi">255</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>acteds</name></author><category term="Java" /><summary type="html"><![CDATA[Java笔记]]></summary></entry><entry><title type="html">Git推送到Github的一些设置</title><link href="/2024/01/25/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/" rel="alternate" type="text/html" title="Git推送到Github的一些设置" /><published>2024-01-25T00:00:00+08:00</published><updated>2024-01-25T00:00:00+08:00</updated><id>/2024/01/25/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE</id><content type="html" xml:base="/2024/01/25/git%E5%90%8C%E6%AD%A5%E5%88%B0github%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/"><![CDATA[<h2 id="引言">引言</h2>
<p>记录一些通常设置。</p>

<h2 id="详解">详解</h2>
<ul>
  <li>下载<a href="https://git-scm.com/downloads">Git</a></li>
  <li>设置Git环境变量</li>
  <li>配置SSH，完成GitHub身份验证<br />
终端输入：<code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa -C 邮箱地址</code>，邮箱地址为GitHub的邮箱地址。<br />
找到公钥文件(id_rsa.pub)，打开文件,复制内容<br />
在GitHub上添加SSH keys(头像-Settings-SSH and GPG keys-New SSH key)，标题随便，key内填公钥内容。</li>
  <li>验证是否成功：<code class="language-plaintext highlighter-rouge">ssh -T git@github.com</code></li>
</ul>

<p>若出现<code class="language-plaintext highlighter-rouge">ssh: connect to host github.com port 22: Connection timed out</code></p>

<p>可以尝试修改SSH主机名：</p>

<p>在.ssh文件夹中新建config文件，无扩展名，并写入以下内容：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host github.com
User 你的GitHub账号名称或邮箱地址
Hostname ssh.github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa
Port 443
</code></pre></div></div>
<p>重新验证是否成功：<code class="language-plaintext highlighter-rouge">ssh -T git@github.com</code></p>

<p>输入yes即可。</p>

<h2 id="额外操作">额外操作</h2>
<p>在使用 Git 进行代码托管和版本控制的过程中，如果你想在提交代码时被正确的识别和归属，那么需要设置正确的 Git 邮箱地址。如果不设置邮箱，那么提交代码的作者将会是默认的 Git 用户，这会导致代码历史不可读，并且无法更好地识别谁提交的代码。</p>

<p>配置 git config：</p>

<pre><code class="language-cmd">git config --global user.name github_name
git config --global user.email github_email
</code></pre>
<p>显示带有颜色和图形的 Git 日志：</p>
<pre><code class="language-cmd">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"
</code></pre>
<p>参数解析：</p>
<ul>
  <li>–color： 启用彩色输出。</li>
  <li>–graph： 以图形的方式展示分支和合并历史。</li>
  <li>–pretty=format： 定制输出格式，使用一系列的占位符表示不同的信息。</li>
  <li>%Cred%h%Creset： 以红色显示短的提交哈希。</li>
  <li>-%C(yellow)%d%Creset： 显示分支和标签信息，并使用黄色。</li>
  <li>%s： 显示提交信息。</li>
  <li>%Cgreen(%cr)%Creset： 以绿色显示相对的提交时间。</li>
  <li>%C(bold blue)&lt;%an&gt;%Creset： 以粗体蓝色显示作者。</li>
</ul>

<p>全局配置文件在用户根目录下的.gitconfig文件，也可直接修改这个文件进行配置</p>

<p>若只想作用于单个仓库，只需要去掉–global参数</p>

<p>单个仓库配置文件在.git/config文件。</p>

<h2 id="推送代码">推送代码</h2>
<pre><code class="language-cmd">git init
git add .
git commit -m "init"
git remote add github git@github.com:[id]/[库名].git
git push -u origin [远程分支名]
</code></pre>]]></content><author><name>acteds</name></author><category term="Git" /><category term="GitHub" /><summary type="html"><![CDATA[Git推送到Github的一些设置]]></summary></entry></feed>