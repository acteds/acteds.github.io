<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>C语言重点知识-基础 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2019/07/03/C%E8%AF%AD%E8%A8%80%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86-%E5%9F%BA%E7%A1%80/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="C语言重点知识-基础"><meta name="keywords" content="c"><meta name="og:keywords" content="c"><meta name="description" content="引言本篇文章介绍C的基础,即输入输出、判断、循环、存储类、函数、操作符、数组。"><meta name="og:description" content="引言本篇文章介绍C的基础,即输入输出、判断、循环、存储类、函数、操作符、数组。"><meta property="og:url" content="/2019/07/03/C%E8%AF%AD%E8%A8%80%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86-%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2019-07-03"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="C语言重点知识-基础"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">C语言重点知识-基础</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2019/07/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#c" title="c">c</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 5505 字，约 16 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>本篇文章介绍C的基础,即输入输出、判断、循环、存储类、函数、操作符、数组。</p><h1 id="其他">其他</h1><h2 id="行尾加">行尾加\</h2><p>在C语言中通过在行的最后加<strong>\</strong>可以告诉C语言这行与下行合并在任意位置,但是如果下行有缩进那么缩进也会被合并:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span><span class="kt">int</span><span class="err"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="err"> </span><span class="n">argc</span><span class="p">,</span><span class="err"> </span><span class="kt">char</span><span class="err"> </span><span class="k">const</span><span class="err"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="err">    </span><span class="kt">char</span><span class="err"> </span><span class="n">a</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="s">"</span><span class="se">\0</span><span class="s">"</span><span class="p">;</span>
<span class="err">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="err"> </span><span class="n">a</span><span class="p">);</span>
<span class="err">    </span><span class="n">pri</span>\
<span class="n">ntf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="err"> </span><span class="n">a</span><span class="p">);</span>
<span class="err">    </span><span class="k">return</span><span class="err"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="goto的使用">goto的使用:</h2><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">a1:</span>
<span class="err">    </span><span class="n">out99</span><span class="p">();</span>
<span class="err">    </span><span class="k">goto</span><span class="err"> </span><span class="n">a1</span><span class="p">;</span>
</code></pre></div></div><h2 id="整型提升">整型提升</h2><p>表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器（ALU）的操作数的字节长度一般就是<strong>int</strong>的字节长度，同时也是CPU的通用寄存器的长度。</p><p>因此，即使两个<strong>char</strong>类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度.所以，表达式中各种长度可能小于<strong>int</strong>长度的整型值，都必须先转换为<strong>int</strong>或 <strong>unsigned int</strong>，然后才能送入CPU去执行运算.</p><p>无符号整型提升时左边补0,有符号整型提升左边补符号位.</p><p>栈区默认使用高地址处的空间。</p><p>数组随着下标的增长,地址是由低到高变化。</p><p><strong>Release</strong>版本是经过优化的,<strong>debug</strong>版本是未经优化的。</p><p>整型是以<strong>补码</strong>存放在内存中,补码=原码除符号位取反+1。</p><h2 id="大端小端字节序存储模式">大端小端(字节序存储模式)</h2><p>大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在內存的低地址中</p><p>小端（存储）模式，是指数据的<strong>低位保存在內存的低地址</strong>中，而数据的髙位，保存在内存的高地址中。</p><p><strong><code class="language-plaintext highlighter-rouge">int a=1;</code></strong>,如果是小端则a的值在内存中为<strong>01 00 00 00</strong>.</p><h2 id="浮点数在内存中的存储">浮点数在内存中的存储:</h2><p>IEEE 754:</p><p>对于32位浮点数,1位符号位+8位次方位,+23位浮点位.,次方位要加127确保为正<br /> -5.0相当于-101.0 即-1.01*2^2 那么s=1,M=1.01,E=2</p><p>也就是:1 10000001 01000000000000000000000</p><p>对于64位浮点数,1位符号位+11位次方位,+54位浮点位.,指数位要加1023确保为正</p><p>表格 1 各种数据类型的初始值</p><table><thead><tr><th>数据类型</th><th>初始化默认值</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>char</td><td>‘\0’</td></tr><tr><td>float</td><td>0</td></tr><tr><td>double</td><td>0</td></tr><tr><td>pointer</td><td>NULL</td></tr></tbody></table><h1 id="输入输出">输入输出</h1><p><strong><code class="language-plaintext highlighter-rouge">printf()</code></strong>的返回值为打印的字符串长度</p><p>使用<strong>printf</strong> 输出 <strong>double</strong> 和 <strong>float</strong> 都可以用 <strong><code class="language-plaintext highlighter-rouge">%f</code></strong> 占位符，而 <strong>double</strong> 可以额外用 <strong><code class="language-plaintext highlighter-rouge">%lf</code></strong>。</p><p>而<strong>scanf</strong>输入情况下 <strong>double</strong> <strong>必须</strong>用 <strong><code class="language-plaintext highlighter-rouge">%lf</code></strong>，<strong>float</strong> <strong>必须</strong>用 <strong><code class="language-plaintext highlighter-rouge">%f</code></strong> 不能混用。</p><p><strong>scanf</strong>函数以<strong>空格</strong>或<strong>换行</strong>做为分隔符</p><p>当<strong><code class="language-plaintext highlighter-rouge">getchar()</code></strong>放在<strong><code class="language-plaintext highlighter-rouge">scanf("%s",chs)</code></strong>语句后面,那么将会接收<strong><code class="language-plaintext highlighter-rouge">sacnf()</code></strong>没有接收的<strong><code class="language-plaintext highlighter-rouge">\n</code></strong>,要解决,则可以再加一个<strong><code class="language-plaintext highlighter-rouge">getchar()</code></strong>或循环<strong><code class="language-plaintext highlighter-rouge">getchar()</code></strong>清空缓冲区.</p><h2 id="格式化输出">格式化输出:</h2><p><strong>基本型，用 %f</strong></p><p>不指定输出类型的长度，一般是实数中的整数部分全部输出，小数部分输出六位。例：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div></div><p>运行结果：<strong>0.333333</strong></p><h2 id="指定数据宽度和小数位数用mnf">指定数据宽度和小数位数，用 <code class="language-plaintext highlighter-rouge">%m.nf</code></h2><p>例：将上个程序的双精度变量 a 输出 15 位小数，用 <code class="language-plaintext highlighter-rouge">%20.15f</code> 的格式声明，指定输出的数据占 20 列，其中包括 15 位小数。改动上面程序如下：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%20.15f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">3</span><span class="p">);</span>
</code></pre></div></div><p>运行结果：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0.333333333333333
</code></pre></div></div><p>注意在 0 的前面有 3 个空格，且双精度数只保证 15 位有效数字的准确性。</p><h2 id="输出的数据左对齐用-mnf">输出的数据左对齐，用 <code class="language-plaintext highlighter-rouge">%-m.nf</code></h2><p>在 <strong><code class="language-plaintext highlighter-rouge">m.n</code></strong> 前加一个负号，其作用与 <strong><code class="language-plaintext highlighter-rouge">%m.nf</code></strong> 形式作用基本相同，但当数据长度不长过 <strong><code class="language-plaintext highlighter-rouge">m</code></strong>时，数据向左靠，右端补空格。</p><p><strong>%p打印地址</strong></p><h2 id="gets"><strong>gets()</strong></h2><p>函数原型：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">gets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">);</span>
</code></pre></div></div><p>函数功能：从键盘上输入字符，直至接受到换行符或EOF时停止，并将读取的结果存放在<strong>buffer</strong>指针所指向的字符数组中。</p><p>读取的换行符被转换为null值，做为字符数组的最后一个字符，来结束字符串。</p><p>读取字符到数组,<strong>str</strong>为数组名。例：<strong>gets(str);</strong></p><p><strong>gets()的安全性问题</strong></p><p>示例:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">gets</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
</code></pre></div></div><p>如果输入的内容大于5，也会正常的打印出来，但是系统会提示程序崩溃。</p><p><strong>gets</strong>函数由于没有指定输入字符大小，所以会<strong>无限读取</strong>，一旦输入的字符大于数组长度，就会发生<strong>内存越界</strong>，从而造成程序崩溃或其他数据的错误。</p><p>考虑到程序安全性和健壮性，建议用<strong>fgets()</strong>来代替<strong>gets()</strong>。即:<strong>fgets(str,5,stdin);</strong>，<strong>stdin</strong>表示从键盘输入数据。</p><h2 id="fgets">fgets()</h2><p>函数原型：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="nf">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div></div><p>函数功能：从文件指针<strong>stream</strong>中读取字符，存到以<strong>s</strong>为起始地址的空间里，直到读完<strong>n-1</strong>个字符，或者读完一行。</p><p>注意：调用<strong>fgets</strong>函数时，最多只能读入<strong>n-1</strong>个字符。读入结束后，系统将自动在最后<strong>加’\0’</strong>，并以<strong>s</strong>作为函数值返回。</p><p>可以这么使用：<strong>fgets(str, sizeof(str), stdin);</strong></p><p>其中<strong>str</strong>为数组首地址，<strong>sizeof(str)</strong>为数组大小，<strong>stdin</strong>表示从键盘输入数据。</p><h1 id="判断语句">判断语句</h1><p><strong>else与离得最近的未匹配的if匹配</strong></p><p><strong>switch</strong> 语句中的 <strong>expression</strong> 是一个常量表达式，<strong>必须</strong>是一个<strong>整型</strong>或<strong>枚举类型</strong>。<strong>case</strong> 的 <strong>constant-expression</strong> <strong>必须</strong>与 switch 中的变量具有<strong>相同的数据类型</strong>，且<strong>必须</strong>是一个<strong>常量</strong>或<strong>字面量</strong>。</p><h1 id="循环">循环</h1><p>while与for的不同</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="err"> </span><span class="p">(</span><span class="kt">int</span><span class="err"> </span><span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">1</span><span class="p">;</span><span class="err"> </span><span class="n">i</span><span class="err"> \</span><span class="o">&lt;</span><span class="err"> </span><span class="mi">10</span><span class="p">;</span><span class="err"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="err">    </span><span class="c1">//该操作只会跳过i==5之后的语句,然后执行i++;</span>
<span class="err">    </span><span class="k">if</span><span class="err"> </span><span class="p">(</span><span class="n">i</span><span class="err"> </span><span class="o">==</span><span class="err"> </span><span class="mi">5</span><span class="p">)</span><span class="err"> </span><span class="p">{</span><span class="err"> </span><span class="k">continue</span><span class="p">;</span><span class="err"> </span><span class="p">}</span>
<span class="err">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="err"> </span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="kt">int</span><span class="err"> </span><span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">while</span><span class="err"> </span><span class="p">(</span><span class="n">i</span><span class="err">\</span><span class="o">&lt;=</span><span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
<span class="err">     </span><span class="c1">//该操作会使i++;语句无法执行,导致死循环</span>
<span class="err">     </span><span class="k">if</span><span class="err"> </span><span class="p">(</span><span class="n">i</span><span class="o">==</span><span class="mi">5</span><span class="p">)</span><span class="err"> </span><span class="p">{</span><span class="err"> </span><span class="k">continue</span><span class="p">;</span><span class="err"> </span><span class="p">}</span>
<span class="err">     </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="err"> </span><span class="n">i</span><span class="p">);</span>
<span class="err">     </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>执行结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>12346789
1234
</code></pre></div></div><p>同样的,<strong>do…while</strong>不当使用<strong>continue</strong>;也会导致死循环.</p><p>for循环里第一条语句在<strong>C99</strong>之前是不能同时定义并赋值的,<strong>只能赋值</strong>即:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="err"> </span><span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="err"> </span><span class="p">(</span><span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">1</span><span class="p">;</span><span class="err"> </span><span class="n">i</span><span class="err"> </span><span class="o">&lt;</span><span class="err"> </span><span class="mi">10</span><span class="p">;</span><span class="err"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="err"> </span><span class="p">{</span><span class="err"> </span><span class="p">}</span>
</code></pre></div></div><p>建议for语句的循环控制变量的取值采用”前闭后开区间”写法</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="err"> </span><span class="p">(</span><span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">1</span><span class="p">;</span><span class="err"> </span><span class="n">i</span><span class="err"> </span><span class="o">&lt;</span><span class="err"> </span><span class="mi">10</span><span class="p">;</span><span class="err"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</code></pre></div></div><p>两条语句执行效果相同,都是死循环</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="err"> </span><span class="p">(;;){}</span>
<span class="k">while</span><span class="err"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err"> </span><span class="p">{}</span>
</code></pre></div></div><p>递归是一个简洁的概念，同时也是一种很有用的手段。但是，使用递归是要付出代价的。与直接的语句(如<strong>while</strong>循环)相比，递归函数会耗费<strong>更多</strong>的运行时间，并且要占用大量的栈空间。递归函数每次调用自身时，都需要把它的状态存到栈中，以便在它调用完自身后，程序可以返回到它原来的状态。未经精心设计的递归函数总是会带来麻烦。</p><h1 id="存储类">存储类</h1><p><strong>auto</strong> 存储类是所有<strong>局部变量默认</strong>的存储类<strong>,auto</strong> <strong>只能</strong>用在函数内，即 <strong>auto</strong> 只能修饰局部变量。</p><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小，且<strong>不能</strong>对它应用一元的<strong>&amp;</strong>运算符（因为它<strong>没有内存位置</strong>）。寄存器只用于需要快速访问的变量，比如计数器。定义 <strong>register</strong> 并不意味着变量将被存储在寄存器中，它意味着变量<strong>可能存储在寄存器</strong>中，这取决于硬件和实现的限制。</p><p><strong>static</strong> 存储类指示编译器在<strong>程序的生命周期</strong>内<strong>保持局部变量</strong>的<strong>存在</strong>，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 <strong>static</strong> 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p><strong>static</strong> 修饰符也可以应用于<strong>全局变量</strong>。当 <strong>static</strong> 修饰全局变量时，会使变量的<strong>作用域限制在</strong>声明它的<strong>文件内</strong>。</p><p>全局声明的一个 <strong>static</strong> 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 <strong>static</strong> 变量或方法<strong>同一个文件</strong>中。<strong>static</strong> 为所有<strong>全局变量默认</strong>的存储类.</p><p><strong>extern</strong> 存储类用于在一个文件中声明一个全局变量或函数，该变量或函数是在另一个文件中定义的。通过使用 <strong>extern</strong>，可以将变量或函数的引用提供给其他文件，使得这些变量或函数在<strong>其他文件</strong>中可见和可访问。具体来说：</p><p>对于变量或函数，<strong>extern</strong> 用于声明一个全局变量或函数。变量或函数的定义通常在另一个文件里，使用 <strong>extern</strong> 声明这个变量或函数后可以在当前文件中使用这个全局变量或函数。</p><p>在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个变量名字相同，会优先使用<strong>局部变量</strong>值.</p><p>全局变量与局部变量在内存中的区别:</p><p>全局变量保存在<strong>内存的全局存储区</strong>中，占用<strong>静态</strong>的存储单元；</p><p>局部变量保存在<strong>栈</strong>中，只有在所在函数被调用时才<strong>动态</strong>地为变量分配存储单元。</p><h1 id="函数">函数</h1><p>在函数声明中，参数的名称并不重要，只有<strong>参数的类型</strong>是<strong>必需</strong>的，因此下面也是有效的声明：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div></div><p>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是<strong>必需</strong>的。应该在调用函数的文件<strong>顶部</strong>声明函数。</p><p>引用的声明以及调用:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">void</span><span class="err"> </span><span class="n">swap</span><span class="p">(</span><span class="kt">int</span><span class="err"> </span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="err"> </span><span class="kt">int</span><span class="err"> </span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="err"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</code></pre></div></div><h2 id="内部函数">内部函数</h2><p>如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数前面加 <strong>static</strong>,即:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){;}</span>
</code></pre></div></div><p>内部函数又称静态函数。使用内部函数，可以使函数的作用域只<strong>局限</strong>于<strong>所在文件</strong>。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。</p><h2 id="外部函数默认--">外部函数<strong>(</strong>默认 )</h2><p>如果在定义函数时，在函数的首部的最左端加关键字 <strong>extern</strong>，则此函数是外部函数，可供<strong>其它文件调</strong>用。即:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">int</span> <span class="nf">max</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">b</span><span class="p">){;}</span>
</code></pre></div></div><p>在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 <strong>extern</strong>，表示该函数是在其他文件中定义的外部函数。</p><h2 id="内联函数">内联函数</h2><p>内联函数是使用 <strong>inline</strong> 关键字修饰的函数。内联函数在源代码中具有函数的结构，但在编译后不具备函数的性质，而是直接将函数体插入到每个调用处。内联函数的主要作用是消除函数调用时的时间开销，特别适合于频繁执行的小函数。</p><h1 id="操作符">操作符</h1><p><strong>所有整数在C语言中都是以补码的形式</strong></p><p><strong>补码为原码除符号位取反再加一</strong></p><p>右移操作符:<strong>&gt;&gt;</strong></p><p>算数右移:右边丢弃,左边补原符号位</p><p>逻辑右移:右边丢弃,左边补0</p><p>无符号为逻辑位移,有符号数为算数右移.</p><p>左移操作符:<strong>&lt;&lt;</strong></p><p>左边丢弃,右边补0</p><p><strong>sizeof返回的数是无符号整型</strong></p><p>因此与-1比较大小则-1会发生隐式类型转换,也会看做无符号数。</p><p><strong>sizeof</strong>内的式子不会进行计算.即:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">short</span><span class="err"> </span><span class="n">s</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="err"> </span><span class="n">a</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">10</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%I64d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="err"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="n">a</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mi">5</span><span class="p">));</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="err"> </span><span class="n">s</span><span class="p">);</span>
</code></pre></div></div><p>结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
0
</code></pre></div></div><p><strong>~</strong></p><p>取反,包括符号位</p><p><strong>&amp;&amp; ||</strong></p><p>断路与断路或,即得出结果后就不再向后执行了</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="err"> </span><span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">0</span><span class="p">,</span><span class="err"> </span><span class="n">a</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">1</span><span class="p">,</span><span class="err"> </span><span class="n">b</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">2</span><span class="p">,</span><span class="err"> </span><span class="n">c</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">3</span><span class="p">,</span><span class="err"> </span><span class="n">d</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">4</span><span class="p">;</span>
<span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="n">a</span><span class="o">++</span> <span class="o">||</span> <span class="o">++</span><span class="n">b</span> <span class="o">||</span> <span class="n">d</span><span class="o">++</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="err"> </span><span class="n">a</span><span class="p">,</span><span class="err"> </span><span class="n">b</span><span class="p">,</span><span class="err"> </span><span class="n">c</span><span class="p">,</span><span class="err"> </span><span class="n">d</span><span class="p">);</span>
<span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">0</span><span class="p">,</span><span class="err"> </span><span class="n">a</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">1</span><span class="p">,</span><span class="err"> </span><span class="n">b</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">2</span><span class="p">,</span><span class="err"> </span><span class="n">c</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">3</span><span class="p">,</span><span class="err"> </span><span class="n">d</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="mi">4</span><span class="p">;</span>
<span class="n">i</span><span class="err"> </span><span class="o">=</span><span class="err"> </span><span class="n">a</span><span class="o">++</span><span class="err"> </span><span class="o">&amp;&amp;</span><span class="err"> </span><span class="o">++</span><span class="n">b</span><span class="err"> </span><span class="o">&amp;&amp;</span><span class="err"> </span><span class="n">d</span><span class="o">++</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d %d %d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="err"> </span><span class="n">a</span><span class="p">,</span><span class="err"> </span><span class="n">b</span><span class="p">,</span><span class="err"> </span><span class="n">c</span><span class="p">,</span><span class="err"> </span><span class="n">d</span><span class="p">);</span>
</code></pre></div></div><p>结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 2 3 4
2 3 3 5
</code></pre></div></div><h1 id="数组">数组</h1><p>声明:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">type</span> <span class="n">arrayName</span> <span class="p">[</span> <span class="n">arraySize</span> <span class="p">];</span>
</code></pre></div></div><p>这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">balance</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div><p>初始化:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">balance</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">.</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">.</span><span class="mi">0</span><span class="p">};</span>
</code></pre></div></div><p>大括号<strong>{}</strong>之间的值的数目不能大于在数组声明时在方括号<strong>[]</strong>中指定的元素数目。</p><p>如果省略掉了数组的大小，数组的大小则为<strong>初始化时元素的个数</strong>。</p><p>二维数组列不能省略,行则可以即:<strong>a[][20]</strong>;</p><p><strong>&amp;arr</strong> 为数组的地址,当使用<strong>&amp;arr+1</strong>时跳过的地址为整个数组的大小.</p><p><strong>sizeof(arr)</strong>表示整个数组的大小</p><p><strong>二维数组存放字符串，则在读取时当一维数组使用:</strong></p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">names</span><span class="p">[</span><span class="mi">6</span><span class="p">][</span><span class="mi">50</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">"马超"</span><span class="p">,</span><span class="s">"关平"</span><span class="p">,</span><span class="s">"赵云"</span><span class="p">,</span><span class="s">"张飞"</span><span class="p">,</span><span class="s">"关羽"</span><span class="p">,</span><span class="s">"刘备"</span><span class="p">};</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"悍将名称：%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p><strong>二维数组传递给函数</strong></p><p>方法1: 第一维的长度可以不指定，但必须指定第二维的长度：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">print_a</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[][</span><span class="mi">5</span><span class="p">],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div><p>方法2: 指向一个有5个元素一维数组的指针：</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">print_b</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)[</span><span class="mi">5</span><span class="p">],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div><p>方法3: 利用数组是顺序存储的特性,通过降维来访问原数组</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">print_c</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></div><p>如果知道二维数组的长度，当然选择第一或者第二种方式，但是长度不确定时，只能传入数组大小来遍历元素。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2019/07/03/C%E8%AF%AD%E8%A8%80%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86-%E5%9F%BA%E7%A1%80/" target="_blank">https://acteds.github.io/2019/07/03/C%E8%AF%AD%E8%A8%80%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86-%E5%9F%BA%E7%A1%80/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1725108600', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
