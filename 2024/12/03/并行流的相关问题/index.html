<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>并行流的相关问题 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="并行流的相关问题"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言"><meta name="og:description" content="引言"><meta property="og:url" content="/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-12-03"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="并行流的相关问题"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">并行流的相关问题</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/12/03 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 4570 字，约 14 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>并行流的相关问题，顺序问题，以及多线程问题。</p><h1 id="java">Java</h1><h2 id="stream流">Stream流</h2><h3 id="并行流">并行流</h3><h4 id="顺序">顺序</h4><p>并行流 (<code class="language-plaintext highlighter-rouge">parallelStream</code>) 并不保证元素的顺序。默认情况下，<code class="language-plaintext highlighter-rouge">parallelStream</code> 会分割任务并让多个线程并行处理数据，这样<strong>处理顺序</strong>是不可预测的，因此它无法保证结果的顺序。</p><p><strong>保证结果顺序：</strong></p><p><strong>使用顺序流</strong>：如果你不特别需要并行处理，可以改为使用顺序流（即使用 <code class="language-plaintext highlighter-rouge">stream()</code> 而不是 <code class="language-plaintext highlighter-rouge">parallelStream()</code>），这样可以确保顺序不变。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">false</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getStringCellValue</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div><p><strong>使用 <code class="language-plaintext highlighter-rouge">collect</code> 时强制保序</strong>：如果你坚持使用并行流，并且仍然需要保持顺序，可以在收集结果时使用 <code class="language-plaintext highlighter-rouge">Collectors.toList()</code>，因为它会<strong>按顺序将流中的元素收集到列表</strong>中，即使是并行流：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableHeader</span> <span class="o">=</span> <span class="nc">StreamSupport</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">spliterator</span><span class="o">(),</span> <span class="kc">true</span><span class="o">)</span>
        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Cell:</span><span class="o">:</span><span class="n">getStringCellValue</span><span class="o">)</span>
        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</code></pre></div></div><p>还可以显示的在流的末尾使用 <code class="language-plaintext highlighter-rouge">sorted()</code> 或 <code class="language-plaintext highlighter-rouge">forEachOrdered()</code> 来强制保持顺序。</p><hr /><p>但是，<strong>即使你使用 <code class="language-plaintext highlighter-rouge">Collectors.toList()</code></strong>，并行流的<strong>内部执行顺序</strong>仍然不可预测，即：</p><p>并行流在执行时不会保证操作的顺序。流中的操作可能会被多个线程并行执行，这样即使是 <code class="language-plaintext highlighter-rouge">map</code> 或 <code class="language-plaintext highlighter-rouge">filter</code> 这些按顺序执行的操作，在并行流中也可能会导致结果的顺序发生改变。</p><p>为什么并行流与 <code class="language-plaintext highlighter-rouge">Collectors.toList()</code> 保持顺序？</p><p>流的合并方式： 当使用 <code class="language-plaintext highlighter-rouge">parallelStream</code> 时，数据会被分割成多个片段，每个线程处理其中的一部分。每个片段中的操作是顺序的，但它们之间的合并顺序不一定保持一致。</p><p><code class="language-plaintext highlighter-rouge">Collectors.toList()</code> 的行为：</p><p><code class="language-plaintext highlighter-rouge">Collectors.toList()</code> 是一个 无状态收集器，它只是将流中的元素收集到一个新的列表中。由于 <code class="language-plaintext highlighter-rouge">List</code> 是有顺序的容器，所以它会保持收集的顺序，即使是并行流。因为在 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 的情况下，流会分割成多个子流，并行处理后最终合并，而合并时，<code class="language-plaintext highlighter-rouge">toList</code> 会保持各个子流处理后的顺序。</p><h4 id="多线程">多线程</h4><p>并行流（<code class="language-plaintext highlighter-rouge">parallelStream</code>）是 Java 8 引入的功能，它通过分割数据源来使用多个线程并行地处理数据，从而提高处理速度。但并行流的多线程使用也带来了一些潜在的问题，特别是在以下几种情况下：</p><p><strong>线程安全问题</strong></p><p>并行流使用多个线程同时操作同一数据，这可能会引发线程安全问题。例如，如果你在流的操作中修改共享的可变对象，或者在 <code class="language-plaintext highlighter-rouge">collect</code> 操作中使用了非线程安全的集合，就可能会出现并发修改的问题。</p><p>解决方案：</p><ul><li>对于共享的资源，确保线程安全。可以使用 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>、<code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList</code> 等线程安全的集合。</li><li>使用 <code class="language-plaintext highlighter-rouge">synchronized</code> 或 <code class="language-plaintext highlighter-rouge">ThreadLocal</code> 来保证每个线程操作自己的副本。</li><li>避免在流中直接修改外部共享的状态，特别是在 <code class="language-plaintext highlighter-rouge">forEach</code> 操作中。</li></ul><p><strong>状态不一致</strong></p><p>并行流中的一些操作可能会导致中间结果的不一致。例如，在并行流的某个操作中修改了共享状态，可能会造成中间状态在多个线程之间不一致，最终导致结果不正确。</p><p>解决方案：</p><ul><li>避免修改流中的共享状态，尤其是不可变对象的状态。</li><li>使用不可变对象和线程本地数据来避免状态不一致。</li><li>对于需要修改状态的操作，确保该操作是原子性的。</li></ul><p><strong>线程池饱和</strong> 并行流会使用公共的 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> 来管理线程池。如果并行流的任务过多，线程池可能会耗尽，导致线程饱和，甚至阻塞其他任务。</p><p>解决方案：</p><ul><li>可以通过设置系统属性 <code class="language-plaintext highlighter-rouge">java.util.concurrent.ForkJoinPool.common.parallelism</code> 来控制 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code> 的线程池大小（默认为 <code class="language-plaintext highlighter-rouge">availableProcessors</code>）。</li><li>对于非常重的任务，考虑使用自定义的线程池，而不是依赖默认的公共线程池。</li></ul><p><strong>示例代码：避免线程安全问题</strong></p><p>假设你在使用并行流时修改了共享的 <code class="language-plaintext highlighter-rouge">List</code>，这将导致线程安全问题：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">sharedList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>

<span class="c1">// 错误的并行流：会修改共享资源，造成线程安全问题</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">sharedList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 不安全</span>

<span class="c1">// 正确的做法：使用线程安全的集合或避免共享资源</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">safeList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">safeList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 安全</span>
</code></pre></div></div><p>或者，避免在流操作中修改外部状态：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 错误的做法：修改外部共享状态</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">externalList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">externalList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 可能不安全</span>

<span class="c1">// 正确的做法：使用局部变量或者线程局部变量</span>
<span class="nc">ThreadLocal</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">localList</span> <span class="o">=</span> <span class="nc">ThreadLocal</span><span class="o">.</span><span class="na">withInitial</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">);</span>
<span class="n">data</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">localList</span><span class="o">.</span><span class="na">get</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>  <span class="c1">// 安全</span>
</code></pre></div></div><p>并行流在适当的场景下可以显著提升性能，但如果使用不当，会导致性能问题或线程安全问题。为了安全高效地使用并行流：</p><ul><li>确保流中的操作是线程安全的。</li><li>避免并行化不适合并行的任务。</li><li>处理数据时，确保操作的顺序性（如果需要的话）。</li><li>留意线程池资源限制和并行度的配置。</li></ul><p>使用并行流时要权衡其带来的好处与潜在的复杂性和开销。</p><h4 id="使用场景">使用场景</h4><p>如果数据量小，使用 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 仍然会开启多个线程，但在这种情况下，开多线程的开销可能大于并行处理带来的性能提升。<code class="language-plaintext highlighter-rouge">parallelStream()</code> 并不会自动判断数据量大小并决定是否启用并行。</p><p>详细解释：</p><ol><li><p><strong><code class="language-plaintext highlighter-rouge">parallelStream()</code> 的工作原理</strong>： <code class="language-plaintext highlighter-rouge">parallelStream()</code> 会将数据分成多个片段，并在不同的线程中并行处理这些片段。具体来说，它使用了 <strong><code class="language-plaintext highlighter-rouge">ForkJoinPool</code></strong> 来管理线程池，默认情况下，会根据 CPU 核心数来决定线程池的大小。</p></li><li><p><strong>线程开销</strong>： 对于较小的数据量，线程的创建、上下文切换和管理等开销可能超过并行化处理所带来的性能提升。这是因为每个线程都有一定的启动成本，而如果数据量不够大，单线程的处理可能已经足够高效。</p></li><li><p><strong><code class="language-plaintext highlighter-rouge">parallelStream()</code> 会开线程</strong>： 即使数据量很小，调用 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 依然会启动多个线程，具体线程数取决于 <strong><code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code></strong> 的设置，默认情况下，它会根据机器的 <strong>CPU 核心数</strong> 来分配线程数。如果你的 CPU 核心数较多，<code class="language-plaintext highlighter-rouge">parallelStream()</code> 会使用多个线程来处理即使是小的数据集。</p></li><li><p><strong>性能评估</strong>：</p><ul><li>对于小数据集，<strong>顺序流（<code class="language-plaintext highlighter-rouge">stream()</code>）</strong> 往往比并行流更高效，因为线程开销、任务划分和合并等都增加了额外的成本。</li><li>如果你有大量的数据并行处理，并且<strong>数据量大于处理开销</strong>，<code class="language-plaintext highlighter-rouge">parallelStream()</code> 的并行化处理可能会带来明显的性能提升。</li></ul></li></ol><p>结论：</p><ul><li><code class="language-plaintext highlighter-rouge">parallelStream()</code> 不会自动判断数据量的大小。</li><li>即使数据量小，<code class="language-plaintext highlighter-rouge">parallelStream()</code> 仍会启动多个线程，但这可能会导致性能下降。</li><li>如果数据量较小，推荐使用顺序流（<code class="language-plaintext highlighter-rouge">stream()</code>），这样可以避免不必要的线程开销。</li></ul><p>如果你的数据量较小，可以通过对比测试顺序流和并行流的性能，来决定是否使用并行流。</p><hr /><p>“<strong>大</strong>”和“<strong>小</strong>”数据量是相对的，具体取决于多种因素，包括数据的复杂性、处理任务的复杂度、硬件环境、并行化的开销等。没有一个固定的阈值来判断数据量是“大”还是“小”，但可以根据以下几个维度来理解和评估：</p><p><strong>数据量的维度</strong></p><ul><li><strong>条目数</strong>：指的是集合中元素的数量。比如，<code class="language-plaintext highlighter-rouge">List</code> 中有 1000 条数据，或者 10,000 条数据。</li><li><strong>元素大小</strong>：每个数据项的大小。例如，每个数据项可能是一个简单的整数，或者包含多个字段和复杂的数据结构。</li></ul><p><strong>一般经验</strong>：</p><ul><li>小数据量：通常为 1000 条以下的数据。</li><li>中等数据量：大约 1000 到 100,000 条。</li><li>大数据量：超过 100,000 条数据，尤其是需要做复杂计算时。</li></ul><p><strong>操作的复杂度</strong></p><ul><li><strong>简单操作</strong>：例如对简单数据类型（如整数、字符串等）的求和、查找等操作。</li><li><p><strong>复杂操作</strong>：例如对每个数据项进行复杂的计算、条件筛选、合并、排序、分组等操作。</p></li><li><strong>小数据量</strong> 和 <strong>简单操作</strong>：并行流的开销不明显，可能没有必要使用 <code class="language-plaintext highlighter-rouge">parallelStream()</code>，使用顺序流更为高效。</li><li><strong>小数据量</strong> 和 <strong>复杂操作</strong>：即使数据量小，复杂的操作可能使得并行化处理带来明显的性能提升。</li></ul><p><strong>硬件和环境的影响</strong></p><ul><li><strong>CPU 核心数</strong>：计算机的核心数直接影响并行流的性能。如果只有 2 个核心，使用 4 个线程的并行流可能不会带来太多的性能提升，甚至可能因线程调度开销而影响性能。如果有 16 核或更多的 CPU，数据量更大时并行流的效果会更加明显。</li><li><strong>内存和 I/O 操作</strong>：如果涉及到 I/O 操作（例如从数据库读取大量数据或进行网络请求），那么并行流的好处可能会受到系统 I/O 性能的限制。如果 CPU 处理时间是瓶颈，那么并行化会带来明显提升。</li></ul><p><strong>性能评估：</strong></p><ul><li>对于 <strong>小数据量</strong> 和 <strong>简单操作</strong>，例如几百条数据的简单映射或过滤，顺序流通常更高效，因为创建和调度线程的开销可能超过并行处理的优势。</li><li>对于 <strong>大数据量</strong> 或 <strong>复杂操作</strong>，如需要排序、大量计算或高复杂度的映射等，并行流能够有效利用多核 CPU 的并行处理能力，减少处理时间。</li></ul><p><strong>经验法则</strong></p><ul><li><strong>小数据量</strong>：几百到几千条数据，建议使用 <strong>顺序流</strong>（<code class="language-plaintext highlighter-rouge">stream()</code>）。</li><li><strong>中等数据量</strong>：几千到十几万条数据，使用 <strong>顺序流</strong> 和 <strong>并行流</strong> 性能相近，可以根据实际测试决定。</li><li><strong>大数据量</strong>：超过十万条数据，特别是当数据量远大于 CPU 核心数时，使用 <strong>并行流</strong>（<code class="language-plaintext highlighter-rouge">parallelStream()</code>）通常能获得更好的性能。</li></ul><p><strong>具体建议：</strong></p><ul><li><strong>实验</strong>：可以进行简单的性能测试，对比 <strong>顺序流</strong> 和 <strong>并行流</strong> 的执行时间，特别是在你的数据集和硬件环境下。对于小数据量，通常可以避免使用并行流。</li><li><strong>监控和调优</strong>：在实际应用中，监控处理过程中的资源使用情况，如 CPU、内存等，并根据需要调整。</li></ul><p>总结：</p><ul><li><strong>小数据量</strong>：通常指几百到几千条数据，顺序流更高效。</li><li><strong>大数据量</strong>：通常指超过十万条数据，并且需要进行计算、排序等操作时，使用并行流能带来显著性能提升。</li><li>数据量“多”还是“少”没有严格标准，主要是看操作的复杂性和系统的硬件资源。在处理小数据量时，避免使用 <code class="language-plaintext highlighter-rouge">parallelStream()</code> 会更高效。</li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" target="_blank">https://acteds.github.io/2024/12/03/%E5%B9%B6%E8%A1%8C%E6%B5%81%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1743685792', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
