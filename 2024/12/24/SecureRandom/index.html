<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>SecureRandom &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/12/24/SecureRandom/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="SecureRandom"><meta name="keywords" content="Java,IDEA"><meta name="og:keywords" content="Java,IDEA"><meta name="description" content="引言"><meta name="og:description" content="引言"><meta property="og:url" content="/2024/12/24/SecureRandom/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-12-24"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="SecureRandom"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">SecureRandom</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/12/24 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#IDEA" title="IDEA">IDEA</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 10046 字，约 29 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p><code class="language-plaintext highlighter-rouge">SecureRandom</code>随机数的坑，java8版本与java17版本的该类底层原理不同。</p><h1 id="securerandom">SecureRandom</h1><h2 id="问题复现">问题复现</h2><p>场景：需要对存入数据库的敏感数据进行非对称加密，对于不涉及加密数据的查询，无所谓随机数是否固定，但对于涉及加密数据的查询，就需要固定随机数了。因此有如下方法用来加密：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/**
     * SM2加密
     *
     * @param data      待加密数据
     * @return 加密后的数据
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">sm2Encrypt</span><span class="o">(</span> <span class="nc">String</span> <span class="n">data</span><span class="o">){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="nc">StringUtil</span><span class="o">.</span><span class="na">isNotNull</span><span class="o">(</span><span class="n">data</span><span class="o">)){</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">//使用固定随机数</span>
            <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
            <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
            <span class="nc">ECPublicKeyParameters</span> <span class="n">publicKeyParam</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ECPublicKeyParameters</span><span class="o">)</span> <span class="nc">PublicKeyFactory</span><span class="o">.</span><span class="na">createKey</span><span class="o">(</span><span class="n">getPublicKey</span><span class="o">().</span><span class="na">getEncoded</span><span class="o">());</span>
            <span class="nc">CipherParameters</span> <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParametersWithRandom</span><span class="o">(</span><span class="n">publicKeyParam</span><span class="o">,</span> <span class="n">random</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypt</span> <span class="o">=</span> <span class="n">iniSmUtil</span><span class="o">().</span><span class="na">encrypt</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(),</span><span class="n">parameters</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">base64String</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">encodeBase64String</span><span class="o">(</span><span class="n">encrypt</span><span class="o">);</span>
            <span class="c1">//转16进制后返回</span>
            <span class="k">return</span> <span class="nc">HexUtil</span><span class="o">.</span><span class="na">encodeHexStr</span><span class="o">(</span><span class="n">base64String</span><span class="o">,</span> <span class="nc">CharsetUtil</span><span class="o">.</span><span class="na">CHARSET_UTF_8</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"SM2数据加密异常:"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div><p>这里的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
<span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
</code></pre></div></div><p>就是固定随机数。测试在Java8中相同种子是否返回相同的随机数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用固定随机数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[-1765061395]</span>
</code></pre></div></div><p><strong>相同</strong>，在Java17中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span><span class="c1">//10000</span>
</code></pre></div></div><p><strong>不相同</strong>。实际上是<code class="language-plaintext highlighter-rouge">SecureRandom</code>的底层随机数算法发生了变化。</p><h2 id="基本用法">基本用法</h2><p><code class="language-plaintext highlighter-rouge">SecureRandom</code> 是一个提供加密强随机数生成器（RNG）的类，用于生成符合加密要求的随机数。</p><p><strong>加密强随机数</strong>：</p><ul><li>加密强随机数是指符合统计随机数生成器测试要求的随机数，满足 FIPS 140-2 和 RFC 4086 的要求，必须生成不可预测的输出。</li><li><code class="language-plaintext highlighter-rouge">SecureRandom</code> 必须生成非确定性输出，即每次生成的结果应该是随机且难以预测的。</li></ul><p><strong>伪随机数生成器（PRNG）与真随机数</strong>：</p><ul><li>大多数 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 的实现是基于伪随机数生成器（PRNG），即使用确定性的算法从随机种子生成伪随机数序列。</li><li>也有一些实现通过硬件或环境噪声等物理方式生成真随机数。</li><li>还有一些实现会结合这两种技术。</li></ul><p><strong>获取 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例</strong>：</p><p>可以通过无参构造函数或 <code class="language-plaintext highlighter-rouge">getInstance</code> 方法获取 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例，并指定具体的随机数生成算法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">r1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span> <span class="c1">// 默认</span>
<span class="nc">SecureRandom</span> <span class="n">r2</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNG"</span><span class="o">);</span> <span class="c1">// 使用特定算法</span>
<span class="nc">SecureRandom</span> <span class="n">r3</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DRBG"</span><span class="o">,</span> <span class="nc">DrbgParameters</span><span class="o">.</span><span class="na">instantiation</span><span class="o">(</span><span class="mi">128</span><span class="o">,</span> <span class="no">RESEED_ONLY</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span> <span class="c1">// 使用 DRBG 算法</span>
</code></pre></div></div><p><strong>生成随机字节</strong>：</p><p>常用的方法是通过 <code class="language-plaintext highlighter-rouge">nextBytes(byte[] bytes)</code> 生成随机字节数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">20</span><span class="o">];</span>
<span class="n">random</span><span class="o">.</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
</code></pre></div></div><p><strong>生成种子</strong>：</p><p><code class="language-plaintext highlighter-rouge">generateSeed</code> 方法可以用来生成一定数量的种子字节，通常用于给其他随机数生成器提供种子。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
</code></pre></div></div><p><strong>自我播种</strong>：</p><ul><li>新创建的 PRNG <code class="language-plaintext highlighter-rouge">SecureRandom</code> 对象不会自动播种，除非是通过 <code class="language-plaintext highlighter-rouge">SecureRandom(byte[])</code> 构造函数创建的。</li><li>如果没有显式调用 <code class="language-plaintext highlighter-rouge">setSeed</code>，第一次调用 <code class="language-plaintext highlighter-rouge">nextBytes</code> 时，它会自动从实现特定的熵源播种自己。</li></ul><p><strong>重播种</strong>：</p><ul><li>可以通过 <code class="language-plaintext highlighter-rouge">reseed</code> 或 <code class="language-plaintext highlighter-rouge">setSeed</code> 方法对 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 进行重播种。<code class="language-plaintext highlighter-rouge">reseed</code> 方法会从熵源读取输入进行重播种，而 <code class="language-plaintext highlighter-rouge">setSeed</code> 方法则需要显式提供种子。</li><li>需要注意的是，并非所有实现都支持 <code class="language-plaintext highlighter-rouge">reseed</code>。</li></ul><p><strong>支持的实现和线程安全性</strong>：</p><ul><li>一些 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实现可能会接受 <code class="language-plaintext highlighter-rouge">SecureRandomParameters</code> 参数来进一步控制方法行为。</li><li>根据实现的不同，<code class="language-plaintext highlighter-rouge">generateSeed</code>、<code class="language-plaintext highlighter-rouge">reseed</code> 和 <code class="language-plaintext highlighter-rouge">nextBytes</code> 方法可能会阻塞，尤其是当熵源是 <code class="language-plaintext highlighter-rouge">/dev/random</code>（在类 Unix 操作系统上）时。</li><li><code class="language-plaintext highlighter-rouge">SecureRandom</code> 对象是线程安全的，可以在多个并发线程中使用。</li></ul><p><strong>线程安全</strong>：</p><ul><li>如果 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 服务提供者支持线程安全，则会在服务提供者注册时设置“ThreadSafe”属性为“true”。</li><li>如果没有声明线程安全，<code class="language-plaintext highlighter-rouge">SecureRandom</code> 会通过同步来确保以下方法的线程安全：</li><li><code class="language-plaintext highlighter-rouge">engineSetSeed(byte[])</code></li><li><code class="language-plaintext highlighter-rouge">engineNextBytes(byte[])</code></li><li><code class="language-plaintext highlighter-rouge">engineGenerateSeed(int)</code></li><li><code class="language-plaintext highlighter-rouge">engineReseed(SecureRandomParameters)</code></li></ul><p><code class="language-plaintext highlighter-rouge">SecureRandom</code> 是 Java 提供的一个加密强度的随机数生成器，它可以生成适用于加密、密码学和其他安全应用的随机数。该类支持多种随机数生成算法，包括伪随机数生成算法和真随机数生成算法。用户可以通过不同的方式获取 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例，并生成随机字节或种子。<code class="language-plaintext highlighter-rouge">SecureRandom</code> 对象是线程安全的，可以在多线程环境中使用。</p><h2 id="数字生成算法">数字生成算法</h2><p>SecureRandom 有如下数字生成算法：<a href="https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#securerandom-number-generation-algorithms">Java Security Standard Algorithm Names</a></p><table><thead><tr><th>算法名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>NativePRNG</strong></td><td>从底层操作系统获取随机数。没有对生成这些数字的阻塞性质做出任何声明。</td></tr><tr><td><strong>NativePRNGBlocking</strong></td><td>从底层操作系统获取随机数，必要时会阻塞。例如，类 UNIX 系统中的 <code class="language-plaintext highlighter-rouge">/dev/random</code>。</td></tr><tr><td><strong>NativePRNGNonBlocking</strong></td><td>从底层操作系统获取随机数，不会阻塞，避免应用程序过度停顿。例如，类 UNIX 系统中的 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>。</td></tr><tr><td><strong>PKCS11</strong></td><td>从底层已安装并配置的 PKCS #11 库获取随机数。</td></tr><tr><td><strong>DRBG</strong></td><td>使用 NIST SP 800-90Ar1 中定义的 DRBG 机制的算法。</td></tr><tr><td><strong>SHA1PRNG</strong></td><td>使用 SUN 提供的伪随机数生成（PRNG）算法。该算法使用 SHA-1 作为 PRNG 的基础。通过对一个真实随机种子值和一个 64 位计数器进行 SHA-1 哈希计算，每次操作时计数器递增 1。 从 160 位的 SHA-1 输出中，仅使用 64 位。</td></tr><tr><td><strong>Windows-PRNG</strong></td><td>从底层 Windows 操作系统获取随机数。</td></tr></tbody></table><p>这些算法各自具有不同的实现方式和用途，可以根据安全需求和平台特性选择合适的算法。</p><p>通过 <code class="language-plaintext highlighter-rouge">new SecureRandom()</code> 创建的 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例使用的算法是 <strong>平台默认的伪随机数生成算法</strong>。该算法通常依赖于操作系统提供的随机数生成机制，但具体算法的选择会根据操作系统和 Java 实现的不同而有所变化。</p><p>常见的实现和算法：</p><ol><li><strong>Unix-like 操作系统（Linux、macOS等）</strong>：<ul><li><code class="language-plaintext highlighter-rouge">SecureRandom</code> 默认会使用基于 <code class="language-plaintext highlighter-rouge">/dev/urandom</code> 或 <code class="language-plaintext highlighter-rouge">/dev/random</code> 的随机数生成器。</li><li><code class="language-plaintext highlighter-rouge">/dev/urandom</code>：非阻塞的伪随机数生成器，它会不断使用系统熵池中的数据生成随机数。</li><li><code class="language-plaintext highlighter-rouge">/dev/random</code>：阻塞的伪随机数生成器，只有当系统熵池中的数据足够时才能生成随机数。</li></ul></li><li><p><strong>Windows 操作系统</strong>：<code class="language-plaintext highlighter-rouge">SecureRandom</code> 默认会使用 <strong>Windows-PRNG</strong>（基于 Windows 操作系统的随机数生成器）。</p></li><li><strong>其他平台</strong>：在一些平台上，<code class="language-plaintext highlighter-rouge">SecureRandom</code> 可能会使用类似 <strong>NativePRNG</strong> 的伪随机数生成算法。</li></ol><p>实现原理：</p><ul><li><strong>NativePRNG</strong>：一种伪随机数生成算法，通常会依赖于操作系统提供的底层熵源。在 Unix-like 系统中，它通过 <code class="language-plaintext highlighter-rouge">dev/urandom</code> 提供一个快速的、非阻塞的随机数生成方式。</li><li><strong>DRBG（Deterministic Random Bit Generator）</strong>：如果平台不提供足够的熵源，或者要求更强的加密性质，<code class="language-plaintext highlighter-rouge">SecureRandom</code> 会使用 DRBG 算法，它是一个基于确定性算法的伪随机数生成器。常用于满足更严格的安全需求。</li></ul><p>通过 <code class="language-plaintext highlighter-rouge">new SecureRandom()</code> 创建的 <code class="language-plaintext highlighter-rouge">SecureRandom</code> 实例使用的是平台默认的算法，它通常依赖于操作系统提供的熵源。在类 Unix 操作系统中，它通常基于 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>，而在 Windows 操作系统中，它会使用 Windows 提供的 <code class="language-plaintext highlighter-rouge">Windows-PRNG</code> 算法。具体使用哪种算法，可以通过 <code class="language-plaintext highlighter-rouge">SecureRandom.getInstance()</code> 方法显式指定。</p><p>下面是几个示例代码，展示了如何选择不同的随机数生成算法并输出其生成的随机数。</p><p><strong>使用 <code class="language-plaintext highlighter-rouge">NativePRNG</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 NativePRNG 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNG"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"NativePRNG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>输出的随机数将来自底层操作系统的随机数源，没有对阻塞性质做任何声明。不同操作系统的行为可能不同。</p><hr /><p><strong>使用 <code class="language-plaintext highlighter-rouge">NativePRNGBlocking</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 NativePRNGBlocking 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNGBlocking"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"NativePRNGBlocking Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>该算法会从底层操作系统的 <code class="language-plaintext highlighter-rouge">blocking</code> 随机数源获取随机数。在 Linux 系统上，通常会从 <code class="language-plaintext highlighter-rouge">/dev/random</code> 获取，可能会在系统缺少足够的熵时导致阻塞。</p><hr /><p><strong>使用 <code class="language-plaintext highlighter-rouge">NativePRNGNonBlocking</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 NativePRNGNonBlocking 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"NativePRNGNonBlocking"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"NativePRNGNonBlocking Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>该算法将从非阻塞的随机数源获取随机数，例如 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>，即使系统缺乏熵，也不会阻塞，能保证更快的响应时间。</p><hr /><p><strong>使用 <code class="language-plaintext highlighter-rouge">PKCS11</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 PKCS11 算法（需要配置并且支持 PKCS11 提供者）</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PKCS11"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PKCS11 Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>该算法将使用已安装的 PKCS#11 加密模块提供的随机数生成器。如果没有安装支持的硬件加密模块或配置正确的 PKCS#11 提供者，可能会抛出异常。</p><hr /><p><strong>使用 <code class="language-plaintext highlighter-rouge">DRBG</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.bouncycastle.crypto.prng.DrbgParameters</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 DRBG 算法</span>
       <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DRBG"</span><span class="o">,</span> <span class="nc">DrbgParameters</span><span class="o">.</span><span class="na">instantiation</span><span class="o">(</span><span class="mi">128</span><span class="o">,</span> <span class="nc">DrbgParameters</span><span class="o">.</span><span class="na">Capability</span><span class="o">.</span><span class="na">RESEED_ONLY</span><span class="o">,</span> <span class="kc">null</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"DRBG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>该算法使用 DRBG（Deterministic Random Bit Generator）机制，通常基于哈希函数或加密算法（例如 SHA-256）生成随机数。需要合适的参数进行初始化。此算法通常提供高安全性，并且能够生成高质量的随机数。</p><p><strong>“DRBG”</strong></p><p>这里指定了使用的算法为 <strong>DRBG</strong>（Deterministic Random Bit Generator）。它是基于特定标准（如 NIST SP 800-90A）定义的伪随机数生成算法。DRBG 主要通过一个确定性算法（通常是基于哈希函数或者加密算法）来生成伪随机数序列，并且可以通过一定的种子输入和系统熵来源进行初始化。</p><p><strong><code class="language-plaintext highlighter-rouge">DrbgParameters.instantiation(int securityStrength, DrbgParameters.Capability capability, byte[] personalizationString)</code></strong></p><p>(DRBG 参数实例化)这个方法用于指定 DRBG 的生成方式，通常包括以下三个重要参数：</p><p><strong><code class="language-plaintext highlighter-rouge">securityStrength</code></strong> (安全强度)</p><ul><li><code class="language-plaintext highlighter-rouge">securityStrength</code> 是 DRBG 算法的安全强度，以位为单位。例如，<code class="language-plaintext highlighter-rouge">128</code> 表示 DRBG 的输出应该具有 128 位的安全强度，通常是为了保证随机数生成的强度和质量。这意味着生成的随机数在算法层面上应该至少提供 128 位的安全保障。</li><li>一般来说，安全强度是基于预期的用途来选择的。如果你需要更高的安全性，可以选择更高的安全强度（比如 256 位）。例如：</li><li>128：适用于一般的加密操作和安全应用。</li><li>256：适用于高安全性的要求。</li></ul><p><strong><code class="language-plaintext highlighter-rouge">capability</code></strong> (能力)</p><p><strong><code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code></strong>:</p><ul><li>这个值表示所请求的 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例 <strong>同时支持预测抗性</strong> 和 <strong>重种子功能</strong>。</li><li><strong>预测抗性（Prediction Resistance）</strong>：确保通过某些途径预测随机数生成器的输出变得极其困难，增加安全性。对于加密应用，通常需要预测抗性来防止攻击者通过某些方式推测后续生成的随机数。</li><li><strong>重种子（Reseed）</strong>：DRBG 需要定期重新引入熵源（例如，新的随机输入），以保持生成的随机数的质量。重种子是为了避免长期使用同一种子产生的随机数序列趋向于可预测。</li></ul><p><strong><code class="language-plaintext highlighter-rouge">RESEED_ONLY</code></strong>:</p><ul><li>这个值表示所请求的 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例 <strong>仅支持重种子功能</strong>，而 <strong>不支持预测抗性</strong>。</li><li>这种能力适用于需要定期刷新或更新种子的场景，但不要求具备强大的抗预测性。在一些不那么敏感的应用中，可能只需要重种子来保证随机数的质量，而不一定要求具有预测抗性。</li></ul><p><strong><code class="language-plaintext highlighter-rouge">NONE</code></strong>:</p><ul><li>这个值表示所请求的 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例 <strong>既不支持预测抗性，也不支持重种子功能</strong>。</li><li>在某些情况下，可能仅需要生成一次性的随机数，而不需要进行任何后续的重种子或抗预测性保护。例如，一些简单的随机数生成应用可能不要求具有特别高的安全标准。</li></ul><p>不同的请求能力与可能的实际能力之间的关系：</p><ul><li>请求 <strong>NONE</strong> 能力时，实际返回的能力可能是 <code class="language-plaintext highlighter-rouge">NONE</code>、<code class="language-plaintext highlighter-rouge">RESEED_ONLY</code> 或 <code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>。</li><li>请求 <strong>RESEED_ONLY</strong> 时，实际返回的能力可能是 <code class="language-plaintext highlighter-rouge">RESEED_ONLY</code> 或 <code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>。</li><li>请求 <strong>PR_AND_RESEED</strong> 时，实际返回的能力一定是 <code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>。</li></ul><p>总结：</p><ul><li><code class="language-plaintext highlighter-rouge">PR_AND_RESEED</code>：支持重种子和预测抗性。</li><li><code class="language-plaintext highlighter-rouge">RESEED_ONLY</code>：仅支持重种子，不支持预测抗性。</li><li><code class="language-plaintext highlighter-rouge">NONE</code>：既不支持预测抗性，也不支持重种子。</li></ul><p>这种能力控制机制提供了灵活性，允许开发者根据实际安全需求选择最合适的 <code class="language-plaintext highlighter-rouge">DRBG</code> 配置。</p><p><strong><code class="language-plaintext highlighter-rouge">personalizationString</code></strong> (个性化字符串)</p><ul><li>这个参数用于初始化 DRBG 时的个性化字符串，通常是额外的输入数据，用于增强生成随机数的多样性和不可预测性。传入 <code class="language-plaintext highlighter-rouge">null</code> 表示没有使用个性化字符串。</li><li>个性化字符串有助于在特定上下文中初始化 DRBG，确保在不同场景中生成的随机数是不同的。</li><li>如果你希望在初始化时根据特定的上下文或环境（如设备ID、时间戳等）来生成不同的随机数种子，可以使用个性化字符串。</li></ul><p><strong>整体效果</strong></p><p>综合来看，这行代码通过 <code class="language-plaintext highlighter-rouge">DrbgParameters.instantiation(128, DrbgParameters.Capability.RESEED_ONLY, null)</code> 来创建一个 <code class="language-plaintext highlighter-rouge">DRBG</code> 实例，它有以下特点：</p><ul><li><strong>128 位安全强度</strong>，生成的随机数序列具有较高的安全性。</li><li><strong>RESEED_ONLY</strong> 能力，意味着该实例不直接生成随机数，而是在需要时执行重种子操作。</li><li><strong>没有个性化字符串</strong>，即 DRBG 使用的是默认的熵源，而不是特定上下文的数据。</li></ul><p>这种配置通常适用于需要安全随机数生成、定期重种子的场景，尤其是在要求较高安全性的加密应用中。</p><hr /><p><strong>使用 <code class="language-plaintext highlighter-rouge">SHA1PRNG</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 SHA1PRNG 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1PRNG"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"SHA1PRNG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>SHA1PRNG 是一个基于 SHA-1 哈希的伪随机数生成器。其生成的随机数会受到初始种子和计数器的影响，生成的随机数相对较为可预测，但对于大多数非安全应用场景是足够的。</p><hr /><p><strong>使用 <code class="language-plaintext highlighter-rouge">Windows-PRNG</code> 算法</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecureRandomExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 使用 Windows-PRNG 算法</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"Windows-PRNG"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Windows-PRNG Random Number: "</span> <span class="o">+</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>预期结果：</strong></p><p>该算法将从 Windows 操作系统的随机数源（例如通过 Windows Cryptographic API）生成随机数。</p><hr /><p>总结</p><ol><li><strong>NativePRNG</strong> 和 <strong>Windows-PRNG</strong> 会依赖操作系统的原生随机数生成机制，通常比较快，但可能不太适合高安全性需求。</li><li><strong>NativePRNGBlocking</strong> 会阻塞直到足够的随机数可用，适合用于高安全性的环境，但可能会延迟。</li><li><strong>NativePRNGNonBlocking</strong> 适用于不希望阻塞的环境，会优先使用 <code class="language-plaintext highlighter-rouge">/dev/urandom</code>。</li><li><strong>PKCS11</strong> 和 <strong>DRBG</strong> 提供硬件加速和更高的安全性，但依赖于相应的硬件和配置。</li><li><strong>SHA1PRNG</strong> 是基于 SHA-1 的伪随机数生成器，适用于一般用途，但不适合高安全性的要求。</li></ol><p>根据具体需求选择合适的算法。</p><h2 id="解决">解决</h2><p>在Java8中相同种子是否返回相同的随机数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用固定随机数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[-1765061395]</span>
</code></pre></div></div><p>在Java17中，指定<code class="language-plaintext highlighter-rouge">SHA1PRNG</code>随机数生成器：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//使用固定随机数</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1PRNG"</span><span class="o">);</span>
    <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[-1765061395]</span>
</code></pre></div></div><p>进一步测试：</p><p>java17：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1PRNG"</span><span class="o">);</span>
        <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[1171630791, -70273684, -1765061395, -786090109, 1560068868, 1762545591, 1861147253, -551574285, 1891309446, -1389656251]</span>
</code></pre></div></div><p>java8：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">SecureRandom</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
        <span class="n">random</span><span class="o">.</span><span class="na">setSeed</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
        <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">);</span><span class="c1">//[1171630791, -70273684, -1765061395, -786090109, 1560068868, 1762545591, 1861147253, -551574285, 1891309446, -1389656251]</span>
</code></pre></div></div><p>可以看出结果一致，实际上只要保证指定种子返回固定的随机数序列即可。</p><p>然后将之前的数据重新指定算法加密即可。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/12/24/SecureRandom/" target="_blank">https://acteds.github.io/2024/12/24/SecureRandom/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1743167898', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
