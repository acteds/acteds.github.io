<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>多线程 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="多线程"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="多线程"><meta name="og:description" content="多线程"><meta property="og:url" content="/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-04-16"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="多线程"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">多线程</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/04/16 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 22953 字，约 66 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="多线程">多线程</h1><p>代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。</p><p><strong>进程</strong></p><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p><p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><pre><code class="language-ascii">                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
</code></pre><p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p><p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p><p>多进程模式（每个进程只有一个线程）：</p><pre><code class="language-ascii">┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
</code></pre><p>多线程模式（一个进程有多个线程）：</p><pre><code class="language-ascii">┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
</code></pre><p>多进程＋多线程模式（复杂度最高）：</p><pre><code class="language-ascii">┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
</code></pre><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。具体采用哪种方式，要考虑到进程和线程的特点。</p><p>和多线程相比，多进程的缺点在于：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul><p>而多进程的优点在于：</p><p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><p><strong>多线程</strong></p><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code class="language-plaintext highlighter-rouge">main()</code>方法，在<code class="language-plaintext highlighter-rouge">main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p><p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p><p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p><p>Java多线程编程的特点又在于：</p><ul><li>多线程模型是Java程序最基本的并发模型；</li><li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li></ul><h2 id="创建新线程">创建新线程</h2><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code class="language-plaintext highlighter-rouge">main()</code>方法。在<code class="language-plaintext highlighter-rouge">main()</code>方法中，我们又可以启动其他线程。</p><p>要创建一个新线程非常容易，我们需要实例化一个<code class="language-plaintext highlighter-rouge">Thread</code>实例，然后调用它的<code class="language-plaintext highlighter-rouge">start()</code>方法。</p><p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p><p>方法一：从<code class="language-plaintext highlighter-rouge">Thread</code>派生一个自定义类，然后覆写<code class="language-plaintext highlighter-rouge">run()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"匿名子类"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">start()</code>方法会在内部自动调用实例的<code class="language-plaintext highlighter-rouge">run()</code>方法。</p><p>方法二：创建<code class="language-plaintext highlighter-rouge">Thread</code>实例时，传入一个<code class="language-plaintext highlighter-rouge">Runnable</code>实例，这种方法内部类会取不到当前Thread匿名类对象，可以通过<code class="language-plaintext highlighter-rouge">Thread.currentThread()</code>得到当前线程对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Runnable接口匿名类"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div><p>若外部<code class="language-plaintext highlighter-rouge">Thread</code>不是匿名的，则也可以在匿名内部类内通过<code class="language-plaintext highlighter-rouge">外部类名.this</code>来引用外部类的实例。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div><p>注意不能使用<code class="language-plaintext highlighter-rouge">t</code>，因为<code class="language-plaintext highlighter-rouge">t</code>现在还没有初始化（其实内部类代码运行的时候已经实例化了），但对编译器来说无法确定在这个时候<code class="language-plaintext highlighter-rouge">t</code>是否已经被正确初始化。因此，即使在实际运行时<code class="language-plaintext highlighter-rouge">t</code>已经被实例化了，编译器也会在编译时会认为<code class="language-plaintext highlighter-rouge">t</code>是一个未被初始化的变量，从而导致编译错误。</p><p>可以使用lambda简化：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Runnable接口匿名类"</span><span class="o">));</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
</code></pre></div></div><p>创建线程后的代码执行顺序：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法开始"</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程开始"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程结束"</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法结束"</span><span class="o">);</span>
</code></pre></div></div><p>只能肯定<code class="language-plaintext highlighter-rouge">main</code>线程先打印<code class="language-plaintext highlighter-rouge">main方法开始</code>，然后创建并启动了新线程，然后再打印。而新线程会在启动后与<code class="language-plaintext highlighter-rouge">main</code>线程并发运行，因此对于新线程启用后的打印语句顺序是<strong>不可预知</strong>的，调度由操作系统控制，<strong>程序本身无法确定线程的调度顺序</strong>。</p><p>要模拟并发执行的效果，可以在线程中调用<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>，强迫<strong>当前线程</strong>暂停一段时间：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法开始"</span><span class="o">);</span>
    <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程开始"</span><span class="o">);</span>
        <span class="n">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程结束"</span><span class="o">);</span>
    <span class="o">});</span>
    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
    <span class="n">sleep</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法结束"</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">){</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">millis</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>要特别注意：直接调用<code class="language-plaintext highlighter-rouge">Thread</code>实例的<code class="language-plaintext highlighter-rouge">run()</code>方法是无效的。直接调用<code class="language-plaintext highlighter-rouge">run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。</p><p><strong>必须</strong>调用<code class="language-plaintext highlighter-rouge">Thread</code>实例的<code class="language-plaintext highlighter-rouge">start()</code>方法才能<strong>启动新线程</strong>，如果查看<code class="language-plaintext highlighter-rouge">Thread</code>类的源代码，会看到<code class="language-plaintext highlighter-rouge">start()</code>方法内部调用了一个<code class="language-plaintext highlighter-rouge">private native void start0()</code>方法，<code class="language-plaintext highlighter-rouge">native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p><p>可以通过<code class="language-plaintext highlighter-rouge">setPriority(int n)</code>对线程设定优先级，n的值范围是1~10, 默认值为5。</p><p>JVM自动把1（低）~10（高）的优先级映射到操作系统实际优先级上（不同操作系统有不同的优先级数量）。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但决<strong>不能</strong>通过设置优先级来<strong>确保</strong>高优先级的线程<strong>一定会先执行</strong>。</p><h2 id="线程的状态">线程的状态</h2><p>在Java程序中，一个线程对象只能调用一次<code class="language-plaintext highlighter-rouge">start()</code>方法启动新线程，并在新线程中执行<code class="language-plaintext highlighter-rouge">run()</code>方法。一旦<code class="language-plaintext highlighter-rouge">run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在<strong>执行</strong><code class="language-plaintext highlighter-rouge">run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被<strong>阻塞</strong>而挂起；</li><li>Waiting：运行中的线程，因为某些操作在<strong>等待</strong>中；</li><li>Timed Waiting：运行中的线程，因为执行<code class="language-plaintext highlighter-rouge">sleep()</code>方法正在计时<strong>等待</strong>；</li><li>Terminated：线程已<strong>终止</strong>，因为<code class="language-plaintext highlighter-rouge">run()</code>方法执行完毕。</li></ul><p>用一个状态转移图表示如下：</p><pre><code class="language-ascii">         ┌─────────────┐
         │     New     │
         └─────────────┘
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
</code></pre><p>当线程启动后，它可以在<code class="language-plaintext highlighter-rouge">Runnable</code>、<code class="language-plaintext highlighter-rouge">Blocked</code>、<code class="language-plaintext highlighter-rouge">Waiting</code>和<code class="language-plaintext highlighter-rouge">Timed Waiting</code>这几个状态之间切换，直到最后变成<code class="language-plaintext highlighter-rouge">Terminated</code>状态，线程终止。</p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code class="language-plaintext highlighter-rouge">run()</code>方法执行到<code class="language-plaintext highlighter-rouge">return</code>语句返回；</li><li>线程意外终止：<code class="language-plaintext highlighter-rouge">run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code class="language-plaintext highlighter-rouge">Thread</code>实例调用<code class="language-plaintext highlighter-rouge">stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。</p><p>例如，<code class="language-plaintext highlighter-rouge">main</code>线程在启动<code class="language-plaintext highlighter-rouge">t</code>线程后，可以通过<code class="language-plaintext highlighter-rouge">t.join()</code>等待<code class="language-plaintext highlighter-rouge">t</code>线程结束后再继续运行：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法开始"</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程开始"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程结束"</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
<span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">//等待t线程结束</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"main方法结束"</span><span class="o">);</span>
</code></pre></div></div><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main方法开始
线程开始
线程结束
main方法结束
</code></pre></div></div><p>如果<code class="language-plaintext highlighter-rouge">t</code>线程已经结束，对实例<code class="language-plaintext highlighter-rouge">t</code>调用<code class="language-plaintext highlighter-rouge">join()</code>会立刻返回。此外，<code class="language-plaintext highlighter-rouge">join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p><p>在 Java 中，多线程中的阻塞状态和等待状态是两种不同的状态，它们之间有一些区别：</p><ol><li>阻塞状态（Blocked）：<ul><li>当线程在获取锁时被其他线程所占用，导致无法继续执行时，线程会进入阻塞状态。</li><li>线程进入阻塞状态是因为正在等待某个条件的发生，一旦条件满足，线程将会被唤醒并切换到就绪状态。</li><li>在阻塞状态下的线程<strong>仍然持有锁</strong>，只是无法继续执行而已。</li></ul></li><li>等待状态（Waiting）：<ul><li>当线程调用 <code class="language-plaintext highlighter-rouge">Object.wait()</code>、<code class="language-plaintext highlighter-rouge">Thread.join()</code> 或 <code class="language-plaintext highlighter-rouge">LockSupport.park()</code> 等方法进入等待状态时，线程会进入等待状态。</li><li>等待状态下的线程会<strong>释放持有的锁</strong>，等待其他线程调用 <code class="language-plaintext highlighter-rouge">notify()</code>、<code class="language-plaintext highlighter-rouge">notifyAll()</code> 或被中断时才能被唤醒。</li><li>等待状态通常用于线程间的协调和通信，等待特定条件满足后再继续执行。</li></ul></li></ol><p>总的来说，阻塞状态是因为线程被其他原因无法继续执行所产生的状态，而等待状态则是线程主动等待某些条件满足才能继续执行的状态。在编写多线程程序时，理解和正确处理线程的阻塞和等待状态是非常重要的。</p><p><strong>注意：<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>不会释放持有的锁。</strong></p><p>Timed Waiting（计时等待）和Waiting（等待）是两种不同的线程状态。</p><ul><li>Timed Waiting（计时等待）是指线程在等待一段时间后自动恢复，例如通过调用<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>或者等待一个锁的过程中调用了<code class="language-plaintext highlighter-rouge">Object.wait(long timeout)</code>方法。在这种状态下，线程是<strong>持有锁</strong>的。</li><li>Waiting（等待）是指线程在等待某个条件满足后被唤醒，例如通过调用<code class="language-plaintext highlighter-rouge">Object.wait()</code>方法或者等待一个锁的过程中调用了<code class="language-plaintext highlighter-rouge">Object.wait()</code>方法。在这种状态下，线程是<strong>释放了持有的锁</strong>的。</li></ul><p>这两种状态的区别在于是否指定了等待的时间。Timed Waiting是有一个固定的等待时间，而Waiting是等待某个条件的发生，时间不确定。</p><h2 id="中断线程">中断线程</h2><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是<strong>其他线程</strong>给该线程发一个信号，该线程收到信号后结束执行<code class="language-plaintext highlighter-rouge">run()</code>方法，使得自身线程能<strong>立刻结束运行</strong>。</p><p>假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code class="language-plaintext highlighter-rouge">interrupt()</code>方法，目标线程<strong>需要反复检测自身状态</strong>是否是interrupted状态，如果是，就立刻结束运行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">isInterrupted</span><span class="o">()){</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                <span class="n">n</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"线程被中断，结束执行"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"中断了，n="</span><span class="o">+</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"开始"</span><span class="o">);</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
<span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
</code></pre></div></div><p>这段代码大概率会一直运行，且<code class="language-plaintext highlighter-rouge">!isInterrupted()</code>并不会起到中断作用，虽然调用<code class="language-plaintext highlighter-rouge">t.interrupt();</code>时，会改变<code class="language-plaintext highlighter-rouge">interrupted</code>的状态，使得<code class="language-plaintext highlighter-rouge">!isInterrupted()</code>为假。</p><p>但主线程请求<code class="language-plaintext highlighter-rouge">t</code>线程中断时，<code class="language-plaintext highlighter-rouge">t</code>线程<strong>大概率</strong>是在运行<code class="language-plaintext highlighter-rouge">sleep(10)</code>，此时线程处在休眠状态，而<code class="language-plaintext highlighter-rouge">sleep(10)</code>在休眠过程中会检测线程是否出现中断请求，如果检测到了了，则会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>异常，并<strong>清除线程的中断状态</strong>，因此<code class="language-plaintext highlighter-rouge">while</code>循环不会结束。</p><p>也有极小概率会正常终止，当主线程请求<code class="language-plaintext highlighter-rouge">t</code>线程中断时，如果<code class="language-plaintext highlighter-rouge">t</code>线程正运行在<code class="language-plaintext highlighter-rouge">n++;</code>则会在下次循环通过<code class="language-plaintext highlighter-rouge">!isInterrupted()</code>为假后结束运行。</p><p>要让之前的代码正常退出，只需要在<code class="language-plaintext highlighter-rouge">catch</code>块中添加<code class="language-plaintext highlighter-rouge">break;</code>。结果如下：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>开始
线程被中断，结束执行
中断了，n=9
结束
</code></pre></div></div><hr /><p>在Java中，调用<code class="language-plaintext highlighter-rouge">interrupt()</code>方法<strong>只是向目标线程发出中断请求</strong>，目标线程可以<strong>选择</strong>是否<strong>响应</strong>这个请求。目标线程可以通过<strong>检查中断状态</strong>并<strong>采取</strong>适当的<strong>措施</strong>来响应中断请求，也可以选择<strong>忽略</strong>中断请求继续执行。</p><p>在处理<code class="language-plaintext highlighter-rouge">InterruptedException</code>时，也可以选择继续等待，或处理中断请求提前结束线程的执行，具体取决于应用程序的需求。</p><p><code class="language-plaintext highlighter-rouge">InterruptedException</code>通常在以下情况下抛出：</p><ol><li><p>当一个线程处于睡眠状态（通过调用<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>进入睡眠状态）时，另一个线程调用了该线程的<code class="language-plaintext highlighter-rouge">interrupt()</code>方法，这会导致处于睡眠状态的线程抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>，并且<strong>清除该线程的中断状态</strong>。</p></li><li><p>如果一个线程在调用<code class="language-plaintext highlighter-rouge">Object.wait()</code>、<code class="language-plaintext highlighter-rouge">Thread.join()</code>、<code class="language-plaintext highlighter-rouge">Thread.sleep()</code>时被中断，则会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>，并且<strong>清除该线程的中断状态</strong>。这样线程在等待某些条件时，如果被中断就会提早终止。</p></li></ol><p>也就是说：当线程处于等待、睡眠状态或以其他方式被占用时，或者线程在活动之前或期间出现中断时会抛出<code class="language-plaintext highlighter-rouge">InterruptedException</code>。</p><p>还可以通过<code class="language-plaintext highlighter-rouge">Thread.currentThread.interrupt()</code>方法来<strong>重新设置当前线程的中断状态</strong>。这种方式可以在捕获<code class="language-plaintext highlighter-rouge">InterruptedException</code>异常后，手动设置线程的中断状态为<code class="language-plaintext highlighter-rouge">true</code>，以便在后续的循环条件中能够正确地退出循环。</p><p><strong>实际上<code class="language-plaintext highlighter-rouge">interrupt()</code>是这么说的</strong>：</p><p><code class="language-plaintext highlighter-rouge">interrupt()</code> 方法用于中断线程。除非当前线程是在中断自己，这种情况总是被允许的，否则会调用此线程的 <code class="language-plaintext highlighter-rouge">checkAccess</code> 方法，可能会导致抛出 <code class="language-plaintext highlighter-rouge">SecurityException</code>。</p><p>如果线程被阻塞在 <code class="language-plaintext highlighter-rouge">Object</code> 类的 <code class="language-plaintext highlighter-rouge">wait()</code>、<code class="language-plaintext highlighter-rouge">wait(long)</code>、<code class="language-plaintext highlighter-rouge">wait(long, int)</code> 方法，或者 <code class="language-plaintext highlighter-rouge">Thread</code> 类的 <code class="language-plaintext highlighter-rouge">join()</code>、<code class="language-plaintext highlighter-rouge">join(long)</code>、<code class="language-plaintext highlighter-rouge">join(long, int)</code>、<code class="language-plaintext highlighter-rouge">sleep(long)</code>、<code class="language-plaintext highlighter-rouge">sleep(long, int)</code> 方法中，那么它的<strong>中断状态将被清除</strong>，并且会收到一个 <code class="language-plaintext highlighter-rouge">InterruptedException</code>。</p><p>如果线程被阻塞在一个 <code class="language-plaintext highlighter-rouge">InterruptibleChannel</code> 的 I/O 操作上，那么该通道将被关闭，线程的<strong>中断状态将被设置</strong>，并且线程将收到一个 <code class="language-plaintext highlighter-rouge">java.nio.channels.ClosedByInterruptException</code>。</p><p>如果线程被阻塞在一个 <code class="language-plaintext highlighter-rouge">Selector</code> 上，那么线程的<strong>中断状态将被设置</strong>，并且它将立即从选择操作中返回，可能返回一个非零值，就像调用了选择器的 <code class="language-plaintext highlighter-rouge">wakeup</code> 方法一样。</p><p>如果以上情况<strong>都不适用</strong>，那么线程的<strong>中断状态将被设置</strong>。</p><p>对一个非存活的线程进行中断操作可能没有任何效果。</p><p>此外，文档还指出，在 JDK 参考实现中，对于一个非存活的线程进行中断操作仍然<strong>会记录中断请求</strong>，并通过 <code class="language-plaintext highlighter-rouge">interrupted()</code> 和 <code class="language-plaintext highlighter-rouge">isInterrupted()</code> 方法报告它。</p><hr /><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>  <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="c1">//判断中断状态</span>
                <span class="k">while</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">n</span><span class="o">++;</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：休眠时检测到中断请求"</span><span class="o">);</span>
                        <span class="k">try</span> <span class="o">{</span><span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span><span class="c1">//收拾东西</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：走了！"</span><span class="o">);</span>
                        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">_</span><span class="o">)</span> <span class="o">{</span>
                            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：别催了，马上走！"</span><span class="o">);</span>
                        <span class="o">}</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：运行时检测到中断请求"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t2：走了！"</span><span class="o">);</span>
            <span class="o">});</span>
            <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span><span class="c1">// 启动新线程t2</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span> <span class="c1">// 等待t2线程结束</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：Main通知关门了!"</span><span class="o">);</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：t2，关门了，快走！"</span><span class="o">);</span>
                <span class="n">t2</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span><span class="c1">// 通知t2，中断请求</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等待t2线程结束</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：又被Main通知关门了!t2怎么还不走？"</span><span class="o">);</span>
                    <span class="c1">//t2.join();</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"t1：算了我不等了，我先走了"</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程t1</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main：t1，关门了，快走！"</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span><span class="c1">// 通知t1，中断请求</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">// 等1ms</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main：t1，快点！"</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span><span class="c1">// 再次通知t1，中断请求</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等待t1，中断完成</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main：已确认t1走了"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 hello!
2 hello!
3 hello!
4 hello!
5 hello!
6 hello!
7 hello!
8 hello!
9 hello!
10 hello!
Main：t1，关门了，快走！
t1：Main通知关门了!
t1：t2，关门了，快走！
t2：休眠时检测到中断请求
Main：t1，快点！
t1：又被Main通知关门了!t2怎么还不走？
t1：算了我不等了，我先走了
Main：已确认t1走了
t2：走了！
</code></pre></div></div><p>假设代码执行没有消耗时间，<code class="language-plaintext highlighter-rouge">XXXXms</code>表示程序运行后的时间。</p><p>0~1000ms：<code class="language-plaintext highlighter-rouge">t2</code>持续输出。</p><p>1000ms：<code class="language-plaintext highlighter-rouge">main</code>线程通过调用<code class="language-plaintext highlighter-rouge">t1.interrupt()</code>从而通知<code class="language-plaintext highlighter-rouge">t1</code>线程中断，并等待<code class="language-plaintext highlighter-rouge">t1</code>。</p><p>1000ms：而此时<code class="language-plaintext highlighter-rouge">t1</code>线程正在等待<code class="language-plaintext highlighter-rouge">t2</code>线程，收到中断请求后抛出异常，捕获异常后<code class="language-plaintext highlighter-rouge">t1</code>也对<code class="language-plaintext highlighter-rouge">t2</code>发出中断请求，并等待<code class="language-plaintext highlighter-rouge">t2</code>。</p><p>1000ms：<code class="language-plaintext highlighter-rouge">t2</code>大概率在休眠时收到中断请求，然后抛出异常，磨蹭10ms后才真正走人。</p><p>1000ms：而<code class="language-plaintext highlighter-rouge">main</code>线程在第一次请求<code class="language-plaintext highlighter-rouge">t1</code>中断后，间隔1ms，再次催促<code class="language-plaintext highlighter-rouge">t1</code>中断请求。</p><p>1001ms：而此时<code class="language-plaintext highlighter-rouge">t1</code>线程还在等待<code class="language-plaintext highlighter-rouge">t2</code>线程，收到中断请求后，不再等待<code class="language-plaintext highlighter-rouge">t2</code>，也没有继续通知<code class="language-plaintext highlighter-rouge">t2</code>,直接结束了运行。</p><p>1001ms：<code class="language-plaintext highlighter-rouge">main</code>线程已经得到<code class="language-plaintext highlighter-rouge">t1</code>线程执行完毕，结束了执行。</p><p>1010ms：<code class="language-plaintext highlighter-rouge">t2</code>磨蹭10ms后才真正走人。</p><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code class="language-plaintext highlighter-rouge">running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code class="language-plaintext highlighter-rouge">HelloThread.running</code>置为<code class="language-plaintext highlighter-rouge">false</code>，就可以让线程结束。其实和<code class="language-plaintext highlighter-rouge">interrupt()</code>方法是一样的，只是<code class="language-plaintext highlighter-rouge">interrupted</code>字段也会被其他方法检测到状态，比如<code class="language-plaintext highlighter-rouge">join()</code>、<code class="language-plaintext highlighter-rouge">sleep()</code>。如果使用自定义的标志位表示中断线程，则其他方法不会响应。</p><p>错误写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
    <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">running</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span> <span class="o">++;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程t1</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">t1</span><span class="o">.</span><span class="na">running</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span><span class="c1">// 通知t1，中断请求</span>
<span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等</span>
</code></pre></div></div><p>因为向上转型的原因，<code class="language-plaintext highlighter-rouge">Thread</code>不存在<code class="language-plaintext highlighter-rouge">running</code>这个字段，好的，我转回去可以吗，也不行，因为是匿名类。把<code class="language-plaintext highlighter-rouge">Thread</code>改成<code class="language-plaintext highlighter-rouge">var</code>倒是可以，<code class="language-plaintext highlighter-rouge">var t1 = new Thread(){...}</code>，不过不建议。</p><p>同样的，如果是实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口传入<code class="language-plaintext highlighter-rouge">Thread</code>构造方法，<code class="language-plaintext highlighter-rouge">Thread</code>当然不知道你定义了<code class="language-plaintext highlighter-rouge">running</code>这个字段，因为<code class="language-plaintext highlighter-rouge">Runnable</code>接口只规定了你有<code class="language-plaintext highlighter-rouge">run()</code>方法。因此只能写正常继承的类了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>  <span class="o">{</span>
        <span class="no">T1</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T1</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 启动新线程t1</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">running</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span><span class="c1">// 通知t1，中断请求</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span><span class="c1">// 等</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">T1</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">running</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">running</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">n</span> <span class="o">++;</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="s">" hello!"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"end!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 hello!
end!
</code></pre></div></div><h2 id="volatile">volatile</h2><p>注意到<code class="language-plaintext highlighter-rouge">T1</code>的标志位<code class="language-plaintext highlighter-rouge">boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code class="language-plaintext highlighter-rouge">volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>为什么要对线程间共享的变量用关键字<code class="language-plaintext highlighter-rouge">volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，<strong>当线程访问变量时</strong>，它会先获取一个副本，并保存在自己的工作内存中。如果<strong>线程修改了变量的值</strong>，虚拟机会在<strong>某个时刻</strong>把修改后的值回写到主内存，但是，这个时间是<strong>不确定</strong>的！</p><pre><code class="language-ascii">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
</code></pre><p>这会导致如果一个线程更新了某个变量，另一个线程读取的值<strong>可能</strong>还是<strong>更新前</strong>的。例如，主内存的变量<code class="language-plaintext highlighter-rouge">a = true</code>，线程1对主线程的<code class="language-plaintext highlighter-rouge">a</code>执行<code class="language-plaintext highlighter-rouge">a = false</code>时，它在此刻仅仅是把变量<code class="language-plaintext highlighter-rouge">a</code>的副本变成了<code class="language-plaintext highlighter-rouge">false</code>，主内存的变量<code class="language-plaintext highlighter-rouge">a</code>还是<code class="language-plaintext highlighter-rouge">true</code>，在JVM把修改后的<code class="language-plaintext highlighter-rouge">a</code>回写到主内存之前，其他线程读取到的<code class="language-plaintext highlighter-rouge">a</code>的值仍然是<code class="language-plaintext highlighter-rouge">true</code>，这就造成了多线程之间共享的变量不一致。</p><p>因此，<code class="language-plaintext highlighter-rouge">volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的<strong>最新值</strong>；</li><li>每次修改变量后，<strong>立刻回写</strong>到主内存。</li></ul><p><code class="language-plaintext highlighter-rouge">volatile</code>关键字解决的是可见性问题：当一个<strong>线程</strong>修改了某个<strong>共享变量</strong>的值，其他线程能够<strong>立刻看到</strong>修改后的值。</p><p>如果我们去掉<code class="language-plaintext highlighter-rouge">volatile</code>关键字，运行上述程序，发现效果和带<code class="language-plaintext highlighter-rouge">volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><p><strong>ABA问题</strong></p><p><code class="language-plaintext highlighter-rouge">volatile</code>关键字可能会导致ABA问题，但不使用<code class="language-plaintext highlighter-rouge">volatile</code>关键字更容易导致ABA问题。</p><p>ABA问题是指在多线程环境下，一个值从A变成了B，然后又变回A，在这个过程中可能会引发一些意料之外的问题。</p><p>使用<code class="language-plaintext highlighter-rouge">volatile</code>关键字修饰的变量可以确保多个线程能够正确地读取和修改该变量，但是它并不能解决ABA问题。例如，线程1读取一个<code class="language-plaintext highlighter-rouge">volatile</code>变量的值为A，然后线程2将其修改为B，最后线程2又将其修改回A，这个过程中线程1可能并不知道变量的值曾经变成过B，因为<code class="language-plaintext highlighter-rouge">volatile</code>只保证了可见性，并没有解决ABA问题。</p><p>要解决ABA问题，可以使用<code class="language-plaintext highlighter-rouge">AtomicStampedReference</code>类或<code class="language-plaintext highlighter-rouge">AtomicMarkableReference</code>类，它们可以在引用的同时记录一个标记（stamp或mark），当引用发生变化时，标记也会相应地发生变化，从而避免了ABA问题。</p><h2 id="守护线程">守护线程</h2><p>Java程序入口就是由JVM启动<code class="language-plaintext highlighter-rouge">main</code>线程，<code class="language-plaintext highlighter-rouge">main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p><p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">LocalTime</span><span class="o">.</span><span class="na">now</span><span class="o">());</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>如果这个线程不结束，JVM进程就无法结束。<strong>这类线程</strong>经常没有负责人来负责结束它们。但是，当<strong>其他线程</strong>结束时，JVM进程又必须要结束。而使用使用守护线程（Daemon Thread）是一个好办法。守护线程是指为其他线程服务的线程。在JVM中，所有<strong>非守护线程</strong>都执行完毕后，无论有没有守护线程，虚拟机<strong>都会</strong>自动退出。在调用<code class="language-plaintext highlighter-rouge">start()</code>方法前，调用<code class="language-plaintext highlighter-rouge">setDaemon(true)</code>就能把该线程标记为守护线程，然后JVM就会无视它了。</p><p>在守护线程中，编写代码要注意：守护线程<strong>不能持有</strong>任何需要关闭的资源，例如打开文件等，因为<strong>虚拟机退出</strong>时，可不管你守护线程在干什么，就像在任务管理器结束进程，可不需要进程同意结束进程，守护线程<strong>没有任何机会来关闭文件</strong>，这会导致数据丢失。</p><p>所有非守护线程都结束时，JVM会立即杀死所有守护线程并退出。这是因为守护线程被认为是为其他线程提供服务的线程，当所有的非守护线程结束时，守护线程也就没有存在的必要了，因此JVM会终止这些守护线程，然后退出。</p><p>父子线程只是谁创建了谁的关系，并没有先后或从属之分，只要创建并运行后，这个所谓的子线程其实和父线程是相互独立的。</p><p>如果想要实现父线程结束时，子线程也结束的效果，可以在子线程中判断父线程是否存活。 <code class="language-plaintext highlighter-rouge">while (fatherThread.isAlive())</code>，示例代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Thread</span> <span class="n">fatherThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span> <span class="c1">// 获取当前线程，即对于t的父线程</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">fatherThread</span><span class="o">.</span><span class="na">isAlive</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main还活着"</span> <span class="o">+</span> <span class="n">n</span><span class="o">++);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Main已关闭了"</span><span class="o">);</span>
<span class="o">});</span>
<span class="n">t</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span><span class="c1">//设置守护线程，JVM无视其运行状态</span>
<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已关闭"</span><span class="o">);</span>
</code></pre></div></div><p>守护进程会在父线程结束后结束。</p><p>可以通过<code class="language-plaintext highlighter-rouge">System.exit(0);</code>显示的控制JVM关闭。如果在最后一行调用<code class="language-plaintext highlighter-rouge">System.exit(0);</code>，<code class="language-plaintext highlighter-rouge">t</code>线程就算不是守护线程JVM也会立即终止。</p><h2 id="线程同步">线程同步</h2><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在<strong>任何指令处被操作系统暂停</strong>，然后在某个时间段后继续执行。</p><p>这个时候，有个单线程模型下不存在的问题就来了：如果<strong>多个线程同时读写共享变量</strong>，会出现<strong>数据不一致</strong>的问题。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上面的代码很简单，两个线程同时对一个<code class="language-plaintext highlighter-rouge">int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p><p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p><p>对于语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</code></pre></div></div><p>看上去是一行语句，实际上对应了3条指令：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ILOAD</span>
<span class="no">IADD</span>
<span class="no">ISTORE</span>
</code></pre></div></div><p>假设<code class="language-plaintext highlighter-rouge">n</code>的值是<code class="language-plaintext highlighter-rouge">100</code>，如果两个线程同时执行<code class="language-plaintext highlighter-rouge">n = n + 1</code>，得到的结果很可能不是<code class="language-plaintext highlighter-rouge">102</code>，而是<code class="language-plaintext highlighter-rouge">101</code>，原因在于：</p><pre><code class="language-ascii">┌───────┐    ┌───────┐
│Thread1│    │Thread2│
└───┬───┘    └───┬───┘
    │            │
    │ILOAD (100) │
    │            │ILOAD (100)
    │            │IADD
    │            │ISTORE (101)
    │IADD        │
    │ISTORE (101)│
    ▼            ▼
</code></pre><p>如果线程1在执行<code class="language-plaintext highlighter-rouge">ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code class="language-plaintext highlighter-rouge">ILOAD</code>后获取的值仍然是<code class="language-plaintext highlighter-rouge">100</code>，最终结果被两个线程的<code class="language-plaintext highlighter-rouge">ISTORE</code>写入后变成了<code class="language-plaintext highlighter-rouge">101</code>，而不是期待的<code class="language-plaintext highlighter-rouge">102</code>。</p><p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证<strong>一组指令</strong>以<strong>原子</strong>方式执行：即某一个线程执行时，其他线程必须等待：</p><pre><code class="language-ascii">┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
</code></pre><p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为<strong>临界区</strong>（Critical Section），任何时候临界区最多只有一个线程能执行。</p><h3 id="synchronized">synchronized</h3><p>保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字对一个对象进行加锁，<code class="language-plaintext highlighter-rouge">synchronized</code>保证了<strong>代码块</strong>在任意时刻最多只有一个线程能执行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>修改后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">add</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">dec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nc">Main</span><span class="o">.</span><span class="na">count</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">add</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">add</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">dec</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">count</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>注意到代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">synchronized</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">lock</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 获取锁</span>
    <span class="o">...</span>
<span class="o">}</span> <span class="c1">// 释放锁</span>
</code></pre></div></div><p>它表示用<code class="language-plaintext highlighter-rouge">Main.lock</code>实例作为锁，两个线程在执行各自的<code class="language-plaintext highlighter-rouge">synchronized(Main.lock) { ... }</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code class="language-plaintext highlighter-rouge">synchronized</code>语句块结束会自动释放锁。这样一来，对<code class="language-plaintext highlighter-rouge">Main.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p><hr /><p>使用<code class="language-plaintext highlighter-rouge">synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了<strong>性能下降</strong>。因为<code class="language-plaintext highlighter-rouge">synchronized</code>代码块无法并发执行，且加锁和解锁需要消耗一定的时间，所以，<code class="language-plaintext highlighter-rouge">synchronized</code>会降低程序的执行效率。</p><p>如何使用<code class="language-plaintext highlighter-rouge">synchronized</code>：</p><ol><li>找出<strong>修改共享变量的线程代码块</strong>；</li><li>选择一个<strong>共享实例</strong>作为锁；</li><li>使用<code class="language-plaintext highlighter-rouge">synchronized(lockObject) { ... }</code>。</li></ol><p>在使用<code class="language-plaintext highlighter-rouge">synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code class="language-plaintext highlighter-rouge">synchronized</code>结束处正确释放锁。</p><hr /><p><strong>不需要锁的原子操作，JVM规范定义了几种原子操作</strong>：</p><ul><li>基本类型（<code class="language-plaintext highlighter-rouge">long</code>和<code class="language-plaintext highlighter-rouge">double</code><strong>除外</strong>）<strong>赋值</strong>，例如：<code class="language-plaintext highlighter-rouge">int n = m</code>；</li><li>引用类型<strong>赋值</strong>，例如：<code class="language-plaintext highlighter-rouge">List&lt;String&gt; list = anotherList</code>。</li></ul><p><code class="language-plaintext highlighter-rouge">long</code>和<code class="language-plaintext highlighter-rouge">double</code>是64位数据，JVM<strong>没有明确规定</strong>64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code class="language-plaintext highlighter-rouge">long</code>和<code class="language-plaintext highlighter-rouge">double</code>的赋值作为原子操作实现的。</p><p>单条原子操作不需要锁，如果是多条原子操作，则需要锁。多线程连续读写多个变量时，同步的目的是为了<strong>保证程序逻辑正确</strong>。</p><p>不但写需要同步，读也需要同步：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>假定当前坐标是<code class="language-plaintext highlighter-rouge">(100, 200)</code>，那么当设置新坐标为<code class="language-plaintext highlighter-rouge">(110, 220)</code>时，上述未同步的多线程<code class="language-plaintext highlighter-rouge">get()</code><strong>读到</strong>的值可能有：</p><ul><li>(100, 200)：x，y更新前；</li><li>(110, 200)：x更新后，y更新前；</li><li>(110, 220)：x，y更新后。</li></ul><p>如果读取到<code class="language-plaintext highlighter-rouge">(110, 200)</code>，即读到了更新后的x，更新前的y，那么可能会造成程序的逻辑错误，无法保证读取的多个变量状态保持一致。</p><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">this.ps = ps;</code>是原子操作。而<code class="language-plaintext highlighter-rouge">int[] ps = new int[] { x, y };</code>不是，不过没有关系，因为<code class="language-plaintext highlighter-rouge">x</code>与<code class="language-plaintext highlighter-rouge">y</code>不是共享变量，它们的值只在当前线程中可见，所以在这种情况下，不需要担心原子性问题。重要的是<code class="language-plaintext highlighter-rouge">ps</code>，原子操作保证了<code class="language-plaintext highlighter-rouge">ps</code><strong>要么是赋值前的值，要么是赋值后的值</strong>。</p><p>不过<code class="language-plaintext highlighter-rouge">get()</code>读取还是有可能存在<code class="language-plaintext highlighter-rouge">x</code>更新后，<code class="language-plaintext highlighter-rouge">y</code>更新前的情况，这个问题并没有解决。</p><hr /><h3 id="测试同步问题">测试同步问题</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 超出出后停止</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="o">;</span><span class="n">x</span><span class="o">++,</span><span class="n">y</span><span class="o">++){</span>
                <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
            <span class="c1">// 线程thread执行完后关闭</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">isAlive</span><span class="o">()){</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">ints</span><span class="o">;</span>
                <span class="n">ints</span> <span class="o">=</span> <span class="n">point</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]-</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">]!=-</span><span class="mi">1</span><span class="o">){</span>
                    <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"x="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">",y="</span><span class="o">+</span><span class="n">ints</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">s</span><span class="o">,</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">stringIntegerEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="nc">Integer</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringIntegerEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="n">count</span><span class="o">+=</span><span class="n">value</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span><span class="o">+</span><span class="s">",count:"</span><span class="o">+</span><span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一共"</span><span class="o">+</span><span class="n">count</span><span class="o">+</span><span class="s">"条同步问题"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台提示有同步问题，<strong>1000条左右的量级</strong>。</p><p>那么把<code class="language-plaintext highlighter-rouge">set</code>，<strong>加锁</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台提示有同步问题，<strong>100w条左右的量级</strong>，为什么同步问题更多了呢？因为加锁后性能变低了。</p><p>那么把<code class="language-plaintext highlighter-rouge">get</code>也<strong>加相同锁</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>肯定没问题，因为<code class="language-plaintext highlighter-rouge">get</code>要等全部<code class="language-plaintext highlighter-rouge">set</code>完才执行，这时就不存在共享变量了。</p><p>那么把get改成<strong>不同锁</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>那<code class="language-plaintext highlighter-rouge">get</code>的<code class="language-plaintext highlighter-rouge">synchronized</code>就锁了个寂寞，控制台提示有同步问题，<strong>100w条左右的量级</strong></p><p>那么把<code class="language-plaintext highlighter-rouge">Point</code>的<code class="language-plaintext highlighter-rouge">set</code>改写成线程安全的形式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
        <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="n">copy</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">get</code>还有线程安全问题，控制台提示有同步问题，<strong>大概100条左右的量级</strong>。</p><p>那么把<code class="language-plaintext highlighter-rouge">get</code>改写成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
    <span class="k">return</span> <span class="n">copy</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>当然有问题，不是原子性的语句，控制台提示有同步问题，<strong>大概100条左右的量级</strong>。</p><p>那么最终改成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
<span class="o">}</span>
</code></pre></div></div><p>还是一样的问题，控制台提示有同步问题，<strong>大概100条作用的量级</strong>。</p><p>那么把<code class="language-plaintext highlighter-rouge">get</code>改成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">return</span> <span class="n">ps</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>问题解决</strong>，一共0条同步问题。</p><hr /><p>胡乱分析：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div><p>对于 <code class="language-plaintext highlighter-rouge">this.ps = new int[] { x, y };</code>来说，它实际上解决的是同时将<code class="language-plaintext highlighter-rouge">x</code>，<code class="language-plaintext highlighter-rouge">y</code>赋值到<code class="language-plaintext highlighter-rouge">ps</code>的问题，因为对于引用类型变量来说赋值是原子的，所以问题解决了。但是获取<code class="language-plaintext highlighter-rouge">x</code>，<code class="language-plaintext highlighter-rouge">y</code>的值可不是原子的，为什么这里没有问题呢？因为<code class="language-plaintext highlighter-rouge">x</code>与<code class="language-plaintext highlighter-rouge">y</code>都是局部变量，不会有变量共享问题。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">get</span><span class="o">(){</span>
    <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span><span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">]};</span>
<span class="o">}</span>
</code></pre></div></div><p>而对于<code class="language-plaintext highlighter-rouge">get</code>来说，<code class="language-plaintext highlighter-rouge">ps[0]</code>,<code class="language-plaintext highlighter-rouge">ps[1]</code>有变量共享问题，因为<code class="language-plaintext highlighter-rouge">ps</code>是共享变量。</p><p>总的来说，在这段测试代码中，只要<code class="language-plaintext highlighter-rouge">set</code>和<code class="language-plaintext highlighter-rouge">get</code>方法有一个有同步问题就会导致测试代码出问题。</p><hr /><p><strong>不可变对象无需同步</strong></p><p>如果多线程读写的是一个不可变对象，那么无需同步，因为不会修改对象的状态：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Data</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">names</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">names</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">set()</code>方法内部创建了一个不可变<code class="language-plaintext highlighter-rouge">List</code>，这个<code class="language-plaintext highlighter-rouge">List</code>包含的对象也是不可变对象<code class="language-plaintext highlighter-rouge">String</code>，因此，整个<code class="language-plaintext highlighter-rouge">List&lt;String&gt;</code>对象都是不可变的，因此读写均无需同步。</p><hr /><p>分析变量是否能被多线程访问时，首先要理清概念，多线程同时执行的是方法。对于下面这个例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Status</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">names</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">names</span> <span class="o">=</span> <span class="n">ns</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">StatusRecord</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">StatusRecord</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">names</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果有A、B两个线程，同时执行是指：</p><ul><li>可能同时执行set()；</li><li>可能同时执行get()；</li><li>可能A执行set()，同时B执行get()。</li></ul><p>对象的成员变量<code class="language-plaintext highlighter-rouge">names</code>、<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>显然能被多线程同时读写，但局部变量（包括方法参数）如果没有“逃逸”，那么只有当前线程可见。局部变量<code class="language-plaintext highlighter-rouge">step</code>也仅在<code class="language-plaintext highlighter-rouge">set()</code>方法内部使用，因此每个线程同时执行<code class="language-plaintext highlighter-rouge">set</code>时都有一份独立的<code class="language-plaintext highlighter-rouge">step</code>存储在线程的栈上，互不影响，但是局部变量<code class="language-plaintext highlighter-rouge">ns</code>虽然每个线程也各有一份，但<strong>后续赋值后</strong>对其他线程就变成可见了。对<code class="language-plaintext highlighter-rouge">set()</code>方法同步时，如果要最小化<code class="language-plaintext highlighter-rouge">synchronized</code>代码块，可以改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 局部变量其他线程不可见:</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
    <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">names</span> <span class="o">=</span> <span class="n">ns</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">+=</span> <span class="n">step</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，深入理解多线程还需理解变量在栈上的存储方式，基本类型和引用类型的存储方式也不同。</p><hr /><p>例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">Point</span> <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">();</span>
        <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">point</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">110</span><span class="o">,</span> <span class="mi">220</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">point</span><span class="o">);</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">point</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">s</span> <span class="o">=</span> <span class="no">STR</span><span class="o">.</span><span class="s">"Point{x=\{x}, y=\{y}\{'}'}"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>最后一条<code class="language-plaintext highlighter-rouge">System.out.println(point);</code>会等待<code class="language-plaintext highlighter-rouge">point.set(110, 220);</code>释放锁后执行。</p><p>如果去掉<code class="language-plaintext highlighter-rouge">toString()</code>的锁，则最后一条<code class="language-plaintext highlighter-rouge">System.out.println(point);</code>打印的内容是不可确定的，可能是<code class="language-plaintext highlighter-rouge">Point{x=100, y=200}</code>也可能是<code class="language-plaintext highlighter-rouge">Point{x=110, y=200}</code>，如果1ms内<code class="language-plaintext highlighter-rouge">set()</code>没执行完<code class="language-plaintext highlighter-rouge">this.x = x;</code>那就是<code class="language-plaintext highlighter-rouge">Point{x=110, y=200}</code>。</p><hr /><h3 id="volatile与synchronized"><code class="language-plaintext highlighter-rouge">volatile</code>与<code class="language-plaintext highlighter-rouge">synchronized</code></h3><p>可能导致线程安全的问题有：原子性问题、有序性问题、可见性问题</p><p>JAVA构建内存模型JMM来应对，其中<code class="language-plaintext highlighter-rouge">volatile</code>解决可见性+有序性问题，原子性问题解决思路本质是<strong>互斥</strong>，只能使用锁来解决，比如<code class="language-plaintext highlighter-rouge">synchronized</code>或者<code class="language-plaintext highlighter-rouge">CAS</code></p><p><code class="language-plaintext highlighter-rouge">volatile</code>只保证每个线程读到的数据是最新值，但不能保证多个线程对同一个变量的操作的原子性。</p><p><code class="language-plaintext highlighter-rouge">synchronized</code>保证<strong>同步代码块内</strong>的代码同一时刻<strong>只能有一个线程访问</strong>，也确保了可见性、有序性和原子性。</p><p>也就是说<code class="language-plaintext highlighter-rouge">synchronized</code>除了加锁外，还具有内存屏障功能，并且强制读取所有共享变量的主内存最新值，退出<code class="language-plaintext highlighter-rouge">synchronized</code>时再强制回写主内存（如果有修改）。</p><h3 id="同步方法">同步方法</h3><p>使用<code class="language-plaintext highlighter-rouge">synchronized</code>的时候，锁住的是哪个对象非常重要。让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code class="language-plaintext highlighter-rouge">synchronized</code>逻辑封装起来。比如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dec</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">-=</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样一来，线程调用<code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">dec()</code>方法时，它不必关心同步逻辑，因为<code class="language-plaintext highlighter-rouge">synchronized</code>代码块在<code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">dec()</code>方法内部。并且<code class="language-plaintext highlighter-rouge">synchronized</code>锁住的对象是<code class="language-plaintext highlighter-rouge">this</code>，即<strong>当前实例</strong>，这又使得创建<strong>多个</strong><code class="language-plaintext highlighter-rouge">Counter</code>实例的时候，它们之间<strong>互不影响</strong>，可以并发执行。</p><hr /><p>如果一个类被设计为允许多线程正确访问，这个类就是“线程安全”的（thread-safe），上面的<code class="language-plaintext highlighter-rouge">Counter</code>类就是线程安全的。Java标准库的<code class="language-plaintext highlighter-rouge">java.lang.StringBuffer</code>也是线程安全的。</p><p>还有一些不变类，例如<code class="language-plaintext highlighter-rouge">String</code>，<code class="language-plaintext highlighter-rouge">Integer</code>，<code class="language-plaintext highlighter-rouge">LocalDate</code>，它们的所有成员变量都是<code class="language-plaintext highlighter-rouge">final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code class="language-plaintext highlighter-rouge">Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><p>除了上述几种少数情况，大部分类，例如<code class="language-plaintext highlighter-rouge">ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code class="language-plaintext highlighter-rouge">ArrayList</code>是可以安全地在线程间共享的。 <strong>没有特殊说明时，一个类默认是非线程安全的</strong>。</p><hr /><p>当我们锁住的是<code class="language-plaintext highlighter-rouge">this</code>实例时，实际上可以用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字修饰这个<strong>方法</strong>。它表示整个方法都用<code class="language-plaintext highlighter-rouge">this</code>实例加锁。</p><p>而对于<code class="language-plaintext highlighter-rouge">static</code>方法，是没有<code class="language-plaintext highlighter-rouge">this</code>实例的，因为<code class="language-plaintext highlighter-rouge">static</code>方法是针对类而不是实例。但是任何一个类都有一个由JVM自动创建的<code class="language-plaintext highlighter-rouge">Class</code>实例，因此，对<code class="language-plaintext highlighter-rouge">static</code>方法添加<code class="language-plaintext highlighter-rouge">synchronized</code>，锁住的是该类的<code class="language-plaintext highlighter-rouge">Class</code>实例。即类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span><span class="o">(</span><span class="nc">Counter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果在<strong>方法</strong>上使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，则表示整个方法都会被加锁，只有获取到锁的线程才能执行该方法。其他线程在获取到锁之前会被阻塞，直到锁被释放。这样可以确保在多线程环境下对该方法的调用是安全的，不会出现竞态条件等问题。确保了在同一时间只有一个线程可以进入该方法的代码块执行。</p><p>如果对两个方法<strong>同时</strong>使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，那么这两个方法将会使用<strong>同一把锁</strong>，即<code class="language-plaintext highlighter-rouge">this</code>。这种情况下，如果一个线程已经获取了锁并在执行其中一个方法，那其他线程就不能同时执行这两个方法中的任意一个，直到获取到锁。</p><p>如果希望两个方法<strong>不使用同一把锁</strong>，则不能在方法上使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，在方法体内使用<code class="language-plaintext highlighter-rouge">synchronized(lockObject) { ... }</code>指定锁即可，或者一个用方法锁，一个用代码锁。</p><p>对于单条赋值语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>不需要同步，因为读取一个 <code class="language-plaintext highlighter-rouge">int</code> 变量是原子操作，不会出现线程安全问题。</p><p>但是如果是两条赋值语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">last</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Pair</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="n">p</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">get</code>方法返回一个包含两个<code class="language-plaintext highlighter-rouge">int</code>值的对象<code class="language-plaintext highlighter-rouge">Pair</code>。如果在调用<code class="language-plaintext highlighter-rouge">get</code>方法的过程中，另一个线程修改了<code class="language-plaintext highlighter-rouge">first</code>或<code class="language-plaintext highlighter-rouge">last</code>的值，就可能导致返回的<code class="language-plaintext highlighter-rouge">Pair</code>对象中的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>不是<strong>原子性地对应的</strong>。</p><p>为了确保返回的<code class="language-plaintext highlighter-rouge">Pair</code>对象中的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>是<strong>原子性地对应的</strong>，需要在<code class="language-plaintext highlighter-rouge">get</code>方法内部使用<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，同时也应该在修改<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>值的<code class="language-plaintext highlighter-rouge">set</code>方法上加上<code class="language-plaintext highlighter-rouge">synchronized</code>关键字，这样既确保在同一时刻只有一个线程能够获取到<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的值，保证获取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的过程是原子的。</p><p>如果只在<code class="language-plaintext highlighter-rouge">get</code>方法上加锁，虽然能保证在同一时刻只有一个线程<strong>能够通过<code class="language-plaintext highlighter-rouge">get</code>方法</strong>获取到<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的值，但不能保证获取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的过程是原子的。</p><p>原子性指的是一个操作是不可分割的整体，要么全部执行成功，要么全部不执行，不会出现中间状态。在这里，原子性是指保证在读取<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>时，它们的值是一致的，不存在读到<code class="language-plaintext highlighter-rouge">first</code>更新后、<code class="language-plaintext highlighter-rouge">last</code>更新前的情况。使用<code class="language-plaintext highlighter-rouge">synchronized</code>确保了这种一致性，但并没有保证<strong>同时获取</strong>这两个值，因此把其他的对<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>写入操作的也锁了才能保证一致性。</p><p>如果不需要保证<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>的<strong>一致性</strong>，即<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>没有什么关系，那么不需要对这两个变量进行同步操作。同步的目的是为了<strong>保证程序逻辑正确</strong>。</p><h2 id="死锁">死锁</h2><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank">https://acteds.github.io/2024/04/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1713441081', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
