<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>网络编程 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="网络编程"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言TCP、UDP、Email、HTTP、RMI。"><meta name="og:description" content="引言TCP、UDP、Email、HTTP、RMI。"><meta property="og:url" content="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-04-23"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="网络编程"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">网络编程</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/04/23 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 72793 字，约 208 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>TCP、UDP、Email、HTTP、RMI。</p><h1 id="网络编程">网络编程</h1><p>网络编程是指编写能够在计算机网络上进行通信的程序的过程。网络编程涉及使用各种协议和技术来实现不同类型的网络通信，例如传输文件、发送电子邮件、浏览网页等。在网络编程中，通常涉及两个或多个计算机之间的数据交换，这些计算机通过网络连接在一起。</p><p>常见服务和对应端口号</p><table><thead><tr><th>端口</th><th>对应服务</th></tr></thead><tbody><tr><td>7</td><td>Echo服务器</td></tr><tr><td>21</td><td>Ftp</td></tr><tr><td>23</td><td>telnet</td></tr><tr><td>25</td><td>SMTP</td></tr><tr><td>79</td><td>Finger</td></tr><tr><td>80</td><td>HTTP</td></tr><tr><td>110</td><td>POP3</td></tr><tr><td>143</td><td>IMAP</td></tr><tr><td>443</td><td>HTTPS</td></tr></tbody></table><h2 id="tcp通信">TCP通信</h2><h3 id="socket概念">Socket概念</h3><p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<strong>特权端口</strong>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p><p>当Socket连接成功地在服务器端和客户端之间建立后：</p><ul><li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li><li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li></ul><p>Socket通常用来实现client-server连接。<code class="language-plaintext highlighter-rouge">java.net</code>包中定义的两个类<code class="language-plaintext highlighter-rouge">Socket</code>和<code class="language-plaintext highlighter-rouge">ServerSocket</code>,分别用来实现双向连接的<code class="language-plaintext highlighter-rouge">client</code>和<code class="language-plaintext highlighter-rouge">server</code>端.</p><p>创建<code class="language-plaintext highlighter-rouge">TCP Socket</code>需要的四个信息：</p><ul><li>本地系统的<code class="language-plaintext highlighter-rouge">IP</code></li><li>本地应用程序使用的<code class="language-plaintext highlighter-rouge">TCP</code>端口号</li><li>远程系统的<code class="language-plaintext highlighter-rouge">IP</code></li><li>远程应用程序相应的<code class="language-plaintext highlighter-rouge">TCP</code>端口号</li></ul><h3 id="inetaddress类">InetAddress类</h3><p><code class="language-plaintext highlighter-rouge">InetAddress</code> 类表示互联网协议 (IP) 地址。它提供了一种将 IP 地址和主机名之间进行转换的方法，以及创建原始套接字时所需的一些其他方法。<code class="language-plaintext highlighter-rouge">InetAddress</code> 类是用于网络编程的基础之一，可以用来确定主机的 IP 地址，或者将 IP 地址转换为主机名。</p><p>要获取<code class="language-plaintext highlighter-rouge">InetAddress</code> 类实例，可以使用其静态方法：</p><ul><li><code class="language-plaintext highlighter-rouge">InetAddress getByAddress(byte[] addr)</code>：根据原始 IP 地址获取 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getByAddress(String host, byte[] addr)</code>：根据主机名和原始 IP 地址获取 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getByName(String host)</code>：根据主机名获取 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">InetAddress[] getAllByName(String host)</code>：根据主机名获取所有与之关联的 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例数组。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getLocalHost()</code>：获取本地主机的 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例。</li></ul><p>这些静态方法可用于创建 <code class="language-plaintext highlighter-rouge">InetAddress</code> 实例，以便与网络通信。</p><p><code class="language-plaintext highlighter-rouge">InetAddress</code> 类的常用方法包括：</p><ul><li><code class="language-plaintext highlighter-rouge">getHostName()</code>：获取主机名。</li><li><code class="language-plaintext highlighter-rouge">getCanonicalHostName()</code>：获取主机的全限定域名。</li><li><code class="language-plaintext highlighter-rouge">getHostAddress()</code>：获取主机的 IP 地址字符串。</li><li><code class="language-plaintext highlighter-rouge">isReachable(int timeout)</code>：测试是否可以达到该主机，在指定的超时时间内。</li><li><code class="language-plaintext highlighter-rouge">isReachable(NetworkInterface netif, int ttl, int timeout)</code>：测试是否可以达到该主机，使用指定的网络接口和生存时间（TTL）。</li></ul><p>这些方法可用于获取主机名、IP 地址、测试主机的可达性等操作。</p><h3 id="socket类">Socket类</h3><p><code class="language-plaintext highlighter-rouge">Socket</code> 类在 Java 网络编程中扮演着重要的角色，它用于实现网络中的两个端点之间的通信。一个 <code class="language-plaintext highlighter-rouge">Socket</code> 实例表示一个网络中的端点，它可以用于发送和接收数据。<code class="language-plaintext highlighter-rouge">Socket</code> 可以连接到远程主机的某个端口，以便与之通信，也可以监听本地端口，等待其他程序的连接请求。</p><p>总的来说，<code class="language-plaintext highlighter-rouge">Socket</code> 的主要作用包括：</p><ul><li><strong>建立连接：</strong> 客户端使用 <code class="language-plaintext highlighter-rouge">Socket</code> 来连接到服务器端的主机和端口，从而建立网络连接。</li><li><strong>发送和接收数据：</strong> 通过 <code class="language-plaintext highlighter-rouge">Socket</code> 实例，可以发送数据到连接的另一端，并从另一端接收数据。</li><li><strong>实现网络应用：</strong> <code class="language-plaintext highlighter-rouge">Socket</code> 是实现网络应用的基础，例如 Web 客户端、服务器、邮件客户端等。</li></ul><p>在 Java 中，<code class="language-plaintext highlighter-rouge">Socket</code> 类用于实现传输层的 TCP 协议，而 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 则用于在服务器端监听和接受客户端连接请求。</p><p><strong>Socket类构造器</strong></p><ul><li><code class="language-plaintext highlighter-rouge">Socket()</code>: 创建一个未连接的Socket对象。</li><li><strong><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号。</strong></li><li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port, boolean stream)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，指定是否使用流模式。</li><li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，并绑定到指定的本地地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">Socket(String host, int port)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号。</li><li><code class="language-plaintext highlighter-rouge">Socket(String host, int port, boolean stream)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，指定是否使用流模式。</li><li><code class="language-plaintext highlighter-rouge">Socket(String host, int port, InetAddress localAddr, int localPort)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，并绑定到指定的本地地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>: 创建一个<code class="language-plaintext highlighter-rouge">ServerSocket</code>对象，绑定到指定的端口号。</li><li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int count)</code>: 创建一个<code class="language-plaintext highlighter-rouge">ServerSocket</code>对象，绑定到指定的端口号，并指定等待连接的队列长度。</li></ul><p><strong>Socket的常用方法</strong></p><ul><li><code class="language-plaintext highlighter-rouge">connect(SocketAddress endpoint)</code>: 连接到指定的远程端点。</li><li><strong><code class="language-plaintext highlighter-rouge">getInputStream()</code>: 返回此套接字的输入流。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">getOutputStream()</code>: 返回此套接字的输出流。</strong></li><li><code class="language-plaintext highlighter-rouge">close()</code>: 关闭套接字连接。</li><li><code class="language-plaintext highlighter-rouge">isConnected()</code>: 返回套接字连接的状态。</li><li><code class="language-plaintext highlighter-rouge">isClosed()</code>: 返回套接字是否已关闭。</li><li><strong><code class="language-plaintext highlighter-rouge">getInetAddress()</code>: 获取远程连接的IP地址。</strong></li><li><code class="language-plaintext highlighter-rouge">getLocalAddress()</code>: 获取本地连接的IP地址。</li><li><strong><code class="language-plaintext highlighter-rouge">getPort()</code>: 获取远程连接的端口号。</strong></li><li><code class="language-plaintext highlighter-rouge">getLocalPort()</code>: 获取本地连接的端口号。</li><li><code class="language-plaintext highlighter-rouge">setSoTimeout(int timeout)</code>: 设置套接字的读取超时时间。</li><li><code class="language-plaintext highlighter-rouge">setKeepAlive(boolean on)</code>: 设置套接字是否在空闲时保持连接。</li><li><code class="language-plaintext highlighter-rouge">setTcpNoDelay(boolean on)</code>: 设置是否启用 Nagle 算法。</li></ul><h3 id="serversocket类">ServerSocket类</h3><p><code class="language-plaintext highlighter-rouge">ServerSocket</code> 类是 Java 网络编程中用于创建服务器端的类。通过 <code class="language-plaintext highlighter-rouge">ServerSocket</code>，可以监听指定的端口，等待客户端的连接请求，并在建立连接后与客户端进行通信。</p><p>一般来说，使用 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 的基本流程如下：</p><ol><li>创建一个 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 实例，并指定服务器监听的端口。</li><li>调用 <code class="language-plaintext highlighter-rouge">ServerSocket</code> 的 <code class="language-plaintext highlighter-rouge">accept()</code> 方法，该方法会阻塞程序，直到有客户端连接请求到达。</li><li>一旦有连接请求到达，<code class="language-plaintext highlighter-rouge">accept()</code> 方法会返回一个 <code class="language-plaintext highlighter-rouge">Socket</code> 实例，代表与客户端的连接。</li><li>使用返回的 <code class="language-plaintext highlighter-rouge">Socket</code> 实例与客户端进行通信，可以发送和接收数据。</li><li>当通信结束后，关闭 <code class="language-plaintext highlighter-rouge">Socket</code> 实例，并继续等待下一个连接请求。</li></ol><p><strong>构造器：</strong></p><ul><li><strong><code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>：用指定的端口<code class="language-plaintext highlighter-rouge">port</code>来创建一个侦听<code class="language-plaintext highlighter-rouge">Socket</code>。</strong></li><li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int backlog)</code>：加上一个用来改变连接队列长度的参数<code class="language-plaintext highlighter-rouge">backlog</code>。</li><li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int backlog, InetAddress localAddr)</code>：在机器存在多个<code class="language-plaintext highlighter-rouge">IP</code>地址的情况下，允许通过<code class="language-plaintext highlighter-rouge">localAddr</code>这个参数来指定侦听的<code class="language-plaintext highlighter-rouge">IP</code>地址。</li></ul><p><strong>常用方法：</strong></p><ul><li><strong><code class="language-plaintext highlighter-rouge">accept()</code>: 监听并接受到此套接字的连接。</strong></li><li><code class="language-plaintext highlighter-rouge">bind(SocketAddress endpoint)</code>: 将套接字绑定到特定的本地地址和端口。</li><li><code class="language-plaintext highlighter-rouge">close()</code>: 关闭套接字。</li><li><code class="language-plaintext highlighter-rouge">getInetAddress()</code>: 返回此套接字的本地地址。</li><li><code class="language-plaintext highlighter-rouge">getLocalPort()</code>: 返回此套接字绑定的本地端口。</li><li><code class="language-plaintext highlighter-rouge">setSoTimeout(int timeout)</code>: 设置通过<code class="language-plaintext highlighter-rouge">accept()</code>方法接受客户端连接的超时时间。</li><li><code class="language-plaintext highlighter-rouge">getSoTimeout()</code>: 获取通过<code class="language-plaintext highlighter-rouge">accept()</code>方法接受客户端连接的超时时间。</li></ul><p>这些方法可用于管理<code class="language-plaintext highlighter-rouge">ServerSocket</code>的状态并与客户端进行通信。</p><h3 id="tcp使用实例">TCP使用实例</h3><p>服务端程序编写</p><ol><li>调用<code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>创建一个服务端套接字，并绑定到指定端口上；</li><li>调用<code class="language-plaintext highlighter-rouge">accept()</code>监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；</li><li>调用<code class="language-plaintext highlighter-rouge">socket</code>类的<code class="language-plaintext highlighter-rouge">getOutputStream()</code>和<code class="language-plaintext highlighter-rouge">getlnputStream()</code>获取输入流和输出流</li><li>关闭<code class="language-plaintext highlighter-rouge">socket</code>；</li></ol><p>客户端程序编写</p><ol><li>调用<code class="language-plaintext highlighter-rouge">Socket()</code>创建流套接字，并链接到服务端；</li><li>调用<code class="language-plaintext highlighter-rouge">socket</code>类的<code class="language-plaintext highlighter-rouge">getOutputStream()</code>和<code class="language-plaintext highlighter-rouge">getInputStream()</code>获取输入流和输出流；</li><li>关闭<code class="language-plaintext highlighter-rouge">socket</code>；</li></ol><p>客户端Socket的建立，链接服务器。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>服务器端Socket的建立</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"can not listen to :"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
        <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">socket</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>打开输入/出流</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintStream</span> <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>  
<span class="nc">DataInputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
</code></pre></div></div><p>关闭Socket</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>简单的<code class="language-plaintext highlighter-rouge">client</code>/<code class="language-plaintext highlighter-rouge">server</code>程序</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ConnectException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Server1</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"resource"</span><span class="o">)</span>  
            <span class="nc">ServerSocket</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8888</span><span class="o">);</span>  
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>  
                <span class="nc">Socket</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>  
                <span class="nc">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>  
                <span class="nc">DataOutputStream</span> <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="n">os</span><span class="o">);</span>  
                <span class="n">dos</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"Hello,"</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">getInetAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">"port#"</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">"bye-bye!"</span><span class="o">);</span>  
                <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
                <span class="n">s1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
                <span class="c1">// s.close();  </span>
            <span class="o">}</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Client1</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nc">Socket</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>  
            <span class="nc">InputStream</span> <span class="n">is</span> <span class="o">=</span><span class="n">s1</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>  
            <span class="nc">DataInputStream</span> <span class="n">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">is</span><span class="o">);</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dis</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>  
            <span class="n">dis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
            <span class="n">s1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ConnectException</span> <span class="n">connExc</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"服务器连接失败！"</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>先运行服务器,然后运行客户端,会收到服务器发的信息.</p><p>例子二</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">1234</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Socket</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
                <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">()));</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好，端口"</span> <span class="o">+</span> <span class="n">sk</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，你成功连接了服务器："</span> <span class="o">+</span> <span class="n">server</span><span class="o">.</span><span class="na">getLocalPort</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">server</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Client1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">client</span><span class="o">;</span>
        <span class="nc">PrintStream</span> <span class="n">ps</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">1234</span><span class="o">);</span>
            <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>
            <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"哦，真好！"</span><span class="o">);</span>
            <span class="n">ps</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>例子三：</p><p>服务端：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServerSocket</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">6666</span><span class="o">);</span> <span class="c1">// 监听指定端口</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"服务器正在运行..."</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="nc">Socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span><span class="c1">//每有一个新客户端就返回一个Socket</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"connected from "</span> <span class="o">+</span> <span class="n">sock</span><span class="o">.</span><span class="na">getRemoteSocketAddress</span><span class="o">());</span>
            <span class="c1">// 用新线程处理</span>
            <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
                <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
                     <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">()</span>
                <span class="o">)</span> <span class="o">{</span>
                    <span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
                    <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好!\n"</span><span class="o">);</span><span class="c1">//注意加换行符，要不然客户端不会结束读取。</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span><span class="c1">//若没有新内容则阻塞。</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"再见"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"再见\n"</span><span class="o">);</span>
                            <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                            <span class="k">break</span><span class="o">;</span><span class="c1">//结束线程</span>
                        <span class="o">}</span>
                        <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"好的: "</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                        <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">sock</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ioe</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">}</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"客户端已断开连接."</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>代码<code class="language-plaintext highlighter-rouge">ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code class="language-plaintext highlighter-rouge">Socket</code>实例，这个<code class="language-plaintext highlighter-rouge">Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，就必须为每个新的<code class="language-plaintext highlighter-rouge">Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p><p>如果没有客户端连接进来，<code class="language-plaintext highlighter-rouge">accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code class="language-plaintext highlighter-rouge">ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code class="language-plaintext highlighter-rouge">accept()</code>就可以获取新的连接。</p><p>客户端：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">6666</span><span class="o">);</span> <span class="c1">// 连接指定服务器端口</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
             <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">var</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="kt">var</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[服务器] "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"&gt;&gt;&gt; "</span><span class="o">);</span> <span class="c1">// 打印提示</span>
                <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span> <span class="c1">// 读取一行输入</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span><span class="c1">//换行符</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="nc">String</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span><span class="c1">// 若没有新内容则阻塞。</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;&lt;&lt; "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"再见"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sock</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"断开连接."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当Socket连接创建成功后，无论是服务器端，还是客户端，都使用<code class="language-plaintext highlighter-rouge">Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>来封装Socket的数据流，这样使用Socket的流，和普通IO流类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用于读取网络数据:</span>
<span class="nc">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
<span class="c1">// 用于写入网络数据:</span>
<span class="nc">OutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
</code></pre></div></div><p>如果不调用<code class="language-plaintext highlighter-rouge">flush()</code>，很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而又想强制把这些数据发送到网络，就必须调用<code class="language-plaintext highlighter-rouge">flush()</code>强制把缓冲区数据发送出去。</p><p><strong>URL与Socket通信的区别</strong></p><p>利用<code class="language-plaintext highlighter-rouge">URL</code>进行通信与利用<code class="language-plaintext highlighter-rouge">socket</code>进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：</p><p>利用<code class="language-plaintext highlighter-rouge">socket</code>进行通信时，在服务器端运行一个<code class="language-plaintext highlighter-rouge">socket</code>通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在<code class="language-plaintext highlighter-rouge">socket</code>通信方式中，服务器是主动等待连接通信的到来。</p><p>利用<code class="language-plaintext highlighter-rouge">URL</code>进行通信时，在服务器端常驻一个<code class="language-plaintext highlighter-rouge">CGI</code>程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在<code class="language-plaintext highlighter-rouge">URL</code>通信方式中，服务器是被动等待连接通信的到来。</p><h2 id="udp通信">UDP通信</h2><p>在基于<code class="language-plaintext highlighter-rouge">TCP/IP</code>网络体系结构的网络中主要使用<code class="language-plaintext highlighter-rouge">TCP</code>和<code class="language-plaintext highlighter-rouge">UDP</code>（<code class="language-plaintext highlighter-rouge">UserDatagramProtocol</code>，用户数据报协议）来实现数据通信。<code class="language-plaintext highlighter-rouge">TCP</code>是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而<code class="language-plaintext highlighter-rouge">UDP</code>则是一种面向无连接的不可靠传输协议，它<strong>不能</strong>确保数据能正确到达目的端，但是它能<strong>提高网络通信的效率</strong>。</p><p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p><p><strong>UDP Socket特性</strong></p><p>通过UDP的UDP端口来实现UDP协议的网络通信。</p><p>其工作过程如下：</p><ul><li>创建一个适当的要发送且注明收发人地址数据报；</li><li>为一个特定的应用程序建立一个传输端口来传送和接收数据包；</li><li>将数据报插入一个传输端口中进行传输；</li><li>等待接收来自于传输端口的一个数据报；</li><li>解码数据报以解开消息、接收者和其它信息；</li></ul><h3 id="datagramsocket类">DatagramSocket类</h3><p><code class="language-plaintext highlighter-rouge">DatagramSocket</code> 类是用于实现 UDP 协议的套接字。</p><p>构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">DatagramSocket()</code>：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）</li><li><strong><code class="language-plaintext highlighter-rouge">DatagramSocket(int port)</code>：创建实例，并固定监听<code class="language-plaintext highlighter-rouge">Port</code>端口的报文。通常用于服务端</strong></li><li><code class="language-plaintext highlighter-rouge">DatagramSocket(int port,InetAddress localAddr)</code>：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自<code class="language-plaintext highlighter-rouge">LocalAddr</code>的报文。</li></ul><p>方法：</p><ul><li><code class="language-plaintext highlighter-rouge">void bind(SocketAddress addr)</code>：将套接字绑定到指定的本地地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">void close()</code>：关闭套接字。</li><li><strong><code class="language-plaintext highlighter-rouge">void connect(InetAddress address, int port)</code>：将套接字连接到指定的远程主机和端口号。</strong></li><li><code class="language-plaintext highlighter-rouge">void disconnect()</code>：断开与远程主机的连接。</li><li><code class="language-plaintext highlighter-rouge">boolean getBroadcast()</code>：获取套接字的广播状态。</li><li><code class="language-plaintext highlighter-rouge">Object getOption(int optID)</code>：获取套接字选项的当前值。</li><li><code class="language-plaintext highlighter-rouge">int getPort()</code>：获取套接字绑定的本地端口号。</li><li><code class="language-plaintext highlighter-rouge">SocketAddress getLocalSocketAddress()</code>：获取套接字绑定的本地地址。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getLocalAddress()</code>：获取套接字绑定的本地 IP 地址。</li><li><code class="language-plaintext highlighter-rouge">int getLocalPort()</code>：获取套接字绑定的本地端口号。</li><li><code class="language-plaintext highlighter-rouge">SocketAddress getRemoteSocketAddress()</code>：获取套接字连接的远程地址。</li><li><code class="language-plaintext highlighter-rouge">boolean isBound()</code>：检查套接字是否绑定到本地地址。</li><li><code class="language-plaintext highlighter-rouge">boolean isConnected()</code>：检查套接字是否连接到远程主机。</li><li><strong><code class="language-plaintext highlighter-rouge">void receive(DatagramPacket p)</code>：接收一个数据包。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void send(DatagramPacket p)</code>：发送一个数据包。</strong></li><li><code class="language-plaintext highlighter-rouge">void setBroadcast(boolean on)</code>：设置套接字的广播状态。</li><li><code class="language-plaintext highlighter-rouge">void setOption(int optID, Object value)</code>：设置套接字选项的值。</li><li><strong><code class="language-plaintext highlighter-rouge">void setSoTimeout(int timeout)</code>：设置套接字的超时时间（接收数据时的超时时间）。</strong></li><li><code class="language-plaintext highlighter-rouge">int getSoTimeout()</code>：获取套接字的超时时间。</li><li><code class="language-plaintext highlighter-rouge">String toString()</code>：返回套接字的字符串表示形式。</li></ul><hr /><h3 id="datagrampacket类">DatagramPacket类</h3><p><code class="language-plaintext highlighter-rouge">DatagramPacket</code> 类表示数据报包，它包含了要发送或接收的数据以及目标地址和端口号等信息。</p><p>常用构造方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据，数据存储在 <code class="language-plaintext highlighter-rouge">buf</code> 中。</strong></li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据到指定的地址和端口。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据。</li><li><strong><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据到指定的地址和端口。</strong></li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, SocketAddress address)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据到指定的地址和端口。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据到指定的地址和端口。</li></ul><p>这些构造方法可以用于创建不同类型的数据报包，以便发送或接收数据。</p><p>方法：</p><ul><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length)</code>：使用指定的缓冲区和长度创建一个 DatagramPacket，用于接收数据。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>：使用指定的缓冲区、长度、远程主机地址和端口号创建一个 DatagramPacket，用于发送数据。</li><li><strong><code class="language-plaintext highlighter-rouge">byte[] getData()</code>：返回数据缓冲区。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void setData(byte[] buf)</code>：设置数据缓冲区。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getLength()</code>：返回数据缓冲区的长度。</strong></li><li><code class="language-plaintext highlighter-rouge">void setLength(int length)</code>：设置数据缓冲区的长度。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getAddress()</code>：返回远程主机的地址。</li><li><code class="language-plaintext highlighter-rouge">void setAddress(InetAddress address)</code>：设置远程主机的地址。</li><li><code class="language-plaintext highlighter-rouge">int getPort()</code>：返回远程主机的端口号。</li><li><code class="language-plaintext highlighter-rouge">void setPort(int port)</code>：设置远程主机的端口号。</li><li><code class="language-plaintext highlighter-rouge">SocketAddress getSocketAddress()</code>：返回远程主机的地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">void setSocketAddress(SocketAddress address)</code>：设置远程主机的地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">void setData(byte[] buf, int offset, int length)</code>：设置数据缓冲区的一部分。</li><li><code class="language-plaintext highlighter-rouge">void setData(ByteBuffer buf)</code>：设置数据缓冲区。</li><li><code class="language-plaintext highlighter-rouge">ByteBuffer getData()</code>：返回数据缓冲区。</li><li><strong><code class="language-plaintext highlighter-rouge">int getOffset()</code>：返回数据缓冲区的偏移量。</strong></li><li><code class="language-plaintext highlighter-rouge">void setOffset(int offset)</code>：设置数据缓冲区的偏移量。</li><li><code class="language-plaintext highlighter-rouge">void setLength(int length, InetAddress address, int port)</code>：设置数据缓冲区的长度、远程主机地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">void setAddress(InetAddress address, int port)</code>：设置远程主机的地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">void setAddress(SocketAddress address)</code>：设置远程主机的地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">SocketAddress getLocalSocketAddress()</code>：返回本地主机的地址和端口号。</li></ul><p>这些方法可以在数据报包中读取和设置数据，以及获取目标地址和端口号等信息。</p><hr /><h3 id="udp使用实例">UDP使用实例</h3><p>在服务器端，使用UDP也需要监听指定的端口。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">(</span><span class="mi">6666</span><span class="o">);</span> <span class="c1">// 监听指定端口</span>
<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span> <span class="c1">// 无限循环</span>
    <span class="c1">// 数据缓冲区:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
    <span class="nc">DatagramPacket</span> <span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="n">ds</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span> <span class="c1">// 收取一个UDP数据包,阻塞</span>
    <span class="c1">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度，将其按UTF-8编码转换为String:</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getOffset</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getLength</span><span class="o">(),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="c1">// 发送数据:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"ACK"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
    <span class="n">packet</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">//设置数据包。</span>
    <span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">//发送</span>
<span class="o">}</span>
</code></pre></div></div><p>当服务器收到一个<code class="language-plaintext highlighter-rouge">DatagramPacket</code>后，通常必须立刻回复一个或多个UDP包，因为客户端地址在<code class="language-plaintext highlighter-rouge">DatagramPacket</code>中，每次收到的<code class="language-plaintext highlighter-rouge">DatagramPacket</code>可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。UDP 是无连接的协议，服务器在接收到 UDP 数据报后，通常需要<strong>立即</strong>给客户端发送响应，以确保通信的连续性和可靠性。没有响应的话，客户端<strong>可能会超时或者认为连接失败</strong>。</p><p>客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">();</span>
<span class="n">ds</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">//设置超时时间</span>
<span class="n">ds</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="nc">InetAddress</span><span class="o">.</span><span class="na">getByName</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">),</span> <span class="mi">6666</span><span class="o">);</span> <span class="c1">// 连接指定服务器和端口</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="nc">DatagramPacket</span> <span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">// 发送</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">// 收取一个UDP数据包,阻塞,超过超时时间则异常</span>
<span class="nc">String</span> <span class="n">resp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getOffset</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resp</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span><span class="c1">// 关闭</span>
<span class="n">ds</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>客户端创建<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code class="language-plaintext highlighter-rouge">setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p><p>客户端的<code class="language-plaintext highlighter-rouge">DatagramSocket</code>还调用了一个<code class="language-plaintext highlighter-rouge">connect()</code>方法“连接”到指定的服务器端。</p><p>这个<code class="language-plaintext highlighter-rouge">connect()</code>方法不是真连接，它是为了在客户端的<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p><p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p><p>如果客户端认为通信结束，就可以调用<code class="language-plaintext highlighter-rouge">disconnect()</code>断开连接：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ds</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例就可以连接另一个服务器端。</p><p>如果客户端希望向两个不同的服务器发送UDP包，有两种方法：</p><ol><li>客户端可以创建两个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例，用<code class="language-plaintext highlighter-rouge">connect()</code>连接到不同的服务器；</li><li>客户端也可以不调用<code class="language-plaintext highlighter-rouge">connect()</code>方法，而是在创建<code class="language-plaintext highlighter-rouge">DatagramPacket</code>的时候指定服务器地址，这样可以用一个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例发送<code class="language-plaintext highlighter-rouge">DatagramPacket</code>到不同的服务器。</li></ol><p>不调用<code class="language-plaintext highlighter-rouge">connect()</code>方法的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">();</span>
<span class="n">ds</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
<span class="nc">InetAddress</span> <span class="n">localhost</span> <span class="o">=</span> <span class="nc">InetAddress</span><span class="o">.</span><span class="na">getByName</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="c1">// 发送到localhost:6666:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">packet1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data1</span><span class="o">,</span> <span class="n">data1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">localhost</span><span class="o">,</span> <span class="mi">6666</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet1</span><span class="o">);</span>
<span class="c1">// 发送到localhost:8888:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data2</span> <span class="o">=</span> <span class="s">"Hi"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">packet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data2</span><span class="o">,</span> <span class="n">data2</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">localhost</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet2</span><span class="o">);</span>
<span class="c1">// 关闭:</span>
<span class="n">ds</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><h2 id="发送email">发送Email</h2><p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code class="language-plaintext highlighter-rouge">abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p><p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p><p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p><pre><code class="language-ascii">           ┌──────────┐    ┌──────────┐
           │PostOffice│    │PostOffice│     .───.
┌─────┐    ├──────────┤    ├──────────┤    (   ( )
│═══ ░│──▶│ ┌─┐ ┌┐┌┐  │──▶│ ┌─┐ ┌┐┌┐ │──▶ `─┬─'
└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
           └─┴─┴──────┘    └─┴─┴──────┘       │
</code></pre><p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p><pre><code class="language-ascii">             ┌─────────┐    ┌─────────┐    ┌─────────┐
             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
│       │──▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀──│       │
└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
   MUA           MTA            MTA            MDA           MUA
</code></pre><p>类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；</p><p>邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；</p><p>最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。</p><p>电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p><p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p><p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p><p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，无需关心SMTP协议的底层原理，只需要使用<code class="language-plaintext highlighter-rouge">JavaMail</code>这个标准API就可以直接发送邮件。</p><p>注：若在web邮箱中设置了“保存到已发送”，使用客户端SMTP服务发信时，已发邮件也会自动同步到网页端“已发送”文件夹内。</p><hr /><p>假设准备使用自己的邮件地址<code class="language-plaintext highlighter-rouge">me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code class="language-plaintext highlighter-rouge">xiaoming@somewhere.com</code>，发送邮件前，首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code class="language-plaintext highlighter-rouge">smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p><ul><li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；</li><li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li><li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。</li></ul><p>有了SMTP服务器的域名和端口号，还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p><p>使用<code class="language-plaintext highlighter-rouge">JavaMail</code>发送邮件，需要把<code class="language-plaintext highlighter-rouge">JavaMail</code>相关的两个依赖加入进来，注意版本号相同：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/jakarta.mail/jakarta.mail-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>jakarta.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jakarta.mail-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.sun.mail/jakarta.mail --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.sun.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jakarta.mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.mail-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.sun.mail/javax.mail --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.sun.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>并且代码引用的<code class="language-plaintext highlighter-rouge">jakarta.mail</code>需替换为<code class="language-plaintext highlighter-rouge">javax.mail</code>。</p><hr /><h3 id="验证发送方信息">验证发送方信息</h3><p><code class="language-plaintext highlighter-rouge">Session</code>类是<code class="language-plaintext highlighter-rouge">JavaMail</code> API中表示邮件会话的类，它包含了创建和管理邮件的相关方法。以下是<code class="language-plaintext highlighter-rouge">Session</code>类的一些常用方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">getSession(Properties props, Authenticator authenticator)</code>：静态方法，用于获取<code class="language-plaintext highlighter-rouge">Session</code>实例。需要传入<code class="language-plaintext highlighter-rouge">Properties</code>对象和<code class="language-plaintext highlighter-rouge">Authenticator</code>对象来配置会话属性和认证信息。</strong></li><li><code class="language-plaintext highlighter-rouge">getTransport(String protocol)</code>：获取指定协议的<code class="language-plaintext highlighter-rouge">Transport</code>对象，用于发送邮件。</li><li><code class="language-plaintext highlighter-rouge">getStore(String protocol)</code>：获取指定协议的<code class="language-plaintext highlighter-rouge">Store</code>对象，用于接收邮件。</li><li><code class="language-plaintext highlighter-rouge">getDebug()</code>：获取调试模式的状态。</li><li><strong><code class="language-plaintext highlighter-rouge">setDebug(boolean debug)</code>：设置调试模式的状态。</strong></li><li><code class="language-plaintext highlighter-rouge">setProtocolForAddress(String type, String protocol)</code>：设置指定地址类型对应的协议。</li><li><code class="language-plaintext highlighter-rouge">setProvider(Provider provider)</code>：设置指定协议的提供者。</li><li><code class="language-plaintext highlighter-rouge">getProperty(String name)</code>：获取指定属性名的属性值。</li><li><code class="language-plaintext highlighter-rouge">setProperty(String name, String value)</code>：设置指定属性名的属性值。</li><li><code class="language-plaintext highlighter-rouge">getDefaultInstance(Properties props, Authenticator authenticator)</code>：静态方法，获取默认的<code class="language-plaintext highlighter-rouge">Session</code>实例。</li></ul><p>这些方法可以帮配置和管理邮件会话，以及创建<code class="language-plaintext highlighter-rouge">Transport</code>和<code class="language-plaintext highlighter-rouge">Store</code>对象来发送和接收邮件。</p><hr /><p><code class="language-plaintext highlighter-rouge">Session</code> 可以配置的一些常见属性包括：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.host</code>: SMTP 服务器主机名。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.port</code>: SMTP 服务器端口号。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.auth</code>: 指定是否需要进行用户认证，通常为 <code class="language-plaintext highlighter-rouge">"true"</code>。</strong></li><li><code class="language-plaintext highlighter-rouge">mail.smtp.starttls.enable</code>: 指定是否启用 STARTTLS 加密，通常为 <code class="language-plaintext highlighter-rouge">"true"</code>。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.fallback</code>: 指定是否在连接失败时回退到普通套接字，通常为 <code class="language-plaintext highlighter-rouge">"false"</code>。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.port</code>: 指定用于创建 SMTP 套接字的端口号，通常与 <code class="language-plaintext highlighter-rouge">mail.smtp.port</code> 相同。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.connectiontimeout</code>: 设置连接超时时间，以毫秒为单位。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.timeout</code>: 设置读取超时时间，以毫秒为单位。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.writetimeout</code>: 设置写入超时时间，以毫秒为单位。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.from</code>：设置发件人地址。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.user</code>：设置 SMTP 认证的用户名。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.password</code>：设置 SMTP 认证的密码。</li><li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.class</code>: 指定用于创建 SMTP 套接字的 <code class="language-plaintext highlighter-rouge">SocketFactory</code> 类的名称， 可以设置为 <code class="language-plaintext highlighter-rouge">javax.net.ssl.SSLSocketFactory</code>，用于创建 SSL 套接字。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.enable</code>：指定是否启用 SSL 安全连接。</strong></li><li><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.trust</code>：指定信任的 SSL 服务器主机名列表。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.protocols</code>：指定使用的 SSL 协议列表。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.ssl.ciphersuites</code>：指定使用的 SSL 加密套件列表。</li></ul><p>中间的协议名改成对应的协议。这些属性可以用于配置 <code class="language-plaintext highlighter-rouge">Session</code> 实例，以控制邮件发送的行为和连接设置。</p><hr /><p>通过<code class="language-plaintext highlighter-rouge">JavaMail</code> API连接到SMTP服务器上：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.Authenticator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.PasswordAuthentication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="o">...</span>
<span class="c1">// 服务器地址:</span>
<span class="nc">String</span> <span class="n">smtp</span> <span class="o">=</span> <span class="s">"smtp.163.com"</span><span class="o">;</span>
<span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"XXX@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"********"</span><span class="o">;</span>
<span class="c1">// 连接到SMTP服务器587端口:</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.host"</span><span class="o">,</span> <span class="s">"smtp.163.com"</span><span class="o">);</span> <span class="c1">// SMTP主机名</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"587"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用TLS加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
<span class="c1">// 获取Session实例:</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Authenticator</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">PasswordAuthentication</span> <span class="nf">getPasswordAuthentication</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PasswordAuthentication</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="c1">// 设置debug模式便于调试:</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div></div><p>以587端口为例，连接SMTP服务器时，需要准备一个<code class="language-plaintext highlighter-rouge">Properties</code>对象，填入相关信息。获取<code class="language-plaintext highlighter-rouge">Session</code>实例时，如果服务器需要认证，还需要传入一个<code class="language-plaintext highlighter-rouge">Authenticator</code>对象，用于提供用户名和密码进行身份验证。获取到<code class="language-plaintext highlighter-rouge">Session</code>实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p><p>SSL加密协议就用587端口，并改成以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"587"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用TLS加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
</code></pre></div></div><p>TLS就用25端口（非SSL协议，看服务器传回的消息里表示会判断这个）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"25"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用TLS加密</span>
</code></pre></div></div><h3 id="发送邮件">发送邮件</h3><p><code class="language-plaintext highlighter-rouge">MimeMessage</code>是<code class="language-plaintext highlighter-rouge">Message</code>的实现类，用于创建多部分邮件消息。<code class="language-plaintext highlighter-rouge">MimeMessage</code>类提供了多个构造方法，主要用于创建不同类型的消息。以下是<code class="language-plaintext highlighter-rouge">MimeMessage</code>类的一些常用构造方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">MimeMessage(Session session)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例。</strong></li><li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, InputStream is)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象和输入流创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，从输入流中读取消息内容。</li><li><code class="language-plaintext highlighter-rouge">MimeMessage(MimeMessage source)</code>：使用另一个<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例创建新的<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，复制源消息的内容。</li><li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, byte[] content)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象和字节数组创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，字节数组包含消息的原始内容。</li><li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, InputStream is, InternetHeaders headers)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象、输入流和邮件头信息创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，用于处理邮件头和消息内容分开的情况。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">MimeMessage</code>类提供了许多方法，用于<strong>设置和获取邮件消息的各种属性和内容</strong>。以下是<code class="language-plaintext highlighter-rouge">MimeMessage</code>类的一些常用方法：</p><ul><li><code class="language-plaintext highlighter-rouge">setSubject(String subject)</code>：设置邮件的主题为指定的字符串。</li><li><strong><code class="language-plaintext highlighter-rouge">setSubject(String subject, String charset)</code>：设置邮件的主题为指定的字符串，并指定字符集。</strong></li><li><code class="language-plaintext highlighter-rouge">setSubject(MimeMessage.RecipientType type, String subject)</code>：设置邮件的特定类型（如收件人、抄送人、密送人）的主题。</li><li><code class="language-plaintext highlighter-rouge">setSubject(String subject, String charset, String encoding)</code>：设置邮件的主题为指定的字符串，并指定字符集和编码方式。</li><li><code class="language-plaintext highlighter-rouge">setSubject(String subject, String charset, String encoding, MimeUtility.EncodedWord.Encoder encoder)</code>：设置邮件的主题为指定的字符串，并指定字符集、编码方式和编码器。</li><li><strong><code class="language-plaintext highlighter-rouge">setFrom(Address address)</code>：设置发件人地址。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">setRecipient(Message.RecipientType type, Address address)</code>：设置收件人、抄送人或密送人地址。</strong><ul><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.TO</code>：主要收件人（”To”）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.CC</code>：抄送（”Cc”），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.BCC</code>：秘密抄送（”Bcc”），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。</li></ul></li><li><strong><code class="language-plaintext highlighter-rouge">setContent(Object content, String contentType)</code>：设置邮件内容和内容类型。内容可以是字符串、字节数组或<code class="language-plaintext highlighter-rouge">Multipart</code>对象。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置纯文本邮件的内容。可以指定第二个参数文字编码，还可以指定第三个参数设置消息的子类型html或plain：</strong></li><li><code class="language-plaintext highlighter-rouge">setSentDate(Date date)</code>：设置邮件的发送日期。</li><li><code class="language-plaintext highlighter-rouge">addHeader(String name, String value)</code>：添加邮件头。</li><li><code class="language-plaintext highlighter-rouge">saveChanges()</code>：保存对邮件的更改。</li><li><code class="language-plaintext highlighter-rouge">getSubject()</code>：获取邮件主题。</li><li><code class="language-plaintext highlighter-rouge">getFrom()</code>：获取发件人地址。</li><li><code class="language-plaintext highlighter-rouge">getRecipients(Message.RecipientType type)</code>：获取指定类型的收件人、抄送人或密送人地址。</li><li><code class="language-plaintext highlighter-rouge">getContent()</code>：获取邮件内容。</li><li><code class="language-plaintext highlighter-rouge">getSentDate()</code>：获取邮件发送日期。</li><li><code class="language-plaintext highlighter-rouge">getAllHeaders()</code>：获取所有邮件头。</li><li><code class="language-plaintext highlighter-rouge">getHeader(String name)</code>：根据名称获取邮件头的值。</li><li><code class="language-plaintext highlighter-rouge">removeHeader(String name)</code>：移除指定名称的邮件头。</li><li><code class="language-plaintext highlighter-rouge">getContentType()</code>：获取邮件内容类型。</li></ul><p>这些方法可以对邮件消息进行各种操作，包括设置和获取邮件的属性、内容，以及添加和移除邮件头等。</p><hr /><p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类用于表示<strong>电子邮件地址</strong>。它有几种不同的构造方法，可以根据需要选择使用：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, boolean strict)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例，并指定是否启用严格模式。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal)</code>：使用给定的电子邮件地址字符串和个人名称创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset)</code>：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset, boolean strict)</code>：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类还提供了一些常用的方法，用于处理电子邮件地址的操作，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">String getAddress()</code>：获取电子邮件地址的地址部分（不包括个人名称）。</li><li><code class="language-plaintext highlighter-rouge">String getPersonal()</code>：获取电子邮件地址的个人名称部分。</li><li><code class="language-plaintext highlighter-rouge">void setAddress(String address)</code>：设置电子邮件地址的地址部分。</li><li><code class="language-plaintext highlighter-rouge">void setPersonal(String personal)</code>：设置电子邮件地址的个人名称部分。</li><li><code class="language-plaintext highlighter-rouge">String getType()</code>：获取电子邮件地址的类型。</li><li><code class="language-plaintext highlighter-rouge">void setType(String type)</code>：设置电子邮件地址的类型。</li><li><code class="language-plaintext highlighter-rouge">boolean isGroup()</code>：检查该地址是否表示一个邮件组。</li><li><code class="language-plaintext highlighter-rouge">boolean isUnicodeSupported()</code>：检查是否支持 Unicode 编码。</li><li><code class="language-plaintext highlighter-rouge">String toString()</code>：将 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 对象转换为字符串表示形式。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">Transport</code> 类用于<strong>发送邮件消息</strong>。以下是 <code class="language-plaintext highlighter-rouge">Transport</code> 类的一些常用方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">send(Message message)</code>：发送邮件消息。</strong></li><li><code class="language-plaintext highlighter-rouge">connect()</code>：连接到邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">connect(String host, String user, String password)</code>：连接到指定主机的邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">close()</code>：关闭连接。</li><li><code class="language-plaintext highlighter-rouge">addConnectionListener(ConnectionListener listener)</code>：添加连接监听器。</li><li><code class="language-plaintext highlighter-rouge">removeConnectionListener(ConnectionListener listener)</code>：移除连接监听器。</li><li><code class="language-plaintext highlighter-rouge">addTransportListener(TransportListener listener)</code>：添加传输监听器。</li><li><code class="language-plaintext highlighter-rouge">removeTransportListener(TransportListener listener)</code>：移除传输监听器。</li><li><code class="language-plaintext highlighter-rouge">isConnected()</code>：检查是否已连接到邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">isSSL()</code>：检查是否使用 SSL 连接。</li><li><code class="language-plaintext highlighter-rouge">getURLName()</code>：获取连接的 URL 名称。</li><li><code class="language-plaintext highlighter-rouge">setURLName(URLName urlname)</code>：设置连接的 URL 名称。</li><li><code class="language-plaintext highlighter-rouge">setDebug(boolean debug)</code>：设置调试模式，用于输出调试信息。</li></ul><p>这些方法可以连接到邮件服务器并发送邮件消息。</p><hr /><p>发送邮件时，需要构造一个<code class="language-plaintext highlighter-rouge">Message</code>对象，然后调用<code class="language-plaintext highlighter-rouge">Transport.send(Message)</code>即可完成发送：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.internet.InternetAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MimeMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Transport</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"xiaoming@somewhere.com"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"这是一幅邮件"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div><p>绝大多数邮件服务器要求<strong>发送方地址和登录用户名必须一致</strong>，否则发送将失败。</p><p>填入真实的地址，运行上述代码，可以在控制台看到<code class="language-plaintext highlighter-rouge">JavaMail</code>打印的调试信息：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这是JavaMail打印的调试信息:
DEBUG: setDebug: Jakarta Mail version 2.0.1
DEBUG: getProvider() returning jakarta.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]
DEBUG SMTP: need username and password for authentication
DEBUG SMTP: protocolConnect returning false, host=smtp.163.com, user=XXX, password=&lt;null&gt;
DEBUG SMTP: useEhlo true, useAuth true
DEBUG SMTP: trying to connect to host "smtp.163.com", port 587, isSSL true
220 163.com Anti-spam GT for Coremail System (163com[20141201])
开始尝试连接smtp.163.comm:
DEBUG SMTP: connected to host "smtp.163.com", port: 587, ...
发送命令EHLO:
EHLO localhost
SMTP服务器响应250:
...
发送命令STARTTLS:
STARTTLS
SMTP服务器响应250:
...
尝试登录:
DEBUG SMTP: protocolConnect login, host=smtp.163.com, user=XXX@163.com, password=&lt;non-null&gt;
DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 
DEBUG SMTP: Using mechanism LOGIN
DEBUG SMTP: AUTH LOGIN command trace suppressed
登录成功:
DEBUG SMTP: AUTH LOGIN succeeded
DEBUG SMTP: use8bit false
开发发送邮件，设置FROM:
MAIL FROM:发件人
250 2.1.0 Sender OK
设置TO:
RCPT TO:收件人
250 2.1.5 Recipient OK
发送邮件数据:
DATA
服务器响应354:
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
真正的邮件数据:
Date: 时间
From: 发送方
To: 收件方
Message-ID: &lt;283383329.0.1713860754302@localhost&gt;
邮件主题是编码后的文本:
Subject: =?UTF-8?B?5L2g5aW9IQ==?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

邮件正文是Base64编码的文本:
5oiR5Y+R5LqG5LiA5Lu96YKu5Lu2
发送成功:
DEBUG SMTP: message successfully delivered to mail server
发送QUIT命令:
QUIT
服务器响应221结束TCP连接:
221 Bye
</code></pre></div></div><p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a href="https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p><p><strong>发送HTML邮件</strong></p><p>发送HTML邮件和文本邮件是类似的，只需要把：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"这是一幅邮件"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><p>改为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一幅邮件&lt;/h1&gt;"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">,</span> <span class="s">"html"</span><span class="o">);</span>
</code></pre></div></div><p>传入的<code class="language-plaintext highlighter-rouge">body</code>是类似<code class="language-plaintext highlighter-rouge">&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p><h3 id="发送附件">发送附件</h3><p><code class="language-plaintext highlighter-rouge">MimeMultipart</code> 是 <code class="language-plaintext highlighter-rouge">JavaMail</code> 中用于处理多部分 MIME 消息的类，<code class="language-plaintext highlighter-rouge">MimeMultipart</code> 类有多个构造方法，用于创建不同类型的多部分消息。以下是一些常用的构造方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">MimeMultipart()</code>：创建一个空的多部分消息，默认使用混合 (<code class="language-plaintext highlighter-rouge">mixed</code>) 类型。</strong></li><li><code class="language-plaintext highlighter-rouge">MimeMultipart(String subtype)</code>：根据指定的子类型创建一个空的多部分消息。常用的子类型包括 <code class="language-plaintext highlighter-rouge">related</code>（相关）、<code class="language-plaintext highlighter-rouge">alternative</code>（备选）、<code class="language-plaintext highlighter-rouge">mixed</code>（混合）等。例如：<ul><li><code class="language-plaintext highlighter-rouge">MimeMultipart("related")</code>：创建一个相关类型的多部分消息。</li><li><code class="language-plaintext highlighter-rouge">MimeMultipart("alternative")</code>：创建一个备选类型的多部分消息。</li></ul></li><li><code class="language-plaintext highlighter-rouge">MimeMultipart(javax.mail.internet.ContentType contentType)</code>：根据指定的 <code class="language-plaintext highlighter-rouge">ContentType</code> 对象创建一个空的多部分消息。ContentType 对象可以包含主类型、子类型、参数等信息。</li><li><code class="language-plaintext highlighter-rouge">MimeMultipart(InputStream is)</code>：从输入流中读取内容，并根据读取的内容创建一个多部分消息。</li></ul><p>这些构造方法提供了不同的方式来创建 <code class="language-plaintext highlighter-rouge">MimeMultipart</code> 对象，以满足不同场景下的需求。</p><p><strong>常用方法包括：</strong></p><ul><li><strong><code class="language-plaintext highlighter-rouge">addBodyPart(BodyPart part)</code>：将一个 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象添加到多部分消息中。</strong></li><li><code class="language-plaintext highlighter-rouge">removeBodyPart(int index)</code>：从多部分消息中移除指定索引位置的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">getBodyPart(int index)</code>：获取多部分消息中指定索引位置的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">getBodyPart(String CID)</code>：根据 Content-ID（CID）获取多部分消息中对应的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">getBodyPartCount()</code>：获取多部分消息中 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象的数量。</li><li><code class="language-plaintext highlighter-rouge">setSubType(String subtype)</code>：设置多部分消息的子类型（subtype），例如 “mixed”、”alternative” 等。</li><li><code class="language-plaintext highlighter-rouge">setPreamble(String preamble)</code>：设置消息的开头部分（preamble）。</li><li><code class="language-plaintext highlighter-rouge">setEpilogue(String epilogue)</code>：设置消息的结尾部分（epilogue）。</li><li><code class="language-plaintext highlighter-rouge">writeTo(OutputStream os)</code>：将多部分消息写入输出流中。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 类用于表示邮件的各个部分，包括正文、附件等。它的构造方法相对简单，通常使用默认构造方法创建对象，然后使用 <code class="language-plaintext highlighter-rouge">setContent</code> 等方法设置内容。以下是 <code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 的构造方法：</p><ul><li><strong>默认构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart()</code></strong></li><li>使用输入流构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart(InputStream is)</code></li><li>使用 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart(DataSource ds)</code></li></ul><p><code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 类的方法如下：</p><ul><li><code class="language-plaintext highlighter-rouge">addHeader(String name, String value)</code>：添加指定名称和值的头信息。</li><li><code class="language-plaintext highlighter-rouge">addHeaderLine(String line)</code>：添加包含完整头信息行的字符串。</li><li><code class="language-plaintext highlighter-rouge">setContentID(String cid)</code>：设置内容 ID。</li><li><code class="language-plaintext highlighter-rouge">setContentLanguage(String[] languages)</code>：设置内容语言。</li><li><code class="language-plaintext highlighter-rouge">setContentTransferEncoding(String encoding)</code>：设置内容传输编码。</li><li><strong><code class="language-plaintext highlighter-rouge">setDataHandler(DataHandler dh)</code>：设置数据处理程序。</strong></li><li><code class="language-plaintext highlighter-rouge">setDescription(String description)</code>：设置描述信息。</li><li><code class="language-plaintext highlighter-rouge">setDisposition(String disposition)</code>：设置附件描述。</li><li><strong><code class="language-plaintext highlighter-rouge">setFileName(String filename)</code>：设置文件名。</strong></li><li><code class="language-plaintext highlighter-rouge">setHeader(String name, String value)</code>：设置指定名称的头信息值。</li><li><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置文本内容。</li><li><code class="language-plaintext highlighter-rouge">updateHeaders()</code>：更新所有头信息。</li><li><code class="language-plaintext highlighter-rouge">addRecipient(Message.RecipientType type, Address address)</code>：添加接收者地址。</li><li><code class="language-plaintext highlighter-rouge">getAllHeaders()</code>：获取所有头信息。</li><li><code class="language-plaintext highlighter-rouge">getContentType()</code>：获取内容类型。</li><li><code class="language-plaintext highlighter-rouge">getDataHandler()</code>：获取数据处理程序。</li><li><code class="language-plaintext highlighter-rouge">getDescription()</code>：获取描述信息。</li><li><code class="language-plaintext highlighter-rouge">getDisposition()</code>：获取附件描述。</li><li><code class="language-plaintext highlighter-rouge">getFileName()</code>：获取文件名。</li><li><code class="language-plaintext highlighter-rouge">getHeader(String name)</code>：根据名称获取头信息值。</li><li><code class="language-plaintext highlighter-rouge">getInputStream()</code>：获取输入流。</li><li><code class="language-plaintext highlighter-rouge">getLineCount()</code>：获取行数。</li><li><code class="language-plaintext highlighter-rouge">getSize()</code>：获取大小。</li><li><code class="language-plaintext highlighter-rouge">getText()</code>：获取文本内容。</li><li><code class="language-plaintext highlighter-rouge">isMimeType(String mimeType)</code>：检查是否与指定的 MIME 类型匹配。</li><li><code class="language-plaintext highlighter-rouge">removeHeader(String name)</code>：移除指定名称的头信息。</li><li><code class="language-plaintext highlighter-rouge">setContent(Multipart mp)</code>：设置内容为多部分。</li><li><strong><code class="language-plaintext highlighter-rouge">setContent(Object obj, String type)</code>：设置内容对象和类型。</strong></li><li><code class="language-plaintext highlighter-rouge">setContent(Multipart mp)</code>：设置内容为多部分。</li><li><code class="language-plaintext highlighter-rouge">setContentID(String cid)</code>：设置内容 ID。</li><li><code class="language-plaintext highlighter-rouge">setContentLanguage(String[] languages)</code>：设置内容语言。</li><li><code class="language-plaintext highlighter-rouge">setDataHandler(DataHandler dh)</code>：设置数据处理程序。</li><li><code class="language-plaintext highlighter-rouge">setDisposition(String disposition)</code>：设置附件描述。</li><li><code class="language-plaintext highlighter-rouge">setFileName(String filename)</code>：设置文件名。</li><li><strong><code class="language-plaintext highlighter-rouge">setHeader(String name, String value)</code>：设置指定名称的头信息值。</strong></li><li><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置文本内容。</li><li><code class="language-plaintext highlighter-rouge">setText(String text, String charset)</code>：设置文本内容和字符集。</li></ul><p>这些方法可以用于配置和操作 <code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 对象的各种属性和内容。</p><hr /><p><code class="language-plaintext highlighter-rouge">DataHandler</code> 的构造方法通常用于创建一个处理特定数据类型的数据处理程序对象。它有以下几个常用的构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">DataHandler(Object obj, String mimeType)</code>：使用给定的对象和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于将 Java 对象转换为数据处理程序。</li><li><code class="language-plaintext highlighter-rouge">DataHandler(URL url)</code>：使用给定的 URL 创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于处理指向外部资源的 URL。</li><li><code class="language-plaintext highlighter-rouge">DataHandler(DataSource dataSource)</code>：使用给定的数据源创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于处理数据源对象。</li></ul><p>这些构造方法根据不同的数据类型和来源创建适当的数据处理程序对象，以便于在应用程序中处理和传输数据。</p><hr /><p><code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 的构造方法通常用于创建一个包含字节数组数据的数据源对象。它有以下两个常用的构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">ByteArrayDataSource(byte[] data, String type)</code>：使用给定的字节数组和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">ByteArrayDataSource(InputStream is, String type)</code>：使用给定的输入流和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 对象。</li></ul><p>这些构造方法将字节数组或输入流与 MIME 类型关联起来，以便于处理和传输数据。</p><hr /><p>常用文件的 MIME 类型如下：</p><ul><li>文本文件：<code class="language-plaintext highlighter-rouge">text/plain</code></li><li>HTML 文件：<code class="language-plaintext highlighter-rouge">text/html</code></li><li>XML 文件：<code class="language-plaintext highlighter-rouge">application/xml</code></li><li>JSON 文件：<code class="language-plaintext highlighter-rouge">application/json</code></li><li>图片文件：<code class="language-plaintext highlighter-rouge">image/jpeg</code>、<code class="language-plaintext highlighter-rouge">image/png</code>、<code class="language-plaintext highlighter-rouge">image/gif</code>、<code class="language-plaintext highlighter-rouge">image/webp</code></li><li>视频文件：<code class="language-plaintext highlighter-rouge">video/mp4</code>、<code class="language-plaintext highlighter-rouge">video/quicktime</code></li><li>音频文件：<code class="language-plaintext highlighter-rouge">audio/mpeg</code>、<code class="language-plaintext highlighter-rouge">audio/wav</code></li><li>PDF 文件：<code class="language-plaintext highlighter-rouge">application/pdf</code></li><li>Word 文档：<code class="language-plaintext highlighter-rouge">application/msword</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.wordprocessingml.document</code></li><li>Excel 表格：<code class="language-plaintext highlighter-rouge">application/vnd.ms-excel</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code></li><li>PowerPoint 演示文稿：<code class="language-plaintext highlighter-rouge">application/vnd.ms-powerpoint</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.presentationml.presentation</code></li><li>压缩文件：<code class="language-plaintext highlighter-rouge">application/zip</code></li><li>二进制文件的 MIME 类型通常是 <code class="language-plaintext highlighter-rouge">application/octet-stream</code>。这个 MIME 类型通常用于表示未知的二进制数据类型，或者不属于其他已知 MIME 类型的二进制数据。</li></ul><p>这些 MIME 类型可以帮助浏览器和其他应用程序识别文件的类型并采取相应的处理方式。</p><hr /><p>要在电子邮件中携带附件，就不能直接调用<code class="language-plaintext highlighter-rouge">message.setText()</code>方法，而是要构造一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeBodyPart</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeMultipart</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.util.ByteArrayDataSource</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"XXX"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMultipart</span><span class="o">();</span>
<span class="c1">// 添加text:</span>
<span class="nc">BodyPart</span> <span class="n">textpart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">textpart</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一幅邮件&lt;/h1&gt;"</span><span class="o">,</span> <span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">textpart</span><span class="o">);</span>
<span class="c1">// 添加附件:</span>
<span class="nc">BodyPart</span> <span class="n">annex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setFileName</span><span class="o">(</span><span class="s">"附件1.7z"</span><span class="o">);</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayDataSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"Maven.7z"</span><span class="o">),</span> <span class="s">"application/octet-stream"</span><span class="o">)));</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">annex</span><span class="o">);</span>
<span class="c1">// 设置邮件内容为multipart:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">multipart</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div><p>一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象可以添加若干个<code class="language-plaintext highlighter-rouge">BodyPart</code>，其中<strong>第一个</strong><code class="language-plaintext highlighter-rouge">BodyPart</code>是文本，即邮件正文，后面的<code class="language-plaintext highlighter-rouge">BodyPart</code>是附件。</p><p><code class="language-plaintext highlighter-rouge">BodyPart</code>依靠<code class="language-plaintext highlighter-rouge">setContent()</code>决定添加的内容。</p><p>如果添加文本，用<code class="language-plaintext highlighter-rouge">setContent("...", "text/plain;charset=utf-8")</code>添加纯文本，或者用<code class="language-plaintext highlighter-rouge">setContent("...", "text/html;charset=utf-8")</code>添加HTML文本。</p><p>如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code class="language-plaintext highlighter-rouge">DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code class="language-plaintext highlighter-rouge">application/octet-stream</code>，Word文档则是<code class="language-plaintext highlighter-rouge">application/msword</code>。</p><p>最后，通过<code class="language-plaintext highlighter-rouge">setContent()</code>把<code class="language-plaintext highlighter-rouge">Multipart</code>添加到<code class="language-plaintext highlighter-rouge">Message</code>中，即可发送。</p><p><code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 是 <code class="language-plaintext highlighter-rouge">javax.mail.util.ByteArrayDataSource</code> 类的一个子类，用于从字节数组中创建数据源对象。在这个特定的代码片段中，它的作用是将 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 对象中的数据转换为字节数组，并将其作为数据源传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法。</p><p><code class="language-plaintext highlighter-rouge">DataHandler</code> 用于将数据封装为一种适合传输的格式，它可以处理各种类型的数据，如字节数组、文件、URL 等。在这里，<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 负责将文件中的数据读取到字节数组中，然后 <code class="language-plaintext highlighter-rouge">DataHandler</code> 将这个字节数组封装为一个数据处理程序，以便于传输和处理。</p><p>如果去掉<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code>，会报错：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"3.png"</span><span class="o">),</span> <span class="s">"image/png"</span><span class="o">));</span>
</code></pre></div></div><p>报错是因为 <code class="language-plaintext highlighter-rouge">DataHandler</code> 的构造方法不接受 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 对象作为参数，而是需要一个 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象。<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 实现了 <code class="language-plaintext highlighter-rouge">DataSource</code> 接口，因此可以作为参数传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法。如果直接将 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法，它将无法识别并处理文件流，从而导致错误。因此，需要使用 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 将文件流转换为 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象，以便 <code class="language-plaintext highlighter-rouge">DataHandler</code> 可以正确处理图像数据。</p><h3 id="发送内嵌图片的html邮件">发送内嵌图片的HTML邮件</h3><p><code class="language-plaintext highlighter-rouge">setHeader</code> 方法用于设置邮件头的值，其参数为邮件头的名称和对应的值。常用的邮件头包括但不限于：</p><ul><li><code class="language-plaintext highlighter-rouge">From</code>：发件人地址。</li><li><code class="language-plaintext highlighter-rouge">To</code>：收件人地址。</li><li><code class="language-plaintext highlighter-rouge">Cc</code>：抄送地址。</li><li><code class="language-plaintext highlighter-rouge">Bcc</code>：密送地址。</li><li><code class="language-plaintext highlighter-rouge">Subject</code>：邮件主题。</li><li><code class="language-plaintext highlighter-rouge">Date</code>：邮件发送时间。</li><li><code class="language-plaintext highlighter-rouge">Content-Type</code>：内容类型。</li><li><code class="language-plaintext highlighter-rouge">Content-Disposition</code>：内容描述。</li><li><strong><code class="language-plaintext highlighter-rouge">Content-ID</code>：内容 ID。</strong></li><li><code class="language-plaintext highlighter-rouge">MIME-Version</code>：MIME 版本。</li><li><code class="language-plaintext highlighter-rouge">Reply-To</code>：回复地址。</li><li><code class="language-plaintext highlighter-rouge">Return-Path</code>：返回路径。</li><li><code class="language-plaintext highlighter-rouge">Message-ID</code>：消息 ID。</li></ul><p>这些参数的设置可以根据邮件的需求和格式进行配置，以满足邮件发送的要求和格式规范。</p><hr /><p>HTML邮件中可以内嵌图片。如果给一个<code class="language-plaintext highlighter-rouge">&lt;img src="http://example.com/test.jpg"&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p><p>内嵌图片实际上也是一个附件，即邮件本身也是<code class="language-plaintext highlighter-rouge">Multipart</code>，但需要做一点额外的处理：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"XXX"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMultipart</span><span class="o">();</span>
<span class="c1">// 添加text:</span>
<span class="nc">BodyPart</span> <span class="n">textpart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">textpart</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一个带图片的邮件&lt;/h1&gt;&lt;p&gt;&lt;img src='cid:img01'"</span><span class="o">,</span> <span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">textpart</span><span class="o">);</span>
<span class="c1">// 添加附件:</span>
<span class="nc">BodyPart</span> <span class="n">annex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setFileName</span><span class="o">(</span><span class="s">"图片1.png"</span><span class="o">);</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayDataSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"3.png"</span><span class="o">),</span> <span class="s">"image/png"</span><span class="o">)));</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Content-ID"</span><span class="o">,</span><span class="s">"&lt;img01&gt;"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">annex</span><span class="o">);</span>
<span class="c1">// 设置邮件内容为multipart:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">multipart</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div><p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code class="language-plaintext highlighter-rouge">&lt;img src='cid:img01'"&gt;</code>引用，然后，在添加图片作为<code class="language-plaintext highlighter-rouge">BodyPart</code>时，除了要正确设置MIME类型（根据图片类型使用<code class="language-plaintext highlighter-rouge">image/jpeg</code>或<code class="language-plaintext highlighter-rouge">image/png</code>），还需要设置一个Header：<code class="language-plaintext highlighter-rouge">imagepart.setHeader("Content-ID", "&lt;img01&gt;");</code>。</p><h3 id="发送给多个收件人">发送给多个收件人</h3><p><strong>设置收件人和发件人：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">addFrom(Address[] addresses)</code>: 添加发件人地址。</li><li><code class="language-plaintext highlighter-rouge">addFrom(String addresses)</code>: 添加发件人地址。</li><li><code class="language-plaintext highlighter-rouge">addRecipient(Message.RecipientType type, Address address)</code>: 添加指定类型的收件人地址。</li><li><strong><code class="language-plaintext highlighter-rouge">addRecipients(Message.RecipientType type, Address[] addresses)</code>: 添加指定类型的收件人地址。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">addRecipients(Message.RecipientType type, String addresses)</code>: 添加指定类型的收件人地址。</strong></li><li><code class="language-plaintext highlighter-rouge">addRecipient(String type, String address)</code>: 添加指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">addRecipients(String type, String addresses)</code>: 添加指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setFrom(Address address)</code>: 设置发件人地址。</li><li><code class="language-plaintext highlighter-rouge">setFrom(String address)</code>: 设置发件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipient(Message.RecipientType type, Address address)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipients(Message.RecipientType type, Address[] addresses)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipients(Message.RecipientType type, String addresses)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipient(String type, Address address)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipients(String type, String addresses)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setReplyTo(Address[] addresses)</code>: 设置回复地址。</li></ul><p><code class="language-plaintext highlighter-rouge">Message.RecipientType</code>：</p><ul><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.TO</code>：主要收件人（”To”）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.CC</code>：抄送（”Cc”），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.BCC</code>：秘密抄送（”Bcc”），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。</li></ul><hr /><p>要设置多个收件人，可以使用<code class="language-plaintext highlighter-rouge">addRecipients</code>方法或<code class="language-plaintext highlighter-rouge">setRecipients</code>方法。这些方法允许为消息的不同类型（如TO、CC、BCC）添加多个收件人。以下是使用这些方法设置多个收件人的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 添加多个收件人</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="s">"recipient1@example.com, recipient2@example.com"</span><span class="o">);</span>
<span class="c1">// 或者使用数组</span>
<span class="nc">Address</span><span class="o">[]</span> <span class="n">recipients</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">InternetAddress</span><span class="o">(</span><span class="s">"recipient1@example.com"</span><span class="o">),</span>
    <span class="k">new</span> <span class="nf">InternetAddress</span><span class="o">(</span><span class="s">"recipient2@example.com"</span><span class="o">)</span>
<span class="o">};</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="n">recipients</span><span class="o">);</span>
</code></pre></div></div><p>注意，在使用<code class="language-plaintext highlighter-rouge">addRecipients</code>方法时，<strong>多个收件人应使用逗号分隔</strong>。还可以使用类似的方法设置CC和BCC收件人。</p><p><code class="language-plaintext highlighter-rouge">addRecipient</code>方法可以多次调用以添加多个收件人，而<code class="language-plaintext highlighter-rouge">setRecipient</code>方法会覆盖之前设置的收件人。因此，如果需要设置多个收件人，应该使用<code class="language-plaintext highlighter-rouge">addRecipient</code>方法。</p><p>如果需要设置收件人、抄送（CC）和密送（BCC）等多个收件人，应该使用<code class="language-plaintext highlighter-rouge">addRecipient</code>方法多次调用来添加不同类型的收件人。例如，可以按照以下方式设置多个收件人：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient1@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient2@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">CC</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"cc@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">BCC</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"bcc@example.com"</span><span class="o">));</span>
</code></pre></div></div><p>而对于多个发件人，SMTP 协议规定邮件的 <code class="language-plaintext highlighter-rouge">From</code> 字段只能有一个发件人。如果需要发送给多个人，但每个人看到的发件人应该不同，可以考虑使用群发邮件的方式，即将所有收件人放在收件人列表中，但在邮件内容中区分不同的收件人。如果需要在邮件内容中显示不同的发件人，可以在邮件内容中自定义发件人的显示方式，例如在邮件正文中注明发件人姓名或其他标识。</p><h3 id="设置别名">设置别名</h3><p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类用于表示<strong>电子邮件地址</strong>。它有几种不同的构造方法，可以根据需要选择使用：</p><ul><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, boolean strict)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例，并指定是否启用严格模式。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal)</code>：使用给定的电子邮件地址字符串和个人名称创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset)</code>：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset, boolean strict)</code>：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li></ul><hr /><p><strong><code class="language-plaintext highlighter-rouge">InternetAddress</code>可以很方便的设置别名</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
</code></pre></div></div><p><strong>在字符串里，也可以设置别名</strong>：</p><p>在字符串里给收件人设置别名的方法是使用 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;</code> 包裹完整的邮件地址，并在地址后面添加别名，格式如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"别名1 &lt;recipient1@example.com&gt;, 别名2 &lt;recipient2@example.com&gt;"</span>
</code></pre></div></div><p>例如，如果要将 “Alice” 和 “Bob” 添加到密送列表，可以这样做：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">BCC</span><span class="o">,</span> <span class="s">"Alice &lt;alice@example.com&gt;, Bob &lt;bob@example.com&gt;"</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">InternetAddress</code>里也可以这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"别名 &lt;recipient@example.com&gt;"</span><span class="o">);</span>
</code></pre></div></div><p>但是不能同时设置字符集，那中文可能出问题，所以还是得这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient@example.com&gt;"</span><span class="o">,</span><span class="s">"别名"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><p>或者这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient@example.com"</span><span class="o">);</span>
<span class="n">address</span><span class="o">.</span><span class="na">setPersonal</span><span class="o">(</span><span class="s">"别名"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><h3 id="常见问题">常见问题</h3><p>如果用户名或口令错误，会导致<code class="language-plaintext highlighter-rouge">535</code>登录失败：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: AUTH LOGIN failed
Exception in thread "main" javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
</code></pre></div></div><p>如果<strong>登录用户和发件人不一致</strong>，会导致<code class="language-plaintext highlighter-rouge">554</code>拒绝发送错误：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
</code></pre></div></div><p>有些时候，如果邮件主题和正文过于简单，会导致<code class="language-plaintext highlighter-rouge">554</code>被识别为垃圾邮件的错误：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">JavaMail</code> API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；</p><p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p><h2 id="接收email">接收Email</h2><p>发送Email，客户端总是通过SMTP协议把邮件发送给MTA。</p><p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p><p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p><p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p><p>以下是 QQ 邮箱、163 邮箱和 Gmail 邮箱的 POP3 和 IMAP 服务器信息：</p><ol><li>QQ 邮箱：<ul><li>POP3 服务器：pop.qq.com</li><li>IMAP 服务器：imap.qq.com</li></ul></li><li>163 邮箱：<ul><li>POP3 服务器：pop.163.com 或 pop3.163.com</li><li>IMAP 服务器：imap.163.com</li></ul></li><li>Gmail 邮箱：<ul><li>POP3 服务器：pop.gmail.com（默认端口号：995）</li><li>IMAP 服务器：imap.gmail.com（默认端口号：993）</li></ul></li></ol><p>对于 Gmail 邮箱，还需要启用“Less secure app access”或生成应用密码。Gmail 强制使用加密连接，请确保使用正确的端口号以及启用 SSL/TLS 加密连接。</p><p><strong>POP3与IMAP</strong></p><p>POP3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作（如移动邮件、标记已读等），不会反馈到服务器上，比如通过客户端收取了邮箱中的3封邮件并移动到其他文件夹，邮箱服务器上的这些邮件是没有同时被移动的 。</p><p>而IMAP提供webmail 与电子邮件客户端之间的双向通信，客户端的操作都会反馈到服务器上，对邮件进行的操作，服务器上的邮件也会做相应的动作。</p><p>同时，<strong>IMAP</strong>像<strong>POP3</strong>那样提供了方便的邮件下载服务，让用户能进行离线阅读。<strong>IMAP</strong>提供的摘要浏览功能可以让你在阅读完所有的邮件到达时间、主题、发件人、大小等信息后才作出是否下载的决定。此外，<strong>IMAP</strong> 更好地支持了从多个不同设备中随时访问新邮件。</p><p>总之，<strong>IMAP</strong> 整体上为用户带来更为便捷和可靠的体验。<strong>POP3</strong> 更易丢失邮件或多次下载相同的邮件，而 <strong>IMAP</strong> 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。</p><h3 id="登录邮箱">登录邮箱</h3><p><code class="language-plaintext highlighter-rouge">URLName</code> 类构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">public URLName()</code>: 默认构造方法，创建一个空的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">public URLName(String url)</code>: 使用给定的 URL 字符串创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。该 URL 字符串应包含完整的 URL 信息，例如：”protocol://host:port/file”。</li><li><strong><code class="language-plaintext highlighter-rouge">public URLName(String protocol, String host, int port, String file, String username, String password)</code>: 使用指定的协议、主机、端口、文件路径、用户名和密码创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。用于表示需要身份验证的 URL。</strong></li><li><code class="language-plaintext highlighter-rouge">public URLName(String protocol, String host, int port, String file)</code>: 使用指定的协议、主机、端口和文件路径创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，用户名和密码为空。通常用于表示不需要身份验证的 URL。</li><li><code class="language-plaintext highlighter-rouge">public URLName(URLName url)</code>: 复制构造方法，创建一个新的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，其内容与给定的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象相同。</li></ul><p><code class="language-plaintext highlighter-rouge">URLName</code> 类中除了构造方法外还有一些常用的方法，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">public String getProtocol()</code>: 返回 URL 的协议部分。</li><li><code class="language-plaintext highlighter-rouge">public String getHost()</code>: 返回 URL 的主机部分。</li><li><code class="language-plaintext highlighter-rouge">public int getPort()</code>: 返回 URL 的端口部分。</li><li><code class="language-plaintext highlighter-rouge">public String getFile()</code>: 返回 URL 的文件路径部分。</li><li><code class="language-plaintext highlighter-rouge">public String getUsername()</code>: 返回 URL 的用户名部分。</li><li><code class="language-plaintext highlighter-rouge">public String getPassword()</code>: 返回 URL 的密码部分。</li><li><code class="language-plaintext highlighter-rouge">public void setProtocol(String protocol)</code>: 设置 URL 的协议部分。</li><li><code class="language-plaintext highlighter-rouge">public void setHost(String host)</code>: 设置 URL 的主机部分。</li><li><code class="language-plaintext highlighter-rouge">public void setPort(int port)</code>: 设置 URL 的端口部分。</li><li><code class="language-plaintext highlighter-rouge">public void setFile(String file)</code>: 设置 URL 的文件路径部分。</li><li><code class="language-plaintext highlighter-rouge">public void setUsername(String username)</code>: 设置 URL 的用户名部分。</li><li><code class="language-plaintext highlighter-rouge">public void setPassword(String password)</code>: 设置 URL 的密码部分。</li></ul><hr /><h4 id="pop3">POP3</h4><p>使用POP3收取Email时，无需关心POP3协议底层，因为<code class="language-plaintext highlighter-rouge">JavaMail</code>提供了高层接口。首先需要连接到Store对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.mail.pop3.POP3SSLStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MessagingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Store</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.URLName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">MessagingException</span> <span class="o">{</span>
        <span class="c1">// 登录用户名:</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
        <span class="c1">// 登录口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
        <span class="c1">// 主机端口号</span>
        <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"995"</span><span class="o">;</span>
        <span class="c1">// pop3主机：</span>
        <span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"pop3.163.com"</span><span class="o">;</span>
        <span class="c1">// 连接到pop3服务器995端口:</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="n">getProperties</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="c1">// 获取Session实例:</span>
        <span class="c1">// 连接到Store:</span>
        <span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3s"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3SSLStore</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Properties</span> <span class="nf">getProperties</span><span class="o">(</span><span class="nc">String</span> <span class="n">host</span><span class="o">,</span> <span class="nc">String</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.host"</span><span class="o">,</span> <span class="n">host</span><span class="o">);</span> <span class="c1">// pop3主机名</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 关闭TLS加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.socketFactory.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">props</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 是 <code class="language-plaintext highlighter-rouge">POP3Store</code> 的 SSL 安全版本。它们的构造方法应该是类似的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span>
</code></pre></div></div><p>这个构造方法接受一个 <code class="language-plaintext highlighter-rouge">Session</code> 对象和一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象作为参数，用于初始化 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象。<code class="language-plaintext highlighter-rouge">Session</code> 对象包含邮件会话的配置信息，而 <code class="language-plaintext highlighter-rouge">URLName</code> 对象包含用于连接到邮件服务器的 URL 信息。</p><p>实际上，<code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 的构造方法内部调用了父类 <code class="language-plaintext highlighter-rouge">POP3Store</code> 的带有四个参数的构造方法，其中第一个参数是 <code class="language-plaintext highlighter-rouge">Session</code> 对象，第二个参数是 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，第三个参数是字符串 <code class="language-plaintext highlighter-rouge">"pop3s"</code>，表示使用 POP3 协议的 SSL 安全版本，第四个参数是 <code class="language-plaintext highlighter-rouge">true</code>，表示要使用 SSL 连接。源码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3SSLStore</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>这样就可以使用 SSL 安全连接到 POP3 邮件服务器。</p><p>对于代码中的<code class="language-plaintext highlighter-rouge">pop3s</code>都可以改成<code class="language-plaintext highlighter-rouge">pop3</code>，因为使用<code class="language-plaintext highlighter-rouge">POP3SSLStore</code>已经定义了<code class="language-plaintext highlighter-rouge">pop3s</code>，即<code class="language-plaintext highlighter-rouge">pop3</code>的SSL安全版本：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3s"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
</code></pre></div></div><p>实际上整个<code class="language-plaintext highlighter-rouge">getProperties</code>方法都是多余的，协议也是多余的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="c1">// 主机端口号</span>
<span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"995"</span><span class="o">;</span>
<span class="c1">// imap主机：</span>
<span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"pop3.163.com"</span><span class="o">;</span>
<span class="c1">// 连接到pop3服务器995端口:</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="c1">// 获取Session实例:</span>
<span class="c1">// 连接到Store:</span>
<span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3SSLStore</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span><span class="c1">//调用就会自动设置pop3s</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><hr /><p>如果不需要使用 SSL 安全连接，可以使用 <code class="language-plaintext highlighter-rouge">POP3Store</code> 类而不是 <code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 类。<code class="language-plaintext highlighter-rouge">POP3Store</code> 类用于表示普通的、非加密的 POP3 连接。在创建 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象时，可以直接指定协议为 <code class="language-plaintext highlighter-rouge">"pop3"</code>，而不是 <code class="language-plaintext highlighter-rouge">"pop3s"</code>，这样就可以使用非加密的方式连接到 POP3 邮件服务器。示例代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"mail.pop3.host"</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">);</span><span class="c1">//多余的操作</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"mail.pop3.port"</span><span class="o">,</span> <span class="s">"110"</span><span class="o">);</span><span class="c1">//多余的操作</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.ssl.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用SSL加密，这个也是多余的操作</span>

<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3Store</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3"</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">,</span> <span class="mi">110</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"username"</span><span class="o">,</span> <span class="s">"password"</span><span class="o">));</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><p>在这个示例中，创建了一个 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象，并指定了 POP3 邮件服务器的主机、端口、用户名和密码。连接时不需要指定使用 SSL，因为默认情况下 <code class="language-plaintext highlighter-rouge">POP3Store</code> 使用的是非加密的方式。</p><p>实际上<code class="language-plaintext highlighter-rouge">POP3Store</code>的构造方法定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="s">"pop3"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">,</span>
                 <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isSSL</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">url</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MailLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="s">"DEBUG POP3"</span><span class="o">,</span>
                            <span class="n">session</span><span class="o">.</span><span class="na">getDebug</span><span class="o">(),</span> <span class="n">session</span><span class="o">.</span><span class="na">getDebugOut</span><span class="o">());</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">isSSL</span><span class="o">)</span>
        <span class="n">isSSL</span> <span class="o">=</span> <span class="nc">PropUtil</span><span class="o">.</span><span class="na">getBooleanProperty</span><span class="o">(</span><span class="n">session</span><span class="o">.</span><span class="na">getProperties</span><span class="o">(),</span>
                                            <span class="s">"mail."</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">".ssl.enable"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isSSL</span><span class="o">)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">defaultPort</span> <span class="o">=</span> <span class="mi">995</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">this</span><span class="o">.</span><span class="na">defaultPort</span> <span class="o">=</span> <span class="mi">110</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">isSSL</span> <span class="o">=</span> <span class="n">isSSL</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，只需要写主机地址和用户名及密码，但由于<code class="language-plaintext highlighter-rouge">URLName</code>这个构造方法要指定端口号，还是指定了<code class="language-plaintext highlighter-rouge">110</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3Store</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">,</span> <span class="mi">110</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">));</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><hr /><h4 id="imap">IMAP</h4><p>使用IMAP协议的SSL安全连接方式（还是写规范点）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.mail.pop3.POP3SSLStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MessagingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Store</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.URLName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">MessagingException</span> <span class="o">{</span>
        <span class="c1">// 登录用户名:</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
        <span class="c1">// 登录口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
        <span class="c1">// 主机端口号</span>
        <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"993"</span><span class="o">;</span>
        <span class="c1">// imap主机：</span>
        <span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"imap.163.com"</span><span class="o">;</span>
        <span class="c1">// 连接到imap服务器993端口:</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="n">getProperties</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="c1">// 获取Session实例:</span>
        <span class="c1">// 连接到Store:</span>
        <span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"imaps"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getStore</span><span class="o">(</span><span class="n">url</span><span class="o">);</span><span class="c1">//获取指定协议的`Store`对象，用于接收邮件。</span>
        <span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Properties</span> <span class="nf">getProperties</span><span class="o">(</span><span class="nc">String</span> <span class="n">host</span><span class="o">,</span> <span class="nc">String</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"imaps"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.host"</span><span class="o">,</span> <span class="n">host</span><span class="o">);</span> <span class="c1">// imap主机名</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 关闭TLS加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.socketFactory.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">props</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>修改的地方也就几处：<code class="language-plaintext highlighter-rouge">port</code>为<code class="language-plaintext highlighter-rouge">993</code>，<code class="language-plaintext highlighter-rouge">host</code>为<code class="language-plaintext highlighter-rouge">imap.163.com</code>，<code class="language-plaintext highlighter-rouge">Store</code>的获取方式改为：<code class="language-plaintext highlighter-rouge">session.getStore(url);</code>，注意协议都改为了：<code class="language-plaintext highlighter-rouge">imaps</code>，这里不能像前面<code class="language-plaintext highlighter-rouge">pop3</code>一样不加<code class="language-plaintext highlighter-rouge">s</code>一样能SSL安全连接。</p><p>同样的，<code class="language-plaintext highlighter-rouge">getProperties</code>方法也是多余的，<code class="language-plaintext highlighter-rouge">new URLName("imaps"...</code>里的<code class="language-plaintext highlighter-rouge">imaps</code>这次不是多余的了，因为调用的是<code class="language-plaintext highlighter-rouge">session.getStore(url);</code>这个一般方法。</p><p><strong>也可以改成<code class="language-plaintext highlighter-rouge">Store store = new IMAPSSLStore(session,url);</code></strong></p><hr /><p>要改为非SSL安全连接的：只需要改<code class="language-plaintext highlighter-rouge">port</code>为<code class="language-plaintext highlighter-rouge">143</code>，协议改为：<code class="language-plaintext highlighter-rouge">imap</code>，<code class="language-plaintext highlighter-rouge">ssl</code>指定为<code class="language-plaintext highlighter-rouge">false</code>或者不写。即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"143"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"imap.163.com"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"imap"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getStore</span><span class="o">(</span><span class="n">url</span><span class="o">);</span><span class="c1">//获取指定协议的`Store`对象，用于接收邮件。</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><p><strong>也可以改成<code class="language-plaintext highlighter-rouge">Store store = new IMAPStore(session,url);</code></strong></p><h3 id="查看邮箱">查看邮箱</h3><p><code class="language-plaintext highlighter-rouge">Store</code> 类表示邮件存储的抽象类，它提供了一组方法用于连接到邮件服务器并访问邮件。下面是一些常用的 <code class="language-plaintext highlighter-rouge">Store</code> 类的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">void connect(String host, String user, String password)</code>：连接到指定主机的邮件服务器，使用指定的用户名和密码进行身份验证。</li><li><code class="language-plaintext highlighter-rouge">void connect()</code>：连接到之前设置的邮件服务器，使用之前设置的用户名和密码进行身份验证。</li><li><code class="language-plaintext highlighter-rouge">Folder getDefaultFolder()</code>：获取默认文件夹，通常是收件箱。</li><li><strong><code class="language-plaintext highlighter-rouge">Folder getFolder(String name)</code>：根据给定的文件夹名称获取文件夹对象。</strong></li><li><code class="language-plaintext highlighter-rouge">Folder[] getPersonalNamespaces()</code>：获取个人文件夹命名空间。</li><li><code class="language-plaintext highlighter-rouge">Folder[] getUserNamespaces(String user)</code>：获取给定用户的文件夹命名空间。</li><li><code class="language-plaintext highlighter-rouge">void close()</code>：关闭与邮件服务器的连接。</li><li><code class="language-plaintext highlighter-rouge">boolean isConnected()</code>：检查是否已连接到邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">void addConnectionListener(ConnectionListener listener)</code>：添加连接监听器，以便在连接状态发生变化时接收通知。</li><li><code class="language-plaintext highlighter-rouge">void removeConnectionListener(ConnectionListener listener)</code>：移除连接监听器。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">Folder</code> 类表示邮件文件夹，它提供了一组方法用于管理和操作邮件文件夹中的邮件。下面是一些常用的 <code class="language-plaintext highlighter-rouge">Folder</code> 类的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">String getFullName()</code>：获取邮件文件夹的完整名称。</li><li><code class="language-plaintext highlighter-rouge">boolean exists()</code>：检查邮件文件夹是否存在。</li><li><strong><code class="language-plaintext highlighter-rouge">void open(int mode)</code>：打开邮件文件夹，并指定打开模式（只读、读写等）。</strong></li><li><code class="language-plaintext highlighter-rouge">boolean isOpen()</code>：检查邮件文件夹是否已打开。</li><li><code class="language-plaintext highlighter-rouge">void appendMessages(Message[] msgs)</code>：向邮件文件夹中追加邮件。</li><li><code class="language-plaintext highlighter-rouge">void delete(boolean recurse)</code>：删除邮件文件夹，可选择是否递归删除子文件夹。</li><li><strong><code class="language-plaintext highlighter-rouge">int getMessageCount()</code>：获取邮件文件夹中的邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getNewMessageCount()</code>：获取邮件文件夹中的新邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getUnreadMessageCount()</code>：获取邮件文件夹中的未读邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getDeletedMessageCount()</code>：获取邮件文件夹中已标记为删除的邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">Message[] getMessages()</code>：获取邮件文件夹中的所有邮件。</strong></li><li><code class="language-plaintext highlighter-rouge">Message getMessage(int msgnum)</code>：根据邮件序号获取邮件对象。</li><li><code class="language-plaintext highlighter-rouge">Message getMessage(int start,int end)</code>：根据邮件序号获取邮件对象。</li><li><code class="language-plaintext highlighter-rouge">Message[] search(SearchTerm term)</code>：根据指定的搜索条件搜索邮件。</li><li><code class="language-plaintext highlighter-rouge">void setFlags(Message[] msgs, Flags flag, boolean value)</code>：设置邮件的标志（例如，已读、已删除等）。</li><li><code class="language-plaintext highlighter-rouge">Message[] expunge()</code>：清除标记为已删除的邮件，并返回已删除的邮件数组。</li><li><code class="language-plaintext highlighter-rouge">void close(boolean expunge)</code>：关闭邮件文件夹，可选择是否删除已删除的邮件。</li><li><code class="language-plaintext highlighter-rouge">void addMessageChangedListener(MessageChangedListener listener)</code>：添加邮件变化监听器。</li><li><code class="language-plaintext highlighter-rouge">void removeMessageChangedListener(MessageChangedListener listener)</code>：移除邮件变化监听器。</li><li><code class="language-plaintext highlighter-rouge">void addFolderListener(FolderListener listener)</code>：添加文件夹监听器。</li><li><code class="language-plaintext highlighter-rouge">void removeFolderListener(FolderListener listener)</code>：移除文件夹监听器。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">MimeUtility</code> 类是 JavaMail API 中用于处理 MIME（Multipurpose Internet Mail Extensions）消息的实用工具类。它提供了一些方法来编码和解码 MIME 消息的各个部分，以及处理文本和二进制数据的方法。</p><p>以下是 <code class="language-plaintext highlighter-rouge">MimeUtility</code> 类的一些常用方法：</p><ol><li><strong>编码方法</strong>：<ul><li><code class="language-plaintext highlighter-rouge">encodeText(String text) throws UnsupportedEncodingException</code>：对文本进行 MIME 编码。</li><li><code class="language-plaintext highlighter-rouge">encodeWord(String word) throws UnsupportedEncodingException</code>：对单词进行 MIME 编码。</li></ul></li><li><strong>解码方法</strong>：<ul><li><strong><code class="language-plaintext highlighter-rouge">decodeText(String text) throws UnsupportedEncodingException</code>：解码 MIME 编码的文本。</strong></li></ul></li><li><strong>其他方法</strong>：<ul><li><code class="language-plaintext highlighter-rouge">fold(int used, String s)</code>：根据 RFC 2822 规范折叠长行。</li><li><code class="language-plaintext highlighter-rouge">unfold(String s)</code>：从折叠的行中还原原始行。</li><li><code class="language-plaintext highlighter-rouge">encodeWord(String word, String charset, String encoding) throws UnsupportedEncodingException</code>：使用指定的字符集和编码对单词进行编码。</li><li><code class="language-plaintext highlighter-rouge">decodeWord(String eword)</code> throws ParseException：解码 MIME 编码的单词。</li><li><code class="language-plaintext highlighter-rouge">quote(String s, String specials)</code>：对字符串中的特殊字符进行引用。</li><li><code class="language-plaintext highlighter-rouge">quote(String s)</code>：对字符串中的特殊字符进行引用，默认引用所有非 ASCII 字符。</li></ul></li></ol><p>这些方法可能会抛出 <code class="language-plaintext highlighter-rouge">UnsupportedEncodingException</code> 或 <code class="language-plaintext highlighter-rouge">ParseException</code> 异常，因此在使用时需要处理这些异常。</p><hr /><p>一个<code class="language-plaintext highlighter-rouge">Store</code>对象表示整个邮箱的存储，要收取邮件，需要通过<code class="language-plaintext highlighter-rouge">Store</code>访问指定的<code class="language-plaintext highlighter-rouge">Folder</code>（文件夹），<strong>通常是<code class="language-plaintext highlighter-rouge">INBOX</code>表示收件箱</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取收件箱:</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="c1">// 以读写方式打开:</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">);</span>
<span class="c1">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getNewMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unread messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getUnreadMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getDeletedMessageCount</span><span class="o">());</span>
<span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Message</span> <span class="n">message</span> <span class="o">:</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 打印每一封邮件:</span>
    <span class="n">printMessage</span><span class="o">((</span><span class="nc">MimeMessage</span><span class="o">)</span> <span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span>
<span class="n">store</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>获取到一个<code class="language-plaintext highlighter-rouge">Message</code>对象时，可以强制转型为<code class="language-plaintext highlighter-rouge">MimeMessage</code>，然后打印出邮件主题、发件人、收件人等信息：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMessage</span><span class="o">(</span><span class="nc">MimeMessage</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">MessagingException</span> <span class="o">{</span>
    <span class="c1">// 邮件主题:</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Subject: "</span> <span class="o">+</span> <span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getSubject</span><span class="o">()));</span>
    <span class="c1">// 发件人:</span>
    <span class="nc">Address</span><span class="o">[]</span> <span class="n">froms</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">getFrom</span><span class="o">();</span>
    <span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InternetAddress</span><span class="o">)</span> <span class="n">froms</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"From: "</span> <span class="o">+</span> <span class="n">getAddressInfo</span><span class="o">(</span><span class="n">address</span><span class="o">));</span>
    <span class="c1">// 收件人（可以有多个）:</span>
    <span class="nc">InternetAddress</span><span class="o">[]</span> <span class="n">recipients</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InternetAddress</span><span class="o">[])</span> <span class="n">msg</span><span class="o">.</span><span class="na">getAllRecipients</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">InternetAddress</span> <span class="n">recipient</span> <span class="o">:</span> <span class="n">recipients</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Recipient: "</span> <span class="o">+</span> <span class="n">getAddressInfo</span><span class="o">(</span><span class="n">recipient</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">// 打印邮件内容</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
 * 获取InternetAddress的字符串形式
 * @param address 地址
 * @return 字符串
 * @throws UnsupportedEncodingException 字符编码不支持。
 */</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">getAddressInfo</span><span class="o">(</span><span class="nc">InternetAddress</span> <span class="n">address</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">personal</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">getPersonal</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">personal</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">address</span><span class="o">.</span><span class="na">getAddress</span><span class="o">()</span> <span class="o">:</span> <span class="o">(</span><span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">personal</span><span class="o">)</span> <span class="o">+</span> <span class="s">" &lt;"</span> <span class="o">+</span> <span class="n">address</span><span class="o">.</span><span class="na">getAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">"&gt;"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>获取邮件的正文，一个<code class="language-plaintext highlighter-rouge">MimeMessage</code>对象也是一个<code class="language-plaintext highlighter-rouge">Part</code>对象，它可能只包含一个文本，也可能是一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象，即由几个<code class="language-plaintext highlighter-rouge">Part</code>构成，因此，需要递归地解析出完整的正文：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 邮件内容
 * @param part 邮件部分内容
 * @return 字符串
 * @throws MessagingException
 * @throws IOException
 */</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">getBody</span><span class="o">(</span><span class="nc">Part</span> <span class="n">part</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是文本:</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"multipart/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是一个Multipart对象:</span>
        <span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Multipart</span><span class="o">)</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
        <span class="c1">// 循环解析每个子Part:</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">BodyPart</span> <span class="n">bodyPart</span> <span class="o">=</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getBodyPart</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">body</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p><strong>注意！网易邮箱对于IMAP协议收信有额外要求</strong>：<a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2eda07326646e6eb0">imap连接提示Unsafe Login，被阻止的收信行为</a></p><p>在<code class="language-plaintext highlighter-rouge">store.connect();</code>后面加上以下代码即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">IAM</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="s">"myname"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"version"</span><span class="o">,</span><span class="s">"1.0.0"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"vendor"</span><span class="o">,</span><span class="s">"myclient"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"support-email"</span><span class="o">,</span><span class="s">"testmail@test.com"</span><span class="o">);</span>
<span class="o">((</span><span class="nc">IMAPStore</span><span class="o">)</span><span class="n">store</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="no">IAM</span><span class="o">);</span>
</code></pre></div></div><p>发送IMAP ID命令（如果服务器支持）并从服务器返回结果。 ID命令向服务器标识客户端并将有关服务器的信息返回给客户端。</p><hr /><p><strong>获取最近的10封邮件：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取邮件文件夹</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_ONLY</span><span class="o">);</span>
<span class="c1">// 获取邮件总数</span>
<span class="kt">int</span> <span class="n">totalMessages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">();</span>
<span class="c1">// 计算要获取的起始邮件号和结束邮件号</span>
<span class="kt">int</span> <span class="n">startMessage</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">totalMessages</span> <span class="o">-</span> <span class="mi">9</span><span class="o">);</span> <span class="c1">// 最近的第一封邮件</span>
<span class="kt">int</span> <span class="n">endMessage</span> <span class="o">=</span> <span class="n">totalMessages</span><span class="o">;</span> <span class="c1">// 最近的最后一封邮件</span>
<span class="c1">// 获取最近的 10 封邮件</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">(</span><span class="n">startMessage</span><span class="o">,</span> <span class="n">endMessage</span><span class="o">);</span>
<span class="c1">// 关闭邮件文件夹</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><h3 id="保存附件">保存附件</h3><p>加个判断就行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">getBody</span><span class="o">(</span><span class="nc">Part</span> <span class="n">part</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是文本:</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"multipart/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是一个Multipart对象:</span>
        <span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Multipart</span><span class="o">)</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
        <span class="c1">// 循环解析每个子Part:</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">BodyPart</span> <span class="n">bodyPart</span> <span class="o">=</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getBodyPart</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">body</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 保存非文本类型的部分为文件</span>
            <span class="n">saveAttachment</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">saveAttachment</span><span class="o">(</span><span class="nc">BodyPart</span> <span class="n">bodyPart</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">bodyPart</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">bodyPart</span><span class="o">.</span><span class="na">getFileName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fileName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fileName</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="n">bodyPart</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
            <span class="nc">FileOutputStream</span> <span class="n">outputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bytesRead</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">outputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">outputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">inputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n已保存的附件: "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">fileName</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="删除邮件">删除邮件</h3><p><code class="language-plaintext highlighter-rouge">Folder</code> 类的删除方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">void open(int mode)</code>：打开邮件文件夹，并指定打开模式（只读、读写等）。</strong><ul><li><code class="language-plaintext highlighter-rouge">Folder.READ_ONLY</code>（值为 1）：只读模式，用于读取邮件但不能修改或删除邮件。</li><li><code class="language-plaintext highlighter-rouge">Folder.READ_WRITE</code>（值为 2）：读写模式，用于读取、修改和删除邮件。</li></ul></li><li><strong><code class="language-plaintext highlighter-rouge">void setFlags(Message[] msgs, Flags flag, boolean value)</code>：设置邮件的标志（例如，已读、已删除等）。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">Message[] expunge()</code>：清除标记为已删除的邮件，并返回已删除的邮件数组。</strong></li><li><code class="language-plaintext highlighter-rouge">void close(boolean expunge)</code>：关闭邮件文件夹，可选择是否删除已删除的邮件。</li></ul><hr /><p>在 JavaMail API 中，<code class="language-plaintext highlighter-rouge">Flags</code> 类表示邮件的标志。<code class="language-plaintext highlighter-rouge">Flags</code> 类提供了一些常量来表示不同的标志，可以使用这些常量来设置或检查邮件的标志。</p><p>构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags();</code>：创建一个空的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li><li><strong><code class="language-plaintext highlighter-rouge">Flags flags = new Flags(Flags.Flag flag);</code>：创建一个包含指定标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</strong></li><li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags(Flags flags);</code>：创建一个包含另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中所有标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li></ul><p>常用的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">void add(Flags.Flag flag)</code>：添加指定的标志。</strong></li><li><code class="language-plaintext highlighter-rouge">void add(Flags flags)</code>：添加另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li><li><code class="language-plaintext highlighter-rouge">boolean contains(Flags.Flag flag)</code>：检查是否存在指定的标志。</li><li><code class="language-plaintext highlighter-rouge">boolean containsAll(Flags flags)</code>：检查是否存在另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li><li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>：比较两个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象是否相等。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag[] getSystemFlags()</code>：返回系统定义的所有标志。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag[] getUserFlags()</code>：返回用户定义的所有标志。</li><li><code class="language-plaintext highlighter-rouge">int hashCode()</code>：返回 <code class="language-plaintext highlighter-rouge">Flags</code> 对象的哈希码值。</li><li><code class="language-plaintext highlighter-rouge">void remove(Flags.Flag flag)</code>：移除指定的标志。</li><li><code class="language-plaintext highlighter-rouge">void remove(Flags flags)</code>：移除另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li><li><code class="language-plaintext highlighter-rouge">void set(Flags.Flag flag, boolean value)</code>：设置指定标志的状态。</li><li><code class="language-plaintext highlighter-rouge">void setFlags(Flags.Flag[] flags, boolean value)</code>：设置指定一组标志的状态。</li><li><code class="language-plaintext highlighter-rouge">void setUserFlags(Flags flags)</code>：设置用户定义的标志。</li></ul><p>以下是 <code class="language-plaintext highlighter-rouge">Flags</code> 类中定义的一些常量：</p><ul><li><code class="language-plaintext highlighter-rouge">Flags.Flag.ANSWERED</code>：已回复标志，表示邮件已被回复。</li><li><strong><code class="language-plaintext highlighter-rouge">Flags.Flag.DELETED</code>：已删除标志，表示邮件已被标记为删除。</strong></li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.DRAFT</code>：草稿标志，表示邮件是草稿。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.FLAGGED</code>：已标记标志，表示邮件已被标记。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.RECENT</code>：最近标志，表示邮件是最近收到的。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.SEEN</code>：已读标志，表示邮件已被阅读。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.USER</code>：用户标志，表示用户定义的标志。</li></ul><p>可以使用这些常量来创建 <code class="language-plaintext highlighter-rouge">Flags</code> 对象，并将其传递给 <code class="language-plaintext highlighter-rouge">Folder.setFlags()</code> 方法来设置邮件的标志。例如，要创建一个包含已读和已回复标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象，可以使用以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">();</span>
<span class="n">flags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">SEEN</span><span class="o">);</span>
<span class="n">flags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">ANSWERED</span><span class="o">);</span>
</code></pre></div></div><hr /><p><strong>批量删除邮件：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取收件箱:</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="c1">// 以读写方式打开:</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">);</span>
<span class="c1">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getNewMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unread messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getUnreadMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getDeletedMessageCount</span><span class="o">());</span>
<span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">setFlags</span><span class="o">(</span><span class="n">messages</span><span class="o">,</span><span class="n">flags</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 关闭邮件文件夹并删除标记为删除的邮件</span>
</code></pre></div></div><p>实际上<code class="language-plaintext highlighter-rouge">Folder</code>的<code class="language-plaintext highlighter-rouge">setFlags</code>方法内部是这样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msgs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
    <span class="n">msgs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">setFlags</span><span class="o">(</span><span class="n">flag</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">MessageRemovedException</span> <span class="n">me</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This message is expunged, skip </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因此可以直接在单个<code class="language-plaintext highlighter-rouge">Message</code>上调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">);</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlags</span><span class="o">(</span><span class="n">flags</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="c1">//...</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 关闭邮件文件夹并删除标记为删除的邮件</span>
</code></pre></div></div><p>加<code class="language-plaintext highlighter-rouge">s</code>的表示可以设置多个，后面的<code class="language-plaintext highlighter-rouge">Boolean</code>值表示是设置还是取消，还可以通过<code class="language-plaintext highlighter-rouge">expunge()</code>方法删除。</p><p>试试用<code class="language-plaintext highlighter-rouge">folder.expunge();</code>删除标记为删除的邮件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">expunge</span><span class="o">();</span><span class="c1">//删除标记为删除的邮件</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭邮件文件夹</span>
</code></pre></div></div><p>提示：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> jakarta.mail.MethodNotSupportedException: Expunge not supported
</code></pre></div></div><p>在使用 POP3 协议时，<code class="language-plaintext highlighter-rouge">POP3Folder</code> 不支持 <code class="language-plaintext highlighter-rouge">expunge()</code> 方法，因此会抛出 <code class="language-plaintext highlighter-rouge">MethodNotSupportedException</code> 异常。因为 POP3 协议不支持在服务器上直接删除邮件，而是通过将邮件标记为删除，然后在下次会话中关闭连接时执行实际的删除操作。</p><p>如果需要在使用 POP3 协议时删除邮件，可以考虑以下方法：</p><ul><li>在读取邮件时，将要删除的邮件标记为删除，但不执行 <code class="language-plaintext highlighter-rouge">expunge()</code> 操作。最后调用 <code class="language-plaintext highlighter-rouge">close(true)</code> 方法来执行实际的删除操作。</li><li>使用其他支持邮件删除的协议，如 IMAP。IMAP 协议支持在服务器上直接删除邮件。</li></ul><p><strong>使用IMAP协议执行同样的代码：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">expunge</span><span class="o">();</span><span class="c1">//删除标记为删除的邮件</span>
<span class="c1">//...</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭邮件文件夹</span>
</code></pre></div></div><p>正常删除。</p><h2 id="http协议">HTTP协议</h2><p>HTTP是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p><p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p><p>当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code class="language-plaintext highlighter-rouge">80</code>端口和加密端口<code class="language-plaintext highlighter-rouge">443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。</p><p>HTTP请求的格式是固定的，由HTTP Header和HTTP Body两部分构成。第一行总是请求方法 路径 HTTP版本，例如，<code class="language-plaintext highlighter-rouge">GET / HTTP/1.1</code>表示使用<code class="language-plaintext highlighter-rouge">GET</code>请求，路径是<code class="language-plaintext highlighter-rouge">/</code>，版本是<code class="language-plaintext highlighter-rouge">HTTP/1.1</code>。</p><p>后续的每一行都是固定的<code class="language-plaintext highlighter-rouge">Header: Value</code>格式，即HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p><ul><li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li><li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li><li>Accept：表示客户端能处理的HTTP响应格式，<code class="language-plaintext highlighter-rouge">*/*</code>表示任意格式，<code class="language-plaintext highlighter-rouge">text/*</code>表示任意文本，<code class="language-plaintext highlighter-rouge">image/png</code>表示PNG格式的图片；</li><li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li></ul><p>如果是<code class="language-plaintext highlighter-rouge">GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code class="language-plaintext highlighter-rouge">POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

username=hello&amp;password=123456
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">POST</code>请求通常要设置<code class="language-plaintext highlighter-rouge">Content-Type</code>表示Body的类型，<code class="language-plaintext highlighter-rouge">Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p><p>此外，<code class="language-plaintext highlighter-rouge">GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code class="language-plaintext highlighter-rouge">http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code class="language-plaintext highlighter-rouge">a=1</code>和<code class="language-plaintext highlighter-rouge">b=K&amp;R</code>。因为URL的长度限制，<code class="language-plaintext highlighter-rouge">GET</code>请求的参数不能太多，而<code class="language-plaintext highlighter-rouge">POST</code>请求的参数就没有长度限制，因为<code class="language-plaintext highlighter-rouge">POST</code>请求的参数必须放到Body中。并且，<code class="language-plaintext highlighter-rouge">POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code class="language-plaintext highlighter-rouge">Content-Type</code>中正确设置即可。常见的发送JSON的<code class="language-plaintext highlighter-rouge">POST</code>请求如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /login HTTP/1.1
Content-Type: application/json
Content-Length: 38

{"username":"bob","password":"123456"}
</code></pre></div></div><p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 133251

&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
...
</code></pre></div></div><p>响应的第一行总是<code class="language-plaintext highlighter-rouge">HTTP版本 响应代码 响应说明</code>，例如，<code class="language-plaintext highlighter-rouge">HTTP/1.1 200 OK</code>表示版本是<code class="language-plaintext highlighter-rouge">HTTP/1.1</code>，响应代码是<code class="language-plaintext highlighter-rouge">200</code>，响应说明是<code class="language-plaintext highlighter-rouge">OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p><ul><li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于<code class="language-plaintext highlighter-rouge">WebSocket</code>连接；</li><li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li><li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li><li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li><li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li></ul><p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code class="language-plaintext highlighter-rouge">GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 18391

????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)
</code></pre></div></div><p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p><p>对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率。</p><p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p><p>所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收。因此HTTP/2.0进一步提高了效率。</p><hr /><p>URL（统一资源定位符）用于标识互联网上的资源位置，是 Web 中最常用的概念之一。它指定了资源的位置和访问方式。通常包含以下几个部分：</p><ol><li><strong>协议（Protocol）</strong>：指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。</li><li><strong>主机名（Host）</strong>：指定了资源所在的主机或服务器的域名或 IP 地址。</li><li><strong>端口（Port）</strong>：指定了访问服务器的端口号。如果未指定，默认为协议的默认端口。</li><li><strong>路径（Path）</strong>：指定了服务器上资源的路径。</li><li><strong>查询字符串（Query String）</strong>：包含了向服务器传递的参数信息。</li><li><strong>片段标识符（Fragment Identifier）</strong>：指定了资源中的特定部分。</li></ol><p>例如，对于 URL <code class="language-plaintext highlighter-rouge">https://www.example.com:8080/index.html?query=example#section1</code>，协议为 HTTPS，主机名为 <code class="language-plaintext highlighter-rouge">www.example.com</code>，端口号为 <code class="language-plaintext highlighter-rouge">8080</code>，路径为 <code class="language-plaintext highlighter-rouge">/index.html</code>，查询字符串为 <code class="language-plaintext highlighter-rouge">query=example</code>，片段标识符为 <code class="language-plaintext highlighter-rouge">section1</code>。</p><p>URL 在 Web 开发中广泛用于定位和访问 Web 页面、图像、视频等各种资源。</p><p><strong>URL类构造方法</strong></p><p><code class="language-plaintext highlighter-rouge">public URL(String spec);</code>：通过指定的字符串创建一个 URL 对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http://home.netscape.com/home/"</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">public URL(URL context, String spec);</code>：通过基于上下文 URL 和相对 URL 字符串创建一个 URL 对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u1</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http://home.netscape.com/home/"</span><span class="o">);</span>
<span class="no">URL</span> <span class="n">u2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="n">u1</span><span class="o">,</span> <span class="s">"welcome.html"</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">public URL(String protocol, String host, String file);</code>：通过指定协议、主机和文件路径创建一个 URL 对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u3</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http"</span><span class="o">,</span> <span class="s">"www.sun.com"</span><span class="o">,</span> <span class="s">"developers/index.html"</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">public URL(String protocol, String host, int port, String file);</code>：通过指定协议、主机、端口和文件路径创建一个 URL 对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">u4</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"http"</span><span class="o">,</span> <span class="s">"www.sun.com"</span><span class="o">,</span> <span class="mi">80</span><span class="o">,</span> <span class="s">"developers/index.html"</span><span class="o">);</span>
</code></pre></div></div><p>常用方法：</p><ul><li><code class="language-plaintext highlighter-rouge">String getProtocol()</code>: 获取 URL 的协议部分，例如 <code class="language-plaintext highlighter-rouge">http</code>、<code class="language-plaintext highlighter-rouge">https</code> 等。</li><li><code class="language-plaintext highlighter-rouge">String getHost()</code>: 获取 URL 的主机名部分。</li><li><code class="language-plaintext highlighter-rouge">int getPort()</code>: 获取 URL 的端口号部分。</li><li><code class="language-plaintext highlighter-rouge">String getPath()</code>: 获取 URL 的路径部分。</li><li><code class="language-plaintext highlighter-rouge">String getQuery()</code>: 获取 URL 的查询部分。</li><li><code class="language-plaintext highlighter-rouge">String getFile()</code>: 获取 URL 的文件名部分。</li><li><code class="language-plaintext highlighter-rouge">URLConnection openConnection()</code>: 打开与此 URL 的连接，并返回一个 <code class="language-plaintext highlighter-rouge">URLConnection</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">InputStream openStream()</code>: 打开与此 URL 的连接，并返回一个 <code class="language-plaintext highlighter-rouge">InputStream</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>: 比较此 URL 与指定对象是否相等。</li><li><code class="language-plaintext highlighter-rouge">String toString()</code>: 返回 URL 的字符串表示形式。</li></ul><hr /><p><strong><code class="language-plaintext highlighter-rouge">URLConnection</code>抽象类</strong></p><p><code class="language-plaintext highlighter-rouge">Uonnection</code>类支持<code class="language-plaintext highlighter-rouge">URL</code>连接的输入/输出流方式的通信,并可以获得<code class="language-plaintext highlighter-rouge">URL</code>对象资源的相关信息。它是所有应用程序和<code class="language-plaintext highlighter-rouge">URL</code>连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。</p><p>常用的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">void connect()</code>: 打开与 URL 引用的资源的通信链接。</strong></li><li><code class="language-plaintext highlighter-rouge">Object getContent()</code>: 获取此 URLConnection 的内容。</li><li><code class="language-plaintext highlighter-rouge">String getHeaderField(int n)</code>: 返回与此 URLConnection 的给定字段相关联的值。</li><li><code class="language-plaintext highlighter-rouge">long getLastModified()</code>: 获取指定资源的最后修改日期。</li><li><code class="language-plaintext highlighter-rouge">int getContentLength()</code>: 获取指定资源的内容长度。</li><li><code class="language-plaintext highlighter-rouge">String getContentType()</code>: 获取指定资源的内容类型。</li><li><strong><code class="language-plaintext highlighter-rouge">InputStream getInputStream()</code>: 返回一个输入流，用于从连接到 URL 的资源读取数据。</strong></li><li><code class="language-plaintext highlighter-rouge">OutputStream getOutputStream()</code>: 返回一个输出流，用于将数据写入到与 URLConnection 关联的资源。</li><li><strong><code class="language-plaintext highlighter-rouge">void setDoOutput(boolean dooutput)</code>: 将 doOutput 字段的值设置为指定值。</strong></li><li><code class="language-plaintext highlighter-rouge">void setDoInput(boolean doinput)</code>: 将 doInput 字段的值设置为指定值。</li><li><strong><code class="language-plaintext highlighter-rouge">void setRequestMethod(String method)</code>: 设置请求方法。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void setRequestProperty(String key, String value)</code>: 设置指定的请求头字段的值。</strong></li><li><code class="language-plaintext highlighter-rouge">void addRequestProperty(String key, String value)</code>: 添加一个请求属性。</li><li><code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;String&gt;&gt; getHeaderFields()</code>: 返回与此 URLConnection 关联的请求头字段的映射。</li><li><code class="language-plaintext highlighter-rouge">String getContentEncoding()</code>: 返回指定资源的内容编码。</li><li><code class="language-plaintext highlighter-rouge">int getConnectTimeout()</code>: 返回与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。</li><li><code class="language-plaintext highlighter-rouge">int getReadTimeout()</code>: 返回从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。</li><li><strong><code class="language-plaintext highlighter-rouge">void setConnectTimeout(int timeout)</code>: 设置与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。</strong></li><li><code class="language-plaintext highlighter-rouge">void setReadTimeout(int timeout)</code>: 设置从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。</li><li><strong><code class="language-plaintext highlighter-rouge">void setUseCaches(boolean usecaches)</code>: 如果连接上的 <code class="language-plaintext highlighter-rouge">UseCaches</code> 标志为 true，则允许该连接使用它可以使用的任何缓存。如果为 false，则忽略缓存。默认为true。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">HttpURLConnection</code> 是 <code class="language-plaintext highlighter-rouge">URLConnection</code> 的子类，提供了一些额外的方法，用于处理 HTTP 请求和响应。以下是 <code class="language-plaintext highlighter-rouge">HttpURLConnection</code> 比 <code class="language-plaintext highlighter-rouge">URLConnection</code> 多出的一些方法：</p><ul><li><code class="language-plaintext highlighter-rouge">getHeaderFieldKey(int n)</code>：返回指定索引处的响应头字段名称。</li><li><code class="language-plaintext highlighter-rouge">getHeaderField(int n)</code>：返回指定索引处的响应头字段的值。</li><li><strong><code class="language-plaintext highlighter-rouge">getHeaderFields()</code>：返回一个包含所有响应头字段的映射。</strong></li><li><code class="language-plaintext highlighter-rouge">getRequestMethod()</code>：返回此连接的请求方法。</li><li><code class="language-plaintext highlighter-rouge">setRequestMethod(String method)</code>：设置请求方法（如 GET、POST 等）。</li><li><strong><code class="language-plaintext highlighter-rouge">getResponseCode()</code>：获取 HTTP 响应代码。</strong></li><li><code class="language-plaintext highlighter-rouge">getResponseMessage()</code>：获取 HTTP 响应消息。</li><li><code class="language-plaintext highlighter-rouge">usingProxy()</code>：返回一个布尔值，指示是否通过代理进行连接。</li><li><code class="language-plaintext highlighter-rouge">disconnect()</code>：关闭连接并释放与该连接关联的所有系统资源。</li></ul><p>这些方法使得 <code class="language-plaintext highlighter-rouge">HttpURLConnection</code> 更适合处理 HTTP 请求和响应，而 <code class="language-plaintext highlighter-rouge">URLConnection</code> 则是更通用的类，可以处理不仅限于 HTTP 的多种协议。</p><hr /><p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而使用Java进行HTTP客户端编程仅限于获得响应内容。</p><p>示例：将<code class="language-plaintext highlighter-rouge">baidu</code>内容重定向到<code class="language-plaintext highlighter-rouge">Demo.txt</code></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"Demo.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">)));</span>
<span class="no">URL</span> <span class="n">url2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">);</span>
<span class="nc">URLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">url2</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setDoOutput</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">nextLine</span><span class="o">;</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
<span class="k">while</span> <span class="o">((</span><span class="n">nextLine</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">nextLine</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>详细点的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">URL</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">);</span>
<span class="nc">HttpURLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">HttpURLConnection</span><span class="o">)</span> <span class="n">url</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestMethod</span><span class="o">(</span><span class="s">"GET"</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setUseCaches</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setConnectTimeout</span><span class="o">(</span><span class="mi">5000</span><span class="o">);</span> <span class="c1">// 请求超时5秒</span>
<span class="c1">// 设置HTTP头:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestProperty</span><span class="o">(</span><span class="s">"Accept"</span><span class="o">,</span> <span class="s">"*/*"</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setRequestProperty</span><span class="o">(</span><span class="s">"User-Agent"</span><span class="o">,</span> <span class="s">"Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)"</span><span class="o">);</span>
<span class="c1">// 连接并发送HTTP请求:</span>
<span class="n">conn</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="c1">// 判断HTTP响应是否200:</span>
<span class="k">if</span> <span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getResponseCode</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">200</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"bad response"</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 获取所有响应Header:</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">getHeaderFields</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
<span class="o">}</span>
<span class="c1">// 获取响应内容:</span>
<span class="nc">String</span> <span class="n">nextLine</span><span class="o">;</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
<span class="k">while</span> <span class="o">((</span><span class="n">nextLine</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">nextLine</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">);</span>
<span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><hr /><p>从<strong>Java 11</strong>开始，引入了新的<code class="language-plaintext highlighter-rouge">HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。首先需要创建一个全局<code class="language-plaintext highlighter-rouge">HttpClient</code>实例，因为<code class="language-plaintext highlighter-rouge">HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">HttpClient</span> <span class="n">httpClient</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">HttpClient</span> <span class="n">httpClient</span> <span class="o">=</span> <span class="nc">HttpClient</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">URISyntaxException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">HttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">))</span>
            <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"User-Agent"</span><span class="o">,</span><span class="s">"Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Accept"</span><span class="o">,</span><span class="s">"*/*"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
            <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">HttpClient</span><span class="o">.</span><span class="na">Version</span><span class="o">.</span><span class="na">HTTP_2</span><span class="o">)</span>
            <span class="o">.</span><span class="na">GET</span><span class="o">()</span>
            <span class="o">.</span><span class="na">build</span><span class="o">();</span>

    <span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">httpClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">());</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()!=</span><span class="mi">200</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"bad response"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 获取所有响应Header:</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">headers</span><span class="o">().</span><span class="na">map</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">body</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><p>如果要获取图片这样的二进制内容，只需要把<code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers.ofString()</code>换成<code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code class="language-plaintext highlighter-rouge">HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code class="language-plaintext highlighter-rouge">InputStream</code>流。</p><p>如果要使用<code class="language-plaintext highlighter-rouge">POST</code>请求，需要准备好发送的Body数据并正确设置<code class="language-plaintext highlighter-rouge">Content-Type</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"http://www.example.com/login"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="s">"username=bob&amp;password=123456"</span><span class="o">;</span>
<span class="nc">HttpRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="nc">HttpRequest</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">(</span><span class="k">new</span> <span class="no">URI</span><span class="o">(</span><span class="n">url</span><span class="o">))</span>
    <span class="c1">// 设置Header:</span>
    <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Accept"</span><span class="o">,</span> <span class="s">"*/*"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Content-Type"</span><span class="o">,</span> <span class="s">"application/x-www-form-urlencoded"</span><span class="o">)</span>
    <span class="c1">// 设置超时:</span>
    <span class="o">.</span><span class="na">timeout</span><span class="o">(</span><span class="nc">Duration</span><span class="o">.</span><span class="na">ofSeconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
    <span class="c1">// 设置版本:</span>
    <span class="o">.</span><span class="na">version</span><span class="o">(</span><span class="nc">Version</span><span class="o">.</span><span class="na">HTTP_2</span><span class="o">)</span>
    <span class="c1">// 使用POST并设置Body:</span>
    <span class="o">.</span><span class="na">POST</span><span class="o">(</span><span class="nc">BodyPublishers</span><span class="o">.</span><span class="na">ofString</span><span class="o">(</span><span class="n">body</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)).</span><span class="na">build</span><span class="o">();</span>
<span class="nc">HttpResponse</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">response</span> <span class="o">=</span> <span class="n">httpClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="nc">HttpResponse</span><span class="o">.</span><span class="na">BodyHandlers</span><span class="o">.</span><span class="na">ofString</span><span class="o">());</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">body</span><span class="o">();</span>
</code></pre></div></div><hr /><p><code class="language-plaintext highlighter-rouge">HttpRequest</code> 类是 Java 11 中引入的，用于表示 HTTP 请求的类。以下是一些常用的 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 方法：</p><ul><li><code class="language-plaintext highlighter-rouge">builder(URI uri)</code>: 静态方法，返回一个新的 <code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 对象，用于构建 HTTP 请求。</li><li><code class="language-plaintext highlighter-rouge">method()</code>: 返回 HTTP 请求方法，如 GET、POST、PUT 等。</li><li><code class="language-plaintext highlighter-rouge">uri()</code>: 返回请求的 URI。</li><li><code class="language-plaintext highlighter-rouge">headers()</code>: 返回请求头信息，以 <code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;String&gt;&gt;</code> 的形式表示。</li><li><code class="language-plaintext highlighter-rouge">bodyPublisher()</code>: 返回请求体的发布器（<code class="language-plaintext highlighter-rouge">BodyPublisher</code>），用于发送请求体数据。</li><li><code class="language-plaintext highlighter-rouge">version()</code>: 返回 HTTP 协议版本。</li><li><code class="language-plaintext highlighter-rouge">expectContinue()</code>: 返回一个布尔值，指示是否期望服务器在发送响应之前先发送一个 100 Continue 响应。</li><li><code class="language-plaintext highlighter-rouge">timeout()</code>: 返回超时时间。</li><li><code class="language-plaintext highlighter-rouge">copy()</code>: 复制当前请求的副本。</li><li><code class="language-plaintext highlighter-rouge">toString()</code>: 将请求对象转换为字符串表示。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">HttpRequest</code> 类中的静态方法通常用于创建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 实例或处理 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 请求。以下是一些常用的静态方法：</p><ul><li><code class="language-plaintext highlighter-rouge">static HttpRequest.Builder newBuilder()</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 实例，用于构建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。</li><li><strong><code class="language-plaintext highlighter-rouge">static HttpRequest.Builder newBuilder(URI uri)</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 实例，并传入URI用于构建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。</strong></li><li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofByteArray(byte[] body)</code>：创建一个发布指定字节数组作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofInputStream(Supplier&lt;InputStream&gt; bodySupplier)</code>：创建一个发布从提供的 <code class="language-plaintext highlighter-rouge">InputStream</code> 读取数据作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofString(String body)</code>：创建一个发布指定字符串作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">static HttpRequest.BodyPublishers ofFile(Path file)</code>：创建一个发布指定文件内容作为请求主体的 <code class="language-plaintext highlighter-rouge">HttpRequest.BodyPublisher</code> 实例。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">HttpRequest.Builder</code> 类用于构建 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。以下是该类的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">GET()</code>：设置请求方法为 GET。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">POST(BodyPublisher bodyPublisher)</code>：设置请求方法为 POST，并指定请求体的发布器。</strong></li><li><code class="language-plaintext highlighter-rouge">PUT(BodyPublisher bodyPublisher)</code>：设置请求方法为 PUT，并指定请求体的发布器。</li><li><code class="language-plaintext highlighter-rouge">DELETE()</code>：设置请求方法为 DELETE。</li><li><strong><code class="language-plaintext highlighter-rouge">header(String name, String value)</code>：添加请求头。</strong></li><li><code class="language-plaintext highlighter-rouge">headers(Map&lt;String, List&lt;String&gt;&gt; headers)</code>：添加多个请求头。</li><li><code class="language-plaintext highlighter-rouge">method(String method)</code>：设置请求方法。</li><li><code class="language-plaintext highlighter-rouge">uri(URI uri)</code>：设置请求的 URI。</li><li><strong><code class="language-plaintext highlighter-rouge">version(HttpClient.Version version)</code>：设置 HTTP 协议版本。</strong></li><li><code class="language-plaintext highlighter-rouge">timeout(Duration duration)</code>：设置超时时间。</li><li><code class="language-plaintext highlighter-rouge">expectContinue(boolean enable)</code>：设置是否期望服务器在发送响应之前先发送一个 100 Continue 响应。</li><li><strong><code class="language-plaintext highlighter-rouge">build()</code>：构建并返回 <code class="language-plaintext highlighter-rouge">HttpRequest</code> 对象。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">URI</code> 类的构造方法如下：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">URI(String uri)</code>：根据给定的 URI 字符串创建 <code class="language-plaintext highlighter-rouge">URI</code> 对象。该字符串必须符合 URI 的语法规则。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">URI(String scheme, String ssp, String fragment)</code></strong>：使用指定的方案、特定部分和片段创建 <code class="language-plaintext highlighter-rouge">URI</code> 对象。方案和特定部分之间用冒号分隔。</li><li><strong><code class="language-plaintext highlighter-rouge">URI(String scheme, String userInfo, String host, int port, String path, String query, String fragment)</code></strong>：使用指定的参数创建 <code class="language-plaintext highlighter-rouge">URI</code> 对象。参数包括方案、用户信息、主机、端口、路径、查询和片段。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">Duration</code> 类表示一段时间的持续时间，它提供了用于处理持续时间的方法。以下是 <code class="language-plaintext highlighter-rouge">Duration</code> 类的一些主要方法：</p><ul><li><code class="language-plaintext highlighter-rouge">static Duration between(Temporal startInclusive, Temporal endExclusive)</code>：返回两个时间点之间的持续时间。</li><li><code class="language-plaintext highlighter-rouge">static Duration ofDays(long days)</code>：创建指定天数的持续时间。</li><li><code class="language-plaintext highlighter-rouge">static Duration ofHours(long hours)</code>：创建指定小时数的持续时间。</li><li><code class="language-plaintext highlighter-rouge">static Duration ofMinutes(long minutes)</code>：创建指定分钟数的持续时间。</li><li><strong><code class="language-plaintext highlighter-rouge">static Duration ofSeconds(long seconds)</code>：创建指定秒数的持续时间。</strong></li><li><code class="language-plaintext highlighter-rouge">static Duration ofMillis(long millis)</code>：创建指定毫秒数的持续时间。</li><li><code class="language-plaintext highlighter-rouge">static Duration ofNanos(long nanos)</code>：创建指定纳秒数的持续时间。</li><li><code class="language-plaintext highlighter-rouge">long toDays()</code>：获取持续时间的天数部分。</li><li><code class="language-plaintext highlighter-rouge">long toHours()</code>：获取持续时间的小时数部分。</li><li><code class="language-plaintext highlighter-rouge">long toMinutes()</code>：获取持续时间的分钟数部分。</li><li><code class="language-plaintext highlighter-rouge">long toSeconds()</code>：获取持续时间的秒数部分。</li><li><code class="language-plaintext highlighter-rouge">long toMillis()</code>：获取持续时间的毫秒数部分。</li><li><code class="language-plaintext highlighter-rouge">long toNanos()</code>：获取持续时间的纳秒数部分。</li><li><code class="language-plaintext highlighter-rouge">Duration plus(Duration duration)</code>：将另一个持续时间添加到此持续时间。</li><li><code class="language-plaintext highlighter-rouge">Duration minus(Duration duration)</code>：从此持续时间中减去另一个持续时间。</li><li><code class="language-plaintext highlighter-rouge">Duration multipliedBy(long multiplicand)</code>：将此持续时间乘以指定的数量。</li><li><code class="language-plaintext highlighter-rouge">Duration dividedBy(long divisor)</code>：将此持续时间除以指定的数量。</li><li><code class="language-plaintext highlighter-rouge">boolean isNegative()</code>：检查持续时间是否为负数。</li><li><code class="language-plaintext highlighter-rouge">boolean isZero()</code>：检查持续时间是否为零。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">HttpClient.Version</code> 是一个枚举类，表示 HTTP 客户端支持的协议版本。它包含以下字段：</p><ul><li><code class="language-plaintext highlighter-rouge">HTTP_1_1</code>：表示 HTTP/1.1 协议版本。</li><li><strong><code class="language-plaintext highlighter-rouge">HTTP_2</code>：表示 HTTP/2 协议版本。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">BodyPublishers</code> 类提供了以下静态方法来创建不同类型的 <code class="language-plaintext highlighter-rouge">BodyPublisher</code> 实例：</p><ul><li><code class="language-plaintext highlighter-rouge">ofByteArray(byte[] body)</code>：将指定的字节数组作为请求主体发送。</li><li><code class="language-plaintext highlighter-rouge">ofByteArrays(Iterable&lt;byte[]&gt; bodies)</code>：按顺序将多个字节数组作为请求主体发送。</li><li><code class="language-plaintext highlighter-rouge">ofFile(Path file)</code>：将指定文件的内容作为请求主体发送。</li><li><code class="language-plaintext highlighter-rouge">ofInputStream(Supplier&lt;? extends InputStream&gt; streamSupplier)</code>：从提供的 <code class="language-plaintext highlighter-rouge">InputStream</code> 中发送请求主体。</li><li><code class="language-plaintext highlighter-rouge">ofString(String body)</code>：将指定的字符串作为请求主体发送。</li><li><strong><code class="language-plaintext highlighter-rouge">ofString(String body, Charset charset)</code>：将指定的字符串以指定的字符集编码作为请求主体发送。</strong></li></ul><p>这些方法提供了灵活的方式来创建不同类型的请求主体，并使其适应于不同的请求场景。</p><hr /><p><code class="language-plaintext highlighter-rouge">HttpClient</code> 类提供了执行 HTTP 请求和处理 HTTP 响应的方法。以下是一些常用的方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">send(HttpRequest request, BodyHandler&lt;T&gt; responseBodyHandler)</code>：发送 HTTP 请求并返回响</strong>应。<code class="language-plaintext highlighter-rouge">request</code> 参数是要发送的请求，<code class="language-plaintext highlighter-rouge">responseBodyHandler</code> 参数指定如何处理响应主体。</li><li><code class="language-plaintext highlighter-rouge">sendAsync(HttpRequest request, BodyHandler&lt;T&gt; responseBodyHandler)</code>：异步发送 HTTP 请求并返回 <code class="language-plaintext highlighter-rouge">CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;</code>，可以在未来的某个时间点获取响应。</li><li><code class="language-plaintext highlighter-rouge">newBuilder()</code>：创建一个新的 <code class="language-plaintext highlighter-rouge">HttpClient.Builder</code> 实例，用于构建 <code class="language-plaintext highlighter-rouge">HttpClient</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">followRedirects()</code>：启用重定向（默认情况下启用）。</li><li><code class="language-plaintext highlighter-rouge">version()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的协议版本。</li><li><code class="language-plaintext highlighter-rouge">sslContext()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的 SSL 上下文。</li><li><code class="language-plaintext highlighter-rouge">proxy()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的代理。</li><li><code class="language-plaintext highlighter-rouge">authenticator()</code>：获取当前 <code class="language-plaintext highlighter-rouge">HttpClient</code> 实例使用的身份验证器。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">HttpResponse</code> 类表示 HTTP 响应，并提供了访问响应状态、头信息和主体的方法。以下是一些常用的方法：</p><ul><li><code class="language-plaintext highlighter-rouge">statusCode()</code>：返回响应的状态码。</li><li><code class="language-plaintext highlighter-rouge">body()</code>：返回响应的主体作为 <code class="language-plaintext highlighter-rouge">HttpResponse.BodySubscriber</code>。</li><li><code class="language-plaintext highlighter-rouge">headers()</code>：返回包含响应头信息的 <code class="language-plaintext highlighter-rouge">Map</code>。</li><li><code class="language-plaintext highlighter-rouge">bodyHandler()</code>：返回用于处理响应主体的 <code class="language-plaintext highlighter-rouge">BodyHandler</code>。</li><li><code class="language-plaintext highlighter-rouge">version()</code>：返回 HTTP 版本。</li><li><code class="language-plaintext highlighter-rouge">uri()</code>：返回请求的 URI。</li><li><code class="language-plaintext highlighter-rouge">request()</code>：返回生成此响应的请求。</li><li><code class="language-plaintext highlighter-rouge">previousResponse()</code>：如果重定向发生，则返回之前的响应。</li><li><code class="language-plaintext highlighter-rouge">sslSession()</code>：返回 SSL 会话。</li></ul><hr /><p><code class="language-plaintext highlighter-rouge">HttpResponse.BodyHandlers</code> 类是一个工具类，提供了一些静态方法用于创建不同类型的 <code class="language-plaintext highlighter-rouge">BodyHandler</code> 实例，以便处理 HTTP 响应主体。以下是一些常用的静态方法：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">ofString()</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体作为字符串处理。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">ofByteArray()</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体作为字节数组处理。</strong></li><li><code class="language-plaintext highlighter-rouge">ofInputStream()</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体作为输入流处理。</li><li><code class="language-plaintext highlighter-rouge">ofFile(Path file)</code>：返回一个 <code class="language-plaintext highlighter-rouge">BodyHandler</code>，用于将响应主体保存到指定文件。</li></ul><h2 id="rmi远程调用">RMI远程调用</h2><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p><p>提供服务的一方称之为服务器，而实现远程调用的一方称之为客户端。</p><p>服务器会提供一个<code class="language-plaintext highlighter-rouge">WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">LocalDateTime</span> <span class="nf">getLocalDateTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">zoneId</span><span class="o">);</span>
</code></pre></div></div><p>要实现RMI，服务器和客户端必须共享同一个接口。定义一个<code class="language-plaintext highlighter-rouge">WorldClock</code>接口，代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">WorldClock</span> <span class="kd">extends</span> <span class="nc">Remote</span> <span class="o">{</span>
    <span class="nc">LocalDateTime</span> <span class="nf">getLocalDateTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">zoneId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>Java的RMI规定此接口<strong>必须派生自<code class="language-plaintext highlighter-rouge">java.rmi.Remote</code></strong>，并在每个方法声明抛出<code class="language-plaintext highlighter-rouge">RemoteException</code>，因为远程方法调用缺乏本地调用的可靠性，远程调用总是存在失败的可能。</p><p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code class="language-plaintext highlighter-rouge">getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code class="language-plaintext highlighter-rouge">WorldClockService</code>代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WorldClockService</span> <span class="kd">implements</span> <span class="nc">WorldClock</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">LocalDateTime</span> <span class="nf">getLocalDateTime</span><span class="o">(</span><span class="nc">String</span> <span class="n">zoneId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">(</span><span class="nc">ZoneId</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">zoneId</span><span class="o">)).</span><span class="na">withNano</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>现在，服务器端的服务相关代码就编写完毕。需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"create World clock remote service..."</span><span class="o">);</span>
        <span class="c1">// 实例化一个WorldClock:</span>
        <span class="nc">WorldClock</span> <span class="n">worldClock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WorldClockService</span><span class="o">();</span>
        <span class="c1">// 将此服务转换为远程服务接口:</span>
        <span class="nc">WorldClock</span> <span class="n">skeleton</span> <span class="o">=</span> <span class="o">(</span><span class="nc">WorldClock</span><span class="o">)</span> <span class="nc">UnicastRemoteObject</span><span class="o">.</span><span class="na">exportObject</span><span class="o">(</span><span class="n">worldClock</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span><span class="c1">// 第二个参数为0，表明任何合适的端口都可用来监听客户连接。</span>
        <span class="c1">// 将RMI服务注册到1099端口:</span>
        <span class="nc">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="nc">LocateRegistry</span><span class="o">.</span><span class="na">createRegistry</span><span class="o">(</span><span class="mi">1099</span><span class="o">);</span>
        <span class="c1">// 注册此服务，服务名为"WorldClock":</span>
        <span class="n">registry</span><span class="o">.</span><span class="na">rebind</span><span class="o">(</span><span class="s">"WorldClock"</span><span class="o">,</span> <span class="n">skeleton</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code class="language-plaintext highlighter-rouge">WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code class="language-plaintext highlighter-rouge">1099</code>，最后一步注册服务时通过<code class="language-plaintext highlighter-rouge">rebind()</code>指定服务名称为<code class="language-plaintext highlighter-rouge">"WorldClock"</code>。</p><p>下一步就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此要把<code class="language-plaintext highlighter-rouge">WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span><span class="o">,</span> <span class="nc">NotBoundException</span> <span class="o">{</span>
        <span class="c1">// 连接到服务器localhost，端口1099:</span>
        <span class="nc">Registry</span> <span class="n">registry</span> <span class="o">=</span> <span class="nc">LocateRegistry</span><span class="o">.</span><span class="na">getRegistry</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">1099</span><span class="o">);</span>
        <span class="c1">// 查找名称为"WorldClock"的服务并强制转型为WorldClock接口:</span>
        <span class="nc">WorldClock</span> <span class="n">worldClock</span> <span class="o">=</span> <span class="o">(</span><span class="nc">WorldClock</span><span class="o">)</span> <span class="n">registry</span><span class="o">.</span><span class="na">lookup</span><span class="o">(</span><span class="s">"WorldClock"</span><span class="o">);</span>
        <span class="c1">// 正常调用接口方法:</span>
        <span class="nc">LocalDateTime</span> <span class="n">now</span> <span class="o">=</span> <span class="n">worldClock</span><span class="o">.</span><span class="na">getLocalDateTime</span><span class="o">(</span><span class="s">"Asia/Shanghai"</span><span class="o">);</span>
        <span class="c1">// 打印调用结果:</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">now</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。</p><p>对客户端来说，客户端持有的<code class="language-plaintext highlighter-rouge">WorldClock</code>接口实际上对应了一个“实现类”，它是由<code class="language-plaintext highlighter-rouge">Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code class="language-plaintext highlighter-rouge">WorldClockService</code>，而是<code class="language-plaintext highlighter-rouge">Registry</code>自动生成的代码。</p><p>把客户端的“实现类”称为<code class="language-plaintext highlighter-rouge">stub</code>，而服务器端的网络服务类称为<code class="language-plaintext highlighter-rouge">skeleton</code>，它会真正调用服务器端的<code class="language-plaintext highlighter-rouge">WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p><pre><code class="language-ascii">┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
  ┌─────────────┐                                 ┌─────────────┐
│ │   Service   │ │         │                     │   Service   │ │
  └─────────────┘                                 └─────────────┘
│        ▲        │         │                            ▲        │
         │                                               │
│        │        │         │                            │        │
  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐
│ │ Client Stub ├─┼─────────┼&gt;│Server Skeleton│──&gt;│Service Impl │ │
  └─────────────┘             └───────────────┘   └─────────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
</code></pre><p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p><p>Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a href="https://grpc.io/">gRPC</a>。</p><hr /><p><code class="language-plaintext highlighter-rouge">Remote</code>接口，用于标识那些方法可以从非本地虚拟机调用的接口。任何作为远程对象的对象必须直接或间接实现这个接口。</p><p><code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类是用于导出远程对象的抽象类。它提供了导出远程对象所需的基本功能。在Java RMI中，远程对象必须继承自 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类或调用 <code class="language-plaintext highlighter-rouge">exportObject</code> 方法来导出对象，以便能够被远程客户端访问。</p><p>实现类可以实现任意数量的远程接口，并且可以扩展其他远程实现类。RMI提供了一些便利类，远程对象实现可以扩展这些类以方便远程对象的创建。这些类包括<code class="language-plaintext highlighter-rouge">java.rmi.server.UnicastRemoteObject</code>和<code class="language-plaintext highlighter-rouge">java.rmi.activation.Activatable</code>。</p><p><code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类的作用包括：</p><ul><li>导出远程对象：通过继承 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类或调用 <code class="language-plaintext highlighter-rouge">exportObject</code> 方法，可以将一个普通的Java对象转换为远程对象，使其能够接收远程调用。</li><li>远程对象的生命周期管理：<code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类提供了一些方法用于管理远程对象的生命周期，如 <code class="language-plaintext highlighter-rouge">unexportObject</code> 方法用于取消导出远程对象。</li><li>RMI通信的基础支持：<code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类提供了与RMI通信相关的基础支持，如实现了 <code class="language-plaintext highlighter-rouge">Remote</code> 接口以标识远程对象，同时提供了一些内部实现用于处理远程调用。</li></ul><p><code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 类包含以下重要的方法：</p><ol><li><code class="language-plaintext highlighter-rouge">UnicastRemoteObject()</code>：构造一个新的 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">UnicastRemoteObject(int port)</code>：在指定端口上创建一个新的 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</code>：在指定端口上创建一个新的 <code class="language-plaintext highlighter-rouge">UnicastRemoteObject</code> 对象，使用指定的客户端和服务器端套接字工厂。</li><li><code class="language-plaintext highlighter-rouge">static RemoteStub exportObject(Remote obj)</code>：导出远程对象并返回其 stub。</li><li><strong><code class="language-plaintext highlighter-rouge">static RemoteStub exportObject(Remote obj, int port)</code>：导出远程对象并返回其 stub，在指定端口上监听。参数 <code class="language-plaintext highlighter-rouge">obj</code> 是要导出的远程对象，参数 <code class="language-plaintext highlighter-rouge">port</code> 是要监听的端口号。如果端口号为 0，则系统会自动选择一个可用的端口。</strong></li><li><code class="language-plaintext highlighter-rouge">static boolean unexportObject(Remote obj, boolean force)</code>：取消导出远程对象。</li><li><code class="language-plaintext highlighter-rouge">static Object toStub(Remote obj)</code>：返回远程对象的 stub。</li></ol><p>这些方法用于导出和管理远程对象，使其能够被远程客户端访问。</p><hr /><p><code class="language-plaintext highlighter-rouge">LocateRegistry</code> 类是 Java RMI 中用于定位远程注册表的工具类。它提供了一组静态方法，用于获取远程注册表的引用。<code class="language-plaintext highlighter-rouge">LocateRegistry</code> 类的方法包括：</p><p><code class="language-plaintext highlighter-rouge">LocateRegistry</code> 类的方法包括：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">static Registry getRegistry(String host, int port)</code>：返回指定主机和端口上的远程注册表引用。</strong></li><li><code class="language-plaintext highlighter-rouge">static Registry getRegistry(String host, int port, RMIClientSocketFactory csf)</code>：返回指定主机和端口上的远程注册表引用，并使用指定的客户端套接字工厂创建套接字连接。</li><li><code class="language-plaintext highlighter-rouge">static Registry getRegistry(String host, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf)</code>：返回指定主机和端口上的远程注册表引用，并使用指定的客户端套接字工厂和服务器套接字工厂创建套接字连接。</li><li><strong><code class="language-plaintext highlighter-rouge">static Registry createRegistry(int port)</code>：在本地主机上的指定端口上创建并返回远程注册表引用。</strong></li></ul><hr /><p><code class="language-plaintext highlighter-rouge">Registry</code> 类是 Java RMI 中的一个类，用于提供远程对象的注册和查找服务。它允许远程客户端查找和访问在远程主机上注册的远程对象。</p><p><code class="language-plaintext highlighter-rouge">Registry</code> 类的主要方法包括：</p><ul><li><code class="language-plaintext highlighter-rouge">void bind(String name, Remote obj)</code>：将指定的远程对象与指定的名称在此注册表中进行绑定。</li><li><code class="language-plaintext highlighter-rouge">void unbind(String name)</code>：从此注册表中移除指定名称的绑定。</li><li><strong><code class="language-plaintext highlighter-rouge">Remote lookup(String name)</code>：返回指定名称绑定的远程对象的引用。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">void rebind(String name, Remote obj)</code>：将指定的远程对象与指定的名称在此注册表中进行重新绑定。</strong></li><li><code class="language-plaintext highlighter-rouge">String[] list()</code>：返回此注册表中的所有绑定名称的数组。</li></ul><p>这些方法允许远程对象在注册表中注册、查找和解绑，从而实现了远程对象之间的通信和访问。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" target="_blank">https://acteds.github.io/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1735570737', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
