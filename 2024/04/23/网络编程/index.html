<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>网络编程 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="网络编程"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="网络编程"><meta name="og:description" content="网络编程"><meta property="og:url" content="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-04-23"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="网络编程"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">网络编程</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/04/23 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 54709 字，约 157 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="网络编程">网络编程</h1><p>常见服务和对应端口号</p><table><thead><tr><th>端口</th><th>对应服务</th></tr></thead><tbody><tr><td>7</td><td>Echo服务器</td></tr><tr><td>21</td><td>Ftp</td></tr><tr><td>23</td><td>telnet</td></tr><tr><td>25</td><td>SMTP</td></tr><tr><td>79</td><td>Finger</td></tr><tr><td>80</td><td>HTTP</td></tr><tr><td>110</td><td>POP3</td></tr><tr><td>143</td><td>IMAP</td></tr><tr><td>443</td><td>HTTPS</td></tr></tbody></table><h2 id="url类">URL类</h2><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">public URL(String spec);</code></td><td><code class="language-plaintext highlighter-rouge">URL u1 =new URL("http://home.netscape.com/home/");</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">public URL(URL context, String spec);</code></td><td><code class="language-plaintext highlighter-rouge">URL u2=new URL(u1, "welcome.html");</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">public URL(String protocol, String host, String file);</code></td><td><code class="language-plaintext highlighter-rouge">URL u3=new URL("http", "www.sun.com",developers/index.html");</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">public URL (String protocol, String host, int port, String file)</code></td><td><code class="language-plaintext highlighter-rouge">URL u4 = new URL("http", "www.sun.com", 80,"developers/index.html" );</code></td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">java.net.URL</code> 类提供了许多用于处理 URL 的方法。以下是一些常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">String getProtocol()</code></td><td>获取 URL 的协议部分，例如 <code class="language-plaintext highlighter-rouge">http</code>、<code class="language-plaintext highlighter-rouge">https</code> 等。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getHost()</code></td><td>获取 URL 的主机名部分。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">int getPort()</code></td><td>获取 URL 的端口号部分。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getPath()</code></td><td>获取 URL 的路径部分。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getQuery()</code></td><td>获取 URL 的查询部分。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getFile()</code></td><td>获取 URL 的文件名部分。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">URLConnection openConnection()</code></td><td>打开与此 URL 的连接，并返回一个 URLConnection 对象。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">InputStream openStream()</code></td><td>打开与此 URL 的连接，并返回一个 InputStream 对象。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code></td><td>比较此 URL 与指定对象是否相等。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String toString()</code></td><td>返回 URL 的字符串表示形式。</td></tr></tbody></table><h2 id="urlconnection抽象类">URLConnection抽象类</h2><p><code class="language-plaintext highlighter-rouge">Uonnection</code>类支持<code class="language-plaintext highlighter-rouge">URL</code>连接的输入/输出流方式的通信,并可以获得<code class="language-plaintext highlighter-rouge">URL</code>对象资源的相关信息。它是所有应用程序和<code class="language-plaintext highlighter-rouge">URL</code>连接通信类的父类。可以用它来输出、输入对象所表示的Intenet上的资源。</p><p>常用的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">void connect()</code></td><td>打开与 URL 引用的资源的通信链接。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">Object getContent()</code></td><td>获取此 URLConnection 的内容。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getHeaderField(int n)</code></td><td>返回与此 URLConnection 的给定字段相关联的值。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">long getLastModified()</code></td><td>获取指定资源的最后修改日期。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">int getContentLength()</code></td><td>获取指定资源的内容长度。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getContentType()</code></td><td>获取指定资源的内容类型。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">InputStream getInputStream()</code></td><td>返回一个输入流，用于从连接到 URL 的资源读取数据。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">OutputStream getOutputStream()</code></td><td>返回一个输出流，用于将数据写入到与 URLConnection 关联的资源。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void setDoOutput(boolean dooutput)</code></td><td>将 doOutput 字段的值设置为指定值。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void setDoInput(boolean doinput)</code></td><td>将 doInput 字段的值设置为指定值。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void setRequestMethod(String method)</code></td><td>设置请求方法。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void setRequestProperty(String key, String value)</code></td><td>设置指定的请求头字段的值。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void addRequestProperty(String key, String value)</code></td><td>添加一个请求属性。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">Map&lt;String, List&lt;String&gt;&gt; getHeaderFields()</code></td><td>返回与此 URLConnection 关联的请求头字段的映射。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">String getContentEncoding()</code></td><td>返回指定资源的内容编码。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">int getConnectTimeout()</code></td><td>返回与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">int getReadTimeout()</code></td><td>返回从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void setConnectTimeout(int timeout)</code></td><td>设置与此 URLConnection 建立的连接的超时时间（以毫秒为单位）。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">void setReadTimeout(int timeout)</code></td><td>设置从连接到 URLConnection 的资源的输入流读取数据的超时时间（以毫秒为单位）。</td></tr></tbody></table><p>示例：将baidu内容重定向到Demo.txt</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"Demo.txt"</span><span class="o">,</span> <span class="kc">true</span><span class="o">)));</span>
<span class="no">URL</span> <span class="n">url2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">URL</span><span class="o">(</span><span class="s">"https://www.baidu.com"</span><span class="o">);</span>
<span class="nc">URLConnection</span> <span class="n">conn</span> <span class="o">=</span> <span class="n">url2</span><span class="o">.</span><span class="na">openConnection</span><span class="o">();</span>
<span class="n">conn</span><span class="o">.</span><span class="na">setDoOutput</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">conn</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">nextLine</span><span class="o">;</span>
<span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">conn</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
<span class="k">while</span> <span class="o">((</span><span class="n">nextLine</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">nextLine</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
<span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><h2 id="tcp通信">TCP通信</h2><h3 id="socket概念">Socket概念</h3><p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<strong>特权端口</strong>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p><p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p><p>当Socket连接成功地在服务器端和客户端之间建立后：</p><ul><li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li><li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li></ul><p>Socket通常用来实现client-server连接。<code class="language-plaintext highlighter-rouge">java.net</code>包中定义的两个类<code class="language-plaintext highlighter-rouge">Socket</code>和<code class="language-plaintext highlighter-rouge">ServerSocket</code>,分别用来实现双向连接的<code class="language-plaintext highlighter-rouge">client</code>和<code class="language-plaintext highlighter-rouge">server</code>端.</p><p>创建<code class="language-plaintext highlighter-rouge">TCP Socket</code>需要的四个信息：</p><ul><li>本地系统的<code class="language-plaintext highlighter-rouge">IP</code></li><li>本地应用程序使用的<code class="language-plaintext highlighter-rouge">TCP</code>端口号</li><li>远程系统的<code class="language-plaintext highlighter-rouge">IP</code></li><li>远程应用程序相应的<code class="language-plaintext highlighter-rouge">TCP</code>端口号</li></ul><h3 id="inetaddress类">InetAddress类</h3><p>要获取<code class="language-plaintext highlighter-rouge">InetAddress</code> 类实例，可以使用其静态方法：</p><ol><li><code class="language-plaintext highlighter-rouge">InetAddress getByAddress(byte[] addr)</code>：根据原始 IP 地址获取 InetAddress 实例。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getByAddress(String host, byte[] addr)</code>：根据主机名和原始 IP 地址获取 InetAddress 实例。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getByName(String host)</code>：根据主机名获取 InetAddress 实例。</li><li><code class="language-plaintext highlighter-rouge">InetAddress[] getAllByName(String host)</code>：根据主机名获取所有与之关联的 InetAddress 实例数组。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getLocalHost()</code>：获取本地主机的 InetAddress 实例。</li></ol><p>这些静态方法可用于创建 InetAddress 实例，以便与网络通信。</p><p><code class="language-plaintext highlighter-rouge">InetAddress</code> 类的常用方法包括：</p><ol><li><code class="language-plaintext highlighter-rouge">getHostName()</code>：获取主机名。</li><li><code class="language-plaintext highlighter-rouge">getCanonicalHostName()</code>：获取主机的全限定域名。</li><li><code class="language-plaintext highlighter-rouge">getHostAddress()</code>：获取主机的 IP 地址字符串。</li><li><code class="language-plaintext highlighter-rouge">isReachable(int timeout)</code>：测试是否可以达到该主机，在指定的超时时间内。</li><li><code class="language-plaintext highlighter-rouge">isReachable(NetworkInterface netif, int ttl, int timeout)</code>：测试是否可以达到该主机，使用指定的网络接口和生存时间（TTL）。</li></ol><p>这些方法可用于获取主机名、IP 地址、测试主机的可达性等操作。</p><h3 id="socket类">Socket类</h3><p><strong>Socket类构造器</strong></p><ul><li><code class="language-plaintext highlighter-rouge">Socket()</code>: 创建一个未连接的Socket对象。</li><li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port, boolean stream)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，指定是否使用流模式。</li><li><code class="language-plaintext highlighter-rouge">Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</code>: 创建一个Socket对象，并将其连接到指定的远程地址和端口号，并绑定到指定的本地地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">Socket(String host, int port)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号。</li><li><code class="language-plaintext highlighter-rouge">Socket(String host, int port, boolean stream)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，指定是否使用流模式。</li><li><code class="language-plaintext highlighter-rouge">Socket(String host, int port, InetAddress localAddr, int localPort)</code>: 创建一个Socket对象，并将其连接到指定的远程主机名和端口号，并绑定到指定的本地地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>: 创建一个ServerSocket对象，绑定到指定的端口号。</li><li><code class="language-plaintext highlighter-rouge">ServerSocket(int port, int count)</code>: 创建一个ServerSocket对象，绑定到指定的端口号，并指定等待连接的队列长度。</li></ul><p><strong>Socket的常用方法</strong></p><ul><li><code class="language-plaintext highlighter-rouge">connect(SocketAddress endpoint)</code>: 连接到指定的远程端点。</li><li><code class="language-plaintext highlighter-rouge">getInputStream()</code>: 返回此套接字的输入流。</li><li><code class="language-plaintext highlighter-rouge">getOutputStream()</code>: 返回此套接字的输出流。</li><li><code class="language-plaintext highlighter-rouge">close()</code>: 关闭套接字连接。</li><li><code class="language-plaintext highlighter-rouge">isConnected()</code>: 返回套接字连接的状态。</li><li><code class="language-plaintext highlighter-rouge">isClosed()</code>: 返回套接字是否已关闭。</li><li><code class="language-plaintext highlighter-rouge">getInetAddress()</code>: 获取远程连接的IP地址。</li><li><code class="language-plaintext highlighter-rouge">getLocalAddress()</code>: 获取本地连接的IP地址。</li><li><code class="language-plaintext highlighter-rouge">getPort()</code>: 获取远程连接的端口号。</li><li><code class="language-plaintext highlighter-rouge">getLocalPort()</code>: 获取本地连接的端口号。</li><li><code class="language-plaintext highlighter-rouge">setSoTimeout(int timeout)</code>: 设置套接字的读取超时时间。</li><li><code class="language-plaintext highlighter-rouge">setKeepAlive(boolean on)</code>: 设置套接字是否在空闲时保持连接。</li><li><code class="language-plaintext highlighter-rouge">setTcpNoDelay(boolean on)</code>: 设置是否启用 Nagle 算法。</li></ul><h3 id="serversocket类">ServerSocket类</h3><p>ServerSocket类用于侦听一个客户端的Socket连接,如果没有连接,它将一直等待。</p><p><strong>ServerSocket构造器</strong></p><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code></td><td>用指定的端口<code class="language-plaintext highlighter-rouge">port</code>来创建一个侦听<code class="language-plaintext highlighter-rouge">Socket</code></td></tr><tr><td><code class="language-plaintext highlighter-rouge">ServerSocket(int port,int backlog)</code></td><td>加上一个用来改变连接队列长度的参数<code class="language-plaintext highlighter-rouge">backlog</code>.</td></tr><tr><td><code class="language-plaintext highlighter-rouge">ServerSocket(int port,int backlog,lnetAddress localAddr)</code></td><td>在机器存在多个<code class="language-plaintext highlighter-rouge">IP</code>地址的情况下,允许通过<code class="language-plaintext highlighter-rouge">localAddr</code>这个参数来指定侦听的<code class="language-plaintext highlighter-rouge">IP</code>地址。</td></tr></tbody></table><p><strong>ServerSocket类的常用方法包括</strong></p><ul><li><code class="language-plaintext highlighter-rouge">accept()</code>: 监听并接受到此套接字的连接。</li><li><code class="language-plaintext highlighter-rouge">bind(SocketAddress endpoint)</code>: 将套接字绑定到特定的本地地址和端口。</li><li><code class="language-plaintext highlighter-rouge">close()</code>: 关闭套接字。</li><li><code class="language-plaintext highlighter-rouge">getInetAddress()</code>: 返回此套接字的本地地址。</li><li><code class="language-plaintext highlighter-rouge">getLocalPort()</code>: 返回此套接字绑定的本地端口。</li><li><code class="language-plaintext highlighter-rouge">setSoTimeout(int timeout)</code>: 设置通过<code class="language-plaintext highlighter-rouge">accept()</code>方法接受客户端连接的超时时间。</li><li><code class="language-plaintext highlighter-rouge">getSoTimeout()</code>: 获取通过<code class="language-plaintext highlighter-rouge">accept()</code>方法接受客户端连接的超时时间。</li></ul><p>这些方法可用于管理ServerSocket的状态并与客户端进行通信。</p><h3 id="tcp使用实例">TCP使用实例</h3><p>服务端程序编写</p><ol><li>调用<code class="language-plaintext highlighter-rouge">ServerSocket(int port)</code>创建一个服务端套接字，并绑定到指定端口上；</li><li>调用<code class="language-plaintext highlighter-rouge">accept()</code>监听链接请求，如果客户端请求链接，则接受链接，返回通信套接字；</li><li>调用<code class="language-plaintext highlighter-rouge">socket</code>类的<code class="language-plaintext highlighter-rouge">getOutputStream()</code>和<code class="language-plaintext highlighter-rouge">getlnputStream()</code>获取输入流和输出流</li><li>关闭<code class="language-plaintext highlighter-rouge">socket</code>；</li></ol><p>客户端程序编写</p><ol><li>调用<code class="language-plaintext highlighter-rouge">Socket()</code>创建流套接字，并链接到服务端；</li><li>调用<code class="language-plaintext highlighter-rouge">socket</code>类的<code class="language-plaintext highlighter-rouge">getOutputStream()</code>和<code class="language-plaintext highlighter-rouge">getInputStream()</code>获取输入流和输出流；</li><li>关闭<code class="language-plaintext highlighter-rouge">socket</code>；</li></ol><p>客户端Socket的建立，链接服务器。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>服务器端Socket的建立</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"can not listen to :"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
        <span class="nc">Socket</span> <span class="n">socket</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="n">socket</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Error:"</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>打开输入/出流</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PrintStream</span> <span class="n">os</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="k">new</span> <span class="nc">BufferedOutputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>  
<span class="nc">DataInputStream</span> <span class="n">is</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">socket</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">());</span>
</code></pre></div></div><p>关闭Socket</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">os</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="n">is</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="n">socket</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>简单的<code class="language-plaintext highlighter-rouge">client</code>/<code class="language-plaintext highlighter-rouge">server</code>程序</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ConnectException</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.ServerSocket</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.net.Socket</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Server1</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"resource"</span><span class="o">)</span>  
            <span class="nc">ServerSocket</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">8888</span><span class="o">);</span>  
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>  
                <span class="nc">Socket</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>  
                <span class="nc">OutputStream</span> <span class="n">os</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>  
                <span class="nc">DataOutputStream</span> <span class="n">dos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataOutputStream</span><span class="o">(</span><span class="n">os</span><span class="o">);</span>  
                <span class="n">dos</span><span class="o">.</span><span class="na">writeUTF</span><span class="o">(</span><span class="s">"Hello,"</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">getInetAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">"port#"</span> <span class="o">+</span> <span class="n">s1</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">"bye-bye!"</span><span class="o">);</span>  
                <span class="n">dos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
                <span class="n">s1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
                <span class="c1">// s.close();  </span>
            <span class="o">}</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Client1</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="nc">Socket</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"127.0.0.1"</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>  
            <span class="nc">InputStream</span> <span class="n">is</span> <span class="o">=</span><span class="n">s1</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>  
            <span class="nc">DataInputStream</span> <span class="n">dis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DataInputStream</span><span class="o">(</span><span class="n">is</span><span class="o">);</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dis</span><span class="o">.</span><span class="na">readUTF</span><span class="o">());</span>  
            <span class="n">dis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
            <span class="n">s1</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ConnectException</span> <span class="n">connExc</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"服务器连接失败！"</span><span class="o">);</span>  
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>先运行服务器,然后运行客户端,会收到服务器发的信息.</p><p>例子二</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServerSocket</span> <span class="n">server</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">1234</span><span class="o">);</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Socket</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">server</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
                <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">()));</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好，端口"</span> <span class="o">+</span> <span class="n">sk</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span> <span class="s">"，你成功连接了服务器："</span> <span class="o">+</span> <span class="n">server</span><span class="o">.</span><span class="na">getLocalPort</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getPort</span><span class="o">()</span> <span class="o">+</span><span class="s">":"</span><span class="o">+</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">server</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Client1</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">client</span><span class="o">;</span>
        <span class="nc">PrintStream</span> <span class="n">ps</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">1234</span><span class="o">);</span>
            <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">()));</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintStream</span><span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">());</span>
            <span class="n">ps</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"哦，真好！"</span><span class="o">);</span>
            <span class="n">ps</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
            <span class="n">client</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>例子三：</p><p>服务端：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Server</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">ServerSocket</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="mi">6666</span><span class="o">);</span> <span class="c1">// 监听指定端口</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"服务器正在运行..."</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
            <span class="nc">Socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span><span class="c1">//每有一个新客户端就返回一个Socket</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"connected from "</span> <span class="o">+</span> <span class="n">sock</span><span class="o">.</span><span class="na">getRemoteSocketAddress</span><span class="o">());</span>
            <span class="c1">// 用新线程处理</span>
            <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()-&gt;{</span>
                <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
                     <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">()</span>
                <span class="o">)</span> <span class="o">{</span>
                    <span class="nc">BufferedWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
                    <span class="nc">BufferedReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"你好!\n"</span><span class="o">);</span><span class="c1">//注意加换行符，要不然客户端不会结束读取。</span>
                    <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span><span class="c1">//若没有新内容则阻塞。</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"再见"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"再见\n"</span><span class="o">);</span>
                            <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                            <span class="k">break</span><span class="o">;</span><span class="c1">//结束线程</span>
                        <span class="o">}</span>
                        <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"好的: "</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                        <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">sock</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">ioe</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">}</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"客户端已断开连接."</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>代码<code class="language-plaintext highlighter-rouge">ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code class="language-plaintext highlighter-rouge">Socket</code>实例，这个<code class="language-plaintext highlighter-rouge">Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，就必须为每个新的<code class="language-plaintext highlighter-rouge">Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p><p>如果没有客户端连接进来，<code class="language-plaintext highlighter-rouge">accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code class="language-plaintext highlighter-rouge">ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code class="language-plaintext highlighter-rouge">accept()</code>就可以获取新的连接。</p><p>客户端：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Socket</span> <span class="n">sock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Socket</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">,</span> <span class="mi">6666</span><span class="o">);</span> <span class="c1">// 连接指定服务器端口</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
             <span class="nc">OutputStream</span> <span class="n">output</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">var</span> <span class="n">writer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">output</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="kt">var</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
            <span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[服务器] "</span> <span class="o">+</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"&gt;&gt;&gt; "</span><span class="o">);</span> <span class="c1">// 打印提示</span>
                <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span> <span class="c1">// 读取一行输入</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">newLine</span><span class="o">();</span><span class="c1">//换行符</span>
                <span class="n">writer</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
                <span class="nc">String</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span><span class="c1">// 若没有新内容则阻塞。</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"&lt;&lt;&lt; "</span> <span class="o">+</span> <span class="n">resp</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"再见"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">sock</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"断开连接."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当Socket连接创建成功后，无论是服务器端，还是客户端，都使用<code class="language-plaintext highlighter-rouge">Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code class="language-plaintext highlighter-rouge">InputStream</code>和<code class="language-plaintext highlighter-rouge">OutputStream</code>来封装Socket的数据流，这样使用Socket的流，和普通IO流类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用于读取网络数据:</span>
<span class="nc">InputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
<span class="c1">// 用于写入网络数据:</span>
<span class="nc">OutputStream</span> <span class="n">out</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="na">getOutputStream</span><span class="o">();</span>
</code></pre></div></div><p>如果不调用<code class="language-plaintext highlighter-rouge">flush()</code>，很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而又想强制把这些数据发送到网络，就必须调用<code class="language-plaintext highlighter-rouge">flush()</code>强制把缓冲区数据发送出去。</p><h3 id="url与socket通信的区别">URL与Socket通信的区别</h3><p>利用<code class="language-plaintext highlighter-rouge">URL</code>进行通信与利用<code class="language-plaintext highlighter-rouge">socket</code>进行通信有许多相似之处。它们都是利用建立连接、获取流来进行通信。它们的区别在：</p><p>利用<code class="language-plaintext highlighter-rouge">socket</code>进行通信时，在服务器端运行一个<code class="language-plaintext highlighter-rouge">socket</code>通信程序。服务器端不停地监听某个端口，等待客户的连接申请，接到申请后建立连接并进行通信，所以，在<code class="language-plaintext highlighter-rouge">socket</code>通信方式中，服务器是主动等待连接通信的到来。</p><p>利用<code class="language-plaintext highlighter-rouge">URL</code>进行通信时，在服务器端常驻一个<code class="language-plaintext highlighter-rouge">CGI</code>程序，但它一直处于休眠状态。只有在客户端要求建立连接时才被激活，然后点用户进行通信。所以，在<code class="language-plaintext highlighter-rouge">URL</code>通信方式中，服务器是被动等待连接通信的到来。</p><h2 id="udp通信">UDP通信</h2><p>在基于<code class="language-plaintext highlighter-rouge">TCP/IP</code>网络体系结构的网络中主要使用<code class="language-plaintext highlighter-rouge">TCP</code>和<code class="language-plaintext highlighter-rouge">UDP</code>（<code class="language-plaintext highlighter-rouge">UserDatagramProtocol</code>，用户数据报协议）来实现数据通信。<code class="language-plaintext highlighter-rouge">TCP</code>是一种面向连接可靠的传输，它能确保数据传送正确到达目的端；而<code class="language-plaintext highlighter-rouge">UDP</code>则是一种面向无连接的不可靠传输协议，它<strong>不能</strong>确保数据能正确到达目的端，但是它能<strong>提高网络通信的效率</strong>。</p><p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p><p><strong>UDP Socket特性</strong></p><p>通过UDP的UDP端口来实现UDP协议的网络通信。</p><p>其工作过程如下：</p><ul><li>创建一个适当的要发送且注明收发人地址数据报；</li><li>为一个特定的应用程序建立一个传输端口来传送和接收数据包；</li><li>将数据报插入一个传输端口中进行传输；</li><li>等待接收来自于传输端口的一个数据报；</li><li>解码数据报以解开消息、接收者和其它信息；</li></ul><h3 id="datagramsocket类">DatagramSocket类</h3><p><code class="language-plaintext highlighter-rouge">DatagramSocket</code> 类是用于实现 UDP 协议的套接字。</p><p>构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">DatagramSocket()</code>：通常用于客户端编程，它并没有特定监听的端囗，仅仅使用一个临时的。程序会让操作系统分配一个可用的端口。（使用这个构造方法时，系统会分配给他一个空闲的端口，但是也可以自己指定一个）</li><li><code class="language-plaintext highlighter-rouge">DatagramSocket(int port)</code>：创建实例，并固定监听<code class="language-plaintext highlighter-rouge">Port</code>端口的报文。通常用于服务端</li><li><code class="language-plaintext highlighter-rouge">DatagramSocket(int port,InetAddress localAddr)</code>：这是个非常有用的构建器，当一台机器拥有多于一个IP地址的时候，由它创建的实例仅仅接收来自<code class="language-plaintext highlighter-rouge">LocalAddr</code>的报文。</li></ul><p>方法：</p><ol><li><code class="language-plaintext highlighter-rouge">void bind(SocketAddress addr)</code>：将套接字绑定到指定的本地地址和端口号。</li><li><code class="language-plaintext highlighter-rouge">void close()</code>：关闭套接字。</li><li><code class="language-plaintext highlighter-rouge">void connect(InetAddress address, int port)</code>：将套接字连接到指定的远程主机和端口号。</li><li><code class="language-plaintext highlighter-rouge">void disconnect()</code>：断开与远程主机的连接。</li><li><code class="language-plaintext highlighter-rouge">boolean getBroadcast()</code>：获取套接字的广播状态。</li><li><code class="language-plaintext highlighter-rouge">Object getOption(int optID)</code>：获取套接字选项的当前值。</li><li><code class="language-plaintext highlighter-rouge">int getPort()</code>：获取套接字绑定的本地端口号。</li><li><code class="language-plaintext highlighter-rouge">SocketAddress getLocalSocketAddress()</code>：获取套接字绑定的本地地址。</li><li><code class="language-plaintext highlighter-rouge">InetAddress getLocalAddress()</code>：获取套接字绑定的本地 IP 地址。</li><li><code class="language-plaintext highlighter-rouge">int getLocalPort()</code>：获取套接字绑定的本地端口号。</li><li><code class="language-plaintext highlighter-rouge">SocketAddress getRemoteSocketAddress()</code>：获取套接字连接的远程地址。</li><li><code class="language-plaintext highlighter-rouge">boolean isBound()</code>：检查套接字是否绑定到本地地址。</li><li><code class="language-plaintext highlighter-rouge">boolean isConnected()</code>：检查套接字是否连接到远程主机。</li><li><code class="language-plaintext highlighter-rouge">void receive(DatagramPacket p)</code>：接收一个数据包。</li><li><code class="language-plaintext highlighter-rouge">void send(DatagramPacket p)</code>：发送一个数据包。</li><li><code class="language-plaintext highlighter-rouge">void setBroadcast(boolean on)</code>：设置套接字的广播状态。</li><li><code class="language-plaintext highlighter-rouge">void setOption(int optID, Object value)</code>：设置套接字选项的值。</li><li><code class="language-plaintext highlighter-rouge">void setSoTimeout(int timeout)</code>：设置套接字的超时时间（接收数据时的超时时间）。</li><li><code class="language-plaintext highlighter-rouge">int getSoTimeout()</code>：获取套接字的超时时间。</li><li><code class="language-plaintext highlighter-rouge">String toString()</code>：返回套接字的字符串表示形式。</li></ol><hr /><h3 id="datagrampacket类">DatagramPacket类</h3><p><code class="language-plaintext highlighter-rouge">DatagramPacket</code> 类表示数据报包，它包含了要发送或接收的数据以及目标地址和端口号等信息。</p><p>常用构造方法：</p><ul><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据，数据存储在 <code class="language-plaintext highlighter-rouge">buf</code> 中。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, InetAddress address, int port)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据到指定的地址和端口。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据到指定的地址和端口。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int length, SocketAddress address)</code>: 创建一个数据报包，用于发送长度为 <code class="language-plaintext highlighter-rouge">length</code> 的数据到指定的地址和端口。</li><li><code class="language-plaintext highlighter-rouge">DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</code>: 创建一个数据报包，用于发送从 <code class="language-plaintext highlighter-rouge">buf</code> 的偏移量 <code class="language-plaintext highlighter-rouge">offset</code> 开始的 <code class="language-plaintext highlighter-rouge">length</code> 长度的数据到指定的地址和端口。</li></ul><p>这些构造方法可以用于创建不同类型的数据报包，以便发送或接收数据。</p><p><code class="language-plaintext highlighter-rouge">DatagramPacket</code> 类的常用方法包括：</p><ul><li><code class="language-plaintext highlighter-rouge">getData()</code>: 返回数据报包中的数据字节数组。</li><li><code class="language-plaintext highlighter-rouge">getLength()</code>: 返回数据报包中数据的长度。</li><li><code class="language-plaintext highlighter-rouge">getAddress()</code>: 返回数据报包的目标地址。</li><li><code class="language-plaintext highlighter-rouge">getPort()</code>: 返回数据报包的目标端口号。</li><li><code class="language-plaintext highlighter-rouge">setData(byte[] buf)</code>: 设置数据报包的数据字节数组。</li><li><code class="language-plaintext highlighter-rouge">setLength(int length)</code>: 设置数据报包的数据长度。</li><li><code class="language-plaintext highlighter-rouge">setAddress(InetAddress address)</code>: 设置数据报包的目标地址。</li><li><code class="language-plaintext highlighter-rouge">setPort(int port)</code>: 设置数据报包的目标端口号。</li><li><code class="language-plaintext highlighter-rouge">getSocketAddress()</code>: 返回数据报包的套接字地址。</li><li><code class="language-plaintext highlighter-rouge">setSocketAddress(SocketAddress address)</code>: 设置数据报包的套接字地址。</li></ul><p>这些方法可以在数据报包中读取和设置数据，以及获取目标地址和端口号等信息。</p><hr /><h3 id="udp使用实例">UDP使用实例</h3><p>在服务器端，使用UDP也需要监听指定的端口。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">(</span><span class="mi">6666</span><span class="o">);</span> <span class="c1">// 监听指定端口</span>
<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span> <span class="c1">// 无限循环</span>
    <span class="c1">// 数据缓冲区:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
    <span class="nc">DatagramPacket</span> <span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
    <span class="n">ds</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span> <span class="c1">// 收取一个UDP数据包,阻塞</span>
    <span class="c1">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度，将其按UTF-8编码转换为String:</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getOffset</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getLength</span><span class="o">(),</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="c1">// 发送数据:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"ACK"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
    <span class="n">packet</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">//设置数据包。</span>
    <span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">//发送</span>
<span class="o">}</span>
</code></pre></div></div><p>当服务器收到一个<code class="language-plaintext highlighter-rouge">DatagramPacket</code>后，通常必须立刻回复一个或多个UDP包，因为客户端地址在<code class="language-plaintext highlighter-rouge">DatagramPacket</code>中，每次收到的<code class="language-plaintext highlighter-rouge">DatagramPacket</code>可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。UDP 是无连接的协议，服务器在接收到 UDP 数据报后，通常需要<strong>立即</strong>给客户端发送响应，以确保通信的连续性和可靠性。没有响应的话，客户端<strong>可能会超时或者认为连接失败</strong>。</p><p>客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">();</span>
<span class="n">ds</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span><span class="c1">//设置超时时间</span>
<span class="n">ds</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="nc">InetAddress</span><span class="o">.</span><span class="na">getByName</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">),</span> <span class="mi">6666</span><span class="o">);</span> <span class="c1">// 连接指定服务器和端口</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="nc">DatagramPacket</span> <span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">// 发送</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
<span class="n">packet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">receive</span><span class="o">(</span><span class="n">packet</span><span class="o">);</span><span class="c1">// 收取一个UDP数据包,阻塞,超过超时时间则异常</span>
<span class="nc">String</span> <span class="n">resp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">packet</span><span class="o">.</span><span class="na">getData</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getOffset</span><span class="o">(),</span> <span class="n">packet</span><span class="o">.</span><span class="na">getLength</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">resp</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span><span class="c1">// 关闭</span>
<span class="n">ds</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>客户端创建<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code class="language-plaintext highlighter-rouge">setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p><p>客户端的<code class="language-plaintext highlighter-rouge">DatagramSocket</code>还调用了一个<code class="language-plaintext highlighter-rouge">connect()</code>方法“连接”到指定的服务器端。</p><p>这个<code class="language-plaintext highlighter-rouge">connect()</code>方法不是真连接，它是为了在客户端的<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p><p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p><p>如果客户端认为通信结束，就可以调用<code class="language-plaintext highlighter-rouge">disconnect()</code>断开连接：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ds</span><span class="o">.</span><span class="na">disconnect</span><span class="o">();</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例就可以连接另一个服务器端。</p><p>如果客户端希望向两个不同的服务器发送UDP包，有两种方法：</p><ol><li>客户端可以创建两个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例，用<code class="language-plaintext highlighter-rouge">connect()</code>连接到不同的服务器；</li><li>客户端也可以不调用<code class="language-plaintext highlighter-rouge">connect()</code>方法，而是在创建<code class="language-plaintext highlighter-rouge">DatagramPacket</code>的时候指定服务器地址，这样可以用一个<code class="language-plaintext highlighter-rouge">DatagramSocket</code>实例发送<code class="language-plaintext highlighter-rouge">DatagramPacket</code>到不同的服务器。</li></ol><p>不调用<code class="language-plaintext highlighter-rouge">connect()</code>方法的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DatagramSocket</span> <span class="n">ds</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramSocket</span><span class="o">();</span>
<span class="n">ds</span><span class="o">.</span><span class="na">setSoTimeout</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
<span class="nc">InetAddress</span> <span class="n">localhost</span> <span class="o">=</span> <span class="nc">InetAddress</span><span class="o">.</span><span class="na">getByName</span><span class="o">(</span><span class="s">"localhost"</span><span class="o">);</span>
<span class="c1">// 发送到localhost:6666:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">packet1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data1</span><span class="o">,</span> <span class="n">data1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">localhost</span><span class="o">,</span> <span class="mi">6666</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet1</span><span class="o">);</span>
<span class="c1">// 发送到localhost:8888:</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">data2</span> <span class="o">=</span> <span class="s">"Hi"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">packet2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DatagramPacket</span><span class="o">(</span><span class="n">data2</span><span class="o">,</span> <span class="n">data2</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">localhost</span><span class="o">,</span> <span class="mi">8888</span><span class="o">);</span>
<span class="n">ds</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">packet2</span><span class="o">);</span>
<span class="c1">// 关闭:</span>
<span class="n">ds</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><h2 id="发送email">发送Email</h2><p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code class="language-plaintext highlighter-rouge">abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p><p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p><p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p><pre><code class="language-ascii">           ┌──────────┐    ┌──────────┐
           │PostOffice│    │PostOffice│     .───.
┌─────┐    ├──────────┤    ├──────────┤    (   ( )
│═══ ░│──▶│ ┌─┐ ┌┐┌┐  │──▶│ ┌─┐ ┌┐┌┐ │──▶ `─┬─'
└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
           └─┴─┴──────┘    └─┴─┴──────┘       │
</code></pre><p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p><pre><code class="language-ascii">             ┌─────────┐    ┌─────────┐    ┌─────────┐
             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
│       │──▶│O ░░░░░░░│───▶│O ░░░░░░░│───▶│O ░░░░░░░│◀──│       │
└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
   MUA           MTA            MTA            MDA           MUA
</code></pre><p>类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；</p><p>邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；</p><p>最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。</p><p>电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p><p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p><p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p><p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，无需关心SMTP协议的底层原理，只需要使用<code class="language-plaintext highlighter-rouge">JavaMail</code>这个标准API就可以直接发送邮件。</p><hr /><p>假设准备使用自己的邮件地址<code class="language-plaintext highlighter-rouge">me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code class="language-plaintext highlighter-rouge">xiaoming@somewhere.com</code>，发送邮件前，首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code class="language-plaintext highlighter-rouge">smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p><ul><li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；</li><li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li><li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。</li></ul><p>有了SMTP服务器的域名和端口号，还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p><p>使用<code class="language-plaintext highlighter-rouge">JavaMail</code>发送邮件，需要把<code class="language-plaintext highlighter-rouge">JavaMail</code>相关的两个依赖加入进来，注意版本号相同：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/jakarta.mail/jakarta.mail-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>jakarta.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jakarta.mail-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.sun.mail/jakarta.mail --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.sun.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>jakarta.mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.1<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>这两个包一个是接口定义，一个是具体实现。如果使用早期的1.x版本，则需注意引入的包名有所不同：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/javax.mail/javax.mail-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>javax.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.mail-api<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
<span class="c">&lt;!-- https://mvnrepository.com/artifact/com.sun.mail/javax.mail --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.sun.mail<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>javax.mail<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.6.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p>并且代码引用的<code class="language-plaintext highlighter-rouge">jakarta.mail</code>需替换为<code class="language-plaintext highlighter-rouge">javax.mail</code>。</p><hr /><h3 id="验证发送方信息">验证发送方信息</h3><p><code class="language-plaintext highlighter-rouge">Session</code>类是<code class="language-plaintext highlighter-rouge">JavaMail</code> API中表示邮件会话的类，它包含了创建和管理邮件的相关方法。以下是<code class="language-plaintext highlighter-rouge">Session</code>类的一些常用方法：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">getSession(Properties props, Authenticator authenticator)</code>：静态方法，用于获取<code class="language-plaintext highlighter-rouge">Session</code>实例。需要传入<code class="language-plaintext highlighter-rouge">Properties</code>对象和<code class="language-plaintext highlighter-rouge">Authenticator</code>对象来配置会话属性和认证信息。</strong></li><li><code class="language-plaintext highlighter-rouge">getTransport(String protocol)</code>：获取指定协议的<code class="language-plaintext highlighter-rouge">Transport</code>对象，用于发送邮件。</li><li><code class="language-plaintext highlighter-rouge">getStore(String protocol)</code>：获取指定协议的<code class="language-plaintext highlighter-rouge">Store</code>对象，用于接收邮件。</li><li><code class="language-plaintext highlighter-rouge">getDebug()</code>：获取调试模式的状态。</li><li><code class="language-plaintext highlighter-rouge">setDebug(boolean debug)</code>：设置调试模式的状态。</li><li><code class="language-plaintext highlighter-rouge">setProtocolForAddress(String type, String protocol)</code>：设置指定地址类型对应的协议。</li><li><code class="language-plaintext highlighter-rouge">setProvider(Provider provider)</code>：设置指定协议的提供者。</li><li><code class="language-plaintext highlighter-rouge">getProperty(String name)</code>：获取指定属性名的属性值。</li><li><code class="language-plaintext highlighter-rouge">setProperty(String name, String value)</code>：设置指定属性名的属性值。</li><li><code class="language-plaintext highlighter-rouge">getDefaultInstance(Properties props, Authenticator authenticator)</code>：静态方法，获取默认的<code class="language-plaintext highlighter-rouge">Session</code>实例。</li></ol><p>这些方法可以帮配置和管理邮件会话，以及创建<code class="language-plaintext highlighter-rouge">Transport</code>和<code class="language-plaintext highlighter-rouge">Store</code>对象来发送和接收邮件。</p><hr /><p><code class="language-plaintext highlighter-rouge">Session</code> 可以配置的一些常见属性包括：</p><ul><li><code class="language-plaintext highlighter-rouge">mail.smtp.host</code>: SMTP 服务器主机名。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.port</code>: SMTP 服务器端口号。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.auth</code>: 指定是否需要进行用户认证，通常为 <code class="language-plaintext highlighter-rouge">"true"</code>。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.starttls.enable</code>: 指定是否启用 STARTTLS 加密，通常为 <code class="language-plaintext highlighter-rouge">"true"</code>。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.class</code>: 指定用于创建 SMTP 套接字的 <code class="language-plaintext highlighter-rouge">SocketFactory</code> 类的名称。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.fallback</code>: 指定是否在连接失败时回退到普通套接字，通常为 <code class="language-plaintext highlighter-rouge">"false"</code>。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.socketFactory.port</code>: 指定用于创建 SMTP 套接字的端口号。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.connectiontimeout</code>: 指定连接超时时间。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.timeout</code>: 指定读取超时时间。</li><li><code class="language-plaintext highlighter-rouge">mail.smtp.writetimeout</code>: 指定写入超时时间。</li></ul><p>这些属性可以用于配置 <code class="language-plaintext highlighter-rouge">Session</code> 实例，以控制邮件发送的行为和连接设置。</p><hr /><p>通过<code class="language-plaintext highlighter-rouge">JavaMail</code> API连接到SMTP服务器上：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.Authenticator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.PasswordAuthentication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="o">...</span>
<span class="c1">// 服务器地址:</span>
<span class="nc">String</span> <span class="n">smtp</span> <span class="o">=</span> <span class="s">"smtp.163.com"</span><span class="o">;</span>
<span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"XXX@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"********"</span><span class="o">;</span>
<span class="c1">// 连接到SMTP服务器587端口:</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.host"</span><span class="o">,</span> <span class="s">"smtp.163.com"</span><span class="o">);</span> <span class="c1">// SMTP主机名</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"587"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用TLS加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
<span class="c1">// 获取Session实例:</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Authenticator</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">PasswordAuthentication</span> <span class="nf">getPasswordAuthentication</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PasswordAuthentication</span><span class="o">(</span><span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="c1">// 设置debug模式便于调试:</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</code></pre></div></div><p>以587端口为例，连接SMTP服务器时，需要准备一个<code class="language-plaintext highlighter-rouge">Properties</code>对象，填入相关信息。获取<code class="language-plaintext highlighter-rouge">Session</code>实例时，如果服务器需要认证，还需要传入一个<code class="language-plaintext highlighter-rouge">Authenticator</code>对象，用于提供用户名和密码进行身份验证。获取到<code class="language-plaintext highlighter-rouge">Session</code>实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p><p>SSL加密协议就用587端口，并改成以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"587"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用TLS加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
</code></pre></div></div><p>TLS就用25端口（非SSL协议，看服务器传回的消息里表示会判断这个）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.port"</span><span class="o">,</span> <span class="s">"25"</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.smtp.starttls.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用TLS加密</span>
</code></pre></div></div><h3 id="发送邮件">发送邮件</h3><p><code class="language-plaintext highlighter-rouge">MimeMessage</code>是<code class="language-plaintext highlighter-rouge">Message</code>的实现类，用于创建多部分邮件消息。<code class="language-plaintext highlighter-rouge">MimeMessage</code>类提供了多个构造方法，主要用于创建不同类型的消息。以下是<code class="language-plaintext highlighter-rouge">MimeMessage</code>类的一些常用构造方法：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">MimeMessage(Session session)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例。</strong></li><li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, InputStream is)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象和输入流创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，从输入流中读取消息内容。</li><li><code class="language-plaintext highlighter-rouge">MimeMessage(MimeMessage source)</code>：使用另一个<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例创建新的<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，复制源消息的内容。</li><li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, byte[] content)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象和字节数组创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，字节数组包含消息的原始内容。</li><li><code class="language-plaintext highlighter-rouge">MimeMessage(Session session, InputStream is, InternetHeaders headers)</code>：使用指定的<code class="language-plaintext highlighter-rouge">Session</code>对象、输入流和邮件头信息创建<code class="language-plaintext highlighter-rouge">MimeMessage</code>实例，用于处理邮件头和消息内容分开的情况。</li></ol><hr /><p><code class="language-plaintext highlighter-rouge">MimeMessage</code>类提供了许多方法，用于<strong>设置和获取邮件消息的各种属性和内容</strong>。以下是<code class="language-plaintext highlighter-rouge">MimeMessage</code>类的一些常用方法：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">setSubject(String subject)</code>：设置邮件主题。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">setFrom(Address address)</code>：设置发件人地址。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">setRecipient(Message.RecipientType type, Address address)</code>：设置收件人、抄送人或密送人地址。</strong><ul><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.TO</code>：主要收件人（”To”）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.CC</code>：抄送（”Cc”），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.BCC</code>：秘密抄送（”Bcc”），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。</li></ul></li><li><strong><code class="language-plaintext highlighter-rouge">setContent(Object content, String contentType)</code>：设置邮件内容和内容类型。内容可以是字符串、字节数组或<code class="language-plaintext highlighter-rouge">Multipart</code>对象。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置纯文本邮件的内容。</strong></li><li><code class="language-plaintext highlighter-rouge">setSentDate(Date date)</code>：设置邮件的发送日期。</li><li><code class="language-plaintext highlighter-rouge">addHeader(String name, String value)</code>：添加邮件头。</li><li><code class="language-plaintext highlighter-rouge">saveChanges()</code>：保存对邮件的更改。</li><li><code class="language-plaintext highlighter-rouge">getSubject()</code>：获取邮件主题。</li><li><code class="language-plaintext highlighter-rouge">getFrom()</code>：获取发件人地址。</li><li><code class="language-plaintext highlighter-rouge">getRecipients(Message.RecipientType type)</code>：获取指定类型的收件人、抄送人或密送人地址。</li><li><code class="language-plaintext highlighter-rouge">getContent()</code>：获取邮件内容。</li><li><code class="language-plaintext highlighter-rouge">getSentDate()</code>：获取邮件发送日期。</li><li><code class="language-plaintext highlighter-rouge">getAllHeaders()</code>：获取所有邮件头。</li><li><code class="language-plaintext highlighter-rouge">getHeader(String name)</code>：根据名称获取邮件头的值。</li><li><code class="language-plaintext highlighter-rouge">removeHeader(String name)</code>：移除指定名称的邮件头。</li><li><code class="language-plaintext highlighter-rouge">getContentType()</code>：获取邮件内容类型。</li></ol><p>这些方法可以对邮件消息进行各种操作，包括设置和获取邮件的属性、内容，以及添加和移除邮件头等。</p><hr /><p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类用于表示<strong>电子邮件地址</strong>。它有几种不同的构造方法，可以根据需要选择使用：</p><ol><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, boolean strict)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例，并指定是否启用严格模式。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal)</code>：使用给定的电子邮件地址字符串和个人名称创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset)</code>：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset, boolean strict)</code>：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li></ol><hr /><p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类还提供了一些常用的方法，用于处理电子邮件地址的操作，例如：</p><ol><li><code class="language-plaintext highlighter-rouge">String getAddress()</code>：获取电子邮件地址的地址部分（不包括个人名称）。</li><li><code class="language-plaintext highlighter-rouge">String getPersonal()</code>：获取电子邮件地址的个人名称部分。</li><li><code class="language-plaintext highlighter-rouge">void setAddress(String address)</code>：设置电子邮件地址的地址部分。</li><li><code class="language-plaintext highlighter-rouge">void setPersonal(String personal)</code>：设置电子邮件地址的个人名称部分。</li><li><code class="language-plaintext highlighter-rouge">String getType()</code>：获取电子邮件地址的类型。</li><li><code class="language-plaintext highlighter-rouge">void setType(String type)</code>：设置电子邮件地址的类型。</li><li><code class="language-plaintext highlighter-rouge">boolean isGroup()</code>：检查该地址是否表示一个邮件组。</li><li><code class="language-plaintext highlighter-rouge">boolean isUnicodeSupported()</code>：检查是否支持 Unicode 编码。</li><li><code class="language-plaintext highlighter-rouge">String toString()</code>：将 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 对象转换为字符串表示形式。</li></ol><hr /><p><code class="language-plaintext highlighter-rouge">Transport</code> 类用于<strong>发送邮件消息</strong>。以下是 <code class="language-plaintext highlighter-rouge">Transport</code> 类的一些常用方法：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">send(Message message)</code>：发送邮件消息。</strong></li><li><code class="language-plaintext highlighter-rouge">connect()</code>：连接到邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">connect(String host, String user, String password)</code>：连接到指定主机的邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">close()</code>：关闭连接。</li><li><code class="language-plaintext highlighter-rouge">addConnectionListener(ConnectionListener listener)</code>：添加连接监听器。</li><li><code class="language-plaintext highlighter-rouge">removeConnectionListener(ConnectionListener listener)</code>：移除连接监听器。</li><li><code class="language-plaintext highlighter-rouge">addTransportListener(TransportListener listener)</code>：添加传输监听器。</li><li><code class="language-plaintext highlighter-rouge">removeTransportListener(TransportListener listener)</code>：移除传输监听器。</li><li><code class="language-plaintext highlighter-rouge">isConnected()</code>：检查是否已连接到邮件服务器。</li><li><code class="language-plaintext highlighter-rouge">isSSL()</code>：检查是否使用 SSL 连接。</li><li><code class="language-plaintext highlighter-rouge">getURLName()</code>：获取连接的 URL 名称。</li><li><code class="language-plaintext highlighter-rouge">setURLName(URLName urlname)</code>：设置连接的 URL 名称。</li><li><code class="language-plaintext highlighter-rouge">setDebug(boolean debug)</code>：设置调试模式，用于输出调试信息。</li></ol><p>这些方法可以连接到邮件服务器并发送邮件消息。</p><hr /><p>发送邮件时，需要构造一个<code class="language-plaintext highlighter-rouge">Message</code>对象，然后调用<code class="language-plaintext highlighter-rouge">Transport.send(Message)</code>即可完成发送：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.internet.InternetAddress</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MimeMessage</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Transport</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"xiaoming@somewhere.com"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"这是一幅邮件"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div><p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p><p>填入真实的地址，运行上述代码，可以在控制台看到<code class="language-plaintext highlighter-rouge">JavaMail</code>打印的调试信息：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这是JavaMail打印的调试信息:
DEBUG: setDebug: Jakarta Mail version 2.0.1
DEBUG: getProvider() returning jakarta.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]
DEBUG SMTP: need username and password for authentication
DEBUG SMTP: protocolConnect returning false, host=smtp.163.com, user=XXX, password=&lt;null&gt;
DEBUG SMTP: useEhlo true, useAuth true
DEBUG SMTP: trying to connect to host "smtp.163.com", port 587, isSSL true
220 163.com Anti-spam GT for Coremail System (163com[20141201])
开始尝试连接smtp.163.comm:
DEBUG SMTP: connected to host "smtp.163.com", port: 587, ...
发送命令EHLO:
EHLO localhost
SMTP服务器响应250:
...
发送命令STARTTLS:
STARTTLS
SMTP服务器响应250:
...
尝试登录:
DEBUG SMTP: protocolConnect login, host=smtp.163.com, user=XXX@163.com, password=&lt;non-null&gt;
DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 
DEBUG SMTP: Using mechanism LOGIN
DEBUG SMTP: AUTH LOGIN command trace suppressed
登录成功:
DEBUG SMTP: AUTH LOGIN succeeded
DEBUG SMTP: use8bit false
开发发送邮件，设置FROM:
MAIL FROM:发件人
250 2.1.0 Sender OK
设置TO:
RCPT TO:收件人
250 2.1.5 Recipient OK
发送邮件数据:
DATA
服务器响应354:
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
真正的邮件数据:
Date: 时间
From: 发送方
To: 收件方
Message-ID: &lt;283383329.0.1713860754302@localhost&gt;
邮件主题是编码后的文本:
Subject: =?UTF-8?B?5L2g5aW9IQ==?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

邮件正文是Base64编码的文本:
5oiR5Y+R5LqG5LiA5Lu96YKu5Lu2
发送成功:
DEBUG SMTP: message successfully delivered to mail server
发送QUIT命令:
QUIT
服务器响应221结束TCP连接:
221 Bye
</code></pre></div></div><p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a href="https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p><p><strong>发送HTML邮件</strong></p><p>发送HTML邮件和文本邮件是类似的，只需要把：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"这是一幅邮件"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><p>改为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一幅邮件&lt;/h1&gt;"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">,</span> <span class="s">"html"</span><span class="o">);</span>
</code></pre></div></div><p>传入的<code class="language-plaintext highlighter-rouge">body</code>是类似<code class="language-plaintext highlighter-rouge">&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p><h3 id="发送附件">发送附件</h3><p><code class="language-plaintext highlighter-rouge">MimeMultipart</code> 是 <code class="language-plaintext highlighter-rouge">JavaMail</code> 中用于处理多部分 MIME 消息的类，<code class="language-plaintext highlighter-rouge">MimeMultipart</code> 类有多个构造方法，用于创建不同类型的多部分消息。以下是一些常用的构造方法：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">MimeMultipart()</code>：创建一个空的多部分消息，默认使用混合 (<code class="language-plaintext highlighter-rouge">mixed</code>) 类型。</strong></li><li><code class="language-plaintext highlighter-rouge">MimeMultipart(String subtype)</code>：根据指定的子类型创建一个空的多部分消息。常用的子类型包括 <code class="language-plaintext highlighter-rouge">related</code>（相关）、<code class="language-plaintext highlighter-rouge">alternative</code>（备选）、<code class="language-plaintext highlighter-rouge">mixed</code>（混合）等。例如：<ul><li><code class="language-plaintext highlighter-rouge">MimeMultipart("related")</code>：创建一个相关类型的多部分消息。</li><li><code class="language-plaintext highlighter-rouge">MimeMultipart("alternative")</code>：创建一个备选类型的多部分消息。</li></ul></li><li><code class="language-plaintext highlighter-rouge">MimeMultipart(javax.mail.internet.ContentType contentType)</code>：根据指定的 <code class="language-plaintext highlighter-rouge">ContentType</code> 对象创建一个空的多部分消息。ContentType 对象可以包含主类型、子类型、参数等信息。</li><li><code class="language-plaintext highlighter-rouge">MimeMultipart(InputStream is)</code>：从输入流中读取内容，并根据读取的内容创建一个多部分消息。</li></ol><p>这些构造方法提供了不同的方式来创建 <code class="language-plaintext highlighter-rouge">MimeMultipart</code> 对象，以满足不同场景下的需求。</p><p><strong>常用方法包括：</strong></p><ol><li><strong><code class="language-plaintext highlighter-rouge">addBodyPart(BodyPart part)</code>：将一个 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象添加到多部分消息中。</strong></li><li><code class="language-plaintext highlighter-rouge">removeBodyPart(int index)</code>：从多部分消息中移除指定索引位置的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">getBodyPart(int index)</code>：获取多部分消息中指定索引位置的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">getBodyPart(String CID)</code>：根据 Content-ID（CID）获取多部分消息中对应的 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">getBodyPartCount()</code>：获取多部分消息中 <code class="language-plaintext highlighter-rouge">BodyPart</code> 对象的数量。</li><li><code class="language-plaintext highlighter-rouge">setSubType(String subtype)</code>：设置多部分消息的子类型（subtype），例如 “mixed”、”alternative” 等。</li><li><code class="language-plaintext highlighter-rouge">setPreamble(String preamble)</code>：设置消息的开头部分（preamble）。</li><li><code class="language-plaintext highlighter-rouge">setEpilogue(String epilogue)</code>：设置消息的结尾部分（epilogue）。</li><li><code class="language-plaintext highlighter-rouge">writeTo(OutputStream os)</code>：将多部分消息写入输出流中。</li></ol><hr /><p><code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 类用于表示邮件的各个部分，包括正文、附件等。它的构造方法相对简单，通常使用默认构造方法创建对象，然后使用 <code class="language-plaintext highlighter-rouge">setContent</code> 等方法设置内容。以下是 <code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 的构造方法：</p><ol><li><strong>默认构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart()</code></strong></li><li>使用输入流构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart(InputStream is)</code></li><li>使用 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象构造方法：<code class="language-plaintext highlighter-rouge">MimeBodyPart(DataSource ds)</code></li></ol><p><code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 类的方法如下：</p><ol><li><code class="language-plaintext highlighter-rouge">addHeader(String name, String value)</code>：添加指定名称和值的头信息。</li><li><code class="language-plaintext highlighter-rouge">addHeaderLine(String line)</code>：添加包含完整头信息行的字符串。</li><li><code class="language-plaintext highlighter-rouge">setContentID(String cid)</code>：设置内容 ID。</li><li><code class="language-plaintext highlighter-rouge">setContentLanguage(String[] languages)</code>：设置内容语言。</li><li><code class="language-plaintext highlighter-rouge">setContentTransferEncoding(String encoding)</code>：设置内容传输编码。</li><li><strong><code class="language-plaintext highlighter-rouge">setDataHandler(DataHandler dh)</code>：设置数据处理程序。</strong></li><li><code class="language-plaintext highlighter-rouge">setDescription(String description)</code>：设置描述信息。</li><li><code class="language-plaintext highlighter-rouge">setDisposition(String disposition)</code>：设置附件描述。</li><li><strong><code class="language-plaintext highlighter-rouge">setFileName(String filename)</code>：设置文件名。</strong></li><li><code class="language-plaintext highlighter-rouge">setHeader(String name, String value)</code>：设置指定名称的头信息值。</li><li><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置文本内容。</li><li><code class="language-plaintext highlighter-rouge">updateHeaders()</code>：更新所有头信息。</li><li><code class="language-plaintext highlighter-rouge">addRecipient(Message.RecipientType type, Address address)</code>：添加接收者地址。</li><li><code class="language-plaintext highlighter-rouge">getAllHeaders()</code>：获取所有头信息。</li><li><code class="language-plaintext highlighter-rouge">getContentType()</code>：获取内容类型。</li><li><code class="language-plaintext highlighter-rouge">getDataHandler()</code>：获取数据处理程序。</li><li><code class="language-plaintext highlighter-rouge">getDescription()</code>：获取描述信息。</li><li><code class="language-plaintext highlighter-rouge">getDisposition()</code>：获取附件描述。</li><li><code class="language-plaintext highlighter-rouge">getFileName()</code>：获取文件名。</li><li><code class="language-plaintext highlighter-rouge">getHeader(String name)</code>：根据名称获取头信息值。</li><li><code class="language-plaintext highlighter-rouge">getInputStream()</code>：获取输入流。</li><li><code class="language-plaintext highlighter-rouge">getLineCount()</code>：获取行数。</li><li><code class="language-plaintext highlighter-rouge">getSize()</code>：获取大小。</li><li><code class="language-plaintext highlighter-rouge">getText()</code>：获取文本内容。</li><li><code class="language-plaintext highlighter-rouge">isMimeType(String mimeType)</code>：检查是否与指定的 MIME 类型匹配。</li><li><code class="language-plaintext highlighter-rouge">removeHeader(String name)</code>：移除指定名称的头信息。</li><li><code class="language-plaintext highlighter-rouge">setContent(Multipart mp)</code>：设置内容为多部分。</li><li><strong><code class="language-plaintext highlighter-rouge">setContent(Object obj, String type)</code>：设置内容对象和类型。</strong></li><li><code class="language-plaintext highlighter-rouge">setContent(Multipart mp)</code>：设置内容为多部分。</li><li><code class="language-plaintext highlighter-rouge">setContentID(String cid)</code>：设置内容 ID。</li><li><code class="language-plaintext highlighter-rouge">setContentLanguage(String[] languages)</code>：设置内容语言。</li><li><code class="language-plaintext highlighter-rouge">setDataHandler(DataHandler dh)</code>：设置数据处理程序。</li><li><code class="language-plaintext highlighter-rouge">setDisposition(String disposition)</code>：设置附件描述。</li><li><code class="language-plaintext highlighter-rouge">setFileName(String filename)</code>：设置文件名。</li><li><strong><code class="language-plaintext highlighter-rouge">setHeader(String name, String value)</code>：设置指定名称的头信息值。</strong></li><li><code class="language-plaintext highlighter-rouge">setText(String text)</code>：设置文本内容。</li><li><code class="language-plaintext highlighter-rouge">setText(String text, String charset)</code>：设置文本内容和字符集。</li></ol><p>这些方法可以用于配置和操作 <code class="language-plaintext highlighter-rouge">MimeBodyPart</code> 对象的各种属性和内容。</p><hr /><p><code class="language-plaintext highlighter-rouge">DataHandler</code> 的构造方法通常用于创建一个处理特定数据类型的数据处理程序对象。它有以下几个常用的构造方法：</p><ol><li><code class="language-plaintext highlighter-rouge">DataHandler(Object obj, String mimeType)</code>：使用给定的对象和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于将 Java 对象转换为数据处理程序。</li><li><code class="language-plaintext highlighter-rouge">DataHandler(URL url)</code>：使用给定的 URL 创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于处理指向外部资源的 URL。</li><li><code class="language-plaintext highlighter-rouge">DataHandler(DataSource dataSource)</code>：使用给定的数据源创建一个 <code class="language-plaintext highlighter-rouge">DataHandler</code> 对象。这个构造方法通常用于处理数据源对象。</li></ol><p>这些构造方法根据不同的数据类型和来源创建适当的数据处理程序对象，以便于在应用程序中处理和传输数据。</p><hr /><p><code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 的构造方法通常用于创建一个包含字节数组数据的数据源对象。它有以下两个常用的构造方法：</p><ol><li><code class="language-plaintext highlighter-rouge">ByteArrayDataSource(byte[] data, String type)</code>：使用给定的字节数组和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">ByteArrayDataSource(InputStream is, String type)</code>：使用给定的输入流和 MIME 类型创建一个 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 对象。</li></ol><p>这些构造方法将字节数组或输入流与 MIME 类型关联起来，以便于处理和传输数据。</p><hr /><p>常用文件的 MIME 类型如下：</p><ul><li>文本文件：<code class="language-plaintext highlighter-rouge">text/plain</code></li><li>HTML 文件：<code class="language-plaintext highlighter-rouge">text/html</code></li><li>XML 文件：<code class="language-plaintext highlighter-rouge">application/xml</code></li><li>JSON 文件：<code class="language-plaintext highlighter-rouge">application/json</code></li><li>图片文件：<code class="language-plaintext highlighter-rouge">image/jpeg</code>、<code class="language-plaintext highlighter-rouge">image/png</code>、<code class="language-plaintext highlighter-rouge">image/gif</code>、<code class="language-plaintext highlighter-rouge">image/webp</code></li><li>视频文件：<code class="language-plaintext highlighter-rouge">video/mp4</code>、<code class="language-plaintext highlighter-rouge">video/quicktime</code></li><li>音频文件：<code class="language-plaintext highlighter-rouge">audio/mpeg</code>、<code class="language-plaintext highlighter-rouge">audio/wav</code></li><li>PDF 文件：<code class="language-plaintext highlighter-rouge">application/pdf</code></li><li>Word 文档：<code class="language-plaintext highlighter-rouge">application/msword</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.wordprocessingml.document</code></li><li>Excel 表格：<code class="language-plaintext highlighter-rouge">application/vnd.ms-excel</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code></li><li>PowerPoint 演示文稿：<code class="language-plaintext highlighter-rouge">application/vnd.ms-powerpoint</code>、<code class="language-plaintext highlighter-rouge">application/vnd.openxmlformats-officedocument.presentationml.presentation</code></li><li>压缩文件：<code class="language-plaintext highlighter-rouge">application/zip</code></li><li>二进制文件的 MIME 类型通常是 <code class="language-plaintext highlighter-rouge">application/octet-stream</code>。这个 MIME 类型通常用于表示未知的二进制数据类型，或者不属于其他已知 MIME 类型的二进制数据。</li></ul><p>这些 MIME 类型可以帮助浏览器和其他应用程序识别文件的类型并采取相应的处理方式。</p><hr /><p>要在电子邮件中携带附件，就不能直接调用<code class="language-plaintext highlighter-rouge">message.setText()</code>方法，而是要构造一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeBodyPart</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.internet.MimeMultipart</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.util.ByteArrayDataSource</span><span class="o">;</span>
<span class="o">...</span>
<span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"XXX"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMultipart</span><span class="o">();</span>
<span class="c1">// 添加text:</span>
<span class="nc">BodyPart</span> <span class="n">textpart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">textpart</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一幅邮件&lt;/h1&gt;"</span><span class="o">,</span> <span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">textpart</span><span class="o">);</span>
<span class="c1">// 添加附件:</span>
<span class="nc">BodyPart</span> <span class="n">annex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setFileName</span><span class="o">(</span><span class="s">"附件1.7z"</span><span class="o">);</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayDataSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"Maven.7z"</span><span class="o">),</span> <span class="s">"application/octet-stream"</span><span class="o">)));</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">annex</span><span class="o">);</span>
<span class="c1">// 设置邮件内容为multipart:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">multipart</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div><p>一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象可以添加若干个<code class="language-plaintext highlighter-rouge">BodyPart</code>，其中<strong>第一个</strong><code class="language-plaintext highlighter-rouge">BodyPart</code>是文本，即邮件正文，后面的<code class="language-plaintext highlighter-rouge">BodyPart</code>是附件。</p><p><code class="language-plaintext highlighter-rouge">BodyPart</code>依靠<code class="language-plaintext highlighter-rouge">setContent()</code>决定添加的内容。</p><p>如果添加文本，用<code class="language-plaintext highlighter-rouge">setContent("...", "text/plain;charset=utf-8")</code>添加纯文本，或者用<code class="language-plaintext highlighter-rouge">setContent("...", "text/html;charset=utf-8")</code>添加HTML文本。</p><p>如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code class="language-plaintext highlighter-rouge">DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code class="language-plaintext highlighter-rouge">application/octet-stream</code>，Word文档则是<code class="language-plaintext highlighter-rouge">application/msword</code>。</p><p>最后，通过<code class="language-plaintext highlighter-rouge">setContent()</code>把<code class="language-plaintext highlighter-rouge">Multipart</code>添加到<code class="language-plaintext highlighter-rouge">Message</code>中，即可发送。</p><p><code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 是 <code class="language-plaintext highlighter-rouge">javax.mail.util.ByteArrayDataSource</code> 类的一个子类，用于从字节数组中创建数据源对象。在这个特定的代码片段中，它的作用是将 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 对象中的数据转换为字节数组，并将其作为数据源传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法。</p><p><code class="language-plaintext highlighter-rouge">DataHandler</code> 用于将数据封装为一种适合传输的格式，它可以处理各种类型的数据，如字节数组、文件、URL 等。在这里，<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 负责将文件中的数据读取到字节数组中，然后 <code class="language-plaintext highlighter-rouge">DataHandler</code> 将这个字节数组封装为一个数据处理程序，以便于传输和处理。</p><p>如果去掉<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code>，会报错：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"3.png"</span><span class="o">),</span> <span class="s">"image/png"</span><span class="o">));</span>
</code></pre></div></div><p>报错是因为 <code class="language-plaintext highlighter-rouge">DataHandler</code> 的构造方法不接受 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 对象作为参数，而是需要一个 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象。<code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 实现了 <code class="language-plaintext highlighter-rouge">DataSource</code> 接口，因此可以作为参数传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法。如果直接将 <code class="language-plaintext highlighter-rouge">FileInputStream</code> 传递给 <code class="language-plaintext highlighter-rouge">DataHandler</code> 构造方法，它将无法识别并处理文件流，从而导致错误。因此，需要使用 <code class="language-plaintext highlighter-rouge">ByteArrayDataSource</code> 将文件流转换为 <code class="language-plaintext highlighter-rouge">DataSource</code> 对象，以便 <code class="language-plaintext highlighter-rouge">DataHandler</code> 可以正确处理图像数据。</p><h3 id="发送内嵌图片的html邮件">发送内嵌图片的HTML邮件</h3><p><code class="language-plaintext highlighter-rouge">setHeader</code> 方法用于设置邮件头的值，其参数为邮件头的名称和对应的值。常用的邮件头包括但不限于：</p><ol><li><code class="language-plaintext highlighter-rouge">From</code>：发件人地址。</li><li><code class="language-plaintext highlighter-rouge">To</code>：收件人地址。</li><li><code class="language-plaintext highlighter-rouge">Cc</code>：抄送地址。</li><li><code class="language-plaintext highlighter-rouge">Bcc</code>：密送地址。</li><li><code class="language-plaintext highlighter-rouge">Subject</code>：邮件主题。</li><li><code class="language-plaintext highlighter-rouge">Date</code>：邮件发送时间。</li><li><code class="language-plaintext highlighter-rouge">Content-Type</code>：内容类型。</li><li><code class="language-plaintext highlighter-rouge">Content-Disposition</code>：内容描述。</li><li><strong><code class="language-plaintext highlighter-rouge">Content-ID</code>：内容 ID。</strong></li><li><code class="language-plaintext highlighter-rouge">MIME-Version</code>：MIME 版本。</li><li><code class="language-plaintext highlighter-rouge">Reply-To</code>：回复地址。</li><li><code class="language-plaintext highlighter-rouge">Return-Path</code>：返回路径。</li><li><code class="language-plaintext highlighter-rouge">Message-ID</code>：消息 ID。</li></ol><p>这些参数的设置可以根据邮件的需求和格式进行配置，以满足邮件发送的要求和格式规范。</p><hr /><p>HTML邮件中可以内嵌图片。如果给一个<code class="language-plaintext highlighter-rouge">&lt;img src="http://example.com/test.jpg"&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p><p>内嵌图片实际上也是一个附件，即邮件本身也是<code class="language-plaintext highlighter-rouge">Multipart</code>，但需要做一点额外的处理：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
<span class="c1">// 设置接收方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"XXX"</span><span class="o">));</span>
<span class="c1">// 设置邮件主题:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setSubject</span><span class="o">(</span><span class="s">"你好!"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="c1">// 设置邮件正文:</span>
<span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMultipart</span><span class="o">();</span>
<span class="c1">// 添加text:</span>
<span class="nc">BodyPart</span> <span class="n">textpart</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">textpart</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="s">"&lt;h1&gt;这是一个带图片的邮件&lt;/h1&gt;&lt;p&gt;&lt;img src='cid:img01'"</span><span class="o">,</span> <span class="s">"text/html;charset=utf-8"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">textpart</span><span class="o">);</span>
<span class="c1">// 添加附件:</span>
<span class="nc">BodyPart</span> <span class="n">annex</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeBodyPart</span><span class="o">();</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setFileName</span><span class="o">(</span><span class="s">"图片1.png"</span><span class="o">);</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setDataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DataHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ByteArrayDataSource</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"3.png"</span><span class="o">),</span> <span class="s">"image/png"</span><span class="o">)));</span>
<span class="n">annex</span><span class="o">.</span><span class="na">setHeader</span><span class="o">(</span><span class="s">"Content-ID"</span><span class="o">,</span><span class="s">"&lt;img01&gt;"</span><span class="o">);</span>
<span class="n">multipart</span><span class="o">.</span><span class="na">addBodyPart</span><span class="o">(</span><span class="n">annex</span><span class="o">);</span>
<span class="c1">// 设置邮件内容为multipart:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setContent</span><span class="o">(</span><span class="n">multipart</span><span class="o">);</span>
<span class="c1">// 发送:</span>
<span class="nc">Transport</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</code></pre></div></div><p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code class="language-plaintext highlighter-rouge">&lt;img src='cid:img01'"&gt;</code>引用，然后，在添加图片作为<code class="language-plaintext highlighter-rouge">BodyPart</code>时，除了要正确设置MIME类型（根据图片类型使用<code class="language-plaintext highlighter-rouge">image/jpeg</code>或<code class="language-plaintext highlighter-rouge">image/png</code>），还需要设置一个Header：<code class="language-plaintext highlighter-rouge">imagepart.setHeader("Content-ID", "&lt;img01&gt;");</code>。</p><h3 id="发送给多个收件人">发送给多个收件人</h3><p><strong>设置收件人和发件人：</strong></p><ul><li><code class="language-plaintext highlighter-rouge">addFrom(Address[] addresses)</code>: 添加发件人地址。</li><li><code class="language-plaintext highlighter-rouge">addFrom(String addresses)</code>: 添加发件人地址。</li><li><code class="language-plaintext highlighter-rouge">addRecipient(Message.RecipientType type, Address address)</code>: 添加指定类型的收件人地址。</li><li><strong><code class="language-plaintext highlighter-rouge">addRecipients(Message.RecipientType type, Address[] addresses)</code>: 添加指定类型的收件人地址。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">addRecipients(Message.RecipientType type, String addresses)</code>: 添加指定类型的收件人地址。</strong></li><li><code class="language-plaintext highlighter-rouge">addRecipient(String type, String address)</code>: 添加指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">addRecipients(String type, String addresses)</code>: 添加指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setFrom(Address address)</code>: 设置发件人地址。</li><li><code class="language-plaintext highlighter-rouge">setFrom(String address)</code>: 设置发件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipient(Message.RecipientType type, Address address)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipients(Message.RecipientType type, Address[] addresses)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipients(Message.RecipientType type, String addresses)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipient(String type, Address address)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setRecipients(String type, String addresses)</code>: 设置指定类型的收件人地址。</li><li><code class="language-plaintext highlighter-rouge">setReplyTo(Address[] addresses)</code>: 设置回复地址。</li></ul><p><code class="language-plaintext highlighter-rouge">Message.RecipientType</code>：</p><ul><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.TO</code>：主要收件人（”To”）这些收件人是邮件的主要目标，邮件会直接发送给他们。通常，主要收件人是你希望直接收到邮件的人。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.CC</code>：抄送（”Cc”），抄送的收件人会收到一份副本，但他们不是主要目标。通常，抄送用于通知其他人邮件的内容，但他们不需要采取任何行动。</li><li><code class="language-plaintext highlighter-rouge">Message.RecipientType.BCC</code>：秘密抄送（”Bcc”），秘密抄送的收件人也会收到一份副本，但其他收件人无法看到他们的地址。这在你希望向某些人发送邮件，但不想让其他收件人知道这些人的地址时很有用。</li></ul><hr /><p>要设置多个收件人，可以使用<code class="language-plaintext highlighter-rouge">addRecipients</code>方法或<code class="language-plaintext highlighter-rouge">setRecipients</code>方法。这些方法允许为消息的不同类型（如TO、CC、BCC）添加多个收件人。以下是使用这些方法设置多个收件人的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MimeMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MimeMessage</span><span class="o">(</span><span class="n">session</span><span class="o">);</span>
<span class="c1">// 添加多个收件人</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="s">"recipient1@example.com, recipient2@example.com"</span><span class="o">);</span>
<span class="c1">// 或者使用数组</span>
<span class="nc">Address</span><span class="o">[]</span> <span class="n">recipients</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">InternetAddress</span><span class="o">(</span><span class="s">"recipient1@example.com"</span><span class="o">),</span>
    <span class="k">new</span> <span class="nf">InternetAddress</span><span class="o">(</span><span class="s">"recipient2@example.com"</span><span class="o">)</span>
<span class="o">};</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="n">recipients</span><span class="o">);</span>
</code></pre></div></div><p>注意，在使用<code class="language-plaintext highlighter-rouge">addRecipients</code>方法时，<strong>多个收件人应使用逗号分隔</strong>。还可以使用类似的方法设置CC和BCC收件人。</p><p><code class="language-plaintext highlighter-rouge">addRecipient</code>方法可以多次调用以添加多个收件人，而<code class="language-plaintext highlighter-rouge">setRecipient</code>方法会覆盖之前设置的收件人。因此，如果需要设置多个收件人，应该使用<code class="language-plaintext highlighter-rouge">addRecipient</code>方法。</p><p>如果需要设置收件人、抄送（CC）和密送（BCC）等多个收件人，应该使用<code class="language-plaintext highlighter-rouge">addRecipient</code>方法多次调用来添加不同类型的收件人。例如，可以按照以下方式设置多个收件人：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">setRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient1@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">TO</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient2@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">CC</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"cc@example.com"</span><span class="o">));</span>
<span class="n">message</span><span class="o">.</span><span class="na">addRecipient</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">BCC</span><span class="o">,</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"bcc@example.com"</span><span class="o">));</span>
</code></pre></div></div><p>而对于多个发件人，SMTP 协议规定邮件的 <code class="language-plaintext highlighter-rouge">From</code> 字段只能有一个发件人。如果需要发送给多个人，但每个人看到的发件人应该不同，可以考虑使用群发邮件的方式，即将所有收件人放在收件人列表中，但在邮件内容中区分不同的收件人。如果需要在邮件内容中显示不同的发件人，可以在邮件内容中自定义发件人的显示方式，例如在邮件正文中注明发件人姓名或其他标识。</p><h3 id="设置别名">设置别名</h3><p><code class="language-plaintext highlighter-rouge">InternetAddress</code> 类用于表示<strong>电子邮件地址</strong>。它有几种不同的构造方法，可以根据需要选择使用：</p><ol><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, boolean strict)</code>：使用给定的电子邮件地址字符串创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例，并指定是否启用严格模式。</li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal)</code>：使用给定的电子邮件地址字符串和个人名称创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li><li><strong><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset)</code>：使用给定的电子邮件地址字符串、个人名称和字符集创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</strong></li><li><code class="language-plaintext highlighter-rouge">InternetAddress(String address, String personal, String charset, boolean strict)</code>：使用给定的电子邮件地址字符串、个人名称、字符集和严格模式创建一个 <code class="language-plaintext highlighter-rouge">InternetAddress</code> 实例。</li></ol><hr /><p><strong><code class="language-plaintext highlighter-rouge">InternetAddress</code>可以很方便的设置别名</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设置发送方地址:</span>
<span class="n">message</span><span class="o">.</span><span class="na">setFrom</span><span class="o">(</span><span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="n">username</span><span class="o">,</span><span class="s">"Sora"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">));</span>
</code></pre></div></div><p><strong>在字符串里，也可以设置别名</strong>：</p><p>在字符串里给收件人设置别名的方法是使用 <code class="language-plaintext highlighter-rouge">&lt;</code> 和 <code class="language-plaintext highlighter-rouge">&gt;</code> 包裹完整的邮件地址，并在地址后面添加别名，格式如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"别名1 &lt;recipient1@example.com&gt;, 别名2 &lt;recipient2@example.com&gt;"</span>
</code></pre></div></div><p>例如，如果要将 “Alice” 和 “Bob” 添加到密送列表，可以这样做：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span><span class="o">.</span><span class="na">addRecipients</span><span class="o">(</span><span class="nc">Message</span><span class="o">.</span><span class="na">RecipientType</span><span class="o">.</span><span class="na">BCC</span><span class="o">,</span> <span class="s">"Alice &lt;alice@example.com&gt;, Bob &lt;bob@example.com&gt;"</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">InternetAddress</code>里也可以这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"别名 &lt;recipient@example.com&gt;"</span><span class="o">);</span>
</code></pre></div></div><p>但是不能同时设置字符集，那中文可能出问题，所以还是得这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient@example.com&gt;"</span><span class="o">,</span><span class="s">"别名"</span><span class="o">,</span><span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><p>或者这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InternetAddress</span><span class="o">(</span><span class="s">"recipient@example.com"</span><span class="o">);</span>
<span class="n">address</span><span class="o">.</span><span class="na">setPersonal</span><span class="o">(</span><span class="s">"别名"</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
</code></pre></div></div><h3 id="常见问题">常见问题</h3><p>如果用户名或口令错误，会导致<code class="language-plaintext highlighter-rouge">535</code>登录失败：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: AUTH LOGIN failed
Exception in thread "main" javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
</code></pre></div></div><p>如果<strong>登录用户和发件人不一致</strong>，会导致<code class="language-plaintext highlighter-rouge">554</code>拒绝发送错误：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
</code></pre></div></div><p>有些时候，如果邮件主题和正文过于简单，会导致<code class="language-plaintext highlighter-rouge">554</code>被识别为垃圾邮件的错误：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">JavaMail</code> API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；</p><p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p><h2 id="接收email">接收Email</h2><p>发送Email，客户端总是通过SMTP协议把邮件发送给MTA。</p><p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p><p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p><p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p><p>以下是 QQ 邮箱、163 邮箱和 Gmail 邮箱的 POP3 和 IMAP 服务器信息：</p><ol><li>QQ 邮箱：<ul><li>POP3 服务器：pop.qq.com</li><li>IMAP 服务器：imap.qq.com</li></ul></li><li>163 邮箱：<ul><li>POP3 服务器：pop.163.com 或 pop3.163.com</li><li>IMAP 服务器：imap.163.com</li></ul></li><li>Gmail 邮箱：<ul><li>POP3 服务器：pop.gmail.com（默认端口号：995）</li><li>IMAP 服务器：imap.gmail.com（默认端口号：993）</li></ul></li></ol><p>对于 Gmail 邮箱，还需要启用“Less secure app access”或生成应用密码。Gmail 强制使用加密连接，请确保使用正确的端口号以及启用 SSL/TLS 加密连接。</p><h3 id="登录邮箱">登录邮箱</h3><p><code class="language-plaintext highlighter-rouge">URLName</code> 类构造方法：</p><ol><li><p><code class="language-plaintext highlighter-rouge">public URLName()</code>: 默认构造方法，创建一个空的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。</p></li><li><p><code class="language-plaintext highlighter-rouge">public URLName(String url)</code>: 使用给定的 URL 字符串创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。该 URL 字符串应包含完整的 URL 信息，例如：”protocol://host:port/file”。</p></li><li><p><strong><code class="language-plaintext highlighter-rouge">public URLName(String protocol, String host, int port, String file, String username, String password)</code>: 使用指定的协议、主机、端口、文件路径、用户名和密码创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象。用于表示需要身份验证的 URL。</strong></p></li><li><p><code class="language-plaintext highlighter-rouge">public URLName(String protocol, String host, int port, String file)</code>: 使用指定的协议、主机、端口和文件路径创建一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，用户名和密码为空。通常用于表示不需要身份验证的 URL。</p></li><li><p><code class="language-plaintext highlighter-rouge">public URLName(URLName url)</code>: 复制构造方法，创建一个新的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，其内容与给定的 <code class="language-plaintext highlighter-rouge">URLName</code> 对象相同。</p></li></ol><p><code class="language-plaintext highlighter-rouge">URLName</code> 类中除了构造方法外还有一些常用的方法，例如：</p><ol><li><p><code class="language-plaintext highlighter-rouge">public String getProtocol()</code>: 返回 URL 的协议部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public String getHost()</code>: 返回 URL 的主机部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public int getPort()</code>: 返回 URL 的端口部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public String getFile()</code>: 返回 URL 的文件路径部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public String getUsername()</code>: 返回 URL 的用户名部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public String getPassword()</code>: 返回 URL 的密码部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public void setProtocol(String protocol)</code>: 设置 URL 的协议部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public void setHost(String host)</code>: 设置 URL 的主机部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public void setPort(int port)</code>: 设置 URL 的端口部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public void setFile(String file)</code>: 设置 URL 的文件路径部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public void setUsername(String username)</code>: 设置 URL 的用户名部分。</p></li><li><p><code class="language-plaintext highlighter-rouge">public void setPassword(String password)</code>: 设置 URL 的密码部分。</p></li></ol><hr /><h4 id="pop3">POP3</h4><p>使用POP3收取Email时，无需关心POP3协议底层，因为<code class="language-plaintext highlighter-rouge">JavaMail</code>提供了高层接口。首先需要连接到Store对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.mail.pop3.POP3SSLStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MessagingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Store</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.URLName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">MessagingException</span> <span class="o">{</span>
        <span class="c1">// 登录用户名:</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
        <span class="c1">// 登录口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
        <span class="c1">// 主机端口号</span>
        <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"995"</span><span class="o">;</span>
        <span class="c1">// pop3主机：</span>
        <span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"pop3.163.com"</span><span class="o">;</span>
        <span class="c1">// 连接到pop3服务器995端口:</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="n">getProperties</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="c1">// 获取Session实例:</span>
        <span class="c1">// 连接到Store:</span>
        <span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3s"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3SSLStore</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Properties</span> <span class="nf">getProperties</span><span class="o">(</span><span class="nc">String</span> <span class="n">host</span><span class="o">,</span> <span class="nc">String</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.host"</span><span class="o">,</span> <span class="n">host</span><span class="o">);</span> <span class="c1">// pop3主机名</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 关闭TLS加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.socketFactory.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">props</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 是 <code class="language-plaintext highlighter-rouge">POP3Store</code> 的 SSL 安全版本。它们的构造方法应该是类似的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span>
</code></pre></div></div><p>这个构造方法接受一个 <code class="language-plaintext highlighter-rouge">Session</code> 对象和一个 <code class="language-plaintext highlighter-rouge">URLName</code> 对象作为参数，用于初始化 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象。<code class="language-plaintext highlighter-rouge">Session</code> 对象包含邮件会话的配置信息，而 <code class="language-plaintext highlighter-rouge">URLName</code> 对象包含用于连接到邮件服务器的 URL 信息。</p><p>实际上，<code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 的构造方法内部调用了父类 <code class="language-plaintext highlighter-rouge">POP3Store</code> 的带有四个参数的构造方法，其中第一个参数是 <code class="language-plaintext highlighter-rouge">Session</code> 对象，第二个参数是 <code class="language-plaintext highlighter-rouge">URLName</code> 对象，第三个参数是字符串 <code class="language-plaintext highlighter-rouge">"pop3s"</code>，表示使用 POP3 协议的 SSL 安全版本，第四个参数是 <code class="language-plaintext highlighter-rouge">true</code>，表示要使用 SSL 连接。源码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3SSLStore</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>这样就可以使用 SSL 安全连接到 POP3 邮件服务器。</p><p>对于代码中的<code class="language-plaintext highlighter-rouge">pop3s</code>都可以改成<code class="language-plaintext highlighter-rouge">pop3</code>，因为使用<code class="language-plaintext highlighter-rouge">POP3SSLStore</code>已经定义了<code class="language-plaintext highlighter-rouge">pop3s</code>，即<code class="language-plaintext highlighter-rouge">pop3</code>的SSL安全版本：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3s"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"pop3s"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
</code></pre></div></div><p>实际上整个<code class="language-plaintext highlighter-rouge">getProperties</code>方法都是多余的，协议也是多余的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="c1">// 主机端口号</span>
<span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"995"</span><span class="o">;</span>
<span class="c1">// imap主机：</span>
<span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"pop3.163.com"</span><span class="o">;</span>
<span class="c1">// 连接到pop3服务器995端口:</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="c1">// 获取Session实例:</span>
<span class="c1">// 连接到Store:</span>
<span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3SSLStore</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span><span class="c1">//调用就会自动设置pop3s</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><hr /><p>如果不需要使用 SSL 安全连接，可以使用 <code class="language-plaintext highlighter-rouge">POP3Store</code> 类而不是 <code class="language-plaintext highlighter-rouge">POP3SSLStore</code> 类。<code class="language-plaintext highlighter-rouge">POP3Store</code> 类用于表示普通的、非加密的 POP3 连接。在创建 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象时，可以直接指定协议为 <code class="language-plaintext highlighter-rouge">"pop3"</code>，而不是 <code class="language-plaintext highlighter-rouge">"pop3s"</code>，这样就可以使用非加密的方式连接到 POP3 邮件服务器。示例代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"mail.pop3.host"</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">);</span><span class="c1">//多余的操作</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"mail.pop3.port"</span><span class="o">,</span> <span class="s">"110"</span><span class="o">);</span><span class="c1">//多余的操作</span>
<span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.pop3.ssl.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 不启用SSL加密，这个也是多余的操作</span>

<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3Store</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"pop3"</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">,</span> <span class="mi">110</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"username"</span><span class="o">,</span> <span class="s">"password"</span><span class="o">));</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><p>在这个示例中，创建了一个 <code class="language-plaintext highlighter-rouge">POP3Store</code> 对象，并指定了 POP3 邮件服务器的主机、端口、用户名和密码。连接时不需要指定使用 SSL，因为默认情况下 <code class="language-plaintext highlighter-rouge">POP3Store</code> 使用的是非加密的方式。</p><p>实际上<code class="language-plaintext highlighter-rouge">POP3Store</code>的构造方法定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">,</span> <span class="s">"pop3"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="nf">POP3Store</span><span class="o">(</span><span class="nc">Session</span> <span class="n">session</span><span class="o">,</span> <span class="nc">URLName</span> <span class="n">url</span><span class="o">,</span>
                 <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">isSSL</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">super</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="n">url</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">url</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="na">getProtocol</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MailLogger</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="s">"DEBUG POP3"</span><span class="o">,</span>
                            <span class="n">session</span><span class="o">.</span><span class="na">getDebug</span><span class="o">(),</span> <span class="n">session</span><span class="o">.</span><span class="na">getDebugOut</span><span class="o">());</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">isSSL</span><span class="o">)</span>
        <span class="n">isSSL</span> <span class="o">=</span> <span class="nc">PropUtil</span><span class="o">.</span><span class="na">getBooleanProperty</span><span class="o">(</span><span class="n">session</span><span class="o">.</span><span class="na">getProperties</span><span class="o">(),</span>
                                            <span class="s">"mail."</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">".ssl.enable"</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isSSL</span><span class="o">)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">defaultPort</span> <span class="o">=</span> <span class="mi">995</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">this</span><span class="o">.</span><span class="na">defaultPort</span> <span class="o">=</span> <span class="mi">110</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">isSSL</span> <span class="o">=</span> <span class="n">isSSL</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，只需要写主机地址和用户名及密码，但由于<code class="language-plaintext highlighter-rouge">URLName</code>这个构造方法要指定端口号，还是指定了<code class="language-plaintext highlighter-rouge">110</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 登录用户名:</span>
<span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="c1">// 登录口令:</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">POP3Store</span><span class="o">(</span><span class="n">session</span><span class="o">,</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="s">"pop3.163.com"</span><span class="o">,</span> <span class="mi">110</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">));</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><hr /><h4 id="imap">IMAP</h4><p>使用IMAP协议的SSL安全连接方式（还是写规范点）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.sun.mail.pop3.POP3SSLStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.MessagingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Session</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.Store</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">jakarta.mail.URLName</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Properties</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoTest</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">testNegative</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">MessagingException</span> <span class="o">{</span>
        <span class="c1">// 登录用户名:</span>
        <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
        <span class="c1">// 登录口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
        <span class="c1">// 主机端口号</span>
        <span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"993"</span><span class="o">;</span>
        <span class="c1">// imap主机：</span>
        <span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"imap.163.com"</span><span class="o">;</span>
        <span class="c1">// 连接到imap服务器993端口:</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="n">getProperties</span><span class="o">(</span><span class="n">host</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="c1">// 获取Session实例:</span>
        <span class="c1">// 连接到Store:</span>
        <span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"imaps"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
        <span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
        <span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getStore</span><span class="o">(</span><span class="n">url</span><span class="o">);</span><span class="c1">//获取指定协议的`Store`对象，用于接收邮件。</span>
        <span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Properties</span> <span class="nf">getProperties</span><span class="o">(</span><span class="nc">String</span> <span class="n">host</span><span class="o">,</span> <span class="nc">String</span> <span class="n">port</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.store.protocol"</span><span class="o">,</span> <span class="s">"imaps"</span><span class="o">);</span> <span class="c1">// 协议名称</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.host"</span><span class="o">,</span> <span class="n">host</span><span class="o">);</span> <span class="c1">// imap主机名</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span> <span class="c1">// 主机端口号</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.auth"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 是否需要用户认证</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.starttls.enable"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">);</span> <span class="c1">// 关闭TLS加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.ssl.enable"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">);</span> <span class="c1">// 启用SSL加密</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.socketFactory.class"</span><span class="o">,</span> <span class="s">"javax.net.ssl.SSLSocketFactory"</span><span class="o">);</span>
        <span class="n">props</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"mail.imap.socketFactory.port"</span><span class="o">,</span> <span class="n">port</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">props</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>修改的地方也就几处：<code class="language-plaintext highlighter-rouge">port</code>为<code class="language-plaintext highlighter-rouge">993</code>，<code class="language-plaintext highlighter-rouge">host</code>为<code class="language-plaintext highlighter-rouge">imap.163.com</code>，<code class="language-plaintext highlighter-rouge">Store</code>的获取方式改为：<code class="language-plaintext highlighter-rouge">session.getStore(url);</code>，注意协议都改为了：<code class="language-plaintext highlighter-rouge">imaps</code>，这里不能像前面<code class="language-plaintext highlighter-rouge">pop3</code>一样不加<code class="language-plaintext highlighter-rouge">s</code>一样能SSL安全连接。</p><p>同样的，<code class="language-plaintext highlighter-rouge">getProperties</code>方法也是多余的，<code class="language-plaintext highlighter-rouge">new URLName("imaps"...</code>里的<code class="language-plaintext highlighter-rouge">imaps</code>这次不是多余的了，因为调用的是<code class="language-plaintext highlighter-rouge">session.getStore(url);</code>这个一般方法。</p><p><strong>也可以改成<code class="language-plaintext highlighter-rouge">Store store = new IMAPSSLStore(session,url);</code></strong></p><hr /><p>要改为非SSL安全连接的：只需要改<code class="language-plaintext highlighter-rouge">port</code>为<code class="language-plaintext highlighter-rouge">143</code>，协议改为：<code class="language-plaintext highlighter-rouge">imap</code>，<code class="language-plaintext highlighter-rouge">ssl</code>指定为<code class="language-plaintext highlighter-rouge">false</code>或者不写。即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"***@163.com"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"***"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">port</span> <span class="o">=</span><span class="s">"143"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">host</span><span class="o">=</span><span class="s">"imap.163.com"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">URLName</span> <span class="n">url</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">URLName</span><span class="o">(</span><span class="s">"imap"</span><span class="o">,</span> <span class="n">host</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">port</span><span class="o">),</span> <span class="s">""</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="nc">Session</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">props</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span><span class="c1">//静态方法，用于获取`Session`实例。</span>
<span class="n">session</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 显示调试信息</span>
<span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">getStore</span><span class="o">(</span><span class="n">url</span><span class="o">);</span><span class="c1">//获取指定协议的`Store`对象，用于接收邮件。</span>
<span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
</code></pre></div></div><p><strong>也可以改成<code class="language-plaintext highlighter-rouge">Store store = new IMAPStore(session,url);</code></strong></p><h3 id="查看邮箱">查看邮箱</h3><p><code class="language-plaintext highlighter-rouge">Store</code> 类表示邮件存储的抽象类，它提供了一组方法用于连接到邮件服务器并访问邮件。下面是一些常用的 <code class="language-plaintext highlighter-rouge">Store</code> 类的方法：</p><ol><li><p><code class="language-plaintext highlighter-rouge">void connect(String host, String user, String password)</code>：连接到指定主机的邮件服务器，使用指定的用户名和密码进行身份验证。</p></li><li><p><code class="language-plaintext highlighter-rouge">void connect()</code>：连接到之前设置的邮件服务器，使用之前设置的用户名和密码进行身份验证。</p></li><li><p><code class="language-plaintext highlighter-rouge">Folder getDefaultFolder()</code>：获取默认文件夹，通常是收件箱。</p></li><li><p><strong><code class="language-plaintext highlighter-rouge">Folder getFolder(String name)</code>：根据给定的文件夹名称获取文件夹对象。</strong></p></li><li><p><code class="language-plaintext highlighter-rouge">Folder[] getPersonalNamespaces()</code>：获取个人文件夹命名空间。</p></li><li><p><code class="language-plaintext highlighter-rouge">Folder[] getUserNamespaces(String user)</code>：获取给定用户的文件夹命名空间。</p></li><li><p><code class="language-plaintext highlighter-rouge">void close()</code>：关闭与邮件服务器的连接。</p></li><li><p><code class="language-plaintext highlighter-rouge">boolean isConnected()</code>：检查是否已连接到邮件服务器。</p></li><li><p><code class="language-plaintext highlighter-rouge">void addConnectionListener(ConnectionListener listener)</code>：添加连接监听器，以便在连接状态发生变化时接收通知。</p></li><li><p><code class="language-plaintext highlighter-rouge">void removeConnectionListener(ConnectionListener listener)</code>：移除连接监听器。</p></li></ol><hr /><p><code class="language-plaintext highlighter-rouge">Folder</code> 类表示邮件文件夹，它提供了一组方法用于管理和操作邮件文件夹中的邮件。下面是一些常用的 <code class="language-plaintext highlighter-rouge">Folder</code> 类的方法：</p><ol><li><code class="language-plaintext highlighter-rouge">String getFullName()</code>：获取邮件文件夹的完整名称。</li><li><code class="language-plaintext highlighter-rouge">boolean exists()</code>：检查邮件文件夹是否存在。</li><li><strong><code class="language-plaintext highlighter-rouge">void open(int mode)</code>：打开邮件文件夹，并指定打开模式（只读、读写等）。</strong></li><li><code class="language-plaintext highlighter-rouge">boolean isOpen()</code>：检查邮件文件夹是否已打开。</li><li><code class="language-plaintext highlighter-rouge">void appendMessages(Message[] msgs)</code>：向邮件文件夹中追加邮件。</li><li><code class="language-plaintext highlighter-rouge">void delete(boolean recurse)</code>：删除邮件文件夹，可选择是否递归删除子文件夹。</li><li><strong><code class="language-plaintext highlighter-rouge">int getMessageCount()</code>：获取邮件文件夹中的邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getNewMessageCount()</code>：获取邮件文件夹中的新邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getUnreadMessageCount()</code>：获取邮件文件夹中的未读邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">int getDeletedMessageCount()</code>：获取邮件文件夹中已标记为删除的邮件数量。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">Message[] getMessages()</code>：获取邮件文件夹中的所有邮件。</strong></li><li><code class="language-plaintext highlighter-rouge">Message getMessage(int msgnum)</code>：根据邮件序号获取邮件对象。</li><li><code class="language-plaintext highlighter-rouge">Message getMessage(int start,int end)</code>：根据邮件序号获取邮件对象。</li><li><code class="language-plaintext highlighter-rouge">Message[] search(SearchTerm term)</code>：根据指定的搜索条件搜索邮件。</li><li><code class="language-plaintext highlighter-rouge">void setFlags(Message[] msgs, Flags flag, boolean value)</code>：设置邮件的标志（例如，已读、已删除等）。</li><li><code class="language-plaintext highlighter-rouge">Message[] expunge()</code>：清除标记为已删除的邮件，并返回已删除的邮件数组。</li><li><code class="language-plaintext highlighter-rouge">void close(boolean expunge)</code>：关闭邮件文件夹，可选择是否删除已删除的邮件。</li><li><code class="language-plaintext highlighter-rouge">void addMessageChangedListener(MessageChangedListener listener)</code>：添加邮件变化监听器。</li><li><code class="language-plaintext highlighter-rouge">void removeMessageChangedListener(MessageChangedListener listener)</code>：移除邮件变化监听器。</li><li><code class="language-plaintext highlighter-rouge">void addFolderListener(FolderListener listener)</code>：添加文件夹监听器。</li><li><code class="language-plaintext highlighter-rouge">void removeFolderListener(FolderListener listener)</code>：移除文件夹监听器。</li></ol><hr /><p><code class="language-plaintext highlighter-rouge">MimeUtility</code> 类是 JavaMail API 中用于处理 MIME（Multipurpose Internet Mail Extensions）消息的实用工具类。它提供了一些方法来编码和解码 MIME 消息的各个部分，以及处理文本和二进制数据的方法。</p><p>以下是 <code class="language-plaintext highlighter-rouge">MimeUtility</code> 类的一些常用方法：</p><ol><li><strong>编码方法</strong>：<ul><li><code class="language-plaintext highlighter-rouge">encodeText(String text) throws UnsupportedEncodingException</code>：对文本进行 MIME 编码。</li><li><code class="language-plaintext highlighter-rouge">encodeWord(String word) throws UnsupportedEncodingException</code>：对单词进行 MIME 编码。</li></ul></li><li><strong>解码方法</strong>：<ul><li><strong><code class="language-plaintext highlighter-rouge">decodeText(String text) throws UnsupportedEncodingException</code>：解码 MIME 编码的文本。</strong></li></ul></li><li><strong>其他方法</strong>：<ul><li><code class="language-plaintext highlighter-rouge">fold(int used, String s)</code>：根据 RFC 2822 规范折叠长行。</li><li><code class="language-plaintext highlighter-rouge">unfold(String s)</code>：从折叠的行中还原原始行。</li><li><code class="language-plaintext highlighter-rouge">encodeWord(String word, String charset, String encoding) throws UnsupportedEncodingException</code>：使用指定的字符集和编码对单词进行编码。</li><li><code class="language-plaintext highlighter-rouge">decodeWord(String eword)</code> throws ParseException：解码 MIME 编码的单词。</li><li><code class="language-plaintext highlighter-rouge">quote(String s, String specials)</code>：对字符串中的特殊字符进行引用。</li><li><code class="language-plaintext highlighter-rouge">quote(String s)</code>：对字符串中的特殊字符进行引用，默认引用所有非 ASCII 字符。</li></ul></li></ol><p>这些方法可能会抛出 <code class="language-plaintext highlighter-rouge">UnsupportedEncodingException</code> 或 <code class="language-plaintext highlighter-rouge">ParseException</code> 异常，因此在使用时需要处理这些异常。</p><hr /><p>一个<code class="language-plaintext highlighter-rouge">Store</code>对象表示整个邮箱的存储，要收取邮件，需要通过<code class="language-plaintext highlighter-rouge">Store</code>访问指定的<code class="language-plaintext highlighter-rouge">Folder</code>（文件夹），<strong>通常是<code class="language-plaintext highlighter-rouge">INBOX</code>表示收件箱</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取收件箱:</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="c1">// 以读写方式打开:</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">);</span>
<span class="c1">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getNewMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unread messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getUnreadMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getDeletedMessageCount</span><span class="o">());</span>
<span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Message</span> <span class="n">message</span> <span class="o">:</span> <span class="n">messages</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 打印每一封邮件:</span>
    <span class="n">printMessage</span><span class="o">((</span><span class="nc">MimeMessage</span><span class="o">)</span> <span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span>
<span class="n">store</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><p>获取到一个<code class="language-plaintext highlighter-rouge">Message</code>对象时，可以强制转型为<code class="language-plaintext highlighter-rouge">MimeMessage</code>，然后打印出邮件主题、发件人、收件人等信息：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">printMessage</span><span class="o">(</span><span class="nc">MimeMessage</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">MessagingException</span> <span class="o">{</span>
    <span class="c1">// 邮件主题:</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Subject: "</span> <span class="o">+</span> <span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getSubject</span><span class="o">()));</span>
    <span class="c1">// 发件人:</span>
    <span class="nc">Address</span><span class="o">[]</span> <span class="n">froms</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="na">getFrom</span><span class="o">();</span>
    <span class="nc">InternetAddress</span> <span class="n">address</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InternetAddress</span><span class="o">)</span> <span class="n">froms</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"From: "</span> <span class="o">+</span> <span class="n">getAddressInfo</span><span class="o">(</span><span class="n">address</span><span class="o">));</span>
    <span class="c1">// 收件人（可以有多个）:</span>
    <span class="nc">InternetAddress</span><span class="o">[]</span> <span class="n">recipients</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InternetAddress</span><span class="o">[])</span> <span class="n">msg</span><span class="o">.</span><span class="na">getAllRecipients</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">InternetAddress</span> <span class="n">recipient</span> <span class="o">:</span> <span class="n">recipients</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Recipient: "</span> <span class="o">+</span> <span class="n">getAddressInfo</span><span class="o">(</span><span class="n">recipient</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="c1">// 打印邮件内容</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
<span class="o">}</span>

<span class="cm">/**
 * 获取InternetAddress的字符串形式
 * @param address 地址
 * @return 字符串
 * @throws UnsupportedEncodingException 字符编码不支持。
 */</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">getAddressInfo</span><span class="o">(</span><span class="nc">InternetAddress</span> <span class="n">address</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">personal</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">getPersonal</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">personal</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">address</span><span class="o">.</span><span class="na">getAddress</span><span class="o">()</span> <span class="o">:</span> <span class="o">(</span><span class="nc">MimeUtility</span><span class="o">.</span><span class="na">decodeText</span><span class="o">(</span><span class="n">personal</span><span class="o">)</span> <span class="o">+</span> <span class="s">" &lt;"</span> <span class="o">+</span> <span class="n">address</span><span class="o">.</span><span class="na">getAddress</span><span class="o">()</span> <span class="o">+</span> <span class="s">"&gt;"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>获取邮件的正文，一个<code class="language-plaintext highlighter-rouge">MimeMessage</code>对象也是一个<code class="language-plaintext highlighter-rouge">Part</code>对象，它可能只包含一个文本，也可能是一个<code class="language-plaintext highlighter-rouge">Multipart</code>对象，即由几个<code class="language-plaintext highlighter-rouge">Part</code>构成，因此，需要递归地解析出完整的正文：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 邮件内容
 * @param part 邮件部分内容
 * @return 字符串
 * @throws MessagingException
 * @throws IOException
 */</span>
<span class="kd">static</span> <span class="nc">String</span> <span class="nf">getBody</span><span class="o">(</span><span class="nc">Part</span> <span class="n">part</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是文本:</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"multipart/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是一个Multipart对象:</span>
        <span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Multipart</span><span class="o">)</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
        <span class="c1">// 循环解析每个子Part:</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">BodyPart</span> <span class="n">bodyPart</span> <span class="o">=</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getBodyPart</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">body</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p><strong>注意！网易邮箱对于IMAP协议收信有额外要求</strong>：<a href="https://help.mail.163.com/faqDetail.do?code=d7a5dc8471cd0c0e8b4b8f4f8e49998b374173cfe9171305fa1ce630d7f67ac2eda07326646e6eb0">imap连接提示Unsafe Login，被阻止的收信行为</a></p><p>在<code class="language-plaintext highlighter-rouge">store.connect();</code>后面加上以下代码即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">store</span><span class="o">.</span><span class="na">connect</span><span class="o">();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="no">IAM</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span><span class="s">"myname"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"version"</span><span class="o">,</span><span class="s">"1.0.0"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"vendor"</span><span class="o">,</span><span class="s">"myclient"</span><span class="o">);</span>
<span class="no">IAM</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"support-email"</span><span class="o">,</span><span class="s">"testmail@test.com"</span><span class="o">);</span>
<span class="o">((</span><span class="nc">IMAPStore</span><span class="o">)</span><span class="n">store</span><span class="o">).</span><span class="na">id</span><span class="o">(</span><span class="no">IAM</span><span class="o">);</span>
</code></pre></div></div><p>发送IMAP ID命令（如果服务器支持）并从服务器返回结果。 ID命令向服务器标识客户端并将有关服务器的信息返回给客户端。</p><hr /><p><strong>获取最近的10封邮件：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取邮件文件夹</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_ONLY</span><span class="o">);</span>
<span class="c1">// 获取邮件总数</span>
<span class="kt">int</span> <span class="n">totalMessages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">();</span>
<span class="c1">// 计算要获取的起始邮件号和结束邮件号</span>
<span class="kt">int</span> <span class="n">startMessage</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">totalMessages</span> <span class="o">-</span> <span class="mi">9</span><span class="o">);</span> <span class="c1">// 最近的第一封邮件</span>
<span class="kt">int</span> <span class="n">endMessage</span> <span class="o">=</span> <span class="n">totalMessages</span><span class="o">;</span> <span class="c1">// 最近的最后一封邮件</span>
<span class="c1">// 获取最近的 10 封邮件</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">(</span><span class="n">startMessage</span><span class="o">,</span> <span class="n">endMessage</span><span class="o">);</span>
<span class="c1">// 关闭邮件文件夹</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div><h3 id="保存附件">保存附件</h3><p>加个判断就行。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">getBody</span><span class="o">(</span><span class="nc">Part</span> <span class="n">part</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是文本:</span>
        <span class="k">return</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">part</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"multipart/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="c1">// Part是一个Multipart对象:</span>
        <span class="nc">Multipart</span> <span class="n">multipart</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Multipart</span><span class="o">)</span> <span class="n">part</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
        <span class="c1">// 循环解析每个子Part:</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getCount</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">BodyPart</span> <span class="n">bodyPart</span> <span class="o">=</span> <span class="n">multipart</span><span class="o">.</span><span class="na">getBodyPart</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">body</span> <span class="o">=</span> <span class="n">getBody</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">body</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">body</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="c1">// 保存非文本类型的部分为文件</span>
            <span class="n">saveAttachment</span><span class="o">(</span><span class="n">bodyPart</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">saveAttachment</span><span class="o">(</span><span class="nc">BodyPart</span> <span class="n">bodyPart</span><span class="o">,</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">MessagingException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">bodyPart</span><span class="o">.</span><span class="na">isMimeType</span><span class="o">(</span><span class="s">"text/*"</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">fileName</span> <span class="o">=</span> <span class="n">bodyPart</span><span class="o">.</span><span class="na">getFileName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">fileName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">fileName</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">InputStream</span> <span class="n">inputStream</span> <span class="o">=</span> <span class="n">bodyPart</span><span class="o">.</span><span class="na">getInputStream</span><span class="o">();</span>
            <span class="nc">FileOutputStream</span> <span class="n">outputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">fileName</span><span class="o">);</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">1024</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">bytesRead</span><span class="o">;</span>
            <span class="k">while</span> <span class="o">((</span><span class="n">bytesRead</span> <span class="o">=</span> <span class="n">inputStream</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="n">buffer</span><span class="o">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">outputStream</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">buffer</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bytesRead</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">outputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">inputStream</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n已保存的附件: "</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="n">fileName</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="删除邮件">删除邮件</h3><p><code class="language-plaintext highlighter-rouge">Folder</code> 类的删除方法：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">void open(int mode)</code>：打开邮件文件夹，并指定打开模式（只读、读写等）。</strong><ul><li><code class="language-plaintext highlighter-rouge">Folder.READ_ONLY</code>（值为 1）：只读模式，用于读取邮件但不能修改或删除邮件。</li><li><code class="language-plaintext highlighter-rouge">Folder.READ_WRITE</code>（值为 2）：读写模式，用于读取、修改和删除邮件。</li></ul></li><li><strong><code class="language-plaintext highlighter-rouge">void setFlags(Message[] msgs, Flags flag, boolean value)</code>：设置邮件的标志（例如，已读、已删除等）。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">Message[] expunge()</code>：清除标记为已删除的邮件，并返回已删除的邮件数组。</strong></li><li><code class="language-plaintext highlighter-rouge">void close(boolean expunge)</code>：关闭邮件文件夹，可选择是否删除已删除的邮件。</li></ol><hr /><p>在 JavaMail API 中，<code class="language-plaintext highlighter-rouge">Flags</code> 类表示邮件的标志。<code class="language-plaintext highlighter-rouge">Flags</code> 类提供了一些常量来表示不同的标志，可以使用这些常量来设置或检查邮件的标志。</p><p>构造方法：</p><ol><li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags();</code>：创建一个空的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags(Flags.Flag flag);</code>：创建一个包含指定标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">Flags flags = new Flags(Flags flags);</code>：创建一个包含另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中所有标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象。</li></ol><p>常用的方法：</p><ol><li><code class="language-plaintext highlighter-rouge">void add(Flags.Flag flag)</code>：添加指定的标志。</li><li><code class="language-plaintext highlighter-rouge">void add(Flags flags)</code>：添加另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li><li><code class="language-plaintext highlighter-rouge">boolean contains(Flags.Flag flag)</code>：检查是否存在指定的标志。</li><li><code class="language-plaintext highlighter-rouge">boolean containsAll(Flags flags)</code>：检查是否存在另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li><li><code class="language-plaintext highlighter-rouge">boolean equals(Object obj)</code>：比较两个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象是否相等。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag[] getSystemFlags()</code>：返回系统定义的所有标志。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag[] getUserFlags()</code>：返回用户定义的所有标志。</li><li><code class="language-plaintext highlighter-rouge">int hashCode()</code>：返回 <code class="language-plaintext highlighter-rouge">Flags</code> 对象的哈希码值。</li><li><code class="language-plaintext highlighter-rouge">void remove(Flags.Flag flag)</code>：移除指定的标志。</li><li><code class="language-plaintext highlighter-rouge">void remove(Flags flags)</code>：移除另一个 <code class="language-plaintext highlighter-rouge">Flags</code> 对象中的所有标志。</li><li><code class="language-plaintext highlighter-rouge">void set(Flags.Flag flag, boolean value)</code>：设置指定标志的状态。</li><li><code class="language-plaintext highlighter-rouge">void setFlags(Flags.Flag[] flags, boolean value)</code>：设置指定一组标志的状态。</li><li><code class="language-plaintext highlighter-rouge">void setUserFlags(Flags flags)</code>：设置用户定义的标志。</li></ol><p>以下是 <code class="language-plaintext highlighter-rouge">Flags</code> 类中定义的一些常量：</p><ol><li><code class="language-plaintext highlighter-rouge">Flags.Flag.ANSWERED</code>：已回复标志，表示邮件已被回复。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.DELETED</code>：已删除标志，表示邮件已被标记为删除。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.DRAFT</code>：草稿标志，表示邮件是草稿。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.FLAGGED</code>：已标记标志，表示邮件已被标记。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.RECENT</code>：最近标志，表示邮件是最近收到的。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.SEEN</code>：已读标志，表示邮件已被阅读。</li><li><code class="language-plaintext highlighter-rouge">Flags.Flag.USER</code>：用户标志，表示用户定义的标志。</li></ol><p>可以使用这些常量来创建 <code class="language-plaintext highlighter-rouge">Flags</code> 对象，并将其传递给 <code class="language-plaintext highlighter-rouge">Folder.setFlags()</code> 方法来设置邮件的标志。例如，要创建一个包含已读和已回复标志的 <code class="language-plaintext highlighter-rouge">Flags</code> 对象，可以使用以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">();</span>
<span class="n">flags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">SEEN</span><span class="o">);</span>
<span class="n">flags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">ANSWERED</span><span class="o">);</span>
</code></pre></div></div><hr /><p><strong>批量删除邮件：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取收件箱:</span>
<span class="nc">Folder</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="na">getFolder</span><span class="o">(</span><span class="s">"INBOX"</span><span class="o">);</span>
<span class="c1">// 以读写方式打开:</span>
<span class="n">folder</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="nc">Folder</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">);</span>
<span class="c1">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Total messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"New messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getNewMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unread messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getUnreadMessageCount</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Deleted messages: "</span> <span class="o">+</span> <span class="n">folder</span><span class="o">.</span><span class="na">getDeletedMessageCount</span><span class="o">());</span>
<span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">setFlags</span><span class="o">(</span><span class="n">messages</span><span class="o">,</span><span class="n">flags</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 关闭邮件文件夹并删除标记为删除的邮件</span>
</code></pre></div></div><p>实际上<code class="language-plaintext highlighter-rouge">Folder</code>的<code class="language-plaintext highlighter-rouge">setFlags</code>方法内部是这样的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msgs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
    <span class="n">msgs</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">setFlags</span><span class="o">(</span><span class="n">flag</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">MessageRemovedException</span> <span class="n">me</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// This message is expunged, skip </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因此可以直接在单个<code class="language-plaintext highlighter-rouge">Message</code>上调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="nc">Flags</span> <span class="n">flags</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Flags</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">);</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlags</span><span class="o">(</span><span class="n">flags</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="c1">//...</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span> <span class="c1">// 关闭邮件文件夹并删除标记为删除的邮件</span>
</code></pre></div></div><p>加<code class="language-plaintext highlighter-rouge">s</code>的表示可以设置多个，后面的<code class="language-plaintext highlighter-rouge">Boolean</code>值表示是设置还是取消，还可以通过<code class="language-plaintext highlighter-rouge">expunge()</code>方法删除。</p><p>试试用<code class="language-plaintext highlighter-rouge">folder.expunge();</code>删除标记为删除的邮件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">expunge</span><span class="o">();</span><span class="c1">//删除标记为删除的邮件</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭邮件文件夹</span>
</code></pre></div></div><p>提示：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> jakarta.mail.MethodNotSupportedException: Expunge not supported
</code></pre></div></div><p>在使用 POP3 协议时，<code class="language-plaintext highlighter-rouge">POP3Folder</code> 不支持 <code class="language-plaintext highlighter-rouge">expunge()</code> 方法，因此会抛出 <code class="language-plaintext highlighter-rouge">MethodNotSupportedException</code> 异常。因为 POP3 协议不支持在服务器上直接删除邮件，而是通过将邮件标记为删除，然后在下次会话中关闭连接时执行实际的删除操作。</p><p>如果需要在使用 POP3 协议时删除邮件，可以考虑以下方法：</p><ol><li>在读取邮件时，将要删除的邮件标记为删除，但不执行 <code class="language-plaintext highlighter-rouge">expunge()</code> 操作。最后调用 <code class="language-plaintext highlighter-rouge">close(true)</code> 方法来执行实际的删除操作。</li><li>使用其他支持邮件删除的协议，如 IMAP。IMAP 协议支持在服务器上直接删除邮件。</li></ol><p><strong>使用IMAP协议执行同样的代码：</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 获取每一封邮件:</span>
<span class="nc">Message</span><span class="o">[]</span> <span class="n">messages</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="na">getMessages</span><span class="o">();</span>
<span class="n">messages</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">setFlag</span><span class="o">(</span><span class="nc">Flags</span><span class="o">.</span><span class="na">Flag</span><span class="o">.</span><span class="na">DELETED</span><span class="o">,</span><span class="kc">true</span><span class="o">);</span>
<span class="n">folder</span><span class="o">.</span><span class="na">expunge</span><span class="o">();</span><span class="c1">//删除标记为删除的邮件</span>
<span class="c1">//...</span>
<span class="n">folder</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 关闭邮件文件夹</span>
</code></pre></div></div><p>正常删除。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" target="_blank">https://acteds.github.io/2024/04/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1713934028', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
