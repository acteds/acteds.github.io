<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>加密与安全 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="加密与安全"><meta name="keywords" content="博客"><meta name="og:keywords" content="博客"><meta name="description" content="加密与安全"><meta name="og:description" content="加密与安全"><meta property="og:url" content="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-04-14"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="加密与安全"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">加密与安全</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/04/14 </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 14527 字，约 42 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="加密与安全">加密与安全</h1><h2 id="编码">编码</h2><p>ASCII码就是一种编码，字母<code class="language-plaintext highlighter-rouge">A</code>的编码是十六进制的<code class="language-plaintext highlighter-rouge">0x41</code>，字母<code class="language-plaintext highlighter-rouge">B</code>是<code class="language-plaintext highlighter-rouge">0x42</code>，以此类推。因为ASCII编码最多只能有128个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code class="language-plaintext highlighter-rouge">0x4e2d</code>，使用UTF-8则需要3个字节编码。因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p><p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p><h3 id="url编码">URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分</p><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p><ul><li>如果字符是<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>，<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>，<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>以及<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">_</code>、<code class="language-plaintext highlighter-rouge">.</code>、<code class="language-plaintext highlighter-rouge">*</code>，则保持不变；</li><li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code class="language-plaintext highlighter-rouge">%XX</code>表示。</li></ul><p>例如：字符<code class="language-plaintext highlighter-rouge">中</code>的UTF-8编码是<code class="language-plaintext highlighter-rouge">0xe4b8ad</code>，因此，它的URL编码是<code class="language-plaintext highlighter-rouge">%E4%B8%AD</code>。URL编码总是大写。</p><p>Java标准库提供了一个<code class="language-plaintext highlighter-rouge">URLEncoder</code>类来对任意字符串进行URL编码，而<code class="language-plaintext highlighter-rouge">URLDecoder则</code>可以解码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">URLEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="s">"中 文!"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span><span class="c1">//%E4%B8%AD+%E6%96%87%21</span>
<span class="nc">String</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nc">URLDecoder</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">encoded</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">decoded</span><span class="o">);</span><span class="c1">//中 文!</span>
</code></pre></div></div><p><strong>和标准的URL编码稍有不同，<code class="language-plaintext highlighter-rouge">URLEncoder</code>把空格字符编码成<code class="language-plaintext highlighter-rouge">+</code></strong>，而现在的URL编码标准要求空格被编码为<code class="language-plaintext highlighter-rouge">%20</code>，不过，服务器都可以处理这两种情况。</p><h3 id="base64编码">Base64编码</h3><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>、<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>、<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>、<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个<code class="language-plaintext highlighter-rouge">int</code>整数表示，然后查表，把<code class="language-plaintext highlighter-rouge">int</code>整数用索引对应到字符，得到编码后的字符串。</p><p>举个例子：3个byte数据分别是<code class="language-plaintext highlighter-rouge">ff</code>、<code class="language-plaintext highlighter-rouge">e0</code>、<code class="language-plaintext highlighter-rouge">1</code>，按6bit分组得到<code class="language-plaintext highlighter-rouge">39</code>、<code class="language-plaintext highlighter-rouge">0b</code>、<code class="language-plaintext highlighter-rouge">22</code>和<code class="language-plaintext highlighter-rouge">2d</code>：</p><pre><code class="language-ascii">┌───────────────┬───────────────┬───────────────┐
│      ff       │      e0       │       1       │
└───────────────┴───────────────┴───────────────┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│1│1│1│1│1│1│1│1│1│0│0│0│0│0│0│0│0│0│0│0│0│1│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌───────────┬───────────┬───────────┬───────────┐
│    63     │    62     │     0     │     1     │
└───────────┴───────────┴───────────┴───────────┘
</code></pre><p>因为6位整数的范围总是<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">63</code>，所以，能用64个字符表示：字符<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>对应索引<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">25</code>，字符<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>对应索引<code class="language-plaintext highlighter-rouge">26</code>~<code class="language-plaintext highlighter-rouge">51</code>，字符<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>对应索引<code class="language-plaintext highlighter-rouge">52</code>~<code class="language-plaintext highlighter-rouge">61</code>，最后两个索引<code class="language-plaintext highlighter-rouge">62</code>、<code class="language-plaintext highlighter-rouge">63</code>分别用字符<code class="language-plaintext highlighter-rouge">+</code>和<code class="language-plaintext highlighter-rouge">/</code>表示。</p><p>所以对于<code class="language-plaintext highlighter-rouge">ff</code>、<code class="language-plaintext highlighter-rouge">e0</code>、<code class="language-plaintext highlighter-rouge">1</code>，首先变成：<code class="language-plaintext highlighter-rouge">63</code>、<code class="language-plaintext highlighter-rouge">62</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">1</code>，再根据表转换为：<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>。</p><p>如果输入的<code class="language-plaintext highlighter-rouge">byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code class="language-plaintext highlighter-rouge">0x00</code>，编码后，在结尾加一个<code class="language-plaintext highlighter-rouge">=</code>表示补充了1个<code class="language-plaintext highlighter-rouge">0x00</code>，加两个<code class="language-plaintext highlighter-rouge">=</code>表示补充了2个<code class="language-plaintext highlighter-rouge">0x00</code>，解码的时候，去掉末尾补充的一个或两个<code class="language-plaintext highlighter-rouge">0x00</code>即可。</p><p>实际上，因为编码后的长度加上<code class="language-plaintext highlighter-rouge">=</code>总是4的倍数，所以即使不加<code class="language-plaintext highlighter-rouge">=</code>也可以计算出原始输入的<code class="language-plaintext highlighter-rouge">byte[]</code>。Base64编码的时候<strong>可以</strong>用<code class="language-plaintext highlighter-rouge">withoutPadding()</code>去掉<code class="language-plaintext highlighter-rouge">=</code>，解码出来的结果是一样的。</p><p>在Java中，二进制数据就是<code class="language-plaintext highlighter-rouge">byte[]</code>数组。Java标准库提供了<code class="language-plaintext highlighter-rouge">Base64</code>来对<code class="language-plaintext highlighter-rouge">byte[]</code>数组进行编解码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"中 文!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">b64encoded</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span><span class="c1">//5LitIOaWhyE=</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span><span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">output</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span><span class="c1">//中 文!</span>
</code></pre></div></div><p>因为标准的Base64编码会出现<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">/</code>和<code class="language-plaintext highlighter-rouge">=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code class="language-plaintext highlighter-rouge">+</code>变成<code class="language-plaintext highlighter-rouge">-</code>，<code class="language-plaintext highlighter-rouge">/</code>变成<code class="language-plaintext highlighter-rouge">_</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xFF</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xE0</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0x1</span><span class="o">};</span>

<span class="nc">String</span> <span class="n">b64encoded</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span><span class="c1">///+AB</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//[-1, -32, 1]</span>

<span class="nc">String</span> <span class="n">b64encoded2</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getUrlEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded2</span><span class="o">);</span><span class="c1">//_-AB</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getUrlDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded2</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//[-1, -32, 1]</span>
</code></pre></div></div><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p><p>Base64 编码将每 6 位原始数据编码为 8 位字符（即 1 字节），因此会使数据长度增加约 1/3。这是因为 每 3 个字节原始数据编码后变为 4 个字节的 Base64 字符串。</p><h2 id="哈希算法">哈希算法</h2><p>哈希算法（Hash）又称<strong>摘要算法</strong>（Digest），它的作用是：对任意一组输入数据进行计算，得到一个<strong>固定长度</strong>的输出<strong>摘要</strong>。</p><p>哈希算法最重要的特点就是：</p><ul><li>相同的输入<strong>一定</strong>得到相同的输出；</li><li>不同的输入<strong>大概率</strong>得到不同的输出。</li></ul><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><p>Java字符串的<code class="language-plaintext highlighter-rouge">hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节<code class="language-plaintext highlighter-rouge">int</code>整数。</p><h3 id="哈希碰撞">哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%X\n"</span><span class="o">,</span><span class="s">"AaAaAa"</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 0x7460E8C0</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%X\n"</span><span class="o">,</span><span class="s">"BBAaBB"</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 0x7460E8C0</span>
</code></pre></div></div><p>碰撞是一定会出现的，因为输出的字节长度是固定的，<code class="language-plaintext highlighter-rouge">String</code>的<code class="language-plaintext highlighter-rouge">hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p><ul><li>碰撞概率低；</li><li>不能猜测输出。</li></ul><p>常用的哈希算法有：</p><table><thead><tr><th style="text-align: left">算法</th><th style="text-align: left">输出长度（位）</th><th style="text-align: left">输出长度（字节）</th></tr></thead><tbody><tr><td style="text-align: left">MD5</td><td style="text-align: left">128 bits</td><td style="text-align: left">16 bytes</td></tr><tr><td style="text-align: left">SHA-1</td><td style="text-align: left">160 bits</td><td style="text-align: left">20 bytes</td></tr><tr><td style="text-align: left">RipeMD-160</td><td style="text-align: left">160 bits</td><td style="text-align: left">20 bytes</td></tr><tr><td style="text-align: left">SHA-256</td><td style="text-align: left">256 bits</td><td style="text-align: left">32 bytes</td></tr><tr><td style="text-align: left">SHA-512</td><td style="text-align: left">512 bits</td><td style="text-align: left">64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。以MD5算法为例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个MessageDigest实例:</span>
<span class="nc">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"MD5"</span><span class="o">);</span>
<span class="c1">// 反复调用update,输入数据:</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"World"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">();</span> <span class="c1">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">result</span><span class="o">).</span><span class="na">toString</span><span class="o">(</span><span class="mi">16</span><span class="o">));</span>
</code></pre></div></div><p>首先根据哈希算法获取一个<code class="language-plaintext highlighter-rouge">MessageDigest</code>实例，然后，反复调用<code class="language-plaintext highlighter-rouge">update(byte[])</code>输入数据。当输入结束后，调用<code class="language-plaintext highlighter-rouge">digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p><h3 id="biginteger的坑"><code class="language-plaintext highlighter-rouge">BigInteger</code>的坑</h3><p><strong>注意：如果<code class="language-plaintext highlighter-rouge">result</code>前面有0会在转换为<code class="language-plaintext highlighter-rouge">BigInteger</code>时丢失</strong>，因为<code class="language-plaintext highlighter-rouge">BigInteger</code>类在处理字符串时会忽略前导零，因为在数值上它们没有意义。</p><p>如果需要保留前导零，可以使用其他方法，如使用<code class="language-plaintext highlighter-rouge">printf</code>格式化补0到指定位数输出，或者直接使用字节数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.math.BigInteger</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">hexString</span> <span class="o">=</span> <span class="s">"000005bd4639f848dd8ed27f1b3f6b0d"</span><span class="o">;</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span><span class="o">=</span><span class="n">hexStringToByteArray</span><span class="o">(</span><span class="n">hexString</span><span class="o">);</span>
        <span class="c1">//5bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">result</span><span class="o">).</span><span class="na">toString</span><span class="o">(</span><span class="mi">16</span><span class="o">));</span>
        <span class="c1">//如果知道输出的位数，可以使用printf：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%032x\n"</span><span class="o">,</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">result</span><span class="o">));</span>
        <span class="c1">//还可以这样直接传入16进制字符串：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%032x\n"</span><span class="o">,</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="n">hexString</span><span class="o">,</span><span class="mi">16</span><span class="o">));</span>
        <span class="c1">//如果不知道，就直接用字节数组吧：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 16进制字符串转换为字节数组。
     * @param hexString 16进制字符串
     * @return 字节数组
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">hexStringToByteArray</span><span class="o">(</span><span class="nc">String</span> <span class="n">hexString</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">hexString</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">byteArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">byteArray</span><span class="o">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span>
                    <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">digit</span><span class="o">(</span><span class="n">hexString</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">16</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">)</span>
                    <span class="o">+</span> <span class="nc">Character</span><span class="o">.</span><span class="na">digit</span><span class="o">(</span><span class="n">hexString</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">),</span> <span class="mi">16</span><span class="o">)</span>
            <span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">byteArray</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="用途">用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>在网站上下载软件的时候，经常看到下载页显示的哈希，如何判断下载到本地的软件是原始的、未经篡改的文件？只需要自己计算一下下载到本地的文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：数据库管理员能够看到用户明文口令；数据库数据一旦泄漏，黑客即可获取用户明文口令。</p><p>不存储用户的原始口令，那么如何对用户进行认证？方法是存储用户口令的哈希，例如，MD5。在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p><p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p><p>使用哈希口令时，还要注意防止彩虹表攻击。如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的<strong>常用口令</strong>和它们的MD5的对照表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令。因此不要使用弱密码，也不要使用生日等个人信息作为密码的原因，在社工面前找到账号对应的人是很容易的。</p><p>即使用户使用了常用口令，也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">md5</span><span class="o">(</span><span class="n">salt</span><span class="o">+</span><span class="n">inputPassword</span><span class="o">)</span>
</code></pre></div></div><p>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th style="text-align: left">username</th><th style="text-align: left">salt</th><th style="text-align: left">password</th></tr></thead><tbody><tr><td style="text-align: left">bob</td><td style="text-align: left">H1r0a</td><td style="text-align: left">a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td style="text-align: left">alice</td><td style="text-align: left">7$p2w</td><td style="text-align: left">e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td style="text-align: left">tim</td><td style="text-align: left">z5Sk9</td><td style="text-align: left">1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的<strong>彩虹表失效</strong>，即使用户使用常用口令，也无法从MD5反推原始口令。这样，就算黑客拿到了数据库和源代码，也要对每个<code class="language-plaintext highlighter-rouge">salt</code>重新计算彩虹表。这已经不能叫彩虹表了，这就是暴力破解。</p><p>就算破解出与<strong>加盐哈希前的密码</strong>一样<strong>加盐哈希的密码</strong>，也不一定能保证就是<strong>原始的密码</strong>，而<strong>只要不是原始的密码</strong>，就算账号所有者的所有网站都设置同一个密码，也只破解了这一家网站的密码，因为每家网站的盐不一样。但是，如果某家网站没有加盐，被破解，那么意味着<strong>原始密码</strong>就被泄露了。</p><p>因此不建议所有网站都设置同一个密码，或者按网站的信任程度和重要性使用不同的密码，并且这些密码之间要像哈希生成的特征码一样，不具有通过几个密码推测出规律的可能。</p><p>盐的生成可以使用随机数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
<span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">bs</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">HexFormat</span><span class="o">.</span><span class="na">of</span><span class="o">().</span><span class="na">formatHex</span><span class="o">(</span><span class="n">bs</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</code></pre></div></div><h3 id="sha-1">SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p><p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code class="language-plaintext highlighter-rouge">"SHA-1"</code>。类似的，计算SHA-256，我们需要传入名称<code class="language-plaintext highlighter-rouge">"SHA-256"</code>，计算SHA-512，我们需要传入名称<code class="language-plaintext highlighter-rouge">"SHA-512"</code>。</p><p>MD5因为输出长度较短，短时间内破解是可能的，目前已经<strong>不推荐使用</strong>。</p><h2 id="bouncycastle">BouncyCastle</h2><p>Java标准库提供了一系列常用的哈希算法。</p><p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p><p>方法一：自己写一个，难度很大；</p><p>方法二：找一个现成的第三方库，直接使用。</p><p><a href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p><p>首先，把BouncyCastle提供的jar包放到classpath中。这个jar包就是<code class="language-plaintext highlighter-rouge">bcprov-jdk18on-xxx.jar</code>，可以从<a href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p><p>Java标准库的<code class="language-plaintext highlighter-rouge">java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注册BouncyCastle:</span>
<span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
<span class="c1">// 按名称正常调用:</span>
<span class="nc">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RipeMD160"</span><span class="o">);</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，注册BouncyCastle是通过下面的语句实现的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
</code></pre></div></div><p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p><h2 id="hmac算法">Hmac算法</h2><p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p><p>我们回顾一下哈希算法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">input</span><span class="o">)</span>
</code></pre></div></div><p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">salt</span> <span class="o">+</span> <span class="n">input</span><span class="o">)</span>
</code></pre></div></div><p>这个<code class="language-plaintext highlighter-rouge">salt</code>可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>Hmac算法<strong>总是和某种哈希算法配合起来用的</strong>。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HmacMD5 ≈ md5(secure_random_key, input)
</code></pre></div></div><p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加<code class="language-plaintext highlighter-rouge">salt</code>，有如下好处：</p><ul><li>HmacMD5使用的<code class="language-plaintext highlighter-rouge">key</code>长度是64字节，更安全；</li><li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li><li>Hmac输出和原有的哈希算法长度一致。</li></ul><p>可见，Hmac本质上就是把<code class="language-plaintext highlighter-rouge">key</code>混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供<code class="language-plaintext highlighter-rouge">key</code>。</p><p>为了保证安全，我们不会自己指定<code class="language-plaintext highlighter-rouge">key</code>，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">KeyGenerator</span> <span class="n">keyGen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
    <span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyGen</span><span class="o">.</span><span class="na">generateKey</span><span class="o">();</span>
    <span class="c1">// 打印随机生成的key:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="n">out</span><span class="o">(</span><span class="n">skey</span><span class="o">);</span>
    <span class="nc">Mac</span> <span class="n">mac</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
    <span class="n">mac</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">key</span><span class="o">);</span><span class="c1">//传入key</span>
    <span class="n">mac</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span><span class="c1">//添加数据</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mac</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span><span class="c1">//调用</span>
    <span class="n">out</span><span class="o">(</span><span class="n">result</span><span class="o">);</span><span class="c1">//a7f9bf40c2929734...</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>和MD5相比，使用HmacMD5的步骤是：</p><ol><li>通过名称<code class="language-plaintext highlighter-rouge">HmacMD5</code>获取<code class="language-plaintext highlighter-rouge">KeyGenerator</code>实例；</li><li>通过<code class="language-plaintext highlighter-rouge">KeyGenerator</code>创建一个<code class="language-plaintext highlighter-rouge">SecretKey</code>实例；</li><li>通过名称<code class="language-plaintext highlighter-rouge">HmacMD5</code>获取<code class="language-plaintext highlighter-rouge">Mac</code>实例；</li><li>用<code class="language-plaintext highlighter-rouge">SecretKey</code>初始化<code class="language-plaintext highlighter-rouge">Mac</code>实例；</li><li>对<code class="language-plaintext highlighter-rouge">Mac</code>实例反复调用<code class="language-plaintext highlighter-rouge">update(byte[])</code>输入数据；</li><li>调用<code class="language-plaintext highlighter-rouge">Mac</code>实例的<code class="language-plaintext highlighter-rouge">doFinal()</code>获取最终的哈希值。</li></ol><p>可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p><table><thead><tr><th style="text-align: left">username</th><th style="text-align: left">secret_key (64 bytes)</th><th style="text-align: left">password</th></tr></thead><tbody><tr><td style="text-align: left">bob</td><td style="text-align: left">a8c06e05f92e…5e16</td><td style="text-align: left">7e0387872a57c85ef6dddbaa12f376de</td></tr><tr><td style="text-align: left">alice</td><td style="text-align: left">e6a343693985…f4be</td><td style="text-align: left">c1f929ac2552642b302e739bc0cdbaac</td></tr><tr><td style="text-align: left">tim</td><td style="text-align: left">f27a973dfdc0…6003</td><td style="text-align: left">af57651c3a8a73303515804d4af43790</td></tr></tbody></table><p>有了Hmac计算的哈希和<code class="language-plaintext highlighter-rouge">SecretKey</code>，我们想要验证怎么办？这时，<code class="language-plaintext highlighter-rouge">SecretKey</code>不能从<code class="language-plaintext highlighter-rouge">KeyGenerator</code>生成，而是从一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组恢复：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.KeyGenerator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.Mac</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">KeyGenerator</span> <span class="n">keyGen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyGen</span><span class="o">.</span><span class="na">generateKey</span><span class="o">();</span>
        <span class="c1">// 打印随机生成的key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
        <span class="n">out</span><span class="o">(</span><span class="n">skey</span><span class="o">);</span>
        <span class="nc">Mac</span> <span class="n">mac</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="n">mac</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">key</span><span class="o">);</span><span class="c1">//传入key</span>
        <span class="n">mac</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span><span class="c1">//添加数据</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mac</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span><span class="c1">//调用</span>
        <span class="n">out</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
        <span class="c1">// 通过字节数组恢复key。</span>
        <span class="nc">SecretKey</span> <span class="n">restoreTheKey</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">skey</span><span class="o">,</span> <span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="nc">Mac</span> <span class="n">mac2</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="n">mac2</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">restoreTheKey</span><span class="o">);</span>
        <span class="n">mac2</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">mac2</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span>
        <span class="n">out</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>恢复<code class="language-plaintext highlighter-rouge">SecretKey</code>的语句就是<code class="language-plaintext highlighter-rouge">new SecretKeySpec(hkey, "HmacMD5")</code>。</p><h2 id="对称加密算法">对称加密算法</h2><p>对称加密算法就是传统的用一个密码进行加密和解密。</p><p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>secret = encrypt(key, message);
</code></pre></div></div><p>而解密则相反，它接收密码和密文，然后输出明文：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plain = decrypt(key, secret);
</code></pre></div></div><p>在软件开发中，常用的对称加密算法有：</p><table><thead><tr><th style="text-align: left">算法</th><th style="text-align: left">密钥长度</th><th style="text-align: left">工作模式</th><th style="text-align: left">填充模式</th></tr></thead><tbody><tr><td style="text-align: left">DES</td><td style="text-align: left">56/64</td><td style="text-align: left">ECB/CBC/PCBC/CTR/…</td><td style="text-align: left">NoPadding/PKCS5Padding/…</td></tr><tr><td style="text-align: left">AES</td><td style="text-align: left">128/192/256</td><td style="text-align: left">ECB/CBC/PCBC/CTR/…</td><td style="text-align: left">NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td style="text-align: left">IDEA</td><td style="text-align: left">128</td><td style="text-align: left">ECB</td><td style="text-align: left">PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p><p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p><h3 id="使用aes加密">使用AES加密</h3><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 128位密钥 = 16 bytes Key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"1234567890abcdef"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>
        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>

    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原文: Hello, world!，16进制：48656c6c6f2c20776f726c6421
密文: ��D�E����\�，16进制：db188644e9450610b9edbec41aee5cde
解密: Hello, world!，16进制：48656c6c6f2c20776f726c6421
</code></pre></div></div><p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p><ol><li>根据算法名称/工作模式/填充模式获取<code class="language-plaintext highlighter-rouge">Cipher</code>实例；</li><li>根据算法名称初始化一个<code class="language-plaintext highlighter-rouge">SecretKey</code>实例，密钥必须是指定长度；</li><li>使用<code class="language-plaintext highlighter-rouge">SecretKey</code>初始化<code class="language-plaintext highlighter-rouge">Cipher</code>实例，并设置加密或解密模式；</li><li>传入明文或密文，获得密文或明文。</li></ol><p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低。</p><p>对于AES加密算法，<strong>不论使用哪种模式</strong>（如ECB、CBC等），<strong>密钥长度必须</strong>为16字节（128位）、24字节（192位）或32字节（256位）。这是由AES算法的规范确定的，以确保加密过程的安全性和正确性。如果密钥长度不符合这些要求，将无法正确使用AES算法进行加密。</p><hr /><p>更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.IvParameterSpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 256位密钥 = 32 bytes Key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"1234567890abcdef1234567890abcdef"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>
        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>


    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="c1">// CBC模式需要生成一个16 bytes的initialization vector:</span>
        <span class="nc">SecureRandom</span> <span class="n">sr</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstanceStrong</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">sr</span><span class="o">.</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
        <span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">,</span> <span class="n">ivps</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="c1">// IV不需要保密，把IV和密文拼一起返回:</span>
        <span class="k">return</span> <span class="nf">join</span><span class="o">(</span><span class="n">iv</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 把input分割成IV和密文:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">input</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">16</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">iv</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="c1">// 解密:</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">,</span> <span class="n">ivps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">join</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs1</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">bs2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">bs1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">bs2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bs1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bs1</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bs2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">bs1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">bs2</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>CBC（Cipher Block Chaining）模式还需要一个16字节的初始向量（IV）。对于IV（Initialization Vector，初始化向量）参数，在AES算法中，它的长度<strong>是固定的</strong>，<strong>为16字节</strong>（128位）。无论使用哪种模式（如CBC、CTR等），IV参数的长度都应为16字节。IV的作用是为了在每次加密操作时引入随机性，即使是在使用相同密钥加密相同数据的情况下也能产生不同的密文。</p><p><strong>为保证安全，随机数必须使用<code class="language-plaintext highlighter-rouge">SecureRandom</code>生成</strong>，虽然也管不到你用<code class="language-plaintext highlighter-rouge">Random</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span><span class="o">=</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
<span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
<span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
</code></pre></div></div><p>因为多了一个<code class="language-plaintext highlighter-rouge">IvParameterSpec</code>实例，因此，初始化方法需要调用<code class="language-plaintext highlighter-rouge">Cipher</code>的一个重载方法并传入<code class="language-plaintext highlighter-rouge">IvParameterSpec</code>。</p><p>其实也就多了个随机数变量而已，<strong>注意随机数必须16字节，key必须为16/24/32字节</strong>。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/" target="_blank">/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1713145865', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
