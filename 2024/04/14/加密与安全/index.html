<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>加密与安全 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="加密与安全"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言Base64编码、URL编码、哈希算法、对称加密算法、口令加密算法、 密钥交换算法、 非对称加密算法、签名算法、数字证书。"><meta name="og:description" content="引言Base64编码、URL编码、哈希算法、对称加密算法、口令加密算法、 密钥交换算法、 非对称加密算法、签名算法、数字证书。"><meta property="og:url" content="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-04-14"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="加密与安全"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">加密与安全</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/04/14 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 37762 字，约 108 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>Base64编码、URL编码、哈希算法、对称加密算法、口令加密算法、 密钥交换算法、 非对称加密算法、签名算法、数字证书。</p><h1 id="加密与安全">加密与安全</h1><h2 id="编码">编码</h2><p>ASCII码就是一种编码，字母<code class="language-plaintext highlighter-rouge">A</code>的编码是十六进制的<code class="language-plaintext highlighter-rouge">0x41</code>，字母<code class="language-plaintext highlighter-rouge">B</code>是<code class="language-plaintext highlighter-rouge">0x42</code>，以此类推。因为ASCII编码最多只能有128个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code class="language-plaintext highlighter-rouge">0x4e2d</code>，使用UTF-8则需要3个字节编码。因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p><p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p><h3 id="url编码">URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分</p><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p><ul><li>如果字符是<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>，<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>，<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>以及<code class="language-plaintext highlighter-rouge">-</code>、<code class="language-plaintext highlighter-rouge">_</code>、<code class="language-plaintext highlighter-rouge">.</code>、<code class="language-plaintext highlighter-rouge">*</code>，则保持不变；</li><li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code class="language-plaintext highlighter-rouge">%XX</code>表示。</li></ul><p>例如：字符<code class="language-plaintext highlighter-rouge">中</code>的UTF-8编码是<code class="language-plaintext highlighter-rouge">0xe4b8ad</code>，因此，它的URL编码是<code class="language-plaintext highlighter-rouge">%E4%B8%AD</code>。URL编码总是大写。</p><p>Java标准库提供了一个<code class="language-plaintext highlighter-rouge">URLEncoder</code>类来对任意字符串进行URL编码，而<code class="language-plaintext highlighter-rouge">URLDecoder则</code>可以解码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">URLEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="s">"中 文!"</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span><span class="c1">//%E4%B8%AD+%E6%96%87%21</span>
<span class="nc">String</span> <span class="n">decoded</span> <span class="o">=</span> <span class="nc">URLDecoder</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">encoded</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">decoded</span><span class="o">);</span><span class="c1">//中 文!</span>
</code></pre></div></div><p><strong>和标准的URL编码稍有不同，<code class="language-plaintext highlighter-rouge">URLEncoder</code>把空格字符编码成<code class="language-plaintext highlighter-rouge">+</code></strong>，而现在的URL编码标准要求空格被编码为<code class="language-plaintext highlighter-rouge">%20</code>，不过，服务器都可以处理这两种情况。</p><h3 id="base64编码">Base64编码</h3><p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>、<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>、<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>、<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">=</code>这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个<code class="language-plaintext highlighter-rouge">int</code>整数表示，然后查表，把<code class="language-plaintext highlighter-rouge">int</code>整数用索引对应到字符，得到编码后的字符串。</p><p>举个例子：3个byte数据分别是<code class="language-plaintext highlighter-rouge">ff</code>、<code class="language-plaintext highlighter-rouge">e0</code>、<code class="language-plaintext highlighter-rouge">1</code>，按6bit分组得到<code class="language-plaintext highlighter-rouge">39</code>、<code class="language-plaintext highlighter-rouge">0b</code>、<code class="language-plaintext highlighter-rouge">22</code>和<code class="language-plaintext highlighter-rouge">2d</code>：</p><pre><code class="language-ascii">┌───────────────┬───────────────┬───────────────┐
│      ff       │      e0       │       1       │
└───────────────┴───────────────┴───────────────┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│1│1│1│1│1│1│1│1│1│1│1│0│0│0│0│0│0│0│0│0│0│0│0│1│
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌───────────┬───────────┬───────────┬───────────┐
│    63     │    62     │     0     │     1     │
└───────────┴───────────┴───────────┴───────────┘
</code></pre><p>因为6位整数的范围总是<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">63</code>，所以，能用64个字符表示：字符<code class="language-plaintext highlighter-rouge">A</code>~<code class="language-plaintext highlighter-rouge">Z</code>对应索引<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">25</code>，字符<code class="language-plaintext highlighter-rouge">a</code>~<code class="language-plaintext highlighter-rouge">z</code>对应索引<code class="language-plaintext highlighter-rouge">26</code>~<code class="language-plaintext highlighter-rouge">51</code>，字符<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">9</code>对应索引<code class="language-plaintext highlighter-rouge">52</code>~<code class="language-plaintext highlighter-rouge">61</code>，最后两个索引<code class="language-plaintext highlighter-rouge">62</code>、<code class="language-plaintext highlighter-rouge">63</code>分别用字符<code class="language-plaintext highlighter-rouge">+</code>和<code class="language-plaintext highlighter-rouge">/</code>表示。</p><p>所以对于<code class="language-plaintext highlighter-rouge">ff</code>、<code class="language-plaintext highlighter-rouge">e0</code>、<code class="language-plaintext highlighter-rouge">1</code>，首先变成：<code class="language-plaintext highlighter-rouge">63</code>、<code class="language-plaintext highlighter-rouge">62</code>、<code class="language-plaintext highlighter-rouge">0</code>、<code class="language-plaintext highlighter-rouge">1</code>，再根据表转换为：<code class="language-plaintext highlighter-rouge">/</code>、<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">A</code>、<code class="language-plaintext highlighter-rouge">B</code>。</p><p>如果输入的<code class="language-plaintext highlighter-rouge">byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code class="language-plaintext highlighter-rouge">0x00</code>，编码后，在结尾加一个<code class="language-plaintext highlighter-rouge">=</code>表示补充了1个<code class="language-plaintext highlighter-rouge">0x00</code>，加两个<code class="language-plaintext highlighter-rouge">=</code>表示补充了2个<code class="language-plaintext highlighter-rouge">0x00</code>，解码的时候，去掉末尾补充的一个或两个<code class="language-plaintext highlighter-rouge">0x00</code>即可。</p><p>实际上，因为编码后的长度加上<code class="language-plaintext highlighter-rouge">=</code>总是4的倍数，所以即使不加<code class="language-plaintext highlighter-rouge">=</code>也可以计算出原始输入的<code class="language-plaintext highlighter-rouge">byte[]</code>。Base64编码的时候<strong>可以</strong>用<code class="language-plaintext highlighter-rouge">withoutPadding()</code>去掉<code class="language-plaintext highlighter-rouge">=</code>，解码出来的结果是一样的。</p><p>在Java中，二进制数据就是<code class="language-plaintext highlighter-rouge">byte[]</code>数组。Java标准库提供了<code class="language-plaintext highlighter-rouge">Base64</code>来对<code class="language-plaintext highlighter-rouge">byte[]</code>数组进行编解码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="s">"中 文!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">b64encoded</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span><span class="c1">//5LitIOaWhyE=</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">output</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span><span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">output</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span><span class="c1">//中 文!</span>
</code></pre></div></div><p>因为标准的Base64编码会出现<code class="language-plaintext highlighter-rouge">+</code>、<code class="language-plaintext highlighter-rouge">/</code>和<code class="language-plaintext highlighter-rouge">=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code class="language-plaintext highlighter-rouge">+</code>变成<code class="language-plaintext highlighter-rouge">-</code>，<code class="language-plaintext highlighter-rouge">/</code>变成<code class="language-plaintext highlighter-rouge">_</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[]</span> <span class="o">{</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xFF</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0xE0</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mh">0x1</span><span class="o">};</span>

<span class="nc">String</span> <span class="n">b64encoded</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">);</span><span class="c1">///+AB</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//[-1, -32, 1]</span>

<span class="nc">String</span> <span class="n">b64encoded2</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getUrlEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b64encoded2</span><span class="o">);</span><span class="c1">//_-AB</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getUrlDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">b64encoded2</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//[-1, -32, 1]</span>
</code></pre></div></div><p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。</p><p>Base64 编码将每 6 位原始数据编码为 8 位字符（即 1 字节），因此会使数据长度增加约 1/3。这是因为 每 3 个字节原始数据编码后变为 4 个字节的 Base64 字符串。</p><h2 id="哈希算法">哈希算法</h2><p>哈希算法（Hash）又称<strong>摘要算法</strong>（Digest），它的作用是：对任意一组输入数据进行计算，得到一个<strong>固定长度</strong>的输出<strong>摘要</strong>。</p><p>哈希算法最重要的特点就是：</p><ul><li>相同的输入<strong>一定</strong>得到相同的输出；</li><li>不同的输入<strong>大概率</strong>得到不同的输出。</li></ul><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><p>Java字符串的<code class="language-plaintext highlighter-rouge">hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节<code class="language-plaintext highlighter-rouge">int</code>整数。</p><h3 id="哈希碰撞">哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%X\n"</span><span class="o">,</span><span class="s">"AaAaAa"</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 0x7460E8C0</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%X\n"</span><span class="o">,</span><span class="s">"BBAaBB"</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span> <span class="c1">// 0x7460E8C0</span>
</code></pre></div></div><p>碰撞是一定会出现的，因为输出的字节长度是固定的，<code class="language-plaintext highlighter-rouge">String</code>的<code class="language-plaintext highlighter-rouge">hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p><p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p><ul><li>碰撞概率低；</li><li>不能猜测输出。</li></ul><p>常用的哈希算法有：</p><table><thead><tr><th style="text-align: left">算法</th><th style="text-align: left">输出长度（位）</th><th style="text-align: left">输出长度（字节）</th></tr></thead><tbody><tr><td style="text-align: left">MD5</td><td style="text-align: left">128 bits</td><td style="text-align: left">16 bytes</td></tr><tr><td style="text-align: left">SHA-1</td><td style="text-align: left">160 bits</td><td style="text-align: left">20 bytes</td></tr><tr><td style="text-align: left">RipeMD-160</td><td style="text-align: left">160 bits</td><td style="text-align: left">20 bytes</td></tr><tr><td style="text-align: left">SHA-256</td><td style="text-align: left">256 bits</td><td style="text-align: left">32 bytes</td></tr><tr><td style="text-align: left">SHA-512</td><td style="text-align: left">512 bits</td><td style="text-align: left">64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。以MD5算法为例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个MessageDigest实例:</span>
<span class="nc">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"MD5"</span><span class="o">);</span>
<span class="c1">// 反复调用update,输入数据:</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"World"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">();</span> <span class="c1">// 16 bytes: 68e109f0f40ca72a15e05cc22786f8e6</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">result</span><span class="o">).</span><span class="na">toString</span><span class="o">(</span><span class="mi">16</span><span class="o">));</span>
</code></pre></div></div><p>首先根据哈希算法获取一个<code class="language-plaintext highlighter-rouge">MessageDigest</code>实例，然后，反复调用<code class="language-plaintext highlighter-rouge">update(byte[])</code>输入数据。当输入结束后，调用<code class="language-plaintext highlighter-rouge">digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p><h3 id="biginteger的坑"><code class="language-plaintext highlighter-rouge">BigInteger</code>的坑</h3><p><strong>注意：如果<code class="language-plaintext highlighter-rouge">result</code>前面有0会在转换为<code class="language-plaintext highlighter-rouge">BigInteger</code>时丢失</strong>，因为<code class="language-plaintext highlighter-rouge">BigInteger</code>类在处理字符串时会忽略前导零，因为在数值上它们没有意义。</p><p>如果需要保留前导零，可以使用其他方法，如使用<code class="language-plaintext highlighter-rouge">printf</code>格式化补0到指定位数输出，或者直接使用字节数组。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.math.BigInteger</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">hexString</span> <span class="o">=</span> <span class="s">"000005bd4639f848dd8ed27f1b3f6b0d"</span><span class="o">;</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span><span class="o">=</span><span class="n">hexStringToByteArray</span><span class="o">(</span><span class="n">hexString</span><span class="o">);</span>
        <span class="c1">//5bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">result</span><span class="o">).</span><span class="na">toString</span><span class="o">(</span><span class="mi">16</span><span class="o">));</span>
        <span class="c1">//如果知道输出的位数，可以使用printf：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%032x\n"</span><span class="o">,</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">result</span><span class="o">));</span>
        <span class="c1">//还可以这样直接传入16进制字符串：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%032x\n"</span><span class="o">,</span><span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="n">hexString</span><span class="o">,</span><span class="mi">16</span><span class="o">));</span>
        <span class="c1">//如果不知道，就直接用字节数组吧：000005bd4639f848dd8ed27f1b3f6b0d</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 16进制字符串转换为字节数组。
     * @param hexString 16进制字符串
     * @return 字节数组
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">hexStringToByteArray</span><span class="o">(</span><span class="nc">String</span> <span class="n">hexString</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">hexString</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">byteArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">byteArray</span><span class="o">[</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="o">(</span>
                    <span class="o">(</span><span class="nc">Character</span><span class="o">.</span><span class="na">digit</span><span class="o">(</span><span class="n">hexString</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="mi">16</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">)</span>
                    <span class="o">+</span> <span class="nc">Character</span><span class="o">.</span><span class="na">digit</span><span class="o">(</span><span class="n">hexString</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">),</span> <span class="mi">16</span><span class="o">)</span>
            <span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">byteArray</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="用途">用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p><p>在网站上下载软件的时候，经常看到下载页显示的哈希，如何判断下载到本地的软件是原始的、未经篡改的文件？只需要自己计算一下下载到本地的文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p><p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：数据库管理员能够看到用户明文口令；数据库数据一旦泄漏，黑客即可获取用户明文口令。</p><p>不存储用户的原始口令，那么如何对用户进行认证？方法是存储用户口令的哈希，例如，MD5。在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p><p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p><p>使用哈希口令时，还要注意防止彩虹表攻击。如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的<strong>常用口令</strong>和它们的MD5的对照表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令。因此不要使用弱密码，也不要使用生日等个人信息作为密码的原因，在社工面前找到账号对应的人是很容易的。</p><p>即使用户使用了常用口令，也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">md5</span><span class="o">(</span><span class="n">salt</span><span class="o">+</span><span class="n">inputPassword</span><span class="o">)</span>
</code></pre></div></div><p>经过加盐处理的数据库表，内容如下：</p><table><thead><tr><th style="text-align: left">username</th><th style="text-align: left">salt</th><th style="text-align: left">password</th></tr></thead><tbody><tr><td style="text-align: left">bob</td><td style="text-align: left">H1r0a</td><td style="text-align: left">a5022319ff4c56955e22a74abcc2c210</td></tr><tr><td style="text-align: left">alice</td><td style="text-align: left">7$p2w</td><td style="text-align: left">e5de688c99e961ed6e560b972dab8b6a</td></tr><tr><td style="text-align: left">tim</td><td style="text-align: left">z5Sk9</td><td style="text-align: left">1eee304b92dc0d105904e7ab58fd2f64</td></tr></tbody></table><p>加盐的目的在于使黑客的<strong>彩虹表失效</strong>，即使用户使用常用口令，也无法从MD5反推原始口令。这样，就算黑客拿到了数据库和源代码，也要对每个<code class="language-plaintext highlighter-rouge">salt</code>重新计算彩虹表。这已经不能叫彩虹表了，这就是暴力破解。</p><p>就算破解出与<strong>加盐哈希前的密码</strong>一样<strong>加盐哈希的密码</strong>，也不一定能保证就是<strong>原始的密码</strong>，而<strong>只要不是原始的密码</strong>，就算账号所有者的所有网站都设置同一个密码，也只破解了这一家网站的密码，因为每家网站的盐不一样。但是，如果某家网站没有加盐，被破解，那么意味着<strong>原始密码</strong>就被泄露了。</p><p>因此不建议所有网站都设置同一个密码，或者按网站的信任程度和重要性使用不同的密码，并且这些密码之间要像哈希生成的特征码一样，不具有通过几个密码推测出规律的可能。</p><p>盐的生成可以使用随机数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
<span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">bs</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">HexFormat</span><span class="o">.</span><span class="na">of</span><span class="o">().</span><span class="na">formatHex</span><span class="o">(</span><span class="n">bs</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</code></pre></div></div><h3 id="sha-1">SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p><p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code class="language-plaintext highlighter-rouge">"SHA-1"</code>。类似的，计算SHA-256，我们需要传入名称<code class="language-plaintext highlighter-rouge">"SHA-256"</code>，计算SHA-512，我们需要传入名称<code class="language-plaintext highlighter-rouge">"SHA-512"</code>。</p><p>MD5因为输出长度较短，短时间内破解是可能的，目前已经<strong>不推荐使用</strong>。</p><h2 id="bouncycastle">BouncyCastle</h2><p>Java标准库提供了一系列常用的哈希算法。</p><p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p><p>方法一：自己写一个，难度很大；</p><p>方法二：找一个现成的第三方库，直接使用。</p><p><a href="https://www.bouncycastle.org/">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p><p>首先，把BouncyCastle提供的jar包放到classpath中。这个jar包就是<code class="language-plaintext highlighter-rouge">bcprov-jdk18on-xxx.jar</code>，可以从<a href="https://www.bouncycastle.org/latest_releases.html">官方网站</a>下载。</p><p>Java标准库的<code class="language-plaintext highlighter-rouge">java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注册BouncyCastle:</span>
<span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
<span class="c1">// 按名称正常调用:</span>
<span class="nc">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RipeMD160"</span><span class="o">);</span>
<span class="n">md</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，注册BouncyCastle是通过下面的语句实现的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
</code></pre></div></div><p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p><h2 id="hmac算法">Hmac算法</h2><p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p><p>我们回顾一下哈希算法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">input</span><span class="o">)</span>
</code></pre></div></div><p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">digest</span> <span class="o">=</span> <span class="n">hash</span><span class="o">(</span><span class="n">salt</span> <span class="o">+</span> <span class="n">input</span><span class="o">)</span>
</code></pre></div></div><p>这个<code class="language-plaintext highlighter-rouge">salt</code>可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>Hmac算法<strong>总是和某种哈希算法配合起来用的</strong>。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HmacMD5 ≈ md5(secure_random_key, input)
</code></pre></div></div><p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加<code class="language-plaintext highlighter-rouge">salt</code>，有如下好处：</p><ul><li>HmacMD5使用的<code class="language-plaintext highlighter-rouge">key</code>长度是64字节，更安全；</li><li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li><li>Hmac输出和原有的哈希算法长度一致。</li></ul><p>可见，Hmac本质上就是把<code class="language-plaintext highlighter-rouge">key</code>混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供<code class="language-plaintext highlighter-rouge">key</code>。</p><p>为了保证安全，我们不会自己指定<code class="language-plaintext highlighter-rouge">key</code>，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="nc">KeyGenerator</span> <span class="n">keyGen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
    <span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyGen</span><span class="o">.</span><span class="na">generateKey</span><span class="o">();</span>
    <span class="c1">// 打印随机生成的key:</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="n">out</span><span class="o">(</span><span class="n">skey</span><span class="o">);</span>
    <span class="nc">Mac</span> <span class="n">mac</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
    <span class="n">mac</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">key</span><span class="o">);</span><span class="c1">//传入key</span>
    <span class="n">mac</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span><span class="c1">//添加数据</span>
    <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mac</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span><span class="c1">//调用</span>
    <span class="n">out</span><span class="o">(</span><span class="n">result</span><span class="o">);</span><span class="c1">//a7f9bf40c2929734...</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>和MD5相比，使用HmacMD5的步骤是：</p><ol><li>通过名称<code class="language-plaintext highlighter-rouge">HmacMD5</code>获取<code class="language-plaintext highlighter-rouge">KeyGenerator</code>实例；</li><li>通过<code class="language-plaintext highlighter-rouge">KeyGenerator</code>创建一个<code class="language-plaintext highlighter-rouge">SecretKey</code>实例；</li><li>通过名称<code class="language-plaintext highlighter-rouge">HmacMD5</code>获取<code class="language-plaintext highlighter-rouge">Mac</code>实例；</li><li>用<code class="language-plaintext highlighter-rouge">SecretKey</code>初始化<code class="language-plaintext highlighter-rouge">Mac</code>实例；</li><li>对<code class="language-plaintext highlighter-rouge">Mac</code>实例反复调用<code class="language-plaintext highlighter-rouge">update(byte[])</code>输入数据；</li><li>调用<code class="language-plaintext highlighter-rouge">Mac</code>实例的<code class="language-plaintext highlighter-rouge">doFinal()</code>获取最终的哈希值。</li></ol><p>可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p><table><thead><tr><th style="text-align: left">username</th><th style="text-align: left">secret_key (64 bytes)</th><th style="text-align: left">password</th></tr></thead><tbody><tr><td style="text-align: left">bob</td><td style="text-align: left">a8c06e05f92e…5e16</td><td style="text-align: left">7e0387872a57c85ef6dddbaa12f376de</td></tr><tr><td style="text-align: left">alice</td><td style="text-align: left">e6a343693985…f4be</td><td style="text-align: left">c1f929ac2552642b302e739bc0cdbaac</td></tr><tr><td style="text-align: left">tim</td><td style="text-align: left">f27a973dfdc0…6003</td><td style="text-align: left">af57651c3a8a73303515804d4af43790</td></tr></tbody></table><p>有了Hmac计算的哈希和<code class="language-plaintext highlighter-rouge">SecretKey</code>，我们想要验证怎么办？这时，<code class="language-plaintext highlighter-rouge">SecretKey</code>不能从<code class="language-plaintext highlighter-rouge">KeyGenerator</code>生成，而是从一个<code class="language-plaintext highlighter-rouge">byte[]</code>数组恢复：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.KeyGenerator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.Mac</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">KeyGenerator</span> <span class="n">keyGen</span> <span class="o">=</span> <span class="nc">KeyGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keyGen</span><span class="o">.</span><span class="na">generateKey</span><span class="o">();</span>
        <span class="c1">// 打印随机生成的key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
        <span class="n">out</span><span class="o">(</span><span class="n">skey</span><span class="o">);</span>
        <span class="nc">Mac</span> <span class="n">mac</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="n">mac</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">key</span><span class="o">);</span><span class="c1">//传入key</span>
        <span class="n">mac</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span><span class="c1">//添加数据</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="n">mac</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span><span class="c1">//调用</span>
        <span class="n">out</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
        <span class="c1">// 通过字节数组恢复key。</span>
        <span class="nc">SecretKey</span> <span class="n">restoreTheKey</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">skey</span><span class="o">,</span> <span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="nc">Mac</span> <span class="n">mac2</span> <span class="o">=</span> <span class="nc">Mac</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"HmacMD5"</span><span class="o">);</span>
        <span class="n">mac2</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">restoreTheKey</span><span class="o">);</span>
        <span class="n">mac2</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"HelloWorld"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">mac2</span><span class="o">.</span><span class="na">doFinal</span><span class="o">();</span>
        <span class="n">out</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>恢复<code class="language-plaintext highlighter-rouge">SecretKey</code>的语句就是<code class="language-plaintext highlighter-rouge">new SecretKeySpec(hkey, "HmacMD5")</code>。</p><h2 id="对称加密算法">对称加密算法</h2><p>对称加密算法就是传统的用一个密码进行加密和解密。</p><p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>secret = encrypt(key, message);
</code></pre></div></div><p>而解密则相反，它接收密码和密文，然后输出明文：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plain = decrypt(key, secret);
</code></pre></div></div><p>在软件开发中，常用的对称加密算法有：</p><table><thead><tr><th style="text-align: left">算法</th><th style="text-align: left">密钥长度</th><th style="text-align: left">工作模式</th><th style="text-align: left">填充模式</th></tr></thead><tbody><tr><td style="text-align: left">DES</td><td style="text-align: left">56/64</td><td style="text-align: left">ECB/CBC/PCBC/CTR/…</td><td style="text-align: left">NoPadding/PKCS5Padding/…</td></tr><tr><td style="text-align: left">AES</td><td style="text-align: left">128/192/256</td><td style="text-align: left">ECB/CBC/PCBC/CTR/…</td><td style="text-align: left">NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td style="text-align: left">IDEA</td><td style="text-align: left">128</td><td style="text-align: left">ECB</td><td style="text-align: left">PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p><p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p><h3 id="ecb模式">ECB模式</h3><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 128位密钥 = 16 bytes Key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"1234567890abcdef"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>
        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>

    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/ECB/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>原文: Hello, world!，16进制：48656c6c6f2c20776f726c6421
密文: ��D�E����\�，16进制：db188644e9450610b9edbec41aee5cde
解密: Hello, world!，16进制：48656c6c6f2c20776f726c6421
</code></pre></div></div><p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p><ol><li>根据算法名称/工作模式/填充模式获取<code class="language-plaintext highlighter-rouge">Cipher</code>实例；</li><li>根据算法名称初始化一个<code class="language-plaintext highlighter-rouge">SecretKey</code>实例，密钥必须是指定长度；</li><li>使用<code class="language-plaintext highlighter-rouge">SecretKey</code>初始化<code class="language-plaintext highlighter-rouge">Cipher</code>实例，并设置加密或解密模式；</li><li>传入明文或密文，获得密文或明文。</li></ol><p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低。</p><p>对于AES加密算法，<strong>不论使用哪种模式</strong>（如ECB、CBC等），<strong>密钥长度必须</strong>为16字节（128位）、24字节（192位）或32字节（256位）。这是由AES算法的规范确定的，以确保加密过程的安全性和正确性。如果密钥长度不符合这些要求，将无法正确使用AES算法进行加密。</p><hr /><h3 id="cbc模式">CBC模式</h3><p>更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.IvParameterSpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.SecretKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 256位密钥 = 32 bytes Key:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span> <span class="o">=</span> <span class="s">"1234567890abcdef1234567890abcdef"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>
        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>


    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="c1">// CBC模式需要生成一个16 bytes的initialization vector:</span>
        <span class="nc">SecureRandom</span> <span class="n">sr</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstanceStrong</span><span class="o">();</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span> <span class="o">=</span> <span class="n">sr</span><span class="o">.</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
        <span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">,</span> <span class="n">ivps</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
        <span class="c1">// IV不需要保密，把IV和密文拼一起返回:</span>
        <span class="k">return</span> <span class="nf">join</span><span class="o">(</span><span class="n">iv</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">key</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 把input分割成IV和密文:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">input</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">16</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">iv</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="n">data</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">data</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="c1">// 解密:</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"AES/CBC/PKCS5Padding"</span><span class="o">);</span>
        <span class="nc">SecretKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecretKeySpec</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"AES"</span><span class="o">);</span>
        <span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">keySpec</span><span class="o">,</span> <span class="n">ivps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">join</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs1</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">bs2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">bs1</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">bs2</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bs1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">bs1</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">bs2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">bs1</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">bs2</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>CBC（Cipher Block Chaining）模式还需要一个16字节的初始向量（IV）。对于IV（Initialization Vector，初始化向量）参数，在AES算法中，它的长度<strong>是固定的</strong>，<strong>为16字节</strong>（128位）。无论使用哪种模式（如CBC、CTR等），IV参数的长度都应为16字节。IV的作用是为了在每次加密操作时引入随机性，即使是在使用相同密钥加密相同数据的情况下也能产生不同的密文。</p><p><strong>为保证安全，随机数必须使用<code class="language-plaintext highlighter-rouge">SecureRandom</code>生成</strong>，虽然也管不到你用<code class="language-plaintext highlighter-rouge">Random</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">iv</span><span class="o">=</span><span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
<span class="k">new</span> <span class="nf">Random</span><span class="o">().</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
<span class="nc">IvParameterSpec</span> <span class="n">ivps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IvParameterSpec</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
</code></pre></div></div><p>因为多了一个<code class="language-plaintext highlighter-rouge">IvParameterSpec</code>实例，因此，初始化方法需要调用<code class="language-plaintext highlighter-rouge">Cipher</code>的一个重载方法并传入<code class="language-plaintext highlighter-rouge">IvParameterSpec</code>。</p><p>其实也就多了个随机数变量而已，<strong>注意随机数必须16字节，key必须为16/24/32字节</strong>。</p><h2 id="口令加密算法">口令加密算法</h2><p>AES加密，密钥长度是固定的128/192/256位。这是因为对称加密算法决定了口令<strong>必须是固定长度</strong>，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p><p>用户输入的口令并不能<strong>直接</strong>作为AES的密钥进行加密（<strong>除非长度恰好</strong>是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p><p>PBE就是Password Based Encryption的缩写，它的作用如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="n">generate</span><span class="o">(</span><span class="n">userPassword</span><span class="o">,</span> <span class="n">secureRandomPassword</span><span class="o">);</span>
</code></pre></div></div><p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.bouncycastle.jce.provider.BouncyCastleProvider</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.SecretKeyFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.PBEKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.spec.PBEParameterSpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.Security</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">// 把BouncyCastle作为Provider添加到java.security:</span>
        <span class="nc">Security</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="k">new</span> <span class="nc">BouncyCastleProvider</span><span class="o">());</span>
        <span class="c1">// 16 bytes随机Salt:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">salt</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstanceStrong</span><span class="o">().</span><span class="na">generateSeed</span><span class="o">(</span><span class="mi">16</span><span class="o">);</span>
        <span class="c1">// 加密口令:</span>
        <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"hello12345"</span><span class="o">;</span>
        <span class="c1">// 数据</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"原文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">data</span><span class="o">);</span><span class="c1">// 原文</span>

        <span class="c1">// 加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">password</span><span class="o">,</span><span class="n">salt</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"密文: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">encrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">// 密文</span>
        <span class="c1">// 解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">password</span><span class="o">,</span><span class="n">salt</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"解密: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"，16进制："</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">decrypted</span><span class="o">);</span><span class="c1">// 解密</span>
    <span class="o">}</span>


    <span class="c1">// 加密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">salt</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 通过password生成key</span>
        <span class="nc">PBEKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEKeySpec</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
        <span class="nc">SecretKeyFactory</span> <span class="n">skeyFactory</span> <span class="o">=</span> <span class="nc">SecretKeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">skeyFactory</span><span class="o">.</span><span class="na">generateSecret</span><span class="o">(</span><span class="n">keySpec</span><span class="o">);</span>
        <span class="c1">// 盐</span>
        <span class="nc">PBEParameterSpec</span> <span class="n">pbeps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEParameterSpec</span><span class="o">(</span><span class="n">salt</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="c1">// 加密</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">skey</span><span class="o">,</span> <span class="n">pbeps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 解密:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="nc">String</span> <span class="n">password</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">salt</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="c1">// 通过password生成key</span>
        <span class="nc">PBEKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEKeySpec</span><span class="o">(</span><span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
        <span class="nc">SecretKeyFactory</span> <span class="n">skeyFactory</span> <span class="o">=</span> <span class="nc">SecretKeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="nc">SecretKey</span> <span class="n">skey</span> <span class="o">=</span> <span class="n">skeyFactory</span><span class="o">.</span><span class="na">generateSecret</span><span class="o">(</span><span class="n">keySpec</span><span class="o">);</span>
        <span class="c1">// 盐</span>
        <span class="nc">PBEParameterSpec</span> <span class="n">pbeps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PBEParameterSpec</span><span class="o">(</span><span class="n">salt</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"PBEwithSHA1and128bitAES-CBC-BC"</span><span class="o">);</span>
        <span class="c1">// 解密</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">skey</span><span class="o">,</span> <span class="n">pbeps</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>



</code></pre></div></div><p>使用PBE时，还需要引入BouncyCastle，并指定算法是<code class="language-plaintext highlighter-rouge">PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用<code class="language-plaintext highlighter-rouge">Cipher</code>的<code class="language-plaintext highlighter-rouge">init()</code>方法时同时传入<code class="language-plaintext highlighter-rouge">SecretKey</code>和<code class="language-plaintext highlighter-rouge">PBEParameterSpec</code>实现的。在创建<code class="language-plaintext highlighter-rouge">PBEParameterSpec</code>的时候，我们还指定了循环次数<code class="language-plaintext highlighter-rouge">1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p><p>如果把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p><h2 id="密钥交换算法">密钥交换算法</h2><p>对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p><p>现在问题来了：如何传递密钥？</p><p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p><p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p><p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p><p>假设甲乙双方需要传递密钥，他们之间可以这么做：</p><ol><li>甲首先选择一个素数<code class="language-plaintext highlighter-rouge">p</code>，例如97，底数<code class="language-plaintext highlighter-rouge">g</code>是<code class="language-plaintext highlighter-rouge">p</code>的一个本原根，例如5，随机数<code class="language-plaintext highlighter-rouge">a</code>，例如123，然后计算<code class="language-plaintext highlighter-rouge">A=g^a mod p</code>，结果是34，然后，甲发送<code class="language-plaintext highlighter-rouge">p＝97</code>，<code class="language-plaintext highlighter-rouge">g=5</code>，<code class="language-plaintext highlighter-rouge">A=34</code>给乙；</li><li>乙方收到后，也选择一个随机数<code class="language-plaintext highlighter-rouge">b</code>，例如，456，然后计算<code class="language-plaintext highlighter-rouge">B = g^b mod p</code>，结果是75，乙再同时计算<code class="language-plaintext highlighter-rouge">s = A^b mod p</code>，结果是22；</li><li>乙把计算的<code class="language-plaintext highlighter-rouge">B=75</code>发给甲，甲计算<code class="language-plaintext highlighter-rouge">s ＝ B^a mod p</code>，计算结果与乙算出的结果一样，都是22。</li></ol><p>所以最终双方协商出的密钥<code class="language-plaintext highlighter-rouge">s</code>是22。注意到这个密钥<code class="language-plaintext highlighter-rouge">s</code>并没有在网络上传输。而通过网络传输的<code class="language-plaintext highlighter-rouge">p</code>，<code class="language-plaintext highlighter-rouge">g</code>，<code class="language-plaintext highlighter-rouge">A</code>和<code class="language-plaintext highlighter-rouge">B</code>是无法推算出<code class="language-plaintext highlighter-rouge">s</code>的，因为实际算法选择的素数是非常大的。</p><p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p><p>如果我们把<code class="language-plaintext highlighter-rouge">a</code>看成甲的私钥，<code class="language-plaintext highlighter-rouge">A</code>看成甲的公钥，<code class="language-plaintext highlighter-rouge">b</code>看成乙的私钥，<code class="language-plaintext highlighter-rouge">B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥<code class="language-plaintext highlighter-rouge">secretKey</code>，DH算法通过数学定律保证了双方各自计算出的<code class="language-plaintext highlighter-rouge">secretKey</code>是相同的。</p><p>使用Java实现DH算法的代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.crypto.KeyAgreement</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.X509EncodedKeySpec</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Bob和Alice:</span>
        <span class="nc">Person</span> <span class="n">bob</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>
        <span class="nc">Person</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">);</span>

        <span class="c1">// 各自生成KeyPair:</span>
        <span class="n">bob</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>

        <span class="c1">// 双方交换各自的PublicKey:</span>
        <span class="c1">// Bob根据Alice的PublicKey生成自己的本地密钥:</span>
        <span class="n">bob</span><span class="o">.</span><span class="na">generateSecretKey</span><span class="o">(</span><span class="n">alice</span><span class="o">.</span><span class="na">publicKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="c1">// Alice根据Bob的PublicKey生成自己的本地密钥:</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">generateSecretKey</span><span class="o">(</span><span class="n">bob</span><span class="o">.</span><span class="na">publicKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>

        <span class="c1">// 检查双方的本地密钥是否相同:注意公key私key后面一部分不一样。</span>
        <span class="n">bob</span><span class="o">.</span><span class="na">printKeys</span><span class="o">();</span>
        <span class="n">alice</span><span class="o">.</span><span class="na">printKeys</span><span class="o">();</span>
        <span class="c1">// 双方的SecretKey相同，后续通信将使用SecretKey作为密钥进行AES加解密...</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">PublicKey</span> <span class="n">publicKey</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">PrivateKey</span> <span class="n">privateKey</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">secretKey</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 生成本地KeyPair:</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateKeyPair</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DH"</span><span class="o">);</span>
            <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">512</span><span class="o">);</span>
            <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">privateKey</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
            <span class="k">this</span><span class="o">.</span><span class="na">publicKey</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">GeneralSecurityException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">generateSecretKey</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">receivedPubKeyBytes</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 从byte[]恢复PublicKey:</span>
            <span class="nc">X509EncodedKeySpec</span> <span class="n">keySpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">receivedPubKeyBytes</span><span class="o">);</span>
            <span class="nc">KeyFactory</span> <span class="n">kf</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DH"</span><span class="o">);</span>
            <span class="nc">PublicKey</span> <span class="n">receivedPublicKey</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">keySpec</span><span class="o">);</span>
            <span class="c1">// 生成本地密钥:</span>
            <span class="nc">KeyAgreement</span> <span class="n">keyAgreement</span> <span class="o">=</span> <span class="nc">KeyAgreement</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"DH"</span><span class="o">);</span>
            <span class="n">keyAgreement</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">privateKey</span><span class="o">);</span> <span class="c1">// 自己的PrivateKey</span>
            <span class="n">keyAgreement</span><span class="o">.</span><span class="na">doPhase</span><span class="o">(</span><span class="n">receivedPublicKey</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span> <span class="c1">// 对方的PublicKey</span>
            <span class="c1">// 生成SecretKey密钥:</span>
            <span class="k">this</span><span class="o">.</span><span class="na">secretKey</span> <span class="o">=</span> <span class="n">keyAgreement</span><span class="o">.</span><span class="na">generateSecret</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">GeneralSecurityException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printKeys</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Name: "</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Private key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">privateKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Public key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">publicKey</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"Secret key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">secretKey</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p><p>假设甲乙在交换公钥时被丙截获，丙把自己的公钥分别发送给甲乙两人，就变成了，甲丙通信，丙乙通信。所以使用对称加密不能防止中间人攻击</p><p>Diffie-Hellman密钥交换算法的最低和最高密钥长度取决于使用的具体实现和协议要求。一般来说，DH密钥的长度必须是64的倍数，并且范围在512到8192之间（包括512和8192）。</p><p>本原根是一个数学概念，在数论中使用。简单来说，对于一个素数$p$，如果有一个数$g$，满足$g$的不同次幂对$p$取模的结果能够覆盖从$1$到$p-1$的所有可能的余数，而且没有重复，那么$g$就是模$p$的本原根。</p><p>举个例子，考虑素数$p=7$。我们要找到一个数$g$，满足$g$的不同次幂对$7$取模的结果覆盖了$1$到$6$的所有余数。对于$p=7$，数$3$就是一个本原根，因为$3^1 \equiv 3 \pmod{7}$，$3^2 \equiv 2 \pmod{7}$，$3^3 \equiv 6 \pmod{7}$，$3^4 \equiv 4 \pmod{7}$，$3^5 \equiv 5 \pmod{7}$，$3^6 \equiv 1 \pmod{7}$。这里$3$的不同次幂依次覆盖了$1$到$6$的所有余数，且没有重复。</p><h2 id="非对称加密算法">非对称加密算法</h2><p>从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p><p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p><p>因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p><p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p><p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code class="language-plaintext highlighter-rouge">N*(N-1)/2</code>个密钥，因此每个人需要管理<code class="language-plaintext highlighter-rouge">N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p><p>既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p><p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p><ol><li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li><li>小红用自己的RSA私钥解密得到AES口令；</li><li>双方使用这个共享的AES口令用AES加密通信。</li></ol><p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p><p>Java标准库提供了RSA算法的实现，示例代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.UnsupportedEncodingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
        <span class="c1">// 明文:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">plain</span> <span class="o">=</span> <span class="s">"Hello, encrypt use RSA"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="c1">// 创建公钥／私钥对:</span>
        <span class="nc">Person</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">);</span>

        <span class="kt">byte</span><span class="o">[]</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">getPublicKey</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"public key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">pk</span><span class="o">);</span>

        <span class="c1">// 用Alice的公钥加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">encrypt</span><span class="o">(</span><span class="n">plain</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"encrypted: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span><span class="c1">//密文</span>


        <span class="kt">byte</span><span class="o">[]</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">getPrivateKey</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"private key: "</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">sk</span><span class="o">);</span>

        <span class="c1">// Alice用自己的私钥解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">alice</span><span class="o">.</span><span class="na">decrypt</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 私钥:</span>
    <span class="nc">PrivateKey</span> <span class="n">sk</span><span class="o">;</span>
    <span class="c1">// 公钥:</span>
    <span class="nc">PublicKey</span> <span class="n">pk</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="c1">// 生成公钥／私钥对:</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">pk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 把私钥导出为字节</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getPrivateKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">sk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 把公钥导出为字节</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getPublicKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">pk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="c1">// 用公钥加密:</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">pk</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 用私钥解密:</span>
    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">input</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">sk</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>RSA的公钥和私钥都可以通过<code class="language-plaintext highlighter-rouge">getEncoded()</code>方法获得以<code class="language-plaintext highlighter-rouge">byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从<code class="language-plaintext highlighter-rouge">byte[]</code>数组恢复公钥或私钥，可以这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">pkData</span> <span class="o">=</span> <span class="o">...</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">skData</span> <span class="o">=</span> <span class="o">...</span>
<span class="nc">KeyFactory</span> <span class="n">kf</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
<span class="c1">// 恢复公钥:</span>
<span class="nc">X509EncodedKeySpec</span> <span class="n">pkSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">pkData</span><span class="o">);</span>
<span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">pkSpec</span><span class="o">);</span>
<span class="c1">// 恢复私钥:</span>
<span class="nc">PKCS8EncodedKeySpec</span> <span class="n">skSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PKCS8EncodedKeySpec</span><span class="o">(</span><span class="n">skData</span><span class="o">);</span>
<span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePrivate</span><span class="o">(</span><span class="n">skSpec</span><span class="o">);</span>
</code></pre></div></div><p>以RSA算法为例，它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p><p>如果修改待加密的<code class="language-plaintext highlighter-rouge">byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。此外，只使用非对称加密算法不能防止中间人攻击。</p><p>对称加密只需记住别人的密码，就可以了，识别到是小红发的邮件，用小红的密码密码打开就可以了，发邮件，用自己的密码加密，发出去就可以了。这个问题是，有多少人就需要记多少人的密码，太麻烦了。 非对称加密，你只要记住自己的密码（秘钥），别人发给你的邮件，你也别管是谁的了，用你秘钥就可以打开。解邮件是很爽，但是，发邮件，就有问题了，你得记住每个人的公钥，然后，进行加密，这和记私钥有啥区别呢？</p><p>不过，好消息是，公钥之所以叫公钥，就是他不需要进行保密，你可以把你的公钥放在信封上和加密信，一起发给别人，别人也可以，把公钥放在信封上面，把邮件发给你，你就可以拿到别人的公钥了，然后就可以用别人的公钥加密文件一起发给别人了。所以，不需要记住别人的公钥，因为别人会告诉你。</p><p>中间人攻击是指：小红给你的发的邮件，被小明，拦截了，然后把信封上面的小红的公钥，换成了，小明的公钥。</p><h2 id="签名算法">签名算法</h2><p>使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p><p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p><p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p><p>这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如<code class="language-plaintext highlighter-rouge">小明喜欢小红</code>，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认<code class="language-plaintext highlighter-rouge">小明喜欢小红</code>这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。</p><p>因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">signature</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">privateKey</span><span class="o">,</span> <span class="n">sha256</span><span class="o">(</span><span class="n">message</span><span class="o">))</span>
</code></pre></div></div><p>对签名进行验证实际上就是用公钥解密：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hash</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">publicKey</span><span class="o">,</span> <span class="n">signature</span><span class="o">)</span>
</code></pre></div></div><p>然后把解密后的哈希与原始消息的哈希进行对比。</p><p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p><p>常用数字签名算法有：</p><ul><li>MD5withRSA</li><li>SHA1withRSA</li><li>SHA256withRSA</li></ul><p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p><h3 id="sha1withrsa">SHA1withRSA</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.UnsupportedEncodingException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">UnsupportedEncodingException</span> <span class="o">{</span>
        <span class="c1">// 生成RSA公钥/私钥:</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>

        <span class="c1">// 待签名的消息或摘要:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, I am Bob!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>

        <span class="c1">// 用自己的私钥签名:</span>
        <span class="nc">Signature</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">sk</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">signed</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>
        <span class="c1">// 将消息与签名公开，签名用来验证消息没有被篡改</span>
        <span class="n">out</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">signed</span><span class="o">);</span>

        <span class="c1">// 用某人公开的公钥验证，解析公开的签名和消息，是否是对应人的。</span>
        <span class="nc">Signature</span> <span class="n">v</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">pk</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
        <span class="c1">// 消息被篡改：</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message2</span> <span class="o">=</span> <span class="s">"Hello, I am Gay"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message2</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
        <span class="c1">// 用其他人的key，公钥对不上：</span>
        <span class="nc">PublicKey</span> <span class="n">pk2</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">().</span><span class="na">getPublic</span><span class="o">();</span>
        <span class="n">v</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">pk2</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>48656c6c6f2c204920616d20426f6221
3aa37bb696a9c9e808cf42e45e17a79d24139972ba409cce9be475fd00d97968e68a110f667e0cca5a5ed177919c5c20b2a3720bbfc0caa5ae128887da7312ab1be5b3ac409d3917853212a3a14eb96899054db49152fd57299922f3794e874325be498f824044f763753b2eb2c855e06d823c3f1fbaf8240eaf65a25cdac0fd
Hello, I am Bob!这消息保真吗? true
Hello, I am Gay这消息保真吗? false
Hello, I am Bob!这消息保真吗? false
</code></pre></div></div><p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p><h3 id="使用signedobject">使用<code class="language-plaintext highlighter-rouge">SignedObject</code></h3><p>实际上可以用<code class="language-plaintext highlighter-rouge">SignedObject</code>携带消息数据，它还会记录签名和签名的算法名称。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="c1">// 生成RSA密钥对</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">keyPairGenerator</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">keyPairGenerator</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">keyPair</span> <span class="o">=</span> <span class="n">keyPairGenerator</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">privateKey</span> <span class="o">=</span> <span class="n">keyPair</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="nc">PublicKey</span> <span class="n">publicKey</span> <span class="o">=</span> <span class="n">keyPair</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>

        <span class="c1">// 创建消息</span>
        <span class="nc">String</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, world!"</span><span class="o">;</span>
        <span class="nc">Signature</span> <span class="n">signature</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA256withRSA"</span><span class="o">);</span>
        <span class="c1">// 使用私钥对消息进行签名，创建含消息数据和签名的对象，SignedObject也会记录签名算法名称。</span>
        <span class="nc">SignedObject</span> <span class="n">signedObject</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SignedObject</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">privateKey</span><span class="o">,</span> <span class="n">signature</span><span class="o">);</span>

        <span class="c1">// 数据的字节数组表示</span>
        <span class="nc">ByteArrayOutputStream</span> <span class="n">byteArrayOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayOutputStream</span><span class="o">();</span><span class="c1">//内存模拟</span>
        <span class="nc">ObjectOutputStream</span> <span class="n">objectOutputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">byteArrayOutputStream</span><span class="o">);</span>
        <span class="n">objectOutputStream</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">signedObject</span><span class="o">);</span><span class="c1">//序列化</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">p7Data</span> <span class="o">=</span> <span class="n">byteArrayOutputStream</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span><span class="c1">//读取字节</span>

        <span class="c1">// 数据保存到文件或发送给其他方</span>
        <span class="n">out</span><span class="o">(</span><span class="n">p7Data</span><span class="o">);</span>


        <span class="nc">ByteArrayInputStream</span> <span class="n">byteArrayInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ByteArrayInputStream</span><span class="o">(</span><span class="n">p7Data</span><span class="o">);</span><span class="c1">//内存模拟</span>
        <span class="nc">ObjectInputStream</span> <span class="n">objectInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">byteArrayInputStream</span><span class="o">);</span>

        <span class="nc">SignedObject</span> <span class="n">signedObjectReceived</span> <span class="o">=</span> <span class="o">(</span><span class="nc">SignedObject</span><span class="o">)</span> <span class="n">objectInputStream</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span><span class="c1">//反序列化</span>
        <span class="c1">// 在接收方，可以使用公钥来验证消息，签名已经在对象里了</span>
        <span class="kt">boolean</span> <span class="n">verified</span> <span class="o">=</span> <span class="n">signedObjectReceived</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">publicKey</span><span class="o">,</span> <span class="n">signature</span><span class="o">);</span>
        <span class="c1">// 拿到消息</span>
        <span class="nc">String</span> <span class="n">verifiedMessage</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">signedObjectReceived</span><span class="o">.</span><span class="na">getObject</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">verifiedMessage</span><span class="o">+</span><span class="s">"，保真吗？"</span><span class="o">+</span><span class="n">verified</span><span class="o">);</span>

    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aced00057372001a6a6176612e73656375726974792e5369676e65644f626a65637409ffbd682a3cd5ff0200035b0007636f6e74656e747400025b425b00097369676e617475726571007e00014c000c746865616c676f726974686d7400124c6a6176612f6c616e672f537472696e673b7870757200025b42acf317f8060854e0020000787000000014aced000574000d48656c6c6f2c20776f726c64217571007e000400000080ad39f5b20d2178c282f04fd90a50ad55a4c444fea270919d61ce8813d7c74ffb6275357c25a1025890db1e78fbae9910f943c2955e6e0734b1ef9cdd83f6ddfa0d2d5d680999146dd3b5021d8c546e1b6e45c587d935a57cfbd32232188bfbe3ea0308a0ae7bc4036dfe0a9d3e495f713297bc33236c7f7981b8637bbc69de5574000d53484132353677697468525341
Hello, world!，保真吗？true
</code></pre></div></div><p>自建一个也非常容易，<code class="language-plaintext highlighter-rouge">SignedObject</code>是一个支持序列化，内部并封装了消息数据、签名信息和签名算法，实例化时要求传入消息数据，私钥，签名算法，内部不会保留私钥。还有验证方法<code class="language-plaintext highlighter-rouge">verify</code>，因为内部保存了签名信息，因此只需要传入公钥和签名算法即可。以及返回消息数据的<code class="language-plaintext highlighter-rouge">getObject</code>方法。<strong>注意！传入的消息数据如果是对象需要实现序列化。</strong></p><p><strong>DSA签名</strong></p><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p><p>DSA只能配合SHA使用，常用的算法有：</p><ul><li>SHA1withDSA</li><li>SHA256withDSA</li><li>SHA512withDSA</li></ul><p>和RSA数字签名相比，DSA的优点是更快。</p><p><strong>ECDSA签名</strong></p><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p><p>P1格式和P7格式是数字证书的编码格式，通常用于存储和传输证书及其相关信息。</p><p><strong>P1格式</strong></p><p>P1格式是一种简单的ASCII文本格式，通常用于存储私钥。P1格式的私钥文件以”—–BEGIN PRIVATE KEY—–“开头，以”—–END PRIVATE KEY—–“结尾，中间包含私钥的内容。</p><p>P1只是一种秘钥文件的规范，指明了文件中包含的内容是私钥或公钥，以及如何编码这些内容。在处理P1格式的秘钥文件时，需要注意文件中包含的标记（例如<code class="language-plaintext highlighter-rouge">-----BEGIN PRIVATE KEY-----</code>和<code class="language-plaintext highlighter-rouge">-----END PRIVATE KEY-----</code>）以及可能的Base64编码。根据具体的规范和编码，需要适当地处理文件内容以提取秘钥的原始数据，并使用相应的类和方法来解析和恢复秘钥对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileOutputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.InvalidKeySpecException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.PKCS8EncodedKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.spec.X509EncodedKeySpec</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Base64</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span><span class="o">,</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="c1">//生成P1格式公钥私钥文件</span>
        <span class="n">newP1</span><span class="o">();</span>

        <span class="c1">//读取P1格式公钥私钥文件</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">object</span> <span class="o">=</span> <span class="n">loadP1</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span><span class="o">=</span> <span class="o">(</span><span class="nc">PrivateKey</span><span class="o">)</span> <span class="n">object</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span><span class="o">=</span> <span class="o">(</span><span class="nc">PublicKey</span><span class="o">)</span> <span class="n">object</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// 待签名的消息或摘要:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, I am Bob!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>

        <span class="c1">// 用自己的私钥签名:</span>
        <span class="nc">Signature</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">sk</span><span class="o">);</span>
        <span class="n">s</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">signed</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>
        <span class="c1">// 将消息与签名公开，签名用来验证消息没有被篡改</span>
        <span class="n">out</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">signed</span><span class="o">);</span>

        <span class="c1">// 用某人公开的公钥验证，解析公开的签名和消息，是否是对应人的。</span>
        <span class="nc">Signature</span> <span class="n">v</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA1withRSA"</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">pk</span><span class="o">);</span>
        <span class="n">v</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">)+</span><span class="s">"这消息保真吗? "</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">signed</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">newP1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">NoSuchAlgorithmException</span> <span class="o">{</span>
        <span class="c1">// 生成RSA公钥/私钥:</span>
        <span class="nc">KeyPairGenerator</span> <span class="n">kpGen</span> <span class="o">=</span> <span class="nc">KeyPairGenerator</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>
        <span class="n">kpGen</span><span class="o">.</span><span class="na">initialize</span><span class="o">(</span><span class="mi">1024</span><span class="o">);</span>
        <span class="nc">KeyPair</span> <span class="n">kp</span> <span class="o">=</span> <span class="n">kpGen</span><span class="o">.</span><span class="na">generateKeyPair</span><span class="o">();</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPrivate</span><span class="o">();</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kp</span><span class="o">.</span><span class="na">getPublic</span><span class="o">();</span>

        <span class="c1">// P1格式公钥</span>
        <span class="nc">String</span> <span class="n">base64EncodedPublicKey</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">pk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">p1FormattedPublicKey</span> <span class="o">=</span> <span class="s">"-----BEGIN PUBLIC KEY-----\n"</span> <span class="o">+</span>
                <span class="n">base64EncodedPublicKey</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span>
                <span class="s">"-----END PUBLIC KEY-----\n"</span><span class="o">;</span>
        <span class="c1">// 将P1格式的公钥保存到文件</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"publicKey.p1"</span><span class="o">);</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">p1FormattedPublicKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="n">fos</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">// P1格式私钥</span>
        <span class="nc">String</span> <span class="n">base64EncodedPrivateKey</span> <span class="o">=</span> <span class="nc">Base64</span><span class="o">.</span><span class="na">getEncoder</span><span class="o">().</span><span class="na">encodeToString</span><span class="o">(</span><span class="n">sk</span><span class="o">.</span><span class="na">getEncoded</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">p1FormattedPrivateKey</span> <span class="o">=</span> <span class="s">"-----BEGIN PRIVATE KEY-----\n"</span> <span class="o">+</span>
                <span class="n">base64EncodedPrivateKey</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span>
                <span class="s">"-----END PRIVATE KEY-----\n"</span><span class="o">;</span>

        <span class="c1">// 将P1格式的私钥保存到文件</span>
        <span class="nc">FileOutputStream</span> <span class="n">fos2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"privateKey.p1"</span><span class="o">);</span>
        <span class="n">fos2</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">p1FormattedPrivateKey</span><span class="o">.</span><span class="na">getBytes</span><span class="o">());</span>
        <span class="n">fos2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">loadP1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InvalidKeySpecException</span><span class="o">,</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">NoSuchAlgorithmException</span> <span class="o">{</span>
        <span class="c1">// 加载P1格式的私钥</span>
        <span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"privateKey.p1"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">privateKeyBytes</span> <span class="o">=</span> <span class="n">fis</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">();</span>
        <span class="n">fis</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">// 移除文本标记</span>
        <span class="nc">String</span> <span class="n">s1</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">privateKeyBytes</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----BEGIN PRIVATE KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----END PRIVATE KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        <span class="n">privateKeyBytes</span><span class="o">=</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
        <span class="nc">KeyFactory</span> <span class="n">kf</span> <span class="o">=</span> <span class="nc">KeyFactory</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"RSA"</span><span class="o">);</span>

        <span class="c1">// 恢复私钥:</span>
        <span class="nc">PKCS8EncodedKeySpec</span> <span class="n">skSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PKCS8EncodedKeySpec</span><span class="o">(</span><span class="n">privateKeyBytes</span><span class="o">);</span>
        <span class="nc">PrivateKey</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePrivate</span><span class="o">(</span><span class="n">skSpec</span><span class="o">);</span>

        <span class="c1">// 加载P1格式的公钥</span>
        <span class="nc">FileInputStream</span> <span class="n">fis2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"publicKey.p1"</span><span class="o">);</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">publicKeyBytes</span> <span class="o">=</span> <span class="n">fis2</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">();</span>
        <span class="n">fis2</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="c1">// 移除文本标记</span>
        <span class="nc">String</span> <span class="n">s2</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">publicKeyBytes</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----BEGIN PUBLIC KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"-----END PUBLIC KEY-----"</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>
                <span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"\\s+"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        <span class="n">publicKeyBytes</span> <span class="o">=</span><span class="nc">Base64</span><span class="o">.</span><span class="na">getDecoder</span><span class="o">().</span><span class="na">decode</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
        <span class="nc">X509EncodedKeySpec</span> <span class="n">pkSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">X509EncodedKeySpec</span><span class="o">(</span><span class="n">publicKeyBytes</span><span class="o">);</span>
        <span class="nc">PublicKey</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="na">generatePublic</span><span class="o">(</span><span class="n">pkSpec</span><span class="o">);</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">sk</span><span class="o">,</span><span class="n">pk</span><span class="o">};</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>P7格式是一种用于存储加密数据和证书链的格式。P7格式的文件以”—–BEGIN PKCS7—–“开头，以”—–END PKCS7—–“结尾，中间包含加密数据和证书链的信息。</p><p>当第三方接口要求使用P7格式签名时，是要求将加密数据和证书链一起打包成P7格式的数据，用于传输或存储。</p><p><strong>SM2算法</strong>是一种基于椭圆曲线的非对称加密算法，是中国制定的国家密码算法标准之一。SM2算法提供了数字签名、密钥交换、公钥加密等功能，被广泛应用于各种安全领域，如电子认证、数字签名、信息传输加密等。由于SM2算法是非对称加密算法，因此在使用时需要生成一对公钥和私钥，公钥用于加密或验证签名，私钥用于解密或生成签名。</p><h2 id="数字证书">数字证书</h2><p>摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p><p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p><p>上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。</p><p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用<strong>自签名</strong>的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p><p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。用下面的命令创建一个key store，并设定口令123456：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-storepass</span> 123456 <span class="nt">-genkeypair</span> <span class="nt">-keyalg</span> RSA <span class="nt">-keysize</span> 1024 <span class="nt">-sigalg</span> SHA1withRSA <span class="nt">-validity</span> 3650 <span class="nt">-alias</span> mycert <span class="nt">-keystore</span> my.keystore <span class="nt">-dname</span> <span class="s2">"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</span>
</code></pre></div></div><p>几个主要的参数是：</p><ul><li>keyalg：指定RSA加密算法；</li><li>sigalg：指定SHA1withRSA签名算法；</li><li>validity：指定证书有效期3650天；</li><li>alias：指定证书在程序中引用的名称；</li><li>dname：最重要的<code class="language-plaintext highlighter-rouge">CN=www.sample.com</code>指定了<code class="language-plaintext highlighter-rouge">Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li></ul><p>执行上述命令，JDK会在当前目录创建一个<code class="language-plaintext highlighter-rouge">my.keystore</code>文件，并存<strong>储创建成功的一个私钥和一个证书</strong>，它的别名是<code class="language-plaintext highlighter-rouge">mycert</code>。可以使用以下命令列出密钥库的内容：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-list</span> <span class="nt">-v</span> <span class="nt">-keystore</span> my.keystore <span class="nt">-storepass</span> 123456
</code></pre></div></div><p>请注意，虽然这个密钥库包含私钥，但这只是一个自签名证书，不会被浏览器等受信任的 CA 所信任，因此在实际生产环境中，您需要从受信任的 CA 获取证书以及相应的私钥，而不是使用自签名证书。</p><p>使用 Java KeyStore (JKS) 工具生成密钥库（keystore），默认情况下，生成的密钥库将包含证书以及相应的私钥。这是因为在实际使用中，密钥库通常用于存储证书和私钥对，以便安全地管理和使用它们。</p><p>还可以使用 <code class="language-plaintext highlighter-rouge">-storetype pkcs12</code> 选项来生成 PKCS12 格式的密钥库：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keytool <span class="nt">-storepass</span> 123456 <span class="nt">-genkeypair</span> <span class="nt">-keyalg</span> RSA <span class="nt">-keysize</span> 1024 <span class="nt">-sigalg</span> SHA1withRSA <span class="nt">-validity</span> 3650 <span class="nt">-alias</span> mycert <span class="nt">-keystore</span> my.p12 <span class="nt">-storetype</span> PKCS12 <span class="nt">-dname</span> <span class="s2">"CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</span>
</code></pre></div></div><p>这个命令使用 <code class="language-plaintext highlighter-rouge">keytool</code> 工具生成了一个包含 RSA 密钥对的 PKCS12 格式的密钥库文件 <code class="language-plaintext highlighter-rouge">my.p12</code>。具体参数的含义如下：</p><ul><li><code class="language-plaintext highlighter-rouge">-storepass 123456</code>: 设置密钥库的密码为 <code class="language-plaintext highlighter-rouge">123456</code>。</li><li><code class="language-plaintext highlighter-rouge">-genkeypair</code>: 生成密钥对。</li><li><code class="language-plaintext highlighter-rouge">-keyalg RSA</code>: 使用 RSA 算法生成密钥对。</li><li><code class="language-plaintext highlighter-rouge">-keysize 1024</code>: 设置密钥大小为 1024 位。</li><li><code class="language-plaintext highlighter-rouge">-sigalg SHA1withRSA</code>: 使用 SHA1withRSA 签名算法。</li><li><code class="language-plaintext highlighter-rouge">-validity 3650</code>: 设置证书的有效期为 3650 天。</li><li><code class="language-plaintext highlighter-rouge">-alias mycert</code>: 设置别名为 <code class="language-plaintext highlighter-rouge">mycert</code>。</li><li><code class="language-plaintext highlighter-rouge">-keystore my.p12</code>: 指定生成的密钥库文件名为 <code class="language-plaintext highlighter-rouge">my.p12</code>。</li><li><code class="language-plaintext highlighter-rouge">-storetype PKCS12</code>: 指定密钥库类型为 PKCS12。</li><li><code class="language-plaintext highlighter-rouge">-dname "CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN"</code>: 设置证书主题信息，包括通用名称 (CN)、组织单位 (OU)、组织 (O)、城市 (L)、州/省 (ST) 和国家代码 (C)。</li></ul><p>这条命令的作用是生成一个包含指定 RSA 密钥对和证书信息的 PKCS12 格式的密钥库文件 <code class="language-plaintext highlighter-rouge">my.p12</code>。</p><p>有了key store存储的证书，就可以通过数字证书进行加解密和签名：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.crypto.Cipher</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStream</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.nio.charset.StandardCharsets</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.GeneralSecurityException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.KeyStore</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.PrivateKey</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.Signature</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.cert.X509Certificate</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>  <span class="o">{</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, use X.509 cert!"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span>
        <span class="c1">// 读取KeyStore:</span>
        <span class="nc">KeyStore</span> <span class="n">ks</span> <span class="o">=</span> <span class="n">loadKeyStore</span><span class="o">(</span><span class="s">"my.p12"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">);</span>
        <span class="c1">// 读取私钥:,用alias指定的名字</span>
        <span class="nc">PrivateKey</span> <span class="n">privateKey</span> <span class="o">=</span> <span class="o">(</span><span class="nc">PrivateKey</span><span class="o">)</span> <span class="n">ks</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="s">"mycert"</span><span class="o">,</span> <span class="s">"123456"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
        <span class="c1">// 读取证书:</span>
        <span class="nc">X509Certificate</span> <span class="n">certificate</span> <span class="o">=</span> <span class="o">(</span><span class="nc">X509Certificate</span><span class="o">)</span> <span class="n">ks</span><span class="o">.</span><span class="na">getCertificate</span><span class="o">(</span><span class="s">"mycert"</span><span class="o">);</span>
        <span class="c1">// 公钥加密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">encrypted</span> <span class="o">=</span> <span class="n">encrypt</span><span class="o">(</span><span class="n">certificate</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">encrypted</span><span class="o">);</span>
        <span class="c1">// 私钥解密:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="o">(</span><span class="n">privateKey</span><span class="o">,</span> <span class="n">encrypted</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"decrypted: "</span> <span class="o">+</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">decrypted</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="c1">// 用私钥签名:</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="o">(</span><span class="n">privateKey</span><span class="o">,</span> <span class="n">certificate</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
        <span class="n">out</span><span class="o">(</span><span class="n">sign</span><span class="o">);</span>
        <span class="c1">// 用公钥验证签名:</span>
        <span class="kt">boolean</span> <span class="n">verified</span> <span class="o">=</span> <span class="n">verify</span><span class="o">(</span><span class="n">certificate</span><span class="o">,</span> <span class="n">message</span><span class="o">,</span> <span class="n">sign</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"verify: "</span> <span class="o">+</span> <span class="n">verified</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">KeyStore</span> <span class="nf">loadKeyStore</span><span class="o">(</span><span class="nc">String</span> <span class="n">keyStoreFile</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="n">keyStoreFile</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">input</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"file not found in classpath: "</span> <span class="o">+</span> <span class="n">keyStoreFile</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="nc">KeyStore</span> <span class="n">ks</span> <span class="o">=</span> <span class="nc">KeyStore</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="nc">KeyStore</span><span class="o">.</span><span class="na">getDefaultType</span><span class="o">());</span>
            <span class="n">ks</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">());</span>
            <span class="k">return</span> <span class="n">ks</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">encrypt</span><span class="o">(</span><span class="nc">X509Certificate</span> <span class="n">certificate</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">certificate</span><span class="o">.</span><span class="na">getPublicKey</span><span class="o">().</span><span class="na">getAlgorithm</span><span class="o">());</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">ENCRYPT_MODE</span><span class="o">,</span> <span class="n">certificate</span><span class="o">.</span><span class="na">getPublicKey</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">decrypt</span><span class="o">(</span><span class="nc">PrivateKey</span> <span class="n">privateKey</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Cipher</span> <span class="n">cipher</span> <span class="o">=</span> <span class="nc">Cipher</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">privateKey</span><span class="o">.</span><span class="na">getAlgorithm</span><span class="o">());</span>
        <span class="n">cipher</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="nc">Cipher</span><span class="o">.</span><span class="na">DECRYPT_MODE</span><span class="o">,</span> <span class="n">privateKey</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">cipher</span><span class="o">.</span><span class="na">doFinal</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">sign</span><span class="o">(</span><span class="nc">PrivateKey</span> <span class="n">privateKey</span><span class="o">,</span> <span class="nc">X509Certificate</span> <span class="n">certificate</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Signature</span> <span class="n">signature</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">certificate</span><span class="o">.</span><span class="na">getSigAlgName</span><span class="o">());</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">initSign</span><span class="o">(</span><span class="n">privateKey</span><span class="o">);</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">signature</span><span class="o">.</span><span class="na">sign</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">verify</span><span class="o">(</span><span class="nc">X509Certificate</span> <span class="n">certificate</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">message</span><span class="o">,</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">sig</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">GeneralSecurityException</span> <span class="o">{</span>
        <span class="nc">Signature</span> <span class="n">signature</span> <span class="o">=</span> <span class="nc">Signature</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">certificate</span><span class="o">.</span><span class="na">getSigAlgName</span><span class="o">());</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">initVerify</span><span class="o">(</span><span class="n">certificate</span><span class="o">);</span>
        <span class="n">signature</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">signature</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">sig</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">o</span><span class="o">){</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">byte</span> <span class="n">b</span> <span class="o">:</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%02x"</span><span class="o">,</span><span class="n">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>从key store直接读取了私钥-公钥对，私钥以<code class="language-plaintext highlighter-rouge">PrivateKey</code>实例表示，公钥以<code class="language-plaintext highlighter-rouge">X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p><p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p><ol><li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li><li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li><li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li></ol><p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p><p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href="https://en.wikipedia.org/wiki/DigiNotar">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/" target="_blank">https://acteds.github.io/2024/04/14/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1716100444', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
