<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java集合-常用实现类 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="Java集合-常用实现类"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言java集合常用实现类，ArrayList、HashMap、EnumMap、TreeMap、Properties、Set、Queue、PriorityQueue、Deque、Stack、Iterator。"><meta name="og:description" content="引言java集合常用实现类，ArrayList、HashMap、EnumMap、TreeMap、Properties、Set、Queue、PriorityQueue、Deque、Stack、Iterator。"><meta property="og:url" content="/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-04-07"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java集合-常用实现类"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java集合-常用实现类</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/04/07 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 26887 字，约 77 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>java集合常用实现类，ArrayList、HashMap、EnumMap、TreeMap、Properties、Set、Queue、PriorityQueue、Deque、Stack、Iterator。</p><h1 id="集合">集合</h1><p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span> <span class="c1">// 可以持有10个String对象</span>
<span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span> <span class="c1">// 可以放入String对象</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">ss</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 可以获取String对象</span>
</code></pre></div></div><p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p><ul><li>数组初始化后大小不可变；</li><li>数组只能按索引顺序存取。</li></ul><p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p><ul><li>可变大小的顺序链表；</li><li>保证无重复元素的集合；</li></ul><h1 id="collection">Collection</h1><p>Java标准库自带的<code class="language-plaintext highlighter-rouge">java.util</code>包提供了集合类：<code class="language-plaintext highlighter-rouge">Collection</code>，它是除<code class="language-plaintext highlighter-rouge">Map</code>外所有其他集合类的根接口。Java的<code class="language-plaintext highlighter-rouge">java.util</code>包主要提供了以下三种类型的集合：</p><ul><li><code class="language-plaintext highlighter-rouge">List</code>：一种有序列表的集合，例如，按索引排列的<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">List</code>；</li><li><code class="language-plaintext highlighter-rouge">Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">Set</code>；</li><li><code class="language-plaintext highlighter-rouge">Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">name</code>查找对应<code class="language-plaintext highlighter-rouge">Student</code>的<code class="language-plaintext highlighter-rouge">Map</code>。</li></ul><p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code class="language-plaintext highlighter-rouge">List</code>，具体的实现类有<code class="language-plaintext highlighter-rouge">ArrayList</code>，<code class="language-plaintext highlighter-rouge">LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// 只能放入String类型</span>
</code></pre></div></div><p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p><p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p><ul><li><code class="language-plaintext highlighter-rouge">Hashtable</code>：一种线程安全的<code class="language-plaintext highlighter-rouge">Map</code>实现；</li><li><code class="language-plaintext highlighter-rouge">Vector</code>：一种线程安全的<code class="language-plaintext highlighter-rouge">List</code>实现；</li><li><code class="language-plaintext highlighter-rouge">Stack</code>：基于<code class="language-plaintext highlighter-rouge">Vector</code>实现的<code class="language-plaintext highlighter-rouge">LIFO</code>的栈。</li></ul><p>还有一小部分接口是遗留接口，也不应该继续使用：</p><ul><li><code class="language-plaintext highlighter-rouge">Enumeration&lt;E&gt;</code>：已被<code class="language-plaintext highlighter-rouge">Iterator&lt;E&gt;</code>取代。</li></ul><h1 id="list">List</h1><p><strong><code class="language-plaintext highlighter-rouge">List</code>的子接口</strong>除了<code class="language-plaintext highlighter-rouge">List</code>接口外，还有<code class="language-plaintext highlighter-rouge">Deque</code>（双端队列）和<code class="language-plaintext highlighter-rouge">Queue</code>（队列）等接口，它们分别代表具有不同特性的列表。<code class="language-plaintext highlighter-rouge">Deque</code>支持在两端添加和删除元素，而<code class="language-plaintext highlighter-rouge">Queue</code>通常采用先进先出（FIFO）的方式管理元素。</p><p>在Java 8中，集合框架引入了一些新的特性，如<code class="language-plaintext highlighter-rouge">forEach()</code>方法、<code class="language-plaintext highlighter-rouge">stream</code>流操作、函数式接口等，可以更方便地对集合进行操作和处理。</p><p>在实际应用中，需要增删元素的有序列表，我们使用最多的是<code class="language-plaintext highlighter-rouge">ArrayList</code>。</p><p><code class="language-plaintext highlighter-rouge">ArrayList</code>把添加和删除的操作封装起来，让我们操作<code class="language-plaintext highlighter-rouge">List</code>类似于操作数组，却不用关心内部元素如何移动。</p><p><code class="language-plaintext highlighter-rouge">List&lt;E&gt;</code>接口有几个主要的接口方法：</p><ul><li>在末尾添加一个元素：<code class="language-plaintext highlighter-rouge">boolean add(E e)</code></li><li>在指定索引添加一个元素：<code class="language-plaintext highlighter-rouge">boolean add(int index, E e)</code></li><li>删除指定索引的元素：<code class="language-plaintext highlighter-rouge">E remove(int index)</code></li><li>删除某个元素：<code class="language-plaintext highlighter-rouge">boolean remove(Object e)</code></li><li>获取指定索引的元素：<code class="language-plaintext highlighter-rouge">E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code class="language-plaintext highlighter-rouge">int size()</code></li></ul><p>实现<code class="language-plaintext highlighter-rouge">List</code>接口并非只能通过数组（即<code class="language-plaintext highlighter-rouge">ArrayList</code>的实现方式）来实现，另一种<code class="language-plaintext highlighter-rouge">LinkedList</code>通过“链表”也实现了List接口。在<code class="language-plaintext highlighter-rouge">LinkedList</code>中，它的内部每个元素都指向在<code class="language-plaintext highlighter-rouge">LinkedList</code>中，它的内部每个元素都指向下一个元素：</p><pre><code class="language-ascii">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐
HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │
        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘
</code></pre><p>我们来比较一下<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>：</p><table><thead><tr><th style="text-align: left"> </th><th style="text-align: left">ArrayList</th><th style="text-align: left">LinkedList</th></tr></thead><tbody><tr><td style="text-align: left">获取指定元素</td><td style="text-align: left">速度很快</td><td style="text-align: left">需要从头开始查找元素</td></tr><tr><td style="text-align: left">添加元素到末尾</td><td style="text-align: left">速度很快</td><td style="text-align: left">速度很快</td></tr><tr><td style="text-align: left">在指定位置添加/删除</td><td style="text-align: left">需要移动元素</td><td style="text-align: left">不需要移动元素</td></tr><tr><td style="text-align: left">内存占用</td><td style="text-align: left">少</td><td style="text-align: left">较大</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">ArrayList</code>适合随机访问，而<code class="language-plaintext highlighter-rouge">LinkedList</code>适合插入和删除操作频繁的场景。</p><p>通常情况下，我们总是优先使用<code class="language-plaintext highlighter-rouge">ArrayList</code>。<code class="language-plaintext highlighter-rouge">List</code>接口<strong>允许</strong>添加<strong>重复</strong>的元素，<code class="language-plaintext highlighter-rouge">List</code>还<strong>允许添加</strong><code class="language-plaintext highlighter-rouge">null</code>。</p><p>除了使用<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>，我们还可以通过<code class="language-plaintext highlighter-rouge">List</code>接口提供的<code class="language-plaintext highlighter-rouge">of()</code>方法，根据给定元素快速创建<code class="language-plaintext highlighter-rouge">List</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</code></pre></div></div><p>但是<code class="language-plaintext highlighter-rouge">List.of()</code>方法不接受<code class="language-plaintext highlighter-rouge">null</code>值，如果传入<code class="language-plaintext highlighter-rouge">null</code>，会抛出<code class="language-plaintext highlighter-rouge">NullPointerException</code>异常。</p><h2 id="遍历list">遍历List</h2><p>可以用<code class="language-plaintext highlighter-rouge">for</code>循环根据索引配合<code class="language-plaintext highlighter-rouge">get(int)</code>方法遍历，但这种方式并不推荐，一是代码复杂，二是因为<code class="language-plaintext highlighter-rouge">get(int)</code>方法只有<code class="language-plaintext highlighter-rouge">ArrayList</code>的实现是高效的，换成<code class="language-plaintext highlighter-rouge">LinkedList</code>后，索引越大，访问速度越慢。</p><p>迭代器<code class="language-plaintext highlighter-rouge">Iterator</code>本身也是一个对象，但它是由<code class="language-plaintext highlighter-rouge">List</code>的<strong>实例</strong>调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法的时候创建的。<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何遍历一个<code class="language-plaintext highlighter-rouge">List</code>，并且不同的<code class="language-plaintext highlighter-rouge">List</code>类型，返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象实现也是不同的，但<strong>总是</strong>具有<strong>最高</strong>的访问效率。</p><p><code class="language-plaintext highlighter-rouge">Iterator</code>对象有两个方法：</p><ul><li><code class="language-plaintext highlighter-rouge">boolean hasNext()</code>判断是否有下一个元素</li><li><code class="language-plaintext highlighter-rouge">E next()</code>返回下一个元素。</li></ul><p>使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历<code class="language-plaintext highlighter-rouge">List</code>代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
    <span class="nc">Integer</span> <span class="n">next</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>由于<code class="language-plaintext highlighter-rouge">Iterator</code>遍历是如此常用，所以，Java的<code class="language-plaintext highlighter-rouge">for each</code>循环本身就可以帮我们使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">next</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>只要实现了<code class="language-plaintext highlighter-rouge">Iterable</code>接口的集合类都可以直接用<code class="language-plaintext highlighter-rouge">for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code class="language-plaintext highlighter-rouge">for each</code>循环变成<code class="language-plaintext highlighter-rouge">Iterator</code>的调用，原因就在于<code class="language-plaintext highlighter-rouge">Iterable</code>接口定义了一个<code class="language-plaintext highlighter-rouge">Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>实例。</p><p>在使用迭代器遍历集合时，如果在遍历过程中<strong>修改</strong>了集合的结构（例如添加或删除元素），会导致<code class="language-plaintext highlighter-rouge">ConcurrentModificationException</code>异常。为了避免这种情况，可以使用迭代器的<code class="language-plaintext highlighter-rouge">remove()</code>方法来删除元素，而不是直接调用集合的删除方法。</p><h2 id="list和array转换">List和Array转换</h2><p>把<code class="language-plaintext highlighter-rouge">List</code>变为<code class="language-plaintext highlighter-rouge">Array</code>有三种方法：</p><p><strong>1.</strong>调用<code class="language-plaintext highlighter-rouge">toArray()</code>方法直接返回一个<code class="language-plaintext highlighter-rouge">Object[]</code>数组，这种方法会丢失类型信息，所以实际应用很少。</p><p><strong>2.</strong>给<code class="language-plaintext highlighter-rouge">toArray(T[])</code>传入一个类型相同的<code class="language-plaintext highlighter-rouge">Array</code>，<code class="language-plaintext highlighter-rouge">List</code>内部自动把元素复制到传入的<code class="language-plaintext highlighter-rouge">Array</code>中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">34</span><span class="o">,</span> <span class="mi">56</span><span class="o">);</span>
    <span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="mi">3</span><span class="o">]);</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Integer</span> <span class="n">n</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">toArray(T[])</code>是泛型方法，因此<code class="language-plaintext highlighter-rouge">T</code>是<strong>独立</strong>的，可以传入其他类型的数组，比如<code class="language-plaintext highlighter-rouge">Number</code>类型，如果传入不兼容类型的数组，则会抛出<code class="language-plaintext highlighter-rouge">ArrayStoreException</code>，如果传入的数组长度小了，则会自动创建一个刚好够大的数组，如果多了则对多的部分填<code class="language-plaintext highlighter-rouge">null</code>。</p><p>最常用的是传入一个“恰好”大小的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
</code></pre></div></div><p><strong>3.</strong>更简洁的写法是使用<code class="language-plaintext highlighter-rouge">List</code>接口定义的<code class="language-plaintext highlighter-rouge">T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">);</span>
</code></pre></div></div><p>当使用 <code class="language-plaintext highlighter-rouge">toArray(IntFunction&lt;A[]&gt; generator)</code> 方法时，它会使用传入的 <code class="language-plaintext highlighter-rouge">generator</code> 函数来创建一个新的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，数组的大小通常为列表的大小。<code class="language-plaintext highlighter-rouge">IntFunction&lt;A[]&gt; generator</code> 是一个函数式接口，接受一个整数参数并返回一个泛型数组。可以通过方法引用 <code class="language-plaintext highlighter-rouge">Integer[]::new</code> 来指定生成的数组类型。<a href="#方法引用">详细解释请看这里</a>。</p><p>反过来，把<code class="language-plaintext highlighter-rouge">Array</code>变为<code class="language-plaintext highlighter-rouge">List</code>就简单多了，通过<code class="language-plaintext highlighter-rouge">List.of(T...)</code>方法最简单：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="o">};</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
</code></pre></div></div><p>对于JDK 11之前的版本，可以使用<code class="language-plaintext highlighter-rouge">Arrays.asList(T...)</code>方法把数组转换成<code class="language-plaintext highlighter-rouge">List</code>。</p><p>因为返回的<code class="language-plaintext highlighter-rouge">List</code>不一定就是<code class="language-plaintext highlighter-rouge">ArrayList</code>或者<code class="language-plaintext highlighter-rouge">LinkedList</code>，因此转换后返回的是一个<strong>只读</strong><code class="language-plaintext highlighter-rouge">List</code>。</p><h2 id="equals方法">equals()方法</h2><p><code class="language-plaintext highlighter-rouge">boolean contains(Object o)</code>方法判断<code class="language-plaintext highlighter-rouge">List</code>是否包含某个指定元素。</p><p><code class="language-plaintext highlighter-rouge">int indexOf(Object o)</code>方法返回某个元素的索引，如果元素不存在，就返回<code class="language-plaintext highlighter-rouge">-1</code>。</p><p>实际上<code class="language-plaintext highlighter-rouge">contains()</code>内部也是调用的<code class="language-plaintext highlighter-rouge">indexOf()</code>,<code class="language-plaintext highlighter-rouge">indexOf()</code>内部<strong>会使用</strong><code class="language-plaintext highlighter-rouge">equals()</code><strong>判断是否相等</strong>而不是使用<code class="language-plaintext highlighter-rouge">==</code>判断。<code class="language-plaintext highlighter-rouge">ArrayList&lt;&gt;</code>的<code class="language-plaintext highlighter-rouge">indexOf()</code>的源码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">indexOf</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="no">E</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>因此如果<strong>要使用</strong><code class="language-plaintext highlighter-rouge">List</code>的<code class="language-plaintext highlighter-rouge">contains()</code>、<code class="language-plaintext highlighter-rouge">indexOf()</code>方法，<strong>必须</strong>正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>方法，否则，放进去的实例的<code class="language-plaintext highlighter-rouge">equals()</code>方法就是继承自<code class="language-plaintext highlighter-rouge">Object</code>的<code class="language-plaintext highlighter-rouge">equals()</code>，也就是<code class="language-plaintext highlighter-rouge">==</code>，因此永远不相等。</p><hr /><p><strong>编写equals</strong></p><p><code class="language-plaintext highlighter-rouge">equals()</code>方法必须满足以下条件：</p><ul><li>自反性（Reflexive）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>来说，<code class="language-plaintext highlighter-rouge">x.equals(x)</code>必须返回<code class="language-plaintext highlighter-rouge">true</code>；</li><li>对称性（Symmetric）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>来说，如果<code class="language-plaintext highlighter-rouge">x.equals(y)</code>为<code class="language-plaintext highlighter-rouge">true</code>，则<code class="language-plaintext highlighter-rouge">y.equals(x)</code>也必须为<code class="language-plaintext highlighter-rouge">true</code>；</li><li>传递性（Transitive）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>和<code class="language-plaintext highlighter-rouge">z</code>来说，如果<code class="language-plaintext highlighter-rouge">x.equals(y)</code>为<code class="language-plaintext highlighter-rouge">true</code>，<code class="language-plaintext highlighter-rouge">y.equals(z)</code>也为<code class="language-plaintext highlighter-rouge">true</code>，那么<code class="language-plaintext highlighter-rouge">x.equals(z)</code>也必须为<code class="language-plaintext highlighter-rouge">true</code>；</li><li>一致性（Consistent）：对于非<code class="language-plaintext highlighter-rouge">null</code>的<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>来说，只要<code class="language-plaintext highlighter-rouge">x</code>和<code class="language-plaintext highlighter-rouge">y</code>状态不变，则<code class="language-plaintext highlighter-rouge">x.equals(y)</code>总是一致地返回<code class="language-plaintext highlighter-rouge">true</code>或者<code class="language-plaintext highlighter-rouge">false</code>；</li><li>对<code class="language-plaintext highlighter-rouge">null</code>的比较：即<code class="language-plaintext highlighter-rouge">x.equals(null)</code>永远返回<code class="language-plaintext highlighter-rouge">false</code>。</li></ul><p>以<code class="language-plaintext highlighter-rouge">Person</code>类为例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>首先，定义“相等”的逻辑含义。对于<code class="language-plaintext highlighter-rouge">Person</code>类，如果<code class="language-plaintext highlighter-rouge">name</code>相等，并且<code class="language-plaintext highlighter-rouge">age</code>相等，我们就认为两个<code class="language-plaintext highlighter-rouge">Person</code>实例相等。对于<strong>引用字段</strong>比较，使用<code class="language-plaintext highlighter-rouge">equals()</code>，对于<strong>基本类型字段</strong>的比较，使用<code class="language-plaintext highlighter-rouge">==</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">boolean</span> <span class="n">nameEquals</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="c1">//如果都是null则相等</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nameEquals</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">//如果this.name不是null则调用它的equals</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">nameEquals</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">nameEquals</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>如果<code class="language-plaintext highlighter-rouge">Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code class="language-plaintext highlighter-rouge">Objects.equals()</code>静态方法，注意不是<code class="language-plaintext highlighter-rouge">Object</code>而是<code class="language-plaintext highlighter-rouge">Objects</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Person</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Objects.equals()</code>静态方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">||</span> <span class="n">a</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</code></pre></div></div><p>是同一个对象或都是<code class="language-plaintext highlighter-rouge">null</code>，<code class="language-plaintext highlighter-rouge">a</code>不是<code class="language-plaintext highlighter-rouge">null</code>则调用<code class="language-plaintext highlighter-rouge">a</code>的<code class="language-plaintext highlighter-rouge">equals</code></p><p>要求是同一个类的写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Person</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="na">age</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="map">Map</h1><p>通过一个键去查询对应的值。使用<code class="language-plaintext highlighter-rouge">List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code class="language-plaintext highlighter-rouge">Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code class="language-plaintext highlighter-rouge">key</code>快速查找<code class="language-plaintext highlighter-rouge">value</code>（元素）。</p><p><code class="language-plaintext highlighter-rouge">Map</code>也是一个接口，最常用的实现类是<code class="language-plaintext highlighter-rouge">HashMap</code>。除了<code class="language-plaintext highlighter-rouge">HashMap</code>外，还有<code class="language-plaintext highlighter-rouge">TreeMap</code>（基于红黑树实现）和<code class="language-plaintext highlighter-rouge">LinkedHashMap</code>（保持插入顺序或访问顺序）等<code class="language-plaintext highlighter-rouge">Map</code>的实现类，它们可以根据具体的需求选择合适的实现类。</p><p><code class="language-plaintext highlighter-rouge">HashMap</code>之所以能根据<code class="language-plaintext highlighter-rouge">key</code>直接拿到<code class="language-plaintext highlighter-rouge">value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code class="language-plaintext highlighter-rouge">value</code>，并根据key直接计算出<code class="language-plaintext highlighter-rouge">value</code>应该存储在哪个索引。</p><p><code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">key</code>不能重复，<code class="language-plaintext highlighter-rouge">value</code>可以重复。<code class="language-plaintext highlighter-rouge">Map</code><strong>不保证顺序</strong>。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>V put(K key, V value)</td><td>把<code class="language-plaintext highlighter-rouge">key</code>和<code class="language-plaintext highlighter-rouge">value</code>做了映射并放入<code class="language-plaintext highlighter-rouge">Map</code>。如果放入的<code class="language-plaintext highlighter-rouge">key</code><strong>已经存在</strong>，则会更新<code class="language-plaintext highlighter-rouge">value</code>并返回被删除的旧的<code class="language-plaintext highlighter-rouge">value</code>，否则，返回<code class="language-plaintext highlighter-rouge">null</code>。</td></tr><tr><td>V get(K key)</td><td>通过<code class="language-plaintext highlighter-rouge">key</code>获取到对应的<code class="language-plaintext highlighter-rouge">value</code>。如果<code class="language-plaintext highlighter-rouge">key</code>不存在，则返回<code class="language-plaintext highlighter-rouge">null</code>。</td></tr><tr><td>boolean containsKey(K key)</td><td>查询某个<code class="language-plaintext highlighter-rouge">key</code>是否存在。</td></tr><tr><td>boolean containsValue(V value)</td><td>查询某个<code class="language-plaintext highlighter-rouge">value</code>是否存在。</td></tr><tr><td>keySet()</td><td>返回<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">Set</code>集合。</td></tr><tr><td>entrySet()</td><td>返回此地图中包含的映射的<code class="language-plaintext highlighter-rouge">Set</code>视图。</td></tr></tbody></table><p><strong>遍历</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k1"</span><span class="o">,</span><span class="s">"v1"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k2"</span><span class="o">,</span><span class="s">"v2"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"k3"</span><span class="o">,</span><span class="s">"v3"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">stringStringEntry</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">stringStringEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">stringStringEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value = "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">k</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"value = "</span><span class="o">+</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">k</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p>使用<code class="language-plaintext highlighter-rouge">key</code>存取<code class="language-plaintext highlighter-rouge">value</code>的时候，就会引出一个问题：</p><p>获取<code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">value</code>时，传入的<code class="language-plaintext highlighter-rouge">key</code>不一定就是放入的那个<code class="language-plaintext highlighter-rouge">key</code>对象。而<code class="language-plaintext highlighter-rouge">Map</code>依然能够正常读取。换句话讲，取<code class="language-plaintext highlighter-rouge">value</code>时，两个<code class="language-plaintext highlighter-rouge">key</code>应该内容相同，但不一定是同一个对象。</p><p>因为在<code class="language-plaintext highlighter-rouge">Map</code>的内部，对<code class="language-plaintext highlighter-rouge">key</code>做比较是通过<code class="language-plaintext highlighter-rouge">equals()</code>实现的，这一点和<code class="language-plaintext highlighter-rouge">List</code>查找元素需要正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>是一样的，即正确使用<code class="language-plaintext highlighter-rouge">Map</code><strong>必须保证</strong>：作为<code class="language-plaintext highlighter-rouge">key</code>的对象必须<strong>正确覆写</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法。</p><p>通过<code class="language-plaintext highlighter-rouge">key</code>计算索引的方式就是调用<code class="language-plaintext highlighter-rouge">key</code>对象的<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，它返回一个<code class="language-plaintext highlighter-rouge">int</code>整数。<code class="language-plaintext highlighter-rouge">HashMap</code>正是通过这个方法直接定位<code class="language-plaintext highlighter-rouge">key</code>对应的<code class="language-plaintext highlighter-rouge">value</code>的索引，继而直接返回<code class="language-plaintext highlighter-rouge">value</code>。</p><p><code class="language-plaintext highlighter-rouge">hashCode()</code>方法要严格遵循以下规范：</p><ol><li>如果两个对象<strong>相等</strong>，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code><strong>必须</strong>相等；</li><li>如果两个对象<strong>不相等</strong>，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code><strong>尽量</strong>不要相等。</li><li><code class="language-plaintext highlighter-rouge">equals()</code>用到的用于比较的每一个字段，都必须在<code class="language-plaintext highlighter-rouge">hashCode()</code>中用于计算；<code class="language-plaintext highlighter-rouge">equals()</code>中没有使用到的字段，绝不可放在<code class="language-plaintext highlighter-rouge">hashCode()</code>中计算。</li></ol><p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code class="language-plaintext highlighter-rouge">hashCode()</code>，会造成<code class="language-plaintext highlighter-rouge">Map</code>内部存储冲突，即<strong>哈希冲突</strong>，使存取的效率下降。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">firstName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">firstName</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">(</span><span class="n">lastName</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">lastName</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">:</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="n">age</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>也可以直接使用<code class="language-plaintext highlighter-rouge">Objects.hash()</code></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">firstName</span><span class="o">,</span><span class="n">lastName</span><span class="o">,</span><span class="n">age</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>对于放入<code class="language-plaintext highlighter-rouge">HashMap</code>的<code class="language-plaintext highlighter-rouge">value</code>对象，没有任何要求。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="s">"123"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">));</span>
</code></pre></div></div><p>在<code class="language-plaintext highlighter-rouge"> HashMap</code> 中使用 <code class="language-plaintext highlighter-rouge">null</code> 作为键是可以编译通过的，因为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的实现允许键为 <code class="language-plaintext highlighter-rouge">null</code>。在这种情况下，<code class="language-plaintext highlighter-rouge">null</code> 的哈希码会被计算为 0，并存储在哈希表的第一个位置。因此，当你调用 <code class="language-plaintext highlighter-rouge">map.get(null)</code> 时，会返回键为 <code class="language-plaintext highlighter-rouge">null</code> 对应的值 “123”。但需要注意的是，在使用 <code class="language-plaintext highlighter-rouge">null </code>作为键时要格外小心，因为它可能会导致混淆和错误。</p><h2 id="哈希冲突">哈希冲突</h2><p>如果不同的两个<code class="language-plaintext highlighter-rouge">key</code>，例如<code class="language-plaintext highlighter-rouge">"a"</code>和<code class="language-plaintext highlighter-rouge">"b"</code>，它们的<code class="language-plaintext highlighter-rouge">hashCode()</code>恰好是相同的，就会造成<strong>哈希冲突</strong>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Ming"</span><span class="o">));</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Xiao Hong"</span><span class="o">));</span>
</code></pre></div></div><p>假设<code class="language-plaintext highlighter-rouge">"a"</code>和<code class="language-plaintext highlighter-rouge">"b"</code>这两个<code class="language-plaintext highlighter-rouge">key</code>最终计算出的索引都是5，造成哈希冲突，那么在<code class="language-plaintext highlighter-rouge">HashMap</code>的数组中，实际存储的不是一个<code class="language-plaintext highlighter-rouge">Person</code>实例，而是一个<code class="language-plaintext highlighter-rouge">List</code>，它包含两个<code class="language-plaintext highlighter-rouge">Entry</code>，一个是<code class="language-plaintext highlighter-rouge">"a"</code>的映射，一个是<code class="language-plaintext highlighter-rouge">"b"</code>的映射：</p><pre><code class="language-ascii">  ┌───┐
0 │   │
  ├───┤
1 │   │
  ├───┤
2 │   │
  ├───┤
3 │   │
  ├───┤
4 │   │
  ├───┤
5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;
  ├───┤
6 │   │
  ├───┤
7 │   │
  └───┘
</code></pre><p>在查找的时候，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
</code></pre></div></div><p>HashMap内部通过<code class="language-plaintext highlighter-rouge">"a"</code>找到的实际上是<code class="language-plaintext highlighter-rouge">List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个<code class="language-plaintext highlighter-rouge">List</code>，并找到一个<code class="language-plaintext highlighter-rouge">Entry</code>，它的<code class="language-plaintext highlighter-rouge">key</code>字段是<code class="language-plaintext highlighter-rouge">"a"</code>，才能返回对应的<code class="language-plaintext highlighter-rouge">Person</code>实例。</p><p>我们把不同的<code class="language-plaintext highlighter-rouge">key</code>具有相同的<code class="language-plaintext highlighter-rouge">hashCode()</code>的情况称之为<strong>哈希冲突</strong>。在冲突的时候，一种最简单的解决办法是用<code class="language-plaintext highlighter-rouge">List</code>存储<code class="language-plaintext highlighter-rouge">hashCode()</code>相同的<code class="language-plaintext highlighter-rouge">key-value</code>。显然，如果冲突的概率越大，这个<code class="language-plaintext highlighter-rouge">List</code>就越长，<code class="language-plaintext highlighter-rouge">Map</code>的<code class="language-plaintext highlighter-rouge">get()</code>方法效率就越低，这就是为什么要尽量满足条件二：如果两个对象不相等，则两个对象的<code class="language-plaintext highlighter-rouge">hashCode()</code>尽量不要相等。</p><p>HashMap中依据<code class="language-plaintext highlighter-rouge">key</code>的hash值来确定<code class="language-plaintext highlighter-rouge">value</code>存储位置，所以<strong>一定</strong>要重写<code class="language-plaintext highlighter-rouge">hashCode</code>方法，而重写<code class="language-plaintext highlighter-rouge">equals</code>方法，是为了解决<code class="language-plaintext highlighter-rouge">hash</code><strong>冲突</strong>，如果两个<code class="language-plaintext highlighter-rouge">key</code>的<code class="language-plaintext highlighter-rouge">hash</code>值相同，就会调用<code class="language-plaintext highlighter-rouge">equals</code>方法，比较<code class="language-plaintext highlighter-rouge">key</code>值是否相同。</p><p>在存储时：如果<code class="language-plaintext highlighter-rouge">hash</code>值相同，且<code class="language-plaintext highlighter-rouge">equals</code>结果相同就覆盖更新<code class="language-plaintext highlighter-rouge">value</code>值，如果<code class="language-plaintext highlighter-rouge">equals</code>结果不同，即不是同一个<code class="language-plaintext highlighter-rouge">key</code>，<code class="language-plaintext highlighter-rouge">HashMap</code>会将这两个<code class="language-plaintext highlighter-rouge">key-value</code>对以链表或红黑树的形式存储在同一个位置上。</p><p>在取值时：如果计算的<code class="language-plaintext highlighter-rouge">hash</code>值所指的索引位置有多个值，则根据<code class="language-plaintext highlighter-rouge">equals</code>方法找到对应的<code class="language-plaintext highlighter-rouge">key-value</code>对。如果<code class="language-plaintext highlighter-rouge">equals</code>结果相同就返回当前<code class="language-plaintext highlighter-rouge">value</code>值，如果不同就遍历<code class="language-plaintext highlighter-rouge">List</code>中下一个元素。即要<code class="language-plaintext highlighter-rouge">key</code>与<code class="language-plaintext highlighter-rouge">hash</code>同时匹配才会认为是同一个<code class="language-plaintext highlighter-rouge">key</code>。</p><p>JDK中源码:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">)))){</span><span class="n">ops</span><span class="o">;}</span>
</code></pre></div></div><h2 id="扩容">扩容</h2><p><code class="language-plaintext highlighter-rouge">HashMap</code>初始化时<strong>默认</strong>的<strong>数组大小</strong>为16，任何<code class="language-plaintext highlighter-rouge">key</code>，无论它的<code class="language-plaintext highlighter-rouge">hashCode()</code>有多大，都可以简单地通过：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">()</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="o">;</span> <span class="c1">// 0xf = 15</span>
</code></pre></div></div><p>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p><p>这里的<strong>数组大小指哈希桶的数量</strong>，<strong>不等于</strong>键值对的数量，而是指的是可以容纳的哈希桶的数量。每个哈希桶可以存储<strong>多个键值对</strong>（链表，红黑树），因此即使存储了大量的键值对，如果它们的<strong>哈希值冲突</strong>导致它们应该存储在同一个哈希桶中，实际上只会占用一个哈希桶的空间。<code class="language-plaintext highlighter-rouge">HashMap</code>会根据键值对的数量动态调整数组的大小，以保持较低的<strong>填充因子</strong>，从而保证较好的性能。</p><p><code class="language-plaintext highlighter-rouge">HashMap</code>的<strong>填充因子</strong>超过一定阈值时，<code class="language-plaintext highlighter-rouge">HashMap</code>会在内部自动扩容，每次<strong>扩容一倍</strong>。</p><p>阈值根据<strong>负载因子</strong>确定,默认为<strong>0.75f</strong>。</p><p>如果初始容量为 1024，那么当 <code class="language-plaintext highlighter-rouge">HashMap</code> 的 size 超过 1024 * 负载因子（默认是 0.75f）= 768 时，就会触发扩容操作，此时新的数组大小将是原来的两倍，即 2048。</p><p>扩容操作包括以下步骤：</p><ol><li>创建一个新的数组，大小是原数组的两倍。</li><li>将原数组中的元素<strong>重新计算哈希值</strong>，并根据新数组的大小<strong>重新分配位置</strong>。</li><li>将重新计算位置后的元素放入新数组中。</li><li>将新数组设置为 <code class="language-plaintext highlighter-rouge">HashMap</code> 的数组，替换原数组。</li></ol><p><code class="language-plaintext highlighter-rouge">HashMap</code> 的扩容操作是一个比较<strong>耗时</strong>的操作，因为需要重新计算哈希值并重新分配位置。因此，尽量在初始化时指定 <code class="language-plaintext highlighter-rouge">HashMap</code> 的<strong>初始容量</strong>和<strong>负载因子</strong>，避免频繁扩容，提高性能。</p><p>在 <strong>HashMap</strong> 中，每个数组元素（哈希桶）可以存储一个链表或红黑树头节点。当<strong>链表</strong>的元素数量<strong>超过</strong>一定阈值（<strong>默认为 8</strong>）时，链表会转换为红黑树，以提高查找效率。当<strong>红黑树</strong>中的节点数量<strong>少于</strong>一个阈值（<strong>默认为6</strong>）时，红黑树会转换回链表结构。这种转换是为了避免在红黑树中维护的额外开销，因为当节点数量较少时，链表可能比红黑树更有效率。</p><p>红黑树在<code class="language-plaintext highlighter-rouge">HashMap</code>中是从<strong>JDK 8</strong>开始引入的。<strong>在JDK 8之前</strong>，<code class="language-plaintext highlighter-rouge">HashMap</code>使用的是<strong>数组+链表</strong>的方式来处理哈希冲突。</p><p>通常<strong>建议将容量设置为 2 的幂次方</strong>，如果设置的容量不是 2 的幂次方，<code class="language-plaintext highlighter-rouge">HashMap</code> 会自动向上取最接近的 2 的幂次方作为实际的容量。负载因子应该是一个大于0且小于1的浮点数，注意加f。</p><p>只能在初始化时设置容量和扩容因子</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;(</span><span class="mi">16</span><span class="o">,</span> <span class="mf">0.75f</span><span class="o">);</span>
</code></pre></div></div><h2 id="线程安全问题">线程安全问题</h2><p><code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">HashMap</code>等集合类是非线程安全的，这意味着如果多个线程同时访问这些集合并且至少一个线程修改了集合，就可能导致不确定的结果，比如数据丢失、数据不一致等问题。为了在多线程环境中安全地使用集合，可以使用<code class="language-plaintext highlighter-rouge">Collections</code>工具类提供的<code class="language-plaintext highlighter-rouge">SynchronizedList</code>和<code class="language-plaintext highlighter-rouge">SynchronizedMap</code>方法来获取线程安全的集合：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">synchronizedList</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">synchronizedMap</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;());</span>
</code></pre></div></div><p>这样就可以确保在多线程环境中对集合的操作是安全的。需要注意的是，虽然这些方法提供了线程安全的集合，但在高并发的情况下仍然需要谨慎处理，以避免出现性能问题。</p><h1 id="enummap">EnumMap</h1><p><code class="language-plaintext highlighter-rouge">HashMap</code>是一种通过对key计算<code class="language-plaintext highlighter-rouge">hashCode()</code>，通过空间换时间的方式，直接定位到<code class="language-plaintext highlighter-rouge">value</code>所在的内部数组的索引，因此，查找效率非常高。</p><p>如果作为<code class="language-plaintext highlighter-rouge">key</code>的对象是<code class="language-plaintext highlighter-rouge">enum</code>类型，还可以使用<code class="language-plaintext highlighter-rouge">EnumMap</code>，它在内部以一个非常紧凑的数组存储<code class="language-plaintext highlighter-rouge">value</code>，并且根据<code class="language-plaintext highlighter-rouge">enum</code>类型的<code class="language-plaintext highlighter-rouge">key</code><strong>直接定位</strong>到内部数组的索引，并<strong>不需要计算</strong><code class="language-plaintext highlighter-rouge">hashCode()</code>，不但效率最高，而且没有额外的空间浪费。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">DayOfWeek</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EnumMap</span><span class="o">&lt;&gt;(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">MONDAY</span><span class="o">,</span> <span class="s">"星期一"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">TUESDAY</span><span class="o">,</span> <span class="s">"星期二"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">WEDNESDAY</span><span class="o">,</span> <span class="s">"星期三"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">THURSDAY</span><span class="o">,</span> <span class="s">"星期四"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">FRIDAY</span><span class="o">,</span> <span class="s">"星期五"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SATURDAY</span><span class="o">,</span> <span class="s">"星期六"</span><span class="o">);</span>
<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">SUNDAY</span><span class="o">,</span> <span class="s">"星期日"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="nc">DayOfWeek</span><span class="o">.</span><span class="na">MONDAY</span><span class="o">));</span>
</code></pre></div></div><p>注意实例化时，需要将枚举的<strong>class</strong>传入构造方法。</p><p>使用<code class="language-plaintext highlighter-rouge">EnumMap</code>的时候，我们总是用<code class="language-plaintext highlighter-rouge">Map</code>接口来引用它，因此，实际上把<code class="language-plaintext highlighter-rouge">HashMap</code>和<code class="language-plaintext highlighter-rouge">EnumMap</code>互换，在客户端看来没有任何区别。<code class="language-plaintext highlighter-rouge">EnumMap</code>内部就存一个数组，数组大小需要根据<code class="language-plaintext highlighter-rouge">Enum</code>类型的<code class="language-plaintext highlighter-rouge">values.length</code>确定，每个<code class="language-plaintext highlighter-rouge">Enum</code>的实例都有一个唯一索引<code class="language-plaintext highlighter-rouge">ordinal()</code>。</p><p>由于<code class="language-plaintext highlighter-rouge">Enum</code>的<code class="language-plaintext highlighter-rouge">ordinal</code>方法提供了一个稳定的顺序，<code class="language-plaintext highlighter-rouge">EnumMap</code>可以直接使用数组来存储<code class="language-plaintext highlighter-rouge">value</code>，而<strong>不需要</strong>进行<code class="language-plaintext highlighter-rouge">hash</code>计算或者<code class="language-plaintext highlighter-rouge">equals</code>比较，因此在效率上有很大的优势。</p><p><code class="language-plaintext highlighter-rouge">EnumMap</code>是有序的，它的顺序和<code class="language-plaintext highlighter-rouge">Enum</code>中<code class="language-plaintext highlighter-rouge">enum</code>常量的顺序一致。这一特性在需要按照<code class="language-plaintext highlighter-rouge">Enum</code>定义的顺序进行操作时非常有用。</p><h1 id="treemap">TreeMap</h1><p>还有一种<code class="language-plaintext highlighter-rouge">Map</code>，它在内部会对Key进行排序，这种<code class="language-plaintext highlighter-rouge">Map</code>就是<code class="language-plaintext highlighter-rouge">SortedMap</code>。<code class="language-plaintext highlighter-rouge">SortedMap</code>是接口，它的实现类是<code class="language-plaintext highlighter-rouge">TreeMap</code>。</p><pre><code class="language-ascii">       ┌───┐
       │Map│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashMap│ │SortedMap│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeMap │
          └─────────┘
</code></pre><p><code class="language-plaintext highlighter-rouge">SortedMap</code><strong>保证</strong>遍历时以Key的<strong>顺序</strong>来进行<strong>排序</strong>。例如，放入的Key是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>、<code class="language-plaintext highlighter-rouge">"orange"</code>，遍历的顺序一定是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"orange"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>，因为<code class="language-plaintext highlighter-rouge">String</code>默认按字母排序。</p><p>使用<code class="language-plaintext highlighter-rouge">TreeMap</code>时，放入的Key<strong>必须实现</strong><code class="language-plaintext highlighter-rouge">Comparable</code>接口。<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Integer</code>这些类已经实现了<code class="language-plaintext highlighter-rouge">Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。<code class="language-plaintext highlighter-rouge">TreeMap</code><strong>不使用</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>。</p><p>如果作为Key的class没有实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，那么，<strong>必须</strong>在<strong>创建</strong><code class="language-plaintext highlighter-rouge">TreeMap</code>时同时<strong>指定</strong>一个自定义排序算法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.Comparator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Map</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Person</span> <span class="n">p1</span><span class="o">,</span> <span class="nc">Person</span> <span class="n">p2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">p1</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Tom"</span><span class="o">),</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">),</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Lily"</span><span class="o">),</span> <span class="mi">3</span><span class="o">);</span>
        <span class="c1">//{Person: Bob}{Person: Lily}{Person: Tom}</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Person</span> <span class="n">key</span> <span class="o">:</span> <span class="n">map</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">)));</span> <span class="c1">// 2</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span> <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="nc">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"{Person: "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"}"</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>，如果<code class="language-plaintext highlighter-rouge">a&lt;b</code>，则返回负数，通常是<code class="language-plaintext highlighter-rouge">-1</code>，如果<code class="language-plaintext highlighter-rouge">a==b</code>，则返回<code class="language-plaintext highlighter-rouge">0</code>，如果<code class="language-plaintext highlighter-rouge">a&gt;b</code>，则返回正数，通常是<code class="language-plaintext highlighter-rouge">1</code>。<code class="language-plaintext highlighter-rouge">TreeMap</code>内部根据比较结果对Key进行排序。</p><h1 id="properties">Properties</h1><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 上次最后打开的文件:</span>
<span class="n">last_open_file</span><span class="o">=</span><span class="sr">/data/</span><span class="n">hello</span><span class="p">.</span><span class="nf">txt</span>
<span class="c1"># 自动保存文件的时间间隔:</span>
<span class="n">auto_save_interval</span><span class="o">=</span><span class="mi">60</span>
</code></pre></div></div><p>配置文件的特点是，它的Key-Value一般都是<code class="language-plaintext highlighter-rouge">String</code>-<code class="language-plaintext highlighter-rouge">String</code>类型的，因此我们完全可以用<code class="language-plaintext highlighter-rouge">Map&lt;String, String&gt;</code>来表示它。</p><p>因为配置文件非常常用，所以Java集合库提供了一个<code class="language-plaintext highlighter-rouge">Properties</code>来表示一组“配置”。由于历史遗留原因，<code class="language-plaintext highlighter-rouge">Properties</code>内部本质上是一个<code class="language-plaintext highlighter-rouge">Hashtable</code>，但我们只需要用到<code class="language-plaintext highlighter-rouge">Properties</code>自身关于读写配置的接口。</p><p><strong>读取配置文件</strong></p><p>用<code class="language-plaintext highlighter-rouge">Properties</code>读取配置文件非常简单。Java默认配置文件以<code class="language-plaintext highlighter-rouge">.properties</code>为扩展名，每行以<code class="language-plaintext highlighter-rouge">key=value</code>表示，以<code class="language-plaintext highlighter-rouge">#</code>号开头的是注释。以下是一个典型的配置文件：</p><div class="language-properties highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># setting.properties
</span>
<span class="py">last_open_file</span><span class="p">=</span><span class="s">/data/hello.txt</span>
<span class="py">auto_save_interval</span><span class="p">=</span><span class="s">60</span>
</code></pre></div></div><p>可以从文件系统读取这个<code class="language-plaintext highlighter-rouge">.properties</code>文件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">f</span> <span class="o">=</span> <span class="s">"src/com/aotmd/text.properties"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="nc">FileInputStream</span> <span class="n">fileInputStream</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">fileInputStream</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">filepath</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"last_open_file"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">interval</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"auto_save_interval"</span><span class="o">,</span> <span class="s">"120"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interval = "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"filepath = "</span> <span class="o">+</span> <span class="n">filepath</span><span class="o">);</span>
</code></pre></div></div><p>用<code class="language-plaintext highlighter-rouge">Properties</code>读取配置文件，一共有三步：</p><ol><li>创建<code class="language-plaintext highlighter-rouge">Properties</code>实例；</li><li>调用<code class="language-plaintext highlighter-rouge">load()</code>读取文件；</li><li>调用<code class="language-plaintext highlighter-rouge">getProperty()</code>获取配置。</li></ol><table><thead><tr><th>返回值类型</th><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>String</td><td>getProperty(String key)</td><td>根据指定的键在此属性列表中搜索属性，如果<code class="language-plaintext highlighter-rouge">key</code>不存在，将返回<code class="language-plaintext highlighter-rouge">null</code>。</td></tr><tr><td>String</td><td>getProperty(String key, String defaultValue)</td><td>获取指定键的属性值，如果该键不存在，则返回<code class="language-plaintext highlighter-rouge">defaultValue</code>。</td></tr><tr><td>Object</td><td>setProperty(String key, String value)</td><td>设置指定键的值。如果键已经存在，则更新其值。</td></tr><tr><td>Set<code class="language-plaintext highlighter-rouge">&lt;String&gt;</code></td><td>stringPropertyNames()</td><td>返回属性列表中的键集，其中该键及其对应的值是字符串。</td></tr><tr><td>Enumeration&lt;?&gt;</td><td>propertyNames()</td><td>返回此属性列表中的键集，其中键及其对应的值不一定是字符串。</td></tr><tr><td>void</td><td>list(PrintStream out)</td><td>将属性列表输出到指定的输出流。</td></tr><tr><td>void</td><td>list(PrintWriter out)</td><td>将属性列表输出到指定的输出流。</td></tr><tr><td>void</td><td>load(InputStream inStream)</td><td>从输入流中读取属性列表（键和元素对）。</td></tr><tr><td>void</td><td>store(OutputStream out, String comments)</td><td>将此属性列表（键和元素对）以适合使用<code class="language-plaintext highlighter-rouge">load(InputStream)</code>方法加载的格式写入<code class="language-plaintext highlighter-rouge">out</code>。<code class="language-plaintext highlighter-rouge">comments</code>写入的注释</td></tr></tbody></table><p>也可以从<code class="language-plaintext highlighter-rouge">classpath</code>读取<code class="language-plaintext highlighter-rouge">.properties</code>文件，因为<code class="language-plaintext highlighter-rouge">load(InputStream)</code>方法接收一个<code class="language-plaintext highlighter-rouge">InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props1</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"./text.properties"</span><span class="o">));</span>
<span class="nc">String</span> <span class="n">filepath1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"last_open_file"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">interval1</span> <span class="o">=</span> <span class="n">props1</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"auto_save_interval"</span><span class="o">,</span> <span class="s">"120"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"interval = "</span> <span class="o">+</span> <span class="n">interval</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"filepath = "</span> <span class="o">+</span> <span class="n">filepath</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Main.class.getResourceAsStream("./text.properties")</code>用于获取位于与<code class="language-plaintext highlighter-rouge">Main.class</code>相同目录下的<code class="language-plaintext highlighter-rouge">text.properties</code>文件的输入流。</p><p><code class="language-plaintext highlighter-rouge">getResourceAsStream()</code>是一个用于获取资源的方法，它会返回一个<code class="language-plaintext highlighter-rouge">InputStream</code>对象，可以用于读取资源文件的内容。</p><p><code class="language-plaintext highlighter-rouge">"./text.properties"</code>表示相对于<code class="language-plaintext highlighter-rouge">Main.class</code>所在目录的路径，即在<code class="language-plaintext highlighter-rouge">Main.class</code>所在目录下寻找名为<code class="language-plaintext highlighter-rouge">text.properties</code>的文件。</p><p>如果有多个<code class="language-plaintext highlighter-rouge">.properties</code>文件，可以反复调用<code class="language-plaintext highlighter-rouge">load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getResourceAsStream</span><span class="o">(</span><span class="s">"/common/setting.properties"</span><span class="o">));</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"C:\\conf\\setting.properties"</span><span class="o">));</span>
</code></pre></div></div><p>上面的代码演示了<code class="language-plaintext highlighter-rouge">Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p><p><code class="language-plaintext highlighter-rouge">Properties</code>设计的目的是存储<code class="language-plaintext highlighter-rouge">String</code>类型的key－value，但<code class="language-plaintext highlighter-rouge">Properties</code>实际上是从<code class="language-plaintext highlighter-rouge">Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了<code class="language-plaintext highlighter-rouge">getProperty()</code>和<code class="language-plaintext highlighter-rouge">setProperty()</code>方法外，还有从<code class="language-plaintext highlighter-rouge">Hashtable</code>继承下来的<code class="language-plaintext highlighter-rouge">get()</code>和<code class="language-plaintext highlighter-rouge">put()</code>方法，这些方法的参数签名是<code class="language-plaintext highlighter-rouge">Object</code>，我们在使用<code class="language-plaintext highlighter-rouge">Properties</code>的时候，不要去调用这些从<code class="language-plaintext highlighter-rouge">Hashtable</code>继承下来的方法。</p><p><strong>写入配置文件</strong> 如果通过<code class="language-plaintext highlighter-rouge">setProperty()</code>修改了<code class="language-plaintext highlighter-rouge">Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code class="language-plaintext highlighter-rouge">store()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">f</span> <span class="o">=</span> <span class="s">"src/com/aotmd/text.properties"</span><span class="o">;</span>
<span class="nc">Properties</span> <span class="n">props</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Properties</span><span class="o">();</span>
<span class="n">props</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"language"</span><span class="o">,</span> <span class="s">"你好"</span><span class="o">);</span>
<span class="nc">FileOutputStream</span> <span class="n">fos</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">store</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="n">fos</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">),</span> <span class="s">"这是写入的properties注释"</span><span class="o">);</span>

<span class="nc">FileInputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
<span class="n">props</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">fis</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
<span class="nc">String</span> <span class="n">language</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"language"</span> <span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"language = "</span> <span class="o">+</span> <span class="n">language</span><span class="o">);</span>
</code></pre></div></div><p>早期版本的Java规定<code class="language-plaintext highlighter-rouge">.properties</code>文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code class="language-plaintext highlighter-rouge">name=\u4e2d\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code class="language-plaintext highlighter-rouge">.properties</code>文件可以使用UTF-8编码了。</p><h1 id="set">Set</h1><p><code class="language-plaintext highlighter-rouge">Map</code>用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但<strong>需要</strong>正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>方法，还要<strong>正确覆写</strong><code class="language-plaintext highlighter-rouge">hashCode()</code>方法。</p><p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用<code class="language-plaintext highlighter-rouge">Set</code>。</p><p><code class="language-plaintext highlighter-rouge">Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p><ul><li>将元素添加进<code class="language-plaintext highlighter-rouge">Set&lt;E&gt;</code>：<code class="language-plaintext highlighter-rouge">boolean add(E e)</code></li><li>将元素从<code class="language-plaintext highlighter-rouge">Set&lt;E&gt;</code>删除：<code class="language-plaintext highlighter-rouge">boolean remove(Object e)</code></li><li>判断是否包含元素：<code class="language-plaintext highlighter-rouge">boolean contains(Object e)</code><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"abc"</span><span class="o">));</span> <span class="c1">// true</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// true</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// false，添加失败，因为元素已存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"xyz"</span><span class="o">));</span> <span class="c1">// true，元素存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"XYZ"</span><span class="o">));</span> <span class="c1">// false，元素不存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="s">"hello"</span><span class="o">));</span> <span class="c1">// false，删除失败，因为元素不存在</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span> <span class="c1">// 2，一共两个元素</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Set</code>实际上<strong>相当于</strong>只存储key、不存储value的<code class="language-plaintext highlighter-rouge">Map</code>。经常用<code class="language-plaintext highlighter-rouge">Set</code>去除重复元素。</p></li></ul><p>放入<code class="language-plaintext highlighter-rouge">Set</code>的元素和<code class="language-plaintext highlighter-rouge">Map</code>的key类似，都要<strong>正确实现</strong><code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，否则该元素无法正确地放入<code class="language-plaintext highlighter-rouge">Set</code>。</p><p>最常用的<code class="language-plaintext highlighter-rouge">Set</code>实现类是<code class="language-plaintext highlighter-rouge">HashSet</code>，实际上，<code class="language-plaintext highlighter-rouge">HashSet</code>仅仅是对<code class="language-plaintext highlighter-rouge">HashMap</code>的一个简单封装，它的核心代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 持有一个HashMap:</span>
    <span class="kd">private</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="no">E</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 放入HashMap的value:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="no">PRESENT</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="no">PRESENT</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">o</span><span class="o">);}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span><span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">==</span> <span class="no">PRESENT</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Set</code>接口并不保证有序，而<code class="language-plaintext highlighter-rouge">SortedSet</code>接口则保证元素是有序的：</p><ul><li><code class="language-plaintext highlighter-rouge">HashSet</code>是<strong>无序</strong>的，因为它实现了<code class="language-plaintext highlighter-rouge">Set</code>接口，并没有实现<code class="language-plaintext highlighter-rouge">SortedSet</code>接口；</li><li><code class="language-plaintext highlighter-rouge">TreeSet</code>是<strong>有序</strong>的，因为它实现了<code class="language-plaintext highlighter-rouge">SortedSet</code>接口。</li></ul><p>用一张图表示：</p><pre><code class="language-ascii">       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
</code></pre><p>使用<code class="language-plaintext highlighter-rouge">TreeSet</code>和使用<code class="language-plaintext highlighter-rouge">TreeMap</code>的要求一样，添加的元素必须正确实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，如果没有实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，那么创建<code class="language-plaintext highlighter-rouge">TreeSet</code>时必须传入一个<code class="language-plaintext highlighter-rouge">Comparator</code>对象。</p><p><code class="language-plaintext highlighter-rouge">Set</code>用于存储不重复的元素集合：</p><ul><li>放入<code class="language-plaintext highlighter-rouge">HashSet</code>的元素与作为<code class="language-plaintext highlighter-rouge">HashMap</code>的key要求相同；</li><li>放入<code class="language-plaintext highlighter-rouge">TreeSet</code>的元素与作为<code class="language-plaintext highlighter-rouge">TreeMap</code>的Key要求相同；</li></ul><p>利用<code class="language-plaintext highlighter-rouge">Set</code>可以去除重复元素；</p><p>遍历<code class="language-plaintext highlighter-rouge">SortedSet</code>按照元素的排序顺序遍历，也可以自定义排序算法。</p><h1 id="queue">Queue</h1><p>队列（<code class="language-plaintext highlighter-rouge">Queue</code>）是一种经常使用的集合。<code class="language-plaintext highlighter-rouge">Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code class="language-plaintext highlighter-rouge">List</code>的区别在于，<code class="language-plaintext highlighter-rouge">List</code>可以在任意位置添加和删除元素，而<code class="language-plaintext highlighter-rouge">Queue</code>只有两个操作：</p><ul><li>把元素添加到队列末尾；</li><li>从队列头部取出元素。</li></ul><p>在Java的标准库中，队列接口<code class="language-plaintext highlighter-rouge">Queue</code>定义了以下几个方法：</p><ul><li><code class="language-plaintext highlighter-rouge">int size()</code>：获取队列长度；</li><li><code class="language-plaintext highlighter-rouge">boolean add(E)</code>/<code class="language-plaintext highlighter-rouge">boolean offer(E)</code>：添加元素到队尾；</li><li><code class="language-plaintext highlighter-rouge">E remove()</code>/<code class="language-plaintext highlighter-rouge">E poll()</code>：获取队首元素并从队列中删除；</li><li><code class="language-plaintext highlighter-rouge">E element()</code>/<code class="language-plaintext highlighter-rouge">E peek()</code>：获取队首元素但并不从队列中删除。</li></ul><p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。</p><p>注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素<strong>失败</strong>时，这两个方法的<strong>行为</strong>是<strong>不同</strong>的。</p><table><thead><tr><th style="text-align: left"> </th><th style="text-align: left">throw Exception</th><th style="text-align: left">返回false或null</th></tr></thead><tbody><tr><td style="text-align: left">添加元素到队尾</td><td style="text-align: left">add(E e)</td><td style="text-align: left">boolean offer(E e)，添加失败返回false</td></tr><tr><td style="text-align: left">取队首元素并删除</td><td style="text-align: left">E remove()</td><td style="text-align: left">E poll()，失败返回null</td></tr><tr><td style="text-align: left">取队首元素但不删除</td><td style="text-align: left">E element()</td><td style="text-align: left">E peek()，失败返回null</td></tr></tbody></table><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"remove"</span><span class="o">);</span>
<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"element"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">element</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">remove</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

<span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"poll"</span><span class="o">);</span>
<span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"peek"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">peek</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">queue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</code></pre></div></div><p><strong>不要</strong>把<code class="language-plaintext highlighter-rouge">null</code>添加到队列中，否则<code class="language-plaintext highlighter-rouge">poll()</code>方法返回<code class="language-plaintext highlighter-rouge">null</code>时，很难确定是取到了<code class="language-plaintext highlighter-rouge">null</code>元素还是队列为空。</p><p><code class="language-plaintext highlighter-rouge">LinkedList</code>即实现了<code class="language-plaintext highlighter-rouge">List</code>接口，又实现了<code class="language-plaintext highlighter-rouge">Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这是一个List:</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 这是一个Queue:</span>
<span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><h1 id="priorityqueue">PriorityQueue</h1><p><code class="language-plaintext highlighter-rouge">Queue</code>是一个先进先出（FIFO）的队列。<code class="language-plaintext highlighter-rouge">PriorityQueue</code>和<code class="language-plaintext highlighter-rouge">Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code class="language-plaintext highlighter-rouge">PriorityQueue</code>调用<code class="language-plaintext highlighter-rouge">remove()</code>或<code class="language-plaintext highlighter-rouge">poll()</code>方法，返回的总是优先级最高的元素。</p><p>要使用<code class="language-plaintext highlighter-rouge">PriorityQueue</code>，我们就必须给每个元素定义“优先级”。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
<span class="c1">// 添加3个元素到队列:</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"apple"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"pear"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="s">"banana"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// apple</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// banana</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// pear</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// null,因为队列为空</span>
</code></pre></div></div><p>放入的顺序是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>、<code class="language-plaintext highlighter-rouge">"banana"</code>，但是取出的顺序却是<code class="language-plaintext highlighter-rouge">"apple"</code>、<code class="language-plaintext highlighter-rouge">"banana"</code>、<code class="language-plaintext highlighter-rouge">"pear"</code>，这是因为从字符串的排序看，<code class="language-plaintext highlighter-rouge">"apple"</code>排在最前面，<code class="language-plaintext highlighter-rouge">"pear"</code>排在最后面。</p><p>放入<code class="language-plaintext highlighter-rouge">PriorityQueue</code>的元素，必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口，<code class="language-plaintext highlighter-rouge">PriorityQueue</code>会根据元素的<strong>排序顺序</strong>决定出队的优先级。</p><p><code class="language-plaintext highlighter-rouge">PriorityQueue</code>默认按元素比较的顺序排序（必须实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口），也可以通过<code class="language-plaintext highlighter-rouge">Comparator</code>自定义排序算法（元素就不必实现<code class="language-plaintext highlighter-rouge">Comparable</code>接口）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.PriorityQueue</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Queue</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">u1</span><span class="o">,</span><span class="n">u2</span><span class="o">)-&gt;{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="n">u2</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 如果两人的号都是A开头或者都是V开头,比较号的大小:</span>
                <span class="kt">int</span> <span class="n">no1</span><span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
                <span class="kt">int</span> <span class="n">no2</span><span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">u2</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
                <span class="k">return</span> <span class="n">no1</span><span class="o">-</span><span class="n">no2</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">u1</span><span class="o">.</span><span class="na">number</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'V'</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// u1的号码是V开头,优先级高:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="c1">// 添加3个元素到队列:</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"A1"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">,</span> <span class="s">"A2"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Boss"</span><span class="o">,</span> <span class="s">"V1"</span><span class="o">));</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">User</span><span class="o">(</span><span class="s">"Boss"</span><span class="o">,</span> <span class="s">"V10"</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Boss/V1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Boss/V10</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Bob/A1</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// Alice/A2</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span><span class="n">number</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span><span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">;}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"User{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="s">", number='"</span> <span class="o">+</span> <span class="n">number</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="deque">Deque</h1><p><code class="language-plaintext highlighter-rouge">Queue</code>是队列，只能一头进，另一头出。</p><p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code class="language-plaintext highlighter-rouge">Deque</code>。</p><p>Java集合提供了接口<code class="language-plaintext highlighter-rouge">Deque</code>来实现一个双端队列，它的功能是：</p><ul><li>既可以添加到队尾，也可以添加到队首；</li><li>既可以从队首获取，又可以从队尾获取。</li></ul><p>比较<code class="language-plaintext highlighter-rouge">Queue</code>和<code class="language-plaintext highlighter-rouge">Deque</code>出队和入队的方法：</p><table><thead><tr><th style="text-align: left"> </th><th style="text-align: left">Queue</th><th style="text-align: left">Deque</th></tr></thead><tbody><tr><td style="text-align: left">添加元素到队尾</td><td style="text-align: left">add(E e) / offer(E e)</td><td style="text-align: left">addLast(E e) / offerLast(E e)</td></tr><tr><td style="text-align: left">取队首元素并删除</td><td style="text-align: left">E remove() / E poll()</td><td style="text-align: left">E removeFirst() / E pollFirst()</td></tr><tr><td style="text-align: left">取队首元素但不删除</td><td style="text-align: left">E element() / E peek()</td><td style="text-align: left">E getFirst() / E peekFirst()</td></tr><tr><td style="text-align: left">添加元素到队首</td><td style="text-align: left">无</td><td style="text-align: left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td style="text-align: left">取队尾元素并删除</td><td style="text-align: left">无</td><td style="text-align: left">E removeLast() / E pollLast()</td></tr><tr><td style="text-align: left">取队尾元素但不删除</td><td style="text-align: left">无</td><td style="text-align: left">E getLast() / E peekLast()</td></tr></tbody></table><p>对于添加元素到队尾的操作，<code class="language-plaintext highlighter-rouge">Queue</code>提供了<code class="language-plaintext highlighter-rouge">add()</code>/<code class="language-plaintext highlighter-rouge">offer()</code>方法，而<code class="language-plaintext highlighter-rouge">Deque</code>提供了<code class="language-plaintext highlighter-rouge">addLast()</code>/<code class="language-plaintext highlighter-rouge">offerLast()</code>方法。添加元素到队首、取队尾元素的操作在<code class="language-plaintext highlighter-rouge">Queue</code>中不存在，在<code class="language-plaintext highlighter-rouge">Deque</code>中由<code class="language-plaintext highlighter-rouge">addFirst()</code>/<code class="language-plaintext highlighter-rouge">removeLast()</code>等方法提供。</p><p><code class="language-plaintext highlighter-rouge">Deque</code>接口实际上扩展自<code class="language-plaintext highlighter-rouge">Queue</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div><p>因此，<code class="language-plaintext highlighter-rouge">Queue</code>提供的<code class="language-plaintext highlighter-rouge">add()</code>/<code class="language-plaintext highlighter-rouge">offer()</code>方法在<code class="language-plaintext highlighter-rouge">Deque</code>中也可以使用，但是，使用<code class="language-plaintext highlighter-rouge">Deque</code>，最好不要调用<code class="language-plaintext highlighter-rouge">offer()</code>，而是调用<code class="language-plaintext highlighter-rouge">offerLast()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Deque</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.LinkedList</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">deque</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span> <span class="c1">// A</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"B"</span><span class="o">);</span> <span class="c1">// A &lt;- B</span>
        <span class="n">deque</span><span class="o">.</span><span class="na">offerFirst</span><span class="o">(</span><span class="s">"C"</span><span class="o">);</span> <span class="c1">// C &lt;- A &lt;- B</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// C, 剩下A &lt;- B</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span> <span class="c1">// B, 剩下A</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// A</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">deque</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span> <span class="c1">// null</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果直接写<code class="language-plaintext highlighter-rouge">deque.offer()</code>，我们就需要思考，<code class="language-plaintext highlighter-rouge">offer()</code>实际上是<code class="language-plaintext highlighter-rouge">offerLast()</code>，我们明确地写上<code class="language-plaintext highlighter-rouge">offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p><p>因此，使用<code class="language-plaintext highlighter-rouge">Deque</code>，推荐总是明确调用<code class="language-plaintext highlighter-rouge">offerLast()</code>/<code class="language-plaintext highlighter-rouge">offerFirst()</code>或者<code class="language-plaintext highlighter-rouge">pollFirst()</code>/<code class="language-plaintext highlighter-rouge">pollLast()</code>方法。</p><p><code class="language-plaintext highlighter-rouge">Deque</code>是一个接口，它的实现类有<code class="language-plaintext highlighter-rouge">ArrayDeque</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>。</p><p>我们发现<code class="language-plaintext highlighter-rouge">LinkedList</code>真是一个全能选手，它即是<code class="language-plaintext highlighter-rouge">List</code>，又是<code class="language-plaintext highlighter-rouge">Queue</code>，还是<code class="language-plaintext highlighter-rouge">Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不推荐的写法:</span>
<span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">d1</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span>
<span class="c1">// 推荐的写法：</span>
<span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">d2</span><span class="o">.</span><span class="na">offerLast</span><span class="o">(</span><span class="s">"z"</span><span class="o">);</span>
</code></pre></div></div><p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p><h1 id="stack">Stack</h1><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p><p><code class="language-plaintext highlighter-rouge">Queue</code>的特点FIFO：所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进<code class="language-plaintext highlighter-rouge">Stack</code>的元素一定最早出<code class="language-plaintext highlighter-rouge">Stack</code>的。因此，<code class="language-plaintext highlighter-rouge">Stack</code>是这样一种数据结构：只能不断地往<code class="language-plaintext highlighter-rouge">Stack</code>中压入（push）元素，最后进去的必须最早弹出（pop）来。</p><p>在Java中，我们用<code class="language-plaintext highlighter-rouge">Deque</code>可以实现<code class="language-plaintext highlighter-rouge">Stack</code>的功能：</p><ul><li>把元素压栈：<code class="language-plaintext highlighter-rouge">push(E)</code>/<code class="language-plaintext highlighter-rouge">addFirst(E)</code>；</li><li>把栈顶的元素“弹出”：<code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">removeFirst()</code>；</li><li>取栈顶元素但不弹出：<code class="language-plaintext highlighter-rouge">peek()</code>/<code class="language-plaintext highlighter-rouge">peekFirst()</code>。</li></ul><p>为什么Java的集合类没有单独的<code class="language-plaintext highlighter-rouge">Stack</code>接口呢？因为有个遗留类名字就叫<code class="language-plaintext highlighter-rouge">Stack</code>，出于兼容性考虑，所以没办法创建<code class="language-plaintext highlighter-rouge">Stack</code>接口，只能用<code class="language-plaintext highlighter-rouge">Deque</code>接口来“模拟”一个<code class="language-plaintext highlighter-rouge">Stack</code>了。</p><p>当我们把<code class="language-plaintext highlighter-rouge">Deque</code>作为<code class="language-plaintext highlighter-rouge">Stack</code>使用时，注意只调用<code class="language-plaintext highlighter-rouge">push()</code>/<code class="language-plaintext highlighter-rouge">pop()</code>/<code class="language-plaintext highlighter-rouge">peek()</code>方法，不要调用<code class="language-plaintext highlighter-rouge">addFirst()</code>/<code class="language-plaintext highlighter-rouge">removeFirst()</code>/<code class="language-plaintext highlighter-rouge">peekFirst()</code>方法，这样代码更加清晰。</p><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发<code class="language-plaintext highlighter-rouge">StackOverflowError</code>。</p><p>除基取余倒排列：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="nc">String</span> <span class="nf">toHex</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">s</span> <span class="o">={</span><span class="s">"0"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">,</span><span class="s">"3"</span><span class="o">,</span><span class="s">"4"</span><span class="o">,</span><span class="s">"5"</span><span class="o">,</span><span class="s">"6"</span><span class="o">,</span><span class="s">"7"</span><span class="o">,</span><span class="s">"8"</span><span class="o">,</span><span class="s">"9"</span><span class="o">,</span><span class="s">"A"</span><span class="o">,</span><span class="s">"B"</span><span class="o">,</span><span class="s">"C"</span><span class="o">,</span><span class="s">"D"</span><span class="o">,</span><span class="s">"E"</span><span class="o">,</span><span class="s">"F"</span><span class="o">};</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">n</span><span class="o">!=</span><span class="mi">0</span><span class="o">){</span>
        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="n">n</span><span class="o">%</span><span class="mi">16</span><span class="o">]);</span>
        <span class="n">n</span><span class="o">/=</span><span class="mi">16</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><h1 id="iterator">Iterator</h1><p>Java的集合类都可以使用<code class="language-plaintext highlighter-rouge">for each</code>循环，<code class="language-plaintext highlighter-rouge">List</code>、<code class="language-plaintext highlighter-rouge">Set</code>和<code class="language-plaintext highlighter-rouge">Queue</code>会迭代每个元素，<code class="language-plaintext highlighter-rouge">Map</code>会迭代每个key。以<code class="language-plaintext highlighter-rouge">List</code>为例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Orange"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>实际上，Java编译器并不知道如何遍历<code class="language-plaintext highlighter-rouge">List</code>。上述代码能够编译通过，只是因为编译器把<code class="language-plaintext highlighter-rouge">for each</code>循环通过<code class="language-plaintext highlighter-rouge">Iterator</code>改写为了普通的<code class="language-plaintext highlighter-rouge">for</code>循环：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
     <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>这种通过<code class="language-plaintext highlighter-rouge">Iterator</code>对象遍历集合的模式称为迭代器。</p><p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关心它们内部的存储结构。</p><p>例如，我们虽然知道<code class="language-plaintext highlighter-rouge">ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code class="language-plaintext highlighter-rouge">get(int)</code>方法。虽然我们可以用<code class="language-plaintext highlighter-rouge">for</code>循环遍历：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code class="language-plaintext highlighter-rouge">ArrayList</code>换成<code class="language-plaintext highlighter-rouge">LinkedList</code>，<code class="language-plaintext highlighter-rouge">get(int)</code>方法耗时会随着<code class="language-plaintext highlighter-rouge">index</code>的增加而增加。如果把<code class="language-plaintext highlighter-rouge">ArrayList</code>换成<code class="language-plaintext highlighter-rouge">Set</code>，上述代码就无法编译，因为<code class="language-plaintext highlighter-rouge">Set</code>内部没有索引。</p><p>用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历就没有上述问题，因为<code class="language-plaintext highlighter-rouge">Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的<code class="language-plaintext highlighter-rouge">for each</code>循环自动转换为<code class="language-plaintext highlighter-rouge">Iterator</code>遍历。</p><p>如果我们自己编写了一个集合类，想要使用<code class="language-plaintext highlighter-rouge">for each</code>循环，只需满足以下条件：</p><ul><li>集合类实现<code class="language-plaintext highlighter-rouge">Iterable</code>接口，该接口要求返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象；</li><li>用<code class="language-plaintext highlighter-rouge">Iterator</code>对象迭代集合内部数据。</li></ul><p>这里的关键在于，集合类通过调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法，返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p><p>一个简单的<code class="language-plaintext highlighter-rouge">Iterator</code>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">rlist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReverseList</span><span class="o">&lt;&gt;();</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Pear"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">rlist</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="no">T</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">ReverseList</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">++);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>虽然实现类稍微比较复杂，但这是底层集合库，只需编写一次。而调用方则完全按<code class="language-plaintext highlighter-rouge">for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p><p>在编写<code class="language-plaintext highlighter-rouge">Iterator</code>的时候，通常可以用一个内部类来实现<code class="language-plaintext highlighter-rouge">Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类可以用<code class="language-plaintext highlighter-rouge">ReverseList.this</code>获得当前外部类的<code class="language-plaintext highlighter-rouge">this</code>引用，然后，通过这个<code class="language-plaintext highlighter-rouge">this</code>引用就可以访问<code class="language-plaintext highlighter-rouge">ReverseList</code>的所有字段和方法。</p><p><code class="language-plaintext highlighter-rouge">Iterator</code>是一种抽象的数据访问模型。使用<code class="language-plaintext highlighter-rouge">Iterator</code>模式进行迭代的好处有：</p><ul><li>对任何集合都采用同一种访问模型；</li><li>调用者对集合内部结构一无所知；</li><li>集合类返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何迭代。</li></ul><p>Java提供了标准的迭代器模型，即集合类实现<code class="language-plaintext highlighter-rouge">java.util.Iterable</code>接口，返回<code class="language-plaintext highlighter-rouge">java.util.Iterator</code>实例。</p><h1 id="collections">Collections</h1><p><code class="language-plaintext highlighter-rouge">Collections</code>是JDK提供的工具类，同样位于<code class="language-plaintext highlighter-rouge">java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。 注意<strong>Collections</strong>结尾多了一个s，不是<strong>Collection</strong>！</p><p><code class="language-plaintext highlighter-rouge">addAll()</code>方法可以给一个<code class="language-plaintext highlighter-rouge">Collection</code>类型的集合添加若干元素。因为方法签名是<code class="language-plaintext highlighter-rouge">Collection</code>，所以我们可以传入<code class="language-plaintext highlighter-rouge">List</code>，<code class="language-plaintext highlighter-rouge">Set</code>等各种集合类型。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">addAll</span><span class="o">(</span><span class="nc">Collection</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">,</span> <span class="no">T</span><span class="o">...</span> <span class="n">elements</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code class="language-plaintext highlighter-rouge">List&lt;T&gt; emptyList()</code></td><td>创建空List，返回的空集合是<strong>不可变集合</strong>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; emptyMap()</code></td><td>创建空Map，返回的空集合是<strong>不可变集合</strong>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">Set&lt;T&gt; emptySet()</code></td><td>创建空Set，返回的空集合是<strong>不可变集合</strong>。</td></tr><tr><td><code class="language-plaintext highlighter-rouge">List&lt;T&gt; singletonList(T o)</code></td><td>创建一个元素的List，也是<strong>不可变集合</strong></td></tr><tr><td><code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; singletonMap(K key, V value)</code></td><td>创建一个元素的Map，也是<strong>不可变集合</strong></td></tr><tr><td><code class="language-plaintext highlighter-rouge">Set&lt;T&gt; singleton(T o)</code></td><td>创建一个元素的Set，也是<strong>不可变集合</strong></td></tr><tr><td><code class="language-plaintext highlighter-rouge">sort(list)</code></td><td>对List排序</td></tr><tr><td><code class="language-plaintext highlighter-rouge">shuffle(list)</code></td><td>对List洗牌，打乱顺序</td></tr></tbody></table><p>也可以用各个集合接口提供的<code class="language-plaintext highlighter-rouge">of(T...)</code>方法，它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合。</p><p><strong>不可变集合</strong></p><p><code class="language-plaintext highlighter-rouge">Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p><ul><li>封装成不可变List：<code class="language-plaintext highlighter-rouge">List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变Set：<code class="language-plaintext highlighter-rouge">Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变Map：<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul><p>这种封装实际上是通过<strong>创建</strong>一个<strong>代理对象</strong>，<strong>拦截</strong>掉所有修改方法实现的。然而，继续对原始的可变<code class="language-plaintext highlighter-rouge">List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code class="language-plaintext highlighter-rouge">List</code>。因此，如果我们希望把一个可变<code class="language-plaintext highlighter-rouge">List</code>封装成不可变<code class="language-plaintext highlighter-rouge">List</code>，那么，返回不可变<code class="language-plaintext highlighter-rouge">List</code>后，最好立刻扔掉可变<code class="language-plaintext highlighter-rouge">List</code>的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code class="language-plaintext highlighter-rouge">List</code>变化了。</p><p><strong>线程安全集合</strong></p><p><code class="language-plaintext highlighter-rouge">Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p><ul><li>变为线程安全的List：<code class="language-plaintext highlighter-rouge">List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li><li>变为线程安全的Set：<code class="language-plaintext highlighter-rouge">Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li><li>变为线程安全的Map：<code class="language-plaintext highlighter-rouge">Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li></ul><p>从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p><h1 id="其他">其他</h1><h2 id="方法引用">方法引用</h2><p>展开<code class="language-plaintext highlighter-rouge">Integer[]::new</code>后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Integer</span><span class="o">[]</span> <span class="nf">apply</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div><p>在这里，<code class="language-plaintext highlighter-rouge">IntFunction&lt;Integer[]&gt;</code> 是一个函数式接口，它定义了一个<code class="language-plaintext highlighter-rouge">IntFunction&lt;Integer[]&gt;</code>的匿名实现，实现了<code class="language-plaintext highlighter-rouge">apply</code>方法来创建一个指定大小的<code class="language-plaintext highlighter-rouge">Integer</code>数组。然后，通过<code class="language-plaintext highlighter-rouge">toArray</code>方法将列表转换为该数组。</p><p>通过lambda 表达式简化后变成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div><p>这个 lambda 表达式接受一个整数参数 <code class="language-plaintext highlighter-rouge">size</code>，并返回一个新的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，长度为 <code class="language-plaintext highlighter-rouge">size</code>。</p><p>通过方法引用再次简化后变成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntFunction</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">[]&gt;</span> <span class="n">generator</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">[]::</span><span class="k">new</span><span class="o">;</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="n">generator</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Integer[]::new</code> 表示一个构造函数引用，它接受一个整数参数（数组的长度）并返回一个 <code class="language-plaintext highlighter-rouge">Integer</code> 数组。这样，<code class="language-plaintext highlighter-rouge">toArray(Integer[]::new)</code> 将生成一个与 <code class="language-plaintext highlighter-rouge">list</code> 大小相同的 <code class="language-plaintext highlighter-rouge">Integer</code> 数组，并将 <code class="language-plaintext highlighter-rouge">list</code> 中的元素复制到这个数组中。</p><p>详情参见：<a href="/2024/04/25/函数式编程/">函数式编程</a></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/" target="_blank">https://acteds.github.io/2024/04/07/Java%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1716100444', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
