<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>泛型 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/03/21/%E6%B3%9B%E5%9E%8B/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="泛型"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言泛型类、泛型方法、擦拭法、entends通配符、super通配符、无限定通配符、Void。"><meta name="og:description" content="引言泛型类、泛型方法、擦拭法、entends通配符、super通配符、无限定通配符、Void。"><meta property="og:url" content="/2024/03/21/%E6%B3%9B%E5%9E%8B/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-03-21"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="泛型"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">泛型</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/03/21 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 29099 字，约 84 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>泛型类、泛型方法、擦拭法、<code class="language-plaintext highlighter-rouge">entends</code>通配符、<code class="language-plaintext highlighter-rouge">super</code>通配符、无限定通配符、<code class="language-plaintext highlighter-rouge">Void</code>。</p><h1 id="泛型">泛型</h1><p>泛型就是编写模板代码来适应任意类型；</p><p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p><p>泛型的继承关系<strong>可以</strong>把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！），但<strong>不能</strong>把<code class="language-plaintext highlighter-rouge">ArrayList&lt;Integer&gt;</code>向上转型为<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>（<code class="language-plaintext highlighter-rouge">T</code>不能变！<code class="language-plaintext highlighter-rouge">T</code>也不能变成父类）。</p><p>如果实例化时<strong>不定义泛型类型</strong>时，那么默认会使用<code class="language-plaintext highlighter-rouge">Object</code>作为泛型类型参数。如<code class="language-plaintext highlighter-rouge">MyClass myClass = new MyClass();</code>，那么<code class="language-plaintext highlighter-rouge">T</code>会被擦除为<code class="language-plaintext highlighter-rouge">Object</code>，相当于<code class="language-plaintext highlighter-rouge">MyClass&lt;Object&gt; myClass = new MyClass&lt;Object&gt;();</code>。</p><p>编译器如果能自动推断出泛型类型，可以省略后面的泛型类型。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;();</span>
</code></pre></div></div><p>编译器看到泛型类型<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>就<strong>可以</strong>自动推断出后面的<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>的泛型类型<strong>必须</strong>是<code class="language-plaintext highlighter-rouge">ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><p>除了<code class="language-plaintext highlighter-rouge">ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code class="language-plaintext highlighter-rouge">Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code class="language-plaintext highlighter-rouge">Comparable&lt;T&gt;</code>这个泛型接口。</p><h2 id="泛型类">泛型类</h2><p>泛型类写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>定义泛型类时，在类名后面定义<code class="language-plaintext highlighter-rouge">泛型类型参数</code>。</p><p><strong>在泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</strong></p><p>初始化：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span><span class="c1">//或new Pair&lt;String&gt;("1","2");</span>
</code></pre></div></div><h2 id="泛型方法">泛型方法</h2><h3 id="泛型方法的定义">泛型方法的定义</h3><p>泛型方法写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 方法实现</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在Java中，泛型方法的定义通常如下所示：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">返回类型</span> <span class="n">方法名</span><span class="o">(</span><span class="n">参数列表</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 方法体</span>
<span class="o">}</span>
</code></pre></div></div><ul><li><code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：泛型类型参数声明，放在<strong>返回类型之前</strong>，表示该方法是一个泛型方法，并且可以接受类型为<code class="language-plaintext highlighter-rouge">T</code>的参数或返回类型为<code class="language-plaintext highlighter-rouge">T</code>的值。</li><li>返回类型：方法的返回类型，可以是泛型类型<code class="language-plaintext highlighter-rouge">T</code>或其他类型。</li><li>方法名：方法的名称。</li><li>参数列表：方法的参数列表，可以包含泛型类型<code class="language-plaintext highlighter-rouge">T</code>。</li><li>方法体：方法的具体实现。</li></ul><p>在泛型方法中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是用来声明泛型类型参数的。当调用泛型方法时，可以根据实际情况传入不同的类型参数。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyClass</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="nc">Integer</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它可以接受任意类型的参数并返回相同类型的值。在调用<code class="language-plaintext highlighter-rouge">myMethod</code>时，根据传入的参数类型确定返回类型，从而实现了泛型方法的灵活性。</p><p>在泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p><p><strong>而在方法中定义的泛型类型参数只适用于该方法</strong>。</p><h3 id="同时定义泛型类与泛型方法">同时定义泛型类与泛型方法</h3><p>如果在类名后面定义了泛型类型参数，在类的方法中仍然<strong>可以</strong>使用独立的泛型类型参数。这两者是独立的，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在这个例子中，<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>是一个泛型类，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>表示类的泛型类型参数。<code class="language-plaintext highlighter-rouge">printValue</code>是泛型方法，<code class="language-plaintext highlighter-rouge">printValue</code>中的<code class="language-plaintext highlighter-rouge">&lt;K&gt;</code>是方法级别的泛型类型参数，泛型方法的<code class="language-plaintext highlighter-rouge">K</code>与类的<code class="language-plaintext highlighter-rouge">T</code>是相互独立的。</p><p><strong>在泛型方法中可以使用泛型类的标识符</strong>。泛型类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>中的泛型方法也可以使用类的泛型标识符<code class="language-plaintext highlighter-rouge">T</code>以下是一个示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Main</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myMethod</span><span class="o">(</span><span class="no">U</span> <span class="n">u</span><span class="o">,</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyClass value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">u</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Method argument: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Main</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">myClass</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Main</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">);</span>
        <span class="n">myClass</span><span class="o">.&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span><span class="n">myMethod</span><span class="o">(</span><span class="mi">123</span><span class="o">,</span><span class="s">"haha"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>在这个例子中，<code class="language-plaintext highlighter-rouge">myMethod</code>是一个泛型方法，它使用了泛型方法类型参数<code class="language-plaintext highlighter-rouge">U</code>，这个类型参数与泛型类<code class="language-plaintext highlighter-rouge">MyClass</code>中的类型参数<code class="language-plaintext highlighter-rouge">T</code>是不同的，它也使用了泛型类方法类型参数<code class="language-plaintext highlighter-rouge">T</code>。在<code class="language-plaintext highlighter-rouge">myMethod&lt;Integer&gt;(123, "haha")</code>这个调用中，类型参数<code class="language-plaintext highlighter-rouge">U</code>被指定为<code class="language-plaintext highlighter-rouge">Integer</code>，类型参数<code class="language-plaintext highlighter-rouge">T</code>在类实例化时被推断为<code class="language-plaintext highlighter-rouge">String</code>。因此，<code class="language-plaintext highlighter-rouge">myMethod</code>方法的第一个参数<code class="language-plaintext highlighter-rouge">u</code>是<code class="language-plaintext highlighter-rouge">Integer</code>类型，第二个参数<code class="language-plaintext highlighter-rouge">t</code>是<code class="language-plaintext highlighter-rouge">String</code>类型。</p><h3 id="泛型类与泛型方法使用相同的泛型类型参数名">泛型类与泛型方法使用相同的泛型类型参数名</h3><p>如果在类名后面定义了泛型类型参数，并且在方法中使用了<strong>相同的泛型类型参数名</strong>，这并不会产生冲突，因为它们在不同的作用域中。类的泛型类型参数适用于整个类，而方法的泛型类型参数只适用于该方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">printValue</span><span class="o">(</span><span class="no">T</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Value: "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Key: "</span> <span class="o">+</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在这个例子中，类<code class="language-plaintext highlighter-rouge">MyClass&lt;T&gt;</code>有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示类的类型参数。泛型方法<code class="language-plaintext highlighter-rouge">printValue</code>中也有一个泛型类型参数<code class="language-plaintext highlighter-rouge">T</code>，表示方法级别的类型参数。这两个<code class="language-plaintext highlighter-rouge">T</code>是不同的，在方法中使用的<code class="language-plaintext highlighter-rouge">T</code>只在方法范围内有效，不会与类的泛型类型参数产生冲突。</p><p>但这样写会在泛型方法中隐藏类的同名泛型类型参数，在泛型方法中就<strong>用不了</strong>类的同名泛型类型参数了，因为它已经被方法中定义的泛型类型参数隐藏了，而并不存在一个<code class="language-plaintext highlighter-rouge">this.</code>来调用泛型类的泛型类型参数。</p><p>因此<strong>不建议这么做</strong>，因为这样也很容易让人误解。<strong>更不建议将</strong><code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">Stirng</code>之类的，别人看了会打人，而且同样会隐藏<code class="language-plaintext highlighter-rouge">Stirng</code>，从而导致你要通过<code class="language-plaintext highlighter-rouge">java.lang.String</code>使用<code class="language-plaintext highlighter-rouge">String</code>。</p><h3 id="静态泛型方法">静态泛型方法</h3><p>编写泛型类时，要特别注意，<strong>泛型类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。</strong></p><p>因为泛型类中定义的泛型类型参数只能用于整个类的实例。而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p><p>在静态方法中，同样可以变成泛型方法，使用泛型类型参数，就是之前泛型方法的写法加个<code class="language-plaintext highlighter-rouge">static</code>，语法一模一样。</p><p>例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">myStaticMethod</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Static method: "</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">MyClass</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">myStaticMethod</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在这个例子中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是在静态泛型方法<code class="language-plaintext highlighter-rouge">myStaticMethod</code>的返回类型<code class="language-plaintext highlighter-rouge">void</code>之前声明的，用于定义该方法的泛型类型参数。在调用静态方法时，需要使用<strong><code class="language-plaintext highlighter-rouge">MyClass.&lt;String&gt;</code></strong>来指定类型参数。</p><ul><li>泛型类的泛型类型参数是在实例化对象时确定的，而静态方法是在类加载时就可以直接调用的，无需创建对象实例。所以静态方法中的返回值、参数等不能使用泛型类的泛型类型参数。因此静态方法如果需要使用泛型，必须定义自己的泛型类型参数。</li><li><strong>必须</strong>将静态方法的泛型类型参数和泛型类的泛型类型参数<strong>区分开</strong>。<strong>其实相同也没关系</strong>，就是容易让人误解，也不存在覆盖泛型类类型参数的问题，因为本来静态方法就不能用类的非静态的东西，但在静态泛型方法内还是存在同名隐藏问题，比如之前说的将<code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">String</code>。</li></ul><h2 id="多个泛型类型">多个泛型类型</h2><p>泛型还可以定义多种类型。例如，我们希望<code class="language-plaintext highlighter-rouge">Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">K</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">K</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用的时候，需要指出两种类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"test"</span><span class="o">,</span> <span class="mi">123</span><span class="o">);</span>
</code></pre></div></div><p>Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对<code class="language-plaintext highlighter-rouge">Key</code>使用一种类型，对<code class="language-plaintext highlighter-rouge">Value</code>使用另一种类型。</p><h2 id="擦拭法">擦拭法</h2><p>所谓擦拭法是指，<strong>虚拟机</strong>对泛型其实一无所知，所有的工作都是<strong>编译器</strong>做的。因此<strong>编译器</strong>把类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>视为<code class="language-plaintext highlighter-rouge">Object</code>；<strong>编译器</strong>根据<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>实现<strong>安全的强制转型</strong>。</p><p>例如，我们编写了一个泛型类<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>，这是<strong>编译器</strong>看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而<strong>虚拟机</strong>根本不知道泛型。这是虚拟机执行的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Object</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用泛型的时候，我们编写的代码也是如此，<strong>编译器</strong>看到的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>而<strong>虚拟机</strong>执行的代码并没有泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">first</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">last</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
</code></pre></div></div><p>Java的泛型是由<strong>编译器</strong>在<strong>编译时</strong>实行的，<strong>编译器</strong>内部<strong>永远</strong>把所有类型<code class="language-plaintext highlighter-rouge">T</code>视为<code class="language-plaintext highlighter-rouge">Object</code>处理，但是，在需要<strong>转型</strong>的时候，<strong>编译器</strong>会根据<code class="language-plaintext highlighter-rouge">T</code>的类型<strong>自动</strong>为我们实行安全地强制转型。</p><p><strong>局限一</strong>：<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能是基本类型，例如<code class="language-plaintext highlighter-rouge">int</code>，因为实际类型是<code class="language-plaintext highlighter-rouge">Object</code>，<code class="language-plaintext highlighter-rouge">Object</code>类型无法持有基本类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p><strong>局限二</strong>：无法取得带泛型的<code class="language-plaintext highlighter-rouge">Class</code>。观察以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="s">"Hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">Class</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c1</span><span class="o">==</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因为<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Object</code>，我们对<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;</code>和<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型获取<code class="language-plaintext highlighter-rouge">Class</code>时，获取到的是同一个<code class="language-plaintext highlighter-rouge">Class</code>，也就是<code class="language-plaintext highlighter-rouge">Pair</code>类的<code class="language-plaintext highlighter-rouge">Class</code>。</p><p>换句话说，所有泛型实例，<strong>无论</strong><code class="language-plaintext highlighter-rouge">T</code>的类型是什么，<code class="language-plaintext highlighter-rouge">getClass()</code>都返回<strong>同一个</strong><code class="language-plaintext highlighter-rouge">Class</code>实例，因为编译后它们全部都是<code class="language-plaintext highlighter-rouge">Pair</code>类，使用<code class="language-plaintext highlighter-rouge">Object</code>替换<code class="language-plaintext highlighter-rouge">T</code>。</p><p><strong>局限三</strong>：无法判断带泛型的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
<span class="c1">// Compile error：</span>
<span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;)</span> <span class="o">{}</span>
</code></pre></div></div><p>原因和前面一样，并不存在<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>，而是只有唯一的<code class="language-plaintext highlighter-rouge">Pair.class</code>。</p><p><strong>局限四</strong>：不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// Compile error：</span>
        <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述代码无法通过编译，因为构造方法的两行语句：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="no">T</span><span class="o">();</span>
</code></pre></div></div><p><strong>擦拭后</strong>实际上变成了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">last</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div><p>这样一来，创建<code class="language-plaintext highlighter-rouge">new Pair&lt;String&gt;()</code>和创建<code class="language-plaintext highlighter-rouge">new Pair&lt;Integer&gt;()</code>，内部的<code class="language-plaintext highlighter-rouge">first</code>和<code class="language-plaintext highlighter-rouge">last</code>全部成了<code class="language-plaintext highlighter-rouge">Object</code>类型，显然编译器要阻止这种类型不对的代码，为了<strong>防止</strong>可能的错误出现<strong>编译器</strong>直接<strong>一刀切</strong>这个操作。</p><p>而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了一个抽象类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><p>上面的<code class="language-plaintext highlighter-rouge">Number</code>是不能直接实例化的，所以编译器要阻止这种行为。</p><p>顺便提一下，如果改成了利用反射实例化：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">clazz</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">first</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>借助<code class="language-plaintext highlighter-rouge">class.newInstance()</code>创建实例时编译器要求强制处理可能出现的异常，相当于做了兼容。直接<code class="language-plaintext highlighter-rouge">new</code>的话如果泛型类型为抽象类，则会出错。</p><p>上述代码借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>参数并通过反射来实例化<code class="language-plaintext highlighter-rouge">T</code>类型，使用的时候，也必须传入<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><h3 id="不恰当的覆写方法">不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span> <span class="o">==</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在 Java 中，泛型类型在编译时会被擦除，<strong>编译器</strong>会把泛型类型的信息擦除掉，将其替换为其上限类型（如果有指定上限类型的话），或者替换为 <code class="language-plaintext highlighter-rouge">Object</code> 类型。这是为了与 Java 的运行时类型擦除机制相适配</p><p>定义的<code class="language-plaintext highlighter-rouge">equals(T t)</code>方法实际上会被擦拭成<code class="language-plaintext highlighter-rouge">equals(Object t)</code>，而这个方法是继承自<code class="language-plaintext highlighter-rouge">Object</code>的，而<strong>编译器</strong>会阻止一个实际上会变成覆写的泛型方法定义。</p><p>因为仅仅通过泛型代码的定义，<strong>编译器</strong>是<strong>无法确定</strong>泛型<strong>是否覆写</strong>了此方法。</p><p>在泛型类型擦除后，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code>与 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法的签名相同。因此，从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法。</p><p>但是，由于 Java 泛型的设计，<strong>编译器</strong>会在编译时对泛型类型进行额外的类型检查，以确保类型安全。在这种情况下，<strong>编译器</strong>会注意到 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法<strong>使用了泛型类型</strong> <code class="language-plaintext highlighter-rouge">T</code>，而 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法使用了原始的 <code class="language-plaintext highlighter-rouge">Object</code> 类型，在编译时这会被认为是<strong>不同</strong>的方法。<br /> 因此，编译器会认为 <code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法<strong>不是重写</strong>，而是一个<strong>新定义的方法</strong>。</p><p>这也是为了确保子类重写父类方法时不会改变方法的行为，避免在子类中意外修改了父类的行为。</p><p>综上所述，虽然从方法签名的角度来看，<code class="language-plaintext highlighter-rouge">Pair</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法应该是重写了 <code class="language-plaintext highlighter-rouge">Object</code> 类中的 <code class="language-plaintext highlighter-rouge">equals</code> 方法，但在编译器的类型检查中，它们会被认为是<strong>不同</strong>的方法，因为泛型类型 <code class="language-plaintext highlighter-rouge">T</code> 在编译时会被认为是不同的参数类型。</p><hr /><p>虽然擦除后不是覆写，但编译器装作有泛型的行为，导致在调用<code class="language-plaintext highlighter-rouge">test()</code>时编译器不知道调用哪个<code class="language-plaintext highlighter-rouge">test()</code>，非预期效果，编译器报错：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Test</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">t1</span><span class="o">=</span><span class="k">new</span> <span class="nc">Test</span><span class="o">&lt;&gt;();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getMethods</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"test"</span><span class="o">)){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">method</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="c1">//        t1.test((Number)124);//错误:java: 对test的引用不明确com.aotmd.SuperTest 中的方法 test(java.lang.Number) 和 com.aotmd.Test 中的方法 test(T) 都匹配</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Test</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">SuperTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">test</span><span class="o">((</span><span class="nc">Number</span><span class="o">)</span> <span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SuperTest</span>  <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">Number</span> <span class="n">o</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">o</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>结果：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class com.aotmd.Test
public void com.aotmd.Test.test(java.lang.Object)
public void com.aotmd.SuperTest.test(java.lang.Number)
</code></pre></div></div><h3 id="泛型继承">泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类是<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>，子类是<code class="language-plaintext highlighter-rouge">IntPair</code>，可以这么继承：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div><p>使用的时候，因为子类<code class="language-plaintext highlighter-rouge">IntPair</code>并没有泛型，所以正常使用即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">IntPair</span> <span class="n">ip</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IntPair</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</code></pre></div></div><p>前面讲了，我们无法获取<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的<code class="language-plaintext highlighter-rouge">T</code>类型，即给定一个变量<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt; p</code>，也无法从<code class="language-plaintext highlighter-rouge">p</code>中获取到<code class="language-plaintext highlighter-rouge">Integer</code>类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code class="language-plaintext highlighter-rouge">T</code>（对<code class="language-plaintext highlighter-rouge">IntPair</code>来说，也就是<code class="language-plaintext highlighter-rouge">Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code class="language-plaintext highlighter-rouge">IntPair</code>只能存取<code class="language-plaintext highlighter-rouge">Integer</code>这种类型。</p><p>在继承了泛型类型的情况下，子类<strong>可以</strong>获取父类的泛型类型。例如：<code class="language-plaintext highlighter-rouge">IntPair</code>可以获取到父类的泛型类型<code class="language-plaintext highlighter-rouge">Integer</code>。获取父类的泛型类型代码比较复杂：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.ParameterizedType</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Type</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;</span><span class="nc">IntPair</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">IntPair</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="nc">Type</span> <span class="n">t</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getGenericSuperclass</span><span class="o">();</span><span class="c1">//获取泛型父类的class</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="k">instanceof</span> <span class="nc">ParameterizedType</span><span class="o">)</span> <span class="o">{</span><span class="c1">//判断是否为ParameterizedType，如果是，则表示泛型父类有实际类型参数。</span>
            <span class="nc">ParameterizedType</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ParameterizedType</span><span class="o">)</span> <span class="n">t</span><span class="o">;</span>
            <span class="nc">Type</span><span class="o">[]</span> <span class="n">types</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="na">getActualTypeArguments</span><span class="o">();</span> <span class="c1">// 获取实际类型参数的数组，本例中数组长度为1。</span>
            <span class="nc">Type</span> <span class="n">firstType</span> <span class="o">=</span> <span class="n">types</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 获取第一个实际类型参数</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">firstType</span><span class="o">);</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">typeClass</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;)</span> <span class="n">firstType</span><span class="o">;</span><span class="c1">//将其转换为 Class 对象，若还是泛型K则转换失败。</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">typeClass</span><span class="o">);</span> <span class="c1">// Integer</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">IntPair</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>修改<code class="language-plaintext highlighter-rouge">IntPair</code>，然后重新运行，类型转换会出错:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">IntPair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">IntPair</span><span class="o">(</span><span class="no">K</span> <span class="n">o1</span><span class="o">,</span><span class="no">K</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">o1</span><span class="o">,</span><span class="n">o2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因为Java引入了泛型，所以，只用<code class="language-plaintext highlighter-rouge">Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p><pre><code class="language-ascii">                      ┌────┐
                      │Type│
                      └────┘
                         ▲
                         │
   ┌────────────┬────────┴─────────┬───────────────┐
   │            │                  │               │
┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐
│Class││ParameterizedType││GenericArrayType││WildcardType│
└─────┘└─────────────────┘└────────────────┘└────────────┘
</code></pre><h3 id="小结">小结</h3><p>Java的泛型是采用擦拭法实现的；</p><p>擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li><li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>；</p><p>子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p><h2 id="extends通配符在形式参数的作用">extends通配符在形式参数的作用</h2><p>之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，他们之前没有什么关系。</p><p>假设我们定义了<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后对<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div><p>注意：传入的类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，实际参数类型是<code class="language-plaintext highlighter-rouge">(Integer, Integer)</code>。</p><p>既然实际参数是<code class="language-plaintext highlighter-rouge">Integer</code>类型，试试传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
</code></pre></div></div><p>直接运行，会得到一个编译错误：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: Pair&lt;Integer&gt;无法转换为Pair&lt;Number&gt;
</code></pre></div></div><p>原因很明显，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，它们之间没什么关系，因此，<code class="language-plaintext highlighter-rouge">add(Pair&lt;Number&gt; p)</code>方法，不接受参数类型<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>。</p><p>方法里的代码逻辑是没有问题，<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">Integer</code>的父类。问题在于方法参数类型定死了只能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>。</p><hr /><p>有没有办法使得方法参数接受<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>使得方法能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。我们把代码改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
    <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>这样一来，给方法传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型时，它符合参数<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型。这种使用<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code class="language-plaintext highlighter-rouge">T</code>的上界限定在<code class="language-plaintext highlighter-rouge">Number</code>了。</p><p>这样写除了可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型，还可以传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型，<code class="language-plaintext highlighter-rouge">Pair&lt;BigDecimal&gt;</code>类型等等，因为<code class="language-plaintext highlighter-rouge">Double</code>和<code class="language-plaintext highlighter-rouge">BigDecimal</code>都是<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p><p>对<code class="language-plaintext highlighter-rouge">Pair&lt;? extends Number&gt;</code>类型调用<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，实际的方法签名变成了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>即返回值是<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>的子类，因为 <code class="language-plaintext highlighter-rouge">Number</code> 是 <code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code> 的上界，所以返回值可以安全地赋值给 <code class="language-plaintext highlighter-rouge">Number</code> 类型的变量 <code class="language-plaintext highlighter-rouge">first</code>(向上提升)：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Number</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>不能赋值给<code class="language-plaintext highlighter-rouge">Integer</code>，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物，也即可能的向下转型是不安全的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span><span class="c1">//错误</span>
</code></pre></div></div><p>这是因为实际的返回类型可能是<code class="language-plaintext highlighter-rouge">Integer</code>，也可能是<code class="language-plaintext highlighter-rouge">Double</code>或者其他类型，编译器只能确定类型一定是<code class="language-plaintext highlighter-rouge">Number</code>的子类（包括<code class="language-plaintext highlighter-rouge">Number</code>类型本身），但具体类型无法确定。</p><hr /><p>尝试写操作：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Number</span> <span class="n">first</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">Number</span> <span class="n">last</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">first</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">()</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">().</span><span class="na">intValue</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java: 不兼容的类型: java.lang.Integer无法转换为capture#1, 共 ? extends java.lang.Number
</code></pre></div></div><p>编译错误发生在<code class="language-plaintext highlighter-rouge">p.setFirst()</code>，我们对<code class="language-plaintext highlighter-rouge">add(Pair&lt;? extends Number&gt; p)</code>传入了<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，对于<code class="language-plaintext highlighter-rouge">setFirst(? extends Number)</code>为什么不能传入<code class="language-plaintext highlighter-rouge">Integer</code>呢？</p><p>因为我们还能传入<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>类型的<code class="language-plaintext highlighter-rouge">p</code>，而传入<code class="language-plaintext highlighter-rouge">setFirst</code>的代码类型并不会变成<code class="language-plaintext highlighter-rouge">Double</code>类型，代码是固定的，形式参数类型为<code class="language-plaintext highlighter-rouge">Pair&lt;Double&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>当然是无法接受<code class="language-plaintext highlighter-rouge">Integer</code>类型的。</p><p>为了避免产生安全问题，编译器一刀切，直接<strong>不接受任何写行为</strong>。</p><p>唯一的例外是可以给方法参数传入<code class="language-plaintext highlighter-rouge">null</code>，因为泛型只接受引用类型，也即对象，因为擦除法都擦成<code class="language-plaintext highlighter-rouge">Object</code>了，而所有的对象都可以赋值<code class="language-plaintext highlighter-rouge">null</code>，所以这是安全的行为。</p><p>总的来说，调用：<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读，则需要用上界接收。写则因为可能向下转型的原因被切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。</p><h3 id="extends通配符形式参数实例">extends通配符形式参数实例</h3><p>Java标准库的<code class="language-plaintext highlighter-rouge">java.util.List&lt;T&gt;</code>接口实现的是一个类似“可变数组”的列表，主要功能包括：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">size</span><span class="o">();</span> <span class="c1">// 获取个数</span>
    <span class="no">T</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">);</span> <span class="c1">// 根据索引获取指定元素</span>
    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 添加一个新元素</span>
    <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span> <span class="c1">// 删除一个已有元素</span>
<span class="o">}</span>
</code></pre></div></div><p>定义一个方法来处理列表的每个元素：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sumOfList</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">? extends Integer</code>限制了只读，只能调用<code class="language-plaintext highlighter-rouge">size()</code>，<code class="language-plaintext highlighter-rouge">get()</code>，不能调用<code class="language-plaintext highlighter-rouge">add()</code>，<code class="language-plaintext highlighter-rouge">remove()</code>。</p><h3 id="使用extends在类限定t类型">使用extends在类限定T类型</h3><p>在定义<strong>泛型类型</strong><code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的时候，也可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div><p>现在，我们只能定义：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">p3</span><span class="o">;</span>
</code></pre></div></div><p>因为<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">Integer</code>和<code class="language-plaintext highlighter-rouge">Double</code>都符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>。<br /> 非<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类类型将无法通过编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p1</span><span class="o">;</span> <span class="c1">// compile error!</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">p2</span><span class="o">;</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Object</code>都不符合<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>，它们不是<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p><h3 id="小结-1">小结</h3><p>  <font color="red"><b>使用类似`&lt;? extends Number&gt;`通配符参与方法的形式参数时表示：</b></font></p><ul><li><strong>调用：<code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt; getFirst();</code>读，则必须至少用上界<code class="language-plaintext highlighter-rouge">Number</code>接收，也可以用<code class="language-plaintext highlighter-rouge">Number</code>的父类接收，比如<code class="language-plaintext highlighter-rouge">Object</code>，避免可能的向下转型。</strong></li><li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? extends Number&gt; o)</code>写则，因为可能向下转型的原因被一刀切了，只有<code class="language-plaintext highlighter-rouge">null</code>值可以赋值给所有对象，才做为例外。(如果有下界倒是可以赋值下界或下界的子类，避免向下转型了)</strong></li><li><strong>方法被修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Number</code>子类的泛型类型。</strong></li></ul><p>  <font color="red"><b>`&lt;? extends 上界&gt;`：传参类型&lt;=上界，只能写`null`，读&gt;=上界。</b></font></p><p>其实<strong>不在方法参数</strong>也能用<code class="language-plaintext highlighter-rouge">&lt;? extends 上界&gt;</code>，效果是相同的。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用类似<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示：</p><ul><li><strong>泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</strong></li></ul><h2 id="super通配符在形式参数的作用">super通配符在形式参数的作用</h2><p>之前说明泛型的继承关系：<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>不是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>的子类，他们之前没有什么关系。<br /> 考察下面的<code class="language-plaintext highlighter-rouge">set</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>传入<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是允许的，而传入<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>是不允许的。</p><p>和<code class="language-plaintext highlighter-rouge">extends</code>通配符相反，这次，我们希望接受泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。还是向上提升的问题，父类可以指向子类，所以写操作是安全的。同样的，向下转型不安全，因此禁止读取。</p><p>使用<code class="language-plaintext highlighter-rouge">super</code>通配符来改写这个方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">first</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的<code class="language-plaintext highlighter-rouge">Pair</code>类型。</p><p>下面的代码可以被正常编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mf">12.3</span><span class="o">,</span> <span class="mf">4.56</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="mi">100</span><span class="o">);</span>
        <span class="n">setSame</span><span class="o">(</span><span class="n">p2</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p1</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p1</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setSame</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setFirst</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setLast</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">setFirst()</code>方法签名实际上是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">);</span>
</code></pre></div></div><p>因此，可以安全地传入<code class="language-plaintext highlighter-rouge">Integer</code>类型。如果你传<code class="language-plaintext highlighter-rouge">Number</code>类型，不好意思，因为泛型有可能是<code class="language-plaintext highlighter-rouge">Integer</code>所以不可以，即：有可能造成<code class="language-plaintext highlighter-rouge">Number</code>转<code class="language-plaintext highlighter-rouge">Integer</code>了，即向下转型。所以你想写入，则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入，也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能的向下转型。</p><p>而<code class="language-plaintext highlighter-rouge">Pair&lt;? super Integer&gt;</code>的<code class="language-plaintext highlighter-rouge">getFirst()</code>方法，它的方法签名实际上是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">?</span> <span class="kd">super</span> <span class="nc">Integer</span> <span class="nf">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>无法使用<code class="language-plaintext highlighter-rouge">Integer</code>类型来接收<code class="language-plaintext highlighter-rouge">getFirst()</code>的返回值，还是老样子，<code class="language-plaintext highlighter-rouge">Integer</code>可不是<code class="language-plaintext highlighter-rouge">Object</code>接收万物，也即可能的向下转型是不安全的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>因为如果传入的实际类型是<code class="language-plaintext highlighter-rouge">Pair&lt;Number&gt;</code>，在上面的代码中编译器无法将<code class="language-plaintext highlighter-rouge">Number</code>类型转型为<code class="language-plaintext highlighter-rouge">Integer</code>，即向下转型。</p><p>唯一可以接收<code class="language-plaintext highlighter-rouge">getFirst()</code>方法返回值的是<code class="language-plaintext highlighter-rouge">Object</code>类型，因为它是所有类的父类，它能包容一切，除它自己外，所有对它的赋值都是向上提升，因此是安全的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>  <font color="red"><b>使用类似`&lt;? super Integer&gt;`通配符参与方法的形式参数时表示：</b></font></p><ul><li><strong>调用：<code class="language-plaintext highlighter-rouge">&lt;? super Integer&gt; getFirst();</code>读，因为没有限定上界，那只能用<code class="language-plaintext highlighter-rouge">Object</code>接收，避免可能的向下转型。</strong></li><li><strong>对于<code class="language-plaintext highlighter-rouge">setFirst(&lt;? super Integer&gt; o)</code>写则，则最多用下界<code class="language-plaintext highlighter-rouge">Integer</code>写入，也可以用<code class="language-plaintext highlighter-rouge">Integer</code>的子类，避免可能向下转型。</strong></li><li><strong>方法修饰的形式参数能够接收所有泛型类型为<code class="language-plaintext highlighter-rouge">Integer</code>或<code class="language-plaintext highlighter-rouge">Integer</code>父类的泛型类型。</strong></li></ul><p>  <font color="red"><b>`&lt;? super 下界&gt;`：传参类型&gt;=下界，写&lt;=下界，读只能`Object`。</b></font></p><p>其实不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? super 下界&gt;</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">&lt;&gt;(</span><span class="s">"123"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;}</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="s">"A{value="</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="对比extends和super通配符在形式参数的作用">对比extends和super通配符在形式参数的作用</h3><p>对比<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>，作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型的区别在于：</p><ul><li> <font color="red"><b>`&lt;? extends T&gt;`：传参类型&lt;=`T`，只能写`null`，读&gt;=`T`。</b></font></li><li> <font color="red"><b>`&lt;? super T&gt;`： 传参类型&gt;=`T`，写&lt;=`T`，读只能`Object`。</b></font></li></ul><p>一个是允许读不允许写，另一个是允许写不允许读。</p><p>Java标准库的<code class="language-plaintext highlighter-rouge">Collections</code>类定义的<code class="language-plaintext highlighter-rouge">copy()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Collections</span> <span class="o">{</span>
    <span class="c1">// 把src的每个元素复制到dest中：</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">dest</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">src</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">dest</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>它的作用是把一个<code class="language-plaintext highlighter-rouge">List</code>的每个元素依次添加到另一个<code class="language-plaintext highlighter-rouge">List</code>中。它的第一个参数是<code class="language-plaintext highlighter-rouge">List&lt;? super T&gt;</code>，表示目标<code class="language-plaintext highlighter-rouge">List</code>，第二个参数<code class="language-plaintext highlighter-rouge">List&lt;? extends T&gt;</code>，表示要复制的<code class="language-plaintext highlighter-rouge">List</code>。我们可以简单地用<code class="language-plaintext highlighter-rouge">for</code>循环实现复制。在<code class="language-plaintext highlighter-rouge">for</code>循环中，对于类型<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">src</code>可以安全的读，而对于类型<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>的变量<code class="language-plaintext highlighter-rouge">dest</code>可以安全的写。</p><p>这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的定义就完美地展示了<code class="language-plaintext highlighter-rouge">extends</code>和<code class="language-plaintext highlighter-rouge">super</code>的意图：</p><ul><li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部不会读取<code class="language-plaintext highlighter-rouge">dest</code>，因为不能调用<code class="language-plaintext highlighter-rouge">dest.get()</code>来获取<code class="language-plaintext highlighter-rouge">T</code>的引用；</li><li><code class="language-plaintext highlighter-rouge">copy()</code>方法内部也不会修改<code class="language-plaintext highlighter-rouge">src</code>，因为不能调用<code class="language-plaintext highlighter-rouge">src.add(T)</code>。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// copy List&lt;Integer&gt; to List&lt;Number&gt; ok：</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">numList</span><span class="o">,</span> <span class="n">intList</span><span class="o">);</span>
</code></pre></div></div><p>这两个 <code class="language-plaintext highlighter-rouge">T</code> 是<strong>同一个类型</strong>。在方法签名中，<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> 定义了方法级别的泛型类型参数，表示 <code class="language-plaintext highlighter-rouge">copy</code> 方法是一个泛型方法，它接受一个类型为 <code class="language-plaintext highlighter-rouge">T</code> 的参数。类型参数的推断是基于传入参数的类型来确定的，编译器会尝试推断出最具体的类型，然后将其用作所有相关类型参数的类型。如果无法推断出一个具体的类型，编译器将无法确定如何匹配类型参数，从而导致编译错误。</p><p>使用前面的结论：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>：<code class="language-plaintext highlighter-rouge">Integer</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>，只能写<code class="language-plaintext highlighter-rouge">null</code>，读&gt;=<code class="language-plaintext highlighter-rouge">T</code>。</strong></li><li><strong><code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>： <code class="language-plaintext highlighter-rouge">Number</code>&gt;=<code class="language-plaintext highlighter-rouge">T</code>，写&lt;=<code class="language-plaintext highlighter-rouge">T</code>，读只能<code class="language-plaintext highlighter-rouge">Object</code>。</strong></li></ul><p>可以得出：<code class="language-plaintext highlighter-rouge">Integer</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>&lt;=<code class="language-plaintext highlighter-rouge">Number</code>。</p><p>在在这次调用中<code class="language-plaintext highlighter-rouge">T</code>的类型确定需要满足两个条件，即：</p><ul><li>因为<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>，所以<code class="language-plaintext highlighter-rouge">Number</code>是<code class="language-plaintext highlighter-rouge">T</code>或<code class="language-plaintext highlighter-rouge">T</code>的父类，也就是说<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Number</code>或其子类</li><li>因为<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>，所以<code class="language-plaintext highlighter-rouge">Integer</code>是<code class="language-plaintext highlighter-rouge">T</code>或<code class="language-plaintext highlighter-rouge">T</code>的子类，也就是说<code class="language-plaintext highlighter-rouge">T</code>是<code class="language-plaintext highlighter-rouge">Integer</code>或其父类</li></ul><p>因此，<code class="language-plaintext highlighter-rouge">T</code> 可以被推断为 <code class="language-plaintext highlighter-rouge">Number</code>或<code class="language-plaintext highlighter-rouge">Integer</code>，从而实现了将 <code class="language-plaintext highlighter-rouge">Integer</code> 类型的列表复制到 <code class="language-plaintext highlighter-rouge">Number</code> 类型的列表的操作。这种根据实际类型推断泛型类型参数的过程称为类型推断。</p><p>这个<code class="language-plaintext highlighter-rouge">copy()</code>方法的另一个好处是可以安全地把一个<code class="language-plaintext highlighter-rouge">List&lt;Integer&gt;</code>添加到<code class="language-plaintext highlighter-rouge">List&lt;Number&gt;</code>，但是无法反过来添加：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">intList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="c1">// ERROR: cannot copy List&lt;Number&gt; to List&lt;Integer&gt;:</span>
<span class="nc">Collections</span><span class="o">.</span><span class="na">copy</span><span class="o">(</span><span class="n">intList</span><span class="o">,</span> <span class="n">numList</span><span class="o">);</span>
</code></pre></div></div><p>因为不存在<code class="language-plaintext highlighter-rouge">Number</code>&lt;=<code class="language-plaintext highlighter-rouge">T</code>&lt;=<code class="language-plaintext highlighter-rouge">Integer</code>这样的类型。</p><p>而这些都是通过<code class="language-plaintext highlighter-rouge">super</code>和<code class="language-plaintext highlighter-rouge">extends</code>通配符，并由编译器强制检查来实现的。</p><h3 id="使用super在类限定t类型">使用super在类限定T类型</h3><p>前面说了可以使用<code class="language-plaintext highlighter-rouge">extends</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div><p>将T限制为<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的子类。</p><p>那么有没有<code class="language-plaintext highlighter-rouge">super</code>通配符来限定<code class="language-plaintext highlighter-rouge">T</code>的类型呢?我想到这样的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">super</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>  <span class="o">}</span>
</code></pre></div></div><p>将T限制为<code class="language-plaintext highlighter-rouge">Number</code>类型或<code class="language-plaintext highlighter-rouge">Number</code>的父类。</p><p><strong>不，java中没有实现在类中对下界进行限定</strong>。</p><h3 id="无限定通配符">无限定通配符</h3><p>Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code class="language-plaintext highlighter-rouge">?</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sample</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div><p>因为<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符既没有<code class="language-plaintext highlighter-rouge">extends</code>，也没有<code class="language-plaintext highlighter-rouge">super</code>，因此：</p><ul><li>不允许调用<code class="language-plaintext highlighter-rouge">set(T)</code>方法并传入引用（<code class="language-plaintext highlighter-rouge">null</code>除外）；</li><li>不允许调用<code class="language-plaintext highlighter-rouge">T get()</code>方法并获取<code class="language-plaintext highlighter-rouge">T</code>引用（只能获取<code class="language-plaintext highlighter-rouge">Object</code>引用）。</li></ul><p>也就是说：<font color="red"><b>`&lt;?&gt;`传参类型随便，只能写`null`(因为无上界)，读只能`Object`(因为无下界)。</b></font></p><p>换句话说，既不能读，也不能写，那只能做一些<code class="language-plaintext highlighter-rouge">null</code>判断：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">isNull</span><span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">p</span><span class="o">.</span><span class="na">getLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符有一个独特的特点，就是：<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>是所有<code class="language-plaintext highlighter-rouge">Pair&lt;T&gt;</code>的超类(抢了OBject的工作)：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;&gt;(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
        <span class="nc">Pair</span><span class="o">&lt;?&gt;</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span> <span class="c1">// 安全地向上转型</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p2</span><span class="o">.</span><span class="na">getFirst</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">p2</span><span class="o">.</span><span class="na">getLast</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述代码是可以正常编译运行的，因为<code class="language-plaintext highlighter-rouge">Pair&lt;Integer&gt;</code>是<code class="language-plaintext highlighter-rouge">Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p><p><strong>实际上<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</strong></p><p>那么有没有一个等同于<code class="language-plaintext highlighter-rouge">&lt;? super 最下子类</code>&gt;答案是没有的，因为这个最下子类并不是一个具体的东西，如果有，那么他也可以匹配任何类型，只能写null和最下子类，只能用Object读。功能基本和<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>重复了</p><h3 id="void">Void</h3><p>在泛型中，<code class="language-plaintext highlighter-rouge">Void</code> 是一个表示“无”或“空”的特殊类型。它类似于 <code class="language-plaintext highlighter-rouge">void</code> 关键字，但 <code class="language-plaintext highlighter-rouge">void</code> 只能用于方法的返回类型，而 <code class="language-plaintext highlighter-rouge">Void</code> 可以在泛型中使用，表示一个没有具体值的占位符。 <code class="language-plaintext highlighter-rouge">Void</code> 类是 Java 中的一个特殊类，位于 <code class="language-plaintext highlighter-rouge">java.lang</code> 包中。它的定义非常简单，如下所示：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Void</span> <span class="o">{</span>
    <span class="c1">// private构造方法，防止实例化</span>
    <span class="kd">private</span> <span class="nf">Void</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><p>可以看到，<code class="language-plaintext highlighter-rouge">Void</code> 类是一个 <code class="language-plaintext highlighter-rouge">final</code> 类，它有一个私有的无参构造方法，这意味着无法实例化 <code class="language-plaintext highlighter-rouge">Void</code> 类。实际上，<code class="language-plaintext highlighter-rouge">Void</code> 类没有任何实质性的内容，它只是作为一个标记类存在，用于表示没有具体值的情况。</p><p>在泛型中，<code class="language-plaintext highlighter-rouge">Void</code> 类通常用作一个占位符，用于表示不返回任何值的情况。例如，<code class="language-plaintext highlighter-rouge">CompletableFuture&lt;Void&gt;</code> 表示一个 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>，该 <code class="language-plaintext highlighter-rouge">CompletableFuture</code> 表示一个异步操作的完成状态，但不提供任何实际的结果。</p><p>总的来说，<code class="language-plaintext highlighter-rouge">Void</code> 类在 Java 中起着表示“无”或“空”的作用，用于表示不需要具体值的情况。</p><h1 id="总结">总结</h1><h2 id="说明">说明</h2><p>泛型的继承关系<strong>可以</strong>把类向上转型，而泛型参数<strong>不能产生变化</strong>。</p><p>如果实例化时<strong>不定义泛型类型参数</strong>时，那么默认会使用<code class="language-plaintext highlighter-rouge">Object</code>作为泛型类型参数。</p><p>编译器如果能自动推断出泛型类型，可以省略定义后面的泛型类型。</p><h2 id="定义">定义</h2><p>定义泛型类时，在类名后面定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，定义泛型方法时，在<strong>返回类型前面</strong>定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p><p>泛型类定义的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><strong>只能用于整个类的实例</strong>，而不能用于类的静态成员（静态字段、静态方法、静态内部类）。</p><p>泛型方法定义的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code><strong>只适用于该方法</strong>，在泛型类中的方法仍然可以设置为泛型方法，也可以使用泛型类的标识符。</p><p>如果泛型类是<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，泛型方法也是<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>，这两个<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>是不同的，在泛型方法中会隐藏泛型类的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。<strong>不建议这么做</strong>，因为这样也很容易让人误解。<strong>更不建议将</strong><code class="language-plaintext highlighter-rouge">T</code>写成<code class="language-plaintext highlighter-rouge">Stirng</code>之类的，别人看了会打人，而且同样会隐藏<code class="language-plaintext highlighter-rouge">Stirng</code>，从而导致你要通过<code class="language-plaintext highlighter-rouge">java.lang.String</code>使用<code class="language-plaintext highlighter-rouge">String</code>。</p><p>泛型类的<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>不能用于静态方法。静态方法同样可以变成泛型方法，使用同样的方法，在<strong>返回类型前面</strong>定义<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p><p>泛型还可以定义多种类型。如类型<code class="language-plaintext highlighter-rouge">&lt;T, K&gt;</code>，Java标准库的<code class="language-plaintext highlighter-rouge">Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。</p><h2 id="擦拭法-1">擦拭法</h2><p>擦拭法决定了泛型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>：</p><ul><li>不能是基本类型，例如：<code class="language-plaintext highlighter-rouge">int</code>；</li><li>不能获取带泛型类型的<code class="language-plaintext highlighter-rouge">Class</code>，例如：<code class="language-plaintext highlighter-rouge">Pair&lt;String&gt;.class</code>；</li><li>不能判断带泛型类型的类型，例如：<code class="language-plaintext highlighter-rouge">x instanceof Pair&lt;String&gt;</code>；</li><li>不能实例化<code class="language-plaintext highlighter-rouge">T</code>类型，例如：<code class="language-plaintext highlighter-rouge">new T()</code>。</li></ul><p>泛型方法要防止重复定义方法，例如：<code class="language-plaintext highlighter-rouge">public boolean equals(T obj)</code>。</p><p>一个类可以继承自一个泛型类，子类可以获取父类的泛型类型<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>。</p><h2 id="extendssuper">extends、super、？</h2><p>作为方法参数，<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>类型、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>类型和<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>的区别在于：</p><ul><li> <font color="red"><b>`&lt;? extends T&gt;`：传参类型&lt;=`T`，只能写`null`，读&gt;=`T`。</b></font></li><li> <font color="red"><b>`&lt;? super T&gt;`： 传参类型&gt;=`T`，写&lt;=`T`，读只能`Object`。</b></font></li><li> <font color="red"><b>`&lt;?&gt;`传参类型随便，只能写`null`(因为无上界)，读只能`Object`(因为无下界)。</b></font></li></ul><p><code class="language-plaintext highlighter-rouge">&lt;?&gt;</code> 等同于 <code class="language-plaintext highlighter-rouge">&lt;? extends Object&gt;</code>，表示未知类型的通配符，表示可以匹配任何类型。</p><p>大多数情况下，可以引入泛型参数<code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>消除<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>通配符。</p><p><strong>不在方法参数也能用<code class="language-plaintext highlighter-rouge">&lt;? extends T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;? super T&gt;</code>、<code class="language-plaintext highlighter-rouge">&lt;?&gt;</code>。</strong></p><p>用<code class="language-plaintext highlighter-rouge">&lt;T extends Number&gt;</code>定义<strong>泛型类</strong>时表示<strong>使用时泛型类型限定为<code class="language-plaintext highlighter-rouge">Number</code>以及<code class="language-plaintext highlighter-rouge">Number</code>的子类。(泛型类型&lt;=上界)</strong></p><p><code class="language-plaintext highlighter-rouge">Myclass&lt;Void&gt;</code>,表示泛型参数为空。</p><p>其实就是因为java<strong>向上提升安全，而向下转型不安全</strong>。</p><h1 id="泛型和反射">泛型和反射</h1><p>Java的部分反射API也是泛型。例如：<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>就是泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile warning:</span>
<span class="nc">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
<span class="c1">// no warning:</span>
<span class="nc">Class</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</code></pre></div></div><p>调用<code class="language-plaintext highlighter-rouge">Class</code>的<code class="language-plaintext highlighter-rouge">getSuperclass()</code>方法返回的<code class="language-plaintext highlighter-rouge">Class</code>类型是<code class="language-plaintext highlighter-rouge">Class&lt;? super T&gt;</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">sup</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getSuperclass</span><span class="o">();</span>
</code></pre></div></div><p>构造方法<code class="language-plaintext highlighter-rouge">Constructor&lt;T&gt;</code>也是泛型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">clazz</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
<span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">i</span> <span class="o">=</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="mi">123</span><span class="o">);</span>
</code></pre></div></div><h3 id="泛型数组">泛型数组</h3><p>我们可以声明带泛型的数组，但不能用<code class="language-plaintext highlighter-rouge">new</code>操作符创建带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// ok</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// compile error!</span>
</code></pre></div></div><p>必须通过强制转型实现带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div><p>使用泛型数组要特别小心，因为数组实际上在运行期<strong>没有</strong>泛型，编译器可以强制检查变量<code class="language-plaintext highlighter-rouge">ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code class="language-plaintext highlighter-rouge">arr</code>，因为它<strong>不是</strong>泛型数组。因为这两个变量实际上指向<strong>同一个</strong>数组，所以，操作<code class="language-plaintext highlighter-rouge">arr</code>可能导致从<code class="language-plaintext highlighter-rouge">ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span><span class="c1">//指向了不是String的内容</span>
<span class="c1">// ClassCastException:</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span><span class="c1">//类型转换错误</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">getFirst</span><span class="o">();</span>
</code></pre></div></div><p>要安全地使用泛型数组，必须扔掉<code class="language-plaintext highlighter-rouge">arr</code>的引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
</code></pre></div></div><p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code class="language-plaintext highlighter-rouge">ps</code>进行操作，这种操作就是安全的。</p><p>带泛型的数组实际上是编译器的类型擦除：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
<span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span> <span class="n">arr</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
<span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
</code></pre></div></div><p>所以我们<strong>不能</strong>直接创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>，因为擦拭后代码变为<code class="language-plaintext highlighter-rouge">Object[]</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// compile error:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>显然编译器要阻止这种类型不对的代码，为了防止可能的错误出现编译器直接一刀切这个操作。</p><p>而且在泛型中这种写法可能会造成尝试去<code class="language-plaintext highlighter-rouge">new</code>一个不能直接实例化的<code class="language-plaintext highlighter-rouge">Type</code>，比如当我们这么写传入了抽象类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[]</span> <span class="n">pair</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Abc</span><span class="o">&lt;</span><span class="nc">Number</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Abc</span><span class="o">().</span><span class="na">createArray</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Abc</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="no">T</span><span class="o">[</span><span class="mi">5</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上面的<code class="language-plaintext highlighter-rouge">Number</code>是不能直接实例化的，所以编译器要阻止这种行为。</p><p><strong>必须</strong>借助<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code>来创建泛型数组：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">().</span><span class="na">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ps</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Pair</span><span class="o">[].</span><span class="na">class</span><span class="o">);</span> <span class="c1">// true</span>
        <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">ps</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">getFirst</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">first</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">T</span> <span class="n">last</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Pair</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">,</span> <span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">first</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="no">T</span> <span class="n">first</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">first</span> <span class="o">=</span> <span class="n">first</span><span class="o">;</span> <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="no">T</span> <span class="n">last</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">;</span> <span class="o">}</span> 
    <span class="no">T</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>泛型方法写法，<code class="language-plaintext highlighter-rouge">&lt;Pair&gt;</code>可省略：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="nc">Pair</span><span class="o">().&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span><span class="n">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">K</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>静态泛型方法写法，<code class="language-plaintext highlighter-rouge">&lt;Pair&gt;</code>可省略：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[]</span> <span class="n">ps</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;[])</span><span class="nc">Pair</span><span class="o">.&lt;</span><span class="nc">Pair</span><span class="o">&gt;</span><span class="n">createArray</span><span class="o">(</span><span class="nc">Pair</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">createArray</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="no">K</span><span class="o">&gt;</span> <span class="n">cls</span><span class="o">,</span><span class="kt">int</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="no">K</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">cls</span><span class="o">,</span> <span class="n">len</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="谨慎使用泛型可变参数">谨慎使用泛型可变参数</h3><p>还可以利用<strong>可变参数</strong>创建泛型数组<code class="language-plaintext highlighter-rouge">T[]</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArrayHelper</span> <span class="o">{</span>
    <span class="nd">@SafeVarargs</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
<span class="nc">Integer</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="nc">ArrayHelper</span><span class="o">.</span><span class="na">asArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</code></pre></div></div><p>在上面的例子中，我们看到，通过：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>似乎</strong>可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>直接调用<code class="language-plaintext highlighter-rouge">asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code class="language-plaintext highlighter-rouge">ClassCastException</code>，原因还是因为擦拭法，在<code class="language-plaintext highlighter-rouge">pickTwo()</code>方法内部，编译器无法检测<code class="language-plaintext highlighter-rouge">K[]</code>的正确类型，因此返回了<code class="language-plaintext highlighter-rouge">Object[]</code>。</p><p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code class="language-plaintext highlighter-rouge">@SafeVarargs</code>消除警告。</p><p>如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p><p>更详细的解释请参考《<a href="https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p><p>泛型是通过类型擦除来实现的，而可变参数<strong>只是</strong>一个传递数组变量的语法糖，本质上还是<strong>创建</strong>一个数组然后传入。</p><p>所以泛型可变参数实际上就是 <code class="language-plaintext highlighter-rouge">Object</code> 数组，这样代码就可以等价为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">ss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">};</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span> <span class="n">asArray</span><span class="o">(</span><span class="n">ss</span><span class="o">);</span> <span class="c1">// asArray 返回的就是 ss 只不过声明为 Object[]，实际上还是 String[],子类赋值给父类,然后转回子类</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="c1">// ClassCastException:</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span> <span class="c1">// pickTwo 返回的是一个新创建的 Object[]，只不过里面的元素实际上是字符串</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">k1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k2</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">objs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[]{</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">};</span><span class="c1">//语法糖</span>
        <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">objs</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * asArray 本质上没有做任何处理，只是把传入的数据返回了而已。
     */</span>
    <span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p>以下是用jad反编译的，jad反编译后的是被擦拭后的，而使用cfr、jdgui反编译都是接近于源码的便于阅读的。(<a href="http://java-decompiler.github.io/">jd-gui工具</a>，<a href="https://github.com/iloveeclipse/plugins">Bytecode Outline</a>插件，不但可以看字节码，还可以看如何生成字节码。）</p><p>反编译后的代码中出现的<code class="language-plaintext highlighter-rouge">transient</code>关键字，这是由于反编译工具对代码进行了简化和优化。transient关键字通常用于修饰成员变量，表示这些变量不会被序列化，与我们讨论的问题无关。</p><p>源代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">toS2</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">toS</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    
    <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="c1">// ClassCastException:</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span><span class="o">...</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">toS</span><span class="o">(</span><span class="no">T</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">toS2</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">toS2</span><span class="o">(</span><span class="no">T</span> <span class="n">objs</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>反编译后：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"123"</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">toS2</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">toS</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">arr</span><span class="o">[]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span><span class="n">asArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span>
        <span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span>
    <span class="o">});</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
    <span class="nc">String</span> <span class="n">firstTwo</span><span class="o">[]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span><span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="nc">Object</span> <span class="n">k1</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k2</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">k3</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">asArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Object</span><span class="o">[]</span> <span class="o">{</span>
        <span class="n">k1</span><span class="o">,</span> <span class="n">k2</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kd">transient</span> <span class="nc">Object</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="nc">Object</span> <span class="n">objs</span><span class="o">[])</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">toS</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="nf">toS2</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Object</span> <span class="nf">toS2</span><span class="o">(</span><span class="nc">Object</span> <span class="n">objs</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">objs</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>可变参数的方法，实际接收的是一个数组</strong>，所以调用可变参数的方法时，会把参数封装成一个数组。如果在泛型方法里，调用泛型可变参数的方法，那么入参会被擦拭成<code class="language-plaintext highlighter-rouge">Object</code>数组。</p><p>报错解释：<code class="language-plaintext highlighter-rouge">main</code>直接调用<code class="language-plaintext highlighter-rouge">asArray</code>时，编译器知道<code class="language-plaintext highlighter-rouge">asArray</code>的入参是<code class="language-plaintext highlighter-rouge">String</code>，但是在调用<code class="language-plaintext highlighter-rouge">pickTwo</code>中编译器不知道<code class="language-plaintext highlighter-rouge">K</code>的类型将会是什么，所以调用<code class="language-plaintext highlighter-rouge">asArray</code>时入参封装（擦拭）成了<code class="language-plaintext highlighter-rouge">Object[]</code>，main中得到返回值强转为<code class="language-plaintext highlighter-rouge">String[]</code>时，就会报错。而在<code class="language-plaintext highlighter-rouge">toS</code>、<code class="language-plaintext highlighter-rouge">toS2</code>中尽管也会被擦拭成<code class="language-plaintext highlighter-rouge">Object</code>，但只是用<code class="language-plaintext highlighter-rouge">Object</code>持有对象引用，对象类型并没有改变，所以在<code class="language-plaintext highlighter-rouge">main</code>中强转时不会报错。</p><p>可变参数改成反射则没有问题：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.lang.reflect.Array</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">asArray</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">firstTwo</span> <span class="o">=</span> <span class="n">pickTwo</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">firstTwo</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">K</span><span class="o">&gt;</span> <span class="no">K</span><span class="o">[]</span> <span class="nf">pickTwo</span><span class="o">(</span><span class="no">K</span> <span class="n">k1</span><span class="o">,</span> <span class="no">K</span> <span class="n">k2</span><span class="o">,</span> <span class="no">K</span> <span class="n">k3</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">K</span><span class="o">[]</span> <span class="n">ks</span><span class="o">=</span><span class="n">asArray</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span> <span class="n">k2</span><span class="o">,</span><span class="n">k3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pickTwo:"</span><span class="o">+</span><span class="n">ks</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ks</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span><span class="o">[]</span> <span class="nf">asArray</span><span class="o">(</span><span class="no">T</span> <span class="n">t1</span><span class="o">,</span><span class="no">T</span> <span class="n">t2</span><span class="o">,</span><span class="no">T</span> <span class="n">t3</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"asArray:"</span><span class="o">+</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="no">T</span><span class="o">[]</span> <span class="n">ts</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">[])</span> <span class="nc">Array</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">getClass</span><span class="o">(),</span> <span class="mi">3</span><span class="o">);</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">t1</span><span class="o">;</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="n">t2</span><span class="o">;</span>
        <span class="n">ts</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="n">t3</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ts</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">ts</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/03/21/%E6%B3%9B%E5%9E%8B/" target="_blank">https://acteds.github.io/2024/03/21/%E6%B3%9B%E5%9E%8B/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1721396085', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
