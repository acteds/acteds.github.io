<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Seata分布式事务 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/09/21/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="Seata分布式事务"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。"><meta name="og:description" content="引言Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。"><meta property="og:url" content="/2024/09/21/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-09-21"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Seata分布式事务"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Seata分布式事务</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/09/21 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 19077 字，约 55 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><p>官方网站：<a href="https://seata.apache.org/zh-cn/">Apache Seata</a>，Demo1：<a href="https://github.com/apache/incubator-seata-samples/tree/master">apache/incubator-seata-sample</a>，Demo2：<a href="https://github.com/Kerry2019/seata-tcc-demo">Kerry2019/seata-tcc-demo</a>，扩展：<a href="https://seata.apache.org/zh-cn/docs/user/appendix/global-transaction-status">事务状态</a>，<a href="https://seata.apache.org/zh-cn/docs/user/appendix/isolation">事务隔离</a>。。</p><h1 id="seata">Seata</h1><h2 id="seata-tcc-模式">Seata TCC 模式</h2><h3 id="准备环境">准备环境</h3><p>首先下载Seata：<a href="https://seata.apache.org/zh-cn/unversioned/download/seata-server/">Seata Java Download Apache Seata</a>，选择二进制版本。</p><p>修改<code class="language-plaintext highlighter-rouge">conf\application.yml</code>，注册到consul，并使用mysql做为存储方式：</p><div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Seata 服务器配置</span>
<span class="na">server</span><span class="pi">:</span>
  <span class="na">port</span><span class="pi">:</span> <span class="m">7091</span>  <span class="c1"># 设置 Seata 服务器的端口为 7091</span>

<span class="c1"># Spring 应用配置</span>
<span class="na">spring</span><span class="pi">:</span>
  <span class="na">application</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">seata-server</span>  <span class="c1"># 设置 Spring 应用的名称为 seata-server</span>

<span class="c1"># 日志配置</span>
<span class="na">logging</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span> <span class="s">classpath:logback-spring.xml</span>  <span class="c1"># 指定 Logback 的配置文件路径</span>
  <span class="na">file</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">${log.home:${user.home}/logs/seata}</span>  <span class="c1"># 指定日志文件的保存路径</span>
  <span class="na">extend</span><span class="pi">:</span>
    <span class="na">logstash-appender</span><span class="pi">:</span>
      <span class="na">destination</span><span class="pi">:</span> <span class="s">127.0.0.1:4560</span>  <span class="c1"># 将日志发送到 Logstash 的地址</span>
    <span class="na">kafka-appender</span><span class="pi">:</span>
      <span class="na">bootstrap-servers</span><span class="pi">:</span> <span class="s">127.0.0.1:9092</span>  <span class="c1"># Kafka 服务器的地址</span>
      <span class="na">topic</span><span class="pi">:</span> <span class="s">logback_to_logstash</span>  <span class="c1"># Kafka 日志主题</span>

<span class="c1"># 控制台用户配置</span>
<span class="na">console</span><span class="pi">:</span>
  <span class="na">user</span><span class="pi">:</span>
    <span class="na">username</span><span class="pi">:</span> <span class="s">seata</span>  <span class="c1"># 控制台用户名</span>
    <span class="na">password</span><span class="pi">:</span> <span class="s">seata</span>  <span class="c1"># 控制台密码</span>

<span class="c1"># Seata 配置</span>
<span class="na">seata</span><span class="pi">:</span>
  <span class="na">config</span><span class="pi">:</span>
    <span class="c1"># support: nacos, consul, apollo, zk, etcd3, file</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">file</span> <span class="c1"># 配置 Seata 的配置方式为文件模式</span>
  <span class="na">registry</span><span class="pi">:</span>
    <span class="c1"># support: nacos, eureka, redis, zk, consul, etcd3, sofa</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">consul</span> <span class="c1"># 使用 Consul 作为注册中心</span>
    <span class="na">consul</span><span class="pi">:</span>
      <span class="na">application</span><span class="pi">:</span> <span class="s">seata-server</span>  <span class="c1"># 在 Consul 中注册的服务名称</span>
      <span class="na">server-addr</span><span class="pi">:</span> <span class="s">127.0.0.1:8500</span>  <span class="c1"># Consul 服务器的地址</span>
      <span class="na">acl-token</span><span class="pi">:</span>  <span class="c1"># ACL token，用于 Consul（如果需要，可以设置为空）</span>
      <span class="na">cluster</span><span class="pi">:</span> <span class="s">seata1</span>  <span class="c1"># Consul 集群的名称,即控制中心出现的服务的名称</span>
  <span class="na">store</span><span class="pi">:</span>
    <span class="c1"># support: file 、 db 、 redis 、 raft</span>
    <span class="na">mode</span><span class="pi">:</span> <span class="s">db</span> <span class="c1"># 配置 Seata 的存储方式为数据库模式</span>
    <span class="na">db</span><span class="pi">:</span>
      <span class="na">datasource</span><span class="pi">:</span> <span class="s">druid</span> <span class="c1"># 使用 Druid 作为数据源</span>
      <span class="na">db-type</span><span class="pi">:</span> <span class="s">mysql</span> <span class="c1"># 数据库类型为 MySQL</span>
      <span class="na">driver-class-name</span><span class="pi">:</span> <span class="s">com.mysql.cj.jdbc.Driver</span> <span class="c1"># 数据库驱动类名</span>
      <span class="na">url</span><span class="pi">:</span> <span class="s">jdbc:mysql://127.0.0.1:3306/seata?rewriteBatchedStatements=true</span> <span class="c1"># 数据库连接 URL</span>
      <span class="na">user</span><span class="pi">:</span> <span class="s">root</span> <span class="c1"># 数据库用户名</span>
      <span class="na">password</span><span class="pi">:</span> <span class="s">root</span> <span class="c1"># 数据库密码</span>

  <span class="na">security</span><span class="pi">:</span>
    <span class="na">secretKey</span><span class="pi">:</span> <span class="s">SeataSecretKey0c382ef121d778043159209298fd40bf3850a017</span> <span class="c1"># 安全密钥</span>
    <span class="na">tokenValidityInMilliseconds</span><span class="pi">:</span> <span class="m">1800000</span> <span class="c1"># Token 的有效时间（30 分钟）</span>
    <span class="na">ignore</span><span class="pi">:</span>
      <span class="c1"># 指定不需要进行安全检查的 URL 路径</span>
      <span class="na">urls</span><span class="pi">:</span> <span class="s">/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.jpeg,/**/*.ico,/api/v1/auth/login,/version.json,/health,/error</span>
</code></pre></div></div><p>mysql新建数据库<code class="language-plaintext highlighter-rouge">seata</code>，并运行：<code class="language-plaintext highlighter-rouge">script\server\db\mysql.sql</code>，初始化表。（也可以使用<code class="language-plaintext highlighter-rouge">file</code> 模式）</p><p>然后先启动consul，再启动seata，可以访问<code class="language-plaintext highlighter-rouge">http://127.0.0.1:7091/</code>，进入后台，账号密码在上面的配置文件中，即<code class="language-plaintext highlighter-rouge">seata</code>。</p><p>客户端配置：</p><p>首先consul要注册上：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.cloud<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-cloud-starter-consul-discovery<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">application.yml</code>:</p><div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">application</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">demo-service</span>
  <span class="na">cloud</span><span class="pi">:</span>
    <span class="na">consul</span><span class="pi">:</span>
      <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
      <span class="na">host</span><span class="pi">:</span> <span class="s">localhost</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">8500</span>
      <span class="na">discovery</span><span class="pi">:</span>
        <span class="na">service-name</span><span class="pi">:</span> <span class="s">demo-service</span>
        <span class="na">health-check</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">/actuator/health</span>
          <span class="na">interval</span><span class="pi">:</span> <span class="s">30s</span>

<span class="na">management</span><span class="pi">:</span>
  <span class="na">endpoints</span><span class="pi">:</span>
    <span class="na">web</span><span class="pi">:</span>
      <span class="na">exposure</span><span class="pi">:</span>
        <span class="na">include</span><span class="pi">:</span> <span class="s">health,info</span>
</code></pre></div></div><p>然后配置seata：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/io.seata/seata-spring-boot-starter --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>io.seata<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>seata-spring-boot-starter<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>2.0.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">application.yml</code>:</p><div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">seata</span><span class="pi">:</span>
  <span class="na">registry</span><span class="pi">:</span>
    <span class="na">consul</span><span class="pi">:</span>
      <span class="c1"># Consul 服务器的地址和端口</span>
      <span class="na">server-addr</span><span class="pi">:</span> <span class="s">127.0.0.1:8500</span>
      <span class="c1"># ACL token 用于访问 Consul。如果 Consul 配置了 ACL，需提供相应的 token。可以为空或省略。</span>
      <span class="na">acl-token</span><span class="pi">:</span>
      <span class="c1"># Consul 集群的名称。可以根据实际情况修改为相应的集群名称。</span>
      <span class="na">cluster</span><span class="pi">:</span> <span class="s">seata1</span>
    <span class="c1"># 注册中心类型，这里设置为 Consul</span>
    <span class="na">type</span><span class="pi">:</span> <span class="s">consul</span>

  <span class="c1"># 事务服务组的名称。这个配置用于指定事务服务组，Seata 将使用该组处理分布式事务。</span>
  <span class="c1"># 1.4.2 版本的默认事务分组名称为 `my_test_tx_group`，1.5 版本将改为 `default_tx_group`。</span>
  <span class="na">tx-service-group</span><span class="pi">:</span> <span class="s">default_tx_group</span>

  <span class="na">service</span><span class="pi">:</span>
    <span class="c1"># 事务分组与服务集群的映射关系</span>
    <span class="na">vgroup-mapping</span><span class="pi">:</span>
      <span class="c1"># 事务分组名称与服务集群名称的映射</span>
      <span class="c1"># 这里将 `default_tx_group` 映射到 `seata1` 服务集群</span>
      <span class="na">default_tx_group</span><span class="pi">:</span> <span class="s">seata1</span>

    <span class="c1"># 默认的服务集群配置</span>
    <span class="na">default</span><span class="pi">:</span>
      <span class="c1"># 服务集群列表。在此配置中，指定 `grouplist` 为 `consul`，表明 Seata 将使用 Consul 作为服务发现机制</span>
      <span class="na">grouplist</span><span class="pi">:</span> <span class="s">consul</span>
</code></pre></div></div><h3 id="tcc接口示例">TCC接口示例</h3><p>TCC 模式（Try-Confirm-Cancel）是一种确保分布式系统中事务一致性的方法，分为三个步骤：</p><ol><li>Try：尝试执行某个操作，预留资源，确保所有操作能够成功执行，<strong>不实际执行操作，如果异常，必须能被Cancel阶段完全回滚</strong>。</li><li>Confirm：所有操作成功执行后，提交资源的最终变更，<strong>实际执行操作</strong>。</li><li>Cancel：如果操作失败，撤销预留的资源，回滚操作，<strong>注意：需要手动写代码还原状态</strong>。</li></ol><p>TCC模式确保了分布式事务的最终一致性，且通过 TCC 模式能减少锁竞争，提高性能。</p><p><strong>注意事项</strong></p><ul><li>业务操作应确保幂等性，以防止重复操作。</li><li><code class="language-plaintext highlighter-rouge">Try</code> 阶段通常是“冻结资源”，而 <code class="language-plaintext highlighter-rouge">Confirm</code> 阶段是“实际扣减资源”。</li></ul><p>一个可能需要回滚，且是分布式调用的接口，现在需要<strong>拆分为3个方法</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@LocalTCC</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderServiceImpl</span> <span class="kd">implements</span> <span class="nc">OrderService</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="nd">@TwoPhaseBusinessAction</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"prepareCreateOrder"</span><span class="o">,</span> <span class="n">commitMethod</span> <span class="o">=</span> <span class="s">"commit"</span><span class="o">,</span> <span class="n">rollbackMethod</span> <span class="o">=</span> <span class="s">"rollback"</span><span class="o">)</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">prepareCreateOrder</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">productId</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Try 阶段：创建订单</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setUserId</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setProductId</span><span class="o">(</span><span class="n">productId</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="s">"PENDING"</span><span class="o">);</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>

        <span class="n">actionContext</span><span class="o">.</span><span class="na">addActionContext</span><span class="o">(</span><span class="s">"orderId"</span><span class="o">,</span> <span class="n">order</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">commit</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Confirm 阶段：确认订单</span>
        <span class="nc">Long</span> <span class="n">orderId</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">actionContext</span><span class="o">.</span><span class="na">getActionContext</span><span class="o">(</span><span class="s">"orderId"</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">();</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="s">"CONFIRMED"</span><span class="o">);</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">rollback</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Cancel 阶段：取消订单</span>
        <span class="nc">Long</span> <span class="n">orderId</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">actionContext</span><span class="o">.</span><span class="na">getActionContext</span><span class="o">(</span><span class="s">"orderId"</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">).</span><span class="na">orElseThrow</span><span class="o">();</span>
        <span class="n">order</span><span class="o">.</span><span class="na">setStatus</span><span class="o">(</span><span class="s">"CANCELLED"</span><span class="o">);</span>
        <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p><strong>以上即是对单一接口需要使用seata TCC模式的一个前提。运行流程</strong>：</p><ol><li><strong>Try 阶段</strong>：在 <code class="language-plaintext highlighter-rouge">prepareCreateOrder</code> 方法中，会创建“未确认”的订单。</li><li><strong>Confirm 阶段</strong>：如果整个事务正常执行，在 <code class="language-plaintext highlighter-rouge">commit</code> 方法中会<strong>确认订单状态</strong>。</li><li><strong>Cancel 阶段</strong>：如果事务过程中出错，<code class="language-plaintext highlighter-rouge">rollback</code> 方法会<strong>取消订单</strong>。</li></ol><hr /><p>以下是对它们的具体解释和关系：</p><p><strong>Try 阶段（<code class="language-plaintext highlighter-rouge">prepareCreateOrder</code>）</strong>：</p><ul><li>检查业务资源是否满足执行条件（例如：检查库存是否足够）。预留或冻结资源，使得资源在本次操作中不可用（例如：检查库存是否足够、创建一个“待确认”的订单）。</li><li>还可以记录一些重要的上下文信息（例如订单 ID），以便在后续的 <code class="language-plaintext highlighter-rouge">commit</code> 或 <code class="language-plaintext highlighter-rouge">rollback</code> 阶段使用。</li><li>这个阶段的操作<strong>必须是可补偿的</strong>（即可以撤销的）。</li><li>如果这个阶段失败，整个事务将被终止，不会继续执行 <code class="language-plaintext highlighter-rouge">commit</code> 或 <code class="language-plaintext highlighter-rouge">rollback</code>。</li><li>如果在这个阶段出现异常抛出，则会进入<code class="language-plaintext highlighter-rouge">rollback</code>阶段。</li></ul><p>在上面的示例， <code class="language-plaintext highlighter-rouge">prepareCreateOrder</code> 方法中，订单服务会创建一个“待确认”的订单，其状态通常是 <code class="language-plaintext highlighter-rouge">PENDING</code> 或类似状态。</p><p>这个订单还没有被正式确认，这样做的目的是为订单创建过程预留一个位置，防止后续操作影响该资源。</p><p><strong>Confirm 阶段（<code class="language-plaintext highlighter-rouge">commit</code>）：</strong></p><ul><li>当整个事务的所有 Try 阶段操作都成功时，Seata 将进入 <code class="language-plaintext highlighter-rouge">commit</code> 阶段。</li><li>这个阶段正式确认事务操作，即最终提交资源变更（例如：实际扣减库存、确认订单，如将订单状态从 <code class="language-plaintext highlighter-rouge">PENDING</code> 改为 <code class="language-plaintext highlighter-rouge">CONFIRMED</code>），完成资源的最终变更。</li><li><strong>注意</strong>：Confirm 操作必须保证最终一致性。它<strong>不应出现失败</strong>，因为这会影响事务的一致性。</li><li>一旦进入 Confirm 阶段，意味着事务已经被提交，后续<strong>不能再回滚</strong>。</li></ul><p>在上面的示例，在 <code class="language-plaintext highlighter-rouge">commit</code> 方法中，将订单状态从 <code class="language-plaintext highlighter-rouge">PENDING</code> 更改为 <code class="language-plaintext highlighter-rouge">CONFIRMED</code>，表示订单已经正式生成。此时，订单信息已经固定下来，任何异常情况下都不应再取消订单。</p><p><strong>Cancel 阶段（<code class="language-plaintext highlighter-rouge">rollback</code>）：</strong></p><ul><li>如果 Try 阶段执行失败或在业务中途发生了异常，Seata 会自动调用 <code class="language-plaintext highlighter-rouge">rollback</code> 方法来撤销所有已做的操作。</li><li><strong>撤销 Try 阶段的操作</strong>，回滚已做的变更（例如：释放预扣库存、取消订单）。</li><li>Rollback 需要保证事务的可补偿性，即<strong>能撤销所有在 Try 阶段完成的操作</strong>（例如，如果库存扣减操作成功，但确认阶段失败，你需要恢复库存）。</li></ul><p>在上面的示例，在 <code class="language-plaintext highlighter-rouge">rollback</code> 方法中，如果订单处于 <code class="language-plaintext highlighter-rouge">PENDING</code> 状态，则将其状态更改为 <code class="language-plaintext highlighter-rouge">CANCELLED</code>，表明订单被取消。这样，整个事务回滚了，订单不会被正式创建，用户也不会产生实际的购买行为。</p><h3 id="注解说明">注解说明</h3><p><strong><code class="language-plaintext highlighter-rouge">@TwoPhaseBusinessAction</code></strong></p><p><code class="language-plaintext highlighter-rouge">@TwoPhaseBusinessAction</code> 注解需要<strong>标记在 <code class="language-plaintext highlighter-rouge">try</code> 阶段的方法</strong>，用于指定 TCC 事务的提交和回滚方法。具体参数说明如下：</p><ul><li><code class="language-plaintext highlighter-rouge">name</code>: 事务的名称，用于标识这个 TCC 事务。</li><li><code class="language-plaintext highlighter-rouge">commitMethod</code>: 提交方法的名称。当事务被确认（Confirm）时调用。</li><li><code class="language-plaintext highlighter-rouge">rollbackMethod</code>: 回滚方法的名称。当事务被取消（Cancel）时调用。</li></ul><p>这些参数帮助 Seata 在事务的 Confirm 和 Cancel 阶段正确地调用相应的方法，确保分布式事务的正确性。</p><hr /><p><strong><code class="language-plaintext highlighter-rouge">@LocalTCC</code></strong></p><p><code class="language-plaintext highlighter-rouge">@LocalTCC</code> 注解用于标识一个实现了 TCC 模式的本地事务服务。它通常不需要参数，它的主要作用是标识类中哪些方法是需要支持 TCC 事务的。Seata 会扫描带有 <code class="language-plaintext highlighter-rouge">@LocalTCC</code> 注解的类，并自动将它们纳入 TCC 事务管理范围。</p><hr /><p><strong><code class="language-plaintext highlighter-rouge">@BusinessActionContextParameter</code></strong></p><p><code class="language-plaintext highlighter-rouge">@BusinessActionContextParameter</code> 是 Seata TCC 模式下用于标识在 TCC 事务的 <code class="language-plaintext highlighter-rouge">Try</code> 方法中需要传递到事务上下文中的参数的注解。这个注解可以帮助 Seata 将这些参数从 <code class="language-plaintext highlighter-rouge">Try</code> 阶段传递到 <code class="language-plaintext highlighter-rouge">Confirm</code> 和 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段。</p><p><strong>主要属性</strong></p><p><strong><code class="language-plaintext highlighter-rouge">value</code> / <code class="language-plaintext highlighter-rouge">paramName</code></strong>: 用于指定参数的名称，默认值为空字符串。<code class="language-plaintext highlighter-rouge">value</code> 和 <code class="language-plaintext highlighter-rouge">paramName</code> 是等效的，主要用于获取参数名称以在上下文中查找。</p><p><strong><code class="language-plaintext highlighter-rouge">isShardingParam</code></strong> (已废弃):表示是否是分片参数，但这个属性现在已经不再使用。</p><p><strong><code class="language-plaintext highlighter-rouge">index</code></strong>:用于指定参数在参数列表中的索引位置。此属性主要用于处理参数是以列表形式传递的情况。</p><p><strong><code class="language-plaintext highlighter-rouge">isParamInProperty</code></strong>:表示参数是否是对象的属性。如果 <code class="language-plaintext highlighter-rouge">index</code> 大于等于 0，这个属性指定是否需要从对象的属性中获取参数值。</p><p><strong>使用示例</strong></p><p>假设你有一个 <code class="language-plaintext highlighter-rouge">Try</code> 方法的签名如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">prepareDecreaseInventory</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">productId</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">count</span><span class="o">)</span>
</code></pre></div></div><p>可以使用 <code class="language-plaintext highlighter-rouge">@BusinessActionContextParameter</code> 注解来指定哪些参数需要传递到事务上下文中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="nd">@TwoPhaseBusinessAction</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"InventoryService"</span><span class="o">,</span> <span class="n">commitMethod</span> <span class="o">=</span> <span class="s">"commit"</span><span class="o">,</span> <span class="n">rollbackMethod</span> <span class="o">=</span> <span class="s">"rollback"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">prepareDecreaseInventory</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">,</span>
                                         <span class="nd">@BusinessActionContextParameter</span><span class="o">(</span><span class="n">paramName</span> <span class="o">=</span> <span class="s">"productId"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">productId</span><span class="o">,</span>
                                         <span class="nd">@BusinessActionContextParameter</span><span class="o">(</span><span class="n">paramName</span> <span class="o">=</span> <span class="s">"count"</span><span class="o">)</span> <span class="nc">Integer</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Try 阶段的逻辑</span>
<span class="o">}</span>
</code></pre></div></div><p>在这个例子中，<code class="language-plaintext highlighter-rouge">productId</code> 和 <code class="language-plaintext highlighter-rouge">count</code> 参数会被传递到 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 中，这样它们可以在 <code class="language-plaintext highlighter-rouge">commit</code> 和 <code class="language-plaintext highlighter-rouge">rollback</code> 方法中使用。</p><p><code class="language-plaintext highlighter-rouge">@BusinessActionContextParameter</code> 注解的作用类似于 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 的 <code class="language-plaintext highlighter-rouge">addActionContext</code> 方法。通过这个注解，可以在 <code class="language-plaintext highlighter-rouge">Try</code> 阶段自动将指定的参数添加到 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 中，而不需要手动调用 <code class="language-plaintext highlighter-rouge">addActionContext</code> 方法，Seata 会自动处理这些参数的传递和保存。</p><hr /><p><strong><code class="language-plaintext highlighter-rouge">@GlobalTransactional</code></strong></p><p><code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 是 Seata 提供的一个注解，用于标记一个全局事务的开始。它主要用于处理分布式事务的场景，将多个本地事务组合成一个全局事务。</p><p><strong>作用</strong></p><p><strong>开启全局事务</strong>: <code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 用于标记一个方法为全局事务的入口点。Seata 会为这个方法创建一个全局事务，并将方法内部调用的所有涉及的本地事务都纳入这个全局事务中。</p><p><strong>事务协调</strong>: 在方法执行过程中，Seata 会跟踪并协调这个全局事务中涉及的所有本地事务。如果方法执行成功，Seata 会提交全局事务；如果方法抛出异常，则会回滚全局事务，确保数据一致性。</p><p><strong>全局事务的传播</strong>: <code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 会将其内部的所有本地事务纳入一个全局事务中，从而实现事务的分布式管理和一致性。</p><p><code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 注解是 Seata 的核心注解之一，用于定义全局事务的行为和配置。它的参数允许你精确控制事务的超时、回滚策略、锁策略等。在配置分布式事务时，这些参数帮助确保事务的一致性和正确性。</p><p><strong>参数详解</strong></p><p><strong><code class="language-plaintext highlighter-rouge">timeoutMills</code></strong>:指定全局事务的超时时间（单位：毫秒）。如果全局事务在这个时间内没有完成，Seata 会<strong>强制回滚</strong>这个事务。默认值为<code class="language-plaintext highlighter-rouge">60000ms</code>。</p><p><strong><code class="language-plaintext highlighter-rouge">name</code></strong>:指定全局事务的名称。可以用来在日志和监控中识别这个全局事务。默认值: 空字符串。</p><p><strong><code class="language-plaintext highlighter-rouge">rollbackFor</code></strong>:指定<strong>需要回滚</strong>的异常类型。当方法执行过程中抛出这些异常时，全局事务会被回滚。默认值: 空数组。示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">rollbackFor</span> <span class="o">=</span> <span class="o">{</span><span class="nc">RuntimeException</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">rollbackForClassName</code></strong>:指定<strong>需要回滚</strong>的异常类名。与 <code class="language-plaintext highlighter-rouge">rollbackFor</code> 类似，但使用异常类名的字符串形式。默认值：空数组。示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">rollbackForClassName</span> <span class="o">=</span> <span class="o">{</span><span class="s">"java.lang.RuntimeException"</span><span class="o">})</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">noRollbackFor</code></strong>:指定不需要回滚的异常类型。当方法抛出这些异常时，全局事务<strong>不会回滚</strong>。默认值: 空数组。<strong>示例</strong>:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">noRollbackFor</span> <span class="o">=</span> <span class="o">{</span><span class="nc">IllegalArgumentException</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">noRollbackForClassName</code></strong>: 指定不需要回滚的异常类名。与 <code class="language-plaintext highlighter-rouge">noRollbackFor</code> 类似，但使用异常类名的字符串形式。默认值: 空数组，示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">noRollbackForClassName</span> <span class="o">=</span> <span class="o">{</span><span class="s">"java.lang.IllegalArgumentException"</span><span class="o">})</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">propagation</code></strong>:指定全局事务的传播行为。定义了事务的传播方式。默认值: <code class="language-plaintext highlighter-rouge">Propagation.REQUIRED</code>，即如果 transaction 存在，则使用当前事务执行，否则使用新事务执行。示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">lockRetryInterval</code></strong>:自定义全局锁的重试间隔时间（单位：毫秒）。用于覆盖全局配置中的锁重试间隔。默认值: 0，表示使用全局配置。示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">lockRetryInterval</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">)</span> 
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">lockRetryInternal</code></strong> (已过时):自定义全局锁的重试间隔时间（单位：毫秒）。与 <code class="language-plaintext highlighter-rouge">lockRetryInterval</code> 类似，但这个参数已经过时，不再推荐使用。默认值: 0，示例:</p><p><strong><code class="language-plaintext highlighter-rouge">lockRetryTimes</code></strong>:自定义全局锁的重试次数。用于覆盖全局配置中的锁重试次数。默认值: -1，表示使用全局配置，示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">lockRetryTimes</span> <span class="o">=</span> <span class="mi">5</span><span class="o">)</span> 
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">lockStrategyMode</code></strong>:指定锁的策略模式。可以选择乐观锁（<code class="language-plaintext highlighter-rouge">OPTIMISTIC</code>）或悲观锁（<code class="language-plaintext highlighter-rouge">PESSIMISTIC</code>）。默认值: <code class="language-plaintext highlighter-rouge">LockStrategyMode.PESSIMISTIC</code>，示例:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@GlobalTransactional</span><span class="o">(</span><span class="n">lockStrategyMode</span> <span class="o">=</span> <span class="nc">LockStrategyMode</span><span class="o">.</span><span class="na">OPTIMISTIC</span><span class="o">)</span>
</code></pre></div></div><h3 id="使用全局事务">使用全局事务</h3><p><code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 注解主要用于管理分布式事务的全局事务，确保在不同微服务之间的操作能够保持一致性。它的作用主要集中在 <strong>Try</strong>、<strong>Confirm</strong> 和 <strong>Cancel</strong> 阶段的事务管理上。</p><p>在使用 <code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 注解的方法中，也可以自由地使用普通的查询接口或服务方法，只要它们本身不涉及事务的提交或回滚。查询接口一般不参与全局事务的管理，因此不需要处理回滚或提交的问题。具体来说，这些查询接口可以是：</p><ul><li><strong>数据库查询</strong>：如使用 MyBatis、JPA、Hibernate 等进行的数据库查询。</li><li><strong>调用其他服务</strong>：如调用其他微服务的 REST API 或 Feign 客户端。</li></ul><p><strong>需要注意的事项</strong></p><p><strong>事务一致性</strong>：</p><ul><li>如果<code class="language-plaintext highlighter-rouge">@GlobalTransactional</code> 方法中使用了普通的查询接口，需要确保这些操作不会影响到全局事务的一致性。</li><li>确保在全局事务的 Try 阶段中进行的所有操作都能够在 Confirm 和 Cancel 阶段得到正确的处理。</li></ul><p><strong>性能影响</strong>：</p><ul><li>如果查询操作涉及到大量的数据或复杂的逻辑，这可能会对全局事务的性能产生影响。</li><li>确保查询操作是优化过的，并且不会导致长时间的锁定或延迟。</li></ul><p><strong>异常处理</strong>：</p><ul><li>在全局事务中，如果查询接口出现异常，确保这些异常能够被捕获并正确处理，以避免事务的回滚机制被破坏。</li></ul><p>使用全局事务，调用之前适配好分布式事务的接口示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">...</span>
<span class="nd">@Autowired</span>
<span class="kd">private</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>
<span class="nd">@GlobalTransactional</span>
<span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/test1"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="nf">test1</span><span class="o">(){</span>
	<span class="n">orderService</span><span class="o">.</span><span class="na">prepareCreateOrder</span><span class="o">(...);</span>
    <span class="o">...</span>
<span class="o">}</span>
<span class="o">...</span>
</code></pre></div></div><h3 id="各阶段的数据传递">各阶段的数据传递</h3><p>在Seata的TCC（Try-Confirm-Cancel）模式中，<code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 是一个非常关键的对象，它用于在分布式事务的各个阶段（Try、Confirm、Cancel）之间传递数据和上下文信息。它帮助事务中的每个阶段共享信息，确保整个TCC事务的正确执行。</p><p><code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 是由 Seata 框架在调用 <code class="language-plaintext highlighter-rouge">@TwoPhaseBusinessAction</code> 注解的 TCC 接口时<strong>自动创建和传递的</strong>。它是分布式事务的上下文对象，包含了事务ID（XID）以及在 <code class="language-plaintext highlighter-rouge">Try</code> 阶段生成的业务参数。以下是 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 的来源和生命周期：</p><p><strong>在Try阶段生成：</strong></p><ul><li>当执行标记为 <code class="language-plaintext highlighter-rouge">@TwoPhaseBusinessAction</code> 的方法时，Seata会自动创建一个 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 对象。</li><li><code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 对象会自动传递给 <code class="language-plaintext highlighter-rouge">Try</code> 方法的参数。</li><li>在 <code class="language-plaintext highlighter-rouge">Try</code> 方法中，可以将需要共享的数据存入 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code>，这些数据将在后续的 <code class="language-plaintext highlighter-rouge">Confirm</code> 和 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段使用。</li></ul><p><strong>在Confirm和Cancel阶段使用：</strong></p><ul><li>当事务成功（调用 <code class="language-plaintext highlighter-rouge">Confirm</code> 方法）或回滚（调用 <code class="language-plaintext highlighter-rouge">Cancel</code> 方法）时，Seata会将同样的 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 对象传递给对应的方法。</li><li><code class="language-plaintext highlighter-rouge">Confirm</code> 和 <code class="language-plaintext highlighter-rouge">Cancel</code> 方法可以从 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 中获取在 <code class="language-plaintext highlighter-rouge">Try</code> 阶段存储的数据（如业务ID、状态等），确保业务的一致性处理。</li></ul><hr /><p><strong><code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 的作用</strong></p><p><code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 的主要作用是<strong>传递事务上下文数据</strong>，确保分布式事务各个阶段的数据一致性和可用性。即：</p><p><strong>携带全局事务ID（XID）：</strong>Seata TCC事务的每个阶段（Try、Confirm、Cancel）需要关联同一个全局事务ID（XID）。<code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 中包含了这个事务ID，确保所有阶段都属于同一事务。</p><p><strong>传递业务参数：</strong><code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 允许在 <code class="language-plaintext highlighter-rouge">Try</code> 阶段传递参数，并在 <code class="language-plaintext highlighter-rouge">Confirm</code> 或 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段读取这些参数。你可以在 <code class="language-plaintext highlighter-rouge">Try</code> 方法中将需要的数据（例如订单ID、用户ID等）放入 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code>，并在 <code class="language-plaintext highlighter-rouge">Confirm</code> 或 <code class="language-plaintext highlighter-rouge">Cancel</code> 中使用。</p><p><strong>支持幂等性处理：</strong>在分布式系统中，网络波动或其他异常情况可能会导致 <code class="language-plaintext highlighter-rouge">Confirm</code> 或 <code class="language-plaintext highlighter-rouge">Cancel</code> 方法被多次调用。通过 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 传递的数据，可以用来做幂等性检查，避免重复执行业务操作。</p><p><strong>支持悬挂控制：</strong><code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 还可以用于处理“悬挂问题”，即当 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段执行在 <code class="language-plaintext highlighter-rouge">Try</code> 之前时，通过 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 可以检测是否存在 <code class="language-plaintext highlighter-rouge">Try</code> 的执行，进而决定是否执行 <code class="language-plaintext highlighter-rouge">Cancel</code>。</p><hr /><p><code class="language-plaintext highlighter-rouge">BusinessActionContext</code>具有以下方法：</p><p><strong><code class="language-plaintext highlighter-rouge">getActionContext()</code></strong>：获取在 Try 阶段存储的业务数据。通常在 <code class="language-plaintext highlighter-rouge">commit</code> 或 <code class="language-plaintext highlighter-rouge">rollback</code> 阶段，通过 <code class="language-plaintext highlighter-rouge">getActionContext()</code> 方法获取在 <code class="language-plaintext highlighter-rouge">prepare</code> 阶段存储的数据。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">value</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getActionContext</span><span class="o">(</span><span class="s">"key"</span><span class="o">);</span>
</code></pre></div></div><ul><li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">key</code> 是存储数据时的键。</li><li><strong>返回值</strong>：返回与该键关联的值，类型为 <code class="language-plaintext highlighter-rouge">Object</code>，需要进行类型转换。</li></ul><p><strong><code class="language-plaintext highlighter-rouge">addActionContext()</code></strong>：在 Try 阶段保存业务数据，用于后续的 Confirm 或 Rollback 阶段使用。在 <code class="language-plaintext highlighter-rouge">prepare</code> 方法中，调用 <code class="language-plaintext highlighter-rouge">addActionContext()</code> 将业务数据存储在上下文中。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">context</span><span class="o">.</span><span class="na">addActionContext</span><span class="o">(</span><span class="s">"orderId"</span><span class="o">,</span> <span class="n">orderId</span><span class="o">);</span>
<span class="n">context</span><span class="o">.</span><span class="na">addActionContext</span><span class="o">(</span><span class="s">"userId"</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
</code></pre></div></div><ul><li><strong>参数</strong>：<code class="language-plaintext highlighter-rouge">key</code>：数据的键，<code class="language-plaintext highlighter-rouge">value</code>：要存储的数据值。</li></ul><p><strong><code class="language-plaintext highlighter-rouge">getXid()</code></strong>：获取全局事务ID（<code class="language-plaintext highlighter-rouge">Xid</code>），用于标识当前事务，在事务处理或日志中非常有用。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">xid</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getXid</span><span class="o">();</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">getBranchId()</code></strong>：获取当前分支事务的ID。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">branchId</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBranchId</span><span class="o">();</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">isDelayReporting()</code></strong>：判断当前事务是否设置了延迟上报。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">isDelayed</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">isDelayReporting</span><span class="o">();</span>
</code></pre></div></div><p><strong><code class="language-plaintext highlighter-rouge">getPhase()</code></strong>：获取当前事务的阶段（如 Try、Confirm、Rollback）。实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BusinessActionContext</span><span class="o">.</span><span class="na">BusinessActionContextPhase</span> <span class="n">phase</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getPhase</span><span class="o">();</span>
</code></pre></div></div><ul><li><strong>返回值</strong>：返回事务的当前阶段，类型为 <code class="language-plaintext highlighter-rouge">BusinessActionContext.BusinessActionContextPhase</code>。</li></ul><hr /><p><strong><code class="language-plaintext highlighter-rouge">BusinessActionContext</code></strong> <strong>是必须的</strong>。它是Seata框架用来传递事务上下文信息的关键组件，即在TCC这三个方式的第一个形参必须是<code class="language-plaintext highlighter-rouge">BusinessActionContext</code>。</p><p>即使你的业务代码中不直接使用 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code>，你仍然需要在 TCC 接口方法中留一个 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 作为第一个参数，以便 Seata 能够正常控制事务。它负责管理和传递事务上下文信息，从而让 Seata 知道如何协调 Try、Confirm 和 Cancel 阶段的操作。</p><hr /><p>对于使用<code class="language-plaintext highlighter-rouge">BusinessActionContext</code>传递信息，还有一些注意的问题：</p><p>在 Seata TCC 模式下，<code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 会通过分布式系统进行传递，这个过程通常涉及到<strong>序列化</strong>和<strong>反序列化</strong>。在序列化和反序列化的过程中，Java 对象的类型可能发生变化，尤其是涉及基础数据类型时。</p><p>示例：<code class="language-plaintext highlighter-rouge">long</code> 类型传值导致的类型变化</p><p><strong>Try 阶段：传递 <code class="language-plaintext highlighter-rouge">long</code> 类型值</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@LocalTCC</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TCCInventoryChange</span> <span class="o">{</span>

    <span class="nd">@Transactional</span>
    <span class="nd">@TwoPhaseBusinessAction</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TCCInventoryChange"</span><span class="o">,</span> <span class="n">commitMethod</span> <span class="o">=</span> <span class="s">"commit"</span><span class="o">,</span> <span class="n">rollbackMethod</span> <span class="o">=</span> <span class="s">"rollback"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">prepare</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">,</span> <span class="kt">long</span> <span class="n">productId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 将 long 类型的 productId 放入 ActionContext</span>
        <span class="n">actionContext</span><span class="o">.</span><span class="na">addActionContext</span><span class="o">(</span><span class="s">"productId"</span><span class="o">,</span> <span class="n">productId</span><span class="o">);</span>  
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  <span class="c1">// 返回成功</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>Commit 阶段：取出 <code class="language-plaintext highlighter-rouge">productId</code></strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">commit</span><span class="o">(</span><span class="nc">BusinessActionContext</span> <span class="n">actionContext</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 试图以 long 类型取出 productId</span>
    <span class="kt">long</span> <span class="n">productId</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Long</span><span class="o">)</span> <span class="n">actionContext</span><span class="o">.</span><span class="na">getActionContext</span><span class="o">(</span><span class="s">"productId"</span><span class="o">);</span>
    <span class="c1">// 处理业务逻辑...</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>但是，实际在执行时可能会抛出 <code class="language-plaintext highlighter-rouge">ClassCastException</code>，因为 <code class="language-plaintext highlighter-rouge">actionContext.getActionContext("productId")</code> 实际上返回的是 <code class="language-plaintext highlighter-rouge">Integer</code>，而不是 <code class="language-plaintext highlighter-rouge">Long</code>，即使我们在 <code class="language-plaintext highlighter-rouge">prepare</code> 阶段传递的是 <code class="language-plaintext highlighter-rouge">long</code> 类型。</p><p><strong>问题出现原因：序列化导致的类型变化</strong></p><p>这是由于 Java 序列化机制在处理基础数据类型时的行为不同。例如，Java 会自动进行类型提升和转换。在 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 经过序列化和反序列化后，Seata 可能将原本的 <code class="language-plaintext highlighter-rouge">long</code> 类型转换成了 <code class="language-plaintext highlighter-rouge">Integer</code>。</p><p>详细说明</p><p><strong>序列化与反序列化过程</strong> 在分布式系统中，<code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 会在不同的节点间传递，传递时会进行序列化和反序列化。序列化是指将对象转换为字节流以便传输，而反序列化则是将字节流重新转换为对象。在序列化过程中，某些数据类型，特别是基础类型（如 <code class="language-plaintext highlighter-rouge">long</code>、<code class="language-plaintext highlighter-rouge">int</code>），有时会在反序列化后出现类型变化。例如，<code class="language-plaintext highlighter-rouge">long</code> 类型可能会因为存储方式在反序列化后变成 <code class="language-plaintext highlighter-rouge">Integer</code>。</p><p><strong>基础类型自动转换</strong> Java 在处理基础类型时，可能会进行自动的类型提升或缩减。例如，如果你存储一个数值类型较小的 <code class="language-plaintext highlighter-rouge">long</code>，它在某些情况下可能会被自动转换为 <code class="language-plaintext highlighter-rouge">Integer</code>。特别是在序列化时，Java 可能将小范围的 <code class="language-plaintext highlighter-rouge">long</code>（如 <code class="language-plaintext highlighter-rouge">long</code> 值不超过 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>）转换为 <code class="language-plaintext highlighter-rouge">Integer</code>，以节省存储空间。</p><p><strong>Seata 内部机制</strong> Seata 在 TCC 模式下可能通过 JSON 序列化（如使用 Jackson 或 FastJSON）来传递 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code>。在某些情况下，JSON 序列化的机制会对数值类型进行优化，并且在反序列化时，如果没有明确指定类型，较小范围的 <code class="language-plaintext highlighter-rouge">long</code> 会被当作 <code class="language-plaintext highlighter-rouge">Integer</code> 反序列化。</p><p>解决方案</p><p>为了避免这种类型转换的问题，尤其是在处理基础数据类型时，可以采取以下几种措施：</p><p><strong>使用显式类型检查和转换</strong> 在获取上下文参数时，显式地检查对象的类型，避免直接进行类型转换。可以先检查 <code class="language-plaintext highlighter-rouge">Object</code> 的类型再进行强制转换：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="nc">Object</span> <span class="n">productIdObj</span> <span class="o">=</span> <span class="n">actionContext</span><span class="o">.</span><span class="na">getActionContext</span><span class="o">(</span><span class="s">"productId"</span><span class="o">);</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">productIdObj</span> <span class="k">instanceof</span> <span class="nc">Long</span><span class="o">)</span> <span class="o">{</span>
       <span class="kt">long</span> <span class="n">productId</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Long</span><span class="o">)</span> <span class="n">productIdObj</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">productIdObj</span> <span class="k">instanceof</span> <span class="nc">Integer</span><span class="o">)</span> <span class="o">{</span>
       <span class="c1">// 处理 long 被序列化为 Integer 的情况</span>
       <span class="kt">long</span> <span class="n">productId</span> <span class="o">=</span> <span class="o">((</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">productIdObj</span><span class="o">).</span><span class="na">longValue</span><span class="o">();</span>
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
       <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"Unexpected type for productId"</span><span class="o">);</span>
   <span class="o">}</span>
</code></pre></div></div><p><strong>序列化时强制指定类型</strong> 在传递 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 数据时，使用 <code class="language-plaintext highlighter-rouge">Long</code> 对象来代替基础类型 <code class="language-plaintext highlighter-rouge">long</code>。这样，序列化时会保留对象的精确类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="n">actionContext</span><span class="o">.</span><span class="na">addActionContext</span><span class="o">(</span><span class="s">"productId"</span><span class="o">,</span> <span class="nc">Long</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">productId</span><span class="o">));</span>
</code></pre></div></div><p><strong>使用 JSON 序列化配置</strong> 如果使用的是 JSON 序列化框架（如 Jackson 或 FastJSON），可以通过配置序列化框架来确保数值类型不会在序列化或反序列化过程中发生变化。例如，使用 Jackson 的 <code class="language-plaintext highlighter-rouge">DeserializationFeature.USE_LONG_FOR_INTS</code> 选项，可以强制将所有整数类型都反序列化为 <code class="language-plaintext highlighter-rouge">long</code> 类型。</p><p>使用 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 传递基础类型时，序列化导致类型变化的情况主要发生在基础类型（如 <code class="language-plaintext highlighter-rouge">long</code> 和 <code class="language-plaintext highlighter-rouge">int</code>）的自动转换过程中。为了避免这种情况，建议在代码中加入类型检查，或者通过序列化框架的配置确保类型的一致性。</p><h3 id="方法返回值类型">方法返回值类型</h3><p>在 Seata TCC 模式下，方法的返回值并没有严格的要求，但有一些约定和最佳实践，特别是在 <code class="language-plaintext highlighter-rouge">Try</code>、<code class="language-plaintext highlighter-rouge">Confirm</code> 和 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段执行时：</p><p><strong>Try 阶段返回值要求</strong>：<code class="language-plaintext highlighter-rouge">Try</code> 方法需要返回一个布尔类型（<code class="language-plaintext highlighter-rouge">boolean</code>）的值，表示准备操作是否成功。</p><ul><li><strong><code class="language-plaintext highlighter-rouge">true</code></strong>：表示 Try 阶段执行成功，Seata 会继续执行 <code class="language-plaintext highlighter-rouge">Confirm</code> 阶段。</li><li><strong><code class="language-plaintext highlighter-rouge">false</code></strong>：表示 Try 阶段执行失败，Seata 会立即执行 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段。</li></ul><p><strong>Confirm 阶段返回值要求</strong>：<code class="language-plaintext highlighter-rouge">Confirm</code> 方法的返回值通常也是布尔类型（<code class="language-plaintext highlighter-rouge">boolean</code>），用于告诉 Seata 确认操作是否执行成功。</p><ul><li><strong><code class="language-plaintext highlighter-rouge">true</code></strong>：表示 <code class="language-plaintext highlighter-rouge">Confirm</code> 操作成功，事务可以提交。</li><li><strong><code class="language-plaintext highlighter-rouge">false</code></strong>：表示 <code class="language-plaintext highlighter-rouge">Confirm</code> 操作失败，但一般不会影响全局事务，因为全局事务在 <code class="language-plaintext highlighter-rouge">Try</code> 成功后已经被认为提交。</li></ul><p><strong>Cancel 阶段返回值要求</strong>：<code class="language-plaintext highlighter-rouge">Cancel</code> 方法的返回值同样是布尔类型（<code class="language-plaintext highlighter-rouge">boolean</code>），用于告诉 Seata 回滚操作是否执行成功。</p><ul><li><strong><code class="language-plaintext highlighter-rouge">true</code></strong>：表示回滚成功，Seata 会认为事务已经被成功回滚。</li><li><strong><code class="language-plaintext highlighter-rouge">false</code></strong>：表示回滚失败，此时 Seata 可能会进行重试，直到回滚成功或达到重试上限。</li></ul><p><strong>返回值的影响</strong></p><ul><li><strong>Try 阶段返回值</strong>：<strong>影响全局事务的决策</strong>，如果 Try 返回 <code class="language-plaintext highlighter-rouge">false</code>，Seata 会立即调用 <code class="language-plaintext highlighter-rouge">Cancel</code> 方法，标记事务失败。</li><li><strong>Confirm 阶段返回值</strong>：理论上不会影响全局事务的提交，即使 <code class="language-plaintext highlighter-rouge">Confirm</code> 方法失败，Seata 也会认为事务已经提交成功。</li><li><strong>Cancel 阶段返回值</strong>：如果 <code class="language-plaintext highlighter-rouge">Cancel</code> 返回 <code class="language-plaintext highlighter-rouge">false</code>，Seata 会进行<strong>重试</strong>，确保事务资源被成功回滚。</li></ul><p><strong>其他返回值</strong></p><p>虽然 TCC 的标准返回类型为 <code class="language-plaintext highlighter-rouge">boolean</code>，但如果你有自定义需求，可以返回其他类型的值， Seata <strong>仅关心 <code class="language-plaintext highlighter-rouge">Try</code> 方法的返回值是否为 <code class="language-plaintext highlighter-rouge">true</code></strong>，来决定是否继续 <code class="language-plaintext highlighter-rouge">Confirm</code> 或 <code class="language-plaintext highlighter-rouge">Cancel</code>。</p><h3 id="调用接口">调用接口</h3><p>在Seata的TCC模式下，<code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 是由Seata自动注入的，但它<strong>必须</strong>放在TCC接口方法的<strong>第一个参数位置</strong>，然后才是业务参数。</p><p>Seata的TCC拦截器要求 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 是第一个参数，这样Seata才能在执行全局事务的各个阶段时自动注入这个上下文。如果放在其他位置，Seata无法识别该参数，从而导致TCC事务处理失败。</p><p>当你调用 TCC 的 <code class="language-plaintext highlighter-rouge">prepare</code>方法时，不需要显式创建或传递 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code>，Seata会在执行拦截时自动注入。也就是说，当你调用时，可以将 <code class="language-plaintext highlighter-rouge">BusinessActionContext</code> 传递为 <code class="language-plaintext highlighter-rouge">null</code>，Seata在执行过程中会为其生成并注入实际的上下文对象。</p><p>对于之前省略实参的：<code class="language-plaintext highlighter-rouge">orderService.prepareCreateOrder(...);</code>，正确的调用方式为：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">orderService</span><span class="o">.</span><span class="na">prepareCreateOrder</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span><span class="n">userId</span><span class="o">,</span><span class="n">productId</span><span class="o">,</span><span class="n">count</span><span class="o">);</span>
</code></pre></div></div><p>另外，在Seata的TCC模式下，<code class="language-plaintext highlighter-rouge">commit</code> 和 <code class="language-plaintext highlighter-rouge">rollback</code> 是由Seata在全局事务的不同阶段<strong>自动调用</strong>的。你只需要在业务代码中显式调用 <code class="language-plaintext highlighter-rouge">prepare</code>（也称为Try方法）来尝试预留资源。</p><p>具体来说：</p><ul><li><code class="language-plaintext highlighter-rouge">prepare</code>（Try阶段）是由你的业务代码<strong>显式调用</strong>的，用于预留资源或执行其他初步操作。</li><li><code class="language-plaintext highlighter-rouge">commit</code>（Confirm阶段）和<code class="language-plaintext highlighter-rouge">rollback</code>（Cancel阶段）会根据全局事务的执行结果（成功或失败）由Seata自动调用，以完成事务提交或回滚。</li></ul><p><strong>你不需要也不能直接调用 <code class="language-plaintext highlighter-rouge">commit</code> 或 <code class="language-plaintext highlighter-rouge">rollback</code>，它们会根据全局事务的状态自动触发</strong>。</p><h3 id="与本地事务的比较">与本地事务的比较</h3><p>本地事务（使用 <code class="language-plaintext highlighter-rouge">@Transactional</code>）</p><ul><li><strong>回滚机制</strong>：当在一个单一的数据源中操作时，Spring 的 <code class="language-plaintext highlighter-rouge">@Transactional</code> 注解可以在发生异常时自动进行回滚。这意味着如果在事务过程中出现任何运行时异常（或被配置为回滚的异常），Spring 会自动回滚事务，撤销所有对数据库的更改，确保数据一致性。</li><li><strong>事务管理</strong>：Spring 自动管理事务的开始、提交和回滚。只需配置 <code class="language-plaintext highlighter-rouge">@Transactional</code> 注解，并确保异常能够被捕获并且未被处理。</li></ul><p>分布式事务（使用 Seata TCC、XA、等）</p><ul><li><strong>事务模型</strong>：在分布式环境中，事务涉及多个服务或数据源，不能依赖于单一的事务管理机制。因此，需要使用分布式事务解决方案（如 Seata、XA、TCC）来协调这些事务的执行。<ul><li><strong>TCC</strong>（Try-Confirm-Cancel）：分为 <code class="language-plaintext highlighter-rouge">Try</code>、<code class="language-plaintext highlighter-rouge">Confirm</code> 和 <code class="language-plaintext highlighter-rouge">Cancel</code> 阶段。<strong>需要自己实现这些阶段的逻辑，以确保在失败情况下能够进行回滚或恢复</strong>。</li><li><strong>XA</strong>：基于两阶段提交协议，适用于需要强一致性的分布式事务，但实现和维护较复杂。</li></ul></li><li><strong>自定义回滚逻辑</strong>：分布式事务通常需要手动管理回滚逻辑。如果某个服务的操作失败，需要确保其他服务能够正确地执行回滚操作，恢复系统到一致性状态。这通常通过实现 <code class="language-plaintext highlighter-rouge">commit</code> 和 <code class="language-plaintext highlighter-rouge">rollback</code> 方法来完成。</li></ul><p>为什么分布式事务需要更多手动处理？</p><ul><li><strong>复杂性</strong>：在分布式环境中，事务涉及多个服务或数据源，它们可能在网络上分布，事务的协调和管理变得更加复杂。</li><li><strong>一致性保障</strong>：为了确保系统的一致性和完整性，需要手动实现各个阶段的逻辑，确保在任何阶段的失败都能够正确地进行回滚或恢复。</li><li><strong>网络和系统故障</strong>：分布式系统中可能会遇到网络延迟、故障或其他不可预见的问题，这要求分布式事务解决方案具备更强的容错性和恢复能力。</li></ul><p>总之，分布式事务相较于本地事务更复杂，需要额外的事务协调机制和手动管理回滚逻辑。然而，它们为分布式系统提供了必要的一致性保证，使得在多服务或多数据源环境中进行可靠的事务处理成为可能。</p><hr /><p>在使用分布式事务框架（如 Seata 的 TCC 模式）时，<code class="language-plaintext highlighter-rouge">@Transactional</code> 注解在每个方法中的作用和意义如下：</p><p><strong>确保本地事务的一致性</strong></p><p><code class="language-plaintext highlighter-rouge">@Transactional</code> 注解用于标记一个方法需要运行在事务中。它确保方法内的数据库操作是原子的，即要么全部成功，要么全部失败。在 TCC 模式下，即使分布式事务的各个步骤有独立的事务控制，<code class="language-plaintext highlighter-rouge">@Transactional</code> 仍然是必要的：</p><ul><li><strong><code class="language-plaintext highlighter-rouge">prepare</code> 方法</strong>：确保即使在 <code class="language-plaintext highlighter-rouge">prepare</code> 阶段操作失败或发生异常，本地事务也能正确回滚，避免数据不一致。</li><li><strong><code class="language-plaintext highlighter-rouge">commit</code> 方法</strong>：确保在 <code class="language-plaintext highlighter-rouge">commit</code> 阶段对数据库的操作是原子的。虽然 <code class="language-plaintext highlighter-rouge">commit</code> 只是确认操作，但仍然需要事务保证操作的一致性。</li><li><strong><code class="language-plaintext highlighter-rouge">rollback</code> 方法</strong>：如果在 <code class="language-plaintext highlighter-rouge">commit</code> 阶段失败，<code class="language-plaintext highlighter-rouge">rollback</code> 方法应当回滚 <code class="language-plaintext highlighter-rouge">prepare</code> 阶段的操作，<code class="language-plaintext highlighter-rouge">@Transactional</code> 确保这一回滚是安全的。</li></ul><p><strong>提供事务隔离和一致性</strong></p><p><code class="language-plaintext highlighter-rouge">@Transactional</code> 控制事务的隔离级别、传播行为、超时时间等，确保方法内部的数据库操作符合预期的事务要求：</p><ul><li><strong>隔离级别</strong>：防止不同事务之间的干扰，避免读到不一致的数据。</li><li><strong>传播行为</strong>：确定方法执行时事务的传播方式，比如是否加入到当前事务中。</li></ul><p><strong>异常处理和事务回滚</strong></p><p><code class="language-plaintext highlighter-rouge">@Transactional</code> 确保方法内部抛出的运行时异常（unchecked exception）会导致事务回滚。这样可以保证在遇到异常时，所有的数据库操作都能够被回滚到操作之前的状态，保持数据的一致性。</p><p>虽然 TCC 模式主要处理分布式事务的协调，<strong>但在每个本地事务中，使用 <code class="language-plaintext highlighter-rouge">@Transactional</code> 注解仍然是确保数据一致性的关键。</strong></p><h3 id="事务幂等悬挂和空回滚">事务幂等、悬挂和空回滚</h3><p><strong>空回滚</strong></p><p>当某分支事务的try阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是<strong>空回滚</strong>。</p><p>执行cancel操作时，应当判断try是否已经执行，如果尚未执行，则应该空回滚。</p><p><strong>业务悬挂</strong></p><p>对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是<strong>业务悬挂</strong>。</p><p>执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂</p><hr /><p>TCC 模式中存在的三大问题是幂等、悬挂和空回滚，而新版seata解决了上述问题：<a href="https://seata.apache.org/zh-cn/blog/seata-tcc-fence/">链接</a>。</p><p>在 Seata1.5.1 版本中，增加了一张事务控制表，表名是 <code class="language-plaintext highlighter-rouge">tcc_fence_log</code> 来解决这个问题。 <code class="language-plaintext highlighter-rouge">@TwoPhaseBusinessAction</code> 注解中有一个属性 <code class="language-plaintext highlighter-rouge">useTCCFence</code> 就是来指定是否开启这个机制，这个属性值默认是 <code class="language-plaintext highlighter-rouge">false</code>。</p><p>首先，在自己的数据库添加一个事务控制表：<code class="language-plaintext highlighter-rouge">tcc_fence_log</code>， 建表语句如下（MySQL 语法）：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="nv">`tcc_fence_log`</span>
<span class="p">(</span>
    <span class="nv">`xid`</span>           <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span>  <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'global id'</span><span class="p">,</span>
    <span class="nv">`branch_id`</span>     <span class="nb">BIGINT</span>        <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'branch id'</span><span class="p">,</span>
    <span class="nv">`action_name`</span>   <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>   <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'action name'</span><span class="p">,</span>
    <span class="nv">`status`</span>        <span class="nb">TINYINT</span>       <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'status(tried:1;committed:2;rollbacked:3;suspended:4)'</span><span class="p">,</span>
    <span class="nv">`gmt_create`</span>    <span class="nb">DATETIME</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'create time'</span><span class="p">,</span>
    <span class="nv">`gmt_modified`</span>  <span class="nb">DATETIME</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">COMMENT</span> <span class="s1">'update time'</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`xid`</span><span class="p">,</span> <span class="nv">`branch_id`</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="nv">`idx_gmt_modified`</span> <span class="p">(</span><span class="nv">`gmt_modified`</span><span class="p">),</span>
    <span class="k">KEY</span> <span class="nv">`idx_status`</span> <span class="p">(</span><span class="nv">`status`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">InnoDB</span>
<span class="k">DEFAULT</span> <span class="n">CHARSET</span> <span class="o">=</span> <span class="n">utf8mb4</span><span class="p">;</span>
</code></pre></div></div><p>然后在<code class="language-plaintext highlighter-rouge">@TwoPhaseBusinessAction</code>，开启<code class="language-plaintext highlighter-rouge">useTCCFence</code>即可。</p><p>开启<code class="language-plaintext highlighter-rouge">useTCCFence</code>后，TCC阶段的转换逻辑会发生变化：</p><table><thead><tr><th>阶段</th><th>useTCCFence</th><th>异常</th><th>程序停止</th></tr></thead><tbody><tr><td>try</td><td>true</td><td>暂停</td><td>无操作</td></tr><tr><td>Confirm</td><td>true</td><td>重试</td><td>无操作</td></tr><tr><td>Cancel</td><td>true</td><td>重试</td><td>重试</td></tr><tr><td>try</td><td>false</td><td>多次执行Cancel</td><td>无操作/还原（加本地事务）</td></tr><tr><td>Confirm</td><td>false</td><td>多次重试</td><td>无操作</td></tr><tr><td>Cancel</td><td>false</td><td>多次重试</td><td>无操作</td></tr></tbody></table><p>开启 <code class="language-plaintext highlighter-rouge">useTCCFence</code> 后的行为主要与解决 TCC 模式下的悬挂问题有关。悬挂问题指的是在 TCC 模式下，当 Confirm 或 Cancel 阶段因为某种原因没有被执行时，可能会导致资源长时间处于锁定状态，影响系统的正常运行。<code class="language-plaintext highlighter-rouge">useTCCFence</code> 就是用来防止这类问题的发生。</p><p>以下是开启 <code class="language-plaintext highlighter-rouge">useTCCFence</code> 后的行为总结：</p><ol><li><p><strong>记录尝试操作</strong>：当开启 <code class="language-plaintext highlighter-rouge">useTCCFence</code> 后，在执行 TCC 的 Try 阶段时，Seata 会记录这次操作，并将其持久化到数据库中。</p></li><li><p><strong>检查确认/取消请求</strong>：在 Confirm 或 Cancel 阶段到来之前，Seata 会先检查是否有对应的 Try 操作记录存在。如果没有找到匹配的 Try 记录，则认为这是一个非法的请求，可能是由于网络重试或其他异常情况导致的重复调用。</p></li><li><p><strong>避免悬挂事务</strong>：通过上述机制，可以有效地避免因 Confirm 或 Cancel 请求丢失而造成的悬挂事务问题。如果系统重启或服务宕机后恢复，未完成的 TCC 事务可以通过这些记录来进行补偿处理。</p></li><li><p><strong>清理过期记录</strong>：对于那些已经完成了 Confirm 或 Cancel 操作的 Try 记录，Seata 会在一段时间之后自动清理它们以节省存储空间并保持系统清洁。</p></li><li><p><strong>提高系统稳定性</strong>：整体而言，启用 <code class="language-plaintext highlighter-rouge">useTCCFence</code> 能够帮助增强 TCC 模式的鲁棒性，减少由外部因素引起的服务不稳定状况，确保分布式事务能够按照预期的方式正确地执行完毕。</p></li></ol><p>需要注意的是，使用 <code class="language-plaintext highlighter-rouge">useTCCFence</code> 功能可能需要对现有的 TCC 业务代码进行一些调整，并且要保证相应的存储支持持久化记录的能力。此外，还需要合理配置超时时间等参数以适应不同的业务场景。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/09/21/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" target="_blank">https://acteds.github.io/2024/09/21/Seata%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1727714095', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
