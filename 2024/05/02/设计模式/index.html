<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>设计模式 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="设计模式"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。"><meta name="og:description" content="引言设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。"><meta property="og:url" content="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-05-02"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="设计模式"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">设计模式</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/05/02 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 42105 字，约 121 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p><h1 id="设计模式">设计模式</h1><p>软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的。23个常用模式分为创建型模式、结构型模式和行为型模式三类，基于以下几个原则：</p><p><strong>开闭原则</strong></p><p>软件应该对扩展开放，而对修改关闭。在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p><p><strong>单一职责原则</strong></p><p>一个类只负责一项职责。针对一个类，其承担的职责越多，被复用的可能性就越小。如果类承担的职责很多，就意味着这些职责耦合在了一起。</p><p><strong>里氏替换原则</strong></p><p>如果调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p><p><strong>接口隔离原则</strong></p><ul><li>客户需要什么样的接口，就提供什么样的接口，不需要的就删除掉；</li><li>类之间的依赖关系应建立在最小的接口上。也就是说，接口中的方法要尽量的少，接口功能要尽量的细分。</li></ul><p><strong>依赖倒置原则</strong></p><p>依赖倒转原则就是要依赖于抽象，不要依赖于实现。高层模块不依赖于底层模块，二者都依赖其抽象；抽象不依赖于细节，细节应该依赖抽象。</p><p>也就是说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等，而不是用具体类。<strong>一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法</strong>。特例：对象的创建过程是违背“开—闭”原则以及依赖倒转原则的，但通过工厂模式，能很好地解决对象创建过程中的依赖倒转问题。</p><p><strong>迪米特原则</strong></p><p>又称为最少知识原则，<strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p><p>如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</p><p>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</p><p>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><p><strong>组合/聚合复用原则</strong></p><p>简单的说是，尽量使用对象的组合/聚合，而不是继承来达到复用的目的。</p><p>组合和聚合都是对象建模中关联关系的一种。聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。</p><p>组合/聚合和继承是实现代码复用的两种基本途径，在设计过程中尽量使用组合/聚合，而不是继承。因为继承使得基类与子类有较强的耦合性，通常情况下基类的内部细节对子类来说是可见的，这样基类的实现细节会暴露给子类，破坏了系统的封装性。</p><p>开闭原则是所有面向对象原则的核心；里式替换原则是实现开闭原则的重要方式之一；依赖倒置原则是系统抽象化的具体实现，其是面向对象设计的主要实现机制之一；接口隔离原则要求接口的方法尽量少，接口尽量细化；迪米特原则降低系统的耦合度，其使得一个模块的修改尽量少的影响其他模块，扩展会相对容易；尽量使用组合/聚合而不是继承达到代码复用的目的。</p><h2 id="创建型模式">创建型模式</h2><p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p><p>常见的创建型模式：</p><ul><li><strong>工厂方法模式（Factory Method Pattern）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li><li><strong>建造者模式（Builder Pattern）</strong>：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype Pattern）</strong>：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</li><li><strong>单例模式（Singleton Pattern）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li></ul><h3 id="工厂方法">工厂方法</h3><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p></blockquote><p>工厂方法即Factory Method，是一种对象创建型模式。</p><p>工厂方法的目的是使得<strong>创建对象</strong>和<strong>使用对象</strong>是<strong>分离</strong>的，并且客户端<strong>总是引用抽象工厂和抽象产品</strong>：</p><pre><code class="language-ascii">┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
</code></pre><p>实现一个解析<code class="language-plaintext highlighter-rouge">字符串</code>为<code class="language-plaintext highlighter-rouge">Number</code>的<code class="language-plaintext highlighter-rouge">Factory</code>，可以定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>有了工厂接口，再编写一个工厂的实现类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberFactoryImpl</span> <span class="kd">implements</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>产品接口是<code class="language-plaintext highlighter-rouge">Number</code>，<code class="language-plaintext highlighter-rouge">NumberFactoryImpl</code>返回的实际产品是<code class="language-plaintext highlighter-rouge">BigDecimal</code>。</p><p>通常会在接口<code class="language-plaintext highlighter-rouge">Factory</code>中再定义一个静态方法<code class="language-plaintext highlighter-rouge">getFactory()</code>来返回真正的子类（在 <strong>Java 8</strong> 中，接口可以包含静态方法）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="c1">// 创建方法:</span>
    <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
    <span class="c1">// 获取工厂实例:</span>
    <span class="kd">static</span> <span class="nc">NumberFactory</span> <span class="nf">getFactory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">impl</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">NumberFactory</span> <span class="n">impl</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberFactoryImpl</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>在客户端中，只需要和工厂接口<code class="language-plaintext highlighter-rouge">NumberFactory</code>以及抽象产品<code class="language-plaintext highlighter-rouge">Number</code>打交道：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NumberFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">NumberFactory</span><span class="o">.</span><span class="na">getFactory</span><span class="o">();</span>
<span class="nc">Number</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"123.456"</span><span class="o">);</span>
</code></pre></div></div><p>调用方可以完全忽略真正的工厂<code class="language-plaintext highlighter-rouge">NumberFactoryImpl</code>和实际的产品<code class="language-plaintext highlighter-rouge">BigDecimal</code>，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。</p><hr /><p>实际上，大多数情况下并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。</p><p>静态工厂方法广泛地应用在Java标准库中。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Integer</code>既是产品又是静态工厂，它提供了静态方法<code class="language-plaintext highlighter-rouge">valueOf()</code>来创建<code class="language-plaintext highlighter-rouge">Integer</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Integer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">low</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">high</span><span class="o">)</span>
            <span class="k">return</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">cache</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="o">(-</span><span class="nc">IntegerCache</span><span class="o">.</span><span class="na">low</span><span class="o">)];</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">valueOf()</code>内部可能会使用<code class="language-plaintext highlighter-rouge">new</code>创建一个新的<code class="language-plaintext highlighter-rouge">Integer</code>实例，但也可能直接返回一个缓存的<code class="language-plaintext highlighter-rouge">Integer</code>实例。对于调用方来说，没必要知道<code class="language-plaintext highlighter-rouge">Integer</code>创建的细节。</p><p>工厂方法可以<strong>隐藏创建产品的细节</strong>，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p><p>如果调用方直接使用<code class="language-plaintext highlighter-rouge">Integer n = new Integer(100)</code>，那么就失去了使用缓存优化的可能性。</p><hr /><p>经常使用的另一个静态工厂方法是<code class="language-plaintext highlighter-rouge">List.of()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">);</span>
</code></pre></div></div><p>这个静态工厂方法接收可变参数，然后返回<code class="language-plaintext highlighter-rouge">List</code>接口。需要注意的是，调用方获取的产品总是<code class="language-plaintext highlighter-rouge">List</code>接口，而且并不关心它的实际类型。</p><p>即使调用方知道<code class="language-plaintext highlighter-rouge">List</code>产品的实际类型是<code class="language-plaintext highlighter-rouge">java.util.ImmutableCollections$ListN</code>，也不要去强制转型为子类，因为静态工厂方法<code class="language-plaintext highlighter-rouge">List.of()</code>保证返回<code class="language-plaintext highlighter-rouge">List</code>，但也完全可以修改为返回<code class="language-plaintext highlighter-rouge">java.util.ArrayList</code>。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p><p>总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p><hr /><p>和<code class="language-plaintext highlighter-rouge">List.of()</code>类似，使用<code class="language-plaintext highlighter-rouge">MessageDigest</code>时，为了创建某个摘要算法，总是使用静态工厂方法<code class="language-plaintext highlighter-rouge">getInstance(String)</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MessageDigest</span> <span class="n">md5</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"MD5"</span><span class="o">);</span>
<span class="nc">MessageDigest</span> <span class="n">sha1</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA-1"</span><span class="o">);</span>
</code></pre></div></div><p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是<code class="language-plaintext highlighter-rouge">MessageDigest</code>这个抽象类。</p><h3 id="抽象工厂">抽象工厂</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></blockquote><p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p><p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，工厂是抽象的，产品也是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p><pre><code class="language-ascii">                                ┌────────┐
                             ─ &gt;│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─&gt;│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ &gt;│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│
               └─────────┘     └─────────┘
</code></pre><p>这种模式有点类似于多个供应商负责提供一系列类型的产品。</p><p>假设希望为用户提供一个可以买荤素菜的环境，定义接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>定义了抽象工厂（<code class="language-plaintext highlighter-rouge">ImeatAndVegetarianFactory</code>）以及两个抽象产品（<code class="language-plaintext highlighter-rouge">IMeat</code>和<code class="language-plaintext highlighter-rouge">IVegetarian</code>）。假设环境可以是超市也可以是菜市场，先写菜市场：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*菜市场*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MarketFactoryImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后就可以使用了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span><span class="k">new</span> <span class="nc">MarketFactoryImpl</span><span class="o">();</span><span class="c1">//菜市场</span>
<span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span><span class="c1">//菜市场的荤菜</span>
<span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span><span class="c1">//菜市场的素菜</span>
</code></pre></div></div><p>看起来似乎也没什么特别的作用。</p><p>再写超市：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MeatDishesFromTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SupermarketImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>要使用，则只需要改动一下初始化的工厂就行了：即把<code class="language-plaintext highlighter-rouge">new MarketFactoryImpl();</code>改成<code class="language-plaintext highlighter-rouge">new SupermarketImpl();</code>。这下作用比较明显了。</p><p>还可以把这行也隐藏起来，这样用户就完全不会接触到具体实现了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span> <span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"超市"</span><span class="o">);</span>
        <span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span>
        <span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
    <span class="kd">static</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="nf">createFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"超市"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SupermarketImpl</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">MarketFactoryImpl</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未定义"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；</p><p>抽象工厂模式实现的关键点是<strong>定义工厂接口和产品接口</strong>，但如何实现工厂与产品本身需要留给具体的子类实现，<strong>客户端只和抽象工厂与抽象产品打交道</strong>。</p><hr /><p>完整代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span> <span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"超市"</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
        <span class="n">f</span><span class="o">=</span><span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span>
        <span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
    <span class="kd">static</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="nf">createFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"超市"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SupermarketImpl</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">MarketFactoryImpl</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未定义"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/*菜市场*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MarketFactoryImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*超市*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SupermarketImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="生成器">生成器</h3><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>生成器模式/建造者模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p><p>使用Builder是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p><p>以Markdown转HTML为例，直接编写一个完整的转换器比较困难，但如果针对类似下面的<strong>一行</strong>文本：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># this is a heading</span>
</code></pre></div></div><p>转换成HTML就很简单：</p><div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>this is a heading<span class="nt">&lt;/h1&gt;</span>
</code></pre></div></div><p>因此，把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p><ul><li>如果以<code class="language-plaintext highlighter-rouge">#</code>开头，使用<code class="language-plaintext highlighter-rouge">HeadingBuilder</code>转换；</li><li>如果以<code class="language-plaintext highlighter-rouge">&gt;</code>开头，使用<code class="language-plaintext highlighter-rouge">QuoteBuilder</code>转换；</li><li>如果以<code class="language-plaintext highlighter-rouge">---</code>开头，使用<code class="language-plaintext highlighter-rouge">HrBuilder</code>转换；</li><li>其余使用<code class="language-plaintext highlighter-rouge">ParagraphBuilder</code>转换。</li></ul><p>这个<code class="language-plaintext highlighter-rouge">HtmlBuilder</code>写出来如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HtmlBuilder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HeadingBuilder</span> <span class="n">headingBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HeadingBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">HrBuilder</span> <span class="n">hrBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HrBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">ParagraphBuilder</span> <span class="n">paragraphBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParagraphBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">QuoteBuilder</span> <span class="n">quoteBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QuoteBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toHtml</span><span class="o">(</span><span class="nc">String</span> <span class="n">markdown</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="nc">String</span> <span class="o">[]</span><span class="n">s</span><span class="o">=</span><span class="n">markdown</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">line</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"#"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">headingBuilder</span><span class="o">.</span><span class="na">buildHeading</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">quoteBuilder</span><span class="o">.</span><span class="na">buildQuote</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"---"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">hrBuilder</span><span class="o">.</span><span class="na">buildHr</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">paragraphBuilder</span><span class="o">.</span><span class="na">buildParagraph</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code class="language-plaintext highlighter-rouge">XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p><p>这样一来，只需要针对每一种类型编写不同的Builder。例如，针对以<code class="language-plaintext highlighter-rouge">#</code>开头的行，需要<code class="language-plaintext highlighter-rouge">HeadingBuilder</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HeadingBuilder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">buildHeading</span><span class="o">(</span><span class="nc">String</span> <span class="n">line</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">++;</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"&lt;h%d&gt;%s&lt;/h%d&gt;"</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">line</span><span class="o">.</span><span class="na">trim</span><span class="o">(),</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p><p><code class="language-plaintext highlighter-rouge">JavaMail</code>的<code class="language-plaintext highlighter-rouge">MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code class="language-plaintext highlighter-rouge">MimeMessage</code>。</p><p>很多时候，可以简化Builder模式，以链式调用的方式来创建对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"123"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"456"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"789"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div><p>生成器模式旨在通过一步一步构建复杂对象来创建对象。在使用 <code class="language-plaintext highlighter-rouge">JavaBean</code> 的 <code class="language-plaintext highlighter-rouge">set</code> 方法构建 <code class="language-plaintext highlighter-rouge">JavaBean</code> 时，虽然没有明确的构建步骤，但通过设置各个属性来构建对象的过程与生成器模式中逐步构建对象的思想相似。因此，可以将使用 <code class="language-plaintext highlighter-rouge">JavaBean</code> 的 <code class="language-plaintext highlighter-rouge">set</code> 方法构建 <code class="language-plaintext highlighter-rouge">JavaBean</code> 视为一种类似生成器模式的实现方式。</p><p><code class="language-plaintext highlighter-rouge">lombok</code>有个<code class="language-plaintext highlighter-rouge">@Builder</code> 可以使对象实现 builder 功能:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">build</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">a</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">b</span><span class="o">(</span><span class="s">"2"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">build</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="nd">@ToString</span>
<span class="nd">@Builder</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>生成的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">b</span><span class="o">;</span>
    <span class="no">A</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ABuilder</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ABuilder</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"A(a="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ABuilder</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">a</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">b</span><span class="o">;</span>

        <span class="nc">ABuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">ABuilder</span> <span class="nf">a</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">ABuilder</span> <span class="nf">b</span><span class="o">(</span><span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="no">A</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"A.ABuilder(a="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>内部生成器的<code class="language-plaintext highlighter-rouge">toString</code>会自动生成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">.</span><span class="na">ABuilder</span> <span class="n">b</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">a</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">b</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span><span class="c1">//A.ABuilder(a=1, b=2)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Builder</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="原型">原型</h3><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote><p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p><p>我们举个例子：如果我们已经有了一个<code class="language-plaintext highlighter-rouge">String[]</code>数组，想再创建一个一模一样的<code class="language-plaintext highlighter-rouge">String[]</code>数组，怎么写？</p><p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 原型:</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">original</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">,</span> <span class="s">"Banana"</span> <span class="o">};</span>
<span class="c1">// 新对象:</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div><p>对于普通类，如何实现原型拷贝？Java的<code class="language-plaintext highlighter-rouge">Object</code>提供了一个<code class="language-plaintext highlighter-rouge">clone()</code>方法，它的意图就是复制一个新的对象出来，需要实现一个<code class="language-plaintext highlighter-rouge">Cloneable</code>接口来标识一个对象是“可复制”的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="c1">// 复制新对象并返回:</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">std</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">score</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用的时候，因为<code class="language-plaintext highlighter-rouge">clone()</code>的方法签名是定义在<code class="language-plaintext highlighter-rouge">Object</code>中，返回类型也是<code class="language-plaintext highlighter-rouge">Object</code>，所以要强制转型，比较麻烦。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
<span class="nc">Object</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">student</span><span class="o">);</span><span class="c1">//test.Student@6f4a47c7</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">clone</span><span class="o">);</span><span class="c1">//test.Student@ae13544</span>
</code></pre></div></div><p>实际上，使用原型模式更好的方式是定义一个<code class="language-plaintext highlighter-rouge">copy()</code>方法，返回明确的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="c1">// 复制新对象并返回:</span>
    <span class="kd">public</span> <span class="nc">Student</span> <span class="nf">copy</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">std</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">score</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p><h3 id="单例">单例</h3><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p><p>因为这个类只有一个实例，因此，自然不能让调用方使用<code class="language-plaintext highlighter-rouge">new ClassName()</code>来创建实例了。所以，单例的构造方法必须是<code class="language-plaintext highlighter-rouge">private</code>，这样就防止了调用方自己创建实例。然后可以对外提供一个静态方法，返回一个固定的实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="c1">// 静态字段引用唯一实例:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>

    <span class="c1">// 通过静态方法返回实例:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// private构造方法保证外部无法实例化:</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//相同实例</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//相同实例</span>
</code></pre></div></div><p>或者直接把静态变量设置为<code class="language-plaintext highlighter-rouge">public</code>。</p><p>单例模式的实现方式很简单：</p><ol><li>只有<code class="language-plaintext highlighter-rouge">private</code>构造方法，确保外部无法实例化；</li><li>通过<code class="language-plaintext highlighter-rouge">private static</code>变量持有唯一实例，保证全局唯一性；</li><li>通过<code class="language-plaintext highlighter-rouge">public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li></ol><p>Java标准库有一些类就是单例，例如<code class="language-plaintext highlighter-rouge">Runtime</code>这个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Runtime</span> <span class="n">runtime</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">();</span>
</code></pre></div></div><h4 id="延迟加载">延迟加载</h4><p>即在调用方第一次调用<code class="language-plaintext highlighter-rouge">getInstance()</code>时才初始化全局唯一实例，类似这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>但这种写法在多线程中是错误的，必须对整个方法进行加锁，但加锁会严重影响并发性能，得不偿失。</p><hr /><h5 id="双重检查">双重检查</h5><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述描述似乎已经解决了我们面临的所有问题，但实际上，从 JVM 的角度讲，这些代码仍然可能发生错误。</p><p>对于 JVM 而言，它执行的是一个个 Java 指令。在 Java 指令中创建对象和赋值操作是分开进行的，也就是说<code class="language-plaintext highlighter-rouge">INSTANCE= new Singleton();</code>语句是分两步执行的。但是 JVM 并不保证这两个操作的先后顺序，即指令重排，也就是说有可能 JVM 会为新的 <code class="language-plaintext highlighter-rouge">Singleton</code> 实例分配空间，然后直接赋值给 <code class="language-plaintext highlighter-rouge">instance</code> 成员，然后再去初始化这个 <code class="language-plaintext highlighter-rouge">Singleton</code> 实例。这样就使出错成为了可能。</p><p>不过在<strong>JDK 5</strong>以及更高版本扩展了<code class="language-plaintext highlighter-rouge">volatile</code>的语义，以便系统将不允许<code class="language-plaintext highlighter-rouge">volatile</code>的写相对于任何之前的读或写重新排序，并且<code class="language-plaintext highlighter-rouge">volatile</code>的读也不能相对于任何后续的读或写重新排序。</p><p>因此，<strong>为<code class="language-plaintext highlighter-rouge">INSTANCE</code>变量添加<code class="language-plaintext highlighter-rouge">volatile</code>就修复了这个问题</strong>。</p><p>另外，如果<code class="language-plaintext highlighter-rouge">INSTANCE</code>变量是一个不可变对象，则也不用加<code class="language-plaintext highlighter-rouge">volatile</code>，就如同<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">float</code>一样，他们的赋值操作是原子的。（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">参见</a>）</p><hr /><h5 id="通过内部类实现">通过内部类实现</h5><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonContainer</span><span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 静态内部类只有在被使用时才会装载，静态属性只会在第一次装载时初始化
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nc">SingletonContainer</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</p><p>这样第一次调用<code class="language-plaintext highlighter-rouge">getInstance</code>的时候，JVM能够保证<code class="language-plaintext highlighter-rouge">INSTANCE</code>只被创建一次，并且会保证把赋值给<code class="language-plaintext highlighter-rouge">INSTANCE</code>的内存初始化完毕。此外该方法也只会在第一次调用的时候使用互斥机制。</p><p><code class="language-plaintext highlighter-rouge">INSTANCE</code> 是在第一次加载 <code class="language-plaintext highlighter-rouge">SingletonContainer</code> 类时被创建的，而 <code class="language-plaintext highlighter-rouge">SingletonContainer</code> 类则在调用 <code class="language-plaintext highlighter-rouge">getInstance</code> 方法的时候才会被加载，因此也实现了延迟加载。</p><hr /><p>要防止通过<strong>反射强行调用私有构造方法</strong>，可以在构造方法添加代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">SingletonContainer</span><span class="o">.</span><span class="na">INSTANCE</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>反射测试：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Singleton</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">();</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span><span class="c1">//java.lang.RuntimeException: !</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">singleton</span><span class="o">);</span>
</code></pre></div></div><p>正常调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//test.Singleton@ae13544</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//test.Singleton@ae13544</span>
</code></pre></div></div><hr /><h4 id="序列化破坏单例">序列化破坏单例</h4><p>单例对象创建好之后，有时需要将对象序列化然后写入磁盘，在需要时从磁盘中读取对象并加载至内存，反序列化后的对象会重新分配内存，如果序列化的目标对象恰好是单例对象，就会破坏单例模式。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">Singleton</span> <span class="n">s2</span><span class="o">;</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="n">s2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//test.Singleton@7494f96a</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//test.Singleton@37883b97</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>添加一个<code class="language-plaintext highlighter-rouge">readResolve()</code>,就能保证反序列化是同一个实例了</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在 Java 的序列化中，当对象被序列化时，如果类中定义了 <code class="language-plaintext highlighter-rouge">readResolve</code> 方法，并且该方法返回一个对象，那么在反序列化时<strong>会调用该方法来获取对象</strong>，而<strong>不是通过从流中反序列化创建一个新的对象</strong>。</p><p>这意味着 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法可以用来控制反序列化过程中返回的对象，<strong>可以在方法中返回任何想要的对象，而不受反序列化的影响</strong>。如果一个类写了 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法，并且在方法中返回了特定的对象，那么反序列化过程<strong>就会返回这个方法中指定的对象</strong>，而<strong>不会</strong>从文件中重新构造对象。示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"序列化前"</span><span class="o">;</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//test.Singleton@561b6512</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s2</span><span class="o">;</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="n">s2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//test.Singleton@c86b9e3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//null</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>先运行<code class="language-plaintext highlighter-rouge">test1()</code>,然后等JVM关闭后重新运行<code class="language-plaintext highlighter-rouge">test2()</code>,模拟序列化的实际运用场景，这个场景下内存地址肯定不一样，但后设置的<code class="language-plaintext highlighter-rouge">name</code>值也丢了。</p><p>实际上，<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法的作用是控制对象的反序列化过程，可以用来确保反序列化后的对象符合特定的要求，或者实现单例模式等。</p><hr /><p>那么我们保存的<code class="language-plaintext highlighter-rouge">s.obj</code>序列化文件就这么废了吗？也不一定，<strong>序列化仅涉及对象的状态（即实例变量）</strong>，不包括类的方法。序列化的主要目的是保存对象的状态，以便在稍后可以将其完全恢复为原始状态。把<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法注释掉不就好了。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"序列化前"</span><span class="o">;</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//Singleton{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Singleton{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>运行<code class="language-plaintext highlighter-rouge">test1()</code>生成<code class="language-plaintext highlighter-rouge">s.obj</code>。删除<code class="language-plaintext highlighter-rouge">readResolve</code>，<code class="language-plaintext highlighter-rouge">运行test2()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//Singleton{name='序列化前'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(((</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">x</span><span class="o">).</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Singleton{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>正常恢复，没有问题，那么试试删除<code class="language-plaintext highlighter-rouge">public String toString()</code>，提示：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.io.InvalidClassException: test.Singleton; local class incompatible: stream classdesc serialVersionUID = 5155019565252345970, local class serialVersionUID = -6864115338217441473
</code></pre></div></div><p>改动太大了，改变了<code class="language-plaintext highlighter-rouge">serialVersionUID</code>，那么显示的在类里指定：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">5155019565252345970L</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>再运行<code class="language-plaintext highlighter-rouge">test2()</code>,正常反序列化，只是这次<code class="language-plaintext highlighter-rouge">toString</code>没有了：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test.Singleton@79d8407f
序列化前
</code></pre></div></div><p>实际上，非重写的方法可以随便添加修改删除，而重写的方法不能动，动了就会导致<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号。（显示指定<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号就好了）</p><hr /><h4 id="使用枚举">使用枚举</h4><p>Java保证枚举类的每个枚举都是单例，所以只需要编写一个只有一个枚举的类即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">World</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
	<span class="no">INSTANCE</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"world"</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code class="language-plaintext highlighter-rouge">World</code>类在调用方看来就可以这么用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</code></pre></div></div><p>使用枚举实现Singleton也避免了即序列化和反序列化会绕过普通类的<code class="language-plaintext highlighter-rouge">private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p><p>枚举在序列化和反序列化过程中<strong>会丢失枚举常量中的普通字段的值</strong>。这是因为枚举在序列化时只保留了枚举常量的名称，并没有保存其他字段的状态。在反序列化时，只会根据枚举常量的名称重新构建枚举常量，而普通字段的值需要在程序中重新设置。即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"序列化前"</span><span class="o">);</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span><span class="c1">//World{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//序列化前</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">World</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">World</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//World{name='null'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//null</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">World</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
    <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"World{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>用有参构造器设置就好了，虽然并没有改变问题的根本，也是个曲线的好办法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span><span class="c1">//World{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">World</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">World</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//World{name='null'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//null</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">World</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
    <span class="no">INSTANCE</span><span class="o">(</span><span class="s">"序列化前"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nc">World</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"World{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而枚举天然就不能使用反射调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">World</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">World</span> <span class="n">world</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span><span class="c1">//java.lang.NoSuchMethodException: test.World.&lt;init&gt;(java.lang.String)</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">world</span><span class="o">);</span>
</code></pre></div></div><p>找不到指定类型的构造方法，看看<code class="language-plaintext highlighter-rouge">java.lang.Enum</code>的源码，只有：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="nf">Enum</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ordinal</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ordinal</span> <span class="o">=</span> <span class="n">ordinal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>唯一构造函数。程序员无法调用此构造函数。它供编译器发出的代码使用，以响应枚举类型声明。形参:</p><ul><li><code class="language-plaintext highlighter-rouge">name</code> – - 此枚举常量的名称，它是用于声明它的标识符。</li><li><code class="language-plaintext highlighter-rouge">ordinal</code> – - 此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）</li></ul><p>那么改成这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">World</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">World</span> <span class="n">world</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">"枚举名"</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="s">"test"</span><span class="o">);</span><span class="c1">//java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">world</span><span class="o">);</span>
</code></pre></div></div><p>异常位置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@CallerSensitive</span>
<span class="nd">@ForceInline</span> <span class="c1">// to ensure Reflection.getCallerClass optimization</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">newInstance</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">initargs</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InstantiationException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span><span class="o">,</span>
           <span class="nc">IllegalArgumentException</span><span class="o">,</span> <span class="nc">InvocationTargetException</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">override</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="nc">Reflection</span><span class="o">.</span><span class="na">getCallerClass</span><span class="o">();</span>
        <span class="n">checkAccess</span><span class="o">(</span><span class="n">caller</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">modifiers</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">clazz</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()</span> <span class="o">&amp;</span> <span class="nc">Modifier</span><span class="o">.</span><span class="na">ENUM</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Cannot reflectively create enum objects"</span><span class="o">);</span>
    <span class="nc">ConstructorAccessor</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">constructorAccessor</span><span class="o">;</span>   <span class="c1">// read volatile</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ca</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">acquireConstructorAccessor</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="no">T</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">ca</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">initargs</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">inst</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p>什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code class="language-plaintext highlighter-rouge">new</code>操作符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span> <span class="c1">// 表示一个单例组件</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p><h2 id="结构型模式">结构型模式</h2><p>结构型模式主要关注如何组合不同的对象以获得更好、更灵活的结构。尽管面向对象的继承机制提供了基本的子类扩展父类功能的能力，但结构型模式不仅限于简单的继承，而更多地通过组合和运行时的动态组合来实现更灵活的功能。</p><p>主要关注如何组合类或对象以获得更大的结构，并且提供了一种方式来定义类之间的关系，以确保系统的某一部分变化不会影响其他部分。</p><p>结构型模式包括以下几种常见的模式：</p><ol><li><strong>适配器模式（Adapter Pattern）</strong>：将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li><strong>桥接模式（Bridge Pattern）</strong>：将抽象部分与它的实现部分<strong>分离</strong>，使它们可以独立地变化。</li><li><strong>组合模式（Composite Pattern）</strong>：将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</li><li><strong>装饰器模式（Decorator Pattern）</strong>：动态地给一个对象添加一些额外的职责，就<strong>增加功能</strong>来说，装饰模式比生成子类更为灵活。</li><li><strong>外观模式（Facade Pattern）</strong>：为子系统中的一组接口提供一个统一的接口，外观模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</li><li><strong>享元模式（Flyweight Pattern）</strong>：运用共享技术有效地支持大量细粒度的对象。</li><li><strong>代理模式（Proxy Pattern）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li></ol><p>适配器就是转换兼容，桥接就是拆分可复用部分，组合就是树形结构，装饰器就是在不改变类的情况下增强类功能，外观就是封装，享元就是缓存不变类，代理模式就是控制限制类。</p><h3 id="适配器">适配器</h3><blockquote><p>将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，则中间需要一个适配器转换。将下面的类传入线程是不行的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">a</span><span class="o">);</span><span class="c1">//没有实现Runnable接口，所以不能向上转型为Runnable</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>办法一是改写<code class="language-plaintext highlighter-rouge">A</code>类，把实现的<code class="language-plaintext highlighter-rouge">Callable</code>改为<code class="language-plaintext highlighter-rouge">Runnable</code>，但这样做不好，因为<code class="language-plaintext highlighter-rouge">A</code>有可能在其他地方作为<code class="language-plaintext highlighter-rouge">Callable</code>被引用，改写<code class="language-plaintext highlighter-rouge">Task</code>的接口，会导致其他正常工作的代码无法编译。</p><p>另一个办法不用改写<code class="language-plaintext highlighter-rouge">A</code>类，而是用一个Adapter，把这个<code class="language-plaintext highlighter-rouge">Callable</code>接口“变成”<code class="language-plaintext highlighter-rouge">Runnable</code>接口，这样，就可以正常编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">CallableToRunnableAdapter</span><span class="o">(</span><span class="n">a</span><span class="o">));</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>这个<code class="language-plaintext highlighter-rouge">CallableToRunnableAdapter</code>类就是Adapter，它接收一个<code class="language-plaintext highlighter-rouge">Callable</code>，输出一个<code class="language-plaintext highlighter-rouge">Runnable</code>。实现非常简单：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CallableToRunnableAdapter</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CallableToRunnableAdapter</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>编写一个Adapter的步骤如下：</p><ol><li>实现目标接口，这里是<code class="language-plaintext highlighter-rouge">Runnable</code>；</li><li>内部持有一个待转换接口的引用，这里是通过字段持有<code class="language-plaintext highlighter-rouge">Callable</code>接口；</li><li>在目标接口的实现方法内部，调用待转换接口的方法。</li></ol><p>这样一来，Thread就可以接收这个<code class="language-plaintext highlighter-rouge">RunnableAdapter</code>，因为它实现了<code class="language-plaintext highlighter-rouge">Runnable</code>接口。<code class="language-plaintext highlighter-rouge">Thread</code>作为调用方，它会调用<code class="language-plaintext highlighter-rouge">RunnableAdapter</code>的<code class="language-plaintext highlighter-rouge">run()</code>方法，在这个<code class="language-plaintext highlighter-rouge">run()</code>方法内部，又调用了<code class="language-plaintext highlighter-rouge">Callable</code>的<code class="language-plaintext highlighter-rouge">call()</code>方法，相当于<code class="language-plaintext highlighter-rouge">Thread</code>通过一层转换，间接调用了<code class="language-plaintext highlighter-rouge">Callable</code>的<code class="language-plaintext highlighter-rouge">call()</code>方法。</p><p>使用lambda也是可以的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">a</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>从某种程度上说，这确实可以被看作是一种简单的转换器思想，通过实现 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口，将 <code class="language-plaintext highlighter-rouge">Callable</code> 接口的 <code class="language-plaintext highlighter-rouge">call</code> 方法转换成了 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口的 <code class="language-plaintext highlighter-rouge">run</code> 方法，使得原本的 <code class="language-plaintext highlighter-rouge">Callable</code> 对象 <code class="language-plaintext highlighter-rouge">a</code> 可以在 <code class="language-plaintext highlighter-rouge">Thread</code> 中被使用。</p><p>虽然这种用法不是传统意义上的转换器模式，但从某种程度上可以看作是一种类似的思想，即通过接口或类的适配来实现不同对象之间的协同工作。</p><p>如果不局限与接口或类的适配，那么实例化类也沾点转换器思想，因为将数据整合“转换“为了类实例。</p><p>向上转型和向下转型在某种程度上也可以被视为适配器思想的一种体现。向上转型是指将子类对象转换为父类对象的过程，这样做可以使得子类对象可以被当做父类对象对待，从而实现多态性。这种转型可以被看作是一种接口的适配，将子类对象适配成了父类对象。</p><p>向下转型是指将父类对象转换为子类对象的过程。这种转型可能涉及到类型检查和转换，以确保父类对象确实可以被转换为子类对象。向下转型也可以被视为一种适配器思想，将父类对象适配成了子类对象，以便对其进行特定的操作或方法调用。</p><hr /><p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code class="language-plaintext highlighter-rouge">String[]</code>，但是需要<code class="language-plaintext highlighter-rouge">List</code>接口时，可以用一个Adapter：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">exist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"Good"</span><span class="o">,</span> <span class="s">"morning"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"and"</span><span class="o">,</span> <span class="s">"Alice"</span><span class="o">};</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">exist</span><span class="o">));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">List&lt;T&gt; Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code class="language-plaintext highlighter-rouge">List</code>。</p><p>假设有一个<code class="language-plaintext highlighter-rouge">InputStream</code>，但希望调用<code class="language-plaintext highlighter-rouge">readText(Reader)</code>这个方法，但它的参数类型是<code class="language-plaintext highlighter-rouge">Reader</code>而不是<code class="language-plaintext highlighter-rouge">InputStream</code>，怎么办？当然是使用适配器，把<code class="language-plaintext highlighter-rouge">InputStream</code>“变成”<code class="language-plaintext highlighter-rouge">Reader</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newInputStream</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"/path/to/file"</span><span class="o">));</span>
<span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="n">readText</span><span class="o">(</span><span class="n">reader</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">InputStreamReader</code>就是Java标准库提供的<code class="language-plaintext highlighter-rouge">Adapter</code>，它负责把一个<code class="language-plaintext highlighter-rouge">InputStream</code>适配为<code class="language-plaintext highlighter-rouge">Reader</code>。类似的还有<code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>。</p><p>除了前面提到的对象适配器和类适配器之外，适配器思想还可以体现在以下几个方面：</p><ol><li><strong>接口适配器模式（Interface Adapter Pattern）</strong>：当一个接口中定义了许多方法，但只有部分方法需要被实现时，可以创建一个抽象类实现该接口，并为接口中的每个方法提供一个空实现。这样在需要使用该接口时，只需要继承这个抽象类，重写需要的方法即可，避免了在实现类中实现所有方法的繁琐性。</li><li><strong>数据适配器</strong>：将一个数据格式转换为另一个数据格式的过程可以看作是一种适配器思想的应用。例如，将一个JSON格式的数据转换为XML格式的数据，或者将一个数据结构转换为另一个数据结构以适应不同的应用场景。</li><li><strong>协议适配器</strong>：在网络通信中，不同的设备或系统可能使用不同的通信协议。协议适配器用于将一个通信协议转换为另一个通信协议，以实现不同设备或系统之间的通信。</li><li><strong>电源适配器</strong>：在不同国家或地区，电源插头的形状和电压标准可能不同。电源适配器用于将一个电源插头转换为另一个电源插头，以适应不同地区的电源标准。</li></ol><h3 id="桥接">桥接</h3><blockquote><p>将抽象部分与它的实现<strong>部分分离</strong>，使它们都可以独立地变化。</p></blockquote><p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p><pre><code class="language-ascii">                   ┌───────┐
                   │  Car  │
                   └───────┘
                       ▲
    ┌──────────────────┼───────────────────┐
    │                  │                   │
┌───────┐          ┌───────┐          ┌───────┐
│BigCar │          │TinyCar│          │BossCar│
└───────┘          └───────┘          └───────┘
    ▲                  ▲                  ▲
    │                  │                  │
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │
      └───────────────┘  └───────────────┘  └───────────────┘
</code></pre><p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p><p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p><p>在桥接模式中，首先把<code class="language-plaintext highlighter-rouge">Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。</p><p>首先定义抽象类<code class="language-plaintext highlighter-rouge">Car</code>，它引用一个<code class="language-plaintext highlighter-rouge">Engine</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="c1">// 引用Engine:</span>
    <span class="kd">protected</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>紧接着，在一个“修正”的抽象类<code class="language-plaintext highlighter-rouge">RefinedCar</code>中定义一些<strong>额外操作</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RefinedCar</span> <span class="kd">extends</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">RefinedCar</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"驾驶 "</span> <span class="o">+</span> <span class="n">getBrand</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 汽车..."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">getBrand</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>这样一来，最终的不同品牌继承自<code class="language-plaintext highlighter-rouge">RefinedCar</code>，例如<code class="language-plaintext highlighter-rouge">BossCar</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">BossCar</span> <span class="kd">extends</span> <span class="nc">RefinedCar</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BossCar</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getBrand</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Boss"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而针对每一种引擎，继承自<code class="language-plaintext highlighter-rouge">Engine</code>，例如<code class="language-plaintext highlighter-rouge">HybridEngine</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HybridEngine</span> <span class="kd">implements</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"启动混合引擎"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的<code class="language-plaintext highlighter-rouge">Car</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RefinedCar</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BossCar</span><span class="o">(</span><span class="k">new</span> <span class="nc">HybridEngine</span><span class="o">());</span>
<span class="n">car</span><span class="o">.</span><span class="na">drive</span><span class="o">();</span>
</code></pre></div></div><p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code class="language-plaintext highlighter-rouge">Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code class="language-plaintext highlighter-rouge">RefinedCar</code>派生一个子类，任何<code class="language-plaintext highlighter-rouge">RefinedCar</code>的子类都可以和任何一种<code class="language-plaintext highlighter-rouge">Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p><pre><code class="language-ascii">       ┌───────────┐
       │    Car    │
       └───────────┘
             ▲
             │
       ┌───────────┐       ┌─────────┐
       │RefinedCar │ ─ ─ ─&gt;│ Engine  │
       └───────────┘       └─────────┘
             ▲                  ▲
    ┌────────┼────────┐         │ ┌──────────────┐
    │        │        │         ├─│  FuelEngine  │
┌───────┐┌───────┐┌───────┐     │ └──────────────┘
│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐
└───────┘└───────┘└───────┘     ├─│ElectricEngine│
                                │ └──────────────┘
                                │ ┌──────────────┐
                                └─│ HybridEngine │
                                  └──────────────┘
</code></pre><p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p><h3 id="组合">组合</h3><blockquote><p>将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p><p>在组合模式中，有两种主要的对象：叶子节点和容器节点。叶子节点表示树中的最终节点，它没有子节点；容器节点表示包含子节点的节点，它可以包含叶子节点和其他容器节点。</p><p>通过使用组合模式，可以将单个对象和组合对象都视为相同类型的对象，从而可以统一处理它们。例如，无论是操作单个文件还是操作整个文件夹（包含多个文件和文件夹），客户端都可以使用相同的方式来进行操作，这样就简化了客户端的代码逻辑。</p><p>总的来说，组合模式可以构建具有层次结构的对象，并且可以统一处理这些对象，提高代码的灵活性和可维护性。</p><p>在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。要以树的结构表示XML，先抽象出节点<code class="language-plaintext highlighter-rouge">Node</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">// 添加一个节点为子节点:</span>
    <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">);</span>
    <span class="c1">// 获取子节点:</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">();</span>
    <span class="c1">// 输出为XML:</span>
    <span class="nc">String</span> <span class="nf">toXml</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>对于一个<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>这样的节点，称之为<code class="language-plaintext highlighter-rouge">ElementNode</code>，它可以作为容器包含多个子节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ElementNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nf">ElementNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">start</span> <span class="o">=</span> <span class="s">"&lt;"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"&gt;\n"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">end</span> <span class="o">=</span> <span class="s">"&lt;/"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"&gt;"</span><span class="o">;</span>
        <span class="nc">StringJoiner</span> <span class="n">sj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringJoiner</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">sj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">toXml</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">sj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>对于普通文本，把它看作<code class="language-plaintext highlighter-rouge">TextNode</code>，它没有子节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TextNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">TextNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">text</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>此外，还可以有注释节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CommentNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CommentNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"&lt;!-- "</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s">" --&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>通过<code class="language-plaintext highlighter-rouge">ElementNode</code>、<code class="language-plaintext highlighter-rouge">TextNode</code>和<code class="language-plaintext highlighter-rouge">CommentNode</code>，就可以构造出一颗树：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"school"</span><span class="o">);</span>
<span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"classA"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Tom"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">)));</span>
<span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"classB"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Grace"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">CommentNode</span><span class="o">(</span><span class="s">"comment..."</span><span class="o">)));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">toXml</span><span class="o">());</span>
</code></pre></div></div><p>最后通过<code class="language-plaintext highlighter-rouge">root</code>节点输出的XML如下：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;school&gt;
&lt;classA&gt;
Tom
Alice
&lt;/classA&gt;
&lt;classB&gt;
Bob
Grace
&lt;!-- comment... --&gt;
&lt;/classB&gt;
&lt;/school&gt;
</code></pre></div></div><p>使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p><pre><code class="language-ascii">             ┌───────────┐
             │   Node    │
             └───────────┘
                   ▲
      ┌────────────┼────────────┐
      │            │            │
┌───────────┐┌───────────┐┌───────────┐
│ElementNode││ TextNode  ││CommentNode│
└───────────┘└───────────┘└───────────┘
</code></pre><p>作为容器节点的<code class="language-plaintext highlighter-rouge">ElementNode</code>又可以添加任意个<code class="language-plaintext highlighter-rouge">Node</code>，这样就可以构成层级结构。</p><p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p><p>文件形式的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 创建文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File1.txt"</span><span class="o">);</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File2.txt"</span><span class="o">);</span>

        <span class="c1">// 创建文件夹并添加文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">folder1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Folder1"</span><span class="o">);</span>
        <span class="n">folder1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file1</span><span class="o">);</span>
        <span class="n">folder1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file2</span><span class="o">);</span>

        <span class="c1">// 创建文件夹并添加文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">folder2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Folder2"</span><span class="o">);</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File3.txt"</span><span class="o">);</span>
        <span class="n">folder2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file3</span><span class="o">);</span>

        <span class="c1">// 将文件夹添加到根文件夹</span>
        <span class="nc">FileSystemComponent</span> <span class="n">rootFolder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Root"</span><span class="o">);</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder1</span><span class="o">);</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder2</span><span class="o">);</span>

        <span class="c1">// 打印整个文件系统</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">FileSystemComponent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">File</span> <span class="kd">extends</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">File</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"File: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Folder</span> <span class="kd">extends</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">FileSystemComponent</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">Folder</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"Folder: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span> <span class="o">:</span> <span class="n">children</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">component</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"\t"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="装饰器">装饰器</h3><blockquote><p>动态地给一个对象<strong>添加一些额外的职责</strong>。就增加功能来说，相比生成子类更为灵活。</p></blockquote><p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p><p>在Java标准库中，<code class="language-plaintext highlighter-rouge">InputStream</code>是抽象类，<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">ServletInputStream</code>、<code class="language-plaintext highlighter-rouge">Socket.getInputStream()</code>这些<code class="language-plaintext highlighter-rouge">InputStream</code>都是最终数据源。</p><p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。</p><p>Decorator模式的目的就是一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得想要的功能。</p><p>例如：给<code class="language-plaintext highlighter-rouge">FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建原始的数据源:</span>
<span class="nc">InputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">);</span>
<span class="c1">// 增加缓冲功能:</span>
<span class="nc">InputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
<span class="c1">// 增加解压缩功能:</span>
<span class="nc">InputStream</span> <span class="n">gis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>
</code></pre></div></div><p>或者一次性写成这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span> <span class="c1">// 第二层装饰</span>
                        <span class="k">new</span> <span class="nf">BufferedInputStream</span><span class="o">(</span> <span class="c1">// 第一层装饰</span>
                            <span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">)</span> <span class="c1">// 核心功能</span>
                        <span class="o">));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>和<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>实际上都是从<code class="language-plaintext highlighter-rouge">FilterInputStream</code>继承的，这个<code class="language-plaintext highlighter-rouge">FilterInputStream</code>就是一个抽象的Decorator。把Decorator模式画出来如下：</p><pre><code class="language-ascii">             ┌───────────┐
             │ Component │
             └───────────┘
                   ▲
      ┌────────────┼─────────────────┐
      │            │                 │
┌───────────┐┌───────────┐     ┌───────────┐
│ComponentA ││ComponentB │...  │ Decorator │
└───────────┘└───────────┘     └───────────┘
                                     ▲
                              ┌──────┴──────┐
                              │             │
                        ┌───────────┐ ┌───────────┐
                        │DecoratorA │ │DecoratorB │...
                        └───────────┘ └───────────┘
</code></pre><p>最顶层的<code class="language-plaintext highlighter-rouge">Component</code>是接口，对应到IO的就是<code class="language-plaintext highlighter-rouge">InputStream</code>这个抽象类。<code class="language-plaintext highlighter-rouge">ComponentA</code>、<code class="language-plaintext highlighter-rouge">ComponentB</code>是实际的子类，对应到IO的就是<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code class="language-plaintext highlighter-rouge">FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>、<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>等。</p><p>Decorator模式实际上把核心功能和附加功能给分开了。核心功能指<code class="language-plaintext highlighter-rouge">FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。</p><p>如果要新增核心功能，就增加Component的子类，例如<code class="language-plaintext highlighter-rouge">ByteInputStream</code>。如果要增加附加功能，就增加Decorator的子类，例如<code class="language-plaintext highlighter-rouge">CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p><p>如果要设计完整的Decorator模式，应该如何设计？</p><p>假设需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p><p>首先，仍然需要定义顶层接口<code class="language-plaintext highlighter-rouge">TextNode</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="c1">// 设置text:</span>
    <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">);</span>
    <span class="c1">// 获取text:</span>
    <span class="nc">String</span> <span class="nf">getText</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>对于核心节点，例如<code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>，它需要从<code class="language-plaintext highlighter-rouge">TextNode</code>直接继承：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpanNode</span> <span class="kd">implements</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"&lt;span&gt;"</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s">"&lt;/span&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为了实现Decorator模式，需要有一个抽象的Decorator类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">NodeDecorator</span> <span class="kd">implements</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="c1">//注意这里也实现了TextNode接口</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="nc">TextNode</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="nf">NodeDecorator</span><span class="o">(</span><span class="nc">TextNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这个<code class="language-plaintext highlighter-rouge">NodeDecorator</code>类的核心是持有一个<code class="language-plaintext highlighter-rouge">TextNode</code>，即将要把功能附加到的<code class="language-plaintext highlighter-rouge">TextNode</code>实例。接下来就可以写一个加粗功能：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoldDecorator</span> <span class="kd">extends</span> <span class="nc">NodeDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BoldDecorator</span><span class="o">(</span><span class="nc">TextNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//重写加了内容</span>
        <span class="k">return</span> <span class="s">"&lt;b&gt;"</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span> <span class="o">+</span> <span class="s">"&lt;/b&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TextNode</span> <span class="n">n1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SpanNode</span><span class="o">();</span><span class="c1">//外层&lt;span&gt;</span>
<span class="n">n1</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span><span class="c1">//正常修改text</span>
<span class="nc">TextNode</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoldDecorator</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span><span class="c1">//getText时加一个&lt;b&gt;包围原内容</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n2</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//调用栈：n2.getText()-&gt;n1.getText()</span>

<span class="nc">TextNode</span> <span class="n">n3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoldDecorator</span><span class="o">(</span><span class="n">n2</span><span class="o">);</span><span class="c1">//getText时加一个&lt;b&gt;包围原内容</span>
<span class="c1">//调用栈：n3.getText()-&gt;n2.getText()-&gt;n1.getText()</span>
<span class="c1">// n1返回text内容，然后n2加&lt;b&gt;返回，然后n1加&lt;b&gt;返回</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n3</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//&lt;b&gt;&lt;b&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/b&gt;&lt;/b&gt;</span>
<span class="c1">//调用栈：n3.setText()-&gt;n2.setText()-&gt;n1.setText()-&gt;this.text = text;</span>
<span class="n">n3</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"HI"</span><span class="o">);</span><span class="c1">//只修改了text</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n3</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//&lt;b&gt;&lt;b&gt;&lt;span&gt;HI&lt;/span&gt;&lt;/b&gt;&lt;/b&gt;</span>
</code></pre></div></div><p>类似的，可以继续加<code class="language-plaintext highlighter-rouge">ItalicDecorator</code>、<code class="language-plaintext highlighter-rouge">UnderlineDecorator</code>等。</p><hr /><p><strong>装饰器与桥接模式</strong></p><p>装饰器和桥接的目的都是降低继承中衍生的子类的数量。</p><p>桥接是通过把一个组件及其子类作为另一总体的字段引用实现功能组合，也可以用多个组件来拼合总体。桥接的子类是负责总体的局部功能，是构成性的，是必要的。</p><p>装饰器则在大类下创建一个装饰器的子族，不管是主要部件还是装饰器都隶属于这个大类，所以装饰器可以不断嵌套。装饰器则是对已经具有了完整功能的总体进行修饰，是附加性的，是可选的。</p><h3 id="外观">外观</h3><blockquote><p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</p></blockquote><p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p><p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p><p>以注册公司为例，假设注册公司需要三步：</p><ol><li>向工商局申请公司营业执照；</li><li>在银行开设账户；</li><li>在税务局开设纳税号。</li></ol><p>以下是三个系统的接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 工商注册:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdminOfIndustry</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Company</span> <span class="nf">register</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 银行开户:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bank</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">openAccount</span><span class="o">(</span><span class="nc">String</span> <span class="n">companyId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 纳税登记:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Taxation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">applyTaxCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">companyId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Facade</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Company</span> <span class="nf">openCompany</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Company</span> <span class="n">c</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">admin</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">bankAccount</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">bank</span><span class="o">.</span><span class="na">openAccount</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">c</span><span class="o">.</span><span class="na">setBankAccount</span><span class="o">(</span><span class="n">bankAccount</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">taxCode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">taxation</span><span class="o">.</span><span class="na">applyTaxCode</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">c</span><span class="o">.</span><span class="na">setTaxCode</span><span class="o">(</span><span class="n">taxCode</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Company</span> <span class="n">c</span> <span class="o">=</span> <span class="n">facade</span><span class="o">.</span><span class="na">openCompany</span><span class="o">(</span><span class="s">"Facade Software Ltd."</span><span class="o">);</span>
</code></pre></div></div><p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code class="language-plaintext highlighter-rouge">RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p><p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p><p>也就是说，我如果需要实现一个功能，比如打印水仙花数，我可以直接在main里写，也可以封装打印水仙花数为一个函数，然后通过主函数调用这个函数。这就是一种简单的外观模式的应用。外观模式的核心思想就是封装复杂的逻辑，提供一个简单的接口给客户端使用，从而简化客户端的操作。</p><h3 id="享元">享元</h3><blockquote><p>运用共享技术有效地支持大量细粒度的对象。</p></blockquote><p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就<strong>没有必要</strong>，直接向调用方返回一个<strong>共享的实例</strong>就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p><p>享元模式在Java标准库中有很多应用。包装类型如<code class="language-plaintext highlighter-rouge">Byte</code>、<code class="language-plaintext highlighter-rouge">Integer</code>都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以<code class="language-plaintext highlighter-rouge">Integer</code>为例，如果我们通过<code class="language-plaintext highlighter-rouge">Integer.valueOf()</code>这个静态工厂方法创建<code class="language-plaintext highlighter-rouge">Integer</code>实例，当传入的<code class="language-plaintext highlighter-rouge">int</code>范围在<code class="language-plaintext highlighter-rouge">-128</code>~<code class="language-plaintext highlighter-rouge">+127</code>之间时，会直接返回缓存的<code class="language-plaintext highlighter-rouge">Integer</code>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">n2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="o">);</span> <span class="c1">// true</span>
</code></pre></div></div><p>对于<code class="language-plaintext highlighter-rouge">Byte</code>来说，因为它一共只有256个状态，所以，通过<code class="language-plaintext highlighter-rouge">Byte.valueOf()</code>创建的<code class="language-plaintext highlighter-rouge">Byte</code>实例，全部都是缓存对象。</p><p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的<strong>复用</strong>。</p><p>总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p><p>在实际应用中，<strong>享元模式主要应用于缓存</strong>，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p><p>以<code class="language-plaintext highlighter-rouge">Student</code>为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="c1">// 持有缓存:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Student</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 静态工厂方法:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Student</span> <span class="nf">create</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
        <span class="c1">// 先查找缓存:</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">std</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 未找到,创建新对象:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"create new Student(%s, %s)"</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">));</span>
            <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
            <span class="c1">// 放入缓存:</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">std</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 缓存中存在:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"return cached Student(%s, %s)"</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="na">id</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="na">name</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在实际应用中，经常使用成熟的缓存库，例如<a href="https://github.com/google/guava">Guava</a>的<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java">Cache</a>，因为它提供了最大缓存数量限制、定时过期等实用功能。</p><p>享元模式的设计思想是尽量复用已创建的对象，常用于工厂方法内部的优化。</p><p>单例模式是不允许创建新实例，只能使用一个实例。</p><p>而享元要求<strong>实例不变</strong>，才能把“创建一个新实例”的操作给优化成“直接返回一个缓存的实例”。</p><h3 id="代理">代理</h3><blockquote><p>为其他对象提供一种代理以<strong>控制</strong>对这个对象的访问。</p></blockquote><p>代理模式，即Proxy，它和Adapter模式很类似。Adapter模式，它用于把A接口转换为B接口，即做兼容：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BAdapter</span> <span class="kd">implements</span> <span class="no">B</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">BAdapter</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">AProxy</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这是原始的，可以加功能，比如权限判断来限制访问，打印日志：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">aProxy</span><span class="o">=</span><span class="k">new</span> <span class="nc">AProxy</span><span class="o">(</span><span class="k">new</span> <span class="nc">AImpl</span><span class="o">());</span>
        <span class="n">aProxy</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">a</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AImpl</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"原功能"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">AProxy</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用前"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用后"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为什么不把权限检查的功能直接写到目标实例的内部？因为编写代码的原则有：</p><ul><li>职责清晰：一个类只负责一件事；</li><li>易于测试：一次只测一个功能。</li></ul><p>用Proxy实现这个权限检查，可以获得更清晰、更简洁的代码：</p><ul><li><code class="language-plaintext highlighter-rouge">A</code>接口：只定义接口；</li><li><code class="language-plaintext highlighter-rouge">AImpl</code>类：只实现A接口的业务逻辑；</li><li><code class="language-plaintext highlighter-rouge">AProxy</code>类：只实现A接口的日志输出代理。</li></ul><p>如果希望编写其他类型的代理，可以继续增加，一个套一个。</p><p>实际上权限检查、打印日志只是代理模式的一种应用。Proxy还广泛应用在：</p><p><strong>远程代理</strong></p><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p><p><strong>虚代理</strong></p><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p><p>例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">I</span> <span class="n">a</span><span class="o">=</span><span class="no">I</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"得到对象"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kd">static</span> <span class="no">I</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">I</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">private</span> <span class="no">I</span> <span class="n">i</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
                    <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">i</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">();</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"打印"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>再加上队列复用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">r</span><span class="o">=()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
                <span class="k">try</span><span class="o">(</span><span class="no">I</span> <span class="n">a</span><span class="o">=</span><span class="no">I</span><span class="o">.</span><span class="na">getInstance</span><span class="o">()){</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                    <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="no">I</span><span class="o">.</span><span class="na">idleQueue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span> <span class="kd">extends</span> <span class="nc">AutoCloseable</span><span class="o">{</span>
    <span class="cm">/*空闲队列，线程安全的*/</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">I</span><span class="o">&gt;</span> <span class="n">idleQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;&gt;(</span><span class="mi">100</span><span class="o">);</span>
    <span class="cm">/**
     * 虚代理
     * @return 虚代理
     */</span>
    <span class="kd">static</span> <span class="no">I</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*复用空闲的A代理*/</span>
        <span class="no">I</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idleQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="nc">Aproxy</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">();</span>
<span class="o">}</span>
 <span class="kd">class</span> <span class="nc">Aproxy</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="kd">private</span> <span class="no">I</span> <span class="n">i</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*调用方法时才实例化*/</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">i</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*丢回空闲队列*/</span>
        <span class="n">idleQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"假装关闭了"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"打印"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已关闭"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>A最多只实例化了2次，因为只有2个线程。如果注释掉：<code class="language-plaintext highlighter-rouge">a.print();</code>，则A实例化0次，因为使用了虚代理。</p><p><strong>保护代理</strong></p><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p><p><strong>智能引用</strong></p><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p><p>代理模式和装饰器模式有一些相似之处，但它们的目的和使用方式略有不同：</p><ul><li><strong>装饰器模式</strong>：装饰器模式旨在动态地给对象<strong>添加额外的职责</strong>，而不改变其接口。它通常通过创建一个包装对象来包裹真实的对象，并在保持真实对象接口不变的情况下，增加额外的功能或责任。</li><li><strong>代理模式</strong>：代理模式为其他对象提供一种代理以<strong>控制对这个对象的访问</strong>。代理类通常在客户端和真实主题之间充当中介，可以用于控制对真实对象的访问权限、缓存对象的访问结果、延迟加载对象等。</li></ul><p>虽然两者都涉及到包装一个对象以增强其功能，但装饰器模式注重于增加新的行为，而代理模式注重于控制对对象的访问。</p><p>Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p><h2 id="行为型模式">行为型模式</h2><p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p><p>行为型模式有：</p><p>责任链模式（Chain of Responsibility）：将请求的发送者和接收者解耦，让多个对象都有机会处理这个请求。</p><p>命令模式（Command）：将请求封装成一个对象，从而可以用不同的请求对客户进行参数化，并且对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p><p>迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>中介模式（Mediator）：用一个中介对象来封装一系列的对象交互，使得对象不需要显式地相互引用，从而达到解耦的目的。</p><p>备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象到原先保存的状态。</p><p>观察者模式（Observer）：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象状态发生变化时，会通知所有的观察者对象。</p><p>状态模式（State）：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式将对象的状态封装成独立的类，并将不同状态对应的行为抽象出来，使得在不同状态下可以定义不同的行为，而不需要使用大量的条件语句来判断当前状态。这样可以让代码更加清晰、可维护，同时也符合开闭原则，因为添加新的状态类不会影响现有代码。</p><p>策略模式（Strategy）：定义了一系列的算法，并将每一个算法封装起来，使得它们可以相互替换，让算法独立于使用它的客户而独立变化。</p><p>模板方法模式（Template Method）：定义一个操作中的算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank">https://acteds.github.io/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1715256149', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
