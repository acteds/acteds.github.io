<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>设计模式 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="设计模式"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。"><meta name="og:description" content="引言设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。"><meta property="og:url" content="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2024-05-02"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="设计模式"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">设计模式</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2024/05/02 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 69589 字，约 199 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p><h1 id="设计模式">设计模式</h1><p>软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的。23个常用模式分为创建型模式、结构型模式和行为型模式三类，基于以下几个原则：</p><p><strong>开闭原则</strong></p><p>软件应该对扩展开放，而对修改关闭。在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p><p><strong>单一职责原则</strong></p><p>一个类只负责一项职责。针对一个类，其承担的职责越多，被复用的可能性就越小。如果类承担的职责很多，就意味着这些职责耦合在了一起。</p><p><strong>里氏替换原则</strong></p><p>如果调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p><p><strong>接口隔离原则</strong></p><ul><li>客户需要什么样的接口，就提供什么样的接口，不需要的就删除掉；</li><li>类之间的依赖关系应建立在最小的接口上。也就是说，接口中的方法要尽量的少，接口功能要尽量的细分。</li></ul><p><strong>依赖倒置原则</strong></p><p>依赖倒转原则就是要依赖于抽象，不要依赖于实现。高层模块不依赖于底层模块，二者都依赖其抽象；抽象不依赖于细节，细节应该依赖抽象。</p><p>也就是说应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等，而不是用具体类。<strong>一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法</strong>。特例：对象的创建过程是违背“开—闭”原则以及依赖倒转原则的，但通过工厂模式，能很好地解决对象创建过程中的依赖倒转问题。</p><p><strong>迪米特原则</strong></p><p>又称为最少知识原则，<strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p><p>如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用。如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。</p><p>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；</p><p>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><p><strong>组合/聚合复用原则</strong></p><p>简单的说是，尽量使用对象的组合/聚合，而不是继承来达到复用的目的。</p><p>组合和聚合都是对象建模中关联关系的一种。聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。</p><p>组合/聚合和继承是实现代码复用的两种基本途径，在设计过程中尽量使用组合/聚合，而不是继承。因为继承使得基类与子类有较强的耦合性，通常情况下基类的内部细节对子类来说是可见的，这样基类的实现细节会暴露给子类，破坏了系统的封装性。</p><p>开闭原则是所有面向对象原则的核心；里式替换原则是实现开闭原则的重要方式之一；依赖倒置原则是系统抽象化的具体实现，其是面向对象设计的主要实现机制之一；接口隔离原则要求接口的方法尽量少，接口尽量细化；迪米特原则降低系统的耦合度，其使得一个模块的修改尽量少的影响其他模块，扩展会相对容易；尽量使用组合/聚合而不是继承达到代码复用的目的。</p><h2 id="创建型模式">创建型模式</h2><p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p><p>常见的创建型模式：</p><ul><li><strong>工厂方法模式（Factory Method Pattern）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li><li><strong>建造者模式（Builder Pattern）</strong>：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>原型模式（Prototype Pattern）</strong>：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</li><li><strong>单例模式（Singleton Pattern）</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li></ul><h3 id="工厂方法">工厂方法</h3><blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p></blockquote><p>工厂方法即Factory Method，是一种对象创建型模式。</p><p>工厂方法的目的是使得<strong>创建对象</strong>和<strong>使用对象</strong>是<strong>分离</strong>的，并且客户端<strong>总是引用抽象工厂和抽象产品</strong>：</p><pre><code class="language-ascii">┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
</code></pre><p>实现一个解析<code class="language-plaintext highlighter-rouge">字符串</code>为<code class="language-plaintext highlighter-rouge">Number</code>的<code class="language-plaintext highlighter-rouge">Factory</code>，可以定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>有了工厂接口，再编写一个工厂的实现类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberFactoryImpl</span> <span class="kd">implements</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>产品接口是<code class="language-plaintext highlighter-rouge">Number</code>，<code class="language-plaintext highlighter-rouge">NumberFactoryImpl</code>返回的实际产品是<code class="language-plaintext highlighter-rouge">BigDecimal</code>。</p><p>通常会在接口<code class="language-plaintext highlighter-rouge">Factory</code>中再定义一个静态方法<code class="language-plaintext highlighter-rouge">getFactory()</code>来返回真正的子类（在 <strong>Java 8</strong> 中，接口可以包含静态方法）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="c1">// 创建方法:</span>
    <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
    <span class="c1">// 获取工厂实例:</span>
    <span class="kd">static</span> <span class="nc">NumberFactory</span> <span class="nf">getFactory</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">impl</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="nc">NumberFactory</span> <span class="n">impl</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NumberFactoryImpl</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>在客户端中，只需要和工厂接口<code class="language-plaintext highlighter-rouge">NumberFactory</code>以及抽象产品<code class="language-plaintext highlighter-rouge">Number</code>打交道：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NumberFactory</span> <span class="n">factory</span> <span class="o">=</span> <span class="nc">NumberFactory</span><span class="o">.</span><span class="na">getFactory</span><span class="o">();</span>
<span class="nc">Number</span> <span class="n">result</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="s">"123.456"</span><span class="o">);</span>
</code></pre></div></div><p>调用方可以完全忽略真正的工厂<code class="language-plaintext highlighter-rouge">NumberFactoryImpl</code>和实际的产品<code class="language-plaintext highlighter-rouge">BigDecimal</code>，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。</p><hr /><p>实际上，大多数情况下并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NumberFactory</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Number</span> <span class="nf">parse</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">BigDecimal</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。</p><p>静态工厂方法广泛地应用在Java标准库中。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Integer</code>既是产品又是静态工厂，它提供了静态方法<code class="language-plaintext highlighter-rouge">valueOf()</code>来创建<code class="language-plaintext highlighter-rouge">Integer</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Integer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Integer</span> <span class="nf">valueOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">low</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">high</span><span class="o">)</span>
            <span class="k">return</span> <span class="nc">IntegerCache</span><span class="o">.</span><span class="na">cache</span><span class="o">[</span><span class="n">i</span> <span class="o">+</span> <span class="o">(-</span><span class="nc">IntegerCache</span><span class="o">.</span><span class="na">low</span><span class="o">)];</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Integer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">valueOf()</code>内部可能会使用<code class="language-plaintext highlighter-rouge">new</code>创建一个新的<code class="language-plaintext highlighter-rouge">Integer</code>实例，但也可能直接返回一个缓存的<code class="language-plaintext highlighter-rouge">Integer</code>实例。对于调用方来说，没必要知道<code class="language-plaintext highlighter-rouge">Integer</code>创建的细节。</p><p>工厂方法可以<strong>隐藏创建产品的细节</strong>，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p><p>如果调用方直接使用<code class="language-plaintext highlighter-rouge">Integer n = new Integer(100)</code>，那么就失去了使用缓存优化的可能性。</p><hr /><p>经常使用的另一个静态工厂方法是<code class="language-plaintext highlighter-rouge">List.of()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"B"</span><span class="o">,</span> <span class="s">"C"</span><span class="o">);</span>
</code></pre></div></div><p>这个静态工厂方法接收可变参数，然后返回<code class="language-plaintext highlighter-rouge">List</code>接口。需要注意的是，调用方获取的产品总是<code class="language-plaintext highlighter-rouge">List</code>接口，而且并不关心它的实际类型。</p><p>即使调用方知道<code class="language-plaintext highlighter-rouge">List</code>产品的实际类型是<code class="language-plaintext highlighter-rouge">java.util.ImmutableCollections$ListN</code>，也不要去强制转型为子类，因为静态工厂方法<code class="language-plaintext highlighter-rouge">List.of()</code>保证返回<code class="language-plaintext highlighter-rouge">List</code>，但也完全可以修改为返回<code class="language-plaintext highlighter-rouge">java.util.ArrayList</code>。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p><p>总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p><hr /><p>和<code class="language-plaintext highlighter-rouge">List.of()</code>类似，使用<code class="language-plaintext highlighter-rouge">MessageDigest</code>时，为了创建某个摘要算法，总是使用静态工厂方法<code class="language-plaintext highlighter-rouge">getInstance(String)</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MessageDigest</span> <span class="n">md5</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"MD5"</span><span class="o">);</span>
<span class="nc">MessageDigest</span> <span class="n">sha1</span> <span class="o">=</span> <span class="nc">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">"SHA-1"</span><span class="o">);</span>
</code></pre></div></div><p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是<code class="language-plaintext highlighter-rouge">MessageDigest</code>这个抽象类。</p><h3 id="抽象工厂">抽象工厂</h3><blockquote><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p></blockquote><p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p><p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，工厂是抽象的，产品也是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p><pre><code class="language-ascii">                                ┌────────┐
                             ─ &gt;│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─&gt;│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ &gt;│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│
               └─────────┘     └─────────┘
</code></pre><p>这种模式有点类似于多个供应商负责提供一系列类型的产品。</p><p>假设希望为用户提供一个可以买荤素菜的环境，定义接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>定义了抽象工厂（<code class="language-plaintext highlighter-rouge">ImeatAndVegetarianFactory</code>）以及两个抽象产品（<code class="language-plaintext highlighter-rouge">IMeat</code>和<code class="language-plaintext highlighter-rouge">IVegetarian</code>）。假设环境可以是超市也可以是菜市场，先写菜市场：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*菜市场*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MarketFactoryImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>然后就可以使用了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">meatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span><span class="k">new</span> <span class="nc">MarketFactoryImpl</span><span class="o">();</span><span class="c1">//菜市场</span>
<span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span><span class="c1">//菜市场的荤菜</span>
<span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span><span class="c1">//菜市场的素菜</span>
</code></pre></div></div><p>看起来似乎也没什么特别的作用。</p><p>再写超市：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MeatDishesFromTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SupermarketImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>要使用，则只需要改动一下初始化的工厂就行了：即把<code class="language-plaintext highlighter-rouge">new MarketFactoryImpl();</code>改成<code class="language-plaintext highlighter-rouge">new SupermarketImpl();</code>。这下作用比较明显了。</p><p>还可以把这行也隐藏起来，这样用户就完全不会接触到具体实现了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span> <span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"超市"</span><span class="o">);</span>
        <span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span>
        <span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
    <span class="kd">static</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="nf">createFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"超市"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SupermarketImpl</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">MarketFactoryImpl</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未定义"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>抽象工厂模式是为了让创建工厂和一组产品与使用相分离，并可以随时切换到另一个工厂以及另一组产品；</p><p>抽象工厂模式实现的关键点是<strong>定义工厂接口和产品接口</strong>，但如何实现工厂与产品本身需要留给具体的子类实现，<strong>客户端只和抽象工厂与抽象产品打交道</strong>。</p><hr /><p>完整代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">=</span> <span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"超市"</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
        <span class="n">f</span><span class="o">=</span><span class="nc">ImeatAndVegetarianFactory</span><span class="o">.</span><span class="na">createFactory</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">);</span>
        <span class="n">test</span><span class="o">(</span><span class="n">f</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">ImeatAndVegetarianFactory</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">IMeat</span> <span class="nc">IMeat</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyMeatDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IMeat</span><span class="o">.</span><span class="na">getMeatName</span><span class="o">());</span>
        <span class="nc">IVegetarian</span> <span class="nc">IVegetarian</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">buyVegetarianDishes</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">IVegetarian</span><span class="o">.</span><span class="na">getVegetarianName</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">();</span>
    <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">();</span>
    <span class="kd">static</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="nf">createFactory</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"超市"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">SupermarketImpl</span><span class="o">();</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"菜市场"</span><span class="o">)){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">MarketFactoryImpl</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"未定义"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">();</span>
<span class="o">}</span>
<span class="cm">/*菜市场*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetMarketImpl</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"菜市场的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">MarketFactoryImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetMarketImpl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*超市*/</span>
<span class="kd">class</span> <span class="nc">MeatDishesFromTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IMeat</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getMeatName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的荤菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">VegetarianDishesInTheWetSupermarket</span> <span class="kd">implements</span> <span class="nc">IVegetarian</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getVegetarianName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"超市的素菜"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SupermarketImpl</span> <span class="kd">implements</span> <span class="nc">ImeatAndVegetarianFactory</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IMeat</span> <span class="nf">buyMeatDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MeatDishesFromTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">IVegetarian</span> <span class="nf">buyVegetarianDishes</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">VegetarianDishesInTheWetSupermarket</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="生成器">生成器</h3><blockquote><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>生成器模式/建造者模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p><p>使用Builder是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p><p>以Markdown转HTML为例，直接编写一个完整的转换器比较困难，但如果针对类似下面的<strong>一行</strong>文本：</p><div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># this is a heading</span>
</code></pre></div></div><p>转换成HTML就很简单：</p><div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>this is a heading<span class="nt">&lt;/h1&gt;</span>
</code></pre></div></div><p>因此，把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p><ul><li>如果以<code class="language-plaintext highlighter-rouge">#</code>开头，使用<code class="language-plaintext highlighter-rouge">HeadingBuilder</code>转换；</li><li>如果以<code class="language-plaintext highlighter-rouge">&gt;</code>开头，使用<code class="language-plaintext highlighter-rouge">QuoteBuilder</code>转换；</li><li>如果以<code class="language-plaintext highlighter-rouge">---</code>开头，使用<code class="language-plaintext highlighter-rouge">HrBuilder</code>转换；</li><li>其余使用<code class="language-plaintext highlighter-rouge">ParagraphBuilder</code>转换。</li></ul><p>这个<code class="language-plaintext highlighter-rouge">HtmlBuilder</code>写出来如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HtmlBuilder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">HeadingBuilder</span> <span class="n">headingBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HeadingBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">HrBuilder</span> <span class="n">hrBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HrBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">ParagraphBuilder</span> <span class="n">paragraphBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParagraphBuilder</span><span class="o">();</span>
    <span class="kd">private</span> <span class="nc">QuoteBuilder</span> <span class="n">quoteBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QuoteBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toHtml</span><span class="o">(</span><span class="nc">String</span> <span class="n">markdown</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="nc">String</span> <span class="o">[]</span><span class="n">s</span><span class="o">=</span><span class="n">markdown</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\s"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">line</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"#"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">headingBuilder</span><span class="o">.</span><span class="na">buildHeading</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">quoteBuilder</span><span class="o">.</span><span class="na">buildQuote</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"---"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">hrBuilder</span><span class="o">.</span><span class="na">buildHr</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">paragraphBuilder</span><span class="o">.</span><span class="na">buildParagraph</span><span class="o">(</span><span class="n">line</span><span class="o">)).</span><span class="na">append</span><span class="o">(</span><span class="sc">'\n'</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code class="language-plaintext highlighter-rouge">XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p><p>这样一来，只需要针对每一种类型编写不同的Builder。例如，针对以<code class="language-plaintext highlighter-rouge">#</code>开头的行，需要<code class="language-plaintext highlighter-rouge">HeadingBuilder</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HeadingBuilder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">buildHeading</span><span class="o">(</span><span class="nc">String</span> <span class="n">line</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">n</span><span class="o">++;</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"&lt;h%d&gt;%s&lt;/h%d&gt;"</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">line</span><span class="o">.</span><span class="na">trim</span><span class="o">(),</span> <span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p><p><code class="language-plaintext highlighter-rouge">JavaMail</code>的<code class="language-plaintext highlighter-rouge">MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code class="language-plaintext highlighter-rouge">MimeMessage</code>。</p><p>很多时候，可以简化Builder模式，以链式调用的方式来创建对象。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">StringBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="n">builder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"123"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"456"</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">"789"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div><p>生成器模式旨在通过一步一步构建复杂对象来创建对象。在使用 <code class="language-plaintext highlighter-rouge">JavaBean</code> 的 <code class="language-plaintext highlighter-rouge">set</code> 方法构建 <code class="language-plaintext highlighter-rouge">JavaBean</code> 时，虽然没有明确的构建步骤，但通过设置各个属性来构建对象的过程与生成器模式中逐步构建对象的思想相似。因此，可以将使用 <code class="language-plaintext highlighter-rouge">JavaBean</code> 的 <code class="language-plaintext highlighter-rouge">set</code> 方法构建 <code class="language-plaintext highlighter-rouge">JavaBean</code> 视为一种类似生成器模式的实现方式。</p><p><code class="language-plaintext highlighter-rouge">lombok</code>有个<code class="language-plaintext highlighter-rouge">@Builder</code> 可以使对象实现 builder 功能:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">build</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">a</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">b</span><span class="o">(</span><span class="s">"2"</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">build</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="nd">@ToString</span>
<span class="nd">@Builder</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>生成的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">b</span><span class="o">;</span>
    <span class="no">A</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">ABuilder</span> <span class="nf">builder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ABuilder</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"A(a="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ABuilder</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">a</span><span class="o">;</span>
        <span class="kd">private</span> <span class="nc">String</span> <span class="n">b</span><span class="o">;</span>

        <span class="nc">ABuilder</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">ABuilder</span> <span class="nf">a</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">ABuilder</span> <span class="nf">b</span><span class="o">(</span><span class="nc">String</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="no">A</span> <span class="nf">build</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">A</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"A.ABuilder(a="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>内部生成器的<code class="language-plaintext highlighter-rouge">toString</code>会自动生成：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span><span class="o">.</span><span class="na">ABuilder</span> <span class="n">b</span> <span class="o">=</span> <span class="no">A</span><span class="o">.</span><span class="na">builder</span><span class="o">().</span><span class="na">a</span><span class="o">(</span><span class="s">"1"</span><span class="o">).</span><span class="na">b</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span><span class="c1">//A.ABuilder(a=1, b=2)</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Builder</span>
<span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="原型">原型</h3><blockquote><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></blockquote><p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p><p>我们举个例子：如果我们已经有了一个<code class="language-plaintext highlighter-rouge">String[]</code>数组，想再创建一个一模一样的<code class="language-plaintext highlighter-rouge">String[]</code>数组，怎么写？</p><p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 原型:</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">original</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">,</span> <span class="s">"Banana"</span> <span class="o">};</span>
<span class="c1">// 新对象:</span>
<span class="nc">String</span><span class="o">[]</span> <span class="n">copy</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">original</span><span class="o">,</span> <span class="n">original</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</code></pre></div></div><p>对于普通类，如何实现原型拷贝？Java的<code class="language-plaintext highlighter-rouge">Object</code>提供了一个<code class="language-plaintext highlighter-rouge">clone()</code>方法，它的意图就是复制一个新的对象出来，需要实现一个<code class="language-plaintext highlighter-rouge">Cloneable</code>接口来标识一个对象是“可复制”的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="nc">Cloneable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="c1">// 复制新对象并返回:</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">clone</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">std</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">score</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用的时候，因为<code class="language-plaintext highlighter-rouge">clone()</code>的方法签名是定义在<code class="language-plaintext highlighter-rouge">Object</code>中，返回类型也是<code class="language-plaintext highlighter-rouge">Object</code>，所以要强制转型，比较麻烦。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Student</span> <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
<span class="nc">Object</span> <span class="n">clone</span> <span class="o">=</span> <span class="n">student</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">student</span><span class="o">);</span><span class="c1">//test.Student@6f4a47c7</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">clone</span><span class="o">);</span><span class="c1">//test.Student@ae13544</span>
</code></pre></div></div><p>实际上，使用原型模式更好的方式是定义一个<code class="language-plaintext highlighter-rouge">copy()</code>方法，返回明确的类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">score</span><span class="o">;</span>

    <span class="c1">// 复制新对象并返回:</span>
    <span class="kd">public</span> <span class="nc">Student</span> <span class="nf">copy</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
        <span class="n">std</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
        <span class="n">std</span><span class="o">.</span><span class="na">score</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">score</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p><h3 id="单例">单例</h3><blockquote><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p></blockquote><p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p><p>因为这个类只有一个实例，因此，自然不能让调用方使用<code class="language-plaintext highlighter-rouge">new ClassName()</code>来创建实例了。所以，单例的构造方法必须是<code class="language-plaintext highlighter-rouge">private</code>，这样就防止了调用方自己创建实例。然后可以对外提供一个静态方法，返回一个固定的实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="c1">// 静态字段引用唯一实例:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>

    <span class="c1">// 通过静态方法返回实例:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// private构造方法保证外部无法实例化:</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//相同实例</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//相同实例</span>
</code></pre></div></div><p>或者直接把静态变量设置为<code class="language-plaintext highlighter-rouge">public</code>。</p><p>单例模式的实现方式很简单：</p><ol><li>只有<code class="language-plaintext highlighter-rouge">private</code>构造方法，确保外部无法实例化；</li><li>通过<code class="language-plaintext highlighter-rouge">private static</code>变量持有唯一实例，保证全局唯一性；</li><li>通过<code class="language-plaintext highlighter-rouge">public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li></ol><p>Java标准库有一些类就是单例，例如<code class="language-plaintext highlighter-rouge">Runtime</code>这个类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Runtime</span> <span class="n">runtime</span> <span class="o">=</span> <span class="nc">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">();</span>
</code></pre></div></div><h4 id="延迟加载">延迟加载</h4><p>即在调用方第一次调用<code class="language-plaintext highlighter-rouge">getInstance()</code>时才初始化全局唯一实例，类似这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>但这种写法在多线程中是错误的，必须对整个方法进行加锁，但加锁会严重影响并发性能，得不偿失。</p><hr /><h5 id="双重检查">双重检查</h5><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="no">INSTANCE</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述描述似乎已经解决了我们面临的所有问题，但实际上，从 JVM 的角度讲，这些代码仍然可能发生错误。</p><p>对于 JVM 而言，它执行的是一个个 Java 指令。在 Java 指令中创建对象和赋值操作是分开进行的，也就是说<code class="language-plaintext highlighter-rouge">INSTANCE= new Singleton();</code>语句是分两步执行的。但是 JVM 并不保证这两个操作的先后顺序，即指令重排，也就是说有可能 JVM 会为新的 <code class="language-plaintext highlighter-rouge">Singleton</code> 实例分配空间，然后直接赋值给 <code class="language-plaintext highlighter-rouge">instance</code> 成员，然后再去初始化这个 <code class="language-plaintext highlighter-rouge">Singleton</code> 实例。这样就使出错成为了可能。</p><p>不过在<strong>JDK 5</strong>以及更高版本扩展了<code class="language-plaintext highlighter-rouge">volatile</code>的语义，以便系统将不允许<code class="language-plaintext highlighter-rouge">volatile</code>的写相对于任何之前的读或写重新排序，并且<code class="language-plaintext highlighter-rouge">volatile</code>的读也不能相对于任何后续的读或写重新排序。</p><p>因此，<strong>为<code class="language-plaintext highlighter-rouge">INSTANCE</code>变量添加<code class="language-plaintext highlighter-rouge">volatile</code>就修复了这个问题</strong>。</p><p>另外，如果<code class="language-plaintext highlighter-rouge">INSTANCE</code>变量是一个不可变对象，则也不用加<code class="language-plaintext highlighter-rouge">volatile</code>，就如同<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">float</code>一样，他们的赋值操作是原子的。（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">参见</a>）</p><hr /><h5 id="通过内部类实现">通过内部类实现</h5><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SingletonContainer</span><span class="o">{</span>
        <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 静态内部类只有在被使用时才会装载，静态属性只会在第一次装载时初始化
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">return</span> <span class="nc">SingletonContainer</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。</p><p>这样第一次调用<code class="language-plaintext highlighter-rouge">getInstance</code>的时候，JVM能够保证<code class="language-plaintext highlighter-rouge">INSTANCE</code>只被创建一次，并且会保证把赋值给<code class="language-plaintext highlighter-rouge">INSTANCE</code>的内存初始化完毕。此外该方法也只会在第一次调用的时候使用互斥机制。</p><p><code class="language-plaintext highlighter-rouge">INSTANCE</code> 是在第一次加载 <code class="language-plaintext highlighter-rouge">SingletonContainer</code> 类时被创建的，而 <code class="language-plaintext highlighter-rouge">SingletonContainer</code> 类则在调用 <code class="language-plaintext highlighter-rouge">getInstance</code> 方法的时候才会被加载，因此也实现了延迟加载。</p><hr /><p>要防止通过<strong>反射强行调用私有构造方法</strong>，可以在构造方法添加代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">SingletonContainer</span><span class="o">.</span><span class="na">INSTANCE</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>反射测试：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">Singleton</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">();</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">Singleton</span> <span class="n">singleton</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span><span class="c1">//java.lang.RuntimeException: !</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">singleton</span><span class="o">);</span>
</code></pre></div></div><p>正常调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//test.Singleton@ae13544</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">());</span><span class="c1">//test.Singleton@ae13544</span>
</code></pre></div></div><hr /><h4 id="序列化破坏单例">序列化破坏单例</h4><p>单例对象创建好之后，有时需要将对象序列化然后写入磁盘，在需要时从磁盘中读取对象并加载至内存，反序列化后的对象会重新分配内存，如果序列化的目标对象恰好是单例对象，就会破坏单例模式。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">Singleton</span> <span class="n">s2</span><span class="o">;</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="n">s2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//test.Singleton@7494f96a</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//test.Singleton@37883b97</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>添加一个<code class="language-plaintext highlighter-rouge">readResolve()</code>,就能保证反序列化是同一个实例了</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在 Java 的序列化中，当对象被序列化时，如果类中定义了 <code class="language-plaintext highlighter-rouge">readResolve</code> 方法，并且该方法返回一个对象，那么在反序列化时<strong>会调用该方法来获取对象</strong>，而<strong>不是通过从流中反序列化创建一个新的对象</strong>。</p><p>这意味着 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法可以用来控制反序列化过程中返回的对象，<strong>可以在方法中返回任何想要的对象，而不受反序列化的影响</strong>。如果一个类写了 <code class="language-plaintext highlighter-rouge">readResolve()</code> 方法，并且在方法中返回了特定的对象，那么反序列化过程<strong>就会返回这个方法中指定的对象</strong>，而<strong>不会</strong>从文件中重新构造对象。示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"序列化前"</span><span class="o">;</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//test.Singleton@561b6512</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s2</span><span class="o">;</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="n">s2</span><span class="o">=</span> <span class="o">(</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span><span class="c1">//test.Singleton@c86b9e3</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//null</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>先运行<code class="language-plaintext highlighter-rouge">test1()</code>,然后等JVM关闭后重新运行<code class="language-plaintext highlighter-rouge">test2()</code>,模拟序列化的实际运用场景，这个场景下内存地址肯定不一样，但后设置的<code class="language-plaintext highlighter-rouge">name</code>值也丢了。</p><p>实际上，<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法的作用是控制对象的反序列化过程，可以用来确保反序列化后的对象符合特定的要求，或者实现单例模式等。</p><hr /><p>那么我们保存的<code class="language-plaintext highlighter-rouge">s.obj</code>序列化文件就这么废了吗？也不一定，<strong>序列化仅涉及对象的状态（即实例变量）</strong>，不包括类的方法。序列化的主要目的是保存对象的状态，以便在稍后可以将其完全恢复为原始状态。把<code class="language-plaintext highlighter-rouge">readResolve()</code> 方法注释掉不就好了。</p><p>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">Singleton</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">Singleton</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">=</span><span class="s">"序列化前"</span><span class="o">;</span>

        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="c1">//Singleton{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">.</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">(){</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Singleton{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>运行<code class="language-plaintext highlighter-rouge">test1()</code>生成<code class="language-plaintext highlighter-rouge">s.obj</code>。删除<code class="language-plaintext highlighter-rouge">readResolve</code>，<code class="language-plaintext highlighter-rouge">运行test2()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">Object</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//Singleton{name='序列化前'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(((</span><span class="nc">Singleton</span><span class="o">)</span> <span class="n">x</span><span class="o">).</span><span class="na">name</span><span class="o">);</span><span class="c1">//序列化前</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Singleton{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>正常恢复，没有问题，那么试试删除<code class="language-plaintext highlighter-rouge">public String toString()</code>，提示：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.io.InvalidClassException: test.Singleton; local class incompatible: stream classdesc serialVersionUID = 5155019565252345970, local class serialVersionUID = -6864115338217441473
</code></pre></div></div><p>改动太大了，改变了<code class="language-plaintext highlighter-rouge">serialVersionUID</code>，那么显示的在类里指定：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Singleton</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">5155019565252345970L</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span> <span class="no">INSTANCE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Singleton</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Singleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>再运行<code class="language-plaintext highlighter-rouge">test2()</code>,正常反序列化，只是这次<code class="language-plaintext highlighter-rouge">toString</code>没有了：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test.Singleton@79d8407f
序列化前
</code></pre></div></div><p>实际上，非重写的方法可以随便添加修改删除，而重写的方法不能动，动了就会导致<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号。（显示指定<code class="language-plaintext highlighter-rouge">serialVersionUID</code>编号就好了）</p><hr /><h4 id="使用枚举">使用枚举</h4><p>Java保证枚举类的每个枚举都是单例，所以只需要编写一个只有一个枚举的类即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">World</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
	<span class="no">INSTANCE</span><span class="o">;</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"world"</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code class="language-plaintext highlighter-rouge">World</code>类在调用方看来就可以这么用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</code></pre></div></div><p>使用枚举实现Singleton也避免了即序列化和反序列化会绕过普通类的<code class="language-plaintext highlighter-rouge">private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p><p>枚举在序列化和反序列化过程中<strong>会丢失枚举常量中的普通字段的值</strong>。这是因为枚举在序列化时只保留了枚举常量的名称，并没有保存其他字段的状态。在反序列化时，只会根据枚举常量的名称重新构建枚举常量，而普通字段的值需要在程序中重新设置。即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"序列化前"</span><span class="o">);</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span><span class="c1">//World{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//序列化前</span>
    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">World</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">World</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//World{name='null'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//null</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">World</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
    <span class="no">INSTANCE</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"World{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>用有参构造器设置就好了，虽然并没有改变问题的根本，也是个曲线的好办法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileOutputStream</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileOutputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectOutputStream</span> <span class="n">oos</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectOutputStream</span><span class="o">(</span><span class="n">f</span><span class="o">)){</span>
                <span class="n">oos</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span><span class="c1">//World{name='序列化前'}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">World</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//序列化前</span>

    <span class="o">}</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test2</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span><span class="nc">ClassNotFoundException</span> <span class="o">{</span>
        <span class="k">try</span><span class="o">(</span><span class="nc">FileInputStream</span> <span class="n">fis</span><span class="o">=</span><span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"s.obj"</span><span class="o">)){</span>
            <span class="k">try</span><span class="o">(</span><span class="nc">ObjectInputStream</span> <span class="n">ois</span><span class="o">=</span><span class="k">new</span> <span class="nc">ObjectInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">)){</span>
                <span class="nc">World</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="nc">World</span><span class="o">)</span> <span class="n">ois</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span><span class="c1">//World{name='null'}</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span><span class="c1">//null</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">World</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="c1">// 唯一枚举:</span>
    <span class="no">INSTANCE</span><span class="o">(</span><span class="s">"序列化前"</span><span class="o">);</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nc">World</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"World{name='"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">'\''</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而枚举天然就不能使用反射调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">World</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">World</span> <span class="n">world</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span><span class="c1">//java.lang.NoSuchMethodException: test.World.&lt;init&gt;(java.lang.String)</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">world</span><span class="o">);</span>
</code></pre></div></div><p>找不到指定类型的构造方法，看看<code class="language-plaintext highlighter-rouge">java.lang.Enum</code>的源码，只有：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="nf">Enum</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">ordinal</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ordinal</span> <span class="o">=</span> <span class="n">ordinal</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>唯一构造函数。程序员无法调用此构造函数。它供编译器发出的代码使用，以响应枚举类型声明。形参:</p><ul><li><code class="language-plaintext highlighter-rouge">name</code> – - 此枚举常量的名称，它是用于声明它的标识符。</li><li><code class="language-plaintext highlighter-rouge">ordinal</code> – - 此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）</li></ul><p>那么改成这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Constructor</span><span class="o">&lt;</span><span class="nc">World</span><span class="o">&gt;</span> <span class="n">declaredConstructor</span> <span class="o">=</span> <span class="nc">World</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getDeclaredConstructor</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">declaredConstructor</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="nc">World</span> <span class="n">world</span> <span class="o">=</span> <span class="n">declaredConstructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="s">"枚举名"</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="s">"test"</span><span class="o">);</span><span class="c1">//java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">world</span><span class="o">);</span>
</code></pre></div></div><p>异常位置：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@CallerSensitive</span>
<span class="nd">@ForceInline</span> <span class="c1">// to ensure Reflection.getCallerClass optimization</span>
<span class="kd">public</span> <span class="no">T</span> <span class="nf">newInstance</span><span class="o">(</span><span class="nc">Object</span> <span class="o">...</span> <span class="n">initargs</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InstantiationException</span><span class="o">,</span> <span class="nc">IllegalAccessException</span><span class="o">,</span>
           <span class="nc">IllegalArgumentException</span><span class="o">,</span> <span class="nc">InvocationTargetException</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">override</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">caller</span> <span class="o">=</span> <span class="nc">Reflection</span><span class="o">.</span><span class="na">getCallerClass</span><span class="o">();</span>
        <span class="n">checkAccess</span><span class="o">(</span><span class="n">caller</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">clazz</span><span class="o">,</span> <span class="n">modifiers</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">clazz</span><span class="o">.</span><span class="na">getModifiers</span><span class="o">()</span> <span class="o">&amp;</span> <span class="nc">Modifier</span><span class="o">.</span><span class="na">ENUM</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"Cannot reflectively create enum objects"</span><span class="o">);</span>
    <span class="nc">ConstructorAccessor</span> <span class="n">ca</span> <span class="o">=</span> <span class="n">constructorAccessor</span><span class="o">;</span>   <span class="c1">// read volatile</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ca</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">acquireConstructorAccessor</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
    <span class="no">T</span> <span class="n">inst</span> <span class="o">=</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">ca</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="n">initargs</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">inst</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p>什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code class="language-plaintext highlighter-rouge">new</code>操作符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span> <span class="c1">// 表示一个单例组件</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p><h2 id="结构型模式">结构型模式</h2><p>结构型模式主要关注如何组合不同的对象以获得更好、更灵活的结构。尽管面向对象的继承机制提供了基本的子类扩展父类功能的能力，但结构型模式不仅限于简单的继承，而更多地通过组合和运行时的动态组合来实现更灵活的功能。</p><p>主要关注如何组合类或对象以获得更大的结构，并且提供了一种方式来定义类之间的关系，以确保系统的某一部分变化不会影响其他部分。</p><p>结构型模式包括以下几种常见的模式：</p><ol><li><strong>适配器模式（Adapter Pattern）</strong>：将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li><strong>桥接模式（Bridge Pattern）</strong>：将抽象部分与它的实现部分<strong>分离</strong>，使它们可以独立地变化。</li><li><strong>组合模式（Composite Pattern）</strong>：将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。</li><li><strong>装饰器模式（Decorator Pattern）</strong>：动态地给一个对象添加一些额外的职责，就<strong>增加功能</strong>来说，装饰模式比生成子类更为灵活。</li><li><strong>外观模式（Facade Pattern）</strong>：为子系统中的一组接口提供一个统一的接口，外观模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</li><li><strong>享元模式（Flyweight Pattern）</strong>：运用共享技术有效地支持大量细粒度的对象。</li><li><strong>代理模式（Proxy Pattern）</strong>：为其他对象提供一种代理以控制对这个对象的访问。</li></ol><p>适配器就是转换兼容，桥接就是拆分可复用部分，组合就是树形结构，装饰器就是在不改变类的情况下增强类功能，外观就是封装，享元就是缓存不变类，代理模式就是控制限制类。</p><h3 id="适配器">适配器</h3><blockquote><p>将一个类的接口<strong>转换</strong>成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p></blockquote><p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，则中间需要一个适配器转换。将下面的类传入线程是不行的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">a</span><span class="o">);</span><span class="c1">//没有实现Runnable接口，所以不能向上转型为Runnable</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>办法一是改写<code class="language-plaintext highlighter-rouge">A</code>类，把实现的<code class="language-plaintext highlighter-rouge">Callable</code>改为<code class="language-plaintext highlighter-rouge">Runnable</code>，但这样做不好，因为<code class="language-plaintext highlighter-rouge">A</code>有可能在其他地方作为<code class="language-plaintext highlighter-rouge">Callable</code>被引用，改写<code class="language-plaintext highlighter-rouge">Task</code>的接口，会导致其他正常工作的代码无法编译。</p><p>另一个办法不用改写<code class="language-plaintext highlighter-rouge">A</code>类，而是用一个Adapter，把这个<code class="language-plaintext highlighter-rouge">Callable</code>接口“变成”<code class="language-plaintext highlighter-rouge">Runnable</code>接口，这样，就可以正常编译：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">CallableToRunnableAdapter</span><span class="o">(</span><span class="n">a</span><span class="o">));</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>这个<code class="language-plaintext highlighter-rouge">CallableToRunnableAdapter</code>类就是Adapter，它接收一个<code class="language-plaintext highlighter-rouge">Callable</code>，输出一个<code class="language-plaintext highlighter-rouge">Runnable</code>。实现非常简单：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CallableToRunnableAdapter</span> <span class="kd">implements</span> <span class="nc">Runnable</span><span class="o">{</span>
    <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CallableToRunnableAdapter</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>编写一个Adapter的步骤如下：</p><ol><li>实现目标接口，这里是<code class="language-plaintext highlighter-rouge">Runnable</code>；</li><li>内部持有一个待转换接口的引用，这里是通过字段持有<code class="language-plaintext highlighter-rouge">Callable</code>接口；</li><li>在目标接口的实现方法内部，调用待转换接口的方法。</li></ol><p>这样一来，Thread就可以接收这个<code class="language-plaintext highlighter-rouge">RunnableAdapter</code>，因为它实现了<code class="language-plaintext highlighter-rouge">Runnable</code>接口。<code class="language-plaintext highlighter-rouge">Thread</code>作为调用方，它会调用<code class="language-plaintext highlighter-rouge">RunnableAdapter</code>的<code class="language-plaintext highlighter-rouge">run()</code>方法，在这个<code class="language-plaintext highlighter-rouge">run()</code>方法内部，又调用了<code class="language-plaintext highlighter-rouge">Callable</code>的<code class="language-plaintext highlighter-rouge">call()</code>方法，相当于<code class="language-plaintext highlighter-rouge">Thread</code>通过一层转换，间接调用了<code class="language-plaintext highlighter-rouge">Callable</code>的<code class="language-plaintext highlighter-rouge">call()</code>方法。</p><p>使用lambda也是可以的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread</span><span class="o">=</span><span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">a</span><span class="o">.</span><span class="na">call</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123L</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>从某种程度上说，这确实可以被看作是一种简单的转换器思想，通过实现 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口，将 <code class="language-plaintext highlighter-rouge">Callable</code> 接口的 <code class="language-plaintext highlighter-rouge">call</code> 方法转换成了 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口的 <code class="language-plaintext highlighter-rouge">run</code> 方法，使得原本的 <code class="language-plaintext highlighter-rouge">Callable</code> 对象 <code class="language-plaintext highlighter-rouge">a</code> 可以在 <code class="language-plaintext highlighter-rouge">Thread</code> 中被使用。</p><p>虽然这种用法不是传统意义上的转换器模式，但从某种程度上可以看作是一种类似的思想，即通过接口或类的适配来实现不同对象之间的协同工作。</p><p>如果不局限与接口或类的适配，那么实例化类也沾点转换器思想，因为将数据整合“转换“为了类实例。</p><p>向上转型和向下转型在某种程度上也可以被视为适配器思想的一种体现。向上转型是指将子类对象转换为父类对象的过程，这样做可以使得子类对象可以被当做父类对象对待，从而实现多态性。这种转型可以被看作是一种接口的适配，将子类对象适配成了父类对象。</p><p>向下转型是指将父类对象转换为子类对象的过程。这种转型可能涉及到类型检查和转换，以确保父类对象确实可以被转换为子类对象。向下转型也可以被视为一种适配器思想，将父类对象适配成了子类对象，以便对其进行特定的操作或方法调用。</p><hr /><p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code class="language-plaintext highlighter-rouge">String[]</code>，但是需要<code class="language-plaintext highlighter-rouge">List</code>接口时，可以用一个Adapter：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">exist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]</span> <span class="o">{</span><span class="s">"Good"</span><span class="o">,</span> <span class="s">"morning"</span><span class="o">,</span> <span class="s">"Bob"</span><span class="o">,</span> <span class="s">"and"</span><span class="o">,</span> <span class="s">"Alice"</span><span class="o">};</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">exist</span><span class="o">));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">List&lt;T&gt; Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code class="language-plaintext highlighter-rouge">List</code>。</p><p>假设有一个<code class="language-plaintext highlighter-rouge">InputStream</code>，但希望调用<code class="language-plaintext highlighter-rouge">readText(Reader)</code>这个方法，但它的参数类型是<code class="language-plaintext highlighter-rouge">Reader</code>而不是<code class="language-plaintext highlighter-rouge">InputStream</code>，怎么办？当然是使用适配器，把<code class="language-plaintext highlighter-rouge">InputStream</code>“变成”<code class="language-plaintext highlighter-rouge">Reader</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="nc">Files</span><span class="o">.</span><span class="na">newInputStream</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"/path/to/file"</span><span class="o">));</span>
<span class="nc">Reader</span> <span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="n">input</span><span class="o">,</span> <span class="s">"UTF-8"</span><span class="o">);</span>
<span class="n">readText</span><span class="o">(</span><span class="n">reader</span><span class="o">);</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">InputStreamReader</code>就是Java标准库提供的<code class="language-plaintext highlighter-rouge">Adapter</code>，它负责把一个<code class="language-plaintext highlighter-rouge">InputStream</code>适配为<code class="language-plaintext highlighter-rouge">Reader</code>。类似的还有<code class="language-plaintext highlighter-rouge">OutputStreamWriter</code>。</p><p>除了前面提到的对象适配器和类适配器之外，适配器思想还可以体现在以下几个方面：</p><ol><li><strong>接口适配器模式（Interface Adapter Pattern）</strong>：当一个接口中定义了许多方法，但只有部分方法需要被实现时，可以创建一个抽象类实现该接口，并为接口中的每个方法提供一个空实现。这样在需要使用该接口时，只需要继承这个抽象类，重写需要的方法即可，避免了在实现类中实现所有方法的繁琐性。</li><li><strong>数据适配器</strong>：将一个数据格式转换为另一个数据格式的过程可以看作是一种适配器思想的应用。例如，将一个JSON格式的数据转换为XML格式的数据，或者将一个数据结构转换为另一个数据结构以适应不同的应用场景。</li><li><strong>协议适配器</strong>：在网络通信中，不同的设备或系统可能使用不同的通信协议。协议适配器用于将一个通信协议转换为另一个通信协议，以实现不同设备或系统之间的通信。</li><li><strong>电源适配器</strong>：在不同国家或地区，电源插头的形状和电压标准可能不同。电源适配器用于将一个电源插头转换为另一个电源插头，以适应不同地区的电源标准。</li></ol><h3 id="桥接">桥接</h3><blockquote><p>将抽象部分与它的实现<strong>部分分离</strong>，使它们都可以独立地变化。</p></blockquote><p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p><pre><code class="language-ascii">                   ┌───────┐
                   │  Car  │
                   └───────┘
                       ▲
    ┌──────────────────┼───────────────────┐
    │                  │                   │
┌───────┐          ┌───────┐          ┌───────┐
│BigCar │          │TinyCar│          │BossCar│
└───────┘          └───────┘          └───────┘
    ▲                  ▲                  ▲
    │                  │                  │
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│
    │ └───────────────┘│ └───────────────┘│ └───────────────┘
    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐
    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │
      └───────────────┘  └───────────────┘  └───────────────┘
</code></pre><p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p><p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p><p>在桥接模式中，首先把<code class="language-plaintext highlighter-rouge">Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。</p><p>首先定义抽象类<code class="language-plaintext highlighter-rouge">Car</code>，它引用一个<code class="language-plaintext highlighter-rouge">Engine</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="c1">// 引用Engine:</span>
    <span class="kd">protected</span> <span class="nc">Engine</span> <span class="n">engine</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Car</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span> <span class="o">=</span> <span class="n">engine</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">start</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>紧接着，在一个“修正”的抽象类<code class="language-plaintext highlighter-rouge">RefinedCar</code>中定义一些<strong>额外操作</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">RefinedCar</span> <span class="kd">extends</span> <span class="nc">Car</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">RefinedCar</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">drive</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">engine</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"驾驶 "</span> <span class="o">+</span> <span class="n">getBrand</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 汽车..."</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">getBrand</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>这样一来，最终的不同品牌继承自<code class="language-plaintext highlighter-rouge">RefinedCar</code>，例如<code class="language-plaintext highlighter-rouge">BossCar</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">BossCar</span> <span class="kd">extends</span> <span class="nc">RefinedCar</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BossCar</span><span class="o">(</span><span class="nc">Engine</span> <span class="n">engine</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">engine</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getBrand</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Boss"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而针对每一种引擎，继承自<code class="language-plaintext highlighter-rouge">Engine</code>，例如<code class="language-plaintext highlighter-rouge">HybridEngine</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HybridEngine</span> <span class="kd">implements</span> <span class="nc">Engine</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"启动混合引擎"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的<code class="language-plaintext highlighter-rouge">Car</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RefinedCar</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BossCar</span><span class="o">(</span><span class="k">new</span> <span class="nc">HybridEngine</span><span class="o">());</span>
<span class="n">car</span><span class="o">.</span><span class="na">drive</span><span class="o">();</span>
</code></pre></div></div><p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code class="language-plaintext highlighter-rouge">Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code class="language-plaintext highlighter-rouge">RefinedCar</code>派生一个子类，任何<code class="language-plaintext highlighter-rouge">RefinedCar</code>的子类都可以和任何一种<code class="language-plaintext highlighter-rouge">Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p><pre><code class="language-ascii">       ┌───────────┐
       │    Car    │
       └───────────┘
             ▲
             │
       ┌───────────┐       ┌─────────┐
       │RefinedCar │ ─ ─ ─&gt;│ Engine  │
       └───────────┘       └─────────┘
             ▲                  ▲
    ┌────────┼────────┐         │ ┌──────────────┐
    │        │        │         ├─│  FuelEngine  │
┌───────┐┌───────┐┌───────┐     │ └──────────────┘
│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐
└───────┘└───────┘└───────┘     ├─│ElectricEngine│
                                │ └──────────────┘
                                │ ┌──────────────┐
                                └─│ HybridEngine │
                                  └──────────────┘
</code></pre><p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p><h3 id="组合">组合</h3><blockquote><p>将对象组合成<strong>树形结构</strong>以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p></blockquote><p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p><p>在组合模式中，有两种主要的对象：叶子节点和容器节点。叶子节点表示树中的最终节点，它没有子节点；容器节点表示包含子节点的节点，它可以包含叶子节点和其他容器节点。</p><p>通过使用组合模式，可以将单个对象和组合对象都视为相同类型的对象，从而可以统一处理它们。例如，无论是操作单个文件还是操作整个文件夹（包含多个文件和文件夹），客户端都可以使用相同的方式来进行操作，这样就简化了客户端的代码逻辑。</p><p>总的来说，组合模式可以构建具有层次结构的对象，并且可以统一处理这些对象，提高代码的灵活性和可维护性。</p><p>在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。要以树的结构表示XML，先抽象出节点<code class="language-plaintext highlighter-rouge">Node</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="c1">// 添加一个节点为子节点:</span>
    <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">);</span>
    <span class="c1">// 获取子节点:</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">();</span>
    <span class="c1">// 输出为XML:</span>
    <span class="nc">String</span> <span class="nf">toXml</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>对于一个<code class="language-plaintext highlighter-rouge">&lt;name&gt;</code>这样的节点，称之为<code class="language-plaintext highlighter-rouge">ElementNode</code>，它可以作为容器包含多个子节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ElementNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="nf">ElementNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">start</span> <span class="o">=</span> <span class="s">"&lt;"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"&gt;\n"</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">end</span> <span class="o">=</span> <span class="s">"&lt;/"</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">"&gt;"</span><span class="o">;</span>
        <span class="nc">StringJoiner</span> <span class="n">sj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringJoiner</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
        <span class="n">list</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">sj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">toXml</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="k">return</span> <span class="n">sj</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>对于普通文本，把它看作<code class="language-plaintext highlighter-rouge">TextNode</code>，它没有子节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">TextNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
	<span class="kd">public</span> <span class="nf">TextNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">text</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>此外，还可以有注释节点：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CommentNode</span> <span class="kd">implements</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">CommentNode</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">Node</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toXml</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"&lt;!-- "</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s">" --&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>通过<code class="language-plaintext highlighter-rouge">ElementNode</code>、<code class="language-plaintext highlighter-rouge">TextNode</code>和<code class="language-plaintext highlighter-rouge">CommentNode</code>，就可以构造出一颗树：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"school"</span><span class="o">);</span>
<span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"classA"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Tom"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Alice"</span><span class="o">)));</span>
<span class="n">root</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ElementNode</span><span class="o">(</span><span class="s">"classB"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">TextNode</span><span class="o">(</span><span class="s">"Grace"</span><span class="o">))</span>
        <span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">CommentNode</span><span class="o">(</span><span class="s">"comment..."</span><span class="o">)));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">toXml</span><span class="o">());</span>
</code></pre></div></div><p>最后通过<code class="language-plaintext highlighter-rouge">root</code>节点输出的XML如下：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;school&gt;
&lt;classA&gt;
Tom
Alice
&lt;/classA&gt;
&lt;classB&gt;
Bob
Grace
&lt;!-- comment... --&gt;
&lt;/classB&gt;
&lt;/school&gt;
</code></pre></div></div><p>使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p><pre><code class="language-ascii">             ┌───────────┐
             │   Node    │
             └───────────┘
                   ▲
      ┌────────────┼────────────┐
      │            │            │
┌───────────┐┌───────────┐┌───────────┐
│ElementNode││ TextNode  ││CommentNode│
└───────────┘└───────────┘└───────────┘
</code></pre><p>作为容器节点的<code class="language-plaintext highlighter-rouge">ElementNode</code>又可以添加任意个<code class="language-plaintext highlighter-rouge">Node</code>，这样就可以构成层级结构。</p><p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p><p>文件形式的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>


<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 创建文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File1.txt"</span><span class="o">);</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File2.txt"</span><span class="o">);</span>

        <span class="c1">// 创建文件夹并添加文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">folder1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Folder1"</span><span class="o">);</span>
        <span class="n">folder1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file1</span><span class="o">);</span>
        <span class="n">folder1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file2</span><span class="o">);</span>

        <span class="c1">// 创建文件夹并添加文件</span>
        <span class="nc">FileSystemComponent</span> <span class="n">folder2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Folder2"</span><span class="o">);</span>
        <span class="nc">FileSystemComponent</span> <span class="n">file3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"File3.txt"</span><span class="o">);</span>
        <span class="n">folder2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file3</span><span class="o">);</span>

        <span class="c1">// 将文件夹添加到根文件夹</span>
        <span class="nc">FileSystemComponent</span> <span class="n">rootFolder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Folder</span><span class="o">(</span><span class="s">"Root"</span><span class="o">);</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder1</span><span class="o">);</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">folder2</span><span class="o">);</span>

        <span class="c1">// 打印整个文件系统</span>
        <span class="n">rootFolder</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">FileSystemComponent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">);</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">File</span> <span class="kd">extends</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">File</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"File: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Folder</span> <span class="kd">extends</span> <span class="nc">FileSystemComponent</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">FileSystemComponent</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">Folder</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">children</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">children</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">component</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">sep</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"Folder: "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">FileSystemComponent</span> <span class="n">component</span> <span class="o">:</span> <span class="n">children</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">component</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">sep</span><span class="o">+</span><span class="s">"\t"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="装饰器">装饰器</h3><blockquote><p>动态地给一个对象<strong>添加一些额外的职责</strong>。就增加功能来说，相比生成子类更为灵活。</p></blockquote><p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p><p>在Java标准库中，<code class="language-plaintext highlighter-rouge">InputStream</code>是抽象类，<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">ServletInputStream</code>、<code class="language-plaintext highlighter-rouge">Socket.getInputStream()</code>这些<code class="language-plaintext highlighter-rouge">InputStream</code>都是最终数据源。</p><p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。</p><p>Decorator模式的目的就是一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得想要的功能。</p><p>例如：给<code class="language-plaintext highlighter-rouge">FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建原始的数据源:</span>
<span class="nc">InputStream</span> <span class="n">fis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">);</span>
<span class="c1">// 增加缓冲功能:</span>
<span class="nc">InputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedInputStream</span><span class="o">(</span><span class="n">fis</span><span class="o">);</span>
<span class="c1">// 增加解压缩功能:</span>
<span class="nc">InputStream</span> <span class="n">gis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>
</code></pre></div></div><p>或者一次性写成这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">InputStream</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GZIPInputStream</span><span class="o">(</span> <span class="c1">// 第二层装饰</span>
                        <span class="k">new</span> <span class="nf">BufferedInputStream</span><span class="o">(</span> <span class="c1">// 第一层装饰</span>
                            <span class="k">new</span> <span class="nf">FileInputStream</span><span class="o">(</span><span class="s">"test.gz"</span><span class="o">)</span> <span class="c1">// 核心功能</span>
                        <span class="o">));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">BufferedInputStream</code>和<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>实际上都是从<code class="language-plaintext highlighter-rouge">FilterInputStream</code>继承的，这个<code class="language-plaintext highlighter-rouge">FilterInputStream</code>就是一个抽象的Decorator。把Decorator模式画出来如下：</p><pre><code class="language-ascii">             ┌───────────┐
             │ Component │
             └───────────┘
                   ▲
      ┌────────────┼─────────────────┐
      │            │                 │
┌───────────┐┌───────────┐     ┌───────────┐
│ComponentA ││ComponentB │...  │ Decorator │
└───────────┘└───────────┘     └───────────┘
                                     ▲
                              ┌──────┴──────┐
                              │             │
                        ┌───────────┐ ┌───────────┐
                        │DecoratorA │ │DecoratorB │...
                        └───────────┘ └───────────┘
</code></pre><p>最顶层的<code class="language-plaintext highlighter-rouge">Component</code>是接口，对应到IO的就是<code class="language-plaintext highlighter-rouge">InputStream</code>这个抽象类。<code class="language-plaintext highlighter-rouge">ComponentA</code>、<code class="language-plaintext highlighter-rouge">ComponentB</code>是实际的子类，对应到IO的就是<code class="language-plaintext highlighter-rouge">FileInputStream</code>、<code class="language-plaintext highlighter-rouge">ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code class="language-plaintext highlighter-rouge">FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code class="language-plaintext highlighter-rouge">BufferedInputStream</code>、<code class="language-plaintext highlighter-rouge">GZIPInputStream</code>等。</p><p>Decorator模式实际上把核心功能和附加功能给分开了。核心功能指<code class="language-plaintext highlighter-rouge">FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。</p><p>如果要新增核心功能，就增加Component的子类，例如<code class="language-plaintext highlighter-rouge">ByteInputStream</code>。如果要增加附加功能，就增加Decorator的子类，例如<code class="language-plaintext highlighter-rouge">CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p><p>如果要设计完整的Decorator模式，应该如何设计？</p><p>假设需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p><p>首先，仍然需要定义顶层接口<code class="language-plaintext highlighter-rouge">TextNode</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="c1">// 设置text:</span>
    <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">);</span>
    <span class="c1">// 获取text:</span>
    <span class="nc">String</span> <span class="nf">getText</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>对于核心节点，例如<code class="language-plaintext highlighter-rouge">&lt;span&gt;</code>，它需要从<code class="language-plaintext highlighter-rouge">TextNode</code>直接继承：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpanNode</span> <span class="kd">implements</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"&lt;span&gt;"</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s">"&lt;/span&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为了实现Decorator模式，需要有一个抽象的Decorator类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">NodeDecorator</span> <span class="kd">implements</span> <span class="nc">TextNode</span> <span class="o">{</span>
    <span class="c1">//注意这里也实现了TextNode接口</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="nc">TextNode</span> <span class="n">target</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="nf">NodeDecorator</span><span class="o">(</span><span class="nc">TextNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">target</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这个<code class="language-plaintext highlighter-rouge">NodeDecorator</code>类的核心是持有一个<code class="language-plaintext highlighter-rouge">TextNode</code>，即将要把功能附加到的<code class="language-plaintext highlighter-rouge">TextNode</code>实例。接下来就可以写一个加粗功能：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoldDecorator</span> <span class="kd">extends</span> <span class="nc">NodeDecorator</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BoldDecorator</span><span class="o">(</span><span class="nc">TextNode</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getText</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//重写加了内容</span>
        <span class="k">return</span> <span class="s">"&lt;b&gt;"</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="na">getText</span><span class="o">()</span> <span class="o">+</span> <span class="s">"&lt;/b&gt;"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>调用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TextNode</span> <span class="n">n1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SpanNode</span><span class="o">();</span><span class="c1">//外层&lt;span&gt;</span>
<span class="n">n1</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span><span class="c1">//正常修改text</span>
<span class="nc">TextNode</span> <span class="n">n2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoldDecorator</span><span class="o">(</span><span class="n">n1</span><span class="o">);</span><span class="c1">//getText时加一个&lt;b&gt;包围原内容</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n2</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//调用栈：n2.getText()-&gt;n1.getText()</span>

<span class="nc">TextNode</span> <span class="n">n3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoldDecorator</span><span class="o">(</span><span class="n">n2</span><span class="o">);</span><span class="c1">//getText时加一个&lt;b&gt;包围原内容</span>
<span class="c1">//调用栈：n3.getText()-&gt;n2.getText()-&gt;n1.getText()</span>
<span class="c1">// n1返回text内容，然后n2加&lt;b&gt;返回，然后n1加&lt;b&gt;返回</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n3</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//&lt;b&gt;&lt;b&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;/b&gt;&lt;/b&gt;</span>
<span class="c1">//调用栈：n3.setText()-&gt;n2.setText()-&gt;n1.setText()-&gt;this.text = text;</span>
<span class="n">n3</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"HI"</span><span class="o">);</span><span class="c1">//只修改了text</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n3</span><span class="o">.</span><span class="na">getText</span><span class="o">());</span><span class="c1">//&lt;b&gt;&lt;b&gt;&lt;span&gt;HI&lt;/span&gt;&lt;/b&gt;&lt;/b&gt;</span>
</code></pre></div></div><p>类似的，可以继续加<code class="language-plaintext highlighter-rouge">ItalicDecorator</code>、<code class="language-plaintext highlighter-rouge">UnderlineDecorator</code>等。</p><hr /><p><strong>装饰器与桥接模式</strong></p><p>装饰器和桥接的目的都是降低继承中衍生的子类的数量。</p><p>桥接是通过把一个组件及其子类作为另一总体的字段引用实现功能组合，也可以用多个组件来拼合总体。桥接的子类是负责总体的局部功能，是构成性的，是必要的。</p><p>装饰器则在大类下创建一个装饰器的子族，不管是主要部件还是装饰器都隶属于这个大类，所以装饰器可以不断嵌套。装饰器则是对已经具有了完整功能的总体进行修饰，是附加性的，是可选的。</p><h3 id="外观">外观</h3><blockquote><p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个<strong>高层接口</strong>，这个接口使得这一子系统更加容易使用。</p></blockquote><p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p><p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p><p>以注册公司为例，假设注册公司需要三步：</p><ol><li>向工商局申请公司营业执照；</li><li>在银行开设账户；</li><li>在税务局开设纳税号。</li></ol><p>以下是三个系统的接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 工商注册:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AdminOfIndustry</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Company</span> <span class="nf">register</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 银行开户:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bank</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">openAccount</span><span class="o">(</span><span class="nc">String</span> <span class="n">companyId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 纳税登记:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Taxation</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">applyTaxCode</span><span class="o">(</span><span class="nc">String</span> <span class="n">companyId</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Facade</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Company</span> <span class="nf">openCompany</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Company</span> <span class="n">c</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">admin</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">bankAccount</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">bank</span><span class="o">.</span><span class="na">openAccount</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">c</span><span class="o">.</span><span class="na">setBankAccount</span><span class="o">(</span><span class="n">bankAccount</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">taxCode</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">taxation</span><span class="o">.</span><span class="na">applyTaxCode</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="n">c</span><span class="o">.</span><span class="na">setTaxCode</span><span class="o">(</span><span class="n">taxCode</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Company</span> <span class="n">c</span> <span class="o">=</span> <span class="n">facade</span><span class="o">.</span><span class="na">openCompany</span><span class="o">(</span><span class="s">"Facade Software Ltd."</span><span class="o">);</span>
</code></pre></div></div><p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code class="language-plaintext highlighter-rouge">RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p><p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p><p>也就是说，我如果需要实现一个功能，比如打印水仙花数，我可以直接在main里写，也可以封装打印水仙花数为一个函数，然后通过主函数调用这个函数。这就是一种简单的外观模式的应用。外观模式的核心思想就是封装复杂的逻辑，提供一个简单的接口给客户端使用，从而简化客户端的操作。</p><h3 id="享元">享元</h3><blockquote><p>运用共享技术有效地支持大量细粒度的对象。</p></blockquote><p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就<strong>没有必要</strong>，直接向调用方返回一个<strong>共享的实例</strong>就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p><p>享元模式在Java标准库中有很多应用。包装类型如<code class="language-plaintext highlighter-rouge">Byte</code>、<code class="language-plaintext highlighter-rouge">Integer</code>都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以<code class="language-plaintext highlighter-rouge">Integer</code>为例，如果我们通过<code class="language-plaintext highlighter-rouge">Integer.valueOf()</code>这个静态工厂方法创建<code class="language-plaintext highlighter-rouge">Integer</code>实例，当传入的<code class="language-plaintext highlighter-rouge">int</code>范围在<code class="language-plaintext highlighter-rouge">-128</code>~<code class="language-plaintext highlighter-rouge">+127</code>之间时，会直接返回缓存的<code class="language-plaintext highlighter-rouge">Integer</code>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">n1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="nc">Integer</span> <span class="n">n2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="o">);</span> <span class="c1">// true</span>
</code></pre></div></div><p>对于<code class="language-plaintext highlighter-rouge">Byte</code>来说，因为它一共只有256个状态，所以，通过<code class="language-plaintext highlighter-rouge">Byte.valueOf()</code>创建的<code class="language-plaintext highlighter-rouge">Byte</code>实例，全部都是缓存对象。</p><p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的<strong>复用</strong>。</p><p>总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p><p>在实际应用中，<strong>享元模式主要应用于缓存</strong>，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p><p>以<code class="language-plaintext highlighter-rouge">Student</code>为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="c1">// 持有缓存:</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Student</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 静态工厂方法:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Student</span> <span class="nf">create</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="n">id</span> <span class="o">+</span> <span class="s">"\n"</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
        <span class="c1">// 先查找缓存:</span>
        <span class="nc">Student</span> <span class="n">std</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">std</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 未找到,创建新对象:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"create new Student(%s, %s)"</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">));</span>
            <span class="n">std</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
            <span class="c1">// 放入缓存:</span>
            <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">std</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="c1">// 缓存中存在:</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"return cached Student(%s, %s)"</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="na">id</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="na">name</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在实际应用中，经常使用成熟的缓存库，例如<a href="https://github.com/google/guava">Guava</a>的<a href="https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java">Cache</a>，因为它提供了最大缓存数量限制、定时过期等实用功能。</p><p>享元模式的设计思想是尽量复用已创建的对象，常用于工厂方法内部的优化。</p><p>单例模式是不允许创建新实例，只能使用一个实例。</p><p>而享元要求<strong>实例不变</strong>，才能把“创建一个新实例”的操作给优化成“直接返回一个缓存的实例”。</p><h3 id="代理">代理</h3><blockquote><p>为其他对象提供一种代理以<strong>控制</strong>对这个对象的访问。</p></blockquote><p>代理模式，即Proxy，它和Adapter模式很类似。Adapter模式，它用于把A接口转换为B接口，即做兼容：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BAdapter</span> <span class="kd">implements</span> <span class="no">B</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">BAdapter</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">AProxy</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这是原始的，可以加功能，比如权限判断来限制访问，打印日志：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">A</span> <span class="n">aProxy</span><span class="o">=</span><span class="k">new</span> <span class="nc">AProxy</span><span class="o">(</span><span class="k">new</span> <span class="nc">AImpl</span><span class="o">());</span>
        <span class="n">aProxy</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">a</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AImpl</span> <span class="kd">implements</span> <span class="no">A</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"原功能"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">AProxy</span> <span class="kd">implements</span> <span class="no">A</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="no">A</span> <span class="n">a</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">AProxy</span><span class="o">(</span><span class="no">A</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用前"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">.</span><span class="na">a</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"调用后"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为什么不把权限检查的功能直接写到目标实例的内部？因为编写代码的原则有：</p><ul><li>职责清晰：一个类只负责一件事；</li><li>易于测试：一次只测一个功能。</li></ul><p>用Proxy实现这个权限检查，可以获得更清晰、更简洁的代码：</p><ul><li><code class="language-plaintext highlighter-rouge">A</code>接口：只定义接口；</li><li><code class="language-plaintext highlighter-rouge">AImpl</code>类：只实现A接口的业务逻辑；</li><li><code class="language-plaintext highlighter-rouge">AProxy</code>类：只实现A接口的日志输出代理。</li></ul><p>如果希望编写其他类型的代理，可以继续增加，一个套一个。</p><p>实际上权限检查、打印日志只是代理模式的一种应用。Proxy还广泛应用在：</p><p><strong>远程代理</strong></p><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p><p><strong>虚代理</strong></p><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p><p>例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">I</span> <span class="n">a</span><span class="o">=</span><span class="no">I</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"得到对象"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kd">static</span> <span class="no">I</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">I</span><span class="o">()</span> <span class="o">{</span>
            <span class="kd">private</span> <span class="no">I</span> <span class="n">i</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
                    <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
                <span class="o">}</span>
                <span class="n">i</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">();</span>
<span class="o">}</span>


<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"打印"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>再加上队列复用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">r</span><span class="o">=()-&gt;{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
                <span class="k">try</span><span class="o">(</span><span class="no">I</span> <span class="n">a</span><span class="o">=</span><span class="no">I</span><span class="o">.</span><span class="na">getInstance</span><span class="o">()){</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
                    <span class="n">a</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="no">I</span><span class="o">.</span><span class="na">idleQueue</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span> <span class="kd">extends</span> <span class="nc">AutoCloseable</span><span class="o">{</span>
    <span class="cm">/*空闲队列，线程安全的*/</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">I</span><span class="o">&gt;</span> <span class="n">idleQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayBlockingQueue</span><span class="o">&lt;&gt;(</span><span class="mi">100</span><span class="o">);</span>
    <span class="cm">/**
     * 虚代理
     * @return 虚代理
     */</span>
    <span class="kd">static</span> <span class="no">I</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*复用空闲的A代理*/</span>
        <span class="no">I</span> <span class="n">i</span> <span class="o">=</span> <span class="n">idleQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="nc">Aproxy</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">();</span>
<span class="o">}</span>
 <span class="kd">class</span> <span class="nc">Aproxy</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="kd">private</span> <span class="no">I</span> <span class="n">i</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*调用方法时才实例化*/</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">i</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="cm">/*丢回空闲队列*/</span>
        <span class="n">idleQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"假装关闭了"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="kd">public</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"实例化"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"打印"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已关闭"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>A最多只实例化了2次，因为只有2个线程。如果注释掉：<code class="language-plaintext highlighter-rouge">a.print();</code>，则A实例化0次，因为使用了虚代理。</p><p><strong>保护代理</strong></p><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p><p><strong>智能引用</strong></p><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p><p>代理模式和装饰器模式有一些相似之处，但它们的目的和使用方式略有不同：</p><ul><li><strong>装饰器模式</strong>：装饰器模式旨在动态地给对象<strong>添加额外的职责</strong>，而不改变其接口。它通常通过创建一个包装对象来包裹真实的对象，并在保持真实对象接口不变的情况下，增加额外的功能或责任。</li><li><strong>代理模式</strong>：代理模式为其他对象提供一种代理以<strong>控制对这个对象的访问</strong>。代理类通常在客户端和真实主题之间充当中介，可以用于控制对真实对象的访问权限、缓存对象的访问结果、延迟加载对象等。</li></ul><p>虽然两者都涉及到包装一个对象以增强其功能，但装饰器模式注重于增加新的行为，而代理模式注重于控制对对象的访问。</p><p>Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p><h2 id="行为型模式">行为型模式</h2><p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p><p>行为型模式有：</p><p>责任链模式（Chain of Responsibility）：将请求的发送者和接收者<strong>解耦</strong>，让多个对象<strong>都有机会</strong>处理这个请求。</p><p>命令模式（Command）：将请求封装成一个对象，从而可以用不同的请求对客户进行参数化，并且对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>解释器模式（Interpreter）：给定一个语言，定义它的文法的一种表示，并定义一个<strong>解释器</strong>，该解释器使用该表示来解释语言中的句子。</p><p>迭代器模式（Iterator）：提供一种方法<strong>顺序访问</strong>一个<strong>聚合对象中各个元素</strong>，而又不暴露该对象的内部表示。</p><p>中介模式（Mediator）：用一个<strong>中介对象</strong>来封装一系列的对象交互，使得对象<strong>不需要显式地相互引用</strong>，从而达到解耦的目的。</p><p>备忘录模式（Memento）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外<strong>保存</strong>这个状态，以便之后<strong>恢复</strong>对象到原先保存的状态。</p><p>观察者模式（Observer）：定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象状态发生变化时，会通知所有的观察者对象。观察者模式就是要分离被观察者和观察者之间的<strong>耦合关系</strong>。</p><p>状态模式（State）：允许对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式将<strong>对象的状态封装成独立的类</strong>，并将不同状态对应的行为<strong>抽象</strong>出来，使得<strong>在不同状态下可以定义不同的行为</strong>，而不需要使用大量的条件语句来判断当前状态。这样可以让代码更加清晰、可维护，同时也符合开闭原则，因为添加新的状态类不会影响现有代码。</p><p>策略模式（Strategy）：定义了一系列的算法，并将每一个算法封装起来，使得它们可以相互替换，<strong>让算法独立于使用它的客户而独立变化</strong>。</p><p>模板方法模式（Template Method）：定义一个操作中的算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变一个算法的<strong>结构</strong>即可<strong>重定义</strong>该算法的某些<strong>特定步骤</strong>。</p><p>访问者模式（Visitor）：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的<strong>新操作</strong>。访问者模式的核心思想是访问比较复杂的数据结构时，不去改变数据结构，而是把对数据的操作<strong>抽象</strong>出来，在“访问”的过程中<strong>以回调形式</strong>在访问者中<strong>处理操作逻辑</strong>。如果要新增一组操作，那么只需要增加一个新的访问者。</p><h3 id="责任链">责任链</h3><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p></blockquote><p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到<strong>其中某个处理成功为止</strong>。责任链模式把多个处理器串成链，然后让请求在链上传递。</p><p>用责任链模式时，每个处理方法只关心自己责任的范围内的数据。对于超出自己责任范围的，扔给下一个处理方法。</p><p>定义一个要处理的<code class="language-plaintext highlighter-rouge">Request</code>数据：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Data</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">=</span><span class="s">""</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Data</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setId</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSum</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>抽象出处理方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">I</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// 返回Boolean.TRUE = 成功</span>
    <span class="c1">// 返回Boolean.FALSE = 拒绝</span>
    <span class="c1">// 返回null = 交下一个处理</span>
    <span class="nc">Boolean</span> <span class="nf">process</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>实现：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AHandler</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">&lt;</span><span class="nc">Data</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Boolean</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Data</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getSum</span><span class="o">()&gt;=</span><span class="mi">90</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"优"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="cm">/*继续责任链*/</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">BHandler</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">&lt;</span><span class="nc">Data</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Boolean</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Data</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getSum</span><span class="o">()&gt;=</span><span class="mi">80</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"良"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="cm">/*继续责任链*/</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CHandler</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">&lt;</span><span class="nc">Data</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Boolean</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Data</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getSum</span><span class="o">()&gt;=</span><span class="mi">60</span><span class="o">){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"及格"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="cm">/*继续责任链*/</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">DHandler</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">&lt;</span><span class="nc">Data</span><span class="o">&gt;{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Boolean</span> <span class="nf">process</span><span class="o">(</span><span class="nc">Data</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">getSum</span><span class="o">()&gt;=</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"不及格"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="cm">/*停止责任链*/</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>组合处理方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HandlerChain</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="no">I</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">handlers</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addHandler</span><span class="o">(</span><span class="no">I</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">handlers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">start</span><span class="o">(</span><span class="no">T</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 依次调用每个Handler:</span>
        <span class="k">for</span> <span class="o">(</span><span class="no">I</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">handler</span> <span class="o">:</span> <span class="n">handlers</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">Boolean</span> <span class="n">r</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 如果返回TRUE或FALSE，处理结束:</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">data</span><span class="o">+</span> <span class="o">(</span><span class="n">r</span> <span class="o">?</span> <span class="s">"已打分"</span> <span class="o">:</span> <span class="s">"已拒绝"</span><span class="o">)</span> <span class="o">+</span><span class="n">handler</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"没有责任方法对此处理："</span> <span class="o">+</span> <span class="n">data</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*构造责任链*/</span>
<span class="nc">HandlerChain</span><span class="o">&lt;</span><span class="nc">Data</span><span class="o">&gt;</span> <span class="n">handlerChain</span><span class="o">=</span><span class="k">new</span> <span class="nc">HandlerChain</span><span class="o">&lt;&gt;();</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">addHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">AHandler</span><span class="o">());</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">addHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">BHandler</span><span class="o">());</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">addHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">CHandler</span><span class="o">());</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">addHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">DHandler</span><span class="o">());</span>
<span class="cm">/*使用责任链*/</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="nc">Data</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="s">"小并"</span><span class="o">,</span><span class="mi">100</span><span class="o">));</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="nc">Data</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="s">"小西"</span><span class="o">,</span><span class="mi">60</span><span class="o">));</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="nc">Data</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="s">"小强"</span><span class="o">,</span><span class="mi">50</span><span class="o">));</span>
<span class="n">handlerChain</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="k">new</span> <span class="nc">Data</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="s">"小希"</span><span class="o">,-</span><span class="mi">1</span><span class="o">));</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>优
test.Data@8c3b9d已打分AHandler
及格
test.Data@4c39bec8已打分CHandler
不及格
test.Data@f79e已拒绝DHandler
test.Data@7ee8290b已拒绝DHandler
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Handler</code>添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。</p><p>责任链模式有很多变种。有些责任链的实现方式是通过某个<code class="language-plaintext highlighter-rouge">Handler</code>手动调用下一个<code class="language-plaintext highlighter-rouge">Handler</code>来传递<code class="language-plaintext highlighter-rouge">Request</code>。</p><p>还有一些责任链模式，每个<code class="language-plaintext highlighter-rouge">Handler</code>都有机会处理<code class="language-plaintext highlighter-rouge">Request</code>，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个<code class="language-plaintext highlighter-rouge">Handler</code>处理掉<code class="language-plaintext highlighter-rouge">Request</code>，而是每个<code class="language-plaintext highlighter-rouge">Handler</code>都做一些工作，比如：记录日志；检查权限；准备相关资源；</p><p>Servlet规范定义的<code class="language-plaintext highlighter-rouge">Filter</code>就是一种责任链模式，它不但允许每个<code class="language-plaintext highlighter-rouge">Filter</code>都有机会处理请求，还允许每个<code class="language-plaintext highlighter-rouge">Filter</code>决定是否将请求“放行”给下一个<code class="language-plaintext highlighter-rouge">Filter</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">AuditFilter</span> <span class="kd">implements</span> <span class="nc">Filter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="o">(</span><span class="nc">ServletRequest</span> <span class="n">req</span><span class="o">,</span> <span class="nc">ServletResponse</span> <span class="n">resp</span><span class="o">,</span> <span class="nc">FilterChain</span> <span class="n">chain</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">ServletException</span> <span class="o">{</span>
        <span class="c1">//做些工作，如果做完了就放行给下一个：</span>
        <span class="n">chain</span><span class="o">.</span><span class="na">doFilter</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这种模式不但允许一个<code class="language-plaintext highlighter-rouge">Filter</code>自行决定处理<code class="language-plaintext highlighter-rouge">ServletRequest</code>和<code class="language-plaintext highlighter-rouge">ServletResponse</code>，还可以“伪造”<code class="language-plaintext highlighter-rouge">ServletRequest</code>和<code class="language-plaintext highlighter-rouge">ServletResponse</code>以便让下一个<code class="language-plaintext highlighter-rouge">Filter</code>处理，能实现非常复杂的功能。</p><p>责任链模式是一种把多个处理器组合在一起，依次处理请求的模式，添加新的处理器或者重新排列处理器非常容易，经常用在拦截、预处理请求等。</p><h3 id="命令">命令</h3><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p></blockquote><p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。</p><p>一个抽象的编辑器：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">TextEditor</span> <span class="n">editor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TextEditor</span><span class="o">();</span>
        <span class="n">editor</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Command pattern in text editor.\n"</span><span class="o">);</span>
        <span class="n">editor</span><span class="o">.</span><span class="na">copy</span><span class="o">();</span>
        <span class="n">editor</span><span class="o">.</span><span class="na">paste</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TextEditor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paste</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//String text = getFromClipBoard();</span>
        <span class="c1">//add(text);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>用一个<code class="language-plaintext highlighter-rouge">StringBuilder</code>模拟一个文本编辑器，它支持<code class="language-plaintext highlighter-rouge">copy()</code>、<code class="language-plaintext highlighter-rouge">paste()</code>、<code class="language-plaintext highlighter-rouge">add()</code>、<code class="language-plaintext highlighter-rouge">delete()</code>等方法。而调用方需要了解<code class="language-plaintext highlighter-rouge">TextEditor</code>的所有接口信息。</p><p>如果改用命令模式，就要把调用方发送命令和执行方执行命令分开。通过引入一个<code class="language-plaintext highlighter-rouge">Command</code>接口，调用方创建一个对应的<code class="language-plaintext highlighter-rouge">Command</code>，然后执行，并不关心内部是如何具体执行的。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">TextEditor</span> <span class="n">editor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TextEditor</span><span class="o">();</span>
        <span class="n">editor</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Command pattern in text editor.\n"</span><span class="o">);</span>
        <span class="nc">Command</span> <span class="n">command</span><span class="o">=</span><span class="k">new</span> <span class="nc">CopyCommand</span><span class="o">(</span><span class="n">editor</span><span class="o">);</span>
        <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
        <span class="nc">Command</span> <span class="n">command2</span><span class="o">=</span><span class="k">new</span> <span class="nc">PasteCommand</span><span class="o">(</span><span class="n">editor</span><span class="o">);</span>
        <span class="n">command2</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Command</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">execute</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CopyCommand</span> <span class="kd">implements</span> <span class="nc">Command</span> <span class="o">{</span>
    <span class="c1">// 持有执行者对象:</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TextEditor</span> <span class="n">receiver</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CopyCommand</span><span class="o">(</span><span class="nc">TextEditor</span> <span class="n">receiver</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">receiver</span> <span class="o">=</span> <span class="n">receiver</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">receiver</span><span class="o">.</span><span class="na">copy</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">PasteCommand</span> <span class="kd">implements</span> <span class="nc">Command</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TextEditor</span> <span class="n">receiver</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PasteCommand</span><span class="o">(</span><span class="nc">TextEditor</span> <span class="n">receiver</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">receiver</span> <span class="o">=</span> <span class="n">receiver</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">receiver</span><span class="o">.</span><span class="na">paste</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TextEditor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">copy</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">paste</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//String text = getFromClipBoard();</span>
        <span class="c1">//add(text);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>实际上，使用命令模式，增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。</p><p>如果<code class="language-plaintext highlighter-rouge">TextEditor</code>复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为可以直接给每个命令增加<code class="language-plaintext highlighter-rouge">undo()</code>，然后把执行的一系列命令用<code class="language-plaintext highlighter-rouge">List</code>保存起来，就既能支持Undo，又能支持Redo。这个时候，又需要一个<code class="language-plaintext highlighter-rouge">Invoker</code>对象，负责执行命令并保存历史命令。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Invoker</span> <span class="n">invoker</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Invoker</span><span class="o">();</span>

        <span class="nc">TextEditor</span> <span class="n">editor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TextEditor</span><span class="o">();</span>
        <span class="nc">Command</span> <span class="n">add</span><span class="o">=</span><span class="k">new</span> <span class="nc">AddCommand</span><span class="o">(</span><span class="n">editor</span><span class="o">);</span>
        <span class="n">add</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"文本编辑器命令模式。"</span><span class="o">);</span>

        <span class="n">invoker</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">add</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>

        <span class="n">invoker</span><span class="o">.</span><span class="na">undo</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>

        <span class="n">invoker</span><span class="o">.</span><span class="na">redo</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>

        <span class="n">add</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"测试"</span><span class="o">);</span>
        <span class="n">invoker</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">add</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
        <span class="n">invoker</span><span class="o">.</span><span class="na">undo</span><span class="o">();</span>
        <span class="n">invoker</span><span class="o">.</span><span class="na">undo</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
        <span class="n">invoker</span><span class="o">.</span><span class="na">redo</span><span class="o">();</span>
        <span class="n">invoker</span><span class="o">.</span><span class="na">redo</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">editor</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>

    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Invoker</span><span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Command</span><span class="o">&gt;</span> <span class="n">commands</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kt">int</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="o">(</span><span class="nc">Command</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">command</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
        <span class="n">commands</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="n">index</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">undo</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"无撤销的命令"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">commands</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">).</span><span class="na">undo</span><span class="o">();</span>
        <span class="n">index</span><span class="o">--;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">redo</span><span class="o">(){</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;</span><span class="n">commands</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"无恢复的命令"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">index</span><span class="o">++;</span>
        <span class="n">commands</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">).</span><span class="na">redo</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Command</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">undo</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">redo</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">execute</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">AddCommand</span> <span class="kd">implements</span> <span class="nc">Command</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">TextEditor</span> <span class="n">receiver</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">text</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span>


    <span class="kd">public</span> <span class="nf">AddCommand</span><span class="o">(</span><span class="nc">TextEditor</span> <span class="n">receiver</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">receiver</span> <span class="o">=</span> <span class="n">receiver</span><span class="o">;</span>
        <span class="cm">/*最初的值*/</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">receiver</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
        <span class="n">index</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setText</span><span class="o">(</span><span class="nc">String</span> <span class="n">text</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">text</span><span class="o">=</span><span class="n">text</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">undo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"无撤销的命令"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">index</span><span class="o">--;</span>
        <span class="n">receiver</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">redo</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="o">&gt;=</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()){</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"无恢复的命令"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">index</span><span class="o">++;</span>
        <span class="n">receiver</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">receiver</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">text</span><span class="o">);</span>
        <span class="cm">/*更新或者添加*/</span>
        <span class="n">index</span><span class="o">++;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()&gt;</span><span class="n">index</span><span class="o">){</span>
            <span class="n">list</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">index</span><span class="o">,</span><span class="k">this</span><span class="o">.</span><span class="na">receiver</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">receiver</span><span class="o">.</span><span class="na">getState</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TextEditor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">StringBuilder</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">buffer</span><span class="o">.</span><span class="na">deleteCharAt</span><span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setState</span><span class="o">(</span><span class="nc">String</span> <span class="n">state</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">buffer</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
        <span class="n">buffer</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">state</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>命令模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。</p><h3 id="解释器">解释器</h3><blockquote><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p></blockquote><p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。</p><p>匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"+861012345678"</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">"^\\+\\d+$"</span><span class="o">));</span>
</code></pre></div></div><p>比如执行java程序，可以在控制台添加参数，而具体要执行什么逻辑实现比较复杂，而用户只需根据文档指定参数即可实现功能。</p><h3 id="迭代器">迭代器</h3><blockquote><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p></blockquote><p>迭代器模式（Iterator）在Java的集合类中广泛使用。以<code class="language-plaintext highlighter-rouge">List</code>为例，要遍历<code class="language-plaintext highlighter-rouge">ArrayList</code>，即使知道它的内部存储了一个<code class="language-plaintext highlighter-rouge">Object[]</code>数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用<code class="language-plaintext highlighter-rouge">Iterator</code>遍历，那么，<code class="language-plaintext highlighter-rouge">ArrayList</code>和<code class="language-plaintext highlighter-rouge">LinkedList</code>都可以以一种统一的接口来遍历：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Orange"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>因为Iterator模式十分有用，因此，Java允许直接把任何支持<code class="language-plaintext highlighter-rouge">Iterator</code>的集合对象用<code class="language-plaintext highlighter-rouge">foreach</code>循环写出来：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">,</span> <span class="s">"Orange"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>然后由Java编译器完成Iterator模式的所有循环代码。</p><p>如果我们自己编写了一个集合类，想要使用<code class="language-plaintext highlighter-rouge">for each</code>循环，只需满足以下条件：</p><ul><li>集合类实现<code class="language-plaintext highlighter-rouge">Iterable</code>接口，该接口要求返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象；</li><li>用<code class="language-plaintext highlighter-rouge">Iterator</code>对象迭代集合内部数据。</li></ul><p>这里的关键在于，集合类通过调用<code class="language-plaintext highlighter-rouge">iterator()</code>方法，返回一个<code class="language-plaintext highlighter-rouge">Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p><p>一个简单的<code class="language-plaintext highlighter-rouge">Iterator</code>示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">rlist</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReverseList</span><span class="o">&lt;&gt;();</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Orange"</span><span class="o">);</span>
        <span class="n">rlist</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Pear"</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">rlist</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">ReverseList</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;&gt;()</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="no">T</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nc">ReverseList</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">++);</span>
            <span class="o">}</span>
        <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>虽然实现类稍微比较复杂，但这是底层集合库，只需编写一次。而调用方则完全按<code class="language-plaintext highlighter-rouge">for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p><p>在编写<code class="language-plaintext highlighter-rouge">Iterator</code>的时候，通常可以用一个内部类来实现<code class="language-plaintext highlighter-rouge">Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类可以用<code class="language-plaintext highlighter-rouge">ReverseList.this</code>获得当前外部类的<code class="language-plaintext highlighter-rouge">this</code>引用，然后，通过这个<code class="language-plaintext highlighter-rouge">this</code>引用就可以访问<code class="language-plaintext highlighter-rouge">ReverseList</code>的所有字段和方法。</p><p><code class="language-plaintext highlighter-rouge">Iterator</code>是一种抽象的数据访问模型。使用<code class="language-plaintext highlighter-rouge">Iterator</code>模式进行迭代的好处有：</p><ul><li>对任何集合都采用同一种访问模型；</li><li>调用者对集合内部结构一无所知；</li><li>集合类返回的<code class="language-plaintext highlighter-rouge">Iterator</code>对象知道如何迭代。</li></ul><p>Java提供了标准的迭代器模型，即集合类实现<code class="language-plaintext highlighter-rouge">java.util.Iterable</code>接口，返回<code class="language-plaintext highlighter-rouge">java.util.Iterator</code>实例。</p><h3 id="中介">中介</h3><blockquote><p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p></blockquote><p>中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p><p>假设有一个多选框，有三个选项，然后有三个按钮，一个是全选，一个是全不选，一个是反选。当多选框全都没有选的时候全不选按钮失效，当多选框全都选了的时候全选按钮失效。当用户点击反选的时候也可能影响全选和全不选按钮的生效情况，如果不加入一个中间对象，那么代码会比较复杂，耦合性也会增加。</p><p>如果引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了。它把多边关系变成多个双边关系，从而简化系统组件的交互耦合度。</p><p>按钮组件：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">SelectButton</span><span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">state</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
    <span class="kd">abstract</span> <span class="kt">boolean</span> <span class="nf">start</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">multiCheckBox</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SelectAllButton</span> <span class="kd">extends</span> <span class="nc">SelectButton</span><span class="o">{</span>

    <span class="kt">boolean</span> <span class="nf">start</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">multiCheckBox</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">state</span><span class="o">)</span><span class="k">return</span> <span class="kc">false</span><span class="o">;</span><span class="c1">//检查按钮是否可点击</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">multiCheckBox</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CancelAllButton</span> <span class="kd">extends</span> <span class="nc">SelectButton</span><span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">start</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">multiCheckBox</span><span class="o">){</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">state</span><span class="o">)</span><span class="k">return</span> <span class="kc">false</span><span class="o">;</span><span class="c1">//检查按钮是否可点击</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">multiCheckBox</span><span class="o">,</span><span class="kc">false</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">CounterSelectButton</span> <span class="kd">extends</span> <span class="nc">SelectButton</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">start</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">multiCheckBox</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">state</span><span class="o">)</span><span class="k">return</span> <span class="kc">false</span><span class="o">;</span><span class="c1">//检查按钮是否可点击</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">multiCheckBox</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">multiCheckBox</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">multiCheckBox</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>中间人：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UI</span><span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="o">[]</span><span class="n">multiCheckBox</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">SelectAllButton</span> <span class="n">selectAllButton</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CancelAllButton</span> <span class="n">cancelAllButton</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CounterSelectButton</span> <span class="n">counterSelectButton</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">UI</span><span class="o">(</span><span class="kt">boolean</span><span class="o">[]</span> <span class="n">multiCheckBox</span><span class="o">,</span> <span class="nc">SelectAllButton</span> <span class="n">selectAllButton</span><span class="o">,</span> <span class="nc">CancelAllButton</span> <span class="n">cancelAllButton</span><span class="o">,</span> <span class="nc">CounterSelectButton</span> <span class="n">counterSelectButton</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">multiCheckBox</span> <span class="o">=</span> <span class="n">multiCheckBox</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">selectAllButton</span> <span class="o">=</span> <span class="n">selectAllButton</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cancelAllButton</span> <span class="o">=</span> <span class="n">cancelAllButton</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">counterSelectButton</span> <span class="o">=</span> <span class="n">counterSelectButton</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">changeEvent</span><span class="o">(){</span>
        <span class="kt">int</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">boolean</span> <span class="n">checkBox</span> <span class="o">:</span> <span class="n">multiCheckBox</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">checkBox</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">==</span><span class="n">multiCheckBox</span><span class="o">.</span><span class="na">length</span><span class="o">){</span>
            <span class="n">selectAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
            <span class="n">cancelAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">count</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">selectAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
            <span class="n">cancelAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">selectAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
            <span class="n">cancelAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
        <span class="n">multiCheckBox</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
        <span class="n">changeEvent</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">){</span>
        <span class="n">multiCheckBox</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span>
        <span class="n">changeEvent</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kt">boolean</span> <span class="nf">selectAllButton</span><span class="o">(){</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">selectAllButton</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="n">multiCheckBox</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span><span class="n">selectAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">boolean</span> <span class="nf">cancelAllButton</span><span class="o">(){</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">cancelAllButton</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="n">multiCheckBox</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">flag</span><span class="o">)</span><span class="n">cancelAllButton</span><span class="o">.</span><span class="na">state</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">boolean</span> <span class="nf">counterSelectButton</span><span class="o">(){</span>
        <span class="kt">boolean</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">counterSelectButton</span><span class="o">.</span><span class="na">start</span><span class="o">(</span><span class="n">multiCheckBox</span><span class="o">);</span>
        <span class="n">changeEvent</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">flag</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>使用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="o">[]</span><span class="n">multiCheckBox</span><span class="o">={</span><span class="kc">false</span><span class="o">,</span><span class="kc">false</span><span class="o">,</span><span class="kc">false</span><span class="o">};</span><span class="cm">/*多选框组件*/</span>
<span class="nc">SelectAllButton</span> <span class="n">selectAllButton</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SelectAllButton</span><span class="o">();</span><span class="cm">/*全选按钮*/</span>
<span class="nc">CancelAllButton</span> <span class="n">cancelAllButton</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CancelAllButton</span><span class="o">();</span><span class="cm">/*全不选按钮*/</span>
<span class="nc">CounterSelectButton</span> <span class="n">counterSelectButton</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CounterSelectButton</span><span class="o">();</span><span class="cm">/*反选按钮*/</span>
<span class="no">UI</span> <span class="n">ui</span> <span class="o">=</span> <span class="k">new</span> <span class="no">UI</span><span class="o">(</span><span class="n">multiCheckBox</span><span class="o">,</span><span class="n">selectAllButton</span><span class="o">,</span> <span class="n">cancelAllButton</span><span class="o">,</span> <span class="n">counterSelectButton</span><span class="o">);</span><span class="cm">/*中间人*/</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ui</span><span class="o">.</span><span class="na">selectAllButton</span><span class="o">()?</span><span class="s">"全选执行成功"</span><span class="o">:</span><span class="s">"全选按钮失效"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ui</span><span class="o">.</span><span class="na">selectAllButton</span><span class="o">()?</span><span class="s">"全选执行成功"</span><span class="o">:</span><span class="s">"全选按钮失效"</span><span class="o">);</span>
<span class="n">ui</span><span class="o">.</span><span class="na">cancel</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ui</span><span class="o">.</span><span class="na">selectAllButton</span><span class="o">()?</span><span class="s">"全选执行成功"</span><span class="o">:</span><span class="s">"全选按钮失效"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ui</span><span class="o">.</span><span class="na">counterSelectButton</span><span class="o">()?</span><span class="s">"反选执行成功"</span><span class="o">:</span><span class="s">"反选按钮失效"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ui</span><span class="o">.</span><span class="na">cancelAllButton</span><span class="o">()?</span><span class="s">"全不选执行成功"</span><span class="o">:</span><span class="s">"全不选按钮失效"</span><span class="o">);</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>全选执行成功
全选按钮失效
全选执行成功
反选执行成功
全不选按钮失效
</code></pre></div></div><p>使用Mediator模式后，各个UI组件互不引用，这样就减少了组件之间的耦合关系，Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；如果新增一个UI组件，只需要修改Mediator更新状态的逻辑，现有的<strong>其他UI组件代码不变</strong>。</p><h3 id="备忘录">备忘录</h3><blockquote><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p></blockquote><p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p><p>几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。</p><p>对于文本编辑器来说，保存就是把<code class="language-plaintext highlighter-rouge">TextEditor</code>类的字符串存储到文件，打开就是恢复<code class="language-plaintext highlighter-rouge">TextEditor</code>类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。</p><p>在使用文本编辑器的时候，还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把<code class="language-plaintext highlighter-rouge">TextEditor</code>类的字符串复制一份存起来，这样就可以Undo或Redo。之前在命令模式中实现撤销重做的<code class="language-plaintext highlighter-rouge">AddCommand</code>类中就用到了备忘录模式记录文本。</p><p>标准的备忘录模式有这么几种角色：</p><ul><li>Memento：存储的内部状态；</li><li>Originator：创建一个备忘录并设置其状态；</li><li>Caretaker：负责保存备忘录。</li></ul><p>实际上在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似<code class="language-plaintext highlighter-rouge">TextEditor</code>的类，增加<code class="language-plaintext highlighter-rouge">getState()</code>和<code class="language-plaintext highlighter-rouge">setState()</code>就可以了。对这个简单的文本编辑器，用一个<code class="language-plaintext highlighter-rouge">String</code>就可以表示其状态，对于复杂的对象模型，通常会使用JSON、XML或序列化等复杂格式。</p><h3 id="观察者">观察者</h3><blockquote><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p></blockquote><p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p><p>假设一个电商网站，有多种<code class="language-plaintext highlighter-rouge">Product</code>（商品），同时，<code class="language-plaintext highlighter-rouge">Customer</code>（消费者）和<code class="language-plaintext highlighter-rouge">Admin</code>（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，<code class="language-plaintext highlighter-rouge">Store</code>（商场）可以这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Store</span><span class="o">();</span>
        <span class="n">store</span><span class="o">.</span><span class="na">addNewProduct</span><span class="o">(</span><span class="s">"商品1"</span><span class="o">,</span><span class="mi">56</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">addNewProduct</span><span class="o">(</span><span class="s">"商品2"</span><span class="o">,</span><span class="mi">78</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">setProductPrice</span><span class="o">(</span><span class="s">"商品2"</span><span class="o">,</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Store</span> <span class="o">{</span>
    <span class="nc">Customer</span> <span class="n">customer</span><span class="o">=</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">();</span>
    <span class="nc">Admin</span> <span class="n">admin</span><span class="o">=</span><span class="k">new</span> <span class="nc">Admin</span><span class="o">();</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNewProduct</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">);</span>
        <span class="n">products</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">p</span><span class="o">);</span>
        <span class="c1">// 通知用户:</span>
        <span class="n">customer</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="c1">// 通知管理员:</span>
        <span class="n">admin</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setProductPrice</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">p</span> <span class="o">=</span> <span class="n">products</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
        <span class="c1">// 通知用户:</span>
        <span class="n">customer</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="c1">// 通知管理员:</span>
        <span class="n">admin</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@ToString</span>
<span class="kd">class</span> <span class="nc">Product</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">price</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Customer</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">on</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"用户查看了："</span><span class="o">+</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Admin</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">on</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"管理员查看了："</span><span class="o">+</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Store</code>类直接引用了<code class="language-plaintext highlighter-rouge">Customer</code>和<code class="language-plaintext highlighter-rouge">Admin</code>。先不考虑多个<code class="language-plaintext highlighter-rouge">Customer</code>或多个<code class="language-plaintext highlighter-rouge">Admin</code>的问题，上述<code class="language-plaintext highlighter-rouge">Store</code>类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，<code class="language-plaintext highlighter-rouge">Store</code>类就必须继续改动。</p><p>问题的本质是<code class="language-plaintext highlighter-rouge">Store</code>希望发送通知给那些关心<code class="language-plaintext highlighter-rouge">Product</code>的对象，但<code class="language-plaintext highlighter-rouge">Store</code>并不想知道这些人是谁。<strong>观察者模式就是要分离被观察者和观察者之间的耦合关系。</strong></p><p>要实现这一目标也很简单，<code class="language-plaintext highlighter-rouge">Store</code>不能直接引用<code class="language-plaintext highlighter-rouge">Customer</code>和<code class="language-plaintext highlighter-rouge">Admin</code>，相反，它引用一个<code class="language-plaintext highlighter-rouge">ProductObserver</code>接口列表，任何人想要观察<code class="language-plaintext highlighter-rouge">Store</code>，只要实现该接口，并且把自己注册到<code class="language-plaintext highlighter-rouge">Store</code>即可。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Admin</span> <span class="n">admin</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Admin</span><span class="o">();</span>
        <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Customer</span><span class="o">();</span>

        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Store</span><span class="o">();</span>
        <span class="n">store</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">admin</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">customer</span><span class="o">);</span>

        <span class="n">store</span><span class="o">.</span><span class="na">addNewProduct</span><span class="o">(</span><span class="s">"商品1"</span><span class="o">,</span><span class="mi">56</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">addNewProduct</span><span class="o">(</span><span class="s">"商品2"</span><span class="o">,</span><span class="mi">78</span><span class="o">);</span>
        <span class="n">store</span><span class="o">.</span><span class="na">setProductPrice</span><span class="o">(</span><span class="s">"商品2"</span><span class="o">,</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Store</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ProductObserver</span><span class="o">&gt;</span> <span class="n">observers</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addNewProduct</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">);</span>
        <span class="n">products</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">p</span><span class="o">);</span>
        <span class="c1">// 通知全部:</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">observer</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setProductPrice</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Product</span> <span class="n">p</span> <span class="o">=</span> <span class="n">products</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="n">p</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
        <span class="c1">// 通知全部:</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observers</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">observer</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// 注册观察者</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addObserver</span><span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">observers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 取消注册</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeObserver</span><span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">observers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">observer</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Getter</span>
<span class="nd">@Setter</span>
<span class="nd">@ToString</span>
<span class="kd">class</span> <span class="nc">Product</span><span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="n">price</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">double</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">ProductObserver</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">on</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Customer</span> <span class="kd">implements</span> <span class="nc">ProductObserver</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">on</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"用户查看了："</span><span class="o">+</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Admin</span> <span class="kd">implements</span> <span class="nc">ProductObserver</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">on</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"管理员查看了："</span><span class="o">+</span><span class="n">p</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>观察者模式：</p><pre><code class="language-ascii">┌─────────┐      ┌───────────────┐
│  Store  │─ ─ ─&gt;│ProductObserver│
└─────────┘      └───────────────┘
     │                   ▲
                         │
     │             ┌─────┴─────┐
     ▼             │           │
┌─────────┐   ┌─────────┐ ┌─────────┐
│ Product │   │  Admin  │ │Customer │ ...
└─────────┘   └─────────┘ └─────────┘
</code></pre><p>观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProductObservable</span> <span class="o">{</span> <span class="c1">// 注意此处拼写是Observable不是Observer!</span>
    <span class="kt">void</span> <span class="nf">addObserver</span><span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">removeObserver</span><span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>对应的实体被观察者就要实现该接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Store</span> <span class="kd">implements</span> <span class="nc">ProductObservable</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProductObserver</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">onEvent</span><span class="o">(</span><span class="nc">ProductEvent</span> <span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>让观察者自己从Event对象中读取通知类型和通知数据。</p><p>广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p><pre><code class="language-ascii">                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
                   Messaging System
                 │                       │
                   ┌──────────────────┐
              ┌──┼&gt;│Topic:newProduct  │──┼─┐    ┌─────────┐
              │    └──────────────────┘    ├───&gt;│ConsumerA│
┌─────────┐   │  │ ┌──────────────────┐  │ │    └─────────┘
│Producer │───┼───&gt;│Topic:priceChanged│────┘
└─────────┘   │  │ └──────────────────┘  │
              │    ┌──────────────────┐         ┌─────────┐
              └──┼&gt;│Topic:soldOut     │──┼─────&gt;│ConsumerB│
                   └──────────────────┘         └─────────┘
                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
</code></pre><p>消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。</p><p>使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 通知全部:</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">ProductObserver</span> <span class="n">observer</span> <span class="o">:</span> <span class="n">observers</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">observer</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>在编写观察者模式的时候，各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。可以异步处理：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 另开线程，异步通知全部:</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(()-&gt;{</span>
    <span class="n">observers</span><span class="o">.</span><span class="na">parallelStream</span><span class="o">().</span><span class="na">forEach</span><span class="o">(</span><span class="n">observer</span><span class="o">-&gt;</span> <span class="n">observer</span><span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">p</span><span class="o">));</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>
</code></pre></div></div><p>此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</p><h3 id="状态">状态</h3><blockquote><p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p></blockquote><p>状态模式（State）经常用在带有状态的对象中。以QQ聊天为例，一个用户的QQ有几种状态：</p><ul><li>离线状态（尚未登录）；</li><li>正在登录状态；</li><li>在线状态；</li><li>忙状态（暂时离开）。</li></ul><p>定义一个<code class="language-plaintext highlighter-rouge">enum</code>就可以表示不同的状态。不同的状态需要对应不同的行为，比如收到消息时：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="o">==</span> <span class="no">ONLINE</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 闪烁图标</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="o">==</span> <span class="no">BUSY</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">reply</span><span class="o">(</span><span class="s">"现在忙，稍后回复"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">...</span>
</code></pre></div></div><p>状态模式的目的是为了把上述一大串<code class="language-plaintext highlighter-rouge">if...else...</code>的逻辑给<strong>分拆到不同的状态类</strong>中，使得<strong>将来增加状态比较容易</strong>。</p><p>状态模式的实现关键在于状态转换。简单的状态转换可以直接由调用方指定，复杂的状态转换可以在内部根据条件触发完成。</p><p>例如，我们设计一个聊天机器人，它有未连线和已连线两个状态。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">init</span><span class="o">();</span>
    <span class="nc">String</span> <span class="nf">reply</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">//对于未连线状态，收到消息也不回复</span>
<span class="kd">class</span> <span class="nc">DisconnectedState</span> <span class="kd">implements</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Bye!"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reply</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">//对于已连线状态，回应收到的消息：</span>
<span class="kd">class</span> <span class="nc">ConnectedState</span> <span class="kd">implements</span> <span class="nc">State</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Hello, I'm Bob."</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">reply</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"?"</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">"Yes. "</span> <span class="o">+</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"."</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">input</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">input</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">"?"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>状态模式的关键设计思想在于状态切换，引入一个<code class="language-plaintext highlighter-rouge">BotContext</code>完成状态切换：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">BotContext</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">State</span> <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DisconnectedState</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">chat</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="s">"hello"</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">input</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// 收到hello切换到在线状态:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="k">instanceof</span> <span class="nc">DisconnectedState</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConnectedState</span><span class="o">();</span>
                <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">init</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="s">"bye"</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span><span class="n">input</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">//  收到bye切换到离线状态:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">state</span> <span class="k">instanceof</span> <span class="nc">ConnectedState</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">state</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DisconnectedState</span><span class="o">();</span>
                <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">init</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="na">reply</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>启动：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Scanner</span> <span class="n">scanner</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
<span class="nc">BotContext</span> <span class="n">bot</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BotContext</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"&gt; "</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">output</span> <span class="o">=</span> <span class="n">bot</span><span class="o">.</span><span class="na">chat</span><span class="o">(</span><span class="n">input</span><span class="o">);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">output</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="s">"(no reply)"</span> <span class="o">:</span> <span class="s">"&lt; "</span> <span class="o">+</span> <span class="n">output</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><h3 id="策略">策略</h3><blockquote><p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p></blockquote><p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p><p>策略模式在Java标准库中应用非常广泛，以排序为例，通过<code class="language-plaintext highlighter-rouge">Arrays.sort()</code>实现忽略大小写排序：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"Pear"</span><span class="o">,</span> <span class="s">"Banana"</span><span class="o">,</span> <span class="s">"orange"</span> <span class="o">};</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="nl">String:</span><span class="o">:</span><span class="n">compareToIgnoreCase</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">array</span><span class="o">));</span>
</code></pre></div></div><p>如果想忽略大小写排序，就传入<code class="language-plaintext highlighter-rouge">String::compareToIgnoreCase</code>，如果想倒序排序，就传入<code class="language-plaintext highlighter-rouge">(s1, s2) -&gt; -s1.compareTo(s2)</code>，这个比较两个元素大小的算法就是策略。</p><p><code class="language-plaintext highlighter-rouge">Arrays.sort()</code>排序方法在比较两个元素大小的时候，需要借助我们传入的<code class="language-plaintext highlighter-rouge">Comparator</code>对象，才能完成比较。这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p><p>上述排序使用到了策略模式，实际上指，在一个方法中，流程是确定的，但是，<strong>某些关键步骤的算法依赖调用方传入的策略</strong>，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。简单的例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">inventory</span><span class="o">((</span><span class="n">e</span><span class="o">)-&gt;{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"检查："</span><span class="o">+</span><span class="n">e</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="n">inventory</span><span class="o">((</span><span class="n">e</span><span class="o">)-&gt;{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"吃："</span><span class="o">+</span><span class="n">e</span><span class="o">);</span>
        <span class="o">});</span>
        <span class="n">inventory</span><span class="o">((</span><span class="n">e</span><span class="o">)-&gt;{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"丢："</span><span class="o">+</span><span class="n">e</span><span class="o">);</span>
        <span class="o">});</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">inventory</span><span class="o">(</span><span class="no">I</span> <span class="n">i</span><span class="o">){</span>
        <span class="cm">/*假设代表这几个实体*/</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">={</span><span class="s">"香蕉"</span><span class="o">,</span><span class="s">"苹果"</span><span class="o">,</span><span class="s">"火龙果"</span><span class="o">,</span><span class="s">"西瓜"</span><span class="o">};</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">string</span> <span class="o">:</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">i</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>根据传入的策略，<code class="language-plaintext highlighter-rouge">inventory</code>实现了不同的功能。</p><p>一个完整的策略模式要定义策略以及使用策略的上下文。以购物车结算为例，假设网站针对普通会员、高级会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">DiscountStrategy</span> <span class="o">{</span>
    <span class="c1">// 计算折扣额度:</span>
    <span class="nc">BigDecimal</span> <span class="nf">getDiscount</span><span class="o">(</span><span class="nc">BigDecimal</span> <span class="n">total</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>接下来，就是实现各种策略：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UserDiscountStrategy</span> <span class="kd">implements</span> <span class="nc">DiscountStrategy</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">BigDecimal</span> <span class="nf">getDiscount</span><span class="o">(</span><span class="nc">BigDecimal</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 普通会员打九折:</span>
        <span class="k">return</span> <span class="n">total</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"0.1"</span><span class="o">)).</span><span class="na">setScale</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">RoundingMode</span><span class="o">.</span><span class="na">DOWN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">OverDiscountStrategy</span> <span class="kd">implements</span> <span class="nc">DiscountStrategy</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">BigDecimal</span> <span class="nf">getDiscount</span><span class="o">(</span><span class="nc">BigDecimal</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 满100减20优惠:</span>
        <span class="k">return</span> <span class="n">total</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">100</span><span class="o">))</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">?</span> <span class="nc">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span> <span class="o">:</span> <span class="nc">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">SeniorDiscountStrategy</span> <span class="kd">implements</span> <span class="nc">DiscountStrategy</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">BigDecimal</span> <span class="nf">getDiscount</span><span class="o">(</span><span class="nc">BigDecimal</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 高级会员打八折:</span>
        <span class="k">return</span> <span class="n">total</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"0.2"</span><span class="o">)).</span><span class="na">setScale</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">RoundingMode</span><span class="o">.</span><span class="na">DOWN</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>要应用策略，可以定义一个<code class="language-plaintext highlighter-rouge">DiscountContext</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">DiscountContext</span> <span class="o">{</span>
    <span class="c1">// 持有某个策略:</span>
    <span class="kd">private</span> <span class="nc">DiscountStrategy</span> <span class="n">strategy</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UserDiscountStrategy</span><span class="o">();</span>

    <span class="c1">// 允许客户端设置新策略:</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setStrategy</span><span class="o">(</span><span class="nc">DiscountStrategy</span> <span class="n">strategy</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">strategy</span> <span class="o">=</span> <span class="n">strategy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">BigDecimal</span> <span class="nf">calculatePrice</span><span class="o">(</span><span class="nc">BigDecimal</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">total</span><span class="o">.</span><span class="na">subtract</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">strategy</span><span class="o">.</span><span class="na">getDiscount</span><span class="o">(</span><span class="n">total</span><span class="o">)).</span><span class="na">setScale</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>调用方必须首先创建一个<code class="language-plaintext highlighter-rouge">DiscountContext</code>，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">DiscountContext</span> <span class="n">ctx</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DiscountContext</span><span class="o">();</span>

<span class="c1">// 默认使用普通会员折扣:</span>
<span class="nc">BigDecimal</span> <span class="n">pay1</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">calculatePrice</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">105</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pay1</span><span class="o">);</span>

<span class="c1">// 使用满减折扣:</span>
<span class="n">ctx</span><span class="o">.</span><span class="na">setStrategy</span><span class="o">(</span><span class="k">new</span> <span class="nc">OverDiscountStrategy</span><span class="o">());</span>
<span class="nc">BigDecimal</span> <span class="n">pay2</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">calculatePrice</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">105</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pay2</span><span class="o">);</span>

<span class="c1">// 使用高级会员折扣:</span>
<span class="n">ctx</span><span class="o">.</span><span class="na">setStrategy</span><span class="o">(</span><span class="k">new</span> <span class="nc">SeniorDiscountStrategy</span><span class="o">());</span>
<span class="nc">BigDecimal</span> <span class="n">pay3</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">calculatePrice</span><span class="o">(</span><span class="nc">BigDecimal</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="mi">105</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pay3</span><span class="o">);</span>
</code></pre></div></div><p>还可以组合：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OverUserDiscountStrategy</span> <span class="kd">implements</span> <span class="nc">DiscountStrategy</span><span class="o">{</span>
    <span class="nc">DiscountStrategy</span> <span class="n">ov</span><span class="o">=</span><span class="k">new</span> <span class="nc">OverDiscountStrategy</span><span class="o">();</span>
    <span class="nc">DiscountStrategy</span> <span class="n">ud</span><span class="o">=</span><span class="k">new</span> <span class="nc">UserDiscountStrategy</span><span class="o">();</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">BigDecimal</span> <span class="nf">getDiscount</span><span class="o">(</span><span class="nc">BigDecimal</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/*先减，再折*/</span>
        <span class="nc">BigDecimal</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">ov</span><span class="o">.</span><span class="na">getDiscount</span><span class="o">(</span><span class="n">total</span><span class="o">);</span>
        <span class="nc">BigDecimal</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">ud</span><span class="o">.</span><span class="na">getDiscount</span><span class="o">(</span><span class="n">total</span><span class="o">.</span><span class="na">subtract</span><span class="o">(</span><span class="n">d1</span><span class="o">));</span>
        <span class="k">return</span> <span class="nc">BigDecimal</span><span class="o">.</span><span class="na">ZERO</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">d1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">d2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p><h3 id="模板方法">模板方法</h3><blockquote><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p></blockquote><p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p><p>因此，模板方法的核心在于定义一个“骨架”。</p><p>假设开发了一个从数据库读取设置的类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Setting</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="nf">getSetting</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">readFromDatabase</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="nf">readFromDatabase</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// TODO: 从数据库读取</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>由于从数据库读取数据较慢，可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。怎么实现缓存，暂时没想好，但可以先写出使用缓存的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Setting</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="nf">getSetting</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 先从缓存读取:</span>
        <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">lookupCache</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 在缓存中未找到,从数据库读取:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">readFromDatabase</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[DEBUG] load from db: "</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
            <span class="c1">// 放入缓存:</span>
            <span class="n">putIntoCache</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[DEBUG] load from cache: "</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s">" = "</span> <span class="o">+</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">readFromDatabase</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>整个流程没有问题，但是，<code class="language-plaintext highlighter-rouge">lookupCache(key)</code>和<code class="language-plaintext highlighter-rouge">putIntoCache(key, value)</code>这两个方法还根本没实现，怎么编译通过？这个不要紧，声明抽象方法就可以：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractSetting</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="nc">String</span> <span class="nf">getSetting</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">lookupCache</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">readFromDatabase</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="n">putIntoCache</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">readFromDatabase</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">){</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="nc">String</span> <span class="nf">lookupCache</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">);</span>

    <span class="kd">protected</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">putIntoCache</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现<code class="language-plaintext highlighter-rouge">lookupCache(key)</code>和<code class="language-plaintext highlighter-rouge">putIntoCache(key, value)</code>这两个方法就交给子类了。子类其实并不关心核心代码<code class="language-plaintext highlighter-rouge">getSetting(key)</code>的逻辑，它只需要关心如何完成两个小小的子任务就可以了。</p><p>假设希望用一个<code class="language-plaintext highlighter-rouge">Map</code>做缓存，那么可以写一个<code class="language-plaintext highlighter-rouge">LocalSetting</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LocalSetting</span> <span class="kd">extends</span> <span class="nc">AbstractSetting</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

    <span class="kd">protected</span> <span class="nc">String</span> <span class="nf">lookupCache</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">putIntoCache</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果要使用Redis做缓存，那么可以再写一个<code class="language-plaintext highlighter-rouge">RedisSetting</code>：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>io.lettuce<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>lettuce-core<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>5.2.1.RELEASE<span class="nt">&lt;/version&gt;</span>
    <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedisSetting</span> <span class="kd">extends</span> <span class="nc">AbstractSetting</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">RedisClient</span> <span class="n">client</span> <span class="o">=</span> <span class="nc">RedisClient</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"redis://localhost:6379"</span><span class="o">);</span>

    <span class="kd">protected</span> <span class="nc">String</span> <span class="nf">lookupCache</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">StatefulRedisConnection</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">connect</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">RedisCommands</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">commands</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">commands</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">putIntoCache</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">(</span><span class="nc">StatefulRedisConnection</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">connect</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">RedisCommands</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">commands</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">sync</span><span class="o">();</span>
            <span class="n">commands</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>客户端代码使用本地缓存的代码这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AbstractSetting</span> <span class="n">setting1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LocalSetting</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test = "</span> <span class="o">+</span> <span class="n">setting1</span><span class="o">.</span><span class="na">getSetting</span><span class="o">(</span><span class="s">"test"</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test = "</span> <span class="o">+</span> <span class="n">setting1</span><span class="o">.</span><span class="na">getSetting</span><span class="o">(</span><span class="s">"test"</span><span class="o">));</span>
</code></pre></div></div><p>要改成Redis缓存，只需要把<code class="language-plaintext highlighter-rouge">LocalSetting</code>替换为<code class="language-plaintext highlighter-rouge">RedisSetting</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AbstractSetting</span> <span class="n">setting2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedisSetting</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"autosave = "</span> <span class="o">+</span> <span class="n">setting2</span><span class="o">.</span><span class="na">getSetting</span><span class="o">(</span><span class="s">"autosave"</span><span class="o">));</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"autosave = "</span> <span class="o">+</span> <span class="n">setting2</span><span class="o">.</span><span class="na">getSetting</span><span class="o">(</span><span class="s">"autosave"</span><span class="o">));</span>
</code></pre></div></div><p>模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code class="language-plaintext highlighter-rouge">final</code>。对于需要子类实现的抽象方法，一般声明为<code class="language-plaintext highlighter-rouge">protected</code>，使得这些方法对外部客户端不可见。</p><p>Java标准库也有很多模板方法的应用。在集合类中，<code class="language-plaintext highlighter-rouge">AbstractList</code>和<code class="language-plaintext highlighter-rouge">AbstractQueuedSynchronizer</code>都定义了很多通用操作，子类只需要实现某些必要方法。</p><h3 id="访问者">访问者</h3><blockquote><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></blockquote><p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p><p>假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出<code class="language-plaintext highlighter-rouge">.java</code>文件，正常的做法是写个递归：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">scan</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">File</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">collector</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 递归调用:</span>
            <span class="n">scan</span><span class="o">(</span><span class="n">file</span><span class="o">,</span> <span class="n">collector</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述代码的问题在于，扫描目录的逻辑和找java文件的逻辑混在了一起。如果下次需要增加一个清理<code class="language-plaintext highlighter-rouge">.class</code>文件的功能，就必须再重复写扫描逻辑。</p><p>因此，访问者模式先把<strong>数据结构</strong>（这里是文件夹和文件构成的树型结构）和对其的<strong>操作</strong>（查找文件）分离开，以后如果要新增操作（例如清理<code class="language-plaintext highlighter-rouge">.class</code>文件），只需要新增访问者，不需要改变现有逻辑。</p><p>用访问者模式改写上述代码步骤如下：</p><p>首先，定义访问者接口，即该访问者能够干的事情：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Visitor</span> <span class="o">{</span>
    <span class="c1">// 访问文件夹:</span>
    <span class="kt">void</span> <span class="nf">visitDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">);</span>
    <span class="c1">// 访问文件:</span>
    <span class="kt">void</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>定义能持有文件夹和文件的数据结构<code class="language-plaintext highlighter-rouge">FileStructure</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FileStructure</span> <span class="o">{</span>
    <span class="c1">// 根目录:</span>
    <span class="kd">private</span> <span class="nc">File</span> <span class="n">path</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">FileStructure</span><span class="o">(</span><span class="nc">File</span> <span class="n">path</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">scan</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">path</span><span class="o">,</span> <span class="n">visitor</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">scan</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">,</span> <span class="nc">Visitor</span> <span class="n">visitor</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 让访问者处理文件夹:</span>
			<span class="n">visitor</span><span class="o">.</span><span class="na">visitDir</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">sub</span> <span class="o">:</span> <span class="n">file</span><span class="o">.</span><span class="na">listFiles</span><span class="o">())</span> <span class="o">{</span>
                <span class="c1">// 递归处理子文件夹:</span>
				<span class="n">scan</span><span class="o">(</span><span class="n">sub</span><span class="o">,</span> <span class="n">visitor</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
            <span class="c1">// 让访问者处理文件:</span>
			<span class="n">visitor</span><span class="o">.</span><span class="na">visitFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>java文件访问者：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">JavaFileVisitor</span> <span class="kd">implements</span> <span class="nc">Visitor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"访问目录："</span> <span class="o">+</span> <span class="n">dir</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"找到的java文件： "</span> <span class="o">+</span> <span class="n">file</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样，就把访问者的行为抽象出来了。如果要实现查找<code class="language-plaintext highlighter-rouge">.java</code>文件，就传入<code class="language-plaintext highlighter-rouge">JavaFileVisitor</code>。</p><p>如果要清理<code class="language-plaintext highlighter-rouge">.class</code>文件，可以再写一个<code class="language-plaintext highlighter-rouge">ClassFileClearnerVisitor</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ClassFileCleanerVisitor</span> <span class="kd">implements</span> <span class="nc">Visitor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".class"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"将清理类文件： "</span> <span class="o">+</span> <span class="n">file</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>访问者模式的核心思想是访问比较复杂的数据结构时，不去改变数据结构，而是把对数据的操作<strong>抽象</strong>出来，在“访问”的过程中<strong>以回调形式</strong>在访问者中<strong>处理操作逻辑</strong>。如果要新增一组操作，那么只需要增加一个新的访问者。</p><p>实际上，Java标准库提供的<code class="language-plaintext highlighter-rouge">Files.walkFileTree()</code>已经实现了一个访问者模式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Files</span><span class="o">.</span><span class="na">walkFileTree</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"."</span><span class="o">),</span> <span class="k">new</span> <span class="nc">SimpleFileVisitor</span><span class="o">&lt;</span><span class="nc">Path</span><span class="o">&gt;(){</span>
    <span class="c1">// 处理Directory:</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">FileVisitResult</span> <span class="nf">preVisitDirectory</span><span class="o">(</span><span class="nc">Path</span> <span class="n">dir</span><span class="o">,</span> <span class="nc">BasicFileAttributes</span> <span class="n">attrs</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pre visit dir: "</span> <span class="o">+</span> <span class="n">dir</span><span class="o">);</span>
        <span class="c1">// 返回CONTINUE表示继续访问:</span>
        <span class="k">return</span> <span class="nc">FileVisitResult</span><span class="o">.</span><span class="na">CONTINUE</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 处理File:</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">FileVisitResult</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">Path</span> <span class="n">file</span><span class="o">,</span> <span class="nc">BasicFileAttributes</span> <span class="n">attrs</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"visit file: "</span> <span class="o">+</span> <span class="n">file</span><span class="o">);</span>
        <span class="c1">// 返回CONTINUE表示继续访问:</span>
        <span class="k">return</span> <span class="nc">FileVisitResult</span><span class="o">.</span><span class="na">CONTINUE</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">});</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Files.walkFileTree()</code>允许访问者返回<code class="language-plaintext highlighter-rouge">FileVisitResult.CONTINUE</code>以便继续访问，或者返回<code class="language-plaintext highlighter-rouge">FileVisitResult.TERMINATE</code>停止访问。</p><p>类似的，对XML的SAX处理也是一个访问者模式，需要提供一个SAX Handler作为访问者处理XML的各个节点。</p><p>简化的写法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">File</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">scan</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"."</span><span class="o">).</span><span class="na">toFile</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Visitor</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>

            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">endsWith</span><span class="o">(</span><span class="s">".java"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">collector</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">scan</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">,</span><span class="nc">Visitor</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">File</span> <span class="n">file</span> <span class="o">:</span> <span class="n">dir</span><span class="o">.</span><span class="na">listFiles</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isFile</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">v</span><span class="o">.</span><span class="na">visitFile</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="na">isDirectory</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">v</span><span class="o">.</span><span class="na">visitDir</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>
                <span class="c1">// 递归调用:</span>
                <span class="n">scan</span><span class="o">(</span><span class="n">file</span><span class="o">,</span><span class="n">v</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Visitor</span> <span class="o">{</span>
    <span class="c1">// 访问文件夹:</span>
    <span class="kt">void</span> <span class="nf">visitDir</span><span class="o">(</span><span class="nc">File</span> <span class="n">dir</span><span class="o">);</span>
    <span class="c1">// 访问文件:</span>
    <span class="kt">void</span> <span class="nf">visitFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>策略模式和访问者模式都允许在运行时改变对象的行为，但它们的应用场景和目的有所不同。</p><p>在策略模式中，定义了一系列算法，并将每个算法封装到具有共同接口的独立类中，使得这些算法可以互相替换。客户端可以在运行时选择不同的算法来使用，而不需要修改原有的代码。策略模式主要关注的是<strong>算法的选择和切换</strong>。</p><p>而在访问者模式中，主要关注的是对<strong>不同类型的元素进行不同的操作</strong>，同时又不改变元素本身的结构。通过访问者模式，可以在不改变元素结构的情况下，定义新的操作方式。访问者模式通常用于处理具有复杂结构的对象，且这些对象的结构经常发生变化。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" target="_blank">https://acteds.github.io/2024/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1716640539', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
