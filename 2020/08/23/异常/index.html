<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java-异常 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2020/08/23/%E5%BC%82%E5%B8%B8/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="Java-异常"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言java的异常处理笔记，包括异常捕获、传播、抛出、屏蔽、类型、自定义、空指针异常，以及常用的调试方式：断言、JDK Logging、Log4j、SLF4J。"><meta name="og:description" content="引言java的异常处理笔记，包括异常捕获、传播、抛出、屏蔽、类型、自定义、空指针异常，以及常用的调试方式：断言、JDK Logging、Log4j、SLF4J。"><meta property="og:url" content="/2020/08/23/%E5%BC%82%E5%B8%B8/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-08-23"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java-异常"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java-异常</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/08/23 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 24019 字，约 69 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>java的异常处理笔记，包括异常捕获、传播、抛出、屏蔽、类型、自定义、空指针异常，以及常用的调试方式：断言、JDK Logging、Log4j、SLF4J。</p><h1 id="异常">异常</h1><p>异常是一种<code class="language-plaintext highlighter-rouge">class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，只需要在上层捕获。Java的异常是<code class="language-plaintext highlighter-rouge">class</code>，它的继承关系如下：</p><pre><code class="language-ascii">                     ┌───────────┐
                     │  Object   │
                     └───────────┘
                           ▲
                           │
                     ┌───────────┐
                     │ Throwable │
                     └───────────┘
                           ▲
                 ┌─────────┴─────────┐
           ┌───────────┐       ┌───────────┐
           │   Error   │       │ Exception │
           └───────────┘       └───────────┘
                 ▲                   ▲
         ┌───────┘              ┌────┴──────────┐
┌─────────────────┐    ┌─────────────────┐┌───────────┐
│OutOfMemoryError │... │RuntimeException ││IOException│...
└─────────────────┘    └─────────────────┘└───────────┘
                                ▲
                    ┌───────────┴─────────────┐
         ┌─────────────────────┐ ┌─────────────────────────┐
         │NullPointerException │ │IllegalArgumentException │...
         └─────────────────────┘ └─────────────────────────┘
</code></pre><p>继承关系可知：<code class="language-plaintext highlighter-rouge">Throwable</code>是异常体系的根，它继承自<code class="language-plaintext highlighter-rouge">Object</code>。<code class="language-plaintext highlighter-rouge">Throwable</code>有两个体系：<code class="language-plaintext highlighter-rouge">Error</code>和<code class="language-plaintext highlighter-rouge">Exception</code>，<code class="language-plaintext highlighter-rouge">Error</code>表示<strong>严重的错误</strong>，程序对此一般无能为力，例如：</p><ul><li><code class="language-plaintext highlighter-rouge">OutOfMemoryError</code>：内存耗尽</li><li><code class="language-plaintext highlighter-rouge">NoClassDefFoundError</code>：无法加载某个Class</li><li><code class="language-plaintext highlighter-rouge">StackOverflowError</code>：栈溢出</li></ul><p>而<code class="language-plaintext highlighter-rouge">Exception</code>则是运行时的错误，它<strong>可以</strong>被捕获并处理。<br /> 某些异常是应用程序逻辑处理的一部分，<strong>应该捕获并处理</strong>。例如：</p><ul><li><code class="language-plaintext highlighter-rouge">NumberFormatException</code>：数值类型的格式错误</li><li><code class="language-plaintext highlighter-rouge">FileNotFoundException</code>：未找到文件</li><li><code class="language-plaintext highlighter-rouge">SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code class="language-plaintext highlighter-rouge">NullPointerException</code>：对某个<code class="language-plaintext highlighter-rouge">null</code>的对象调用方法或字段</li><li><code class="language-plaintext highlighter-rouge">IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code class="language-plaintext highlighter-rouge">Exception</code>又分为两大类：</p><ol><li><code class="language-plaintext highlighter-rouge">RuntimeException</code>以及它的子类；</li><li>非<code class="language-plaintext highlighter-rouge">RuntimeException</code>（包括<code class="language-plaintext highlighter-rouge">IOException</code>、<code class="language-plaintext highlighter-rouge">ReflectiveOperationException</code>等等）</li></ol><p>Java规定：</p><ul><li><strong>必须捕获</strong>的异常，包括<code class="language-plaintext highlighter-rouge">Exception</code>及其子类，但不包括<code class="language-plaintext highlighter-rouge">RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>可以不捕获的异常，包括<code class="language-plaintext highlighter-rouge">Error</code>及其子类，<code class="language-plaintext highlighter-rouge">RuntimeException</code>及其子类。</li></ul><p>注意：编译器对<code class="language-plaintext highlighter-rouge">RuntimeException</code>及其子类<strong>不做强制捕获要求</strong>，不是指应用程序本身不应该捕获并处理<code class="language-plaintext highlighter-rouge">RuntimeException</code>。<strong>是否需要捕获，具体问题具体分析</strong>。为了保证程序的健康性,在有可能出现异常的时候还是老实使用<code class="language-plaintext highlighter-rouge">try..catch</code>处理。<br /> <code class="language-plaintext highlighter-rouge">Exception</code>与<code class="language-plaintext highlighter-rouge">RuntimeException</code>的区别是面试中经常出现的问题。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"123"</span> <span class="o">;</span> <span class="c1">// 定义字符串,全部由数字组成  </span>
<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">;</span> <span class="c1">// 将字符串变为int类型  </span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">temp</span> <span class="o">*</span> <span class="n">temp</span><span class="o">)</span> <span class="o">;</span> <span class="c1">// 计算乘方</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">parseInt()</code>的定义格式：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">parseInt</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">NumberFormatException</span>
</code></pre></div></div><p>此方法明明使用了<strong>throws</strong>关键字抛出异常,为什么不用处理,也可以编译通过？<br /> 异常处理是通过5个关键字来实现的：</p><table><thead><tr><th>关键词</th><th>说明</th></tr></thead><tbody><tr><td>try</td><td>执行可能产生异常的代码</td></tr><tr><td>catch</td><td>捕获异常</td></tr><tr><td>throw</td><td>抛出异常,手动抛出异常</td></tr><tr><td>throws</td><td>声明异常,声明方法可能要抛出的各种异常</td></tr><tr><td>finally</td><td>无论是否发生异常代码总能执行</td></tr></tbody></table><p>程序运行时抛出的异常实际上就是一个异常对象。该对象中不仅封装了错误信息,还提供了些处理方法：</p><ul><li><strong>String getMessage()</strong>在<strong>Exception</strong>类中定义的方法,被继承到<strong>所有</strong>的异常类中,用于获得与异常相关的描述信息。</li><li><strong>void printstackTrace()</strong>在<strong>Exception</strong>类中定义的方法,用于在控制台上显示有关异常的信息,不但有异常的原因,还涉及产生异常的代码行。</li></ul><h2 id="异常捕获">异常捕获</h2><p><strong>内部处理</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span><span class="o">{</span>
<span class="c1">//可能发生异常的代码段</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">异常类型</span> <span class="n">e</span><span class="o">){</span> 
<span class="c1">//对异常进行处理的代码段 </span>
<span class="o">}</span><span class="k">finally</span><span class="o">{</span>
<span class="c1">//始终执行的代码段</span>
<span class="o">}</span>
<span class="c1">//其他代码段</span>
</code></pre></div></div><p>在<code class="language-plaintext highlighter-rouge">try</code>发生异常则程序才会到<code class="language-plaintext highlighter-rouge">catch</code>块中执行，<code class="language-plaintext highlighter-rouge">catch</code>块代码处理完后,程序仍会向下执行而不会异常终止。发生异常语句后面的代码<strong>不会被执行</strong>;<br /> 无论是否发生异常, <code class="language-plaintext highlighter-rouge">finally</code>块都将<strong>执行</strong>;<code class="language-plaintext highlighter-rouge">finally</code>块是可选的,可视具体情况决定是否添加;<code class="language-plaintext highlighter-rouge">finally</code>块必须和<code class="language-plaintext highlighter-rouge">try</code>块一起使用,不能单独存在。<br /> 如果没有发生异常，就正常执行<code class="language-plaintext highlighter-rouge">try { ... }</code>语句块，然后执行<code class="language-plaintext highlighter-rouge">finally</code>。如果发生了异常，就中断执行<code class="language-plaintext highlighter-rouge">try { ... }</code>语句块，然后跳转执行匹配的<code class="language-plaintext highlighter-rouge">catch</code>语句块，最后执行<code class="language-plaintext highlighter-rouge">finally</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getNumber</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getNumber</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getNumber</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">getNumber</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">){</span>
        <span class="k">try</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">exception</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span><span class="k">finally</span><span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span><span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span><span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>打印：<code class="language-plaintext highlighter-rouge">-1110</code>。<br /> 在 Java 中，<code class="language-plaintext highlighter-rouge">finally</code> 块中的 <code class="language-plaintext highlighter-rouge">return</code> 语句会覆盖 <code class="language-plaintext highlighter-rouge">try</code> 块中的 <code class="language-plaintext highlighter-rouge">return</code> 语句。换句话说，如果在 <code class="language-plaintext highlighter-rouge">try</code> 块中有 <code class="language-plaintext highlighter-rouge">return</code> 语句，并且在 <code class="language-plaintext highlighter-rouge">finally</code> 块中也有 <code class="language-plaintext highlighter-rouge">return</code> 语句，则最终的返回值是 <code class="language-plaintext highlighter-rouge">finally</code> 块中的返回值。这是因为 <code class="language-plaintext highlighter-rouge">finally</code> 块中的代码始终会在 <code class="language-plaintext highlighter-rouge">try</code> 块中的 <code class="language-plaintext highlighter-rouge">return</code> 语句执行之后执行，无论是否发生异常。因此，<code class="language-plaintext highlighter-rouge">finally</code> 块中的 <code class="language-plaintext highlighter-rouge">return</code> 语句会覆盖 <code class="language-plaintext highlighter-rouge">try</code> 块中的任何返回值。<br /> <strong>多重catch</strong><br /> 有时候,在<code class="language-plaintext highlighter-rouge">try</code>块中的代码段将有可能产生<strong>多种</strong>不同类型的<strong>异常</strong>,而我们又需要针对不同的异常类型进行不同的处理方式,那么我们就可以使用<strong>多重</strong><code class="language-plaintext highlighter-rouge">catch</code>块,来分别捕获不同类型的异常。<br /> 使用多个<code class="language-plaintext highlighter-rouge">catch</code>语句后，每个<code class="language-plaintext highlighter-rouge">catch</code>会分别捕获对应的<code class="language-plaintext highlighter-rouge">Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code class="language-plaintext highlighter-rouge">catch</code>语句，匹配到某个<code class="language-plaintext highlighter-rouge">catch</code>后，执行<code class="language-plaintext highlighter-rouge">catch</code>代码块，然后<strong>不再</strong>继续匹配。即多个<code class="language-plaintext highlighter-rouge">catch</code>语句<strong>只有一个</strong>能被执行。因此存在多个<code class="language-plaintext highlighter-rouge">catch</code>的时候，<code class="language-plaintext highlighter-rouge">catch</code>的顺序非常重要：子类必须写在前面。如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条<code class="language-plaintext highlighter-rouge">catch</code>子句。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bad input"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bad input"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unknown error"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>因为处理<code class="language-plaintext highlighter-rouge">IOException</code>和<code class="language-plaintext highlighter-rouge">NumberFormatException</code>的代码是相同的，所以我们可以把它两用<code class="language-plaintext highlighter-rouge">|</code><strong>合并</strong>到一起：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOException</span> <span class="o">|</span> <span class="nc">NumberFormatException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Bad input"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Unknown error"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>嵌套<code class="language-plaintext highlighter-rouge">try/catch</code></strong><br /> 有时候,整个语句块可以产生异常,而其中的某个部分又可能产生另外的异常,而我们需要分别进行处理;这样,就可以通过嵌套<code class="language-plaintext highlighter-rouge">try/catch</code>块来完成;嵌套<code class="language-plaintext highlighter-rouge">try/catch</code>块就是在一个<code class="language-plaintext highlighter-rouge">try/catch</code>块中包含有另外的<code class="language-plaintext highlighter-rouge">try/catch</code>块。<br /> 只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。<br /> 如果某个方法中的代码有可能引发异常,可以使用<code class="language-plaintext highlighter-rouge">try/catch</code>块进行处理,这种处理方式成为”内部处理”。<br /> 如果不方便在方法内部进行处理,也可以将异常往方法外部传递,这就要使用到关键字<code class="language-plaintext highlighter-rouge">throws</code>;<code class="language-plaintext highlighter-rouge">throws</code>用于将方法内部产生的异常抛给主调方法;</p><h2 id="异常传播">异常传播</h2><p>某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code class="language-plaintext highlighter-rouge">try ... catch</code>被捕获为止：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">process1</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">process1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">process2</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">process2</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// 会抛出NumberFormatException</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>因为RuntimeException可以不需要<code class="language-plaintext highlighter-rouge">catch</code>或<code class="language-plaintext highlighter-rouge">throws</code>。所以<code class="language-plaintext highlighter-rouge">process2()</code>和<code class="language-plaintext highlighter-rouge">process1()</code>可以不对异常处理，<code class="language-plaintext highlighter-rouge">main()</code>也可以不要<code class="language-plaintext highlighter-rouge">try/catch</code>。<br /> 通过<code class="language-plaintext highlighter-rouge">printStackTrace()</code>可以打印出方法的调用栈，类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NumberFormatException</span><span class="o">:</span> <span class="nc">Cannot</span> <span class="n">parse</span> <span class="kc">null</span> <span class="n">string</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">/</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">550</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">/</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">685</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">process2</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">15</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">process1</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">12</span><span class="o">)</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">6</span><span class="o">)</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code class="language-plaintext highlighter-rouge">NumberFormatException</code>是在<code class="language-plaintext highlighter-rouge">java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code class="language-plaintext highlighter-rouge">main()</code>调用<code class="language-plaintext highlighter-rouge">process1()</code>；</li><li><code class="language-plaintext highlighter-rouge">process1()</code>调用<code class="language-plaintext highlighter-rouge">process2()</code>；</li><li><code class="language-plaintext highlighter-rouge">process2()</code>调用<code class="language-plaintext highlighter-rouge">Integer.parseInt(String)</code>；</li><li><code class="language-plaintext highlighter-rouge">Integer.parseInt(String)</code>调用<code class="language-plaintext highlighter-rouge">Integer.parseInt(String, int)</code>。</li></ol><p>查看<code class="language-plaintext highlighter-rouge">Integer.java</code>源码可知，抛出异常的方法代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">parseInt</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">radix</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">NumberFormatException</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NumberFormatException</span><span class="o">(</span><span class="s">"null"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>并且，每层调用均给出了源代码的行号，可直接定位。<br /> <strong>方法抛出异常</strong>:<br /> <code class="language-plaintext highlighter-rouge">返回值类型 方法名(参数列表) throws 异常类型{代码段}</code><br /> 当调用带有<code class="language-plaintext highlighter-rouge">throws</code>关键字的方法时,则<strong>必须</strong>放在<code class="language-plaintext highlighter-rouge">try/catch</code>块中进行监控,否则编译器将会报错;</p><h2 id="抛出异常">抛出异常</h2><p>如何抛出异常？参考<code class="language-plaintext highlighter-rouge">Integer.parseInt()</code>方法，抛出异常分两步：</p><ol><li>创建某个<code class="language-plaintext highlighter-rouge">Exception</code>的实例；</li><li>用<code class="language-plaintext highlighter-rouge">throw</code>语句抛出。</li></ol><p>下面是一个例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">process2</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">NullPointerException</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">();</span>
        <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">process2</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果一个方法捕获了某个异常后，又在<code class="language-plaintext highlighter-rouge">catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">process1</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">process2</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NullPointerException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kt">void</span> <span class="nf">process2</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当<code class="language-plaintext highlighter-rouge">process2()</code>抛出<code class="language-plaintext highlighter-rouge">NullPointerException</code>后，被<code class="language-plaintext highlighter-rouge">process1()</code>捕获，然后抛出<code class="language-plaintext highlighter-rouge">IllegalArgumentException()</code>。<br /> 如果在<code class="language-plaintext highlighter-rouge">main()</code>中捕获<code class="language-plaintext highlighter-rouge">IllegalArgumentException</code>，我们看看打印的异常栈：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">process1</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">process1</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">process2</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NullPointerException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">process2</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>打印出的异常栈类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span>
    <span class="n">at</span> <span class="nc">Main</span><span class="o">.</span><span class="na">process1</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">15</span><span class="o">)</span>
    <span class="n">at</span> <span class="nc">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div></div><p>新的异常<strong>丢失了原始异常信息</strong>，我们已经看不到原始异常<code class="language-plaintext highlighter-rouge">NullPointerException</code>的信息了。为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code class="language-plaintext highlighter-rouge">Exception</code>实例传进去，新的<code class="language-plaintext highlighter-rouge">Exception</code>就可以持有原始<code class="language-plaintext highlighter-rouge">Exception</code>信息。<br /> 改进如下：<code class="language-plaintext highlighter-rouge">throw new IllegalArgumentException(e);</code>。<br /> 运行代码，打印出的异常栈类似：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span><span class="o">:</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NullPointerException</span>
    <span class="n">at</span> <span class="nc">Main</span><span class="o">.</span><span class="na">process1</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">15</span><span class="o">)</span>
    <span class="n">at</span> <span class="nc">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">5</span><span class="o">)</span>
<span class="nc">Caused</span> <span class="nl">by:</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NullPointerException</span>
    <span class="n">at</span> <span class="nc">Main</span><span class="o">.</span><span class="na">process2</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">20</span><span class="o">)</span>
    <span class="n">at</span> <span class="nc">Main</span><span class="o">.</span><span class="na">process1</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">13</span><span class="o">)</span>
</code></pre></div></div><p>注意到<code class="language-plaintext highlighter-rouge">Caused by: Xxx</code>，说明捕获的<code class="language-plaintext highlighter-rouge">IllegalArgumentException</code>并不是造成问题的根源，根源在于<code class="language-plaintext highlighter-rouge">NullPointerException</code>，是在<code class="language-plaintext highlighter-rouge">Main.process2()</code>方法抛出的。<br /> 在代码中获取原始异常可以使用<code class="language-plaintext highlighter-rouge">Throwable.getCause()</code>方法。如果返回<code class="language-plaintext highlighter-rouge">null</code>，说明已经是“根异常”了。<br /> 有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。<br /> 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！<br /> 除了把原始的<code class="language-plaintext highlighter-rouge">Exception</code>实例传进去，也可以通过<code class="language-plaintext highlighter-rouge">e2.initCause(e)</code>方法添加e的异常信息。</p><h2 id="异常屏蔽">异常屏蔽</h2><p>如果在执行<code class="language-plaintext highlighter-rouge">finally</code>语句时抛出异常，那么，<code class="language-plaintext highlighter-rouge">catch</code>语句的异常还能否继续抛出？例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"catched"</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"finally"</span><span class="o">);</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">catched</span>
<span class="k">finally</span>
<span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">12</span><span class="o">)</span>
</code></pre></div></div><p>这说明<code class="language-plaintext highlighter-rouge">finally</code>抛出异常后，原来在<code class="language-plaintext highlighter-rouge">catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。<br /> 在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用<code class="language-plaintext highlighter-rouge">origin</code>变量保存原始异常，然后调用<code class="language-plaintext highlighter-rouge">Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code class="language-plaintext highlighter-rouge">finally</code>抛出：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Exception</span> <span class="n">origin</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="s">"abc"</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
            <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="nc">Exception</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">origin</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">addSuppressed</span><span class="o">(</span><span class="n">origin</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当<code class="language-plaintext highlighter-rouge">catch</code>和<code class="language-plaintext highlighter-rouge">finally</code>都抛出了异常时，虽然<code class="language-plaintext highlighter-rouge">catch</code>的异常被屏蔽了，但是，<code class="language-plaintext highlighter-rouge">finally</code>抛出的异常仍然包含了它：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">IllegalArgumentException</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">12</span><span class="o">)</span>
	<span class="nl">Suppressed:</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NumberFormatException</span><span class="o">:</span> <span class="nc">For</span> <span class="n">input</span> <span class="nl">string:</span> <span class="s">"abc"</span>
		<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">/</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NumberFormatException</span><span class="o">.</span><span class="na">forInputString</span><span class="o">(</span><span class="nc">NumberFormatException</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">67</span><span class="o">)</span>
		<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">/</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">588</span><span class="o">)</span>
		<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">/</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">685</span><span class="o">)</span>
		<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">7</span><span class="o">)</span>
</code></pre></div></div><p>通过<code class="language-plaintext highlighter-rouge">Throwable.getSuppressed()</code>可以获取所有的<code class="language-plaintext highlighter-rouge">Suppressed Exception</code>。<br /> 绝大多数情况下，在<code class="language-plaintext highlighter-rouge">finally</code>中不要抛出异常。因此，我们通常不需要关心<code class="language-plaintext highlighter-rouge">Suppressed Exception</code>。<br /> <strong><code class="language-plaintext highlighter-rouge">e.printStackTrace()</code>和<code class="language-plaintext highlighter-rouge">System.out</code>输出顺序混乱</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.InputMismatchException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="o">/</span><span class="mi">0</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"try - first statement"</span><span class="o">);</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"try - last statement"</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">catch</span> <span class="o">(</span><span class="nc">InputMismatchException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"InputMismatchException Exception"</span><span class="o">);</span>
        <span class="o">}</span><span class="k">catch</span> <span class="o">(</span><span class="nc">ArithmeticException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">//ex.printStackTrace();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"ArithmeticException Exception"</span><span class="o">);</span>
            <span class="n">ex</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="c1">//ex.printStackTrace(System.out);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"最后执行输出语句"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArithmeticException</span> <span class="nc">Exception</span>
<span class="n">最后执行输出语句</span>
<span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">ArithmeticException</span><span class="o">:</span> <span class="o">/</span> <span class="n">by</span> <span class="n">zero</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">8</span><span class="o">)</span>
</code></pre></div></div><p>最后写在catch块外面的那句打印输出， 在异常信息前面输出了， 本意是最后哪一个打印信息是在最后执行的。<br /> <strong>原因</strong>：使用 printStackTrace()的时候默认是输出到System.err中去的，而普通的输出都是放入System.out，这两者都是对上层封装的输出流，在默认情况下两者是指向Console的文本流。所以两者可能会出现同步问题。</p><h2 id="异常类型">异常类型</h2><p>产生异常的原因多种多样,大致有：系统资源不可用：如内存分配失败,文件打开失败,数据源连接失败等等;程序控制不当：如被零除,负数开方,数组下标越界等等。<br /> 当异常发生时,程序一般会作出如下反应：发生异常的部分产生系统定义的错误信息;程序意外终止,并将控制权返回操作系统;程序中所有已分配资源的状态保持不变,这样将会导致资源泄漏。那么我们就必须对有可能产生的异常进行处理。<br /> 自定义异常类一般继承于<code class="language-plaintext highlighter-rouge">Exception</code>类;<code class="language-plaintext highlighter-rouge">Exception</code>类是绝大部分异常类的父类,在异常类型不明的情况下,可以都认为是<code class="language-plaintext highlighter-rouge">Exception</code>.<br /> <code class="language-plaintext highlighter-rouge">Throwable</code>有两个直接子类,它们是：<br /> <code class="language-plaintext highlighter-rouge">Error</code>类：称为<strong>错误类</strong>,通常是指<strong>系统</strong>中的<strong>内部错误</strong>以及资源耗尽的错误,是比较严重的,仅靠修改程序本身是<strong>不能</strong>恢复执行的<br /> <code class="language-plaintext highlighter-rouge">Exception</code>类：称为<strong>异常类</strong>,表示程序本身<strong>可以</strong>处理的错误。在开发Java程序过程中进行的异常处理,主要就是针对<code class="language-plaintext highlighter-rouge">Exception</code>类及其子类的异常处理。<br /> Java 根据各个类库也定义了一些其他的异常,下面的表中列出了 Java 的非检查性异常。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时,抛出此异常。例如,一个整数”除以零”时,抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小,则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时,抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器,或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说,即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引(例如对数组、字符串或向量的排序)超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组,则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时,抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型,但该字符串不能转换为适当格式时,抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常,指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出,指示索引或者为负,或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时,抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 <strong>java.lang</strong> 包中的检查性异常类。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时,找不到相应的类,抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象,但该对象的类无法实现 Cloneable 接口时,抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候,抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例,而指定的类对象因为是一个接口或是一个抽象类而无法实例化时,抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断,抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h2 id="自定义异常类"><strong>自定义异常类</strong></h2><p>Java标准库定义的常用异常包括：</p><pre><code class="language-ascii">Exception
├─ RuntimeException
│  ├─ NullPointerException
│  ├─ IndexOutOfBoundsException
│  ├─ SecurityException
│  │
│  └─ IllegalArgumentException
│     └─ NumberFormatException
│
├─ IOException
│  ├─ UnsupportedCharsetException
│  ├─ FileNotFoundException
│  └─ SocketException
│
├─ ParseException
├─ GeneralSecurityException
├─ SQLException
└─ TimeoutException
</code></pre><p>当我们在代码中需要抛出异常时，<strong>尽量</strong>使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出<code class="language-plaintext highlighter-rouge">IllegalArgumentException</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kt">void</span> <span class="nf">process1</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。<br /> 一个常见的做法是自定义一个<code class="language-plaintext highlighter-rouge">BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。<br /> <code class="language-plaintext highlighter-rouge">BaseException</code>需要从一个适合的<code class="language-plaintext highlighter-rouge">Exception</code>派生，通常建议从<code class="language-plaintext highlighter-rouge">RuntimeException</code>派生：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{}</span>
</code></pre></div></div><p>其他业务类型的异常就可以从<code class="language-plaintext highlighter-rouge">BaseException</code>派生：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserNotFoundException</span> <span class="kd">extends</span> <span class="nc">BaseException</span> <span class="o">{}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LoginFailedException</span> <span class="kd">extends</span> <span class="nc">BaseException</span> <span class="o">{}</span>
</code></pre></div></div><p>自定义的<code class="language-plaintext highlighter-rouge">BaseException</code>应该提供多个构造方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">BaseException</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">BaseException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">,</span> <span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">,</span> <span class="n">cause</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">BaseException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">BaseException</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">cause</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述构造方法实际上都是原样照抄<code class="language-plaintext highlighter-rouge">RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。<br /> 只需要继承<code class="language-plaintext highlighter-rouge">Exception</code>类就可以自定义异常类。因为JAVA中提供的都是标准异常类(包括一些异常信息),如果需要自己想要的异常信息就可以自定义异常类。<code class="language-plaintext highlighter-rouge">Exception</code>类是绝大部分异常类的父类,在异常类型不明的情况下,可以都认为是<code class="language-plaintext highlighter-rouge">Exception</code>.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MyException</span> <span class="kd">extends</span> <span class="nc">Exception</span> <span class="o">{</span><span class="c1">// 自定义异常类,继承Exception类  </span>
    <span class="kd">public</span> <span class="nf">MyException</span><span class="o">(</span><span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span><span class="c1">// 调用Exception类中有一个参数的构造方法,传递错误信息  </span>
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span>  
        <span class="k">try</span> <span class="o">{</span>  
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">MyException</span><span class="o">(</span><span class="s">"自定义异常。"</span><span class="o">);</span><span class="c1">// 抛出异常  </span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span><span class="c1">//打印错误信息:MyException: 自定义异常。  </span>
        <span class="o">}</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h2 id="空指针异常">空指针异常</h2><p>好的编码习惯可以极大地降低<code class="language-plaintext highlighter-rouge">NullPointerException</code>的产生，例如：<br /> 成员变量在定义时初始化：<code class="language-plaintext highlighter-rouge">private String name = "";</code>使用空字符串<code class="language-plaintext highlighter-rouge">""</code>而不是默认的<code class="language-plaintext highlighter-rouge">null</code>可避免很多<code class="language-plaintext highlighter-rouge">NullPointerException</code>，编写业务逻辑时，用空字符串<code class="language-plaintext highlighter-rouge">""</code>表示未填写比<code class="language-plaintext highlighter-rouge">null</code>安全得多。<br /> 返回空字符串<code class="language-plaintext highlighter-rouge">""</code>、空数组而不是<code class="language-plaintext highlighter-rouge">null</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">readLinesFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">getFileSize</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 返回空数组而不是null:</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>这样可以使得调用方无需检查结果是否为<code class="language-plaintext highlighter-rouge">null</code>。<br /> 如果调用方一定要根据<code class="language-plaintext highlighter-rouge">null</code>判断，比如返回<code class="language-plaintext highlighter-rouge">null</code>表示文件不存在，那么考虑返回<code class="language-plaintext highlighter-rouge">Optional&lt;T&gt;</code>。<code class="language-plaintext highlighter-rouge">Optional.empty()</code>是<code class="language-plaintext highlighter-rouge">Optional</code>类的一个静态方法，用于创建一个空的<code class="language-plaintext highlighter-rouge">Optional</code>对象。<code class="language-plaintext highlighter-rouge">Optional</code>是一个容器对象，可以包含或不包含一个非空值。使用<code class="language-plaintext highlighter-rouge">Optional.empty()</code>可以表示一个不包含任何值的情况，通常用于方法返回值，表示方法执行没有返回有效结果。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">readFromFile</span><span class="o">(</span><span class="nc">String</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">fileExist</span><span class="o">(</span><span class="n">file</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>这样调用方必须通过<code class="language-plaintext highlighter-rouge">Optional.isPresent()</code>判断是否有结果。<br /> <strong>定位NullPointerException</strong><br /> 如果产生了<code class="language-plaintext highlighter-rouge">NullPointerException</code>，例如，调用<code class="language-plaintext highlighter-rouge">a.b.c.x()</code>时产生了<code class="language-plaintext highlighter-rouge">NullPointerException</code>，原因可能是：</p><ul><li><code class="language-plaintext highlighter-rouge">a</code>是<code class="language-plaintext highlighter-rouge">null</code>；</li><li><code class="language-plaintext highlighter-rouge">a.b</code>是<code class="language-plaintext highlighter-rouge">null</code>；</li><li><code class="language-plaintext highlighter-rouge">a.b.c</code>是<code class="language-plaintext highlighter-rouge">null</code>；</li></ul><p>确定到底是哪个对象是<code class="language-plaintext highlighter-rouge">null</code>以前只能打印这样的日志：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">b</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">c</span><span class="o">);</span>
</code></pre></div></div><p>从<strong>Java 14</strong>开始，如果产生了<code class="language-plaintext highlighter-rouge">NullPointerException</code>，JVM可以给出详细的信息告诉我们<code class="language-plaintext highlighter-rouge">null</code>对象到底是谁。我们来看例子：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Person</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">address</span><span class="o">.</span><span class="na">city</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="nc">String</span><span class="o">[]</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
    <span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Address</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">"main"</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NullPointerException</span><span class="o">:</span> <span class="nc">Cannot</span> <span class="n">invoke</span> <span class="s">"String.toLowerCase()"</span> <span class="n">because</span> <span class="s">"p.address.city"</span> <span class="n">is</span> <span class="kc">null</span>
	<span class="n">at</span> <span class="n">com</span><span class="o">.</span><span class="na">aotmd</span><span class="o">.</span><span class="na">Main</span><span class="o">.</span><span class="na">main</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">java</span><span class="o">:</span><span class="mi">6</span><span class="o">)</span>
</code></pre></div></div><p>可以在<code class="language-plaintext highlighter-rouge">NullPointerException</code>的详细信息中看到类似<code class="language-plaintext highlighter-rouge">... because "p.address.city" is null</code>，意思是<code class="language-plaintext highlighter-rouge">city</code>字段为<code class="language-plaintext highlighter-rouge">null</code>，这样我们就能快速定位问题所在。<br /> 这种增强的<code class="language-plaintext highlighter-rouge">NullPointerException</code>详细信息是<strong>Java 14</strong>新增的功能，但默认是关闭的，我们可以给JVM添加一个<code class="language-plaintext highlighter-rouge">-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="na">-XX</span>:<span class="na">+ShowCodeDetailsInExceptionMessages </span><span class="kd">Main</span>.java
</code></pre></div></div><h2 id="断言">断言</h2><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code class="language-plaintext highlighter-rouge">assert</code>关键字来实现断言。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(-</span><span class="mf">123.45</span><span class="o">);</span>
    <span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>语句<code class="language-plaintext highlighter-rouge">assert x &gt;= 0;</code>即为断言，断言条件<code class="language-plaintext highlighter-rouge">x &gt;= 0</code>预期为<code class="language-plaintext highlighter-rouge">true</code>。如果计算结果为<code class="language-plaintext highlighter-rouge">false</code>，则断言失败，抛出<code class="language-plaintext highlighter-rouge">AssertionError</code>。<br /> 使用<code class="language-plaintext highlighter-rouge">assert</code>语句时，还可以添加一个可选的断言消息：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">:</span> <span class="s">"x must &gt;= 0"</span><span class="o">;</span>
</code></pre></div></div><p>这样，断言失败的时候，<code class="language-plaintext highlighter-rouge">AssertionError</code>会带上消息<code class="language-plaintext highlighter-rouge">x must &gt;= 0</code>，更加便于调试。<br /> Java断言的特点是：断言失败时会抛出<code class="language-plaintext highlighter-rouge">AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。<br /> 对于可恢复的程序错误，不应该使用断言。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">assert</span> <span class="n">arr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>应该抛出异常并在上层捕获：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">arr</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"array cannot be null"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>当我们在程序中使用<code class="language-plaintext highlighter-rouge">assert</code>时，例如，一个简单的断言：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</code></pre></div></div><p>断言<code class="language-plaintext highlighter-rouge">x</code>必须大于<code class="language-plaintext highlighter-rouge">0</code>，实际上<code class="language-plaintext highlighter-rouge">x</code>为<code class="language-plaintext highlighter-rouge">-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出<code class="language-plaintext highlighter-rouge">AssertionError</code>，而是正常打印了<code class="language-plaintext highlighter-rouge">x</code>的值。<br /> 这是因为JVM默认关闭断言指令，即遇到<code class="language-plaintext highlighter-rouge">assert</code>语句就自动忽略了，不执行。执行<code class="language-plaintext highlighter-rouge">assert</code>语句，必须给Java虚拟机传递<code class="language-plaintext highlighter-rouge">-enableassertions</code>（可简写为<code class="language-plaintext highlighter-rouge">-ea</code>）参数启用断言。<br /> 还可以有选择地对特定地类启用断言，命令行参数是：<code class="language-plaintext highlighter-rouge">-ea:com.itranswarp.sample.Main</code>，表示只对<code class="language-plaintext highlighter-rouge">com.itranswarp.sample.Main</code>这个类启用断言。或者对特定地包启用断言，命令行参数是：<code class="language-plaintext highlighter-rouge">-ea:com.itranswarp.sample...</code>（注意结尾有3个<code class="language-plaintext highlighter-rouge">.</code>），表示对<code class="language-plaintext highlighter-rouge">com.itranswarp.sample</code>这个包启动断言。<br /> 实际开发中，很少使用断言。更好的方法是编写单元测试。</p><h2 id="jdk-logging">JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用<code class="language-plaintext highlighter-rouge">System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。<br /> 代码改好了怎么办？当然是删除没有用的<code class="language-plaintext highlighter-rouge">System.out.println()</code>语句了。<br /> 如果改代码又改出问题怎么办？再加上<code class="language-plaintext highlighter-rouge">System.out.println()</code>。<br /> 反复这么搞几次，很快大家就发现使用<code class="language-plaintext highlighter-rouge">System.out.println()</code>非常麻烦。<br /> 怎么办？解决方法是使用日志。<br /> 那什么是日志？日志就是Logging，它的目的是为了取代<code class="language-plaintext highlighter-rouge">System.out.println()</code>。<br /> 输出日志，而不是用<code class="language-plaintext highlighter-rouge">System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写<code class="language-plaintext highlighter-rouge">"ERROR: " + var</code>；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li><li>可以按包名控制日志级别，只输出某些包打的日志；</li><li>可以……</li></ol><p>Java标准库内置了日志包<code class="language-plaintext highlighter-rouge">java.util.logging</code>，可以直接用。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.logging.Logger</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">Logger</span><span class="o">.</span><span class="na">getGlobal</span><span class="o">();</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start process..."</span><span class="o">);</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">warning</span><span class="o">(</span><span class="s">"memory is running out..."</span><span class="o">);</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">fine</span><span class="o">(</span><span class="s">"ignored."</span><span class="o">);</span>
        <span class="n">logger</span><span class="o">.</span><span class="na">severe</span><span class="o">(</span><span class="s">"process will be terminated..."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>运行上述代码，得到类似如下的输出：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">4</span>:11:01 下午 <span class="kd">com</span>.aotmd.Main <span class="kd">main</span>
信息: <span class="nb">start</span> <span class="kd">process</span>...
<span class="m">4</span>:11:01 下午 <span class="kd">com</span>.aotmd.Main <span class="kd">main</span>
警告: <span class="kd">memory</span> <span class="kd">is</span> <span class="kd">running</span> <span class="kd">out</span>...
<span class="m">4</span>:11:01 下午 <span class="kd">com</span>.aotmd.Main <span class="kd">main</span>
严重: <span class="kd">process</span> <span class="kd">will</span> <span class="kd">be</span> <span class="kd">terminated</span>...
</code></pre></div></div><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。<br /> 再仔细观察发现，4条日志，只打印了3条，<code class="language-plaintext highlighter-rouge">logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。<br /> 使用Java标准库内置的Logging有以下局限：<br /> Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code class="language-plaintext highlighter-rouge">main()</code>方法，就无法修改配置；<br /> 配置不太方便，需要在JVM启动时传递参数<code class="language-plaintext highlighter-rouge">-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。<br /> 因此，Java标准库内置的Logging使用并不是非常广泛。</p><h2 id="commons-logging">Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个<strong>第三方日志库</strong>，它是由Apache创建的日志模块。<br /> Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。<strong>默认</strong>情况下，Commons Logging自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。<br /> 使用Commons Logging只需要和两个类打交道，通过<code class="language-plaintext highlighter-rouge">LogFactory</code>获取<code class="language-plaintext highlighter-rouge">Log</code>类的实例； 使用<code class="language-plaintext highlighter-rouge">Log</code>实例的方法打日志。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.logging.Log</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.commons.logging.LogFactory</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="nc">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start..."</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"end."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>控制台：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4:14:37 下午 com.aotmd.Main main
信息: start...
4:14:37 下午 com.aotmd.Main main
警告: end.
</code></pre></div></div><p>Commons Logging是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来。下载后，解压，找到<code class="language-plaintext highlighter-rouge">commons-logging-1.2.jar</code>这个文件，再把Java源码<code class="language-plaintext highlighter-rouge">Main.java</code>放到一个目录下，例如<code class="language-plaintext highlighter-rouge">work</code>目录：</p><pre><code class="language-ascii">work
├─ commons-logging-1.2.jar
└─ Main.java
</code></pre><p>然后用<code class="language-plaintext highlighter-rouge">javac</code>编译<code class="language-plaintext highlighter-rouge">Main.java</code>，编译的时候要指定<code class="language-plaintext highlighter-rouge">classpath</code>，不然编译器找不到我们引用的<code class="language-plaintext highlighter-rouge">org.apache.commons.logging</code>包。编译命令如下：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">javac</span> <span class="na">-cp </span><span class="kd">commons</span><span class="na">-logging</span><span class="o">-</span><span class="m">1</span>.2.jar <span class="kd">Main</span>.java
</code></pre></div></div><p>如果编译成功，那么当前目录下就会多出一个<code class="language-plaintext highlighter-rouge">Main.class</code>文件：</p><pre><code class="language-ascii">work
├─ commons-logging-1.2.jar
├─ Main.java
└─ Main.class
</code></pre><p>现在可以执行这个<code class="language-plaintext highlighter-rouge">Main.class</code>，使用<code class="language-plaintext highlighter-rouge">java</code>命令，也必须指定<code class="language-plaintext highlighter-rouge">classpath</code>，命令如下：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="na">-cp </span>.<span class="o">;</span><span class="kd">commons</span><span class="na">-logging</span><span class="o">-</span><span class="m">1</span>.2.jar <span class="kd">Main</span>
</code></pre></div></div><p>注意到传入的<code class="language-plaintext highlighter-rouge">classpath</code>有两部分：一个是<code class="language-plaintext highlighter-rouge">.</code>，一个是<code class="language-plaintext highlighter-rouge">commons-logging-1.2.jar</code>，用<code class="language-plaintext highlighter-rouge">;</code>分割。<code class="language-plaintext highlighter-rouge">.</code>表示当前目录，如果没有这个<code class="language-plaintext highlighter-rouge">.</code>，JVM不会在当前目录搜索<code class="language-plaintext highlighter-rouge">Main.class</code>，就会报错。<br /> 如果在Linux或macOS下运行，注意<code class="language-plaintext highlighter-rouge">classpath</code>的分隔符不是<code class="language-plaintext highlighter-rouge">;</code>，而是<code class="language-plaintext highlighter-rouge">:</code>：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-cp</span> .:commons-logging-1.2.jar Main
</code></pre></div></div><p>Commons Logging定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是<code class="language-plaintext highlighter-rouge">INFO</code>。<br /> 使用Commons Logging时，如果在静态方法中引用<code class="language-plaintext highlighter-rouge">Log</code>，通常直接定义一个静态类型变量：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在静态方法中引用Log:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="nc">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"foo"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在实例方法中引用<code class="language-plaintext highlighter-rouge">Log</code>，通常定义一个实例变量：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在实例方法中引用Log:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">protected</span> <span class="kd">final</span> <span class="nc">Log</span> <span class="n">log</span> <span class="o">=</span> <span class="nc">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="n">getClass</span><span class="o">());</span>
    <span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"foo"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>注意到实例变量log的获取方式是<code class="language-plaintext highlighter-rouge">LogFactory.getLog(getClass())</code>，虽然也可以用<code class="language-plaintext highlighter-rouge">LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该<code class="language-plaintext highlighter-rouge">log</code>实例。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 在子类中使用父类实例化的log:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">bar</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"bar"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>由于Java类的动态特性，子类获取的<code class="language-plaintext highlighter-rouge">log</code>字段实际上相当于<code class="language-plaintext highlighter-rouge">LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。<br /> 此外，Commons Logging的日志方法，例如<code class="language-plaintext highlighter-rouge">info()</code>，除了标准的<code class="language-plaintext highlighter-rouge">info(String)</code>外，还提供了一个非常有用的重载方法：<code class="language-plaintext highlighter-rouge">info(String, Throwable)</code>，这使得记录异常更加简单：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"got exception!"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>为什么 <code class="language-plaintext highlighter-rouge">getClass()</code> 不是Object执行的?类比于<code class="language-plaintext highlighter-rouge">toString</code>,如果子类没重写那就是<code class="language-plaintext highlighter-rouge">Object</code>的<code class="language-plaintext highlighter-rouge">toString</code>,也就是打印<code class="language-plaintext highlighter-rouge">hashCode</code>;<br /> <code class="language-plaintext highlighter-rouge">getClass()</code>是<code class="language-plaintext highlighter-rouge">Object</code>类中的一个方法，用于返回当前对象的<strong>运行时类</strong>。返回的<code class="language-plaintext highlighter-rouge">Class</code>对象是由该类的静态同步方法锁定的对象。实际结果类型是<code class="language-plaintext highlighter-rouge">Class&lt;? extends |X|&gt;</code>，其中<code class="language-plaintext highlighter-rouge">|X|</code>是调用<code class="language-plaintext highlighter-rouge">getClass()</code>方法的表达式的静态类型的擦除。这意味着返回的<code class="language-plaintext highlighter-rouge">Class</code>对象表示调用<code class="language-plaintext highlighter-rouge">getClass()</code>的对象的<strong>运行时类</strong>的类型。<br /> 如果严格按继承来搞，虽然理论完美了，但大家都拿不到实际类型了，实际运行就得抓狂，所以JDK的实现是<code class="language-plaintext highlighter-rouge">native</code>方法，特事特办。<br /> 类似的还有：为啥interface可以直接向上转型为Object？这些统统是特例，说明了工程领域的一个深刻道理：理论再完备，落地也要考虑各种实际情况。</p><h2 id="log4j">Log4j</h2><p>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。<br /> Log4j是一种非常流行的日志框架，最新版本是2.x。<br /> Log4j是一个组件化设计的日志系统，它的架构大致如下：</p><pre><code class="language-ascii">log.info("User signed in.");
 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
 ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │
 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
 ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │
 │   └──────────┘    └──────────┘    └──────────┘    └──────────┘
 │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
 └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │
     └──────────┘    └──────────┘    └──────────┘    └──────────┘
</code></pre><p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库</li></ul><p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code class="language-plaintext highlighter-rouge">ERROR</code>级别的日志。<br /> 最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。<br /> 上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。<br /> 以XML配置为例，使用Log4j的时候，我们把一个<code class="language-plaintext highlighter-rouge">log4j2.xml</code>的文件放到<code class="language-plaintext highlighter-rouge">classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;Configuration&gt;</span>
	<span class="nt">&lt;Properties&gt;</span>
        <span class="c">&lt;!-- 定义日志格式 --&gt;</span>
		<span class="nt">&lt;Property</span> <span class="na">name=</span><span class="s">"log.pattern"</span><span class="nt">&gt;</span>%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n<span class="nt">&lt;/Property&gt;</span>
        <span class="c">&lt;!-- 定义文件名变量 --&gt;</span>
		<span class="nt">&lt;Property</span> <span class="na">name=</span><span class="s">"file.err.filename"</span><span class="nt">&gt;</span>log/err.log<span class="nt">&lt;/Property&gt;</span>
		<span class="nt">&lt;Property</span> <span class="na">name=</span><span class="s">"file.err.pattern"</span><span class="nt">&gt;</span>log/err.%i.log.gz<span class="nt">&lt;/Property&gt;</span>
	<span class="nt">&lt;/Properties&gt;</span>
    <span class="c">&lt;!-- 定义Appender，即目的地 --&gt;</span>
	<span class="nt">&lt;Appenders&gt;</span>
        <span class="c">&lt;!-- 定义输出到屏幕 --&gt;</span>
		<span class="nt">&lt;Console</span> <span class="na">name=</span><span class="s">"console"</span> <span class="na">target=</span><span class="s">"SYSTEM_OUT"</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span>
			<span class="nt">&lt;PatternLayout</span> <span class="na">pattern=</span><span class="s">"${log.pattern}"</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;/Console&gt;</span>
        <span class="c">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span>
		<span class="nt">&lt;RollingFile</span> <span class="na">name=</span><span class="s">"err"</span> <span class="na">bufferedIO=</span><span class="s">"true"</span> <span class="na">fileName=</span><span class="s">"${file.err.filename}"</span> <span class="na">filePattern=</span><span class="s">"${file.err.pattern}"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;PatternLayout</span> <span class="na">pattern=</span><span class="s">"${log.pattern}"</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;Policies&gt;</span>
                <span class="c">&lt;!-- 根据文件大小自动切割日志 --&gt;</span>
				<span class="nt">&lt;SizeBasedTriggeringPolicy</span> <span class="na">size=</span><span class="s">"1 MB"</span> <span class="nt">/&gt;</span>
			<span class="nt">&lt;/Policies&gt;</span>
            <span class="c">&lt;!-- 保留最近10份 --&gt;</span>
			<span class="nt">&lt;DefaultRolloverStrategy</span> <span class="na">max=</span><span class="s">"10"</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;/RollingFile&gt;</span>
	<span class="nt">&lt;/Appenders&gt;</span>
	<span class="nt">&lt;Loggers&gt;</span>
		<span class="nt">&lt;Root</span> <span class="na">level=</span><span class="s">"info"</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- 对info级别的日志，输出到console --&gt;</span>
			<span class="nt">&lt;AppenderRef</span> <span class="na">ref=</span><span class="s">"console"</span> <span class="na">level=</span><span class="s">"info"</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span>
			<span class="nt">&lt;AppenderRef</span> <span class="na">ref=</span><span class="s">"err"</span> <span class="na">level=</span><span class="s">"error"</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;/Root&gt;</span>
	<span class="nt">&lt;/Loggers&gt;</span>
<span class="nt">&lt;/Configuration&gt;</span>
</code></pre></div></div><p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code class="language-plaintext highlighter-rouge">INFO</code>级别的日志，会自动输出到屏幕，而<code class="language-plaintext highlighter-rouge">ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。<br /> 有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code class="language-plaintext highlighter-rouge">classpath</code>中：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code class="language-plaintext highlighter-rouge">commons-logging-1.2.jar</code>也放到<code class="language-plaintext highlighter-rouge">classpath</code>中。<br /> 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17:21:28.723 [main] INFO  com.aotmd.Main
start...
17:21:28.726 [main] WARN  com.aotmd.Main
end.
</code></pre></div></div><h2 id="slf4j和logback">SLF4J和Logback</h2><p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。<br /> 有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？<br /> 其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。<br /> 为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。<br /> 因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。<br /> 我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">99</span><span class="o">;</span>
<span class="n">p</span><span class="o">.</span><span class="na">setScore</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Set score "</span> <span class="o">+</span> <span class="n">score</span> <span class="o">+</span> <span class="s">" for Person "</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" ok."</span><span class="o">);</span>
</code></pre></div></div><p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">99</span><span class="o">;</span>
<span class="n">p</span><span class="o">.</span><span class="na">setScore</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>
<span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"Set score {} for Person {} ok."</span><span class="o">,</span> <span class="n">score</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div><p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。<br /> 如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Logger</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">getClass</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><p>对比一下Commons Logging和SLF4J的接口：</p><table><thead><tr><th style="text-align: left">Commons Logging</th><th style="text-align: left">SLF4J</th></tr></thead><tbody><tr><td style="text-align: left">org.apache.commons.logging.Log</td><td style="text-align: left">org.slf4j.Logger</td></tr><tr><td style="text-align: left">org.apache.commons.logging.LogFactory</td><td style="text-align: left">org.slf4j.LoggerFactory</td></tr></tbody></table><p>不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory。<br /> 使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载<a href="https://www.slf4j.org/download.html">SLF4J</a>和<a href="https://logback.qos.ch/download.html">Logback</a>，然后把以下jar包放到classpath下：</p><ul><li>slf4j-api-1.7.x.jar</li><li>logback-classic-1.2.x.jar</li><li>logback-core-1.2.x.jar</li></ul><p>目前支持jdk8的为：<br /> <a href="https://mvnrepository.com/artifact/org.slf4j/slf4j-api/2.0.12">slf4j-api-2.0.12</a><br /> <a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-core/1.3.14">logback-core-1.3.14</a><br /> <a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-classic/1.3.14">logback-classic-1.3.14</a><br /> 然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，把<code class="language-plaintext highlighter-rouge">logback.xml</code>放到classpath下，配置如下：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;configuration&gt;</span>
	<span class="nt">&lt;appender</span> <span class="na">name=</span><span class="s">"CONSOLE"</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.ConsoleAppender"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;encoder&gt;</span>
			<span class="nt">&lt;pattern&gt;</span>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n<span class="nt">&lt;/pattern&gt;</span>
		<span class="nt">&lt;/encoder&gt;</span>
	<span class="nt">&lt;/appender&gt;</span>
	<span class="nt">&lt;appender</span> <span class="na">name=</span><span class="s">"FILE"</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.RollingFileAppender"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;encoder&gt;</span>
			<span class="nt">&lt;pattern&gt;</span>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n<span class="nt">&lt;/pattern&gt;</span>
			<span class="nt">&lt;charset&gt;</span>utf-8<span class="nt">&lt;/charset&gt;</span>
		<span class="nt">&lt;/encoder&gt;</span>
		<span class="nt">&lt;file&gt;</span>log/output.log<span class="nt">&lt;/file&gt;</span>
		<span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.FixedWindowRollingPolicy"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;fileNamePattern&gt;</span>log/output.log.%i<span class="nt">&lt;/fileNamePattern&gt;</span>
		<span class="nt">&lt;/rollingPolicy&gt;</span>
		<span class="nt">&lt;triggeringPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span><span class="nt">&gt;</span>
			<span class="nt">&lt;MaxFileSize&gt;</span>1MB<span class="nt">&lt;/MaxFileSize&gt;</span>
		<span class="nt">&lt;/triggeringPolicy&gt;</span>
	<span class="nt">&lt;/appender&gt;</span>
	<span class="nt">&lt;root</span> <span class="na">level=</span><span class="s">"INFO"</span><span class="nt">&gt;</span>
		<span class="nt">&lt;appender-ref</span> <span class="na">ref=</span><span class="s">"CONSOLE"</span> <span class="nt">/&gt;</span>
		<span class="nt">&lt;appender-ref</span> <span class="na">ref=</span><span class="s">"FILE"</span> <span class="nt">/&gt;</span>
	<span class="nt">&lt;/root&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">Main</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"start..."</span><span class="o">);</span>
        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"end."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>运行即可获得类似如下的输出：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17:03:40.465 [main] INFO  com.aotmd.Main - start...
17:03:40.467 [main] WARN  com.aotmd.Main - end.
</code></pre></div></div><p>从目前的趋势来看，越来越多的开源项目从Commons Logging加Log4j转向了SLF4J加Logback。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2020/08/23/%E5%BC%82%E5%B8%B8/" target="_blank">https://acteds.github.io/2020/08/23/%E5%BC%82%E5%B8%B8/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1714032803', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
