<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java笔记 &mdash; 个人博客</title><link rel="stylesheet" href="/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="/assets/css/components/collection.css"><link rel="stylesheet" href="/assets/css/components/repo-card.css"><link rel="stylesheet" href="/assets/css/sections/repo-list.css"><link rel="stylesheet" href="/assets/css/components/boxed-group.css"><link rel="stylesheet" href="/assets/css/globals/common.css"><link rel="stylesheet" href="/assets/css/globals/responsive.css"><link rel="stylesheet" href="/assets/css/posts/index.css"><link rel="stylesheet" href="/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="/assets/css/highlight/monokai.sublime.css"><link rel="canonical" href="/2020/05/26/Java%E7%AC%94%E8%AE%B0/"><link rel="alternate" type="application/atom+xml" title="个人博客" href="/feed.xml"><link rel="shortcut icon" href="/favicon.ico"><meta property="og:title" content="Java笔记"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="引言java的基础笔记，输入输出、字符串、编码、数组、继承、多态、内部类、枚举、record、BigDecimal、BigInteger、Random、SecureRandom。"><meta name="og:description" content="引言java的基础笔记，输入输出、字符串、编码、数组、继承、多态、内部类、枚举、record、BigDecimal、BigInteger、Random、SecureRandom。"><meta property="og:url" content="/2020/05/26/Java%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="个人博客"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2020-05-26"> <script src="/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="/assets/js/jquery-ui.js"></script> <script src="/assets/js/main.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80669434-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-80669434-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="/" title="个人博客"><span class="octicon octicon-mark-github"></span> 个人博客</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java笔记"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java笔记</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2020/05/26 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="/categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 62145 字，约 178 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="引言">引言</h1><p>java的基础笔记，输入输出、字符串、编码、数组、继承、多态、内部类、枚举、record、BigDecimal、BigInteger、Random、SecureRandom。</p><h1 id="基础">基础</h1><h2 id="基本数据类型">基本数据类型</h2><ul><li>简单数据类型<ul><li>数值型<ul><li>整数类（byte(8)，short(16)，int(32)，long(64)）</li><li>浮点类型（float(32)，double(64)）</li></ul></li><li>字符型（char(16)）</li><li>布尔型（boolean(1)）</li></ul></li><li>引用数据类型<ul><li>类（class）</li><li>接口（interface）</li><li>数组</li></ul></li><li>int型：不带L：100，200，9_000_000</li><li>long型：必须带L：100L，200L，9_000_000_000_000L</li><li>double型：不带F：1.0，2.3e10</li><li>float型：必须带F：1.0F，2.3e10F</li></ul><p>中间的<code class="language-plaintext highlighter-rouge">_</code>可以随意加。<code class="language-plaintext highlighter-rouge">1_2_3_4</code>，浮点数也可以，比如<code class="language-plaintext highlighter-rouge">12_3.45</code>，不过为了规范，还是应该三个添加一个最好。</p><p><code class="language-plaintext highlighter-rouge">long l1 = 182L;</code> 因为<code class="language-plaintext highlighter-rouge">long</code>，<code class="language-plaintext highlighter-rouge">float</code>等字面值中均是数字开头，字母结尾，故变量名<strong>不能数字开头</strong>，避免与变量值歧义，编译不过。</p><p>整数运算在除数为<code class="language-plaintext highlighter-rouge">0</code>时会报错，而浮点数运算在除数为<code class="language-plaintext highlighter-rouge">0</code>时，不会报错，但会返回几个特殊值：</p><ul><li><code class="language-plaintext highlighter-rouge">NaN</code>表示Not a Number</li><li><code class="language-plaintext highlighter-rouge">Infinity</code>表示无穷大</li><li><code class="language-plaintext highlighter-rouge">-Infinity</code>表示负无穷大</li></ul><p>java中可以对<strong>浮点数</strong>求模。</p><p>字符类型<code class="language-plaintext highlighter-rouge">char</code>表示一个字符。Java的<code class="language-plaintext highlighter-rouge">char</code>类型除了可表示标准的ASCII外，还可以表示一个Unicode字符。注意<code class="language-plaintext highlighter-rouge">char</code>类型使用单引号<code class="language-plaintext highlighter-rouge">'</code>，且仅有一个字符，要和双引号<code class="language-plaintext highlighter-rouge">"</code>的字符串类型区分开。</p><p><code class="language-plaintext highlighter-rouge">var</code>不是关键字，而是在Java 10中引入的一种类型推断的新特性。它用于声明局部变量时，可以根据赋值语句的类型推断变量的类型，从而简化代码编写。需要注意的是，虽然<code class="language-plaintext highlighter-rouge">var</code>可以用于声明局部变量，但不能用于声明方法参数、方法返回值、类的字段等其他地方。</p><hr /><p><strong>位移&lt;&lt;&gt;&gt; &gt;&gt;&gt;</strong></p><p>左移加0,右移加<strong>符号位</strong></p><p>例如<strong>int a=30;a&gt;&gt;36;</strong></p><p>那么<strong>36</strong>大于<strong>int的位数</strong>,要进行除<strong>32</strong>取余,即<strong>a&gt;&gt;4</strong></p><p>无符号右移运算符<strong>&gt;&gt;&gt;</strong></p><p>用来将一个数的各二进制位无符号右移若干位,与运算符<strong>&gt;&gt;相同</strong>的是移出的低位被舍弃,但<strong>不同</strong>的是最高位<strong>补0</strong>,如:</p><p><strong>a=00110111</strong>,则<strong>a&gt;&gt;&gt;2</strong> 结果为 <strong>00001101</strong></p><p><strong>b=11010011</strong>,则<strong>b&gt;&gt;&gt;2</strong> 结果为 <strong>00110100</strong></p><hr /><p><strong>处理无符号整型</strong></p><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code class="language-plaintext highlighter-rouge">byte</code>、<code class="language-plaintext highlighter-rouge">short</code>、<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p><p>例如，byte是有符号整型，范围是<code class="language-plaintext highlighter-rouge">-128</code>~<code class="language-plaintext highlighter-rouge">+127</code>，但如果把<code class="language-plaintext highlighter-rouge">byte</code>看作无符号整型，它的范围就是<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">255</code>。把一个负的<code class="language-plaintext highlighter-rouge">byte</code>按无符号整型转换为<code class="language-plaintext highlighter-rouge">int</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="kt">byte</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Byte</span><span class="o">.</span><span class="na">toUnsignedInt</span><span class="o">(</span><span class="n">x</span><span class="o">));</span> <span class="c1">// 255</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Byte</span><span class="o">.</span><span class="na">toUnsignedInt</span><span class="o">(</span><span class="n">y</span><span class="o">));</span> <span class="c1">// 127</span>
</code></pre></div></div><p>因为<code class="language-plaintext highlighter-rouge">byte</code>的<code class="language-plaintext highlighter-rouge">-1</code>的二进制表示是<code class="language-plaintext highlighter-rouge">11111111</code>，以无符号整型转换后的<code class="language-plaintext highlighter-rouge">int</code>就是<code class="language-plaintext highlighter-rouge">255</code>。</p><p>类似的，可以把一个<code class="language-plaintext highlighter-rouge">short</code>按unsigned转换为<code class="language-plaintext highlighter-rouge">int</code>，把一个<code class="language-plaintext highlighter-rouge">int</code>按unsigned转换为<code class="language-plaintext highlighter-rouge">long</code>。</p><p>负数在计算机中用补码表示，计算方法是除符号位外取反+1，-1的原码是10000001，取反=111111110，再+1=11111111之所以用补码不是原码是因为补码可以把减法转换为加法</p><hr /><p><code class="language-plaintext highlighter-rouge">Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p><h2 id="输入输出">输入输出</h2><p><strong>输入</strong></p><ul><li><code class="language-plaintext highlighter-rouge">nextInt()</code>: 读取输入的下一个整数。如果遇到非整数字符（如空格、换行符等），会停止读取，并将输入中的整数部分作为结果返回。</li><li><code class="language-plaintext highlighter-rouge">nextDouble()</code>: 读取输入的下一个浮点数（小数）。同样地，遇到非浮点数字符会停止读取，并将输入中的浮点数部分作为结果返回。</li><li><code class="language-plaintext highlighter-rouge">next()</code>: 读取输入的下一个单词（以空格分隔的字符串）。遇到空格、换行符等会停止读取，并将输入中的单词部分作为结果返回。</li><li><code class="language-plaintext highlighter-rouge">nextLine()</code>: 读取输入的下一行文本（包括换行符）。它会读取输入直到换行符为止，并将包括换行符在内的整行文本作为结果返回。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Scanner</span><span class="o">;</span>
<span class="nc">Scanner</span> <span class="n">scanner</span><span class="o">=</span><span class="k">new</span> <span class="nc">Scanner</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">scanner</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span><span class="c1">//读整数</span>
<span class="kt">double</span> <span class="n">d</span><span class="o">=</span><span class="n">nextDouble</span><span class="o">()</span><span class="c1">//读小数</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">scanner</span><span class="o">.</span><span class="na">next</span><span class="o">();</span><span class="c1">//读一串</span>
<span class="n">scanner</span><span class="o">.</span><span class="na">nextLine</span><span class="o">();</span><span class="c1">//读一行</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">System.out</code>代表标准输出流，而<code class="language-plaintext highlighter-rouge">System.in</code>代表标准输入流。</p><p><strong>输出</strong></p><p>有回车 <code class="language-plaintext highlighter-rouge">System.out.println();</code></p><p>无回车 <code class="language-plaintext highlighter-rouge">System.out.print();</code></p><p>格式化输出使用<code class="language-plaintext highlighter-rouge">System.out.printf()</code>，不想打印只想生成字符串则使用<code class="language-plaintext highlighter-rouge">String.format()</code>。</p><table><thead><tr><th style="text-align: left">占位符</th><th style="text-align: left">说明</th><th>占位符</th><th>说明</th></tr></thead><tbody><tr><td style="text-align: left">%d</td><td style="text-align: left">格式化输出整数</td><td>%%</td><td>转义%，代指一个%</td></tr><tr><td style="text-align: left">%x</td><td style="text-align: left">格式化输出十六进制整数</td><td>%8d</td><td>输出补到8位，不足在<strong>前</strong>面补空格</td></tr><tr><td style="text-align: left">%f</td><td style="text-align: left">格式化输出浮点数</td><td>%-8d</td><td>输出补到8位，不足在<strong>后</strong>面补空格</td></tr><tr><td style="text-align: left">%e</td><td style="text-align: left">格式化输出科学计数法表示的浮点数</td><td>%08d</td><td>输出补到8位，不足则<strong>前</strong>面补<strong>0</strong></td></tr><tr><td style="text-align: left">%s</td><td style="text-align: left">格式化字符串</td><td>%6.3f</td><td>输出补到6位,小数位占3位</td></tr></tbody></table><p>详细的格式化参数请参考JDK文档<a href="https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/util/Formatter.html#syntax">java.util.Formatter</a></p><h2 id="字符串">字符串</h2><p><strong><code class="language-plaintext highlighter-rouge">args[0]</code></strong>是命令行执行的第一个字符串 <code class="language-plaintext highlighter-rouge">public static void main(String[] args){}</code>，以此类推。</p><h3 id="字符类型">字符类型</h3><p>字符类型<code class="language-plaintext highlighter-rouge">char</code>是<strong>基本数据类型</strong>，它是<code class="language-plaintext highlighter-rouge">character</code>的缩写。一个<code class="language-plaintext highlighter-rouge">char</code>保存一个Unicode字符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">c1</span> <span class="o">=</span> <span class="sc">'A'</span><span class="o">;</span><span class="kt">char</span> <span class="n">c2</span> <span class="o">=</span> <span class="sc">'中'</span><span class="o">;</span>
</code></pre></div></div><p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用<strong>一个</strong><code class="language-plaintext highlighter-rouge">char</code>类型表示，它们都占用<strong>两个字节</strong>。要显示一个字符的Unicode编码，只需将<code class="language-plaintext highlighter-rouge">char</code>类型直接赋值给<code class="language-plaintext highlighter-rouge">int</code>类型即可：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="sc">'A'</span><span class="o">;</span> <span class="c1">// 字母“A”的Unicodde编码是65</span>
<span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="sc">'中'</span><span class="o">;</span> <span class="c1">// 汉字“中”的Unicode编码是20013</span>
</code></pre></div></div><p>还可以直接用转义字符<code class="language-plaintext highlighter-rouge">\u</code>+Unicode编码来表示一个字符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意是十六进制:</span>
<span class="kt">char</span> <span class="n">c3</span> <span class="o">=</span> <span class="sc">'\u0041'</span><span class="o">;</span> <span class="c1">// 'A'，因为十六进制0041 = 十进制65</span>
<span class="kt">char</span> <span class="n">c4</span> <span class="o">=</span> <span class="sc">'\u4e2d'</span><span class="o">;</span> <span class="c1">// '中'，因为十六进制4e2d = 十进制20013</span>
</code></pre></div></div><h3 id="字符串类型">字符串类型</h3><p>字符串类型<code class="language-plaintext highlighter-rouge">String</code>是<strong>引用类型</strong>，<code class="language-plaintext highlighter-rouge">\</code>是转义字符，两个<code class="language-plaintext highlighter-rouge">\\</code>表示一个<code class="language-plaintext highlighter-rouge">\</code>字符：<br /> 常见的转义字符包括：</p><ul><li><code class="language-plaintext highlighter-rouge">\"</code> 表示字符<code class="language-plaintext highlighter-rouge">"</code></li><li><code class="language-plaintext highlighter-rouge">\'</code> 表示字符<code class="language-plaintext highlighter-rouge">'</code></li><li><code class="language-plaintext highlighter-rouge">\\</code> 表示字符<code class="language-plaintext highlighter-rouge">\</code></li><li><code class="language-plaintext highlighter-rouge">\n</code> 表示换行符</li><li><code class="language-plaintext highlighter-rouge">\r</code> 表示回车符</li><li><code class="language-plaintext highlighter-rouge">\t</code> 表示Tab</li><li><code class="language-plaintext highlighter-rouge">\u####</code> 表示一个Unicode编码的字符</li></ul><p>Java编译器对<code class="language-plaintext highlighter-rouge">String</code>有特殊处理，即可以直接用<code class="language-plaintext highlighter-rouge">"..."</code>来表示一个字符串。实际上字符串在<code class="language-plaintext highlighter-rouge">String</code>内部是通过一个<code class="language-plaintext highlighter-rouge">char[]</code>数组表示的，因此，按下面的写法也是可以的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="k">new</span> <span class="kt">char</span><span class="o">[]</span> <span class="o">{</span><span class="sc">'H'</span><span class="o">,</span> <span class="sc">'e'</span><span class="o">,</span> <span class="sc">'l'</span><span class="o">,</span> <span class="sc">'l'</span><span class="o">,</span> <span class="sc">'o'</span><span class="o">,</span> <span class="sc">'!'</span><span class="o">});</span>
</code></pre></div></div><hr /><p><strong>字符串连接</strong></p><p>Java的编译器对字符串做了特殊照顾，可以使用<code class="language-plaintext highlighter-rouge">+</code>连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。如果用<code class="language-plaintext highlighter-rouge">+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接。</p><p>引用类型的变量可以指向一个空值<code class="language-plaintext highlighter-rouge">null</code>，它表示不存在，即该变量不指向任何对象。要区分空值<code class="language-plaintext highlighter-rouge">null</code>和空字符串<code class="language-plaintext highlighter-rouge">""</code>，空字符串是一个有效的字符串对象，它不等于<code class="language-plaintext highlighter-rouge">null</code>。</p><hr /><p><strong>多行字符串</strong></p><p>从<strong>Java 13</strong>开始，字符串可以用<code class="language-plaintext highlighter-rouge">"""..."""</code>表示多行字符串（Text Blocks）了。多行字符串前面共同的空格会被去掉，即：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"""
...........SELECT * FROM
...........  users
...........WHERE id &gt; 100
...........ORDER BY name DESC
..........."""</span><span class="o">;</span>
</code></pre></div></div><p>用<code class="language-plaintext highlighter-rouge">.</code>标注的空格都会被去掉。如果多行字符串的排版不规则，那么，去掉的空格就会变成这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"""
.........  SELECT * FROM
.........    users
.........WHERE id &gt; 100
.........  ORDER BY name DESC
.........  """</span><span class="o">;</span>
</code></pre></div></div><p>总是以最短的行首空格为基准。</p><hr /><h3 id="不可变特性">不可变特性</h3><p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。字符串会维护在常量池内，而字符串变量指向常量池中的字符串。</p><p>这意味着一旦字符串对象被创建，它的值就不能被修改。当你对字符串进行操作时，实际上是创建了一个新的字符串对象，而原始字符串对象保持不变。</p><p>这种不可变性带来了一些优点，例如：</p><ul><li>线程安全：由于字符串是不可变的，多个线程可以安全地共享字符串对象而无需担心数据竞争。</li><li>缓存哈希值：由于字符串的不可变性，可以缓存字符串的哈希值，提高性能。</li><li>安全性：不可变字符串可以避免在运行时被修改，提高代码的安全性。</li></ul><p>另外，字符串常量池是Java中用于存储字符串常量的特殊区域，它可以减少内存占用，提高性能。当你创建一个字符串常量时，如果常量池中已经存在相同内容的字符串，则会直接返回常量池中的字符串引用，而不会创建新的字符串对象。</p><p>因此，了解字符串的不可变性和字符串常量池的特性有助于更好地理解和利用Java中的字符串。</p><hr /><p>判断值类型的变量是否相等，可以使用<code class="language-plaintext highlighter-rouge">==</code>运算符。但是，判断引用类型的变量是否相等，<code class="language-plaintext highlighter-rouge">==</code>表示“引用是否相等”。要判断引用类型的变量内容是否相等，必须使用<code class="language-plaintext highlighter-rouge">equals()</code>方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"HELLO"</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s2</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s1 == s2"</span><span class="o">);</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"s1 != s2"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>调用<code class="language-plaintext highlighter-rouge">"HELLO".toLowerCase()</code>会创建一个新的<strong>字符串对象</strong>，因为在Java中字符串是不可变的，任何对字符串的修改操作都会创建一个新的字符串对象。因此，<code class="language-plaintext highlighter-rouge">"HELLO".toLowerCase()</code>会在堆内存中创建一个新的字符串对象，该对象存储小写形式的字符串。因此，<code class="language-plaintext highlighter-rouge">String s2 = "HELLO".toLowerCase();</code>中的<code class="language-plaintext highlighter-rouge">s2</code>引用的是<strong>堆</strong>内存中新创建的对象，其内存地址与字符串常量池中的地址不同。</p><h3 id="obectequals">Obect.equals()</h3><p>判断两个字符串是否相等在java中,用的是<strong>equals();</strong></p><p>例;A字符串和B和字符串比较:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">a</span><span class="o">=</span><span class="s">"123"</span><span class="o">,</span><span class="n">b</span><span class="o">=</span><span class="s">"456"</span><span class="o">;</span>  
<span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">))</span> <span class="o">{</span>  
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"相等"</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div><p><strong>equals()</strong>是<strong>Object</strong>的方法,所以对所有对象都适用。<strong>默认</strong>为:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>  
    <span class="k">return</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">);</span>  
<span class="o">}</span>
</code></pre></div></div><p><strong>String.equals()</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">anObject</span><span class="o">)</span> <span class="o">{</span>  
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">anObject</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="k">if</span> <span class="o">(</span><span class="n">anObject</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">String</span> <span class="n">aString</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span><span class="n">anObject</span><span class="o">;</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">coder</span><span class="o">()</span> <span class="o">==</span> <span class="n">aString</span><span class="o">.</span><span class="na">coder</span><span class="o">())</span> <span class="o">{</span>  
            <span class="k">return</span> <span class="nf">isLatin1</span><span class="o">()</span> <span class="o">?</span> <span class="nc">StringLatin1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">aString</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> 
                <span class="o">:</span> <span class="nc">StringUTF16</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">aString</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>  
        <span class="o">}</span>  
    <span class="o">}</span>  
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>  
<span class="o">}</span>
</code></pre></div></div><p><strong>String</strong>类重写<strong>equals</strong>方法时,首先判断如果是自己直接返回<strong>true</strong>,如果不是自己,判断参数是否为<strong>String</strong>类型,不是则返回<strong>false</strong>。之后就是比较字符串内容是否相等了。</p><p>堆和常量池的区别:</p><p>Java的存储空间：寄存器、栈、<strong>堆</strong>、静态存储区、<strong>常量存储区(常量池)</strong>、其他存储位置。</p><p>此处重点介绍堆和常量存储区：</p><p><strong>堆</strong>：存储<strong>new</strong>的对象; <strong>常量池</strong>：用来存储<strong>final static</strong>、<strong>String</strong>的常量。</p><p><strong>Object.equals</strong>与<strong>String.equals</strong>的区别</p><p><strong>Object.equals(==)</strong>：<strong>比较内存地址;</strong></p><p><strong>String.equals: 比较内容,不管内存地址。</strong></p><p><strong>Object.equals</strong>相等,<strong>String.equals一定</strong>相等;</p><p><strong>String.equals</strong>相等,<strong>Object.equals不一定</strong>相等。</p><p>实例</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 维护在常量池里面  </span>
<span class="nc">String</span> <span class="n">a</span><span class="o">=</span><span class="s">"hello"</span><span class="o">;</span>  
<span class="nc">String</span> <span class="n">b</span><span class="o">=</span><span class="s">"hello"</span><span class="o">;</span>  
<span class="c1">// new出来的所有对象都在堆内存中  </span>
<span class="c1">// 只要是new出现来的都是新对象  </span>
<span class="nc">String</span> <span class="n">c</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>  
<span class="nc">String</span> <span class="n">d</span><span class="o">=</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"hello"</span><span class="o">);</span>  
<span class="c1">// 对比内存地址  </span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a==b = "</span> <span class="o">+</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">));</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a==c = "</span> <span class="o">+</span> <span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">c</span><span class="o">));</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"c==d = "</span> <span class="o">+</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">d</span><span class="o">));</span>  
<span class="c1">// 对比内容  </span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a.equals(b) = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"a.equals(c) = "</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">c</span><span class="o">));</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"c.equals(d) = "</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">d</span><span class="o">));</span>
</code></pre></div></div><p>结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a==b = true
a==c = false
c==d = false
a.equals(b) = true
a.equals(c) = true
c.equals(d) = true
</code></pre></div></div><p><strong>a</strong>,<strong>b</strong>都是常量,<strong>a</strong>和<strong>b</strong>都是指向常量存储区中的常量<strong>‘hello’</strong>,所以无论内容还是内存地址都是一样的,因此<strong>a==b</strong>以及<strong>a.equals(b)</strong>都是<strong>true</strong>;</p><p><strong>c,d</strong>都是变量,他们都是<strong>new</strong>出来的对象,里面存在两个<strong>hello</strong>变量,<strong>c</strong>和<strong>d</strong>分别指向自己的<strong>hello</strong>变量,所以<strong>c</strong>和<strong>d</strong>内容一样,但是内存地址不一样,因此<strong>c==d</strong>是<strong>false</strong>,但是<strong>c.equals(d)</strong>为<strong>true</strong>。</p><h3 id="常用方法">常用方法</h3><ul><li><code class="language-plaintext highlighter-rouge">equals(Object obj)</code>: 比较两个字符串值是否相等。</li><li><code class="language-plaintext highlighter-rouge">equalsIgnoreCase(String anotherString)</code>: 比较两个字符串值是否相等，忽略大小写。</li><li><code class="language-plaintext highlighter-rouge">length()</code>: 返回字符串的长度。</li><li><code class="language-plaintext highlighter-rouge">charAt(int index)</code>: 返回指定索引处的字符。</li><li><code class="language-plaintext highlighter-rouge">substring(int beginIndex)</code>: 返回从指定索引开始到字符串末尾的子字符串。</li><li><code class="language-plaintext highlighter-rouge">substring(int beginIndex, int endIndex)</code>: 返回从beginIndex开始到endIndex-1的子字符串。</li><li><code class="language-plaintext highlighter-rouge">indexOf(String str)</code>: 返回指定子字符串在原字符串中第一次出现的索引。</li><li><code class="language-plaintext highlighter-rouge">lastIndexOf(String str)</code>: 返回指定子字符串在原字符串中最后一次出现的索引。</li><li><code class="language-plaintext highlighter-rouge">contains(CharSequence s)</code>: 判断是否包含指定的字符序列。</li><li><code class="language-plaintext highlighter-rouge">startsWith(String prefix)</code>: 判断字符串是否以指定前缀开头。</li><li><code class="language-plaintext highlighter-rouge">endsWith(String suffix)</code>: 判断字符串是否以指定后缀结尾。</li><li><code class="language-plaintext highlighter-rouge">isEmpty()</code>: 判断字符串是否为空。</li><li><code class="language-plaintext highlighter-rouge">isBlank()</code>: 判断字符串是否只有空白字符。</li><li><code class="language-plaintext highlighter-rouge">toUpperCase()</code>: 将字符串转换为大写。</li><li><code class="language-plaintext highlighter-rouge">toLowerCase()</code>: 将字符串转换为小写。</li><li><code class="language-plaintext highlighter-rouge">trim()</code>: 去除字符串两端的空白字符。</li><li><code class="language-plaintext highlighter-rouge">strip()</code>: 去除字符串两端的空白字符，包括中文空格。</li><li><code class="language-plaintext highlighter-rouge">replace(char oldChar, char newChar)</code>: 替换字符串中的字符。</li><li><code class="language-plaintext highlighter-rouge">replace(String old, String new)</code>: 替换字符串中的old为new。</li><li><code class="language-plaintext highlighter-rouge">replaceAll(String regex, String new)</code>: 正则替换。</li><li><code class="language-plaintext highlighter-rouge">split(String regex)</code>: 根据给定正则表达式分隔字符串。</li><li><code class="language-plaintext highlighter-rouge">String.join(CharSequence delimiter, CharSequence... elements)</code>: 使用指定分隔符delimiter连接多个字符串。</li><li><code class="language-plaintext highlighter-rouge">String.format(String format, Object... args)</code>: 使用指定格式化字符串和参数创建格式化字符串。</li><li><code class="language-plaintext highlighter-rouge">formatted(Object... args)</code>: 格式化字符串，同上，只是format变成了调用方。。</li><li><code class="language-plaintext highlighter-rouge">matches(String regex)</code>: 判断字符串是否匹配指定的正则表达式。</li><li><code class="language-plaintext highlighter-rouge">String.valueOf(Object o)</code>:转换为字符串。</li></ul><h3 id="字符串转其他类型">字符串转其他类型</h3><p>将<strong>radix</strong>进制的<strong>s</strong>转换为十进制数。<code class="language-plaintext highlighter-rouge">Integer.parseInt(String s[,int radix=10])</code> <strong>radix</strong>的范围是在2~36之间,超出范围会<strong>抛异常</strong>，<strong>s</strong>的长度也<strong>不能超出</strong>7,否则也会抛异常。</p><p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code class="language-plaintext highlighter-rouge">int</code>类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span> <span class="c1">// 123</span>
<span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="s">"ff"</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span> <span class="c1">// 按十六进制转换，255</span>
</code></pre></div></div><p>把字符串转换为<code class="language-plaintext highlighter-rouge">boolean</code>类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">b1</span> <span class="o">=</span> <span class="nc">Boolean</span><span class="o">.</span><span class="na">parseBoolean</span><span class="o">(</span><span class="s">"true"</span><span class="o">);</span> <span class="c1">// true</span>
<span class="kt">boolean</span> <span class="n">b2</span> <span class="o">=</span> <span class="nc">Boolean</span><span class="o">.</span><span class="na">parseBoolean</span><span class="o">(</span><span class="s">"FALSE"</span><span class="o">);</span> <span class="c1">// false</span>
</code></pre></div></div><p>要特别注意，<code class="language-plaintext highlighter-rouge">Integer</code>有个<code class="language-plaintext highlighter-rouge">getInteger(String)</code>方法，它不是将字符串转换为<code class="language-plaintext highlighter-rouge">int</code>，而是把该字符串对应的系统变量转换为<code class="language-plaintext highlighter-rouge">Integer</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span><span class="o">.</span><span class="na">getInteger</span><span class="o">(</span><span class="s">"java.version"</span><span class="o">);</span> <span class="c1">// 版本号，11</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">String</code>和<code class="language-plaintext highlighter-rouge">char[]</code>类型可以互相转换，方法是：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> <span class="c1">// String -&gt; char[]</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span> <span class="c1">// char[] -&gt; String</span>
</code></pre></div></div><p>如果修改了<code class="language-plaintext highlighter-rouge">char[]</code>数组，<code class="language-plaintext highlighter-rouge">String</code>并不会改变。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">[]</span> <span class="n">cs</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">cs</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
<span class="n">cs</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</code></pre></div></div><p>这是因为通过<code class="language-plaintext highlighter-rouge">new String(char[])</code>创建新的<code class="language-plaintext highlighter-rouge">String</code>实例时，它并不会直接引用传入的<code class="language-plaintext highlighter-rouge">char[]</code>数组，而是会复制一份，所以，修改外部的<code class="language-plaintext highlighter-rouge">char[]</code>数组不会影响<code class="language-plaintext highlighter-rouge">String</code>实例内部的<code class="language-plaintext highlighter-rouge">char[]</code>数组，因为这是两个不同的数组。</p><p>从<code class="language-plaintext highlighter-rouge">String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><h3 id="字符编码">字符编码</h3><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code class="language-plaintext highlighter-rouge">0</code>到<code class="language-plaintext highlighter-rouge">127</code>，最高位始终为<code class="language-plaintext highlighter-rouge">0</code>，称为<code class="language-plaintext highlighter-rouge">ASCII</code>编码。例如，字符<code class="language-plaintext highlighter-rouge">'A'</code>的编码是<code class="language-plaintext highlighter-rouge">0x41</code>，字符<code class="language-plaintext highlighter-rouge">'1'</code>的编码是<code class="language-plaintext highlighter-rouge">0x31</code>。</p><p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code class="language-plaintext highlighter-rouge">GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code class="language-plaintext highlighter-rouge">1</code>，以便和<code class="language-plaintext highlighter-rouge">ASCII</code>编码区分开。例如，汉字<code class="language-plaintext highlighter-rouge">'中'</code>的<code class="language-plaintext highlighter-rouge">GB2312</code>编码是<code class="language-plaintext highlighter-rouge">0xd6d0</code>。</p><p>类似的，日文有<code class="language-plaintext highlighter-rouge">Shift_JIS</code>编码，韩文有<code class="language-plaintext highlighter-rouge">EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p><p>为了统一全球所有语言的编码，全球统一码联盟发布了<code class="language-plaintext highlighter-rouge">Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p><p><code class="language-plaintext highlighter-rouge">Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在<code class="language-plaintext highlighter-rouge">ASCII</code>、<code class="language-plaintext highlighter-rouge">GB2312</code>和<code class="language-plaintext highlighter-rouge">Unicode</code>的编码：</p><p>英文字符<code class="language-plaintext highlighter-rouge">'A'</code>的<code class="language-plaintext highlighter-rouge">ASCII</code>编码和<code class="language-plaintext highlighter-rouge">Unicode</code>编码：</p><pre><code class="language-ascii">         ┌────┐
ASCII:   │ 41 │
         └────┘
         ┌────┬────┐
Unicode: │ 00 │ 41 │
         └────┴────┘
</code></pre><p>英文字符的<code class="language-plaintext highlighter-rouge">Unicode</code>编码就是简单地在前面添加一个<code class="language-plaintext highlighter-rouge">00</code>字节。</p><p>中文字符<code class="language-plaintext highlighter-rouge">'中'</code>的<code class="language-plaintext highlighter-rouge">GB2312</code>编码和<code class="language-plaintext highlighter-rouge">Unicode</code>编码：</p><pre><code class="language-ascii">         ┌────┬────┐
GB2312:  │ d6 │ d0 │
         └────┴────┘
         ┌────┬────┐
Unicode: │ 4e │ 2d │
         └────┴────┘
</code></pre><p>那我们经常使用的<code class="language-plaintext highlighter-rouge">UTF-8</code>又是什么编码呢？因为英文字符的<code class="language-plaintext highlighter-rouge">Unicode</code>编码高字节总是<code class="language-plaintext highlighter-rouge">00</code>，包含大量英文的文本会浪费空间，所以，出现了<code class="language-plaintext highlighter-rouge">UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code class="language-plaintext highlighter-rouge">Unicode</code>编码变成1～4字节的变长编码。通过<code class="language-plaintext highlighter-rouge">UTF-8</code>编码，英文字符<code class="language-plaintext highlighter-rouge">'A'</code>的<code class="language-plaintext highlighter-rouge">UTF-8</code>编码变为<code class="language-plaintext highlighter-rouge">0x41</code>，正好和<code class="language-plaintext highlighter-rouge">ASCII</code>码一致，而中文<code class="language-plaintext highlighter-rouge">'中'</code>的<code class="language-plaintext highlighter-rouge">UTF-8</code>编码为3字节<code class="language-plaintext highlighter-rouge">0xe4b8ad</code>。</p><p><code class="language-plaintext highlighter-rouge">UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code class="language-plaintext highlighter-rouge">UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>在Java中，<code class="language-plaintext highlighter-rouge">char</code>类型实际上就是两个字节的<code class="language-plaintext highlighter-rouge">Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">b1</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span> <span class="c1">// 按系统默认编码转换，不推荐</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">b2</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"UTF-8"</span><span class="o">);</span> <span class="c1">// 按UTF-8编码转换</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">b2</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">"GBK"</span><span class="o">);</span> <span class="c1">// 按GBK编码转换</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">b3</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span> <span class="c1">// 按UTF-8编码转换</span>
</code></pre></div></div><p>注意：转换编码后，就不再是<code class="language-plaintext highlighter-rouge">char</code>类型，而是<code class="language-plaintext highlighter-rouge">byte</code>类型表示的数组。</p><p>如果要把已知编码的<code class="language-plaintext highlighter-rouge">byte[]</code>转换为<code class="language-plaintext highlighter-rouge">String</code>，可以这样做：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="s">"GBK"</span><span class="o">);</span> <span class="c1">// 按GBK转换</span>
<span class="nc">String</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="nc">StandardCharsets</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">);</span> <span class="c1">// 按UTF-8转换</span>
</code></pre></div></div><p>始终牢记：Java的<code class="language-plaintext highlighter-rouge">String</code>和<code class="language-plaintext highlighter-rouge">char</code>在内存中总是以Unicode编码表示。</p><p>对于不同版本的JDK，<code class="language-plaintext highlighter-rouge">String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code class="language-plaintext highlighter-rouge">String</code>总是以<code class="language-plaintext highlighter-rouge">char[]</code>存储，它的定义如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">offset</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>而较新的JDK版本的<code class="language-plaintext highlighter-rouge">String</code>则以<code class="language-plaintext highlighter-rouge">byte[]</code>存储：如果<code class="language-plaintext highlighter-rouge">String</code>仅包含ASCII字符，则每个<code class="language-plaintext highlighter-rouge">byte</code>存储一个字符，否则，每两个<code class="language-plaintext highlighter-rouge">byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code class="language-plaintext highlighter-rouge">String</code>通常仅包含ASCII字符：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">String</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">byte</span> <span class="n">coder</span><span class="o">;</span> <span class="c1">// 0 = LATIN1, 1 = UTF16</span>
</code></pre></div></div><p>对于使用者来说，<code class="language-plaintext highlighter-rouge">String</code>内部的优化不影响任何已有代码，因为它的<code class="language-plaintext highlighter-rouge">public</code>方法签名是不变的。</p><h3 id="字符串拼接">字符串拼接</h3><p><strong>StringBuilder</strong></p><p>Java编译器对<code class="language-plaintext highlighter-rouge">String</code>做了特殊处理，使得我们可以直接用<code class="language-plaintext highlighter-rouge">+</code>拼接字符串。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="s">","</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p><p>为了能高效拼接字符串，Java标准库提供了<code class="language-plaintext highlighter-rouge">StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code class="language-plaintext highlighter-rouge">StringBuilder</code>中新增字符时，不会创建新的临时对象。<code class="language-plaintext highlighter-rouge">StringBuilder</code>还可以进行链式调用。使用append()方法添加字符串，然后使用toString()方法返回拼接后的字符串。</p><p>对于普通的字符串<code class="language-plaintext highlighter-rouge">+</code>操作，并不需要我们将其改写为<code class="language-plaintext highlighter-rouge">StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code class="language-plaintext highlighter-rouge">+</code>操作编码为<code class="language-plaintext highlighter-rouge">StringConcatFactory</code>的操作。在运行期，<code class="language-plaintext highlighter-rouge">StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code class="language-plaintext highlighter-rouge">StringBuilder</code>操作。</p><p><code class="language-plaintext highlighter-rouge">StringBuffer</code>，是Java早期的一个<code class="language-plaintext highlighter-rouge">StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code class="language-plaintext highlighter-rouge">StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。<code class="language-plaintext highlighter-rouge">StringBuilder</code>和<code class="language-plaintext highlighter-rouge">StringBuffer</code>接口完全相同，现在完全没有必要使用<code class="language-plaintext highlighter-rouge">StringBuffer</code>。</p><p><strong>StringJoiner</strong></p><p>要高效拼接字符串，应该使用<code class="language-plaintext highlighter-rouge">StringBuilder</code>。</p><p>很多时候，我们拼接的字符串像这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Grace"</span><span class="o">};</span>
<span class="kt">var</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"Hello "</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">name</span><span class="o">).</span><span class="na">append</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 注意去掉最后的", ":</span>
<span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"!"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</code></pre></div></div><p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code class="language-plaintext highlighter-rouge">StringJoiner</code>来干这个事，构造方法可以在第二个参数和第三个参数传入开头的结尾：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Grace"</span><span class="o">};</span>
<span class="kt">var</span> <span class="n">sj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringJoiner</span><span class="o">(</span><span class="s">","</span><span class="o">,</span> <span class="s">"Hello "</span><span class="o">,</span> <span class="s">"!"</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">name</span> <span class="o">:</span> <span class="n">names</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sj</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sj</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</code></pre></div></div><p><strong>String.join()</strong></p><p><code class="language-plaintext highlighter-rouge">String</code>还提供了一个静态方法<code class="language-plaintext highlighter-rouge">join()</code>，这个方法在内部使用了<code class="language-plaintext highlighter-rouge">StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code class="language-plaintext highlighter-rouge">String.join()</code>更方便：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">"Bob"</span><span class="o">,</span> <span class="s">"Alice"</span><span class="o">,</span> <span class="s">"Grace"</span><span class="o">};</span>
<span class="kt">var</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="s">", "</span><span class="o">,</span> <span class="n">names</span><span class="o">);</span>
</code></pre></div></div><h2 id="数组">数组</h2><p>定义一个数组类型的变量，使用数组类型<code class="language-plaintext highlighter-rouge">类型[]</code>，例如，<code class="language-plaintext highlighter-rouge">int[]</code>。和单个基本类型变量不同，数组变量初始化<strong>必须</strong>使用<code class="language-plaintext highlighter-rouge">new int[5]</code>表示创建一个可容纳5个<code class="language-plaintext highlighter-rouge">int</code>元素的数组。</p><ul><li>数组所有元素初始化为默认值，整型都是<code class="language-plaintext highlighter-rouge">0</code>，浮点型是<code class="language-plaintext highlighter-rouge">0.0</code>，布尔型是<code class="language-plaintext highlighter-rouge">false</code>；</li><li>数组一旦创建后，<strong>大小</strong>就<strong>不可改变</strong>。</li></ul><p>要访问数组中的某一个元素，需要使用索引。数组索引从<code class="language-plaintext highlighter-rouge">0</code>开始，例如，5个元素的数组，索引范围是<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">4</code>。</p><p>可以修改数组中的某一个元素，使用赋值语句，例如，<code class="language-plaintext highlighter-rouge">ns[1] = 79;</code>。</p><p>可以用<code class="language-plaintext highlighter-rouge">数组变量.length</code>获取数组大小。</p><p>数组是引用类型，在使用索引访问数组元素时，如果<strong>索引超出范围</strong>，运行时将报错。</p><p>可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]</span> <span class="o">{</span> <span class="mi">68</span><span class="o">,</span> <span class="mi">79</span><span class="o">,</span> <span class="mi">91</span><span class="o">,</span> <span class="mi">85</span><span class="o">,</span> <span class="mi">62</span> <span class="o">};</span>
</code></pre></div></div><p><strong>还可以进一步简写为</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">ns</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">68</span><span class="o">,</span> <span class="mi">79</span><span class="o">,</span> <span class="mi">91</span><span class="o">,</span> <span class="mi">85</span><span class="o">,</span> <span class="mi">62</span> <span class="o">};</span>
</code></pre></div></div><p>对于<strong>简单数据类型</strong>的数组,当对其进行初始化时,会将对应的值赋给对应的各个数组元素。</p><p>在定义数组的时候,系统会给这个数组分配用于存放这个数组的内存空间：它会在<strong>堆(Heap)</strong>内存空间中给数组分配—个空间用于存放数组变量。</p><p><strong>引用数据类型</strong>数组在创建的时候也是首先给数组元素分配<strong>內存空间</strong>然后给这些数组元素一个默认的初始值<strong>null.</strong></p><p>在进行<strong>引用数据类型</strong>数组的初始化的时候,和<strong>简单数据类型</strong>数组的初始化有些<strong>不同</strong>,因为数组<strong>本身是引用类</strong>型,而现在<strong>数组元素也是</strong>引用类型,所以这个时候需要给数组元素<strong>所引用</strong>的对象<strong>也分配</strong>内存空间。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"one"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"two"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"three"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Iou"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"five"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"six"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"seven"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">7</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"eight"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">8</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"nine"</span><span class="o">);</span>  
<span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"ten"</span><span class="o">);</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
</code></pre></div></div><hr /><p>数组<strong>没有length()</strong>这个方法,<strong>String有length()</strong>这个方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">8</span><span class="o">];</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span><span class="c1">//8  </span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"012345678"</span><span class="o">;</span>  
<span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">length</span><span class="o">);</span><span class="c1">//9</span>
</code></pre></div></div><p><strong>s.charAt(n)</strong></p><p>获取<strong>字符串</strong>的第<strong>n+1</strong>个字符</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">"hello world"</span><span class="o">;</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span><span class="c1">//h</span>
</code></pre></div></div><p><strong>import java.util.Arrays;</strong></p><p><strong>Arrays.toString(arr)</strong><br /> 格式化的将数组内容转为字符串</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">={</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">};</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">b</span><span class="o">));</span><span class="c1">//[1, 2, 3, 4, 5]</span>
</code></pre></div></div><p><strong>Arrays.sort(arr)</strong></p><p>对数组进行<strong>升序</strong>排序</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">12</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">19</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">13</span><span class="o">};</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"before sort:"</span><span class="o">);</span>  
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>  
<span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"after sort:"</span><span class="o">);</span>  
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
</code></pre></div></div><p>输出:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>before sort:
12 3 19 2 10 13
after sort:
2 3 10 12 13 19
</code></pre></div></div><p>数组可直接相互<strong>热拷贝</strong>(a,b<strong>相同指向</strong>)</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span><span class="o">={</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">},</span><span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="o">;</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">a</span><span class="o">));</span><span class="c1">//[1, 2, 3]  </span>
<span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">9</span><span class="o">;</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">b</span><span class="o">));</span><span class="c1">//[9, 2, 3]</span>
</code></pre></div></div><p>冷拷贝</p><p><strong>System.arraycopy(src, srcPos, dest, destPos, length)</strong></p><p>从<strong>src</strong>[<strong>srcPos</strong>]开始复制<strong>length</strong>个元素到<strong>dest</strong>[<strong>destPos</strong>]的对应位置上.</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>源数组。</td></tr><tr><td>srcPos</td><td>源数组中的起始位置。</td></tr><tr><td>dest</td><td>目标数组。</td></tr><tr><td>destPos</td><td>目标数据中的起始位置。</td></tr><tr><td>ength</td><td>要复制的数组元素的数量。</td></tr></tbody></table><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">={</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">10</span><span class="o">};</span>  
<span class="kt">int</span><span class="o">[]</span> <span class="n">b</span> <span class="o">={</span><span class="mi">100</span><span class="o">,</span><span class="mi">200</span><span class="o">,</span><span class="mi">300</span><span class="o">,</span><span class="mi">400</span><span class="o">,</span><span class="mi">500</span><span class="o">,</span><span class="mi">600</span><span class="o">,</span><span class="mi">700</span><span class="o">,</span><span class="mi">800</span><span class="o">,</span><span class="mi">900</span><span class="o">,</span><span class="mi">100</span><span class="o">};</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"b = "</span> <span class="o">+</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">b</span><span class="o">));</span><span class="c1">//b = [100, 200, 300, 400, 500, 3, 4, 5, 6, 7]</span>
</code></pre></div></div><p>完整复制:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">={</span><span class="mi">12</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">19</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">13</span><span class="o">},</span><span class="n">b</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">b</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">b</span><span class="o">));</span><span class="c1">//[12, 3, 19, 2, 10, 13]</span>
</code></pre></div></div><h2 id="多维数组">多维数组</h2><p>当使用<strong>new</strong>来创建多维数组时,不必指定每一维的大小而<strong>只需要</strong>指定<strong>最左边</strong>的维的大小就可以了。如果你指定了其中的某一维的大小,那么所有处于这一维<strong>左边</strong>的各维的大小<strong>都要</strong>指定。</p><p>动态初始化</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][][]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">][</span><span class="mi">2</span><span class="o">][</span><span class="mi">4</span><span class="o">];</span>  
<span class="kt">int</span><span class="o">[][]</span> <span class="n">ab</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">][];</span>
</code></pre></div></div><p>静态初始化</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span><span class="o">[][][]</span> <span class="n">a2</span> <span class="o">=</span> <span class="o">{</span>  
    <span class="o">{</span>
        <span class="o">{</span><span class="mf">1.1</span><span class="o">,</span> <span class="mf">2.2</span><span class="o">},</span> <span class="o">{</span><span class="mf">3.3</span><span class="o">,</span> <span class="mf">4.4</span><span class="o">}</span>
    <span class="o">},{</span>
        <span class="o">{</span><span class="mf">5.5</span><span class="o">,</span> <span class="mf">6.6</span><span class="o">},</span> <span class="o">{</span><span class="mf">7.7</span><span class="o">,</span> <span class="mf">8.8</span><span class="o">}</span>
    <span class="o">},{</span>
        <span class="o">{</span><span class="mf">9.9</span><span class="o">,</span> <span class="mf">1.2</span><span class="o">},</span> <span class="o">{</span><span class="mf">2.3</span><span class="o">,</span> <span class="mf">3.4</span><span class="o">}</span>
    <span class="o">},</span>  
<span class="o">};</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">a2</span><span class="o">));</span>
</code></pre></div></div><p>多维数组也可以通过数组声明和初始化分开的动态初始化方法来对数组进行初始化</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span><span class="o">[][][]</span> <span class="n">a2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="o">[</span><span class="mi">2</span><span class="o">][</span><span class="mi">3</span><span class="o">][</span><span class="mi">4</span><span class="o">];</span>
</code></pre></div></div><p>java中多维数组的声明和初始化应按从高维到低维的顺序进行</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">][];</span>  
<span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>  
<span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>  
<span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span>
</code></pre></div></div><p>获取某维长度例子:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">[][]</span> <span class="n">x</span> <span class="o">=</span> <span class="o">{</span>
    <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">},</span> <span class="o">{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">},</span> <span class="o">{</span><span class="mi">6</span><span class="o">},</span> <span class="o">{}</span>
<span class="o">};</span>  
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">length</span><span class="o">);</span><span class="c1">//3  </span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">length</span><span class="o">);</span><span class="c1">//4</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Arrays.deepToString()</code>可以输出多维数组</p><h2 id="流程控制">流程控制</h2><p><code class="language-plaintext highlighter-rouge">switch</code>语句根据<code class="language-plaintext highlighter-rouge">switch (表达式)</code>计算的结果，跳转到匹配的<code class="language-plaintext highlighter-rouge">case</code>结果，然后继续执行后续语句，直到遇到<code class="language-plaintext highlighter-rouge">break</code>结束执行。字符串匹配时，是比较“内容相等”。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="o">(</span><span class="n">option</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
        <span class="o">...</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="o">...</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="o">...</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">switch</code>时，注意<code class="language-plaintext highlighter-rouge">case</code>语句并没有花括号<code class="language-plaintext highlighter-rouge">{}</code>，而且，<code class="language-plaintext highlighter-rouge">case</code>语句具有“穿透性”，漏写<code class="language-plaintext highlighter-rouge">break</code>将导致意想不到的结果。</p><p>从Java 12开始，<code class="language-plaintext highlighter-rouge">switch</code>语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且<strong>不需要</strong><code class="language-plaintext highlighter-rouge">break</code>语句，还可以直接返回值。</p><p>如果有多条语句，需要用<code class="language-plaintext highlighter-rouge">{}</code>括起来，若这时需要返回值则需要用<code class="language-plaintext highlighter-rouge">yield</code>。还可以使用多个匹配项，用逗号分隔：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">fruit</span> <span class="o">=</span> <span class="s">"pear"</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">opt</span> <span class="o">=</span> <span class="k">switch</span> <span class="o">(</span><span class="n">fruit</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">"apple"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">case</span> <span class="s">"pear"</span><span class="o">,</span> <span class="s">"mango"</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"pear or mango"</span><span class="o">);</span>
        <span class="n">yield</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">default</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">};</span><span class="c1">// 注意赋值语句要以;结束</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"opt = "</span> <span class="o">+</span> <span class="n">opt</span><span class="o">);</span>
</code></pre></div></div><hr /><p>使用<code class="language-plaintext highlighter-rouge">for</code>循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。<code class="language-plaintext highlighter-rouge">break</code>结束整个循环<code class="language-plaintext highlighter-rouge">continue</code>结束本次循环，整个循环继续执行。</p><p>使用label跳出多重循环（尽量不要使用）。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">OUTER:</span>  
<span class="c1">//outer label  </span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>  
    <span class="nl">INNER:</span>  
    <span class="c1">//inter label  </span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"轮次: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" 未执行完"</span><span class="o">);</span>  
            <span class="k">break</span> <span class="no">INNER</span><span class="o">;</span><span class="c1">//跳出内层for(),执行下一轮  </span>
        <span class="o">}</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" 完整执行"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
轮次: 9 完整执行
轮次: 10 完整执行
轮次: 11 完整执行
轮次: 12 完整执行
轮次: 13 完整执行
轮次: 14 完整执行
轮次: 15 完整执行
轮次: 16 完整执行
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">OUTER:</span>  
<span class="c1">//outer label  </span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>  
    <span class="nl">INNER:</span>  
    <span class="c1">//inter label  </span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"轮次: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>  
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" 未执行完"</span><span class="o">);</span>  
            <span class="k">break</span> <span class="no">OUTER</span><span class="o">;</span><span class="c1">//跳出外层for(),执行下一个语句  </span>
        <span class="o">}</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">" 完整执行"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>结果:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>轮次: 1 完整执行
轮次: 2 完整执行
轮次: 3 完整执行
轮次: 4 完整执行
轮次: 5 未执行完
</code></pre></div></div><h2 id="三目运算符">三目运算符</h2><p>在 Java 中，三目运算符的使用是有一定的类型要求的。三目运算符的语法如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">condition</span> <span class="o">?</span> <span class="n">value1</span> <span class="o">:</span> <span class="n">value2</span><span class="o">;</span>
</code></pre></div></div><p>其中，<code class="language-plaintext highlighter-rouge">condition</code> 是一个布尔表达式，<code class="language-plaintext highlighter-rouge">value1</code> 和 <code class="language-plaintext highlighter-rouge">value2</code> 是根据 <code class="language-plaintext highlighter-rouge">condition</code> 的结果返回的值。虽然它们不一定必须是完全相同的类型，但它们<strong>必须是兼容的</strong>，<strong>以便编译器能够推断出一个公共类型</strong>。</p><p>具体的规则如下：</p><ol><li>如果 <code class="language-plaintext highlighter-rouge">value1</code> 和 <code class="language-plaintext highlighter-rouge">value2</code> 是相同的类型，那么结果类型就是这种类型。</li><li>如果 <code class="language-plaintext highlighter-rouge">value1</code> 和 <code class="language-plaintext highlighter-rouge">value2</code> 是不同的类型，但其中一个可以自动转换成另一个的类型，那么结果类型是可以兼容的那个类型。</li><li>如果 <code class="language-plaintext highlighter-rouge">value1</code> 和 <code class="language-plaintext highlighter-rouge">value2</code> 是原始类型（如 <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>），则适用 Java 的原始类型提升规则。</li><li>如果 <code class="language-plaintext highlighter-rouge">value1</code> 和 <code class="language-plaintext highlighter-rouge">value2</code> 是对象类型，则必须有一个共同的超类型（通常是一个父类或接口），结果类型是这个共同的超类型。</li></ol><p>举几个例子来说明：</p><ol><li>相同类型的例子：<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
 <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// 结果类型是 int</span>
</code></pre></div></div></li><li>可自动转换的类型：<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
 <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">10.0</span><span class="o">;</span>
 <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// 结果类型是 double，因为 int 可以自动转换为 double</span>
</code></pre></div></div></li><li>对象类型的例子：<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>
 <span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
 <span class="nc">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span> <span class="o">?</span> <span class="n">str</span> <span class="o">:</span> <span class="n">obj</span><span class="o">;</span> <span class="c1">// 结果类型是 Object，因为 String 和 Object 具有共同的超类型 Object</span>
</code></pre></div></div></li></ol><p>当使用三目运算符时，需要确保 <code class="language-plaintext highlighter-rouge">value1</code> 和 <code class="language-plaintext highlighter-rouge">value2</code> 是类型兼容的，否则会导致编译错误。</p><h2 id="java关键字表">java关键字表</h2><table><thead><tr><th>abstract</th><th>assert</th><th>boolean</th><th>break</th><th>byte</th><th>continue</th></tr></thead><tbody><tr><td>case</td><td>catch</td><td>char</td><td>class</td><td>const</td><td>double</td></tr><tr><td>default</td><td>do</td><td>else</td><td>enum</td><td>extends</td><td>final</td></tr><tr><td>finally</td><td>float</td><td>for</td><td>goto</td><td>if</td><td>implements</td></tr><tr><td>import</td><td>instanceof</td><td>int</td><td>interface</td><td>long</td><td>native</td></tr><tr><td>new</td><td>null</td><td>package</td><td>private</td><td>protected</td><td>public</td></tr><tr><td>return</td><td>short</td><td>static</td><td>strictfp</td><td>super</td><td>switch</td></tr><tr><td>synchronized</td><td>this</td><td>throw</td><td>throws</td><td>transient</td><td>try</td></tr><tr><td>void</td><td>volatile</td><td>while</td><td> </td><td> </td><td> </td></tr></tbody></table><p><strong>volatile</strong> 关键字用于标记字段可能会被多个线程同时访问，告诉编译器不要对这个字段进行优化，因为它的值可能会在其他线程中更改。这可以确保每次读取字段时都从内存中读取最新的值，而不是使用缓存中的旧值。</p><p><strong>transient</strong> 关键字用于告诉编译器在序列化时忽略字段。当对象被序列化时，<strong>transient</strong> 修饰的字段的值不会被保存。</p><p><strong>native</strong>本地方法，由本地其他语言代码实现</p><p><strong>synchronized</strong> 关键字用于实现线程同步，确保多个线程在访问共享资源时不会发生冲突。当一个线程访问一个对象的 <strong>synchronized</strong> 方法或代码块时，其他线程必须等待，直到该线程执行完成释放锁。</p><p><strong>java.lang.Runnable</strong>多线程接口。</p><p><code class="language-plaintext highlighter-rouge">java.lang.Runnable</code>是一个接口，用于表示可以由线程执行的任务。它只包含一个方法<code class="language-plaintext highlighter-rouge">run()</code>，该方法定义了线程要执行的代码。通过实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口并重写<code class="language-plaintext highlighter-rouge">run()</code>方法，可以创建一个可运行的任务，然后将其传递给<code class="language-plaintext highlighter-rouge">Thread</code>类的构造函数，从而创建一个线程并启动它。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">run()</code>方法中包含了线程的执行逻辑，当线程启动时，会调用<code class="language-plaintext highlighter-rouge">run()</code>方法来执行任务。实现<code class="language-plaintext highlighter-rouge">Runnable</code>接口的类可以实现自己的逻辑，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, I am a runnable task."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Runnable</span> <span class="n">myRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">myRunnable</span><span class="o">);</span>
        <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>在上面的例子中，<code class="language-plaintext highlighter-rouge">MyRunnable</code>实现了<code class="language-plaintext highlighter-rouge">Runnable</code>接口，并在<code class="language-plaintext highlighter-rouge">run()</code>方法中定义了要执行的任务。然后，创建一个<code class="language-plaintext highlighter-rouge">Thread</code>对象，并将<code class="language-plaintext highlighter-rouge">MyRunnable</code>实例传递给<code class="language-plaintext highlighter-rouge">Thread</code>的构造函数，最后调用<code class="language-plaintext highlighter-rouge">start()</code>方法启动线程，线程会执行<code class="language-plaintext highlighter-rouge">MyRunnable</code>中的<code class="language-plaintext highlighter-rouge">run()</code>方法。</p><h1 id="面向对象基础">面向对象基础</h1><h2 id="包">包</h2><p>当一个大型程序交由数个不同的程序人员开发时,用到相同的类名是很有可能的, Java程序开发中为了避免这种情况,提供了一个包的概念(<strong>package</strong>) 。</p><p>同一个包内的类名<strong>不允许重复</strong>,不同包内<strong>可以有</strong>相同名称的类。包允许将类组合成较小的单元,类似于文件夹;在包与包之间对于类的访问权限能提供更有力的约束。</p><p>使用包很简单,通过关键字<strong>package</strong> 声明,作为Java源文件的<strong>第一条语句</strong>,指明该源文件定义的类所在的包。<strong>package</strong>语句一般格式为:</p><p><strong>package packageName;</strong></p><p>包名可以是一个合法的标识符,也可以是若干个标识符加”<strong>.</strong>“号分割而成,点号就是文件夹的分隔.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">tom</span><span class="o">;</span>  
<span class="kn">package</span> <span class="nn">sun.com.cn</span><span class="o">;</span>  
</code></pre></div></div><p>注意只能有一个包声明，以上只为格式例子。</p><p>如果省略了<strong>package</strong>语句,类将保存在一个缺省的没有名称的包中;尽管缺省包很方便,但对于大型的程序,它是不恰当的;请尽量为自己编写的类定义具体的包。</p><p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p><p>包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p><p><strong>import</strong></p><p>在一个<code class="language-plaintext highlighter-rouge">class</code>中，我们总会引用其他的<code class="language-plaintext highlighter-rouge">class</code>，如果要使用ArrayList，可以使用完整类名：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div><p>很显然，每次写完整类名比较痛苦。那么还可以使用<strong>import</strong>语句。</p><p>使用<strong>import</strong>语句可以引入包中的类。Java源文件中<strong>可以</strong>有<strong>多个import</strong>语句,它们在程序中的位置是有要求的,<strong>必须</strong>写在<strong>package</strong>语句和<strong>源文件</strong>的类定义<strong>之间</strong>。</p><p>要引入<code class="language-plaintext highlighter-rouge">java.util</code>包中的<code class="language-plaintext highlighter-rouge">Date</code>类,使用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Date</span><span class="o">;</span>
</code></pre></div></div><p>如果要引入一个包中的全部类,则可以用星号来代替,如:<strong>import java.awt.*;</strong></p><p>还有一种<code class="language-plaintext highlighter-rouge">import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="c1">// 导入System类的所有静态字段和静态方法:</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">System</span><span class="o">.*;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 相当于调用System.out.println(…)</span>
        <span class="n">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">import static</code>很少使用。</p><p>Java编译器最终编译出的<code class="language-plaintext highlighter-rouge">.class</code>文件只使用<strong>完整类名</strong>，因此，在代码中，当编译器遇到一个<code class="language-plaintext highlighter-rouge">class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code class="language-plaintext highlighter-rouge">class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code class="language-plaintext highlighter-rouge">package</code>是否存在这个<code class="language-plaintext highlighter-rouge">class</code>；</li><li>查找<code class="language-plaintext highlighter-rouge">import</code>的包是否包含这个<code class="language-plaintext highlighter-rouge">class</code>；</li><li>查找<code class="language-plaintext highlighter-rouge">java.lang</code>包是否包含这个<code class="language-plaintext highlighter-rouge">class</code>。</li></ul></li></ul><p>如果按照上面的规则还无法确定类名，则编译报错。</p><p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p><ul><li>默认自动<code class="language-plaintext highlighter-rouge">import</code>当前<code class="language-plaintext highlighter-rouge">package</code>的其他<code class="language-plaintext highlighter-rouge">class</code>；</li><li>默认自动<code class="language-plaintext highlighter-rouge">import java.lang.*</code>。注意：自动导入的是<code class="language-plaintext highlighter-rouge">java.lang</code>包，但类似<code class="language-plaintext highlighter-rouge">java.lang.reflect</code>这些包仍需要手动导入。</li></ul><p>如果有两个<code class="language-plaintext highlighter-rouge">class</code>名称相同，例如，<code class="language-plaintext highlighter-rouge">mr.jun.Arrays</code>和<code class="language-plaintext highlighter-rouge">java.util.Arrays</code>，那么只能<code class="language-plaintext highlighter-rouge">import</code>其中一个，另一个必须写完整类名。</p><h2 id="类">类</h2><p>类是一个独立的单位,它有一个类名,其内部包括成员变量,用于描述属性;还包括类的成员方法,用于描述行为。因此,类也被认为是种抽象数据类型,这种数据类型不但包括数据,还包括方法。</p><p>包含<strong>main</strong>方法的主类必須定义为<strong>public</strong>。</p><p>在一个.java中可以有<strong>多个</strong>类,但只能有一个类为<strong>public</strong>修饰符,且该类的名称必须与文件名称相同.</p><p><strong>class</strong>为Java定义类的关键字,必须写在<strong>修饰符</strong>和<strong>类名</strong>中间,使用空格隔开.</p><p>类的名字要符合Java的命名规范,同时名字要有意义能够反映出这个类的内容,<strong>第一个字母一般为大写</strong>.</p><p>定义类的最终目的是要使用这些类,<strong>创建</strong>并操作某类的对象是使用该类的最主要手段。</p><p><strong>创建类的实例对象</strong></p><p><strong>类名对象名=new类名([参数1,参数2…]);</strong></p><p>例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">NoteTest</span> <span class="n">t</span><span class="o">=</span><span class="k">new</span> <span class="nc">NoteTest</span><span class="o">();</span>
</code></pre></div></div><p>通过运算符“<strong>.</strong>”,对象可以实现对<strong>自己变量</strong>的访问及对<strong>自己方法</strong>的调用。</p><hr /><h3 id="构造方法">构造方法</h3><p>构造方法是让编程人员在编写代码的时候可以更方便,少写点代码,还可以在构造方法里面加入一些初始化代码.</p><p><strong>构造方法</strong>是类中的一种特殊方法,是为对象<strong>初始化</strong>操作编写的方法,用它来定义对象的初始状态。每个类都有<strong>构造方法</strong>,它也是由<strong>方法名</strong>、<strong>参数</strong>和<strong>方法体</strong>组成。构造<strong>方法名必须</strong>与<strong>类名相同</strong>,它<strong>没有返回值类型</strong>,用户<strong>不能直接调用</strong>它,<strong>只能</strong>通过<strong>new</strong>对象实例化时由虚拟机<strong>自动调用</strong>.</p><p>因为是由虚拟机来调用构造方法,所以构造方法一般应定义成 <strong>public</strong></p><p><strong>每个</strong>对象在生成时都<strong>必须</strong>执行构造方法,而且只能执行一次;如果构造方法调用失败,那么对象也无法创建;</p><p>在没有定义构造方法的情况下,类会<strong>自动</strong>产生一个无参数的默认构造方法,这个默认的构造方法什么都不做;一旦<strong>显式</strong>地定义了构造方法,默认的无参构造方法自动消失,若此时还需要无参构造方法,则需要显示地重新定义。</p><p>一个类可以有多个<strong>构造方法</strong>,<strong>构造方法可以被重载</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">uid</span><span class="o">,</span><span class="n">username</span><span class="o">,</span><span class="n">password</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">User</span><span class="o">()</span> <span class="o">{}</span>  
    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">uid</span><span class="o">,</span> <span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="nc">String</span> <span class="n">password</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">uid</span> <span class="o">=</span> <span class="n">uid</span><span class="o">;</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="n">password</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h3 id="this">this</h3><p><strong>this</strong>就是指代当前对象 ,<strong>this可以</strong>出现在<strong>实例方法</strong>和<strong>构造方法</strong>中,但<strong>不可以</strong>出现在<strong>类方法</strong>中。</p><p>当<strong>局部变量</strong>和<strong>成员变量</strong>的名字<strong>相同</strong>时,成员变量就会被隐藏,这时如果想在成员方法中使用成员变量,就必须便用关键字<strong>this</strong>.</p><p>语法：</p><blockquote><p><strong>this.成员变量名</strong></p><p><strong>this.成员方法名()</strong></p><p><strong>this()</strong></p></blockquote><p>通过<strong>this()</strong>可以调用自己的其他<strong>构造方法</strong>.</p><p>在使用<strong>this</strong>调用构造方法的时候有以下规范:</p><p>所有的<strong>构造方法</strong>是在对象实例化的时候被默认调用而且是在调用普通方法<strong>之前</strong>调用,所以使用”<strong>this()</strong>”<strong>调用构造方法</strong>的操作,一定要放在构造方法的<strong>首行</strong>,首行指第一条语句,且在一个构造方法里<strong>只能调用一个</strong>;</p><p>如果一个类之中存在多个构造方法,且这些构造方法都使用了<strong>this()</strong>互相调用,那么至少要保留一个构造方法没有调用其他构造方法,以作为程序的出口。(不能陷入死循环)</p><p><strong>this不能</strong>用在<strong>static</strong>方法中！(java中类的方法池中都有一个隐含的参数<strong>this</strong>,他表示本对象的引用但是<strong>static</strong>方法是没有这个隐含参数的,因为<strong>static</strong>方法和类的实例无关它只在类装载的时候初始化,很多书都把静态变量称作类级变量)</p><h3 id="类的封装">类的封装</h3><p>在设计一个类时,应该对成员变量的访问作出一些<strong>限定</strong>,不允许外界随意访问.这就需要实现类的封装。</p><p>所谓类的封装是指在定义一个类时,将类中的属性<strong>私有化</strong>,即使用 <strong>private</strong>关键字来修饰,私有属性只能在它所在<strong>类中</strong>被访问,如果外界想要访问私有属性,需要使用<strong>公有</strong>方法进行间接调用,其中包括用于获取属性值的 getXxx方法和设置属性值的 setXxx方法。</p><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包子类</th><th>同包非子类</th><th>不同包子类</th><th>不同包且非子类</th></tr></thead><tbody><tr><td>private</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>默认</td><td>是</td><td>是</td><td>是</td><td>否</td><td>否</td></tr><tr><td>protected</td><td>是</td><td>是</td><td>是</td><td>是</td><td>否</td></tr><tr><td>public</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="tostring">tostring()</h3><p><strong>public String toString()</strong>返回该对象的字符串表示。通常,<strong>ToString</strong>方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span>  
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span><span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">Test</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">));</span><span class="c1">//默认调用toString()  </span>
    <span class="o">}</span>  
    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="s">"Test{a="</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="s">", b="</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h3 id="实例方法类方法">实例方法，类方法</h3><p>实例方法就是对象方法,和类方法的区别是,类方法有<strong>static</strong>关键字,<strong>不需要实例</strong>,<strong>直接类名调用</strong>，类属性也是如此。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="c1">//类属性  </span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span><span class="c1">//实例属性  </span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">f1</span><span class="o">(){};</span><span class="c1">//实例方法  </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">f2</span><span class="o">()</span> <span class="o">{}</span><span class="c1">//类方法  </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[]){</span><span class="c1">//类方法  </span>
        <span class="nc">NoteTest</span> <span class="n">noteTest</span><span class="o">=</span><span class="k">new</span> <span class="nc">NoteTest</span><span class="o">();</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">noteTest</span><span class="o">.</span><span class="na">b</span><span class="o">);</span>  
        <span class="n">noteTest</span><span class="o">.</span><span class="na">f1</span><span class="o">();</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">NoteTest</span><span class="o">.</span><span class="na">a</span><span class="o">);</span>  
        <span class="nc">NoteTest</span><span class="o">.</span><span class="na">f2</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>类方法，类属性也可以通过实例调用，但这没有意义。这通常是不推荐的做法，因为类方法和类属性是与类相关联的，而不是与实例相关联的。正确的做法是通过类名直接调用类方法和访问类属性。通过实例调用类方法和类属性可能会造成混淆，不利于代码的清晰性和维护性。</p><p>在代码中，实例对象能访问类字段只是因为编译器可以根据实例类型自动转换为<code class="language-plaintext highlighter-rouge">类名.静态字段</code>来访问静态对象。对于类方法也是如此。</p><p>静态方法（类方法）属于类而不属于实例，因此，静态方法内部，无法访问<code class="language-plaintext highlighter-rouge">this</code>变量，也无法访问实例字段，它只能访问静态字段（类字段/类属性）。</p><h2 id="方法">方法</h2><p><strong>方法</strong>是完成特定功能的、相对独立的程序段。<strong>方法</strong>一旦定义,就可以在不同的程序段中多次调用,故方法可以增强程序结构的清晰度,提高编程效率。在Java程序中,<strong>方法只能在类</strong>中声明,格式如下:</p><blockquote><p><strong>[修饰符] 返回值类型 方法名 [(参数表)]{</strong></p><p><strong>声明部分</strong></p><p><strong>语句部分</strong></p><p><strong>}</strong></p></blockquote><p>方法声明包括方法头和方法体2部分</p><ol><li>修饰符可以是公共访问控制符<strong>public</strong>、私有访冋控制符<strong>private</strong>、保护访问控制符 <strong>protected</strong>等。</li><li>类型标识符反映方法完成其功能后返回的运算结果的数据类型。如果方法<strong>没有返回值</strong>,用<strong>void</strong>关键字指明。</li><li>方法名要符合标识符的命名规则,不要与Java中的关键字<strong>重名</strong>。</li><li>参数表指定在<strong>调用</strong>该方法时,应该传递的参数的个数和数据类型。</li><li>对于<strong>有返回值</strong>的方法,其方法体中至少有一条<code class="language-plaintext highlighter-rouge">return</code>语句。</li><li>对于<strong>没有返回值</strong>的方法，可以用<code class="language-plaintext highlighter-rouge">return;</code>终止执行方法。</li><li>方法声明<strong>不能嵌套</strong>,即不能在方法中再声明其它的方法。</li></ol><p>对于有返回值的方法作为表达式或表达式的一部分来调用,其在表达式中出现的形式为：</p><p><strong>方法名([实际参数表])</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">act</span><span class="o">(){</span>  
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"act() = "</span> <span class="o">+</span> <span class="n">act</span><span class="o">());</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>在调用一个带有<strong>形式参数</strong>的方法时,必须为方法提供<strong>实际参数</strong>,完成实际参数与形式参数的结合,称为参数传递,然后用实际参数执行所调用的方法体。<strong>在Java中</strong>,参数传递是以<strong>传值</strong>的方式进行,即<strong>将实际参数的值传递给形式参数.</strong>同构造方法一样，普通方法也可以进行重载。</p><h3 id="可变参数">可变参数</h3><p>可变参数用<code class="language-plaintext highlighter-rouge">类型...</code>定义，可变参数相当于数组类型。Java中的可变参数（varargs）实际上是一种<strong>语法糖</strong>，编译器会将传递给可变参数的参数<strong>封装成一个数组</strong>，因此可以像处理数组一样处理这些参数。这种语法糖使得方法的调用更加简洁，不再需要手动创建数组来传递参数。</p><p>如果对带有可变参数的方法传入<code class="language-plaintext highlighter-rouge">null</code>，编译器会不知道怎么处理，编译器无法确定应该创建一个空数组还是一个包含一个<code class="language-plaintext highlighter-rouge">null</code>元素的数组。这种情况下，编译器会产生一个警告（warning），提示可能会有<code class="language-plaintext highlighter-rouge">NullPointerException</code>的风险。因此，在使用可变参数时，应该<strong>避免</strong>传入<code class="language-plaintext highlighter-rouge">null</code>。</p><h3 id="递归程序">递归程序</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">test</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>  
        <span class="k">return</span> <span class="nf">test</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)*</span><span class="n">n</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"5! = "</span> <span class="o">+</span> <span class="n">test</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span><span class="c1">//5! = 120  </span>
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h2 id="继承">继承</h2><p>最高层是<strong>最普遍</strong>的、<strong>最一般</strong>的情况,往下每一层都比上一层<strong>更具体</strong>,并包含有高层的特征,通过这样的层次结构使下层的类能自动享用上层类的特点和性质;</p><p>继承其实就是自动地共享被继承类中成员属性和成员方法的机制。</p><p>继承是利用现有的类创建新类的过程,现有的类称作基类(或父类),创建的新类称作派生类(子类)</p><p>在Java中实现继承需要使用到<strong>extends</strong>关键字;</p><blockquote><p><strong>[访问修饰符] class 派生类名 extends 基类名{</strong></p><p><strong>成员列表</strong></p><p><strong>}</strong></p></blockquote><p>如:</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="nc">User</span><span class="o">{}</span>
</code></pre></div></div><p>在Java中，每个类都具有父类。如果一个类没有声明父类，则默认情况下会继承<code class="language-plaintext highlighter-rouge">java.lang.Object</code>。</p><p><strong>严禁定义与父类重名的字段</strong></p><p>在Java中，严禁定义与父类重名的字段是为了避免可能引起的混淆和语义歧义。具体来说，这样的限制主要是为了维护良好的代码可读性和可维护性，避免潜在的错误和困惑。当子类定义了与父类同名的字段时，可能会导致以下问题：</p><ol><li>语义歧义：同名字段可能具有不同的含义，这会使代码的意图变得模糊，增加理解和维护的难度。</li><li>可见性问题：如果子类定义了与父类同名的字段，可能会掩盖父类的字段，导致无法访问父类的字段，从而造成错误或者逻辑混乱。</li><li>潜在的错误：当同名字段在父类和子类中同时存在时，应用继承关系的代码可能会对同名字段产生矛盾的假设，从而引发潜在的错误。</li></ol><p>为了避免上述问题，Java语言规范明确禁止在子类中定义与父类同名的字段。如果子类需要引用父类的字段，应该通过<strong>super</strong>关键字或者在父类中提供合适的访问方法。</p><p>总之，严禁定义与父类重名的字段是为了保证代码的清晰性、可读性和可维护性，以及避免可能引起的混淆和错误。</p><h3 id="继承的作用">继承的作用</h3><ul><li>引入继承,实现了代码重用;</li><li>引入继承,实现了递增式的程序设计。</li><li>继承是能自动传播代码和重用代码的有力工具;</li><li>继承能够在某些比较一般的类的基础上建造、建立和扩充新类;</li><li>能减少代码和数据的重复冗余度,并通过增强一致性来减少模块间的接口和界面,从而增强了程序的可维护性。</li><li>能清晰地体现出类与类之间的层次结构关系。</li></ul><h3 id="继承的限制">继承的限制</h3><p>一个子类只能够继承一个父类,存在<strong>单继承</strong>局限，子类不会继承任何父类的构造方法。</p><p>子类可以获得<strong>除private</strong>权限<strong>以外</strong>的所有父类属性,但是：</p><p>在创建子类的对象时<strong>默认</strong>先执行调用父类的无参构造方法，然后再执行子类自己的<strong>构造方法</strong>。要取消这个默认行为，子类可以在自己的<strong>构造方法</strong>中使用<strong>super</strong>关键字来调用父类的<strong>含参数构造方法</strong>,但这个调用语句<strong>必须</strong>是子类构造方法的<strong>第一个</strong>可执行语句。</p><p>若不显示的进行<strong>super</strong>,则会自动调用<strong>super()</strong>;若此时父类没有<strong>无参构造函数</strong>则会出错.</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Father</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="nf">Father</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"父类带参构造函数"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="nc">Father</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="nf">Son</span><span class="o">()</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span><span class="c1">//必须  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"子类无参构造函数"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h3 id="super">super</h3><ul><li>在<strong>子类的构造方法</strong>中,<strong>super</strong>关键字可以<strong>显式</strong>地调用父类的构造方法,用于将参数传递给它;需要注意的是：<strong>该语句必须是子类构造方法的第一条语句。</strong> 其一般语法是： <code class="language-plaintext highlighter-rouge">super(实际参数);</code></li><li>如果父类和子类中有<strong>同名成员</strong>,在子类中默认访问是属于自己的那一个成员; <strong>super</strong>可以访问父类的<strong>变量</strong>或<strong>方法</strong>，值得注意的是，<code class="language-plaintext highlighter-rouge">super</code>关键字访问的是父类中已经实例化的成员，而<strong>不会影响</strong>到子类中的同名成员。</li></ul><p><strong>super</strong>关键字可以明确地指定要访问父类中的成员;前提条件是：父类中的该成员<strong>不是private</strong>的。</p><p>这种用法中<strong>不需要</strong>像<strong>构造方法</strong>中一样需要限定为第一条语句.</p><p>其一般语法是：</p><blockquote><p><strong>super.成员名;</strong></p><p><strong>super.方法名();</strong></p></blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">uid</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">User</span><span class="o">(</span><span class="nc">String</span> <span class="n">uid</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">uid</span> <span class="o">=</span> <span class="n">uid</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="s">"User{uid='"</span> <span class="o">+</span> <span class="n">uid</span> <span class="o">+</span> <span class="sc">'\\'</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="nc">User</span><span class="o">{</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="nc">String</span> <span class="n">uid</span><span class="o">,</span><span class="nc">String</span> <span class="n">username</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">(</span><span class="n">uid</span><span class="o">);</span><span class="c1">//必须,否则自动调用super(),然后报错  </span>
        <span class="k">this</span><span class="o">.</span><span class="na">username</span><span class="o">=</span><span class="n">username</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>  
        <span class="nc">String</span> <span class="n">s</span><span class="o">=</span><span class="s">""</span><span class="o">;</span>  
        <span class="n">s</span><span class="o">=</span><span class="kd">super</span><span class="o">.</span><span class="na">toString</span><span class="o">()+</span><span class="s">"\nStudent{uid='"</span> <span class="o">+</span> <span class="n">uid</span> <span class="o">+</span> <span class="sc">'\\'</span> <span class="o">+</span> <span class="s">", username='"</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="sc">'\\'</span> <span class="o">+</span> <span class="sc">'}'</span><span class="o">;;</span>  
        <span class="k">return</span> <span class="n">s</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"张三"</span><span class="o">));</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><h3 id="final">final</h3><p><strong>final</strong>修饰符可以修饰类、成员变量和方法。</p><ul><li>对于类，<strong>final</strong>表示该类不能被继承，即它是一个最终类，不能有子类。</li><li>对于方法，<strong>final</strong>表示该方法不能被子类重写，即它是一个最终方法。</li><li>对于变量，<strong>final</strong>表示只能被赋值一次，这意味着一旦被赋值后，就不能再改变它的值。</li></ul><p>当编译器确定一个<strong>方法</strong>是<strong>final</strong>的时候，它会使用内联（inline）机制，将方法调用直接替换为方法体的内容，这样可以避免方法调用的开销，提高执行效率。这种优化是可能的，因为<strong>final</strong>方法是不能被子类重写的，所以在编译时就可以确定调用的是哪个方法。</p><h3 id="阻止继承">阻止继承</h3><p>正常情况下，只要某个class没有<code class="language-plaintext highlighter-rouge">final</code>修饰符，那么任何类都可以从该class继承。</p><p>从<strong>Java 15</strong>开始，允许使用<code class="language-plaintext highlighter-rouge">sealed</code>修饰class，并通过<code class="language-plaintext highlighter-rouge">permits</code>明确写出能够从该class继承的子类名称。例如，定义一个<code class="language-plaintext highlighter-rouge">Shape</code>类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">sealed</span> <span class="kd">class</span> <span class="nc">Shape</span> <span class="n">permits</span> <span class="nc">Rect</span><span class="o">,</span> <span class="nc">Circle</span><span class="o">,</span> <span class="nc">Triangle</span> <span class="o">{}</span>
</code></pre></div></div><p>上述<code class="language-plaintext highlighter-rouge">Shape</code>类就是一个<code class="language-plaintext highlighter-rouge">sealed</code>类，它只允许指定的3个类继承它。这种<code class="language-plaintext highlighter-rouge">sealed</code>类主要用于一些框架，防止继承被滥用。</p><h3 id="构造代码块初始化块静态代码块">构造代码块/初始化块、静态代码块</h3><p>构造代码块和静态代码块的作用是在对象创建和类加载时执行特定的初始化操作，可以用来进行一些必要的预处理或初始化工作。</p><p>构造代码块：</p><ul><li>构造代码块用于在<strong>创建对象时</strong>执行初始化操作。</li><li>构造代码块没有任何修饰符（如 public、private、protected）。</li><li><strong>每次</strong>创建对象时，构造代码块都会被执行，且<strong>优先于</strong>构造方法执行。</li><li>构造代码块中的代码实际上会被自动插入到每个构造方法的<strong>最前面</strong>。</li></ul><p>静态代码块：</p><ul><li>静态代码块用于在<strong>类被加载时</strong>执行初始化操作，<strong>仅执行一次</strong>。</li><li>静态代码块使用 <code class="language-plaintext highlighter-rouge">static</code> 关键字修饰。</li><li>静态代码块在类加载时自动执行，且优先于构造代码块和构造方法执行。</li></ul><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">HelloA</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">HelloA</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"helloA"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"AAA"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"AAA static"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">HelloB</span> <span class="kd">extends</span> <span class="nc">HelloA</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">HelloB</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hellob"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"BBB"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"BBB static"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">HelloB</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>父类静态代码块-&gt;子类静态代码块-&gt;父类构造代码块-&gt;父类构造方法-&gt;子类构造代码块-&gt;子类构造方法</p><p>在Java中，类的初始化过程如下：</p><ol><li>加载：查找并加载类的字节码文件，创建一个 <code class="language-plaintext highlighter-rouge">Class</code> 对象。</li><li>连接：<ul><li>验证：确保字节码文件的正确性。</li><li>准备：为类的静态变量分配内存，并设置默认初始值。</li><li>解析：将符号引用转换为直接引用。</li></ul></li><li>初始化：<ul><li>执行类的静态代码块和静态字段的赋值操作。</li><li>如果有父类，先初始化父类。</li></ul></li></ol><p>在实例化对象时，会先初始化类。初始化类的过程包括执行静态代码块和静态字段的赋值操作。然后执行构造方法。</p><p><code class="language-plaintext highlighter-rouge">HelloA</code>和<code class="language-plaintext highlighter-rouge">HelloB</code>都有静态代码块和构造代码块，按照上面的顺序执行会是这样的：</p><ol><li>加载<code class="language-plaintext highlighter-rouge">HelloA</code>类和<code class="language-plaintext highlighter-rouge">HelloB</code>类。</li><li>连接：<ul><li>验证、准备、解析。</li></ul></li><li>初始化<code class="language-plaintext highlighter-rouge">HelloA</code>类：<ul><li>执行<code class="language-plaintext highlighter-rouge">HelloA</code>类的静态代码块和静态字段的赋值操作。</li></ul></li><li>初始化<code class="language-plaintext highlighter-rouge">HelloB</code>类：<ul><li>执行<code class="language-plaintext highlighter-rouge">HelloB</code>类的静态代码块和静态字段的赋值操作。</li></ul></li><li>创建<code class="language-plaintext highlighter-rouge">HelloB</code>对象：<ul><li>执行<code class="language-plaintext highlighter-rouge">HelloA</code>的构造代码块和构造方法。</li><li>执行<code class="language-plaintext highlighter-rouge">HelloB</code>的构造代码块和构造方法。</li></ul></li></ol><p>因此，最终的输出顺序是：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AAA static
BBB static
AAA
helloA
BBB
Hellob
</code></pre></div></div><h2 id="多态">多态</h2><p>多态是面向对象的最后一个主要特征,它本身主要分为两个方面：</p><p>方法的多态性：<strong>重载</strong>与<strong>覆写</strong></p><ul><li><strong>重载</strong>：同一个方法名称,根据不同的参数类型及个数可以完成不同的功能;</li><li><strong>覆写</strong>：同一个方法,根据操作的子类不同,所完成的功能也不同。</li></ul><p>对象的多态性：父子类对象的转换。</p><ul><li><strong>向上转型</strong>：子类对象变为父类对象,格式：<strong>父类 父类对象=子类实例</strong>,自动;</li><li><strong>向下转型</strong>：父类对象变为子类对象,格式：<strong>子类 子类对象=(子类)父类实例</strong>,强制;</li></ul><p><strong>向上转型、向下转型</strong></p><p>向上转型是将子类的实例赋值给父类的引用变量，通过父类引用来访问子类对象。子类在向上转型为父类后，只能使用父类中定义过的方法和属性，而无法直接使用子类特有的方法和属性。</p><p>在向上转型后，如果需要重新使用子类特有的方法和属性，需要进行向下转型。向下转型是将父类的引用变量重新指向子类对象，并将其类型更改为子类类型，可以使用子类特有的方法和属性。</p><p>在向下转型的时候，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code class="language-plaintext highlighter-rouge">ClassCastException</code>。</p><p>向上转型是编译时的概念，因为编译器只会检查类型是否匹配。在运行时，Java会自动调用实际对象的方法，即实现了向上转型的多态特性。</p><p>为了避免向下转型出错，Java提供了<code class="language-plaintext highlighter-rouge">instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型。<code class="language-plaintext highlighter-rouge">instanceof</code>实际上判断一个变量所指向的实例是否是<strong>指定类型</strong>，或者这个类型的<strong>子类</strong>。如果一个引用变量为<code class="language-plaintext highlighter-rouge">null</code>，那么对任何<code class="language-plaintext highlighter-rouge">instanceof</code>的判断都为<code class="language-plaintext highlighter-rouge">false</code>。</p><p>从<strong>Java 14</strong>开始，判断<code class="language-plaintext highlighter-rouge">instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">obj</span><span class="o">;</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><p>可以改写如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="s">"hello"</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="k">instanceof</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 可以直接使用变量s:</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div><p>这种使用<code class="language-plaintext highlighter-rouge">instanceof</code>的写法更加简洁。</p><p><strong>方法覆盖（重写/覆写）</strong></p><p>在类的继承体系结构中,如果子类中出现了与父类中<strong>相同</strong>原型的方法,那么认为子类中的方法<strong>覆盖</strong>了父类中的方法(也称为方法重写);通过<strong>子类</strong>的实例调用被覆盖的方法时,将<strong>总是调用子类中的方法</strong>,而父类中的方法将被<strong>隐藏</strong>。这是因为在运行时，Java 虚拟机会动态地确定对象的实际类型，并调用该实际类型中的方法。这种行为称为动态方法调度（Dynamic Method Dispatch）。 加上<code class="language-plaintext highlighter-rouge">@Override</code>可以让编译器帮助检查是否进行了<strong>正确的覆盖</strong> 。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span><span class="c1">//用于容纳main方法  </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>  
        <span class="nc">ParentClass</span> <span class="n">parobj</span><span class="o">=</span><span class="k">new</span> <span class="nc">ParentClass</span><span class="o">();</span>  
        <span class="n">parobj</span><span class="o">.</span><span class="na">fun</span><span class="o">();</span><span class="c1">//父类的实例调用此方法  </span>
        <span class="nc">ChildClass</span> <span class="n">chiobj</span><span class="o">=</span><span class="k">new</span> <span class="nc">ChildClass</span><span class="o">();</span>  
        <span class="n">chiobj</span><span class="o">.</span><span class="na">fun</span><span class="o">();</span><span class="c1">//子类的实例调用此方法  </span>
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">ParentClass</span><span class="o">{</span><span class="c1">//定义父类  </span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fun</span><span class="o">(){</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是父类中的方法。"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">ChildClass</span> <span class="kd">extends</span> <span class="nc">ParentClass</span> <span class="o">{</span><span class="c1">//子类继承于父类  </span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">fun</span><span class="o">(){</span><span class="c1">//子类覆盖父类中的方法  </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是子类中的方法。"</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p><strong>区分方法覆盖和方法重载</strong></p><p>方法覆盖(重写)和方法重载是两个极易混淆的概念,必须严格区分;</p><p>方法覆盖出现的前提条件之一是<strong>必须有继承</strong>发生的情况下,而且要求父类和子类中的方法<strong>必须同原型</strong>;</p><p>方法重载时,继承并不是必需的,它<strong>只要求方法名称相同</strong>,而参数列表则<strong>必须不同</strong>,换言之,各方法的<strong>原型</strong>其实是<strong>不同</strong>的。</p><p>父类的引用指向哪个类的实例就调用哪个类中的方法;同样是使用父类的引用,调用同一个名称的方法,却可以得到不同的调用结果，这就是多态。即：同一方法,多种形态;实际上多态包括<strong>动态多态</strong>和<strong>静态多态</strong>。</p><ul><li>静态多态也称为编译时多态,即在编译时决定调用哪个方法; 静态多态一般是指<strong>方法重载</strong>; 只要构成了方法重载,就可以认为形成了静态多态的条件; 静态多态与是否发生继承没有必然联系。</li><li>动态多态也称为运行时多态,即在运行时才能确定调用哪个方法;形成动态多态<strong>必须要有继承</strong>的情况存在;在继承中必须要有<strong>方法覆盖</strong>;必须由基类的引用指向派生类的实例,并且通过基类的引用调用被覆盖的方法;</li></ul><p>方法签名指的是一个方法的名称、参数列表以及参数类型的组合。它用于区分相同名称但参数不同的方法，是方法重载的重要依据。方法签名包括方法名、参数类型和参数数目，不包括方法的返回值类型。例如，以下是一个方法的签名： <code class="language-plaintext highlighter-rouge">public void printArray(int[] arr)</code> ，方法名为<code class="language-plaintext highlighter-rouge">printArray</code>，参数类型为<code class="language-plaintext highlighter-rouge">int[]</code>，参数数目为<code class="language-plaintext highlighter-rouge">1</code>，没有返回值类型。</p><p>实例 ：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">Person</span> <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">"小张"</span><span class="o">,</span> <span class="mi">18</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getPerson</span><span class="o">());</span>  
        <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">Student</span><span class="o">(</span><span class="s">"小李"</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span><span class="s">"中国工学院"</span><span class="o">,</span><span class="s">"一年级"</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getPerson</span><span class="o">());</span>  
        <span class="n">p</span><span class="o">=</span><span class="k">new</span> <span class="nc">GraduateStudent</span><span class="o">(</span><span class="s">"小花"</span><span class="o">,</span> <span class="mi">22</span><span class="o">,</span><span class="s">"中国工学院"</span><span class="o">,</span><span class="s">"一年级"</span><span class="o">,</span><span class="s">"李"</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getPerson</span><span class="o">());</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Person</span><span class="o">{</span>  
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>  
    <span class="kd">protected</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Person</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">();</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPerson</span><span class="o">(){</span>  
        <span class="k">return</span> <span class="s">"姓名:"</span><span class="o">+</span><span class="n">name</span><span class="o">+</span><span class="s">" 年龄:"</span><span class="o">+</span><span class="n">age</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Student</span> <span class="kd">extends</span> <span class="nc">Person</span><span class="o">{</span>  
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">school</span><span class="o">;</span>  
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">grade</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">school</span><span class="o">,</span> <span class="nc">String</span> <span class="n">grade</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">);</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">school</span> <span class="o">=</span> <span class="n">school</span><span class="o">;</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">grade</span> <span class="o">=</span> <span class="n">grade</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPerson</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getPerson</span><span class="o">()+</span><span class="s">" 学校:"</span><span class="o">+</span><span class="n">school</span><span class="o">+</span><span class="s">" 班级:"</span><span class="o">+</span><span class="n">age</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">GraduateStudent</span> <span class="kd">extends</span> <span class="nc">Student</span><span class="o">{</span>  
    <span class="kd">protected</span> <span class="nc">String</span> <span class="n">mentor</span><span class="o">;</span>  
    <span class="kd">public</span> <span class="nf">GraduateStudent</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">,</span> <span class="nc">String</span> <span class="n">school</span><span class="o">,</span> <span class="nc">String</span> <span class="n">grade</span><span class="o">,</span> <span class="nc">String</span> <span class="n">mentor</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">,</span> <span class="n">school</span><span class="o">,</span> <span class="n">grade</span><span class="o">);</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">mentor</span> <span class="o">=</span> <span class="n">mentor</span><span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPerson</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getPerson</span><span class="o">()+</span><span class="s">" 导师:"</span><span class="o">+</span><span class="n">mentor</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><p>输出:</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>姓名:小张 年龄:18
姓名:小李 年龄:20 学校:中国工学院 班级:20
姓名:小花 年龄:22 学校:中国工学院 班级:22 导师:李
</code></pre></div></div><h2 id="抽象类">抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>把一个方法声明为<code class="language-plaintext highlighter-rouge">abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code class="language-plaintext highlighter-rouge">Person</code>类也无法被实例化。<strong>必须</strong>把<code class="language-plaintext highlighter-rouge">Person</code>类本身也声明为<code class="language-plaintext highlighter-rouge">abstract</code>，才能正确编译它：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>抽象类不能被实例化，但抽象类中可以定义非抽象方法，用以为子类提供默认的实现。</p><p>子类继承抽象类后，如果不是抽象类，则必须实现抽象类中的所有抽象方法，否则子类也必须定义为抽象类。因此，抽象方法实际上相当于定义了“规范”，让子类实现自己的逻辑，从而实现多态性。</p><p><strong>使用抽象类数组（new I[]并不是实例化，而是数组特定写法）</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Abst</span><span class="o">[]</span> <span class="n">absts</span><span class="o">=</span><span class="k">new</span> <span class="nc">Abst</span><span class="o">[]{</span><span class="k">new</span> <span class="no">A</span><span class="o">(),</span><span class="k">new</span> <span class="no">A</span><span class="o">()};</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Abst</span><span class="o">{</span> <span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="kd">extends</span> <span class="nc">Abst</span><span class="o">{}</span>
</code></pre></div></div><p>实际上就是（参见<a href="#数组">数组简写</a>）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">A</span> <span class="n">a1</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="no">A</span> <span class="n">a2</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="nc">Abst</span><span class="o">[]</span> <span class="n">absts</span><span class="o">={</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">};</span>
</code></pre></div></div><h2 id="接口">接口</h2><p>接口关键字:<strong>interface</strong></p><p>如果某个类中的所有方法<strong>都是</strong>抽象方法,那么可以考虑将该类定义为接口;</p><p>Java中的接口是一个特殊的抽象类,可以利用接口实现多态,同时接口也弥补了Java单一继承的弱点。一般便用接口声明<strong>方法或常量</strong>,接口中的方法<strong>只能</strong>是声明,<strong>不能是具体的实现</strong>。</p><p>接口就是某个事物对外提供的一些功能的<strong>申明</strong></p><p>语法格式如下:</p><blockquote><p><strong>[修饰符] interface 接口名[extends父接口名列表]{</strong></p><p><strong>[public] [static] [final]常量;</strong></p><p><strong>[public] [abstract]方法;</strong></p><p><strong>}</strong></p></blockquote><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>修饰符</td><td>可选,指定接口的访问权限,可选值为<strong>public</strong>。</td></tr><tr><td>接口名</td><td>必选,用于指定接口的名称,一般情况下,要求首字母大写。</td></tr><tr><td><strong>extends</strong>父接口名列表</td><td>可选,用于继承哪些接口，可继承多个。</td></tr><tr><td>方法</td><td>接口中的方法<strong>只有定义</strong>而没有被实现。</td></tr></tbody></table><p>接口定义的所有方法默认都是<code class="language-plaintext highlighter-rouge">public abstract</code>的，而所有变量也都是<code class="language-plaintext highlighter-rouge">public static final</code>的。</p><p>与抽象类相似,接口同样<strong>不可以</strong>实例化,只能用于实现;如果某类要<strong>实现接口</strong>,则使用<strong>implements</strong>关键字. <strong>[访问权限]class类名implements接口名{ 成员列表｝</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClass</span> <span class="kd">implements</span> <span class="nc">IMyInterface</span> <span class="o">{}</span>
</code></pre></div></div><p>一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code class="language-plaintext highlighter-rouge">interface</code>，如果有一个以上接口被实现,则用<strong>逗号</strong>隔开接口名称,如下所示;</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">demo</span> <span class="kd">implements</span> <span class="n">myinterface</span><span class="o">,</span><span class="n">myconstants</span><span class="o">{}</span>
</code></pre></div></div><p>接口调用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd.test</span><span class="o">;</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NoteTest</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
        <span class="nc">ICalc</span> <span class="nc">ICalc4</span> <span class="o">=</span><span class="k">new</span> <span class="nc">Calc</span><span class="o">();</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">ICalc4</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">));</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
<span class="kd">interface</span> <span class="nc">ICalc</span> <span class="o">{</span>  
    <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>  
    <span class="kt">int</span> <span class="nf">sub</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">);</span>  
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">Calc</span> <span class="kd">implements</span> <span class="nc">ICalc</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">;</span> <span class="o">}</span>  
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">sub</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="o">;</span> <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div></div><hr /><p><strong>default</strong></p><p><code class="language-plaintext highlighter-rouge">default</code>方法是<strong>Java 8</strong>引入的接口新特性之一，它允许在接口中定义具有默认实现的方法。在接口中使用<code class="language-plaintext highlighter-rouge">default</code>关键字修饰的方法可以在接口中<strong>直接实现</strong>，而不需要实现类去实现这个方法。这样的好处是可以向现有的接口添加新的方法，而不会影响到已有的实现类，因为它们可以选择性地覆盖默认实现。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">eat</span><span class="o">();</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Animal sleeps"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Dog eats"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>   <span class="c1">// Output: Dog eats</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span> <span class="c1">// Output: Animal sleeps</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>需要注意的是，如果一个类实现了多个接口，而这些接口中有<strong>相同签名</strong>的<code class="language-plaintext highlighter-rouge">default</code>方法，那么实现类<strong>必须覆盖</strong>这个方法并<strong>明确指定</strong>调用哪个接口的方法。</p><p>一个接口可以定义多个<code class="language-plaintext highlighter-rouge">default</code>方法。在实现类中，如果要调用<strong>特定</strong>接口的<code class="language-plaintext highlighter-rouge">default</code>方法，可以使用<code class="language-plaintext highlighter-rouge">接口名.super.方法名()</code>的语法来指定调用哪个接口的方法。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Animal eats"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Animal sleeps"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Pet</span> <span class="o">{</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Pet plays"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">implements</span> <span class="nc">Animal</span><span class="o">,</span> <span class="nc">Pet</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">eat</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Animal</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span> <span class="c1">// 调用Animal接口的eat方法</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Animal</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span> <span class="c1">// 调用Animal接口的sleep方法</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">play</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Pet</span><span class="o">.</span><span class="na">super</span><span class="o">.</span><span class="na">play</span><span class="o">();</span> <span class="c1">// 调用Pet接口的play方法</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Dog</span> <span class="n">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">();</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">eat</span><span class="o">();</span>   <span class="c1">// Output: Animal eats</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">sleep</span><span class="o">();</span> <span class="c1">// Output: Animal sleeps</span>
        <span class="n">dog</span><span class="o">.</span><span class="na">play</span><span class="o">();</span>  <span class="c1">// Output: Pet plays</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>接口中的默认方法（default method）<strong>可以调用接口中的抽象方法</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">I</span> <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
        <span class="n">i</span><span class="o">.</span><span class="na">out</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">hi</span><span class="o">();</span>
    <span class="k">default</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">(){</span><span class="n">hi</span><span class="o">();}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">hi</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"测试"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p><strong>使用接口数组（new I[]并不是实例化，而是数组特定写法）</strong>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">I</span><span class="o">[]</span> <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">I</span><span class="o">[]{</span><span class="k">new</span> <span class="no">A</span><span class="o">(),</span><span class="k">new</span> <span class="no">A</span><span class="o">()};</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{}</span>
<span class="kd">class</span> <span class="nc">A</span> <span class="kd">implements</span> <span class="no">I</span><span class="o">{}</span>
</code></pre></div></div><p>实际上就是（参见<a href="#数组">数组简写</a>）：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">A</span> <span class="n">a1</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="no">A</span> <span class="n">a2</span><span class="o">=</span><span class="k">new</span> <span class="no">A</span><span class="o">();</span>
<span class="no">I</span><span class="o">[]</span> <span class="n">i</span><span class="o">={</span><span class="n">a1</span><span class="o">,</span><span class="n">a2</span><span class="o">};</span>
</code></pre></div></div><p><strong>抽象类与接口的异同</strong></p><table><thead><tr><th style="text-align: left">异同点</th><th style="text-align: left">abstract class</th><th>interface</th></tr></thead><tbody><tr><td style="text-align: left">实例化</td><td style="text-align: left">不能</td><td>不能</td></tr><tr><td style="text-align: left">构造方法</td><td style="text-align: left">可以，为了让子类调用并完成初始化</td><td>不能</td></tr><tr><td style="text-align: left">初始化块</td><td style="text-align: left">可以</td><td>不能，接口中只有常量，不需要。</td></tr><tr><td style="text-align: left">继承</td><td style="text-align: left">只能继承抽象类，使用：<code class="language-plaintext highlighter-rouge">extends</code></td><td>只能继承接口，使用：<code class="language-plaintext highlighter-rouge">extends</code></td></tr><tr><td style="text-align: left">被继承</td><td style="text-align: left">只能<code class="language-plaintext highlighter-rouge">extends</code>一个抽象类</td><td>可以<code class="language-plaintext highlighter-rouge">implements</code>多个接口</td></tr><tr><td style="text-align: left">字段</td><td style="text-align: left">可以</td><td><strong>只能</strong>定义<strong>静态常量属性</strong>，即只读</td></tr><tr><td style="text-align: left">抽象方法</td><td style="text-align: left">可以定义</td><td>可以定义</td></tr><tr><td style="text-align: left">非抽象方法</td><td style="text-align: left"><strong>可以</strong>包含普通方法，静态方法</td><td>可以定义default方法</td></tr></tbody></table><h2 id="内部类">内部类</h2><h3 id="内部类-1">内部类</h3><p>有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。</p><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Outer</span><span class="o">.</span><span class="na">Inner</span> <span class="n">inner</span><span class="o">=</span><span class="k">new</span> <span class="nc">Outer</span><span class="o">().</span><span class="na">new</span> <span class="nc">Inner</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Outer</span> <span class="o">{</span>
    <span class="kd">class</span> <span class="nc">Inner</span> <span class="o">{</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"已实例化"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>上述定义的<code class="language-plaintext highlighter-rouge">Outer</code>是一个普通类，而<code class="language-plaintext highlighter-rouge">Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。</p><p>要实例化一个<code class="language-plaintext highlighter-rouge">Inner</code>，必须首先创建一个<code class="language-plaintext highlighter-rouge">Outer</code>的实例，然后，调用<code class="language-plaintext highlighter-rouge">Outer</code>实例的<code class="language-plaintext highlighter-rouge">new</code>来创建<code class="language-plaintext highlighter-rouge">Inner</code>实例。这是因为Inner Class除了有一个<code class="language-plaintext highlighter-rouge">this</code>指向它自己，还<strong>隐含</strong>地持有一个Outer Class实例，可以用<code class="language-plaintext highlighter-rouge">Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p><p>如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问外部类<code class="language-plaintext highlighter-rouge">private</code>的权限。</p><p>包含内部类的外部类，在这个外部类里面，也可以使用内部类本身<code class="language-plaintext highlighter-rouge">private</code>的字段。</p><p>观察Java编译器编译后的<code class="language-plaintext highlighter-rouge">.class</code>文件可以发现，<code class="language-plaintext highlighter-rouge">Outer</code>类被编译为<code class="language-plaintext highlighter-rouge">Outer.class</code>，而<code class="language-plaintext highlighter-rouge">Inner</code>类被编译为<code class="language-plaintext highlighter-rouge">Outer$Inner.class</code>。</p><p>非静态内部类<strong>不能</strong>有静态成员变量，因为非静态内部类的实例是依赖于外部类实例存在的，而静态成员变量是不依赖于实例存在的。如果非静态内部类有静态成员变量，会导致内部类的实例和外部类实例之间产生不一致。</p><h3 id="匿名类">匿名类</h3><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Outer</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Outer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Outer</span><span class="o">()</span> <span class="o">{</span>
        <span class="no">I</span> <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="no">I</span><span class="o">(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">out</span><span class="o">()</span> <span class="o">{</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"匿名类"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">};</span>
        <span class="n">i</span><span class="o">.</span><span class="na">out</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">I</span><span class="o">{</span>
    <span class="kt">void</span> <span class="nf">out</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>我们在方法内部实例化了一个<code class="language-plaintext highlighter-rouge">I</code>。<code class="language-plaintext highlighter-rouge">I</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code class="language-plaintext highlighter-rouge">I</code>接口的匿名类，并且通过<code class="language-plaintext highlighter-rouge">new</code>实例化该匿名类，然后转型为<code class="language-plaintext highlighter-rouge">I</code>。</p><p>如果匿名类实现的接口只有一个方法，则可以用lamda表达式来简化代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">I</span> <span class="n">i</span><span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"匿名类"</span><span class="o">);</span>
<span class="n">i</span><span class="o">.</span><span class="na">out</span><span class="o">();</span>
</code></pre></div></div><p>匿名类和Inner Class一样，可以访问Outer Class的<code class="language-plaintext highlighter-rouge">private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p><p>观察Java编译器编译后的<code class="language-plaintext highlighter-rouge">.class</code>文件可以发现，<code class="language-plaintext highlighter-rouge">Outer</code>类被编译为<code class="language-plaintext highlighter-rouge">Outer.class</code>，而匿名类被编译为<code class="language-plaintext highlighter-rouge">Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code class="language-plaintext highlighter-rouge">Outer$1</code>、<code class="language-plaintext highlighter-rouge">Outer$2</code>、<code class="language-plaintext highlighter-rouge">Outer$3</code>……</p><p>除了接口外，匿名类也完全可以继承自普通类。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;()</span> <span class="o">{};</span> <span class="c1">// 匿名类!</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">map3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span><span class="c1">// 匿名类!</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">out</span><span class="o">(){</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">{</span>
        <span class="n">put</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"1"</span><span class="o">);</span>
        <span class="n">put</span><span class="o">(</span><span class="s">"B"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">map3</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"A"</span><span class="o">));</span>
</code></pre></div></div><p>匿名类是一种在使用过程中直接定义类的方式，适合于创建一次性的、不需要重复使用的类。在使用匿名类时，有几个要注意的地方：</p><ol><li><strong>作用域</strong>：匿名类的作用域只在定义的地方，超出该作用域就无法再次使用。</li><li><strong>继承与实现</strong>：可以继承一个类，也可以实现一个接口，但不能同时做到。在匿名类中可以重写父类的方法或实现接口的方法。</li><li><strong>访问权限</strong>：匿名类可以访问外部类的成员变量和方法，但是外部类不能直接访问匿名类的成员变量和方法。</li><li><strong>初始化块</strong>：可以在匿名类中使用初始化块来进行一些初始化操作，类似于构造方法，但并不是真正的构造方法，匿名类没有显式的构造方法。</li><li><strong>变量捕获</strong>：如果在匿名类中使用了外部的变量，该变量必须是<code class="language-plaintext highlighter-rouge">final</code>或者是事实上的<code class="language-plaintext highlighter-rouge">final</code>（即在初始化后不再改变），否则编译会报错。</li></ol><p>非静态内部类<strong>不能</strong>有静态成员变量，因为非静态内部类的实例是依赖于外部类实例存在的，而静态成员变量是不依赖于实例存在的。如果非静态内部类有静态成员变量，会导致内部类的实例和外部类实例之间产生不一致。</p><h3 id="静态内部类">静态内部类</h3><p>顾名思义，就是内部内加上<code class="language-plaintext highlighter-rouge">static</code>，既然有类方法，类字段，那么这个就叫类类吧，既然有实例方法,实例字段,那么不带<code class="language-plaintext highlighter-rouge">static</code>的就叫实例类。</p><p>用<code class="language-plaintext highlighter-rouge">static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code class="language-plaintext highlighter-rouge">Outer</code>的实例，而是一个完全独立的类，因此无法引用<code class="language-plaintext highlighter-rouge">Outer.this</code>，但它可以访问<code class="language-plaintext highlighter-rouge">Outer</code>的<code class="language-plaintext highlighter-rouge">private</code><strong>静态</strong>字段和<strong>静态</strong>方法。如果把<code class="language-plaintext highlighter-rouge">StaticNested</code>移到<code class="language-plaintext highlighter-rouge">Outer</code>之外，就失去了访问<code class="language-plaintext highlighter-rouge">private</code>的权限。</p><h2 id="编译和运行">编译和运行</h2><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">javac</span> <span class="na">-d </span><span class="o">&lt;</span> <span class="kd">destination</span> <span class="kd">directory</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="kd">java</span> <span class="kd">files</span><span class="o">&gt;</span>
</code></pre></div></div><p>将编译java文件得到的class 文件输出到指定目录 <code class="language-plaintext highlighter-rouge">destination directory</code>， 如果java 文件属于某个包<code class="language-plaintext highlighter-rouge">com.hello</code>，则会自动生成包名对应的文件目录 <code class="language-plaintext highlighter-rouge">com/hello</code>，如：<strong>javac –d . Demo.java</strong></p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">java</span> <span class="na">-cp  </span><span class="kd">or</span> <span class="na">-classpath </span><span class="o">&lt;</span><span class="kd">class</span> <span class="kd">file</span> <span class="nb">path</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="kd">class</span> <span class="kd">name</span><span class="o">&gt;</span>
</code></pre></div></div><p>明确指出用户的类库路径，覆盖环境变量获得的<strong>CLASSPATH</strong>，如果不通过-cp 设置 <strong>CLASSPATH</strong>，当前目录默认为用户的类库路径，此时如果<strong>class</strong>文件包含在当前目录子文件中，同样会报<strong>ClassNotFoundException</strong> 。如：<strong>java -cp 绝对路径 com.Test</strong></p><p>指定编码：<strong>javac -encoding UTF-8</strong></p><p>Java 11新增功能，可以直接运行一个<strong>单文件</strong>源码：<code class="language-plaintext highlighter-rouge">java Hello.java</code></p><p>假设我们创建了如下的目录结构：</p><pre><code class="language-ascii">work
├── bin
└── src
    └── com
        └── itranswarp
            ├── sample
            │   └── Main.java
            └── world
                └── Person.java
</code></pre><p>其中，<code class="language-plaintext highlighter-rouge">bin</code>目录用于存放编译后的<code class="language-plaintext highlighter-rouge">class</code>文件，<code class="language-plaintext highlighter-rouge">src</code>目录按包结构存放Java源码，我们怎么一次性编译这些Java源码呢？首先，确保当前目录是<code class="language-plaintext highlighter-rouge">work</code>目录然后，编译<code class="language-plaintext highlighter-rouge">src</code>目录下的所有Java文件：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ <span class="kd">javac</span> <span class="na">-d </span>./bin <span class="kd">src</span>/<span class="o">**</span>/<span class="o">*</span>.java
</code></pre></div></div><p>命令行<code class="language-plaintext highlighter-rouge">-d</code>指定输出的<code class="language-plaintext highlighter-rouge">class</code>文件存放<code class="language-plaintext highlighter-rouge">bin</code>目录，后面的参数<code class="language-plaintext highlighter-rouge">src/**/*.java</code>表示<code class="language-plaintext highlighter-rouge">src</code>目录下的所有<code class="language-plaintext highlighter-rouge">.java</code>文件，包括任意深度的子目录。</p><p>注意：Windows不支持<code class="language-plaintext highlighter-rouge">**</code>这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有<code class="language-plaintext highlighter-rouge">.java</code>文件：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">C</span>:\work&gt; <span class="kd">javac</span> <span class="na">-d </span><span class="kd">bin</span> <span class="kd">src</span>\com\itranswarp\sample\Main.java <span class="kd">src</span>\com\itranswarp\world\Persion.java
</code></pre></div></div><p>如果编译无误，则<code class="language-plaintext highlighter-rouge">javac</code>命令没有任何输出。可以在<code class="language-plaintext highlighter-rouge">bin</code>目录下看到如下<code class="language-plaintext highlighter-rouge">class</code>文件：</p><pre><code class="language-ascii">bin
└── com
    └── itranswarp
        ├── sample
        │   └── Main.class
        └── world
            └── Person.class
</code></pre><p>现在，我们就可以直接运行<code class="language-plaintext highlighter-rouge">class</code>文件了。根据当前目录的位置确定classpath，例如，当前目录仍为<code class="language-plaintext highlighter-rouge">work</code>，则classpath为<code class="language-plaintext highlighter-rouge">bin</code>或者<code class="language-plaintext highlighter-rouge">./bin</code>：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ <span class="kd">java</span> <span class="na">-cp </span><span class="kd">bin</span> <span class="kd">com</span>.itranswarp.sample.Main 
<span class="kd">Hello</span><span class="o">,</span> <span class="kd">world</span><span class="err">!</span>
</code></pre></div></div><h3 id="classpath">classpath</h3><p><code class="language-plaintext highlighter-rouge">classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code class="language-plaintext highlighter-rouge">class</code>。</p><p>因为Java是编译型语言，源码文件是<code class="language-plaintext highlighter-rouge">.java</code>，而编译后的<code class="language-plaintext highlighter-rouge">.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code class="language-plaintext highlighter-rouge">abc.xyz.Hello</code>的类，应该去哪搜索对应的<code class="language-plaintext highlighter-rouge">Hello.class</code>文件。</p><p>所以，<code class="language-plaintext highlighter-rouge">classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code class="language-plaintext highlighter-rouge">;</code>分隔，带空格的目录用<code class="language-plaintext highlighter-rouge">""</code>括起来，可能长这样：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">C</span>:\work\project1\bin<span class="o">;</span><span class="kd">C</span>:\shared<span class="o">;</span><span class="s2">"D:\My Documents\project1\bin"</span>
</code></pre></div></div><p>在Linux系统上，用<code class="language-plaintext highlighter-rouge">:</code>分隔，可能长这样：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">/usr/shared</span>:/usr/local/bin:/home/liaoxuefeng/bin
</code></pre></div></div><p>现在我们假设<code class="language-plaintext highlighter-rouge">classpath</code>是<code class="language-plaintext highlighter-rouge">.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code class="language-plaintext highlighter-rouge">abc.xyz.Hello</code>这个类时，会依次查找：</p><ul><li> <当前目录>\abc\xyz\Hello.class </当前目录></li><li>C:\work\project1\bin\abc\xyz\Hello.class</li><li>C:\shared\abc\xyz\Hello.class</li></ul><p>注意到<code class="language-plaintext highlighter-rouge">.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code class="language-plaintext highlighter-rouge">class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p><p><code class="language-plaintext highlighter-rouge">classpath</code>的设定方法有两种：</p><ul><li>在系统环境变量中设置<code class="language-plaintext highlighter-rouge">classpath</code>环境变量，不推荐；强烈不推荐在系统环境变量中设置<code class="language-plaintext highlighter-rouge">classpath</code>，那样会污染整个系统环境。</li><li>在启动JVM时设置<code class="language-plaintext highlighter-rouge">classpath</code>变量，推荐。</li></ul><p>在启动JVM时设置<code class="language-plaintext highlighter-rouge">classpath</code>才是推荐的做法。实际上就是给<code class="language-plaintext highlighter-rouge">java</code>命令传入<code class="language-plaintext highlighter-rouge">-classpath</code>或<code class="language-plaintext highlighter-rouge">-cp</code>参数：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="na">-classpath </span>.<span class="o">;</span><span class="kd">C</span>:\work\project1\bin<span class="o">;</span><span class="kd">C</span>:\shared <span class="kd">abc</span>.xyz.Hello
</code></pre></div></div><p>或者使用<code class="language-plaintext highlighter-rouge">-cp</code>的简写：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="na">-cp </span>.<span class="o">;</span><span class="kd">C</span>:\work\project1\bin<span class="o">;</span><span class="kd">C</span>:\shared <span class="kd">abc</span>.xyz.Hello
</code></pre></div></div><p>没有设置系统环境变量，也没有传入<code class="language-plaintext highlighter-rouge">-cp</code>参数，那么JVM<strong>默认</strong>的<code class="language-plaintext highlighter-rouge">classpath</code>为<code class="language-plaintext highlighter-rouge">.</code>，即当前目录：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="kd">abc</span>.xyz.Hello
</code></pre></div></div><p>上述命令告诉JVM只在当前目录搜索<code class="language-plaintext highlighter-rouge">Hello.class</code>。</p><p>在IDE中运行Java程序，IDE自动传入的<code class="language-plaintext highlighter-rouge">-cp</code>参数是当前工程的<code class="language-plaintext highlighter-rouge">bin</code>目录和引入的jar包。</p><p>通常，我们在自己编写的<code class="language-plaintext highlighter-rouge">class</code>中，会引用Java核心库的<code class="language-plaintext highlighter-rouge">class</code>，例如，<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">ArrayList</code>等。不需要告诉JVM如何去Java核心库查找<code class="language-plaintext highlighter-rouge">class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？不要把任何Java核心库添加到classpath中。默认的当前目录<code class="language-plaintext highlighter-rouge">.</code>对于绝大多数情况都够用了。</p><p>假设我们有一个编译后的<code class="language-plaintext highlighter-rouge">Hello.class</code>，它的包名是<code class="language-plaintext highlighter-rouge">com.example</code>，当前目录是<code class="language-plaintext highlighter-rouge">C:\work</code>，那么，目录结构必须如下：</p><pre><code class="language-ascii">C:\work
└─ com
   └─ example
      └─ Hello.class
</code></pre><p>运行这个<code class="language-plaintext highlighter-rouge">Hello.class</code>必须在当前目录下使用如下命令：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">C</span>:\work&gt; <span class="kd">java</span> <span class="na">-cp </span>. <span class="kd">com</span>.example.Hello
</code></pre></div></div><p>JVM根据classpath设置的<code class="language-plaintext highlighter-rouge">.</code>在当前目录下查找<code class="language-plaintext highlighter-rouge">com.example.Hello</code>，即实际搜索文件必须位于<code class="language-plaintext highlighter-rouge">com/example/Hello.class</code>。如果指定的<code class="language-plaintext highlighter-rouge">.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p><h3 id="jar包">jar包</h3><p>如果有很多<code class="language-plaintext highlighter-rouge">.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>jar包就是用来干这个事的，它可以把<code class="language-plaintext highlighter-rouge">package</code>组织的目录层级，以及各个目录下的所有文件（包括<code class="language-plaintext highlighter-rouge">.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>jar包实际上就是一个zip格式的<strong>压缩文件</strong>，而jar包相当于目录。如果我们要执行一个jar包的<code class="language-plaintext highlighter-rouge">class</code>，就可以把jar包放到<code class="language-plaintext highlighter-rouge">classpath</code>中：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="na">-cp </span>./hello.jar <span class="kd">abc</span>.xyz.Hello
</code></pre></div></div><p>这样JVM会自动在<code class="language-plaintext highlighter-rouge">hello.jar</code>文件里去搜索某个类。</p><p>那么问题来了：如何创建jar包？</p><p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code class="language-plaintext highlighter-rouge">.zip</code>改为<code class="language-plaintext highlighter-rouge">.jar</code>，一个jar包就创建成功。</p><p>假设编译输出的目录结构是这样：</p><pre><code class="language-ascii">package_sample
└─ bin
   ├─ hong
   │  └─ Person.class
   │  ming
   │  └─ Person.class
   └─ mr
      └─ jun
         └─ Arrays.class
</code></pre><p>这里需要特别注意的是，jar包里的第一层目录，不能是<code class="language-plaintext highlighter-rouge">bin</code>，而应该是<code class="language-plaintext highlighter-rouge">hong</code>、<code class="language-plaintext highlighter-rouge">ming</code>、<code class="language-plaintext highlighter-rouge">mr</code>。</p><p>jar包还可以包含一个特殊的<code class="language-plaintext highlighter-rouge">/META-INF/MANIFEST.MF</code>文件，<code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>是纯文本，可以指定<code class="language-plaintext highlighter-rouge">Main-Class</code>和其它信息。JVM会自动读取这个<code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>文件，如果存在<code class="language-plaintext highlighter-rouge">Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">java</span> <span class="na">-jar </span><span class="kd">hello</span>.jar
</code></pre></div></div><p>在大型项目中，不可能手动编写<code class="language-plaintext highlighter-rouge">MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>，可以非常方便地创建jar包。</p><h3 id="class版本">class版本</h3><p>通常说的Java 8，Java 11，Java 17，是指JDK的版本，也就是JVM的版本，更确切地说，就是<code class="language-plaintext highlighter-rouge">java.exe</code>这个程序的版本：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">-version</span>
java version <span class="s2">"17"</span> 2021-09-14 LTS
</code></pre></div></div><p>而每个版本的JVM，它能执行的class文件版本也不同。例如，Java 11对应的class文件版本是55，而Java 17对应的class文件版本是61。</p><p>如果用Java 11编译一个Java程序，输出的class文件版本默认就是55，这个class既可以在Java 11上运行，也可以在Java 17上运行，因为Java 17支持的class文件版本是61，表示“最多支持到版本61”。查看class版本可以用<code class="language-plaintext highlighter-rouge">javap -v</code>。</p><p>如果用Java 17编译一个Java程序，输出的class文件版本默认就是61，它可以在Java 17、Java 18上运行，但不可能在Java 11上运行，因为Java 11支持的class版本最多到55。如果使用低于Java 17的JVM运行，会得到一个<code class="language-plaintext highlighter-rouge">UnsupportedClassVersionError</code>，错误信息类似：</p><div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.UnsupportedClassVersionError: Xxx has been compiled by a more recent version of the Java Runtime...
</code></pre></div></div><p>只要看到<code class="language-plaintext highlighter-rouge">UnsupportedClassVersionError</code>就表示当前要加载的class文件版本超过了JVM的能力，必须使用更高版本的JVM才能运行。</p><p>我们也可以用Java 17编译一个Java程序，指定输出的class版本要兼容Java 11（即class版本55），这样编译生成的class文件就可以在Java &gt;=11的环境中运行。</p><p>指定编译输出有两种方式，一种是在<code class="language-plaintext highlighter-rouge">javac</code>命令行中用参数<code class="language-plaintext highlighter-rouge">--release</code>设置：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ <span class="kd">javac</span> <span class="na">--release </span><span class="m">11</span> <span class="kd">Main</span>.java
</code></pre></div></div><p>参数<code class="language-plaintext highlighter-rouge">--release 11</code>表示源码兼容Java 11，编译的class输出版本为Java 11兼容，即class版本55。</p><p>第二种方式是用参数<code class="language-plaintext highlighter-rouge">--source</code>指定源码版本，用参数<code class="language-plaintext highlighter-rouge">--target</code>指定输出class版本：</p><div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ <span class="kd">javac</span> <span class="na">--source </span><span class="m">9</span> <span class="na">--target </span><span class="m">11</span> <span class="kd">Main</span>.java
</code></pre></div></div><p>上述命令如果使用Java 17的JDK编译，它会把源码视为Java 9兼容版本，并输出class为Java 11兼容版本。注意<code class="language-plaintext highlighter-rouge">--release</code>参数和<code class="language-plaintext highlighter-rouge">--source --target</code>参数只能二选一，不能同时设置。</p><p>然而，指定版本如果低于当前的JDK版本，会有一些潜在的问题。例如，我们用Java 17编译<code class="language-plaintext highlighter-rouge">Hello.java</code>，参数设置<code class="language-plaintext highlighter-rouge">--source 9</code>和<code class="language-plaintext highlighter-rouge">--target 11</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"hello"</span><span class="o">.</span><span class="na">indent</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>用低于Java 11的JVM运行<code class="language-plaintext highlighter-rouge">Hello</code>会得到一个<code class="language-plaintext highlighter-rouge">LinkageError</code>，因为无法加载<code class="language-plaintext highlighter-rouge">Hello.class</code>文件，而用Java 11运行<code class="language-plaintext highlighter-rouge">Hello</code>会得到一个<code class="language-plaintext highlighter-rouge">NoSuchMethodError</code>，因为<code class="language-plaintext highlighter-rouge">String.indent()</code>方法是从Java 12才添加进来的，Java 11的<code class="language-plaintext highlighter-rouge">String</code>版本根本没有<code class="language-plaintext highlighter-rouge">indent()</code>方法。</p><p>注：如果使用–release 11则会在编译时检查该方法是否在Java 11中存在。</p><p><strong>因此，如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class。</strong></p><p>如果使用<code class="language-plaintext highlighter-rouge">javac</code>编译时不指定任何版本参数，那么相当于使用<code class="language-plaintext highlighter-rouge">--release 当前版本</code>编译，即源码版本和输出版本均为当前版本。</p><p><strong>源码版本</strong></p><p>在编写源代码的时候，我们通常会预设一个源码的版本。在编译的时候，如果用<code class="language-plaintext highlighter-rouge">--source</code>或<code class="language-plaintext highlighter-rouge">--release</code>指定源码版本，则使用指定的源码版本检查语法。</p><p>例如，使用了lambda表达式的源码版本至少要为8才能编译，使用了<code class="language-plaintext highlighter-rouge">var</code>关键字的源码版本至少要为10才能编译，使用<code class="language-plaintext highlighter-rouge">switch</code>表达式的源码版本至少要为12才能编译，且12和13版本需要启用<code class="language-plaintext highlighter-rouge">--enable-preview</code>参数。</p><h3 id="模块">模块</h3><p>从Java 9开始，JDK又引入了模块（Module）。</p><p>什么是模块？这要从Java 9之前的版本说起。</p><p>我们知道，<code class="language-plaintext highlighter-rouge">.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code class="language-plaintext highlighter-rouge">.class</code>文件，很不便于管理，所以，<code class="language-plaintext highlighter-rouge">jar</code>文件就是<code class="language-plaintext highlighter-rouge">class</code>文件的容器。</p><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code class="language-plaintext highlighter-rouge">rt.jar</code>，一共有60多M。</p><p>如果是自己开发的程序，除了一个自己的<code class="language-plaintext highlighter-rouge">app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java <span class="nt">-cp</span> app.jar:a.jar:b.jar:c.jar com.Main
</code></pre></div></div><p><strong>注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</strong></p><p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code class="language-plaintext highlighter-rouge">ClassNotFoundException</code>。</p><p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p><p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code class="language-plaintext highlighter-rouge">a.jar</code>必须依赖另一个<code class="language-plaintext highlighter-rouge">b.jar</code>才能运行，那我们应该给<code class="language-plaintext highlighter-rouge">a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code class="language-plaintext highlighter-rouge">b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p><p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code class="language-plaintext highlighter-rouge">rt.jar</code>分拆成了几十个模块，这些模块以<code class="language-plaintext highlighter-rouge">.jmod</code>扩展名标识，可以在<code class="language-plaintext highlighter-rouge">$JAVA_HOME/jmods</code>目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>…</li></ul><p>这些<code class="language-plaintext highlighter-rouge">.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code class="language-plaintext highlighter-rouge">java.base</code>对应的文件就是<code class="language-plaintext highlighter-rouge">java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code class="language-plaintext highlighter-rouge">module-info.class</code>文件了。所有的模块都直接或间接地依赖<code class="language-plaintext highlighter-rouge">java.base</code>模块，只有<code class="language-plaintext highlighter-rouge">java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code class="language-plaintext highlighter-rouge">Object</code>直接或间接继承而来。</p><p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><p><strong>编写模块</strong></p><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以<code class="language-plaintext highlighter-rouge">oop-module</code>工程为例，它的目录结构如下：</p><pre><code class="language-ascii">oop-module
├── bin
├── build.sh
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
</code></pre><p>其中，<code class="language-plaintext highlighter-rouge">bin</code>目录存放编译后的class文件，<code class="language-plaintext highlighter-rouge">src</code>目录存放源码，按包名的目录结构存放，仅仅在<code class="language-plaintext highlighter-rouge">src</code>目录下多了一个<code class="language-plaintext highlighter-rouge">module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">module</span> <span class="n">hello</span><span class="o">.</span><span class="na">world</span> <span class="o">{</span>
	<span class="n">requires</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span> <span class="c1">// 可不写，任何模块都会自动引入java.base</span>
	<span class="n">requires</span> <span class="n">java</span><span class="o">.</span><span class="na">xml</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>其中，<code class="language-plaintext highlighter-rouge">module</code>是关键字，后面的<code class="language-plaintext highlighter-rouge">hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code class="language-plaintext highlighter-rouge">requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code class="language-plaintext highlighter-rouge">java.base</code>可以被自动引入外，这里我们引入了一个<code class="language-plaintext highlighter-rouge">java.xml</code>的模块。</p><p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code class="language-plaintext highlighter-rouge">Main.java</code>代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.itranswarp.sample</span><span class="o">;</span>
<span class="c1">// 必须引入java.xml模块后才能使用其中的类:</span>
<span class="kn">import</span> <span class="nn">javax.xml.XMLConstants</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Greeting</span> <span class="n">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Greeting</span><span class="o">();</span>
		<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">g</span><span class="o">.</span><span class="na">hello</span><span class="o">(</span><span class="nc">XMLConstants</span><span class="o">.</span><span class="na">XML_NS_PREFIX</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果把<code class="language-plaintext highlighter-rouge">requires java.xml;</code>从<code class="language-plaintext highlighter-rouge">module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p><p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p><p>首先，我们把工作目录切换到<code class="language-plaintext highlighter-rouge">oop-module</code>，在当前目录下编译所有的<code class="language-plaintext highlighter-rouge">.java</code>文件，并存放到<code class="language-plaintext highlighter-rouge">bin</code>目录下，命令如下：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>javac <span class="nt">-d</span> bin src/module-info.java src/com/itranswarp/sample/<span class="k">*</span>.java
</code></pre></div></div><p>如果编译成功，现在项目结构如下：</p><pre><code class="language-ascii">oop-module
├── bin
│   ├── com
│   │   └── itranswarp
│   │       └── sample
│   │           ├── Greeting.class
│   │           └── Main.class
│   └── module-info.class
└── src
    ├── com
    │   └── itranswarp
    │       └── sample
    │           ├── Greeting.java
    │           └── Main.java
    └── module-info.java
</code></pre><p>注意到<code class="language-plaintext highlighter-rouge">src</code>目录下的<code class="language-plaintext highlighter-rouge">module-info.java</code>被编译到<code class="language-plaintext highlighter-rouge">bin</code>目录下的<code class="language-plaintext highlighter-rouge">module-info.class</code>。</p><p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code class="language-plaintext highlighter-rouge">--main-class</code>参数，让这个jar包能自己定位<code class="language-plaintext highlighter-rouge">main</code>方法所在的类：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jar <span class="nt">--create</span> <span class="nt">--file</span> hello.jar <span class="nt">--main-class</span> com.itranswarp.sample.Main <span class="nt">-C</span> bin <span class="nb">.</span>
</code></pre></div></div><p>现在我们就在当前目录下得到了<code class="language-plaintext highlighter-rouge">hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code class="language-plaintext highlighter-rouge">java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code class="language-plaintext highlighter-rouge">jmod</code>命令把一个jar包转换成模块：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jmod create <span class="nt">--class-path</span> hello.jar hello.jmod
</code></pre></div></div><p>于是，在当前目录下我们又得到了<code class="language-plaintext highlighter-rouge">hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p><p><strong>运行模块</strong></p><p>要运行一个jar，我们使用<code class="language-plaintext highlighter-rouge">java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">--module-path</span> hello.jmod <span class="nt">--module</span> hello.world
</code></pre></div></div><p>结果是一个错误：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Error occurred during initialization of boot layer
java.lang.module.FindException: JMOD format not supported at execution <span class="nb">time</span>: hello.jmod
</code></pre></div></div><p>原因是<code class="language-plaintext highlighter-rouge">.jmod</code>不能被放入<code class="language-plaintext highlighter-rouge">--module-path</code>中。换成<code class="language-plaintext highlighter-rouge">.jar</code>就没问题了：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>java <span class="nt">--module-path</span> hello.jar <span class="nt">--module</span> hello.world
Hello, xml!
</code></pre></div></div><p>那我们辛辛苦苦创建的<code class="language-plaintext highlighter-rouge">hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p><p><strong>打包JRE</strong></p><p>前面讲了，为了支持模块化，<strong>Java 9</strong>首先带头把自己的一个巨大无比的<code class="language-plaintext highlighter-rouge">rt.jar</code>拆成了几十个<code class="language-plaintext highlighter-rouge">.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p><p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code class="language-plaintext highlighter-rouge">jlink</code>命令来干这件事。命令如下：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jlink <span class="nt">--module-path</span> hello.jmod <span class="nt">--add-modules</span> java.base,java.xml,hello.world <span class="nt">--output</span> jre/
</code></pre></div></div><p>我们在<code class="language-plaintext highlighter-rouge">--module-path</code>参数指定了我们自己的模块<code class="language-plaintext highlighter-rouge">hello.jmod</code>，然后，在<code class="language-plaintext highlighter-rouge">--add-modules</code>参数中指定了我们用到的3个模块<code class="language-plaintext highlighter-rouge">java.base</code>、<code class="language-plaintext highlighter-rouge">java.xml</code>和<code class="language-plaintext highlighter-rouge">hello.world</code>，用<code class="language-plaintext highlighter-rouge">,</code>分隔。最后，在<code class="language-plaintext highlighter-rouge">--output</code>参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到<code class="language-plaintext highlighter-rouge">jre</code>目录，这是一个完整的并且带有我们自己<code class="language-plaintext highlighter-rouge">hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>jre/bin/java <span class="nt">--module</span> hello.world
Hello, xml!
</code></pre></div></div><p>要分发我们自己的Java应用程序，只需要把这个<code class="language-plaintext highlighter-rouge">jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><p><strong>访问权限</strong></p><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块<code class="language-plaintext highlighter-rouge">hello.world</code>用到了模块<code class="language-plaintext highlighter-rouge">java.xml</code>的一个类<code class="language-plaintext highlighter-rouge">javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code class="language-plaintext highlighter-rouge">java.xml</code>的<code class="language-plaintext highlighter-rouge">module-info.java</code>中声明了若干导出：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">module</span> <span class="n">java</span><span class="o">.</span><span class="na">xml</span> <span class="o">{</span>
    <span class="n">exports</span> <span class="n">java</span><span class="o">.</span><span class="na">xml</span><span class="o">;</span>
    <span class="n">exports</span> <span class="n">javax</span><span class="o">.</span><span class="na">xml</span><span class="o">.</span><span class="na">catalog</span><span class="o">;</span>
    <span class="n">exports</span> <span class="n">javax</span><span class="o">.</span><span class="na">xml</span><span class="o">.</span><span class="na">datatype</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code class="language-plaintext highlighter-rouge">hello.world</code>模块中的<code class="language-plaintext highlighter-rouge">com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">module</span> <span class="n">hello</span><span class="o">.</span><span class="na">world</span> <span class="o">{</span>
    <span class="n">exports</span> <span class="n">com</span><span class="o">.</span><span class="na">itranswarp</span><span class="o">.</span><span class="na">sample</span><span class="o">;</span>
    <span class="n">requires</span> <span class="n">java</span><span class="o">.</span><span class="na">base</span><span class="o">;</span>
	<span class="n">requires</span> <span class="n">java</span><span class="o">.</span><span class="na">xml</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，模块进一步隔离了代码的访问权限。</p><h2 id="装箱拆箱">装箱拆箱</h2><p><strong>Double.parseDouble</strong>方法是把数字类型的字符串,转换成<strong>double</strong>类型</p><p><strong>Double.valueOf</strong>方法是把数字类型的字符串,转换成<strong>Double</strong>类型</p><p>可以看出大体是没有任何区别,就是返回值的<strong>类型</strong>区别</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">a</span><span class="o">=</span><span class="nc">Double</span><span class="o">.</span><span class="na">parseDouble</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>  
<span class="nc">Double</span> <span class="n">b</span><span class="o">=</span><span class="nc">Double</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="s">"123"</span><span class="o">);</span>
</code></pre></div></div><p><strong>valueOf</strong>方法在返回的时候<strong>new Double()</strong>,所以返回的是<strong>Double</strong>。</p><p><strong>intValue()</strong>表示拆箱，将对象类型转换为基础类型</p><p><strong>valueOf()</strong>表示装箱，将基础类型转换为对象类型</p><p>因为<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">Integer</code>可以互相转换，所以，Java编译器可以帮助我们<strong>自动</strong>在<code class="language-plaintext highlighter-rouge">int</code>和<code class="language-plaintext highlighter-rouge">Integer</code>之间转型。自动装箱和自动拆箱只发生在编译阶段（JDK&gt;=1.5），目的是为了少写代码。装箱和拆箱会影响代码的执行效率，因为编译后的<code class="language-plaintext highlighter-rouge">class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code class="language-plaintext highlighter-rouge">NullPointerException</code>，比如:<code class="language-plaintext highlighter-rouge">Integer n = null;int i=n;</code></p><p>所有的包装类型都是不变类。<code class="language-plaintext highlighter-rouge">Integer</code>的核心代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Integer</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>因此，一旦创建了<code class="language-plaintext highlighter-rouge">Integer</code>对象，该对象就是不变的。但实际我们代码，这样是不会报错的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
<span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
</code></pre></div></div><p>原因：<code class="language-plaintext highlighter-rouge">num</code>是一个<code class="language-plaintext highlighter-rouge">Integer</code>对象，初始值为5。当我们执行<code class="language-plaintext highlighter-rouge">num + 1</code>时，实际上创建了一个新的<code class="language-plaintext highlighter-rouge">Integer</code>对象来表示6，然后将其赋值给<code class="language-plaintext highlighter-rouge">num</code>。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Integer</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
<span class="nc">Integer</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">127</span><span class="o">;</span>
<span class="nc">Integer</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">99999</span><span class="o">;</span>
<span class="nc">Integer</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">99999</span><span class="o">;</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"x == y: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="n">y</span><span class="o">));</span> <span class="c1">// true</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m == n: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">m</span><span class="o">==</span><span class="n">n</span><span class="o">));</span> <span class="c1">// false</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"x.equals(y): "</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">y</span><span class="o">));</span> <span class="c1">// true</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"m.equals(n): "</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">n</span><span class="o">));</span> <span class="c1">// true</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">==</code>比较，较小的两个相同的<code class="language-plaintext highlighter-rouge">Integer</code>返回<code class="language-plaintext highlighter-rouge">true</code>，较大的两个相同的<code class="language-plaintext highlighter-rouge">Integer</code>返回<code class="language-plaintext highlighter-rouge">false</code>，这是因为<code class="language-plaintext highlighter-rouge">Integer</code>是不变类，编译器把<code class="language-plaintext highlighter-rouge">Integer x = 127;</code>自动变为<code class="language-plaintext highlighter-rouge">Integer x = Integer.valueOf(127);</code>，为了节省内存，<code class="language-plaintext highlighter-rouge">Integer.valueOf()</code>对于较小的数，始终返回相同的实例。</p><p><code class="language-plaintext highlighter-rouge">Integer</code>本身会缓存[-128,127]的整数，所以当你值在这个范围内时，就会直接取出<code class="language-plaintext highlighter-rouge">Integer</code>,不会<code class="language-plaintext highlighter-rouge">new</code>一个新的<code class="language-plaintext highlighter-rouge">Integer</code>，因此<code class="language-plaintext highlighter-rouge">==</code>为<code class="language-plaintext highlighter-rouge">true</code>, 而当数超过这个范围时，就会<code class="language-plaintext highlighter-rouge">new</code>一个新的<code class="language-plaintext highlighter-rouge">Integer</code>，不同的<code class="language-plaintext highlighter-rouge">Integer</code>对象，因此<code class="language-plaintext highlighter-rouge">==</code>为<code class="language-plaintext highlighter-rouge">false</code>。</p><p>因此，<code class="language-plaintext highlighter-rouge">==</code>比较“恰好”为<code class="language-plaintext highlighter-rouge">true</code>，但我们绝不能因为Java标准库的<code class="language-plaintext highlighter-rouge">Integer</code>内部有缓存优化就用<code class="language-plaintext highlighter-rouge">==</code>比较，必须用<code class="language-plaintext highlighter-rouge">equals()</code>方法比较两个<code class="language-plaintext highlighter-rouge">Integer</code>。 按照语义编程，而不是针对特定的底层实现去“优化”。</p><p>因为<code class="language-plaintext highlighter-rouge">Integer.valueOf()</code>可能始终返回同一个<code class="language-plaintext highlighter-rouge">Integer</code>实例，因此，在我们自己创建<code class="language-plaintext highlighter-rouge">Integer</code>的时候，以下两种方法：</p><ul><li>方法1：<code class="language-plaintext highlighter-rouge">Integer n = new Integer(100);</code></li><li>方法2：<code class="language-plaintext highlighter-rouge">Integer n = Integer.valueOf(100);</code></li></ul><p>方法2更好，因为方法1总是创建新的<code class="language-plaintext highlighter-rouge">Integer</code>实例，方法2把内部优化留给<code class="language-plaintext highlighter-rouge">Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p><p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code class="language-plaintext highlighter-rouge">Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p><p>Java的包装类型还定义了一些有用的静态变量</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span>
<span class="nc">Boolean</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Boolean</span><span class="o">.</span><span class="na">TRUE</span><span class="o">;</span>
<span class="nc">Boolean</span> <span class="n">f</span> <span class="o">=</span> <span class="nc">Boolean</span><span class="o">.</span><span class="na">FALSE</span><span class="o">;</span>
<span class="c1">// int可表示的最大/最小值:</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span> <span class="c1">// 2147483647</span>
<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span> <span class="c1">// -2147483648</span>
<span class="c1">// long类型占用的bit和byte数量:</span>
<span class="kt">int</span> <span class="n">sizeOfLong</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">SIZE</span><span class="o">;</span> <span class="c1">// 64 (bits)</span>
<span class="kt">int</span> <span class="n">bytesOfLong</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">BYTES</span><span class="o">;</span> <span class="c1">// 8 (bytes)</span>
</code></pre></div></div><p>所有的整数和浮点数的包装类型都继承自<code class="language-plaintext highlighter-rouge">Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 向上转型为Number:</span>
<span class="nc">Number</span> <span class="n">num</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">(</span><span class="mi">999</span><span class="o">);</span>
<span class="c1">// 获取byte, int, long, float, double:</span>
<span class="kt">byte</span> <span class="n">b</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">byteValue</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">intValue</span><span class="o">();</span>
<span class="kt">long</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">longValue</span><span class="o">();</span>
<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">floatValue</span><span class="o">();</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="na">doubleValue</span><span class="o">();</span>
</code></pre></div></div><h2 id="javabean">JavaBean</h2><p>如果读写方法符合以下这种命名规范：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 读方法:</span>
<span class="kd">public</span> <span class="nc">Type</span> <span class="nf">getXyz</span><span class="o">()</span>
<span class="c1">// 写方法:</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setXyz</span><span class="o">(</span><span class="nc">Type</span> <span class="n">value</span><span class="o">)</span>
</code></pre></div></div><p>那么这种<code class="language-plaintext highlighter-rouge">class</code>被称为<code class="language-plaintext highlighter-rouge">JavaBean</code>，上面的字段是<code class="language-plaintext highlighter-rouge">xyz</code>，那么读写方法名分别以<code class="language-plaintext highlighter-rouge">get</code>和<code class="language-plaintext highlighter-rouge">set</code>开头，并且后接大写字母开头的字段名<code class="language-plaintext highlighter-rouge">Xyz</code>，因此两个读写方法名分别是<code class="language-plaintext highlighter-rouge">getXyz()</code>和<code class="language-plaintext highlighter-rouge">setXyz()</code>。<code class="language-plaintext highlighter-rouge">boolean</code>字段比较特殊，它的读方法一般命名为<code class="language-plaintext highlighter-rouge">isXyz()</code>。</p><p>IDEA：<strong>alt+/</strong> 内容辅助，在类内右键-生成Getter和Setter.. 。</p><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code class="language-plaintext highlighter-rouge">Introspector</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.beans.BeanInfo</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.beans.Introspector</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.beans.PropertyDescriptor</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">BeanInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="nc">Introspector</span><span class="o">.</span><span class="na">getBeanInfo</span><span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">PropertyDescriptor</span> <span class="n">pd</span> <span class="o">:</span> <span class="n">info</span><span class="o">.</span><span class="na">getPropertyDescriptors</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">pd</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  "</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="na">getReadMethod</span><span class="o">());</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"  "</span> <span class="o">+</span> <span class="n">pd</span><span class="o">.</span><span class="na">getWriteMethod</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">name</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAge</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">age</span><span class="o">;}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setAge</span><span class="o">(</span><span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span><span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;}</span>
<span class="o">}</span>
</code></pre></div></div><p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意<code class="language-plaintext highlighter-rouge">class</code>属性是从<code class="language-plaintext highlighter-rouge">Object</code>继承的<code class="language-plaintext highlighter-rouge">getClass()</code>方法带来的。</p><h2 id="枚举">枚举</h2><p>在Java中，我们可以通过<code class="language-plaintext highlighter-rouge">static final</code>来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的<code class="language-plaintext highlighter-rouge">int</code>表示：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Weekday</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SUN</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MON</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TUE</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">WED</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">THU</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">FRI</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SAT</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>使用常量的时候，可以这么引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">day</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">day</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SAT</span> <span class="o">||</span> <span class="n">day</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// TODO: work at home</span>
<span class="o">}</span>
</code></pre></div></div><p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Color</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">RED</span> <span class="o">=</span> <span class="s">"r"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">GREEN</span> <span class="o">=</span> <span class="s">"g"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">BLUE</span> <span class="o">=</span> <span class="s">"b"</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>使用常量的时候，可以这么引用：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">color</span> <span class="o">=</span> <span class="s">"r"</span>
<span class="k">if</span> <span class="o">(</span><span class="nc">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">color</span><span class="o">))</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>无论是<code class="language-plaintext highlighter-rouge">int</code>常量还是<code class="language-plaintext highlighter-rouge">String</code>常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">weekday</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">weekday</span> <span class="o">==</span> <span class="mi">7</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tasks</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">MON</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>假设<code class="language-plaintext highlighter-rouge">weekday</code>表示星期几，<code class="language-plaintext highlighter-rouge">tasks</code>表示任务，<code class="language-plaintext highlighter-rouge">Weekday.MON</code>表示星期一。<code class="language-plaintext highlighter-rouge">6</code>和<code class="language-plaintext highlighter-rouge">7</code>并不能直观地表达出是星期六和星期日，<code class="language-plaintext highlighter-rouge">tasks</code>被用来表示星期几的任务，这种用法并不符合语义。</p><p>上述代码编译和运行均不会报错，但存在两个问题：</p><ul><li>注意到<code class="language-plaintext highlighter-rouge">Weekday</code>定义的常量范围是<code class="language-plaintext highlighter-rouge">0</code>~<code class="language-plaintext highlighter-rouge">6</code>，并不包含<code class="language-plaintext highlighter-rouge">7</code>，但是在代码中可以使用<code class="language-plaintext highlighter-rouge">6</code>和<code class="language-plaintext highlighter-rouge">7</code>来表示星期六和星期日。这种情况下，编译器无法检查出不在枚举范围内的值，因为<code class="language-plaintext highlighter-rouge">6</code>和<code class="language-plaintext highlighter-rouge">7</code>是合法的<code class="language-plaintext highlighter-rouge">int</code>值，但却不是合法的星期枚举值。</li><li>定义的常量虽然可以表示星期值，但它们仍然是<code class="language-plaintext highlighter-rouge">int</code>类型的常量，可以与其他<code class="language-plaintext highlighter-rouge">int</code>类型的变量进行比较，这并不符合枚举值的语义。虽然使用<code class="language-plaintext highlighter-rouge">tasks == Weekday.MON</code>来判断<code class="language-plaintext highlighter-rouge">tasks</code>是否是星期一的任务，虽然可以正常运行，但这种比较并不直观，容易引起误解。</li></ul><hr /><p><strong>enum</strong></p><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code class="language-plaintext highlighter-rouge">enum</code>来定义枚举类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Weekday</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">day</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SAT</span> <span class="o">||</span> <span class="n">day</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Work at home!"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Work at office!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span>
    <span class="no">SUN</span><span class="o">,</span> <span class="no">MON</span><span class="o">,</span> <span class="no">TUE</span><span class="o">,</span> <span class="no">WED</span><span class="o">,</span> <span class="no">THU</span><span class="o">,</span> <span class="no">FRI</span><span class="o">,</span> <span class="no">SAT</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>注意到定义枚举类是通过关键字<code class="language-plaintext highlighter-rouge">enum</code>实现的，我们只需依次列出枚举的常量名。</p><p>和<code class="language-plaintext highlighter-rouge">int</code>定义的常量相比，使用<code class="language-plaintext highlighter-rouge">enum</code>定义枚举有如下好处：</p><p>首先，<code class="language-plaintext highlighter-rouge">enum</code>常量本身带有类型信息，即<code class="language-plaintext highlighter-rouge">Weekday.SUN</code>类型是<code class="language-plaintext highlighter-rouge">Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="k">if</span> <span class="o">(</span><span class="n">day</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Compile error: bad operand types for binary operator '=='</span>
<span class="o">}</span>
</code></pre></div></div><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p><p>最后，不同类型的枚举<strong>不能</strong>互相<strong>比较</strong>或者赋值，因为类型不符。例如，不能给一个<code class="language-plaintext highlighter-rouge">Weekday</code>枚举类型的变量赋值为<code class="language-plaintext highlighter-rouge">Color</code>枚举类型的值：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Weekday</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">;</span> <span class="c1">// ok!</span>
<span class="nc">Weekday</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">;</span> <span class="c1">// Compile error: incompatible types</span>
</code></pre></div></div><p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p><p><strong>enum的比较</strong></p><p>使用<code class="language-plaintext highlighter-rouge">enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用<code class="language-plaintext highlighter-rouge">equals()</code>方法，如果使用<code class="language-plaintext highlighter-rouge">==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code class="language-plaintext highlighter-rouge">equals()</code>方法，但<code class="language-plaintext highlighter-rouge">enum</code>类型可以例外。</p><p>这是因为<code class="language-plaintext highlighter-rouge">enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code class="language-plaintext highlighter-rouge">==</code>比较：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">day</span> <span class="o">==</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">FRI</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// ok!</span>
<span class="o">}</span>
<span class="k">if</span> <span class="o">(</span><span class="n">day</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// ok, but more code!</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>enum类型</strong></p><p>通过<code class="language-plaintext highlighter-rouge">enum</code>定义的枚举类，和其他的<code class="language-plaintext highlighter-rouge">class</code>有什么区别？</p><p>答案是<strong>没有任何区别</strong>。<code class="language-plaintext highlighter-rouge">enum</code>定义的类型就是<code class="language-plaintext highlighter-rouge">class</code>，只不过它有以下几个特点：</p><ul><li>定义的<code class="language-plaintext highlighter-rouge">enum</code>类型总是继承自<code class="language-plaintext highlighter-rouge">java.lang.Enum</code>，且无法被继承；</li><li>只能定义出<code class="language-plaintext highlighter-rouge">enum</code>的实例，而无法通过<code class="language-plaintext highlighter-rouge">new</code>操作符创建<code class="language-plaintext highlighter-rouge">enum</code>的实例；</li><li>定义的每个实例都是引用类型的唯一实例；</li><li>可以将<code class="language-plaintext highlighter-rouge">enum</code>类型用于<code class="language-plaintext highlighter-rouge">switch</code>语句。</li></ul><p>例如，我们定义的<code class="language-plaintext highlighter-rouge">Color</code>枚举类：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Color</span> <span class="o">{</span>
    <span class="no">RED</span><span class="o">,</span> <span class="no">GREEN</span><span class="o">,</span> <span class="no">BLUE</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>编译器编译出的<code class="language-plaintext highlighter-rouge">class</code>大概就像这样：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Color</span> <span class="kd">extends</span> <span class="nc">Enum</span> <span class="o">{</span> <span class="c1">// 继承自Enum，标记为final class</span>
    <span class="c1">// 每个实例均为全局唯一:</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="no">RED</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Color</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="no">GREEN</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Color</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="no">BLUE</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Color</span><span class="o">();</span>
    <span class="c1">// private构造方法，确保外部无法调用new操作符:</span>
    <span class="kd">private</span> <span class="nf">Color</span><span class="o">()</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div><p>所以，编译后的<code class="language-plaintext highlighter-rouge">enum</code>类和普通<code class="language-plaintext highlighter-rouge">class</code>并<strong>没有任何区别</strong>。但是我们自己无法按定义普通<code class="language-plaintext highlighter-rouge">class</code>那样来定义<code class="language-plaintext highlighter-rouge">enum</code>，必须使用<code class="language-plaintext highlighter-rouge">enum</code>关键字，这是Java语法规定的。</p><p>因为<code class="language-plaintext highlighter-rouge">enum</code>是一个<code class="language-plaintext highlighter-rouge">class</code>，每个枚举的值都是<code class="language-plaintext highlighter-rouge">class</code>实例，因此，这些实例有一些方法：</p><p><strong>name()</strong></p><p>返回常量名，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">.</span><span class="na">name</span><span class="o">();</span> <span class="c1">// "SUN"</span>
</code></pre></div></div><p><strong>ordinal()</strong></p><p>返回定义的常量的<strong>顺序</strong>，从0开始计数，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">MON</span><span class="o">.</span><span class="na">ordinal</span><span class="o">();</span> <span class="c1">// 1</span>
</code></pre></div></div><p>改变枚举常量定义的顺序就会导致<code class="language-plaintext highlighter-rouge">ordinal()</code>返回值发生变化。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span><span class="no">SUN</span><span class="o">,</span> <span class="no">MON</span><span class="o">,</span> <span class="no">TUE</span><span class="o">,</span> <span class="no">WED</span><span class="o">,</span> <span class="no">THU</span><span class="o">,</span> <span class="no">FRI</span><span class="o">,</span> <span class="no">SAT</span><span class="o">;}</span>
</code></pre></div></div><p>和</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span><span class="no">MON</span><span class="o">,</span> <span class="no">TUE</span><span class="o">,</span> <span class="no">WED</span><span class="o">,</span> <span class="no">THU</span><span class="o">,</span> <span class="no">FRI</span><span class="o">,</span> <span class="no">SAT</span><span class="o">,</span> <span class="no">SUN</span><span class="o">;}</span>
</code></pre></div></div><p>的<code class="language-plaintext highlighter-rouge">ordinal</code>就是不同的。如果在代码中编写了类似<code class="language-plaintext highlighter-rouge">if(x.ordinal()==1)</code>这样的语句，就要<strong>保证</strong><code class="language-plaintext highlighter-rouge">enum</code>的枚举<strong>顺序不能变</strong>。新增的常量必须放在最后。</p><p><code class="language-plaintext highlighter-rouge">Weekday</code>的枚举常量如果要和<code class="language-plaintext highlighter-rouge">int</code>转换，使用<code class="language-plaintext highlighter-rouge">ordinal()</code>不是非常方便？比如这样写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">task</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">MON</span><span class="o">.</span><span class="na">ordinal</span><span class="o">();</span>
</code></pre></div></div><p>但是，如果不小心修改了枚举的<strong>顺序</strong>，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就<strong>不要依靠</strong><code class="language-plaintext highlighter-rouge">ordinal()</code>的返回值。因为<code class="language-plaintext highlighter-rouge">enum</code>本身是<code class="language-plaintext highlighter-rouge">class</code>，所以我们可以定义<code class="language-plaintext highlighter-rouge">private</code>的<strong>构造方法</strong>，并且，给每个枚举常量添加字段：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Weekday</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">day</span><span class="o">.</span><span class="na">dayValue</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">day</span><span class="o">.</span><span class="na">dayValue</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Work at home!"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Work at office!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span>
    <span class="no">MON</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="no">TUE</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="no">WED</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="no">THU</span><span class="o">(</span><span class="mi">4</span><span class="o">),</span> <span class="no">FRI</span><span class="o">(</span><span class="mi">5</span><span class="o">),</span> <span class="no">SAT</span><span class="o">(</span><span class="mi">6</span><span class="o">),</span> <span class="no">SUN</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">dayValue</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Weekday</span><span class="o">(</span><span class="kt">int</span> <span class="n">dayValue</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dayValue</span> <span class="o">=</span> <span class="n">dayValue</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code class="language-plaintext highlighter-rouge">int</code>值。</p><p>注意：<strong>枚举类的字段</strong>也<strong>可以</strong>是非<code class="language-plaintext highlighter-rouge">final</code>类型，即可以在运行期修改，但是<strong>不推荐这样做</strong>！</p><p>默认情况下，对枚举常量调用<code class="language-plaintext highlighter-rouge">toString()</code>会返回和<code class="language-plaintext highlighter-rouge">name()</code>一样的字符串。但是，<code class="language-plaintext highlighter-rouge">toString()</code>可以被覆写，而<code class="language-plaintext highlighter-rouge">name()</code>则不行，因此判断枚举常量的<strong>名字</strong>，要始终使用<code class="language-plaintext highlighter-rouge">name()</code>方法，绝不能调用<code class="language-plaintext highlighter-rouge">toString()</code>！覆写<code class="language-plaintext highlighter-rouge">toString()</code>的目的是在输出时更有可读性。可以给<code class="language-plaintext highlighter-rouge">Weekday</code>添加<code class="language-plaintext highlighter-rouge">toString()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Weekday</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">day</span><span class="o">.</span><span class="na">dayValue</span> <span class="o">==</span> <span class="mi">6</span> <span class="o">||</span> <span class="n">day</span><span class="o">.</span><span class="na">dayValue</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Today is "</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="s">". Work at home!"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Today is "</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="s">". Work at office!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span>
    <span class="no">MON</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"星期一"</span><span class="o">),</span> <span class="no">TUE</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"星期二"</span><span class="o">),</span> <span class="no">WED</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s">"星期三"</span><span class="o">),</span> <span class="no">THU</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s">"星期四"</span><span class="o">),</span> <span class="no">FRI</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s">"星期五"</span><span class="o">),</span> <span class="no">SAT</span><span class="o">(</span><span class="mi">6</span><span class="o">,</span> <span class="s">"星期六"</span><span class="o">),</span> <span class="no">SUN</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">"星期日"</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">dayValue</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">chinese</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nf">Weekday</span><span class="o">(</span><span class="kt">int</span> <span class="n">dayValue</span><span class="o">,</span> <span class="nc">String</span> <span class="n">chinese</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">dayValue</span> <span class="o">=</span> <span class="n">dayValue</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">chinese</span> <span class="o">=</span> <span class="n">chinese</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">chinese</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>values()</strong></p><p><code class="language-plaintext highlighter-rouge">enum</code>类中有一个名为<code class="language-plaintext highlighter-rouge">values()</code>的方法，它返回包含枚举类中所有枚举常量的数组。该方法在<code class="language-plaintext highlighter-rouge">java.lang.Enum</code>类中被定义为<code class="language-plaintext highlighter-rouge">final</code>，因此所有枚举类都可以直接使用该方法。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span>
    <span class="no">MONDAY</span><span class="o">,</span> <span class="no">TUESDAY</span><span class="o">,</span> <span class="no">WEDNESDAY</span><span class="o">,</span> <span class="no">THURSDAY</span><span class="o">,</span> <span class="no">FRIDAY</span><span class="o">,</span> <span class="no">SATURDAY</span><span class="o">,</span> <span class="no">SUNDAY</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Weekday</span><span class="o">[]</span> <span class="n">weekdays</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">values</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Weekday</span> <span class="n">day</span> <span class="o">:</span> <span class="n">weekdays</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">day</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>该示例定义了一个<code class="language-plaintext highlighter-rouge">Weekday</code>枚举类，然后通过调用<code class="language-plaintext highlighter-rouge">values()</code>方法获取所有枚举常量，并使用<code class="language-plaintext highlighter-rouge">for</code>循环遍历打印每个枚举常量的名称。<code class="language-plaintext highlighter-rouge">values()</code>方法是枚举类中的一个便捷方法，用于获取所有枚举常量，方便对枚举类进行遍历和操作。</p><hr /><p><strong>switch</strong></p><p>最后，枚举类可以应用在<code class="language-plaintext highlighter-rouge">switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">String</code>类型更适合用在<code class="language-plaintext highlighter-rouge">switch</code>语句中：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Weekday</span> <span class="n">day</span> <span class="o">=</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">SUN</span><span class="o">;</span>
        <span class="k">switch</span><span class="o">(</span><span class="n">day</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">MON:</span>
            <span class="k">case</span> <span class="nl">TUE:</span>
            <span class="k">case</span> <span class="nl">WED:</span>
            <span class="k">case</span> <span class="nl">THU:</span>
            <span class="k">case</span> <span class="nl">FRI:</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Today is "</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="s">". Work at office!"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">SAT:</span>
            <span class="k">case</span> <span class="nl">SUN:</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Today is "</span> <span class="o">+</span> <span class="n">day</span> <span class="o">+</span> <span class="s">". Work at home!"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"cannot process "</span> <span class="o">+</span> <span class="n">day</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">enum</span> <span class="nc">Weekday</span> <span class="o">{</span>
    <span class="no">MON</span><span class="o">,</span> <span class="no">TUE</span><span class="o">,</span> <span class="no">WED</span><span class="o">,</span> <span class="no">THU</span><span class="o">,</span> <span class="no">FRI</span><span class="o">,</span> <span class="no">SAT</span><span class="o">,</span> <span class="no">SUN</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>加上<code class="language-plaintext highlighter-rouge">default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p><p>不能用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="nc">Weekday</span><span class="o">.</span><span class="na">MON</span><span class="o">:</span>
</code></pre></div></div><p>而只能用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="nl">MON:</span>
</code></pre></div></div><p>在<code class="language-plaintext highlighter-rouge">Switch()</code>里面已经写了是 <code class="language-plaintext highlighter-rouge">day</code>，而<code class="language-plaintext highlighter-rouge">day</code>的类型是<code class="language-plaintext highlighter-rouge">Weekday</code>，所以<code class="language-plaintext highlighter-rouge">case</code>后面的<code class="language-plaintext highlighter-rouge">Weekday</code>就省略了，因为所有的<code class="language-plaintext highlighter-rouge">case</code>类型必须是<code class="language-plaintext highlighter-rouge">Weekday</code>。</p><p><code class="language-plaintext highlighter-rouge">switch</code>语句中的<code class="language-plaintext highlighter-rouge">case</code>标签必须使用枚举常量的非限定名称，而不是枚举类的名称，是因为Java语言规定了这样的语法规则。</p><p>在<code class="language-plaintext highlighter-rouge">switch</code>语句中，<code class="language-plaintext highlighter-rouge">case</code>标签用于匹配要执行的代码块。在枚举类型中，每个枚举常量都是一个实例，因此在<code class="language-plaintext highlighter-rouge">switch</code>语句中，应该匹配的是枚举常量的值，而不是枚举类本身。</p><p>使用枚举常量的非限定名称作为<code class="language-plaintext highlighter-rouge">case</code>标签可以让代码更清晰易读，并且可以避免混淆。如果允许在<code class="language-plaintext highlighter-rouge">switch</code>语句中使用枚举类的名称，可能会导致代码不够清晰，不容易理解。</p><p>因此，Java语言规定了<code class="language-plaintext highlighter-rouge">switch</code>语句中的<code class="language-plaintext highlighter-rouge">case</code>标签必须使用枚举常量的非限定名称，以确保代码的正确性和清晰性。</p><hr /><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">a</span><span class="o">){</span>
            <span class="k">case</span> <span class="no">X</span><span class="o">.</span><span class="na">y</span><span class="o">:</span> <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"NUMBER_OF_PROCESSORS"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>case只能比较常量，不能比较变量，所以要在编译期计算常量的值。</p><p>这种final定义：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>编译期能计算出来，所以可以用 case X.y，编译器麻溜地把代码直接替换成 case 1</p><p>这种final定义：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"NUMBER_OF_PROCESSORS"</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div></div><p>编译期算不出来，只能运行才知道，所以不能用<code class="language-plaintext highlighter-rouge">case X.y</code></p><h2 id="record">record</h2><p>使用<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ol><li>定义class时使用<code class="language-plaintext highlighter-rouge">final</code>，无法派生子类；</li><li>每个字段使用<code class="language-plaintext highlighter-rouge">final</code>，保证创建实例后无法修改任何字段。</li></ol><p>假设我们希望定义一个<code class="language-plaintext highlighter-rouge">Point</code>类，有<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>两个变量，同时它是一个不变类，可以这么写：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">x</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">y</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为了保证不变类的比较，还需要正确覆写<code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法，这样才能在集合类中正常使用。这些代码写起来都非常简单，但是很繁琐。</p><p><strong>record</strong></p><p>从<strong>Java 14</strong>开始，引入了新的<code class="language-plaintext highlighter-rouge">Record</code>类。 <code class="language-plaintext highlighter-rouge">record</code> 类的目的是为了简化创建不可变数据对象的过程。它自动为类生成 <code class="language-plaintext highlighter-rouge">equals()</code>、<code class="language-plaintext highlighter-rouge">hashCode()</code>、<code class="language-plaintext highlighter-rouge">toString()</code> 方法，同时提供了一个简洁的声明方式来定义类的属性。通过使用 <code class="language-plaintext highlighter-rouge">record</code>，可以更加简洁地定义数据模型，避免编写大量样板代码，提高代码的可读性和可维护性。</p><p>定义<code class="language-plaintext highlighter-rouge">Record</code>类时，使用关键字<code class="language-plaintext highlighter-rouge">record</code>。把上述<code class="language-plaintext highlighter-rouge">Point</code>类改写为<code class="language-plaintext highlighter-rouge">Record</code>类，代码如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{}</span>
</code></pre></div></div><p>把上述定义改写为class，相当于以下代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="kd">extends</span> <span class="nc">Record</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">x</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">y</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Point[x=%s, y=%s]"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>除了用<code class="language-plaintext highlighter-rouge">final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code class="language-plaintext highlighter-rouge">toString()</code>、<code class="language-plaintext highlighter-rouge">equals()</code>和<code class="language-plaintext highlighter-rouge">hashCode()</code>方法。</p><p>换句话说，使用<code class="language-plaintext highlighter-rouge">record</code>关键字，可以一行写出一个不变类。</p><p>和<code class="language-plaintext highlighter-rouge">enum</code>类似，我们自己不能直接从<code class="language-plaintext highlighter-rouge">Record</code>派生，只能通过<code class="language-plaintext highlighter-rouge">record</code>关键字由编译器实现继承。</p><p><strong>构造方法</strong></p><p>编译器默认按照<code class="language-plaintext highlighter-rouge">record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p><p>假设<code class="language-plaintext highlighter-rouge">Point</code>类的<code class="language-plaintext highlighter-rouge">x</code>、<code class="language-plaintext highlighter-rouge">y</code>不允许负数，我们就得给<code class="language-plaintext highlighter-rouge">Point</code>的构造方法加上检查逻辑：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Point</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>注意到方法<code class="language-plaintext highlighter-rouge">public Point {...}</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="kd">extends</span> <span class="nc">Record</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 这是我们编写的Compact Constructor:</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// 这是编译器继续生成的赋值代码:</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div><p>作为<code class="language-plaintext highlighter-rouge">record</code>的<code class="language-plaintext highlighter-rouge">Point</code>仍然可以添加静态方法。一种常用的静态方法是<code class="language-plaintext highlighter-rouge">of()</code>方法，用来创建<code class="language-plaintext highlighter-rouge">Point</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="n">record</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Point</span> <span class="nf">of</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Point</span> <span class="nf">of</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样我们可以写出更简洁的代码：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">z</span> <span class="o">=</span> <span class="nc">Point</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
<span class="kt">var</span> <span class="n">p</span> <span class="o">=</span> <span class="nc">Point</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">456</span><span class="o">);</span>
</code></pre></div></div><p>还可以手动写构造方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="no">C</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">a</span><span class="o">());</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">b</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">record</span> <span class="nf">C</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
    <span class="kd">public</span> <span class="nf">C</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">a</span><span class="o">=</span><span class="n">a</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span><span class="o">=</span><span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>如果不需要在赋值前后做某些事情，则没有必要这样写。也可以写多个构造方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.aotmd</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">C</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="no">C</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="no">C</span> <span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="no">C</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">record</span> <span class="nf">C</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span><span class="kt">int</span> <span class="n">b</span><span class="o">){</span>
    <span class="kd">public</span> <span class="nf">C</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="mi">2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"一参"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="nf">C</span><span class="o">(){</span>
        <span class="k">this</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"无参"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>最后必须传递到自动生成的构造方法，Java中的<code class="language-plaintext highlighter-rouge">record</code>类在定义非规范记录构造函数（non-canonical record constructor）时，必须委托给其他构造函数。这意味着非规范记录构造函数的第一条语句必须是对其他构造函数的调用。且非规范记录构造函数<strong>必须</strong>最终委托给自动生成的构造函数，否则会导致编译错误。这意味着在构造函数体内的调用链<strong>必须最终</strong>指向自动生成的构造函数。</p><h2 id="biginteger">BigInteger</h2><p>在Java中，由CPU原生提供的整型最大范围是64位<code class="language-plaintext highlighter-rouge">long</code>型整数。使用<code class="language-plaintext highlighter-rouge">long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p><p>如果我们使用的整数范围超过了<code class="language-plaintext highlighter-rouge">long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code class="language-plaintext highlighter-rouge">java.math.BigInteger</code>就是用来表示任意大小的整数。<code class="language-plaintext highlighter-rouge">BigInteger</code>内部用一个<code class="language-plaintext highlighter-rouge">int[]</code>数组来模拟一个非常大的整数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigInteger</span> <span class="n">bi</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="s">"1234567890"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bi</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span> <span class="c1">// 2867971860299718107233761438093672048294900000</span>
</code></pre></div></div><p>对<code class="language-plaintext highlighter-rouge">BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigInteger</span> <span class="n">i1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="s">"1234567890"</span><span class="o">);</span>
<span class="nc">BigInteger</span> <span class="n">i2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="s">"12345678901234567890"</span><span class="o">);</span>
<span class="nc">BigInteger</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">i1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i2</span><span class="o">);</span> <span class="c1">// 12345678902469135780</span>
</code></pre></div></div><p>和<code class="language-plaintext highlighter-rouge">long</code>型整数运算比，<code class="language-plaintext highlighter-rouge">BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p><p>也可以把<code class="language-plaintext highlighter-rouge">BigInteger</code>转换成<code class="language-plaintext highlighter-rouge">long</code>型：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigInteger</span><span class="o">(</span><span class="s">"123456789000"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">longValue</span><span class="o">());</span> <span class="c1">// 123456789000</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">longValueExact</span><span class="o">());</span> <span class="c1">// java.lang.ArithmeticException: BigInteger out of long range</span>
</code></pre></div></div><p>使用<code class="language-plaintext highlighter-rouge">longValueExact()</code>方法时，如果超出了<code class="language-plaintext highlighter-rouge">long</code>型的范围，会抛出<code class="language-plaintext highlighter-rouge">ArithmeticException</code>。</p><p><code class="language-plaintext highlighter-rouge">BigInteger</code>和<code class="language-plaintext highlighter-rouge">Integer</code>、<code class="language-plaintext highlighter-rouge">Long</code>一样，也是不可变类，并且也继承自<code class="language-plaintext highlighter-rouge">Number</code>类。因为<code class="language-plaintext highlighter-rouge">Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code class="language-plaintext highlighter-rouge">byte</code>：<code class="language-plaintext highlighter-rouge">byteValue()</code></li><li>转换为<code class="language-plaintext highlighter-rouge">short</code>：<code class="language-plaintext highlighter-rouge">shortValue()</code></li><li>转换为<code class="language-plaintext highlighter-rouge">int</code>：<code class="language-plaintext highlighter-rouge">intValue()</code></li><li>转换为<code class="language-plaintext highlighter-rouge">long</code>：<code class="language-plaintext highlighter-rouge">longValue()</code></li><li>转换为<code class="language-plaintext highlighter-rouge">float</code>：<code class="language-plaintext highlighter-rouge">floatValue()</code></li><li>转换为<code class="language-plaintext highlighter-rouge">double</code>：<code class="language-plaintext highlighter-rouge">doubleValue()</code></li></ul><p>通过上述方法，可以把<code class="language-plaintext highlighter-rouge">BigInteger</code>转换成基本类型。</p><p>如果<code class="language-plaintext highlighter-rouge">BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。</p><p>如果需要<strong>准确</strong>地转换成基本类型，可以使用<code class="language-plaintext highlighter-rouge">intValueExact()</code>、<code class="language-plaintext highlighter-rouge">longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code class="language-plaintext highlighter-rouge">ArithmeticException</code>异常。</p><p><code class="language-plaintext highlighter-rouge">BigInteger</code>转换基本类型，为什么没有<code class="language-plaintext highlighter-rouge">floatValueExact()</code>方法。</p><p><code class="language-plaintext highlighter-rouge">BigInteger</code>是一个整数类型，而浮点数类型包括<code class="language-plaintext highlighter-rouge">float</code>和<code class="language-plaintext highlighter-rouge">double</code>。因为浮点数类型是具有小数点的，所以在进行类型转换时可能发生<strong>精度损失</strong>或<strong>溢出</strong>等情况。因此，<code class="language-plaintext highlighter-rouge">BigInteger</code>类没有提供<code class="language-plaintext highlighter-rouge">floatValueExact()</code>方法，以避免精度损失问题。</p><h2 id="bigdecimal">BigDecimal</h2><p>和<code class="language-plaintext highlighter-rouge">BigInteger</code>类似，<code class="language-plaintext highlighter-rouge">BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">bd</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.4567"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bd</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="n">bd</span><span class="o">));</span> <span class="c1">// 15241.55677489</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">BigDecimal</code>用<code class="language-plaintext highlighter-rouge">scale()</code>表示小数位数，例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.45"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.4500"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"1234500"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d1</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// 2,两位小数</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d2</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// 4</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d3</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// 0</span>
</code></pre></div></div><p>通过<code class="language-plaintext highlighter-rouge">BigDecimal</code>的<code class="language-plaintext highlighter-rouge">stripTrailingZeros()</code>方法，可以将一个<code class="language-plaintext highlighter-rouge">BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code class="language-plaintext highlighter-rouge">BigDecimal</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.4500"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="na">stripTrailingZeros</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d1</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// 4</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d2</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// 2,因为去掉了00</span>
<span class="nc">BigDecimal</span> <span class="n">d3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"1234500"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d4</span> <span class="o">=</span> <span class="n">d3</span><span class="o">.</span><span class="na">stripTrailingZeros</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d3</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// 0</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d4</span><span class="o">.</span><span class="na">scale</span><span class="o">());</span> <span class="c1">// -2</span>
</code></pre></div></div><p>如果一个<code class="language-plaintext highlighter-rouge">BigDecimal</code>的<code class="language-plaintext highlighter-rouge">scale()</code>返回<strong>负数</strong>，例如，<code class="language-plaintext highlighter-rouge">-2</code>，表示这个数是个整数，并且末尾有2个0。</p><p>可以对一个<code class="language-plaintext highlighter-rouge">BigDecimal</code>设置它的<code class="language-plaintext highlighter-rouge">scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.456789"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="na">setScale</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">RoundingMode</span><span class="o">.</span><span class="na">HALF_UP</span><span class="o">);</span> <span class="c1">// 四舍五入，123.4568</span>
<span class="nc">BigDecimal</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="na">setScale</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">RoundingMode</span><span class="o">.</span><span class="na">DOWN</span><span class="o">);</span> <span class="c1">// 直接截断，123.4567</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d2</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d3</span><span class="o">);</span>
</code></pre></div></div><p>对<code class="language-plaintext highlighter-rouge">BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.456"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"23.456789"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="na">divide</span><span class="o">(</span><span class="n">d2</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="nc">RoundingMode</span><span class="o">.</span><span class="na">HALF_UP</span><span class="o">);</span> <span class="c1">// 保留10位小数并四舍五入</span>
<span class="nc">BigDecimal</span> <span class="n">d4</span> <span class="o">=</span> <span class="n">d1</span><span class="o">.</span><span class="na">divide</span><span class="o">(</span><span class="n">d2</span><span class="o">);</span> <span class="c1">// 报错：ArithmeticException，因为除不尽</span>
</code></pre></div></div><p>还可以对<code class="language-plaintext highlighter-rouge">BigDecimal</code>做除法的同时求余数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"12.345"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"0.12"</span><span class="o">);</span>
<span class="nc">BigDecimal</span><span class="o">[]</span> <span class="n">dr</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">divideAndRemainder</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dr</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span> <span class="c1">// 102</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dr</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span> <span class="c1">// 0.105</span>
</code></pre></div></div><p>调用<code class="language-plaintext highlighter-rouge">divideAndRemainder()</code>方法时，返回的数组包含两个<code class="language-plaintext highlighter-rouge">BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。可以利用这个方法判断两个<code class="language-plaintext highlighter-rouge">BigDecimal</code>是否是整数倍数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"12.75"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"0.15"</span><span class="o">);</span>
<span class="nc">BigDecimal</span><span class="o">[]</span> <span class="n">dr</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">divideAndRemainder</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="n">dr</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="na">signum</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="c1">// n是m的整数倍</span>
<span class="o">}</span>
</code></pre></div></div><p><strong>比较BigDecimal</strong></p><p>在比较两个<code class="language-plaintext highlighter-rouge">BigDecimal</code>的值是否相等时，要特别注意，使用<code class="language-plaintext highlighter-rouge">equals()</code>方法不但要求两个<code class="language-plaintext highlighter-rouge">BigDecimal</code>的值相等，还要求它们的<code class="language-plaintext highlighter-rouge">scale()</code>相等：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">BigDecimal</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.456"</span><span class="o">);</span>
<span class="nc">BigDecimal</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BigDecimal</span><span class="o">(</span><span class="s">"123.45600"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">d2</span><span class="o">));</span> <span class="c1">// false,因为scale不同</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">d2</span><span class="o">.</span><span class="na">stripTrailingZeros</span><span class="o">()));</span> <span class="c1">// true,因为d2去除尾部0后scale变为3</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">d1</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">d2</span><span class="o">));</span> <span class="c1">// 0</span>
</code></pre></div></div><p>必须使用<code class="language-plaintext highlighter-rouge">compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code class="language-plaintext highlighter-rouge">0</code>，分别表示小于、大于和等于。</p><p>总是使用<code class="language-plaintext highlighter-rouge">compareTo()</code>比较两个<code class="language-plaintext highlighter-rouge">BigDecimal</code>的值，不要使用<code class="language-plaintext highlighter-rouge">equals()</code>！</p><p>如果查看<code class="language-plaintext highlighter-rouge">BigDecimal</code>的源码，可以发现，实际上一个<code class="language-plaintext highlighter-rouge">BigDecimal</code>是通过一个<code class="language-plaintext highlighter-rouge">BigInteger</code>和一个<code class="language-plaintext highlighter-rouge">scale</code>来表示的，即<code class="language-plaintext highlighter-rouge">BigInteger</code>表示一个完整的整数，而<code class="language-plaintext highlighter-rouge">scale</code>表示小数位数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BigDecimal</span> <span class="kd">extends</span> <span class="nc">Number</span> <span class="kd">implements</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">BigDecimal</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">BigInteger</span> <span class="n">intVal</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">scale</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">BigDecimal</code>也是从<code class="language-plaintext highlighter-rouge">Number</code>继承的，也是不可变对象。</p><p><code class="language-plaintext highlighter-rouge">BigDecimal</code>用于表示精确的小数，常用于<strong>财务计算</strong>；</p><h2 id="常用工具类">常用工具类</h2><h3 id="math">Math</h3><p>顾名思义，<code class="language-plaintext highlighter-rouge">Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p><p>求绝对值：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(-</span><span class="mi">100</span><span class="o">);</span> <span class="c1">// 100</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(-</span><span class="mf">7.8</span><span class="o">);</span> <span class="c1">// 7.8</span>
</code></pre></div></div><p>取最大或最小值：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">99</span><span class="o">);</span> <span class="c1">// 100</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mf">1.2</span><span class="o">,</span> <span class="mf">2.3</span><span class="o">);</span> <span class="c1">// 1.2</span>
</code></pre></div></div><p>计算x的y次方：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// 2的10次方=1024</span>
</code></pre></div></div><p>计算√x：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 1.414...</span>
</code></pre></div></div><p>计算e的x次方：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">exp</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 7.389...</span>
</code></pre></div></div><p>计算以e为底的对数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">log</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span> <span class="c1">// 1.386...</span>
</code></pre></div></div><p>计算以10为底的对数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">log10</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span> <span class="c1">// 2</span>
</code></pre></div></div><p>三角函数：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">sin</span><span class="o">(</span><span class="mf">3.14</span><span class="o">);</span> <span class="c1">// 0.00159...</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">cos</span><span class="o">(</span><span class="mf">3.14</span><span class="o">);</span> <span class="c1">// -0.9999...</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">tan</span><span class="o">(</span><span class="mf">3.14</span><span class="o">);</span> <span class="c1">// -0.0015...</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">asin</span><span class="o">(</span><span class="mf">1.0</span><span class="o">);</span> <span class="c1">// 1.57079...</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">acos</span><span class="o">(</span><span class="mf">1.0</span><span class="o">);</span> <span class="c1">// 0.0</span>
</code></pre></div></div><p>Math还提供了几个数学常量：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span><span class="o">;</span> <span class="c1">// 3.14159...</span>
<span class="kt">double</span> <span class="n">e</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">E</span><span class="o">;</span> <span class="c1">// 2.7182818...</span>
<span class="nc">Math</span><span class="o">.</span><span class="na">sin</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">PI</span> <span class="o">/</span> <span class="mi">6</span><span class="o">);</span> <span class="c1">// sin(π/6) = 0.5</span>
</code></pre></div></div><p>生成一个随机数x，x的范围是<code class="language-plaintext highlighter-rouge">0 &lt;= x &lt; 1</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">();</span> <span class="c1">// 0.53907... 每次都不一样</span>
</code></pre></div></div><p>如果我们要生成一个区间在<code class="language-plaintext highlighter-rouge">[MIN, MAX)</code>的随机数，可以借助<code class="language-plaintext highlighter-rouge">Math.random()</code>实现，计算如下：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">();</span> <span class="c1">// x的范围是[0,1)</span>
<span class="kt">double</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">double</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">50</span><span class="o">;</span>
<span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="o">(</span><span class="n">max</span> <span class="o">-</span> <span class="n">min</span><span class="o">)</span> <span class="o">+</span> <span class="n">min</span><span class="o">;</span> <span class="c1">// y的范围是[10,50)</span>
<span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="n">y</span><span class="o">;</span> <span class="c1">// n的范围是[10,50)的整数</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</code></pre></div></div><p>Java标准库还提供了一个<code class="language-plaintext highlighter-rouge">StrictMath</code>，它提供了和<code class="language-plaintext highlighter-rouge">Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code class="language-plaintext highlighter-rouge">StrictMath</code>保证所有平台计算结果都是完全相同的，而<code class="language-plaintext highlighter-rouge">Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code class="language-plaintext highlighter-rouge">Math</code>就足够了。</p><h3 id="hexformat">HexFormat</h3><p>需要<strong>JDK版本17</strong>，在处理<code class="language-plaintext highlighter-rouge">byte[]</code>数组时，我们经常需要与十六进制字符串转换，自己写起来比较麻烦，用Java标准库提供的<code class="language-plaintext highlighter-rouge">HexFormat</code>则可以方便地帮我们转换。</p><p>要将<code class="language-plaintext highlighter-rouge">byte[]</code>数组转换为十六进制字符串，可以用<code class="language-plaintext highlighter-rouge">formatHex()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">();</span>
<span class="nc">HexFormat</span> <span class="n">hf</span> <span class="o">=</span> <span class="nc">HexFormat</span><span class="o">.</span><span class="na">of</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">hexData</span> <span class="o">=</span> <span class="n">hf</span><span class="o">.</span><span class="na">formatHex</span><span class="o">(</span><span class="n">data</span><span class="o">);</span> <span class="c1">// 48656c6c6f</span>
</code></pre></div></div><p>如果要定制转换格式，则使用定制的<code class="language-plaintext highlighter-rouge">HexFormat</code>实例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 分隔符为空格，添加前缀0x，大写字母:</span>
<span class="nc">HexFormat</span> <span class="n">hf</span> <span class="o">=</span> <span class="nc">HexFormat</span><span class="o">.</span><span class="na">ofDelimiter</span><span class="o">(</span><span class="s">" "</span><span class="o">).</span><span class="na">withPrefix</span><span class="o">(</span><span class="s">"0x"</span><span class="o">).</span><span class="na">withUpperCase</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">hf</span><span class="o">.</span><span class="na">formatHex</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">.</span><span class="na">getBytes</span><span class="o">()));</span> <span class="c1">// 0x48 0x65 0x6C 0x6C 0x6F;</span>
</code></pre></div></div><p>从十六进制字符串到<code class="language-plaintext highlighter-rouge">byte[]</code>数组转换，使用<code class="language-plaintext highlighter-rouge">parseHex()</code>方法：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="o">[]</span> <span class="n">bs</span> <span class="o">=</span> <span class="nc">HexFormat</span><span class="o">.</span><span class="na">of</span><span class="o">().</span><span class="na">parseHex</span><span class="o">(</span><span class="s">"48656c6c6f"</span><span class="o">);</span>
</code></pre></div></div><h3 id="random">Random</h3><p><code class="language-plaintext highlighter-rouge">Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><p>要生成一个随机数，可以使用<code class="language-plaintext highlighter-rouge">nextInt()</code>、<code class="language-plaintext highlighter-rouge">nextLong()</code>、<code class="language-plaintext highlighter-rouge">nextFloat()</code>、<code class="language-plaintext highlighter-rouge">nextDouble()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Random</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">();</span>
<span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span> <span class="c1">// 2071575453,每次都不一样</span>
<span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <span class="c1">// 5,生成一个[0,10)之间的int</span>
<span class="n">r</span><span class="o">.</span><span class="na">nextLong</span><span class="o">();</span> <span class="c1">// 8811649292570369305,每次都不一样</span>
<span class="n">r</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">();</span> <span class="c1">// 0.54335...生成一个[0,1)之间的float</span>
<span class="n">r</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span> <span class="c1">// 0.3716...生成一个[0,1)之间的double</span>
</code></pre></div></div><p>每次运行程序，生成的随机数都是不同的，这是因为我们创建<code class="language-plaintext highlighter-rouge">Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建<code class="language-plaintext highlighter-rouge">Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Random</span> <span class="n">r</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">12345</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">r</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
<span class="o">}</span>
<span class="c1">// 51, 80, 41, 28, 55...</span>
</code></pre></div></div><p>前面我们使用的<code class="language-plaintext highlighter-rouge">Math.random()</code>实际上内部调用了<code class="language-plaintext highlighter-rouge">Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p><h3 id="securerandom">SecureRandom</h3><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code class="language-plaintext highlighter-rouge">SecureRandom</code>就是用来创建安全的随机数的：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SecureRandom</span> <span class="n">sr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sr</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code class="language-plaintext highlighter-rouge">SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.SecureRandom</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.security.NoSuchAlgorithmException</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SecureRandom</span> <span class="n">sr</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">sr</span> <span class="o">=</span> <span class="nc">SecureRandom</span><span class="o">.</span><span class="na">getInstanceStrong</span><span class="o">();</span> <span class="c1">// 获取高强度安全随机数生成器</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">NoSuchAlgorithmException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">sr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecureRandom</span><span class="o">();</span> <span class="c1">// 获取普通的安全随机数生成器</span>
        <span class="o">}</span>
        <span class="kt">byte</span><span class="o">[]</span> <span class="n">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">16</span><span class="o">];</span>
        <span class="n">sr</span><span class="o">.</span><span class="na">nextBytes</span><span class="o">(</span><span class="n">buffer</span><span class="o">);</span> <span class="c1">// 用安全随机数填充buffer</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">buffer</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p><p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code class="language-plaintext highlighter-rouge">SecureRandom</code>来产生安全的随机数。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="" target="_blank">acteds</a></li><li>本文链接：<a href="/2020/05/26/Java%E7%AC%94%E8%AE%B0/" target="_blank">https://acteds.github.io/2020/05/26/Java%E7%AC%94%E8%AE%B0/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"> <script src="https://beaudar.lipk.org/client.js" repo="mzlogin/blog-comments" issue-term="title" label="gitment" theme="github-light" comment-order="desc" input-position="top" crossorigin="anonymous" async> </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: '/assets/search_data.json?v=1724847190', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2024 <span title="acteds">acteds</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/acteds/acteds.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="/" title="首页" target="">首页</a></li><li> <a href="/categories/" title="分类" target="">分类</a></li><li> <a href="/wiki/" title="维基" target="">维基</a></li><li> <a href="/about/" title="关于" target="">关于</a></li><li><a href="/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
